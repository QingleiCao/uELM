diff --git a/cime b/cime
index 65c5dff1eb..b0ada2143d 160000
--- a/cime
+++ b/cime
@@ -1 +1 @@
-Subproject commit 65c5dff1ebd65ab6de14fac9c7244ba626a56247
+Subproject commit b0ada2143def2bfc5f6d42941486d8264a52628a
diff --git a/cime_config/machines/Depends.ascent.cmake b/cime_config/machines/Depends.ascent.cmake
new file mode 100644
index 0000000000..e8b674138e
--- /dev/null
+++ b/cime_config/machines/Depends.ascent.cmake
@@ -0,0 +1,7 @@
+list(APPEND NOOPT_FILES
+  eam/src/dynamics/eul/dyn_comp.F90
+  eam/src/dynamics/fv/dyn_comp.F90
+  eam/src/dynamics/se/dyn_comp.F90
+  eam/src/dynamics/sld/dyn_comp.F90
+  eam/src/physics/cam/microp_aero.F90)
+
diff --git a/cime_config/machines/Depends.chrysalis.intel.cmake b/cime_config/machines/Depends.chrysalis.intel.cmake
new file mode 100644
index 0000000000..a59f2b3c64
--- /dev/null
+++ b/cime_config/machines/Depends.chrysalis.intel.cmake
@@ -0,0 +1,12 @@
+# Reduce optimization on files with long compile times
+set(O2MODELSRC
+  eam/src/physics/cam/micro_mg_cam.F90      # ~2027 seconds
+  elm/src/data_types/VegetationDataType.F90 # ~ 930 seconds
+)
+if (NOT DEBUG)
+  foreach(ITEM IN LISTS O2MODELSRC)
+    e3sm_remove_flags("${ITEM}" "-O3")
+    e3sm_add_flags("${ITEM}" "-O2")
+  endforeach()
+endif()
+
diff --git a/cime_config/machines/Depends.cray.cmake b/cime_config/machines/Depends.cray.cmake
new file mode 100644
index 0000000000..17168db6d8
--- /dev/null
+++ b/cime_config/machines/Depends.cray.cmake
@@ -0,0 +1,16 @@
+list(APPEND NOOPT_FILES cice/src/mpi/ice_boundary.F90 cice/src/serial/ice_boundary.F90 cice/src/source/ice_domain.F90 eam/src/physics/cam/gw_common.F90)
+
+set(O0MODELSRC
+  eam/src/chemistry/aerosol/dust_sediment_mod.F90
+  eam/src/chemistry/modal_aero/modal_aero_convproc.F90
+  eam/src/chemistry/utils/modal_aero_calcsize.F90
+  eam/src/physics/cam/zm_conv.F90)
+
+if (NOT DEBUG)
+  foreach(ITEM IN LISTS O0MODELSRC)
+    e3sm_remove_flags("${ITEM}" "-O1")
+    e3sm_add_flags("${ITEM}" "-O0 -vector0")
+  endforeach()
+
+endif()
+
diff --git a/cime_config/machines/Depends.gnu.cmake b/cime_config/machines/Depends.gnu.cmake
new file mode 100644
index 0000000000..f55fca3955
--- /dev/null
+++ b/cime_config/machines/Depends.gnu.cmake
@@ -0,0 +1,14 @@
+e3sm_add_flags("eam/src/dynamics/fv/geopk.F90" "-fcray-pointer")
+
+list(APPEND MPAS_ICE_SHORTWAVE
+  ${CMAKE_BINARY_DIR}/core_seaice/column/ice_shortwave.f90
+)
+
+# For optimized GNU builds that use v9 or higher, remove an optimization on one file
+if (NOT DEBUG)
+  if (CMAKE_Fortran_COMPILER_VERSION VERSION_GREATER_EQUAL 9)
+    foreach(ITEM IN LISTS MPAS_ICE_SHORTWAVE)
+      e3sm_add_flags("${ITEM}" "-fno-tree-pta") # avoids an error that shows up in solver with gnu9 and higher
+    endforeach()
+  endif()
+endif()
diff --git a/cime_config/machines/Depends.ibm.cmake b/cime_config/machines/Depends.ibm.cmake
new file mode 100644
index 0000000000..81178b1293
--- /dev/null
+++ b/cime_config/machines/Depends.ibm.cmake
@@ -0,0 +1,68 @@
+# These routines have problems with stacksize when omp is invoked add -qsmallstack to resolve
+set(SSOBJS
+  eam/src/chemistry/mozart/mo_sethet.F90
+  eam/src/chemistry/mozart/mo_drydep.F90)
+
+foreach(ITEM IN LISTS SSOBJS)
+  e3sm_add_flags("${ITEM}" "-qsmallstack")
+endforeach()
+
+# These routines benefit from -qnostrict without violating the bfb test
+set(PERFOBJS
+  homme/src/share/prim_advection_base.F90
+  homme/src/share/vertremap_base.F90
+  homme/src/share/edge_mod_base.F90
+  homme/src/share/derivative_mod_base.F90
+  homme/src/share/bndry_mod_base.F90
+  homme/src/theta-l/share/prim_advance_mod.F90
+  homme/src/preqx/share/prim_advance_mod.F90
+  eam/src/physics/cam/uwshcu.F90
+  eam/src/chemistry/aerosol/wetdep.F90)
+
+#Model crashes if these files are compiled with O3(default) optimizations
+set(REDUCEOPT
+  eam/src/chemistry/bulk_aero/seasalt_model.F90
+  eam/src/chemistry/modal_aero/seasalt_model.F90
+  eam/src/chemistry/mozart/linoz_data.F90)
+
+set(NOINLINE
+  eam/src/physics/clubb/advance_xm_wpxp_module.F90
+  eam/src/physics/clubb/advance_wp2_wp3_module.F90)
+
+foreach(ITEM IN LISTS NOINLINE)
+  e3sm_add_flags("${ITEM}" "-Q!")
+endforeach()
+
+if (NOT DEBUG)
+  foreach(ITEM IN LISTS PERFOBJS)
+    e3sm_add_flags("${ITEM}" "-qnostrict")
+  endforeach()
+
+  foreach(ITEM IN LISTS REDUCEOPT)
+    e3sm_add_flags("${ITEM}" "-O2")
+  endforeach()
+
+endif()
+
+# These files take long time to compile with default optimization flags.
+# Reducing optimization gives <1min build-times and little impact on model run time.
+list(APPEND NOOPT_FILES ${CMAKE_CURRENT_BINARY_DIR}/buffer.F90)
+
+# xlf2008_r: qsmp and O0 are incompatible. Option O0 is ignored.
+set(NOQSMP
+  ${CMAKE_CURRENT_BINARY_DIR}/buffer.F90
+  eam/src/dynamics/eul/dyn_comp.F90
+  eam/src/dynamics/fv/dyn_comp.F90
+  eam/src/dynamics/se/dyn_comp.F90
+  eam/src/dynamics/sld/dyn_comp.F90
+  eam/src/physics/cam/microp_aero.F90
+
+  # These take >28min with -qsmp
+  eam/src/physics/rrtmg/ext/rrtmg_lw/rrtmg_lw_k_g.f90
+  eam/src/physics/rrtmg/ext/rrtmg_sw/rrtmg_sw_k_g.f90
+)
+if (compile_threaded)
+  foreach(ITEM IN LISTS NOQSMP)
+    e3sm_add_flags("${ITEM}" "-qnosmp")
+  endforeach()
+endif()
diff --git a/cime_config/machines/Depends.ibmgpu.cmake b/cime_config/machines/Depends.ibmgpu.cmake
new file mode 100644
index 0000000000..c5a0133d1c
--- /dev/null
+++ b/cime_config/machines/Depends.ibmgpu.cmake
@@ -0,0 +1,157 @@
+# These routines have problems with stacksize when omp is invoked add -qsmallstack to resolve
+set(SSOBJS
+  eam/src/chemistry/mozart/mo_sethet.F90
+  eam/src/chemistry/mozart/mo_drydep.F90)
+
+foreach(ITEM IN LISTS SSOBJS)
+  e3sm_add_flags("${ITEM}" "-qsmallstack")
+endforeach()
+
+# These routines benefit from -qnostrict without violating the bfb test
+set(PERFOBJS
+  homme/src/share/prim_advection_base.F90
+  homme/src/share/vertremap_base.F90
+  homme/src/share/edge_mod_base.F90
+  homme/src/share/derivative_mod_base.F90
+  homme/src/share/bndry_mod_base.F90
+  homme/src/theta-l/share/prim_advance_mod.F90
+  homme/src/preqx/share/prim_advance_mod.F90
+  eam/src/physics/cam/uwshcu.F90
+  eam/src/chemistry/aerosol/wetdep.F90)
+
+#Model crashes if these files are compiled with O3(default) optimizations
+set(REDUCEOPT
+  eam/src/chemistry/bulk_aero/seasalt_model.F90
+  eam/src/chemistry/modal_aero/seasalt_model.F90
+  eam/src/chemistry/mozart/linoz_data.F90)
+
+set(NOINLINE
+  eam/src/physics/clubb/advance_xm_wpxp_module.F90
+  eam/src/physics/clubb/advance_wp2_wp3_module.F90)
+
+foreach(ITEM IN LISTS NOINLINE)
+  e3sm_add_flags("${ITEM}" "-Q!")
+endforeach()
+
+if (NOT DEBUG)
+  foreach(ITEM IN LISTS PERFOBJS)
+    e3sm_add_flags("${ITEM}" "-qnostrict")
+  endforeach()
+
+  foreach(ITEM IN LISTS REDUCEOPT)
+    e3sm_add_flags("${ITEM}" "-O2")
+  endforeach()
+
+endif()
+
+# These files take long time to compile with default optimization flags.
+# Reducing optimization gives <1min build-times and little impact on model run time.
+list(APPEND NOOPT_FILES ${CMAKE_CURRENT_BINARY_DIR}/buffer.F90)
+
+# xlf2008_r: qsmp and O0 are incompatible. Option O0 is ignored.
+set(NOQSMP
+  ${CMAKE_CURRENT_BINARY_DIR}/buffer.F90
+  eam/src/dynamics/eul/dyn_comp.F90
+  eam/src/dynamics/fv/dyn_comp.F90
+  eam/src/dynamics/se/dyn_comp.F90
+  eam/src/dynamics/sld/dyn_comp.F90
+  eam/src/physics/cam/microp_aero.F90
+
+  # These take >28min with -qsmp
+  eam/src/physics/rrtmg/ext/rrtmg_lw/rrtmg_lw_k_g.f90
+  eam/src/physics/rrtmg/ext/rrtmg_sw/rrtmg_sw_k_g.f90
+)
+if (compile_threaded)
+  foreach(ITEM IN LISTS NOQSMP)
+    e3sm_add_flags("${ITEM}" "-qnosmp")
+  endforeach()
+endif()
+
+set(CPPDEFS "${CPPDEFS} -DMPAS_OPENMP_OFFLOAD")
+list(APPEND MPAS_ADD_ACC_FLAGS
+  ${CMAKE_BINARY_DIR}/core_seaice/shared/mpas_seaice_mesh_pool.f90
+  ${CMAKE_BINARY_DIR}/core_seaice/shared/mpas_seaice_velocity_solver_variational.f90
+  ${CMAKE_BINARY_DIR}/core_seaice/shared/mpas_seaice_velocity_solver.f90
+)
+
+set(FILES_NEED_OPENMP_FLAGS
+  eam/src/physics/crm/samomp/ADV_MPDATA/advect_scalar.F90
+  eam/src/physics/crm/samomp/ADV_MPDATA/advect_scalar2D.F90
+  eam/src/physics/crm/samomp/ADV_MPDATA/advect_scalar3D.F90
+  eam/src/physics/crm/samomp/ADV_MPDATA/advection.F90
+  eam/src/physics/crm/samomp/accelerate_crm.F90
+  eam/src/physics/crm/samomp/adams.F90
+  eam/src/physics/crm/samomp/MICRO_SAM1MOM/cloud.F90
+  eam/src/physics/crm/samomp/MICRO_SAM1MOM/micro_params.F90
+  eam/src/physics/crm/samomp/MICRO_SAM1MOM/microphysics.F90
+  eam/src/physics/crm/samomp/MICRO_SAM1MOM/precip_init.F90
+  eam/src/physics/crm/samomp/MICRO_SAM1MOM/precip_proc.F90
+  eam/src/physics/crm/samomp/advect2_mom_xy.F90
+  eam/src/physics/crm/samomp/SGS_TKE/diffuse_mom.F90
+  eam/src/physics/crm/samomp/SGS_TKE/diffuse_mom2D.F90
+  eam/src/physics/crm/samomp/SGS_TKE/diffuse_mom3D.F90
+  eam/src/physics/crm/samomp/SGS_TKE/diffuse_scalar.F90
+  eam/src/physics/crm/samomp/SGS_TKE/diffuse_scalar2D.F90
+  eam/src/physics/crm/samomp/SGS_TKE/diffuse_scalar3D.F90
+  eam/src/physics/crm/samomp/SGS_TKE/sgs.F90
+  eam/src/physics/crm/samomp/SGS_TKE/shear_prod2D.F90
+  eam/src/physics/crm/samomp/SGS_TKE/shear_prod3D.F90
+  eam/src/physics/crm/samomp/SGS_TKE/tke_full.F90
+  eam/src/physics/crm/samomp/abcoefs.F90
+  eam/src/physics/crm/samomp/advect2_mom_z.F90
+  eam/src/physics/crm/samomp/advect_all_scalars.F90
+  eam/src/physics/crm/samomp/buoyancy.F90
+  eam/src/physics/crm/samomp/crm_module.F90
+  eam/src/physics/crm/samomp/advect_mom.F90
+  eam/src/physics/crm/samomp/atmosphere.F90
+  eam/src/physics/crm/samomp/bound_duvdt.F90
+  eam/src/physics/crm/samomp/bound_exchange.F90
+  eam/src/physics/crm/samomp/boundaries.F90
+  eam/src/physics/crm/samomp/coriolis.F90
+  eam/src/physics/crm/samomp/crmtracers.F90
+  eam/src/physics/crm/crm_ecpp_output_module.F90
+  eam/src/physics/crm/crm_input_module.F90
+  eam/src/physics/crm/samomp/crm_surface.F90
+  eam/src/physics/crm/crm_output_module.F90
+  eam/src/physics/crm/crm_rad_module.F90
+  eam/src/physics/crm/crm_state_module.F90
+  eam/src/physics/crm/samomp/damping.F90
+  eam/src/physics/crm/samomp/grid.F90
+  eam/src/physics/crm/samomp/diagnose.F90
+  eam/src/physics/crm/samomp/params.F90
+  eam/src/physics/crm/samomp/dmdf.F90
+  eam/src/physics/crm/samomp/domain.F90
+  eam/src/physics/crm/ecppvars.F90
+  eam/src/physics/crm/samomp/fft.F90
+  eam/src/physics/crm/samomp/fftpack5.F90
+  eam/src/physics/crm/samomp/fftpack5_1d.F90
+  eam/src/physics/crm/samomp/forcing.F90
+  eam/src/physics/crm/samomp/ice_fall.F90
+  eam/src/physics/crm/samomp/kurant.F90
+  eam/src/physics/crm/samomp/press_grad.F90
+  eam/src/physics/crm/samomp/module_ecpp_stats.F90
+  eam/src/physics/crm/samomp/setparm.F90
+  eam/src/physics/crm/samomp/module_ecpp_crm_driver.F90
+  eam/src/physics/crm/samomp/press_rhs.F90
+  eam/src/physics/crm/samomp/pressure.F90
+  eam/src/physics/crm/samomp/periodic.F90
+  eam/src/physics/crm/samomp/scalar_momentum.F90
+  eam/src/physics/crm/samomp/random.F90
+  eam/src/physics/crm/samomp/setperturb.F90
+  eam/src/physics/crm/samomp/task_init.F90
+  eam/src/physics/crm/samomp/task_util_NOMPI.F90
+  eam/src/physics/crm/samomp/utils.F90
+  eam/src/physics/crm/samomp/uvw.F90
+  eam/src/physics/crm/samomp/vars.F90
+  eam/src/physics/crm/samomp/zero.F90
+  eam/src/physics/crm/openacc_utils.F90
+  eam/src/physics/crm/samomp/sat.F90 )
+
+foreach(ITEM IN LISTS MPAS_ADD_ACC_FLAGS)
+  e3sm_add_flags("${ITEM}" "-qsmp -qoffload")
+endforeach()
+
+foreach(ITEM IN LISTS FILES_NEED_OPENMP_FLAGS)
+  e3sm_add_flags("${ITEM}" "-qsmp=omp -qoffload")
+endforeach()
+
diff --git a/cime_config/machines/Depends.intel.cmake b/cime_config/machines/Depends.intel.cmake
new file mode 100644
index 0000000000..a163401def
--- /dev/null
+++ b/cime_config/machines/Depends.intel.cmake
@@ -0,0 +1,19 @@
+set(PERFOBJS
+  homme/src/share/prim_advection_base.F90
+  homme/src/share/vertremap_base.F90
+  homme/src/share/edge_mod_base.F90
+  homme/src/share/derivative_mod_base.F90
+  homme/src/share/bndry_mod_base.F90
+  homme/src/theta-l/share/prim_advance_mod.F90
+  homme/src/preqx/share/prim_advance_mod.F90
+  homme/src/preqx/share/viscosity_preqx_base.F90
+  homme/src/share/viscosity_base.F90
+  homme/src/theta-l/share/viscosity_theta.F90
+  homme/src/theta-l/share/eos.F90
+  eam/src/physics/cam/uwshcu.F90)
+
+if (NOT DEBUG)
+  foreach(ITEM IN LISTS PERFOBJS)
+    e3sm_add_flags("${ITEM}" "-O3 -fp-model fast -no-prec-div")
+  endforeach()
+endif()
diff --git a/cime_config/machines/Depends.nag.cmake b/cime_config/machines/Depends.nag.cmake
new file mode 100644
index 0000000000..7313e675a5
--- /dev/null
+++ b/cime_config/machines/Depends.nag.cmake
@@ -0,0 +1 @@
+list(NOOPT_FILES APPEND eam/src/control/wrap_mpi.F90 eam/src/utils/fft99.F90)
diff --git a/cime_config/machines/Depends.oneapi-ifx.cmake b/cime_config/machines/Depends.oneapi-ifx.cmake
new file mode 100644
index 0000000000..0dd35e56bc
--- /dev/null
+++ b/cime_config/machines/Depends.oneapi-ifx.cmake
@@ -0,0 +1,14 @@
+
+set(CPPDEFS "${CPPDEFS} -DMPAS_OPENMP_OFFLOAD")
+list(APPEND MPAS_ADD_ACC_FLAGS
+  ${CMAKE_BINARY_DIR}/core_seaice/shared/mpas_seaice_mesh_pool.f90
+  ${CMAKE_BINARY_DIR}/core_seaice/shared/mpas_seaice_velocity_solver_variational.f90
+  ${CMAKE_BINARY_DIR}/core_seaice/shared/mpas_seaice_velocity_solver.f90
+)
+
+foreach(ITEM IN LISTS MPAS_ADD_ACC_FLAGS)
+  e3sm_add_flags("${ITEM}" "-fiopenmp -fopenmp-targets=spir64")
+endforeach()
+
+# compile mpas_seaice_core_interface.f90 with ifort, not ifx
+e3sm_add_flags("${CMAKE_BINARY_DIR}/core_seaice/model_forward/mpas_seaice_core_interface.f90" "-fc=ifort")
diff --git a/cime_config/machines/Depends.pgi.cmake b/cime_config/machines/Depends.pgi.cmake
new file mode 100644
index 0000000000..09aba440ff
--- /dev/null
+++ b/cime_config/machines/Depends.pgi.cmake
@@ -0,0 +1,14 @@
+# Files that cannot be compiled with -O2 without losing reproducibility
+set(O1MODELSRC
+  eam/src/chemistry/aerosol/dust_sediment_mod.F90
+  eam/src/chemistry/modal_aero/modal_aero_convproc.F90
+  eam/src/chemistry/utils/modal_aero_calcsize.F90
+  eam/src/physics/cam/zm_conv.F90)
+
+if (NOT DEBUG)
+  foreach(ITEM IN LISTS O1MODELSRC)
+    e3sm_remove_flags("${ITEM}" "-O2")
+    e3sm_add_flags("${ITEM}" "-O1 -Mnovect")
+  endforeach()
+
+endif()
diff --git a/cime_config/machines/Depends.pgigpu.cmake b/cime_config/machines/Depends.pgigpu.cmake
new file mode 100644
index 0000000000..3517a4d31e
--- /dev/null
+++ b/cime_config/machines/Depends.pgigpu.cmake
@@ -0,0 +1,135 @@
+list(APPEND NOOPT_FILES
+  eam/src/dynamics/eul/dyn_comp.F90
+  eam/src/dynamics/fv/dyn_comp.F90
+  eam/src/dynamics/se/dyn_comp.F90
+  eam/src/dynamics/sld/dyn_comp.F90
+  eam/src/physics/cam/microp_aero.F90)
+
+# Files that cannot be compiled with -O2 without losing reproducibility
+set(O1MODELSRC
+  eam/src/chemistry/aerosol/dust_sediment_mod.F90
+  eam/src/chemistry/modal_aero/modal_aero_convproc.F90
+  eam/src/chemistry/utils/modal_aero_calcsize.F90
+  eam/src/physics/cam/zm_conv.F90)
+if (NOT DEBUG)
+  foreach(ITEM IN LISTS O1MODELSRC)
+    e3sm_remove_flags("${ITEM}" "-O2")
+    e3sm_add_flags("${ITEM}" "-O1 -Mnovect")
+  endforeach()
+endif()
+
+set(FILES_NEED_OPENACC_FLAGS
+  eam/src/physics/crm/sam/ADV_MPDATA/advect_scalar.F90
+  eam/src/physics/crm/sam/ADV_MPDATA/advect_scalar2D.F90
+  eam/src/physics/crm/sam/ADV_MPDATA/advect_scalar3D.F90
+  eam/src/physics/crm/sam/ADV_MPDATA/advection.F90
+  eam/src/physics/crm/sam/accelerate_crm.F90
+  eam/src/physics/crm/sam/adams.F90
+  eam/src/physics/crm/sam/MICRO_SAM1MOM/cloud.F90
+  eam/src/physics/crm/sam/MICRO_SAM1MOM/micro_params.F90
+  eam/src/physics/crm/sam/MICRO_SAM1MOM/microphysics.F90
+  eam/src/physics/crm/sam/MICRO_SAM1MOM/precip_init.F90
+  eam/src/physics/crm/sam/MICRO_SAM1MOM/precip_proc.F90
+  eam/src/physics/crm/sam/advect2_mom_xy.F90
+  eam/src/physics/crm/sam/SGS_TKE/diffuse_mom.F90
+  eam/src/physics/crm/sam/SGS_TKE/diffuse_mom2D.F90
+  eam/src/physics/crm/sam/SGS_TKE/diffuse_mom3D.F90
+  eam/src/physics/crm/sam/SGS_TKE/diffuse_scalar.F90
+  eam/src/physics/crm/sam/SGS_TKE/diffuse_scalar2D.F90
+  eam/src/physics/crm/sam/SGS_TKE/diffuse_scalar3D.F90
+  eam/src/physics/crm/sam/SGS_TKE/sgs.F90
+  eam/src/physics/crm/sam/SGS_TKE/shear_prod2D.F90
+  eam/src/physics/crm/sam/SGS_TKE/shear_prod3D.F90
+  eam/src/physics/crm/sam/SGS_TKE/tke_full.F90
+  eam/src/physics/crm/sam/abcoefs.F90
+  eam/src/physics/crm/sam/advect2_mom_z.F90
+  eam/src/physics/crm/sam/advect_all_scalars.F90
+  eam/src/physics/crm/sam/buoyancy.F90
+  eam/src/physics/crm/sam/crm_module.F90
+  eam/src/physics/crm/sam/advect_mom.F90
+  eam/src/physics/crm/sam/atmosphere.F90
+  eam/src/physics/crm/sam/bound_duvdt.F90
+  eam/src/physics/crm/sam/bound_exchange.F90
+  eam/src/physics/crm/sam/boundaries.F90
+  eam/src/physics/crm/sam/coriolis.F90
+  eam/src/physics/crm/sam/crmtracers.F90
+  eam/src/physics/crm/crm_ecpp_output_module.F90
+  eam/src/physics/crm/crm_input_module.F90
+  eam/src/physics/crm/sam/crm_surface.F90
+  eam/src/physics/crm/crm_output_module.F90
+  eam/src/physics/crm/crm_rad_module.F90
+  eam/src/physics/crm/crm_state_module.F90
+  eam/src/physics/crm/sam/damping.F90
+  eam/src/physics/crm/sam/grid.F90
+  eam/src/physics/crm/sam/diagnose.F90
+  eam/src/physics/crm/sam/params.F90
+  eam/src/physics/crm/sam/dmdf.F90
+  eam/src/physics/crm/sam/domain.F90
+  eam/src/physics/crm/ecppvars.F90
+  eam/src/physics/crm/sam/fft.F90
+  eam/src/physics/crm/sam/fftpack5.F90
+  eam/src/physics/crm/sam/fftpack5_1d.F90
+  eam/src/physics/crm/sam/forcing.F90
+  eam/src/physics/crm/sam/ice_fall.F90
+  eam/src/physics/crm/sam/kurant.F90
+  eam/src/physics/crm/sam/press_grad.F90
+  eam/src/physics/crm/sam/module_ecpp_stats.F90
+  eam/src/physics/crm/sam/setparm.F90
+  eam/src/physics/crm/sam/module_ecpp_crm_driver.F90
+  eam/src/physics/crm/sam/press_rhs.F90
+  eam/src/physics/crm/sam/pressure.F90
+  eam/src/physics/crm/sam/periodic.F90
+  eam/src/physics/crm/sam/scalar_momentum.F90
+  eam/src/physics/crm/sam/random.F90
+  eam/src/physics/crm/sam/setperturb.F90
+  eam/src/physics/crm/sam/task_init.F90
+  eam/src/physics/crm/sam/task_util_NOMPI.F90
+  eam/src/physics/crm/sam/utils.F90
+  eam/src/physics/crm/sam/uvw.F90
+  eam/src/physics/crm/sam/vars.F90
+  eam/src/physics/crm/sam/zero.F90
+  eam/src/physics/crm/openacc_utils.F90
+  eam/src/physics/crm/sam/sat.F90 )
+
+# add accelerator/gpu flags for MPAS files
+set(CPPDEFS "${CPPDEFS} -DMPAS_OPENACC")
+list(APPEND MPAS_ADD_ACC_FLAGS
+  ${CMAKE_BINARY_DIR}/core_ocean/mode_forward/mpas_ocn_time_integration_si.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/mode_forward/mpas_ocn_time_integration_split.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_diagnostics.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_diagnostics_variables.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_equation_of_state_jm.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_equation_of_state_linear.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_equation_of_state_wright.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_mesh.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_surface_bulk_forcing.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_surface_land_ice_fluxes.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_tendency.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_tracer_advection_mono.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_tracer_advection_std.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vel_forcing_explicit_bottom_drag.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vel_forcing_surface_stress.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vel_hadv_coriolis.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vel_hmix_del2.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vel_hmix_del4.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vel_hmix_leith.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vel_pressure_grad.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vel_tidal_potential.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vel_vadv.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_vmix.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_tracer_advection_shared.f90
+  ${CMAKE_BINARY_DIR}/core_ocean/shared/mpas_ocn_tracer_advection_vert.f90
+  # seaice
+  ${CMAKE_BINARY_DIR}/core_seaice/shared/mpas_seaice_mesh_pool.f90
+  ${CMAKE_BINARY_DIR}/core_seaice/shared/mpas_seaice_velocity_solver_variational.f90
+  ${CMAKE_BINARY_DIR}/core_seaice/shared/mpas_seaice_velocity_solver.f90
+)
+
+foreach(ITEM IN LISTS FILES_NEED_OPENACC_FLAGS)
+  e3sm_add_flags("${ITEM}" "-Minline -acc -ta=tesla:ccall,fastmath,loadcache:L1,unroll,fma,managed,ptxinfo -Mcuda -Minfo=accel")
+endforeach()
+
+foreach(ITEM IN LISTS MPAS_ADD_ACC_FLAGS)
+  e3sm_add_flags("${ITEM}" "-acc -gpu=cc70,cc60,deepcopy -Minfo=accel")
+endforeach()
+
diff --git a/cime_config/machines/Depends.summit.cmake b/cime_config/machines/Depends.summit.cmake
new file mode 100644
index 0000000000..e8b674138e
--- /dev/null
+++ b/cime_config/machines/Depends.summit.cmake
@@ -0,0 +1,7 @@
+list(APPEND NOOPT_FILES
+  eam/src/dynamics/eul/dyn_comp.F90
+  eam/src/dynamics/fv/dyn_comp.F90
+  eam/src/dynamics/se/dyn_comp.F90
+  eam/src/dynamics/sld/dyn_comp.F90
+  eam/src/physics/cam/microp_aero.F90)
+
diff --git a/cime_config/machines/cmake_macros/cray_theta.cmake b/cime_config/machines/cmake_macros/cray_theta.cmake
index 54ba99a09c..a1681161cb 100644
--- a/cime_config/machines/cmake_macros/cray_theta.cmake
+++ b/cime_config/machines/cmake_macros/cray_theta.cmake
@@ -1,7 +1,5 @@
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O1")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O1")
 endif()
 if (COMP_NAME STREQUAL eam)
diff --git a/cime_config/machines/cmake_macros/gnu_ascent.cmake b/cime_config/machines/cmake_macros/gnu_ascent.cmake
index b8b8f36044..44d98eb880 100644
--- a/cime_config/machines/cmake_macros/gnu_ascent.cmake
+++ b/cime_config/machines/cmake_macros/gnu_ascent.cmake
@@ -1,7 +1,5 @@
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2")
 endif()
 if (COMP_NAME STREQUAL gptl)
@@ -14,14 +12,8 @@ if (NOT MPILIB STREQUAL mpi-serial)
   string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
 endif()
 string(APPEND CXX_LIBS " -lstdc++")
-set(MPICC "mpicc")
 set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
-set(SCC "gcc")
-set(SCXX "g++")
-set(SFC "gfortran")
 set(PIO_FILESYSTEM_HINTS "gpfs")
 set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
 set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
 set(PNETCDF_PATH "$ENV{PNETCDF_PATH}")
-set(SUPPORTS_CXX "TRUE")
diff --git a/cime_config/machines/cmake_macros/gnu_badger.cmake b/cime_config/machines/cmake_macros/gnu_badger.cmake
index 11a986f030..55439f8d6f 100644
--- a/cime_config/machines/cmake_macros/gnu_badger.cmake
+++ b/cime_config/machines/cmake_macros/gnu_badger.cmake
@@ -1,10 +1,5 @@
 set(PIO_FILESYSTEM_HINTS "lustre")
-set(MPICC "mpicc")
-set(MPIFC "mpif90")
 set(MPICXX "mpic++")
-set(SFC "gfortran")
-set(SCC "gcc")
-set(SCXX "g++")
 execute_process(COMMAND nc-config --libs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
 string(APPEND SLIBS " ${SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0}")
 execute_process(COMMAND nf-config --flibs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
diff --git a/cime_config/machines/cmake_macros/gnu_cades.cmake b/cime_config/machines/cmake_macros/gnu_cades.cmake
index 8855080770..ed34a30cb5 100644
--- a/cime_config/machines/cmake_macros/gnu_cades.cmake
+++ b/cime_config/machines/cmake_macros/gnu_cades.cmake
@@ -1,33 +1,8 @@
-if (compile_threaded)
-  string(APPEND CFLAGS " -fopenmp")
-endif()
-if (COMP_NAME STREQUAL cism)
-  string(APPEND CMAKE_OPTS " -D CISM_GNU=ON")
-endif()
-string(APPEND CPPDEFS " -DFORTRANUNDERSCORE -DNO_R16")
-set(CXX_LINKER "FORTRAN")
-string(APPEND FC_AUTO_R8 " -fdefault-real-8")
-string(APPEND FFLAGS " -O -fconvert=big-endian -ffree-line-length-none -ffixed-line-length-none -fno-range-check")
-if (compile_threaded)
-  string(APPEND FFLAGS " -fopenmp")
-endif()
-if (DEBUG)
-  string(APPEND FFLAGS " -g -Wall")
-endif()
-string(APPEND FIXEDFLAGS " -ffixed-form")
-string(APPEND FREEFLAGS " -ffree-form")
+string(APPEND FFLAGS " -O -fno-range-check")
 set(HDF5_PATH "/software/dev_tools/swtree/cs400_centos7.2_pe2016-08/hdf5-parallel/1.8.17/centos7.2_gnu5.3.0")
 set(NETCDF_PATH "/software/dev_tools/swtree/cs400_centos7.2_pe2016-08/netcdf-hdf5parallel/4.3.3.1/centos7.2_gnu5.3.0")
 set(PNETCDF_PATH "/software/dev_tools/swtree/cs400_centos7.2_pe2016-08/pnetcdf/1.9.0/centos7.2_gnu5.3.0")
 set(LAPACK_LIBDIR "/software/tools/compilers/intel_2017/mkl/lib/intel64")
-if (compile_threaded)
-  string(APPEND LDFLAGS " -fopenmp")
-endif()
 string(APPEND SLIBS " -L${NETCDF_PATH}/lib -Wl,-rpath=${NETCDF_PATH}/lib -lnetcdff -lnetcdf")
-set(MPICC "mpicc")
 set(MPICXX "mpic++")
-set(MPIFC "mpif90")
-set(SCC "gcc")
 set(SCXX "gcpp")
-set(SFC "gfortran")
-set(SUPPORTS_CXX "TRUE")
diff --git a/cime_config/machines/cmake_macros/gnu_cori-haswell.cmake b/cime_config/machines/cmake_macros/gnu_cori-haswell.cmake
index 044bd14490..5b43091851 100644
--- a/cime_config/machines/cmake_macros/gnu_cori-haswell.cmake
+++ b/cime_config/machines/cmake_macros/gnu_cori-haswell.cmake
@@ -1,7 +1,5 @@
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2")
 endif()
 string(APPEND CXX_LIBS " -lstdc++")
diff --git a/cime_config/machines/cmake_macros/gnu_cori-knl.cmake b/cime_config/machines/cmake_macros/gnu_cori-knl.cmake
index 044bd14490..5b43091851 100644
--- a/cime_config/machines/cmake_macros/gnu_cori-knl.cmake
+++ b/cime_config/machines/cmake_macros/gnu_cori-knl.cmake
@@ -1,7 +1,5 @@
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2")
 endif()
 string(APPEND CXX_LIBS " -lstdc++")
diff --git a/cime_config/machines/cmake_macros/gnu_eddi.cmake b/cime_config/machines/cmake_macros/gnu_eddi.cmake
index c532cd7c65..d0fbe69155 100644
--- a/cime_config/machines/cmake_macros/gnu_eddi.cmake
+++ b/cime_config/machines/cmake_macros/gnu_eddi.cmake
@@ -1,4 +1,3 @@
-set(SUPPORTS_CXX "TRUE")
 if (COMP_NAME STREQUAL gptl)
   string(APPEND CPPDEFS " -DHAVE_VPRINTF -DHAVE_GETTIMEOFDAY -DHAVE_BACKTRACE")
 endif()
@@ -7,12 +6,6 @@ if (NOT DEBUG)
   string(APPEND FFLAGS " -fno-unsafe-math-optimizations")
 endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -g -fbacktrace -fbounds-check -ffpe-trap=invalid,zero,overflow")
+  string(APPEND FFLAGS " -fbounds-check -ffpe-trap=invalid,zero,overflow")
 endif()
 string(APPEND SLIBS " -L$ENV{NETCDF_HOME}/lib/ -lnetcdff -lnetcdf -lcurl -llapack -lblas")
-if (MPILIB STREQUAL mpi-serial)
-  set(SCC "gcc")
-endif()
-if (MPILIB STREQUAL mpi-serial)
-  set(SFC "gfortran")
-endif()
diff --git a/cime_config/machines/cmake_macros/gnu_gcp.cmake b/cime_config/machines/cmake_macros/gnu_gcp.cmake
index 034d6a8e04..537fb69b4c 100644
--- a/cime_config/machines/cmake_macros/gnu_gcp.cmake
+++ b/cime_config/machines/cmake_macros/gnu_gcp.cmake
@@ -1,4 +1,3 @@
-set(SUPPORTS_CXX "TRUE")
 if (COMP_NAME STREQUAL gptl)
   string(APPEND CPPDEFS " -DHAVE_VPRINTF -DHAVE_GETTIMEOFDAY -DHAVE_BACKTRACE -DHAVE_SLASHPROC")
 endif()
@@ -7,11 +6,11 @@ if (NOT DEBUG)
   string(APPEND FFLAGS " -fno-unsafe-math-optimizations")
 endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -g -fbacktrace -fbounds-check -ffpe-trap=invalid,zero,overflow")
+  string(APPEND FFLAGS " -fbounds-check -ffpe-trap=invalid,zero,overflow")
 endif()
 string(APPEND SLIBS " -L$ENV{HDF5_PATH}/lib -lhdf5_fortran -lhdf5 -lhdf5_hl -lhdf5hl_fortran")
 string(APPEND SLIBS " -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff")
-string(APPEND SLIBS " -L$ENV{CURL_PATH}/lib -lcurl -lblas -llapack")
+string(APPEND SLIBS " -L$ENV{CURL_PATH}/lib -lcurl")
 string(APPEND SLIBS " -L$ENV{LAPACK_PATH}/lib64 -lblas -llapack")
 string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf")
 set(HDF5_PATH "$ENV{HDF5_PATH}")
diff --git a/cime_config/machines/cmake_macros/gnu_grizzly.cmake b/cime_config/machines/cmake_macros/gnu_grizzly.cmake
index 11a986f030..55439f8d6f 100644
--- a/cime_config/machines/cmake_macros/gnu_grizzly.cmake
+++ b/cime_config/machines/cmake_macros/gnu_grizzly.cmake
@@ -1,10 +1,5 @@
 set(PIO_FILESYSTEM_HINTS "lustre")
-set(MPICC "mpicc")
-set(MPIFC "mpif90")
 set(MPICXX "mpic++")
-set(SFC "gfortran")
-set(SCC "gcc")
-set(SCXX "g++")
 execute_process(COMMAND nc-config --libs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
 string(APPEND SLIBS " ${SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0}")
 execute_process(COMMAND nf-config --flibs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
diff --git a/cime_config/machines/cmake_macros/gnu_jlse.cmake b/cime_config/machines/cmake_macros/gnu_jlse.cmake
index 6ea2fec384..ad9a451236 100644
--- a/cime_config/machines/cmake_macros/gnu_jlse.cmake
+++ b/cime_config/machines/cmake_macros/gnu_jlse.cmake
@@ -1,8 +1,6 @@
 string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2")
 endif()
 execute_process(COMMAND $ENV{NETCDF_PATH}/bin/nf-config --flibs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
diff --git a/cime_config/machines/cmake_macros/gnu_modex.cmake b/cime_config/machines/cmake_macros/gnu_modex.cmake
index bec6c2421f..a498aa767f 100644
--- a/cime_config/machines/cmake_macros/gnu_modex.cmake
+++ b/cime_config/machines/cmake_macros/gnu_modex.cmake
@@ -1,4 +1,3 @@
-set(SUPPORTS_CXX "TRUE")
 if (COMP_NAME STREQUAL gptl)
   string(APPEND CPPDEFS " -DHAVE_VPRINTF -DHAVE_GETTIMEOFDAY -DHAVE_BACKTRACE")
 endif()
@@ -6,7 +5,7 @@ if (NOT DEBUG)
   string(APPEND FFLAGS " -fno-unsafe-math-optimizations")
 endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -g -fbacktrace -fbounds-check -ffpe-trap=invalid,zero,overflow")
+  string(APPEND FFLAGS " -fbounds-check -ffpe-trap=invalid,zero,overflow")
 endif()
 string(APPEND SLIBS " -L$ENV{HDF5_HOME}/lib -lhdf5_fortran -lhdf5 -lhdf5_hl -lhdf5hl_fortran")
 string(APPEND SLIBS " -L$ENV{NETCDF_PATH}/lib/ -lnetcdff -lnetcdf -lcurl -lblas -llapack")
diff --git a/cime_config/machines/cmake_macros/gnu_summit.cmake b/cime_config/machines/cmake_macros/gnu_summit.cmake
index fd5fef79f0..44d98eb880 100644
--- a/cime_config/machines/cmake_macros/gnu_summit.cmake
+++ b/cime_config/machines/cmake_macros/gnu_summit.cmake
@@ -1,12 +1,7 @@
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2")
 endif()
-if (DEBUG)
-  string(APPEND CXXFLAGS " -O0 -g")
-endif()
 if (COMP_NAME STREQUAL gptl)
   string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
 endif()
@@ -17,14 +12,8 @@ if (NOT MPILIB STREQUAL mpi-serial)
   string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
 endif()
 string(APPEND CXX_LIBS " -lstdc++")
-set(MPICC "mpicc")
 set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
-set(SCC "gcc")
-set(SCXX "g++")
-set(SFC "gfortran")
 set(PIO_FILESYSTEM_HINTS "gpfs")
 set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
 set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
 set(PNETCDF_PATH "$ENV{PNETCDF_PATH}")
-set(SUPPORTS_CXX "TRUE")
diff --git a/cime_config/machines/cmake_macros/gnugpu_ascent.cmake b/cime_config/machines/cmake_macros/gnugpu_ascent.cmake
index 447846809b..31a258d699 100644
--- a/cime_config/machines/cmake_macros/gnugpu_ascent.cmake
+++ b/cime_config/machines/cmake_macros/gnugpu_ascent.cmake
@@ -1,7 +1,5 @@
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2")
 endif()
 if (COMP_NAME STREQUAL gptl)
@@ -19,11 +17,5 @@ set(PIO_FILESYSTEM_HINTS "gpfs")
 set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
 set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
 set(PNETCDF_PATH "$ENV{PNETCDF_PATH}")
-set(SUPPORTS_CXX "TRUE")
-if (NOT DEBUG)
-  string(APPEND CUDA_FLAGS " -O3 -arch sm_70 --use_fast_math")
-endif()
-if (DEBUG)
-  string(APPEND CUDA_FLAGS " -O0 -g -arch sm_70")
-endif()
+string(APPEND CUDA_FLAGS " -O3 -arch sm_70 --use_fast_math")
 set(USE_CUDA "TRUE")
diff --git a/cime_config/machines/cmake_macros/gnugpu_summit.cmake b/cime_config/machines/cmake_macros/gnugpu_summit.cmake
index 7cbe263f0f..369a9e63ef 100644
--- a/cime_config/machines/cmake_macros/gnugpu_summit.cmake
+++ b/cime_config/machines/cmake_macros/gnugpu_summit.cmake
@@ -1,7 +1,5 @@
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2")
 endif()
 if (COMP_NAME STREQUAL gptl)
@@ -20,11 +18,5 @@ set(PIO_FILESYSTEM_HINTS "gpfs")
 set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
 set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
 set(PNETCDF_PATH "$ENV{PNETCDF_PATH}")
-set(SUPPORTS_CXX "TRUE")
-if (NOT DEBUG)
-  string(APPEND CUDA_FLAGS " -O3 -arch sm_70 --use_fast_math")
-endif()
-if (DEBUG)
-  string(APPEND CUDA_FLAGS " -O0 -g -arch sm_70")
-endif()
+string(APPEND CUDA_FLAGS " -O3 -arch sm_70 --use_fast_math")
 set(USE_CUDA "TRUE")
diff --git a/cime_config/machines/cmake_macros/ibmgpu_ascent.cmake b/cime_config/machines/cmake_macros/ibmgpu_ascent.cmake
index e55ce6b180..53a9f69b2c 100644
--- a/cime_config/machines/cmake_macros/ibmgpu_ascent.cmake
+++ b/cime_config/machines/cmake_macros/ibmgpu_ascent.cmake
@@ -1,73 +1,4 @@
-string(APPEND CFLAGS " -g -qfullpath -qmaxmem=-1 -qphsinfo")
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O3")
-endif()
-if (NOT DEBUG AND compile_threaded)
-  string(APPEND CFLAGS " -qsmp=omp")
-endif()
-if (DEBUG AND compile_threaded)
-  string(APPEND CFLAGS " -qsmp=omp:noopt")
-endif()
-string(APPEND CXXFLAGS " -g -qfullpath -qmaxmem=-1 -qphsinfo")
-if (NOT DEBUG)
-  string(APPEND CXXFLAGS " -O2")
-endif()
-if (NOT DEBUG AND compile_threaded)
-  string(APPEND CXXFLAGS " -qsmp=omp")
-endif()
-if (DEBUG AND compile_threaded)
-  string(APPEND CXXFLAGS " -qsmp=omp:noopt")
-endif()
-string(APPEND CPPDEFS " -DFORTRAN_SAME -DCPRIBM")
-if (COMP_NAME STREQUAL eam)
-  string(APPEND CPPDEFS " -DUSE_CBOOL")
-endif()
-string(APPEND CPPDEFS " -DLINUX")
-if (COMP_NAME STREQUAL gptl)
-  string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
-endif()
-set(CPRE "-WF,-D")
-string(APPEND FC_AUTO_R8 " -qrealsize=8")
-string(APPEND FFLAGS " -g -qfullpath -qmaxmem=-1 -qphsinfo")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -qstrict -Q")
-endif()
-if (NOT DEBUG AND compile_threaded)
-  string(APPEND FFLAGS " -qsmp=omp")
-endif()
-if (DEBUG AND compile_threaded)
-  string(APPEND FFLAGS " -qsmp=omp:noopt")
-endif()
 if (DEBUG)
   string(APPEND FFLAGS " -qinitauto=7FF7FFFF -qflttrap=ov:zero:inv:en")
 endif()
-string(APPEND FFLAGS " -qzerosize -qfree=f90 -qxlf2003=polymorphic")
-string(APPEND FFLAGS " -qspillsize=2500 -qextname=flush")
-if (COMP_NAME STREQUAL cice AND compile_threaded)
-  string(APPEND FFLAGS " -qsmp=omp:noopt")
-endif()
-string(APPEND FFLAGS_NOOPT " -O0")
-string(APPEND FIXEDFLAGS " -qsuffix=f=f -qfixed=132")
-string(APPEND FREEFLAGS " -qsuffix=f=f90:cpp=F90")
-set(HAS_F2008_CONTIGUOUS "TRUE")
-string(APPEND LDFLAGS " -Wl,--relax -Wl,--allow-multiple-definition")
-string(APPEND LDFLAGS " -qsmp -qoffload -lcudart -L$ENV{CUDA_DIR}/lib64")
-if (MPILIB STREQUAL mpi-serial)
-  string(APPEND SLIBS " -lxlopt -lxl -lxlsmp -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
-endif()
-if (NOT MPILIB STREQUAL mpi-serial)
-  string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -lxlopt -lxl -lxlsmp -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
-endif()
-string(APPEND CXX_LIBS " -L/sw/ascent/gcc/8.1.1/lib64 -lstdc++ -L$ENV{OLCF_XLC_ROOT}/lib -libmc++")
-set(MPICC "mpicc")
-set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
-set(PIO_FILESYSTEM_HINTS "gpfs")
-set(SCC "xlc_r")
-set(SFC "xlf90_r")
-set(SCXX "xlc++_r")
-set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
-set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
-set(PNETCDF_PATH "$ENV{PNETCDF_PATH}")
-set(SUPPORTS_CXX "TRUE")
-set(KOKKOS_OPTIONS "--arch=Power9 --with-serial")
+string(APPEND CXX_LIBS " -L/sw/ascent/gcc/8.1.1/lib64")
diff --git a/cime_config/machines/cmake_macros/ibmgpu_summit.cmake b/cime_config/machines/cmake_macros/ibmgpu_summit.cmake
index b5e6bf7e8e..e69de29bb2 100644
--- a/cime_config/machines/cmake_macros/ibmgpu_summit.cmake
+++ b/cime_config/machines/cmake_macros/ibmgpu_summit.cmake
@@ -1,70 +0,0 @@
-string(APPEND CFLAGS " -g -qfullpath -qmaxmem=-1 -qphsinfo")
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O3")
-endif()
-if (NOT DEBUG AND compile_threaded)
-  string(APPEND CFLAGS " -qsmp=omp")
-endif()
-if (DEBUG AND compile_threaded)
-  string(APPEND CFLAGS " -qsmp=omp:noopt")
-endif()
-string(APPEND CXXFLAGS " -g -qfullpath -qmaxmem=-1 -qphsinfo")
-if (NOT DEBUG)
-  string(APPEND CXXFLAGS " -O2")
-endif()
-if (NOT DEBUG AND compile_threaded)
-  string(APPEND CXXFLAGS " -qsmp=omp")
-endif()
-if (DEBUG AND compile_threaded)
-  string(APPEND CXXFLAGS " -qsmp=omp:noopt")
-endif()
-string(APPEND CPPDEFS " -DFORTRAN_SAME -DCPRIBM")
-if (COMP_NAME STREQUAL eam)
-  string(APPEND CPPDEFS " -DUSE_CBOOL")
-endif()
-string(APPEND CPPDEFS " -DLINUX")
-if (COMP_NAME STREQUAL gptl)
-  string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
-endif()
-set(CPRE "-WF,-D")
-string(APPEND FC_AUTO_R8 " -qrealsize=8")
-string(APPEND FFLAGS " -g -qfullpath -qmaxmem=-1 -qphsinfo")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -qstrict -Q")
-endif()
-if (NOT DEBUG AND compile_threaded)
-  string(APPEND FFLAGS " -qsmp=omp")
-endif()
-if (DEBUG AND compile_threaded)
-  string(APPEND FFLAGS " -qsmp=omp:noopt")
-endif()
-string(APPEND FFLAGS " -qzerosize -qfree=f90 -qxlf2003=polymorphic")
-string(APPEND FFLAGS " -qspillsize=2500 -qextname=flush")
-if (COMP_NAME STREQUAL cice AND compile_threaded)
-  string(APPEND FFLAGS " -qsmp=omp:noopt")
-endif()
-string(APPEND FFLAGS_NOOPT " -O0")
-string(APPEND FIXEDFLAGS " -qsuffix=f=f -qfixed=132")
-string(APPEND FREEFLAGS " -qsuffix=f=f90:cpp=F90")
-set(HAS_F2008_CONTIGUOUS "TRUE")
-string(APPEND LDFLAGS " -Wl,--relax -Wl,--allow-multiple-definition")
-string(APPEND LDFLAGS " -qsmp -qoffload -lcudart -L$ENV{CUDA_DIR}/lib64")
-if (MPILIB STREQUAL mpi-serial)
-  string(APPEND SLIBS " -lxlopt -lxl -lxlsmp -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
-endif()
-if (NOT MPILIB STREQUAL mpi-serial)
-  string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -lxlopt -lxl -lxlsmp -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
-endif()
-string(APPEND CXX_LIBS " -L/sw/summit/gcc/8.1.1/lib64 -lstdc++ -L$ENV{OLCF_XLC_ROOT}/lib -libmc++")
-set(MPICC "mpicc")
-set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
-set(PIO_FILESYSTEM_HINTS "gpfs")
-set(SCC "xlc_r")
-set(SFC "xlf90_r")
-set(SCXX "xlc++_r")
-set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
-set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
-set(PNETCDF_PATH "$ENV{PNETCDF_PATH}")
-set(SUPPORTS_CXX "TRUE")
-set(KOKKOS_OPTIONS "--arch=Power9 --with-serial")
diff --git a/cime_config/machines/cmake_macros/intel.cmake b/cime_config/machines/cmake_macros/intel.cmake
index 8e02e70633..5b6f8ed751 100644
--- a/cime_config/machines/cmake_macros/intel.cmake
+++ b/cime_config/machines/cmake_macros/intel.cmake
@@ -1,4 +1,4 @@
-string(APPEND CFLAGS " -O2 -fp-model precise -std=gnu99")
+string(APPEND CFLAGS " -fp-model precise -std=gnu99")
 if (compile_threaded)
   string(APPEND CFLAGS " -qopenmp")
 endif()
diff --git a/cime_config/machines/cmake_macros/intel_anvil.cmake b/cime_config/machines/cmake_macros/intel_anvil.cmake
index b10916dd7e..2f942af424 100644
--- a/cime_config/machines/cmake_macros/intel_anvil.cmake
+++ b/cime_config/machines/cmake_macros/intel_anvil.cmake
@@ -8,7 +8,7 @@ if (COMP_NAME STREQUAL gptl)
   string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
 endif()
 if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -debug minimal -qno-opt-dynamic-align")
+  string(APPEND FFLAGS " -qno-opt-dynamic-align")
 endif()
 execute_process(COMMAND $ENV{NETCDF_FORTRAN_PATH}/bin/nf-config --fflags OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
 string(APPEND FFLAGS " ${SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0}")
@@ -20,17 +20,11 @@ if (compile_threaded AND DEBUG)
 endif()
 if (compile_threaded)
   string(APPEND FFLAGS_NOOPT " -static-intel")
-endif()
-if (compile_threaded)
   string(APPEND LDFLAGS " -static-intel")
 endif()
 if (MPILIB STREQUAL impi)
   set(MPICC "mpiicc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPICXX "mpiicpc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPIFC "mpiifort")
 endif()
 set(PIO_FILESYSTEM_HINTS "gpfs")
diff --git a/cime_config/machines/cmake_macros/intel_badger.cmake b/cime_config/machines/cmake_macros/intel_badger.cmake
index 5fa2204339..8f7a2d0eea 100644
--- a/cime_config/machines/cmake_macros/intel_badger.cmake
+++ b/cime_config/machines/cmake_macros/intel_badger.cmake
@@ -1,25 +1,12 @@
 set(PIO_FILESYSTEM_HINTS "lustre")
 if (MPILIB STREQUAL impi)
   set(MPICC "mpiicc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPICXX "mpiicpc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPIFC "mpiifort")
 endif()
-if (NOT MPILIB STREQUAL impi)
-  set(MPICC "mpicc")
-endif()
 if (NOT MPILIB STREQUAL impi)
   set(MPICXX "mpic++")
 endif()
-if (NOT MPILIB STREQUAL impi)
-  set(MPIFC "mpif90")
-endif()
-set(SFC "ifort")
-set(SCC "icc")
-set(SCXX "icpc")
 execute_process(COMMAND $ENV{NETCDF_ROOT}/bin/nc-config --libs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
 string(APPEND SLIBS " ${SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0}")
 execute_process(COMMAND $ENV{NETCDF_ROOT}/bin/nf-config --flibs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
diff --git a/cime_config/machines/cmake_macros/intel_bebop.cmake b/cime_config/machines/cmake_macros/intel_bebop.cmake
index 23f214dcd7..7221c6f7b8 100644
--- a/cime_config/machines/cmake_macros/intel_bebop.cmake
+++ b/cime_config/machines/cmake_macros/intel_bebop.cmake
@@ -4,15 +4,11 @@ if (COMP_NAME STREQUAL gptl)
 endif()
 string(APPEND CXX_LIBS " -lstdc++")
 if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -debug minimal -qno-opt-dynamic-align")
+  string(APPEND FFLAGS " -qno-opt-dynamic-align")
 endif()
 if (MPILIB STREQUAL impi)
   set(MPICC "mpiicc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPICXX "mpiicpc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPIFC "mpiifort")
 endif()
 execute_process(COMMAND nf-config --flibs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
diff --git a/cime_config/machines/cmake_macros/intel_cascade.cmake b/cime_config/machines/cmake_macros/intel_cascade.cmake
index 69126268f6..ba947116b9 100644
--- a/cime_config/machines/cmake_macros/intel_cascade.cmake
+++ b/cime_config/machines/cmake_macros/intel_cascade.cmake
@@ -1,7 +1,7 @@
 string(APPEND CONFIG_ARGS " --enable-filesystem-hints=lustre")
 string(APPEND CPPDEFS " -DLINUX")
 if (DEBUG)
-  string(APPEND FFLAGS " -g -traceback  -O0 -fpe0 -check  all -check noarg_temp_created -ftrapuv")
+  string(APPEND FFLAGS " -check all -ftrapuv")
 endif()
 set(NETCDF_PATH "$ENV{NETCDF_HOME}")
 set(PIO_FILESYSTEM_HINTS "lustre")
diff --git a/cime_config/machines/cmake_macros/intel_chrysalis.cmake b/cime_config/machines/cmake_macros/intel_chrysalis.cmake
index 73f96f2cf7..0d9f3a32b8 100644
--- a/cime_config/machines/cmake_macros/intel_chrysalis.cmake
+++ b/cime_config/machines/cmake_macros/intel_chrysalis.cmake
@@ -26,10 +26,6 @@ set(PNETCDF_PATH "$ENV{PNETCDF_PATH}")
 string(APPEND LDFLAGS " -static-intel")
 if (MPILIB STREQUAL impi)
   set(MPICC "mpiicc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPICXX "mpiicpc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPIFC "mpiifort")
 endif()
diff --git a/cime_config/machines/cmake_macros/intel_compy.cmake b/cime_config/machines/cmake_macros/intel_compy.cmake
index fd386eeb4e..c21003ae44 100644
--- a/cime_config/machines/cmake_macros/intel_compy.cmake
+++ b/cime_config/machines/cmake_macros/intel_compy.cmake
@@ -1,15 +1,9 @@
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
 if (COMP_NAME STREQUAL gptl)
   string(APPEND CFLAGS " -DHAVE_SLASHPROC")
 endif()
 string(APPEND CPPDEFS " -DLINUX")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -g -traceback  -O0 -fpe0 -check  all -check noarg_temp_created -ftrapuv -init=snan")
+  string(APPEND FFLAGS " -check all -ftrapuv -init=snan")
 endif()
 set(NETCDF_PATH "$ENV{NETCDF_HOME}")
 set(PNETCDF_PATH "$ENV{PNETCDF_HOME}")
@@ -17,10 +11,6 @@ set(PIO_FILESYSTEM_HINTS "lustre")
 string(APPEND SLIBS " -lpmi -L${NETCDF_PATH}/lib -lnetcdf -lnetcdff -L$ENV{MKL_PATH}/lib/intel64/ -lmkl_rt $ENV{PNETCDF_LIBRARIES}")
 if (MPILIB STREQUAL impi)
   set(MPICC "mpiicc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPICXX "mpiicpc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPIFC "mpiifort")
 endif()
diff --git a/cime_config/machines/cmake_macros/intel_constance.cmake b/cime_config/machines/cmake_macros/intel_constance.cmake
index e0854ab766..431c1b93d6 100644
--- a/cime_config/machines/cmake_macros/intel_constance.cmake
+++ b/cime_config/machines/cmake_macros/intel_constance.cmake
@@ -1,12 +1,6 @@
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
 string(APPEND CPPDEFS " -DLINUX")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -g -traceback  -O0 -fpe0 -check  all -check noarg_temp_created -ftrapuv")
+  string(APPEND FFLAGS " -check all -ftrapuv")
 endif()
 set(NETCDF_PATH "$ENV{NETCDF_HOME}")
 set(PIO_FILESYSTEM_HINTS "lustre")
diff --git a/cime_config/machines/cmake_macros/intel_cori-haswell.cmake b/cime_config/machines/cmake_macros/intel_cori-haswell.cmake
index 89012b1f73..1745cc7a72 100644
--- a/cime_config/machines/cmake_macros/intel_cori-haswell.cmake
+++ b/cime_config/machines/cmake_macros/intel_cori-haswell.cmake
@@ -1,18 +1,8 @@
-set(ALBANY_PATH "/global/cfs/cdirs/e3sm/software/albany-trilinos/albany-install-2020-08-07")
-string(APPEND FFLAGS " -convert big_endian -assume byterecl -ftz -traceback -assume realloc_lhs -fp-model consistent -fimf-use-svml")
+string(APPEND FFLAGS " -fp-model consistent -fimf-use-svml")
 if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -debug minimal -qno-opt-dynamic-align")
-endif()
-string(APPEND CXXFLAGS " -std=c++14 -fp-model consistent")
-if (compile_threaded)
-  string(APPEND CXXFLAGS " -qopenmp")
-endif()
-if (DEBUG)
-  string(APPEND CXXFLAGS " -O0 -g")
-endif()
-if (NOT DEBUG)
-  string(APPEND CXXFLAGS " -O2")
+  string(APPEND FFLAGS " -qno-opt-dynamic-align")
 endif()
+string(APPEND CXXFLAGS " -fp-model consistent")
 set(PETSC_PATH "$ENV{PETSC_DIR}")
 set(SCC "icc")
 set(SCXX "icpc")
diff --git a/cime_config/machines/cmake_macros/intel_cori-knl.cmake b/cime_config/machines/cmake_macros/intel_cori-knl.cmake
index a82be9c82b..5701582922 100644
--- a/cime_config/machines/cmake_macros/intel_cori-knl.cmake
+++ b/cime_config/machines/cmake_macros/intel_cori-knl.cmake
@@ -1,37 +1,22 @@
-set(ALBANY_PATH "/global/homes/m/mperego/e3sm-software/albany-trilinos/albany-install-2021-01-05")
+set(ALBANY_PATH "/global/homes/m/mperego/e3sm-software/albany-trilinos/albany-install-2021-10-01")
 string(APPEND CONFIG_ARGS " --host=cray")
 if (MPILIB STREQUAL impi)
   string(APPEND CFLAGS " -axMIC-AVX512 -xCORE-AVX2")
 endif()
 string(APPEND CPPDEFS " -DARCH_MIC_KNL")
-string(APPEND FFLAGS " -convert big_endian -assume byterecl -ftz -traceback -assume realloc_lhs -fp-model consistent -fimf-use-svml")
+string(APPEND FFLAGS " -fp-model consistent -fimf-use-svml")
 if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -debug minimal -qno-opt-dynamic-align")
+  string(APPEND FFLAGS " -qno-opt-dynamic-align")
 endif()
 if (MPILIB STREQUAL impi)
   string(APPEND FFLAGS " -xMIC-AVX512")
 endif()
 string(APPEND FFLAGS " -DHAVE_ERF_INTRINSICS")
-string(APPEND CXXFLAGS " -std=c++14 -fp-model consistent")
-if (compile_threaded)
-  string(APPEND CXXFLAGS " -qopenmp")
-endif()
-if (DEBUG)
-  string(APPEND CXXFLAGS " -O0 -g")
-endif()
-if (NOT DEBUG)
-  string(APPEND CXXFLAGS " -O2")
-endif()
+string(APPEND CXXFLAGS " -fp-model consistent")
 if (MPILIB STREQUAL impi)
   set(MPICC "mpiicc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPICXX "mpiicpc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPIFC "mpiifort")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPI_LIB_NAME "impi")
 endif()
 set(PETSC_PATH "$ENV{PETSC_DIR}")
diff --git a/cime_config/machines/cmake_macros/intel_ghost.cmake b/cime_config/machines/cmake_macros/intel_ghost.cmake
index d000931ba7..3bf190ad60 100644
--- a/cime_config/machines/cmake_macros/intel_ghost.cmake
+++ b/cime_config/machines/cmake_macros/intel_ghost.cmake
@@ -1,11 +1,5 @@
 set(ALBANY_PATH "/projects/ccsm/AlbanyTrilinos_20190904/albany-build/install")
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
 set(ESMF_LIBDIR "/projects/ccsm/esmf-6.3.0rp1/lib/libO/Linux.intel.64.openmpi.default")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
 if (MPILIB STREQUAL openmpi)
   set(MPI_PATH "/opt/openmpi-1.8-intel")
 endif()
diff --git a/cime_config/machines/cmake_macros/intel_grizzly.cmake b/cime_config/machines/cmake_macros/intel_grizzly.cmake
index 5fa2204339..8f7a2d0eea 100644
--- a/cime_config/machines/cmake_macros/intel_grizzly.cmake
+++ b/cime_config/machines/cmake_macros/intel_grizzly.cmake
@@ -1,25 +1,12 @@
 set(PIO_FILESYSTEM_HINTS "lustre")
 if (MPILIB STREQUAL impi)
   set(MPICC "mpiicc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPICXX "mpiicpc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPIFC "mpiifort")
 endif()
-if (NOT MPILIB STREQUAL impi)
-  set(MPICC "mpicc")
-endif()
 if (NOT MPILIB STREQUAL impi)
   set(MPICXX "mpic++")
 endif()
-if (NOT MPILIB STREQUAL impi)
-  set(MPIFC "mpif90")
-endif()
-set(SFC "ifort")
-set(SCC "icc")
-set(SCXX "icpc")
 execute_process(COMMAND $ENV{NETCDF_ROOT}/bin/nc-config --libs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
 string(APPEND SLIBS " ${SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0}")
 execute_process(COMMAND $ENV{NETCDF_ROOT}/bin/nf-config --flibs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
diff --git a/cime_config/machines/cmake_macros/intel_itasca.cmake b/cime_config/machines/cmake_macros/intel_itasca.cmake
index 3fe4c1aaf5..e6838280e6 100644
--- a/cime_config/machines/cmake_macros/intel_itasca.cmake
+++ b/cime_config/machines/cmake_macros/intel_itasca.cmake
@@ -1,32 +1,13 @@
-string(APPEND CFLAGS " -O2 -fp-model precise -I/soft/intel/x86_64/2013/composer_xe_2013/composer_xe_2013_sp1.3.174/mkl/include")
+string(APPEND CFLAGS " -O2 -I/soft/intel/x86_64/2013/composer_xe_2013/composer_xe_2013_sp1.3.174/mkl/include")
 if (compile_threaded)
   string(APPEND CFLAGS " -openmp")
 endif()
-string(APPEND CPPDEFS " -DFORTRANUNDERSCORE -DNO_R16")
-string(APPEND CPPDEFS " -DCPRINTEL")
-string(APPEND CXX_LDFLAGS " -cxxlib")
-set(CXX_LINKER "FORTRAN")
-string(APPEND FC_AUTO_R8 " -r8")
-string(APPEND FFLAGS " -fp-model source -convert big_endian -assume byterecl -ftz -traceback -assume realloc_lhs -I/soft/intel/x86_64/2013/composer_xe_2013/composer_xe_2013_sp1.3.174/mkl/include")
+string(APPEND FFLAGS " -I/soft/intel/x86_64/2013/composer_xe_2013/composer_xe_2013_sp1.3.174/mkl/include")
 if (compile_threaded)
   string(APPEND FFLAGS " -openmp")
-endif()
-if (DEBUG)
-  string(APPEND FFLAGS " -O0 -g -check uninit -check bounds -check pointers -fpe0")
-endif()
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
-string(APPEND FIXEDFLAGS " -fixed -132")
-string(APPEND FREEFLAGS " -free")
-if (compile_threaded)
   string(APPEND LDFLAGS " -openmp")
 endif()
 set(MPICC "mpiicc")
 set(MPICXX "mpiicpc")
 set(MPIFC "mpiifort")
-set(SCC "icc")
-set(SCXX "icpc")
-set(SFC "ifort")
 string(APPEND SLIBS " -L/soft/netcdf/fortran-4.4-intel-sp1-update3-parallel/lib -lnetcdff -L/soft/hdf5/hdf5-1.8.13-intel-2013-sp1-update3-impi-5.0.0.028/lib -openmp -fPIC -lnetcdf -lnetcdf -L/soft/intel/x86_64/2013/composer_xe_2013/composer_xe_2013_sp1.3.174/mkl/lib/intel64 -lmkl_intel_lp64 -lmkl_core -lmkl_intel_thread -lpthread -lm")
-set(SUPPORTS_CXX "TRUE")
diff --git a/cime_config/machines/cmake_macros/intel_mappy.cmake b/cime_config/machines/cmake_macros/intel_mappy.cmake
index f891556116..64dd290052 100644
--- a/cime_config/machines/cmake_macros/intel_mappy.cmake
+++ b/cime_config/machines/cmake_macros/intel_mappy.cmake
@@ -2,13 +2,7 @@ set(ALBANY_PATH "/projects/install/rhel7-x86_64/ACME/AlbanyTrilinos/Albany/build
 if (COMP_NAME STREQUAL gptl)
   string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
 endif()
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
 string(APPEND CXX_LIBS " -lstdc++ -lmpi_cxx")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
 set(NETCDF_PATH "$ENV{NETCDFROOT}")
 set(PNETCDF_PATH "$ENV{PNETCDFROOT}")
 execute_process(COMMAND ${NETCDF_PATH}/bin/nf-config --flibs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
diff --git a/cime_config/machines/cmake_macros/intel_melvin.cmake b/cime_config/machines/cmake_macros/intel_melvin.cmake
index 6f345b0800..dd58c586d0 100644
--- a/cime_config/machines/cmake_macros/intel_melvin.cmake
+++ b/cime_config/machines/cmake_macros/intel_melvin.cmake
@@ -2,13 +2,7 @@ set(ALBANY_PATH "/projects/install/rhel6-x86_64/ACME/AlbanyTrilinos/Albany/build
 if (COMP_NAME STREQUAL gptl)
   string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
 endif()
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
 string(APPEND CXX_LIBS " -lstdc++ -lmpi_cxx")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
 set(NETCDF_PATH "$ENV{NETCDFROOT}")
 set(PNETCDF_PATH "$ENV{PNETCDFROOT}")
 execute_process(COMMAND ${NETCDF_PATH}/bin/nf-config --flibs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
diff --git a/cime_config/machines/cmake_macros/intel_quartz.cmake b/cime_config/machines/cmake_macros/intel_quartz.cmake
index aa851129bb..a899ab38f8 100644
--- a/cime_config/machines/cmake_macros/intel_quartz.cmake
+++ b/cime_config/machines/cmake_macros/intel_quartz.cmake
@@ -1,12 +1,6 @@
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
 string(APPEND CPPDEFS " -DNO_SHR_VMATH -DCNL")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -g -traceback  -O0 -fpe0 -check  all -check noarg_temp_created -ftrapuv")
+  string(APPEND FFLAGS " -check all -ftrapuv")
 endif()
 string(APPEND SLIBS " -llapack -lblas")
 set(MPI_LIB_NAME "mpich")
diff --git a/cime_config/machines/cmake_macros/intel_sandiatoss3.cmake b/cime_config/machines/cmake_macros/intel_sandiatoss3.cmake
index 317bd3a6d6..60df912184 100644
--- a/cime_config/machines/cmake_macros/intel_sandiatoss3.cmake
+++ b/cime_config/machines/cmake_macros/intel_sandiatoss3.cmake
@@ -2,13 +2,7 @@ set(ALBANY_PATH "/projects/ccsm/AlbanyTrilinos_20190904/albany-build/install")
 if (COMP_NAME STREQUAL gptl)
   string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
 endif()
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
 set(ESMF_LIBDIR "/projects/ccsm/esmf-6.3.0rp1/lib/libO/Linux.intel.64.openmpi.default")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
 if (MPILIB STREQUAL openmpi)
   set(MPI_PATH "$ENV{MPIHOME}")
 endif()
diff --git a/cime_config/machines/cmake_macros/intel_sooty.cmake b/cime_config/machines/cmake_macros/intel_sooty.cmake
index 964bbec837..8773085262 100644
--- a/cime_config/machines/cmake_macros/intel_sooty.cmake
+++ b/cime_config/machines/cmake_macros/intel_sooty.cmake
@@ -1,12 +1,6 @@
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
 string(APPEND CPPDEFS " -DLINUX")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -g -traceback  -O0 -fpe0 -check  all -check noarg_temp_created -ftrapuv -init=snan")
+  string(APPEND FFLAGS " -check all -ftrapuv -init=snan")
 endif()
 set(NETCDF_PATH "$ENV{NETCDF_PATH}")
 set(PIO_FILESYSTEM_HINTS "lustre")
diff --git a/cime_config/machines/cmake_macros/intel_stampede2.cmake b/cime_config/machines/cmake_macros/intel_stampede2.cmake
index 0e8b56f8ce..8cc5f38147 100644
--- a/cime_config/machines/cmake_macros/intel_stampede2.cmake
+++ b/cime_config/machines/cmake_macros/intel_stampede2.cmake
@@ -4,15 +4,12 @@ if (COMP_NAME STREQUAL gptl)
   string(APPEND CPPDEFS " -DHAVE_NANOTIME -DBIT64 -DHAVE_VPRINTF -DHAVE_BACKTRACE -DHAVE_SLASHPROC -DHAVE_COMM_F2C -DHAVE_TIMES -DHAVE_GETTIMEOFDAY")
 endif()
 string(APPEND CPPDEFS " -DARCH_MIC_KNL")
-string(APPEND FFLAGS " -convert big_endian -assume byterecl -ftz -traceback -assume realloc_lhs -fp-model consistent -fimf-use-svml")
+string(APPEND FFLAGS " -fp-model consistent -fimf-use-svml")
 if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -debug minimal -qno-opt-dynamic-align")
+  string(APPEND FFLAGS " -qno-opt-dynamic-align")
 endif()
 string(APPEND FFLAGS " -xCORE-AVX2")
 set(HDF5_PATH "$ENV{TACC_HDF5_DIR}")
-set(MPICC "mpicc")
-set(MPICXX "mpicxx")
-set(MPIFC "mpif90")
 set(MPI_LIB_NAME "impi")
 if (MPILIB STREQUAL impi)
   set(NETCDF_PATH "$ENV{TACC_NETCDF_DIR}")
@@ -23,11 +20,6 @@ endif()
 set(PETSC_PATH "$ENV{PETSC_DIR}")
 if (MPILIB STREQUAL impi)
   set(PNETCDF_PATH "$ENV{TACC_PNETCDF_DIR}")
-endif()
-set(SCC "icc")
-set(SCXX "icpc")
-set(SFC "ifort")
-if (MPILIB STREQUAL impi)
   string(APPEND SLIBS " -L${NETCDF_PATH} -lnetcdff -Wl,--as-needed,-L${NETCDF_PATH}/lib -lnetcdff -lnetcdf")
 endif()
 if (MPILIB STREQUAL mpi-serial)
diff --git a/cime_config/machines/cmake_macros/intel_syrah.cmake b/cime_config/machines/cmake_macros/intel_syrah.cmake
index aa851129bb..a899ab38f8 100644
--- a/cime_config/machines/cmake_macros/intel_syrah.cmake
+++ b/cime_config/machines/cmake_macros/intel_syrah.cmake
@@ -1,12 +1,6 @@
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
 string(APPEND CPPDEFS " -DNO_SHR_VMATH -DCNL")
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -g -traceback  -O0 -fpe0 -check  all -check noarg_temp_created -ftrapuv")
+  string(APPEND FFLAGS " -check all -ftrapuv")
 endif()
 string(APPEND SLIBS " -llapack -lblas")
 set(MPI_LIB_NAME "mpich")
diff --git a/cime_config/machines/cmake_macros/intel_theta.cmake b/cime_config/machines/cmake_macros/intel_theta.cmake
index 23ea051aaf..cee4387571 100644
--- a/cime_config/machines/cmake_macros/intel_theta.cmake
+++ b/cime_config/machines/cmake_macros/intel_theta.cmake
@@ -1,8 +1,8 @@
 string(APPEND CONFIG_ARGS " --host=cray")
 string(APPEND CPPDEFS " -DARCH_MIC_KNL")
-string(APPEND FFLAGS " -convert big_endian -assume byterecl -ftz -traceback -assume realloc_lhs -fp-model consistent -fimf-use-svml=true")
+string(APPEND FFLAGS " -fp-model consistent -fimf-use-svml=true")
 if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -debug minimal -qno-opt-dynamic-align -fp-speculation=off")
+  string(APPEND FFLAGS " -qno-opt-dynamic-align -fp-speculation=off")
 endif()
 string(APPEND FFLAGS " -DHAVE_ERF_INTRINSICS")
 set(SCC "icc")
diff --git a/cime_config/machines/cmake_macros/nag.cmake b/cime_config/machines/cmake_macros/nag.cmake
index 4a14dac99d..9f9a8d77aa 100644
--- a/cime_config/machines/cmake_macros/nag.cmake
+++ b/cime_config/machines/cmake_macros/nag.cmake
@@ -8,9 +8,6 @@ string(APPEND FFLAGS " -wmismatch=mpi_send,mpi_recv,mpi_bcast,mpi_allreduce,mpi_
 if (NOT DEBUG)
   string(APPEND FFLAGS " -ieee=full -O2")
 endif()
-if (DEBUG)
-  string(APPEND FFLAGS " -g -time -f2003 -ieee=stop")
-endif()
 if (DEBUG)
   string(APPEND FFLAGS " -C=all -g -time -f2003 -ieee=stop")
 endif()
diff --git a/cime_config/machines/cmake_macros/nag_constance.cmake b/cime_config/machines/cmake_macros/nag_constance.cmake
index 27dd36ae2c..8db30816e1 100644
--- a/cime_config/machines/cmake_macros/nag_constance.cmake
+++ b/cime_config/machines/cmake_macros/nag_constance.cmake
@@ -3,10 +3,10 @@ if (NOT DEBUG)
 endif()
 string(APPEND CPPDEFS " -DLINUX")
 if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -kind=byte")
+  string(APPEND FFLAGS " -kind=byte")
 endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -C=all  -g  -O0 -v")
+  string(APPEND FFLAGS " -O0 -v")
 endif()
 set(NETCDF_PATH "$ENV{NETCDF_HOME}")
 set(PIO_FILESYSTEM_HINTS "lustre")
diff --git a/cime_config/machines/cmake_macros/nvidia.cmake b/cime_config/machines/cmake_macros/nvidia.cmake
index ce224dc374..2d6d2b44f2 100644
--- a/cime_config/machines/cmake_macros/nvidia.cmake
+++ b/cime_config/machines/cmake_macros/nvidia.cmake
@@ -1,10 +1,10 @@
-set(MPICC "mpicc")
-set(MPICXX "mpicxx")
-set(MPIFC "mpif90")
+set(MPICC "cc")
+set(MPICXX "CC")
+set(MPIFC "ftn")
 set(SCC "nvcc")
 set(SCXX "nvc++")
 set(SFC "nvfortran")
-string(APPEND CPPDEFS " -DFORTRANUNDERSCORE -DNO_R16 -DCPRNVIDIA -DCPL_BYPASS")
+string(APPEND CPPDEFS " -DFORTRANUNDERSCORE -DNO_R16 -DCPRNVIDIA")
 if (compile_threaded)
   string(APPEND CFLAGS " -mp")
 endif()
@@ -41,7 +41,7 @@ string(APPEND FFLAGS_NOOPT " -O0 -Mnofma")
 string(APPEND FIXEDFLAGS " -Mfixed")
 string(APPEND FREEFLAGS " -Mfree")
 set(HAS_F2008_CONTIGUOUS "FALSE")
-string(APPEND LDFLAGS " -Wl,--allow-multiple-definition -L/usr/local/hdf5/lib ")
+string(APPEND LDFLAGS " -Wl,--allow-multiple-definition")
 if (compile_threaded)
   string(APPEND LDFLAGS " -mp")
 endif()
diff --git a/cime_config/machines/cmake_macros/nvidia_docker.cmake b/cime_config/machines/cmake_macros/nvidia_docker.cmake
deleted file mode 100644
index 5e2b176f7b..0000000000
--- a/cime_config/machines/cmake_macros/nvidia_docker.cmake
+++ /dev/null
@@ -1,26 +0,0 @@
-if (COMP_NAME STREQUAL gptl)
-  string(APPEND CPPDEFS " -DHAVE_NANOTIME -DBIT64 -DHAVE_SLASHPROC -DHAVE_GETTIMEOFDAY")
-endif()
-string(APPEND SLIBS " -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_PATH}/lib -lnetcdf -lnetcdff")
-string(APPEND SLIBS " -L$ENV{BLASLAPACK_DIR} -lblas -llapack")
-set(CXX_LINKER "FORTRAN")
-set(NETCDF_PATH "$ENV{NETCDF_PATH}")
-set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
-set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
-set(HDF5_PATH "$ENV{HDF5_PATH}")
-set(PNETCDF_PATH "")
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2")
-endif()
-if (NOT DEBUG)
-  string(APPEND CXXFLAGS " -O2")
-endif()
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
-endif()
-set(MPICC "mpicc")
-set(MPICXX "mpicxx")
-set(MPIFC "mpif90")
-set(SCC "nvcc")
-set(SCXX "nvc++")
-set(SFC "nvfortran")
diff --git a/cime_config/machines/cmake_macros/nvidiagpu.cmake b/cime_config/machines/cmake_macros/nvidiagpu.cmake
index 0edc0171bf..45ee806818 100644
--- a/cime_config/machines/cmake_macros/nvidiagpu.cmake
+++ b/cime_config/machines/cmake_macros/nvidiagpu.cmake
@@ -1,20 +1,23 @@
-set(MPICC "mpicc")
-set(MPICXX "mpicxx")
-set(MPIFC "mpif90")
+set(MPICC "cc")
+set(MPICXX "CC")
+set(MPIFC "ftn")
 set(SCC "nvcc")
 set(SCXX "nvc++")
 set(SFC "nvfortran")
-string(APPEND CPPDEFS " -DFORTRANUNDERSCORE -DNO_R16 -DCPRNVIDIA -DCPL_BYPASS")
+string(APPEND CPPDEFS " -DFORTRANUNDERSCORE -DNO_R16 -DCPRNVIDIA")
+if (DEBUG)
+  string(APPEND CPPDEFS " -DYAKL_DEBUG")
+endif()
 if (compile_threaded)
   string(APPEND CFLAGS " -mp")
 endif()
 if (NOT DEBUG)
-  string(APPEND CFLAGS " -O0 -Mnofma -Mvect=nosimd")
+  string(APPEND CFLAGS " -O2")
 endif()
 if (DEBUG)
   string(APPEND CFLAGS " -g")
 endif()
-string(APPEND FFLAGS " -i4 -Mstack_arrays  -Mextend -byteswapio -Mflushz -Kieee -DHAVE_IEEE_ARITHMETIC -Mallocatable=03 -DNO_R16 -traceback")
+string(APPEND FFLAGS " -i4 -Mstack_arrays -Mextend -byteswapio -Mflushz -Kieee -DHAVE_IEEE_ARITHMETIC -Mallocatable=03 -DNO_R16 -traceback")
 if (compile_threaded)
   string(APPEND FFLAGS " -mp")
 endif()
@@ -22,17 +25,14 @@ if (DEBUG)
   string(APPEND FFLAGS " -O0 -g -Ktrap=fp -Mbounds -Kieee")
 endif()
 if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2")
+  string(APPEND FFLAGS " -O2 -DHAVE_IEEE_ARITHMETIC")
 endif()
 string(APPEND CXXFLAGS " -std=c++14")
 if (compile_threaded)
   string(APPEND CXXFLAGS " -mp")
 endif()
-if(COMP_NAME STREQUAL "elm") 
-  string(APPEND FFLAGS " -gpu=deepcopy -Minfo=accel -acc -cuda ")
-endif() 
 if (DEBUG)
-  string(APPEND CXXFLAGS " -g -O0 -Mnofma -Wall -Kieee -traceback")
+  string(APPEND CXXFLAGS " -g -O0 -Mnofma -Wall -traceback")
 endif()
 if (NOT DEBUG)
   string(APPEND CXXFLAGS " -O2")
@@ -44,7 +44,7 @@ string(APPEND FFLAGS_NOOPT " -O0 -Mnofma")
 string(APPEND FIXEDFLAGS " -Mfixed")
 string(APPEND FREEFLAGS " -Mfree")
 set(HAS_F2008_CONTIGUOUS "FALSE")
-string(APPEND LDFLAGS " -Wl,--allow-multiple-definition -L/usr/local/hdf5/lib -acc -cuda")
+string(APPEND LDFLAGS " -Wl,--allow-multiple-definition")
 if (compile_threaded)
   string(APPEND LDFLAGS " -mp")
 endif()
diff --git a/cime_config/machines/cmake_macros/nvidiagpu_docker.cmake b/cime_config/machines/cmake_macros/nvidiagpu_docker.cmake
deleted file mode 100644
index c5cfbdbeb5..0000000000
--- a/cime_config/machines/cmake_macros/nvidiagpu_docker.cmake
+++ /dev/null
@@ -1,20 +0,0 @@
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2 -Mvect=nosimd")
-endif()
-if (COMP_NAME STREQUAL gptl)
-  string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
-endif()
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -Mvect=nosimd -DSUMMITDEV_PGI")
-endif()
-string(APPEND LDFLAGS " -gpu=cc70,cc60,deepcopy -Minfo=accel")
-string(APPEND SLIBS " -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{BLASLAPACK_DIR} -lblas -llapack")
-set(CXX_LINKER "FORTRAN")
-string(APPEND CXX_LIBS " -lstdc++")
-set(MPICXX "mpicxx")
-set(PIO_FILESYSTEM_HINTS "gpfs")
-set(SFC "nvfortran")
-set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
-set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
-set(PNETCDF_PATH "")
-set(SUPPORTS_CXX "TRUE")
diff --git a/cime_config/machines/cmake_macros/pgi.cmake b/cime_config/machines/cmake_macros/pgi.cmake
index 43ce50ef8c..a7bdf9244b 100644
--- a/cime_config/machines/cmake_macros/pgi.cmake
+++ b/cime_config/machines/cmake_macros/pgi.cmake
@@ -14,7 +14,7 @@ if (compile_threaded)
   string(APPEND FFLAGS " -mp")
 endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -O0 -g -Ktrap=fp -Mbounds -Kieee")
+  string(APPEND FFLAGS " -O0 -g -Ktrap=fp -Mbounds")
 endif()
 if (COMP_NAME STREQUAL datm)
   string(APPEND FFLAGS " -Mnovect")
diff --git a/cime_config/machines/cmake_macros/pgi_ascent.cmake b/cime_config/machines/cmake_macros/pgi_ascent.cmake
index 2390694d4e..090a1b86f2 100644
--- a/cime_config/machines/cmake_macros/pgi_ascent.cmake
+++ b/cime_config/machines/cmake_macros/pgi_ascent.cmake
@@ -1,7 +1,5 @@
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2 -Mvect=nosimd")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2 -DSUMMITDEV_PGI")
 endif()
 if (COMP_NAME STREQUAL gptl)
@@ -10,12 +8,8 @@ endif()
 string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
 set(CXX_LINKER "FORTRAN")
 string(APPEND CXX_LIBS " -lstdc++")
-set(MPICC "mpicc")
 set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
 set(PIO_FILESYSTEM_HINTS "gpfs")
-set(SCC "pgcc")
-set(SCXX "pgc++")
 set(SFC "pgfortran")
 set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
 set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
diff --git a/cime_config/machines/cmake_macros/pgi_compy.cmake b/cime_config/machines/cmake_macros/pgi_compy.cmake
index f2e75b503c..2d59aaa0dd 100644
--- a/cime_config/machines/cmake_macros/pgi_compy.cmake
+++ b/cime_config/machines/cmake_macros/pgi_compy.cmake
@@ -11,7 +11,7 @@ if (NOT DEBUG)
   string(APPEND FFLAGS " -O2")
 endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -C -Mbounds -traceback -Mchkfpstk -Mchkstk -Mdalign  -Mdepchk  -Mextend -Miomutex -Mrecursive  -Ktrap=fp -O0 -g -byteswapio -Meh_frame")
+  string(APPEND FFLAGS " -C -traceback -Mchkfpstk -Mchkstk -Mdalign  -Mdepchk -Miomutex -Mrecursive  -Meh_frame")
 endif()
 if (COMP_NAME STREQUAL eam)
   string(APPEND FFLAGS " -Mnovect")
@@ -25,11 +25,7 @@ set(PNETCDF_PATH "$ENV{PNETCDF_HOME}")
 string(APPEND SLIBS " -lpmi -L${NETCDF_PATH}/lib -lnetcdf -lnetcdff -L$ENV{MKL_PATH}/lib/intel64/ -lmkl_rt $ENV{PNETCDF_LIBRARIES}")
 if (MPILIB STREQUAL impi)
   set(MPICC "mpipgcc")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPICXX "mpipgcxx")
-endif()
-if (MPILIB STREQUAL impi)
   set(MPIFC "mpipgf90")
 endif()
 set(SUPPORTS_CXX "TRUE")
diff --git a/cime_config/machines/cmake_macros/pgi_constance.cmake b/cime_config/machines/cmake_macros/pgi_constance.cmake
index bbd49b9fb2..112bc32fb3 100644
--- a/cime_config/machines/cmake_macros/pgi_constance.cmake
+++ b/cime_config/machines/cmake_macros/pgi_constance.cmake
@@ -6,10 +6,8 @@ if (NOT DEBUG)
   string(APPEND FFLAGS " -O2")
 endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -g -traceback  -O0 -fpe0 -check  all -check noarg_temp_created -ftrapuv")
-endif()
-if (DEBUG)
-  string(APPEND FFLAGS " -C -Mbounds -traceback -Mchkfpstk -Mchkstk -Mdalign  -Mdepchk  -Mextend -Miomutex -Mrecursive  -Ktrap=fp -O0 -g -byteswapio -Meh_frame")
+  string(APPEND FFLAGS " -traceback  -fpe0 -check  all -check noarg_temp_created -ftrapuv")
+  string(APPEND FFLAGS " -C -Mchkfpstk -Mchkstk -Mdalign  -Mdepchk -Miomutex -Mrecursive -Meh_frame")
 endif()
 set(NETCDF_PATH "$ENV{NETCDF_HOME}")
 set(PIO_FILESYSTEM_HINTS "lustre")
diff --git a/cime_config/machines/cmake_macros/pgi_summit.cmake b/cime_config/machines/cmake_macros/pgi_summit.cmake
index 2390694d4e..090a1b86f2 100644
--- a/cime_config/machines/cmake_macros/pgi_summit.cmake
+++ b/cime_config/machines/cmake_macros/pgi_summit.cmake
@@ -1,7 +1,5 @@
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2 -Mvect=nosimd")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2 -DSUMMITDEV_PGI")
 endif()
 if (COMP_NAME STREQUAL gptl)
@@ -10,12 +8,8 @@ endif()
 string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
 set(CXX_LINKER "FORTRAN")
 string(APPEND CXX_LIBS " -lstdc++")
-set(MPICC "mpicc")
 set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
 set(PIO_FILESYSTEM_HINTS "gpfs")
-set(SCC "pgcc")
-set(SCXX "pgc++")
 set(SFC "pgfortran")
 set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
 set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
diff --git a/cime_config/machines/cmake_macros/pgielmacc.cmake b/cime_config/machines/cmake_macros/pgielmacc.cmake
deleted file mode 100644
index d2320f6bd0..0000000000
--- a/cime_config/machines/cmake_macros/pgielmacc.cmake
+++ /dev/null
@@ -1,49 +0,0 @@
-string(APPEND CFLAGS " -time")
-if (compile_threaded)
-  string(APPEND CFLAGS " -mp")
-endif()
-string(APPEND CPPDEFS " -DFORTRANUNDERSCORE -DNO_SHR_VMATH -DNO_R16 -DCPRPGI -DCPL_BYPASS")
-set(CXX_LINKER "CXX")
-string(APPEND FC_AUTO_R8 " -r8")
-string(APPEND FFLAGS " -i4 -time -Mnostack_arrays  -Mextend -byteswapio -Mflushz -Kieee -Mallocatable=03")
-if (compile_threaded)
-  string(APPEND FFLAGS " -mp")
-endif()
-if (DEBUG)
-  string(APPEND FFLAGS " -O0 -g -Mnovect -Kieee -Mchkptr -Mchkstk")
-endif()
-if (COMP_NAME STREQUAL datm)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL dlnd)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL elm)
-  string(APPEND FFLAGS " -ta=tesla:deepcopy,ptxinfo -Minfo=accel -acc -Mcuda")
-endif()
-if (COMP_NAME STREQUAL drof)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL dwav)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL dice)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL docn)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-string(APPEND FFLAGS_NOOPT " -O0")
-string(APPEND FIXEDFLAGS " -Mfixed")
-string(APPEND FREEFLAGS " -Mfree")
-set(HAS_F2008_CONTIGUOUS "FALSE")
-string(APPEND LDFLAGS " -time -Wl,--allow-multiple-definition -acc -Mcuda")
-if (compile_threaded)
-  string(APPEND LDFLAGS " -mp")
-endif()
-set(MPICC "mpicc")
-set(MPICXX "mpicxx")
-set(MPIFC "mpifort")
-set(SCC "pgcc")
-set(SCXX "pgc++")
-set(SFC "pgfortran")
diff --git a/cime_config/machines/cmake_macros/pgielmacc_summit.cmake b/cime_config/machines/cmake_macros/pgielmacc_summit.cmake
deleted file mode 100644
index 1c8c2cac4d..0000000000
--- a/cime_config/machines/cmake_macros/pgielmacc_summit.cmake
+++ /dev/null
@@ -1,22 +0,0 @@
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2 -Mvect=nosimd")
-endif()
-if (COMP_NAME STREQUAL gptl)
-  string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
-endif()
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -Mvect=nosimd -DSUMMITDEV_PGI")
-endif()
-string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
-set(CXX_LINKER "FORTRAN")
-string(APPEND CXX_LIBS " -lstdc++")
-set(MPICC "mpicc")
-set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
-set(PIO_FILESYSTEM_HINTS "gpfs")
-set(SCC "pgcc")
-set(SFC "pgfortran")
-set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
-set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
-set(PNETCDF_PATH "$ENV{PNETCDF_PATH}")
-set(SUPPORTS_CXX "TRUE")
diff --git a/cime_config/machines/cmake_macros/pgigpu.cmake b/cime_config/machines/cmake_macros/pgigpu.cmake
index d7e94a9076..bb28af9a00 100644
--- a/cime_config/machines/cmake_macros/pgigpu.cmake
+++ b/cime_config/machines/cmake_macros/pgigpu.cmake
@@ -17,7 +17,7 @@ if (COMP_NAME STREQUAL eam)
   string(APPEND FFLAGS " ")
 endif()
 if (DEBUG)
-  string(APPEND FFLAGS " -O0 -g -Ktrap=fp -Mbounds -Kieee")
+  string(APPEND FFLAGS " -O0 -g -Ktrap=fp -Mbounds")
 endif()
 if (COMP_NAME STREQUAL datm)
   string(APPEND FFLAGS " -Mnovect")
diff --git a/cime_config/machines/cmake_macros/pgigpu_ascent.cmake b/cime_config/machines/cmake_macros/pgigpu_ascent.cmake
index 366c92ec25..f3ba8dc978 100644
--- a/cime_config/machines/cmake_macros/pgigpu_ascent.cmake
+++ b/cime_config/machines/cmake_macros/pgigpu_ascent.cmake
@@ -12,11 +12,8 @@ string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -
 set(CXX_LINKER "FORTRAN")
 string(APPEND CXX_LIBS " -lstdc++")
 set(KOKKOS_OPTIONS "--arch=Power9,Volta70 --with-cuda=$ENV{CUDA_DIR} --with-cuda-options=enable_lambda")
-set(MPICC "mpicc")
 set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
 set(PIO_FILESYSTEM_HINTS "gpfs")
-set(SCC "pgcc")
 set(SFC "pgfortran")
 set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
 set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
diff --git a/cime_config/machines/cmake_macros/pgigpu_blues.cmake b/cime_config/machines/cmake_macros/pgigpu_blues.cmake
index dfb36fce22..955639298c 100644
--- a/cime_config/machines/cmake_macros/pgigpu_blues.cmake
+++ b/cime_config/machines/cmake_macros/pgigpu_blues.cmake
@@ -4,8 +4,6 @@ endif()
 set(PIO_FILESYSTEM_HINTS "gpfs")
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2 -Mvect=nosimd")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2 -Mvect=nosimd -DSUMMITDEV_PGI")
 endif()
 string(APPEND LDFLAGS " -Minline -ta=tesla:ccall,fastmath,loadcache:L1,unroll,fma,managed,deepcopy,nonvvm -Mcuda -Minfo=accel")
diff --git a/cime_config/machines/cmake_macros/pgigpu_summit.cmake b/cime_config/machines/cmake_macros/pgigpu_summit.cmake
index 366c92ec25..ed292a1bdb 100644
--- a/cime_config/machines/cmake_macros/pgigpu_summit.cmake
+++ b/cime_config/machines/cmake_macros/pgigpu_summit.cmake
@@ -7,16 +7,13 @@ endif()
 if (NOT DEBUG)
   string(APPEND FFLAGS " -O2 -Mvect=nosimd -DSUMMITDEV_PGI")
 endif()
-string(APPEND LDFLAGS " -Minline -ta=nvidia,cc70,fastmath,loadcache:L1,unroll,fma,managed,ptxinfo -Mcuda -Minfo=accel")
+string(APPEND LDFLAGS " -gpu=cc70,cc60,deepcopy -Minfo=accel")
 string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
 set(CXX_LINKER "FORTRAN")
 string(APPEND CXX_LIBS " -lstdc++")
 set(KOKKOS_OPTIONS "--arch=Power9,Volta70 --with-cuda=$ENV{CUDA_DIR} --with-cuda-options=enable_lambda")
-set(MPICC "mpicc")
 set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
 set(PIO_FILESYSTEM_HINTS "gpfs")
-set(SCC "pgcc")
 set(SFC "pgfortran")
 set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
 set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
diff --git a/cime_config/machines/cmake_macros/pgigpu_swing.cmake b/cime_config/machines/cmake_macros/pgigpu_swing.cmake
index dfb36fce22..6b010b2197 100644
--- a/cime_config/machines/cmake_macros/pgigpu_swing.cmake
+++ b/cime_config/machines/cmake_macros/pgigpu_swing.cmake
@@ -4,11 +4,9 @@ endif()
 set(PIO_FILESYSTEM_HINTS "gpfs")
 if (NOT DEBUG)
   string(APPEND CFLAGS " -O2 -Mvect=nosimd")
-endif()
-if (NOT DEBUG)
   string(APPEND FFLAGS " -O2 -Mvect=nosimd -DSUMMITDEV_PGI")
 endif()
-string(APPEND LDFLAGS " -Minline -ta=tesla:ccall,fastmath,loadcache:L1,unroll,fma,managed,deepcopy,nonvvm -Mcuda -Minfo=accel")
+string(APPEND LDFLAGS " -gpu=cc70,cc60,deepcopy -Minfo=accel")
 execute_process(COMMAND $ENV{NETCDF_FORTRAN_PATH}/bin/nf-config --flibs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
 string(APPEND SLIBS " ${SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0} -llapack -lblas")
 execute_process(COMMAND $ENV{NETCDF_C_PATH}/bin/nc-config --libs OUTPUT_VARIABLE SHELL_CMD_OUTPUT_BUILD_INTERNAL_IGNORE0 OUTPUT_STRIP_TRAILING_WHITESPACE)
diff --git a/cime_config/machines/config_compilers.xml b/cime_config/machines/config_compilers.xml
index c9c516c163..187f0ca7f5 100644
--- a/cime_config/machines/config_compilers.xml
+++ b/cime_config/machines/config_compilers.xml
@@ -599,57 +599,6 @@ flags should be captured within MPAS CMake files.
   <SFC> pgf95 </SFC>
 </compiler>
 
-<compiler COMPILER="pgielmacc">
-  <CFLAGS>
-    <base> -time </base>
-    <append compile_threaded="TRUE"> -mp </append>
-  </CFLAGS>
-  <CPPDEFS>
-    <append> -DFORTRANUNDERSCORE -DNO_SHR_VMATH -DNO_R16 -DCPRPGI -DCPL_BYPASS </append>
-  </CPPDEFS>
-  <CXX_LINKER>CXX</CXX_LINKER>
-  <FC_AUTO_R8>
-    <base> -r8 </base>
-  </FC_AUTO_R8>
-  <FFLAGS>
-    <base>  -i4 -time -Mnostack_arrays  -Mextend -byteswapio -Mflushz -Kieee -Mallocatable=03 </base>
-    <append compile_threaded="TRUE"> -mp </append>
-    <append DEBUG="TRUE"> -O0 -g -Mnovect -Kieee -Mchkptr -Mchkstk </append>
-    <append COMP_NAME="datm"> -Mnovect </append>
-    <append COMP_NAME="dlnd"> -Mnovect </append>
-    <append COMP_NAME="elm"> -ta=tesla:deepcopy,ptxinfo -Minfo=accel -acc -Mcuda </append>
-    <append COMP_NAME="drof"> -Mnovect </append>
-    <append COMP_NAME="dwav"> -Mnovect </append>
-    <append COMP_NAME="dice"> -Mnovect </append>
-    <append COMP_NAME="docn"> -Mnovect </append>
-  </FFLAGS>
-  <FFLAGS_NOOPT>
-    <base> -O0 </base>
-  </FFLAGS_NOOPT>
-  <FIXEDFLAGS>
-    <base> -Mfixed </base>
-  </FIXEDFLAGS>
-  <FREEFLAGS>
-    <base> -Mfree </base>
-  </FREEFLAGS>
-  <!-- Note that SUPPORTS_CXX is false for pgi in general, because we
-       need some machine-specific libraries -->
-  <!-- Technically, PGI does recognize this keyword during parsing,
-       but support is either buggy or incomplete, notably in that
-       the "contiguous" attribute is incompatible with "intent".-->
-  <HAS_F2008_CONTIGUOUS>FALSE</HAS_F2008_CONTIGUOUS>
-  <LDFLAGS>
-    <base> -time -Wl,--allow-multiple-definition -acc -Mcuda </base>
-    <append compile_threaded="TRUE"> -mp </append>
-  </LDFLAGS>
-  <MPICC> mpicc </MPICC>
-  <MPICXX> mpicxx </MPICXX>
-  <MPIFC> mpifort </MPIFC>
-  <SCC> pgcc </SCC>
-  <SCXX> pgc++ </SCXX>
-  <SFC> pgfortran </SFC>
-</compiler>
-
 <compiler COMPILER="pgigpu">
   <CFLAGS>
     <base> -time </base>
@@ -1344,40 +1293,6 @@ flags should be captured within MPAS CMake files.
   <SFC> gfortran </SFC>
 </compiler>
 
-<compiler MACH="perlmutter" COMPILER="gnu">
-  <CONFIG_ARGS>
-    <base> --host=cray </base>
-  </CONFIG_ARGS>
-  <CPPDEFS>
-    <append COMP_NAME="gptl"> -DHAVE_NANOTIME -DBIT64 -DHAVE_SLASHPROC -DHAVE_GETTIMEOFDAY </append>
-  </CPPDEFS>
-  <SLIBS>
-    <append> -L$ENV{CRAY_HDF5_PARALLEL_PREFIX}/lib -lhdf5_hl -lhdf5 -L$ENV{CRAY_NETCDF_HDF5PARALLEL_PREFIX} -L$ENV{CRAY_PARALLEL_NETCDF_PREFIX}/lib -lpnetcdf -lnetcdf -lnetcdff </append>
-    <append> -lblas -llapack </append>
-  </SLIBS>
-  <CXX_LINKER>FORTRAN</CXX_LINKER>
-  <NETCDF_PATH>$ENV{CRAY_NETCDF_HDF5PARALLEL_PREFIX}</NETCDF_PATH>
-  <NETCDF_C_PATH>$ENV{CRAY_NETCDF_HDF5PARALLEL_PREFIX}</NETCDF_C_PATH>
-  <NETCDF_FORTRAN_PATH>$ENV{CRAY_NETCDF_HDF5PARALLEL_PREFIX}</NETCDF_FORTRAN_PATH>
-  <HDF5_PATH>$ENV{CRAY_HDF5_PARALLEL_PREFIX}</HDF5_PATH>
-  <PNETCDF_PATH>$ENV{CRAY_PARALLEL_NETCDF_PREFIX}</PNETCDF_PATH>
-  <CFLAGS>
-    <append DEBUG="FALSE"> -O2 -g </append>
-  </CFLAGS>
-  <FFLAGS>
-    <append DEBUG="FALSE"> -O2 -g </append>
-  </FFLAGS>
-  <CXX_LIBS>
-    <base>-lstdc++</base>
-  </CXX_LIBS>
-  <MPICC> cc </MPICC>
-  <MPICXX> CC </MPICXX>
-  <MPIFC> ftn </MPIFC>
-  <SCC> gcc </SCC>
-  <SCXX> g++ </SCXX>
-  <SFC> gfortran </SFC>
-</compiler>
-
 <compiler MACH="perlmutter" COMPILER="gnugpu">
   <CONFIG_ARGS>
     <base> --host=cray </base>
@@ -2050,35 +1965,6 @@ flags should be captured within MPAS CMake files.
   <SUPPORTS_CXX>TRUE</SUPPORTS_CXX>
 </compiler>
 
-<compiler MACH="summit" COMPILER="pgielmacc">
-  <CFLAGS>
-    <append DEBUG="FALSE"> -O2 -Mvect=nosimd </append>
-  </CFLAGS>
-  <CPPDEFS>
-    <append COMP_NAME="gptl"> -DHAVE_SLASHPROC </append>
-  </CPPDEFS>
-  <FFLAGS>
-    <append DEBUG="FALSE"> -O2 -Mvect=nosimd -DSUMMITDEV_PGI </append>
-  </FFLAGS>
-  <SLIBS>
-    <append> -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack</append>
-  </SLIBS>
-  <CXX_LINKER>FORTRAN</CXX_LINKER>
-  <CXX_LIBS>
-    <base>-lstdc++</base>
-  </CXX_LIBS>
-  <MPICC> mpicc </MPICC>
-  <MPICXX> mpiCC </MPICXX>
-  <MPIFC> mpif90 </MPIFC>
-  <PIO_FILESYSTEM_HINTS>gpfs</PIO_FILESYSTEM_HINTS>
-  <SCC> pgcc </SCC>
-  <SFC> pgfortran </SFC>
-  <NETCDF_C_PATH>$ENV{NETCDF_C_PATH}</NETCDF_C_PATH>
-  <NETCDF_FORTRAN_PATH>$ENV{NETCDF_FORTRAN_PATH}</NETCDF_FORTRAN_PATH>
-  <PNETCDF_PATH>$ENV{PNETCDF_PATH}</PNETCDF_PATH>
-  <SUPPORTS_CXX>TRUE</SUPPORTS_CXX>
-</compiler>
-
 <compiler MACH="ascent" COMPILER="gnu">
   <CFLAGS>
     <append DEBUG="FALSE"> -O2  </append>
diff --git a/cime_config/machines/config_machines.xml b/cime_config/machines/config_machines.xml
index 8f41f1d45c..e9f45836d8 100644
--- a/cime_config/machines/config_machines.xml
+++ b/cime_config/machines/config_machines.xml
@@ -55,155 +55,6 @@
      This allows using a different mpirun command to launch unit tests
 
   -->
-  <machine MACH="pm-cpu">
-    <DESC>Perlmutter CPU-only nodes at NERSC.  Phase2 only: Each node has 2 AMD EPYC 7713 64-Core (Milan) 512GB</DESC>
-    <NODENAME_REGEX>$ENV{NERSC_HOST}:perlmutter</NODENAME_REGEX>
-    <OS>Linux</OS>
-    <COMPILERS>intel,gnu,nvidia,amdclang</COMPILERS>
-    <MPILIBS>mpich</MPILIBS>
-    <PROJECT>e3sm</PROJECT>
-    <SAVE_TIMING_DIR>/global/cfs/cdirs/e3sm</SAVE_TIMING_DIR>
-    <SAVE_TIMING_DIR_PROJECTS>e3sm,m3411,m3412</SAVE_TIMING_DIR_PROJECTS>
-    <CIME_OUTPUT_ROOT>$ENV{PSCRATCH}/e3sm_scratch/pm-cpu</CIME_OUTPUT_ROOT>
-    <CIME_HTML_ROOT>/global/cfs/cdirs/e3sm/www/$ENV{USER}</CIME_HTML_ROOT>
-    <CIME_URL_ROOT>http://portal.nersc.gov/project/e3sm/$ENV{USER}</CIME_URL_ROOT>
-    <DIN_LOC_ROOT>/global/cfs/cdirs/e3sm/inputdata</DIN_LOC_ROOT>
-    <DIN_LOC_ROOT_CLMFORC>/global/cfs/cdirs/e3sm/inputdata/atm/datm7</DIN_LOC_ROOT_CLMFORC>
-    <DOUT_S_ROOT>$CIME_OUTPUT_ROOT/archive/$CASE</DOUT_S_ROOT>
-    <BASELINE_ROOT>/global/cfs/cdirs/e3sm/baselines/$COMPILER</BASELINE_ROOT>
-    <CCSM_CPRNC>/global/cfs/cdirs/e3sm/tools/cprnc/cprnc</CCSM_CPRNC>
-    <GMAKE_J>10</GMAKE_J>
-    <TESTS>e3sm_developer</TESTS>
-    <NTEST_PARALLEL_JOBS>4</NTEST_PARALLEL_JOBS>
-    <BATCH_SYSTEM>nersc_slurm</BATCH_SYSTEM>
-    <SUPPORTED_BY>e3sm</SUPPORTED_BY>
-    <MAX_TASKS_PER_NODE>256</MAX_TASKS_PER_NODE>
-    <MAX_MPITASKS_PER_NODE>128</MAX_MPITASKS_PER_NODE>
-    <PROJECT_REQUIRED>TRUE</PROJECT_REQUIRED>
-    <mpirun mpilib="default">
-      <executable>srun</executable>
-      <arguments>
-        <arg name="label"> --label</arg>
-        <arg name="num_tasks"> -n {{ total_tasks }} -N {{ num_nodes }}</arg>
-        <arg name="thread_count">-c $SHELL{echo 256/`./xmlquery --value MAX_MPITASKS_PER_NODE`|bc}</arg>
-        <arg name="binding"> $SHELL{if [ 128 -ge `./xmlquery --value MAX_MPITASKS_PER_NODE` ]; then echo "--cpu_bind=cores"; else echo "--cpu_bind=threads";fi;} </arg>
-        <arg name="placement"> -m plane=$SHELL{echo `./xmlquery --value MAX_MPITASKS_PER_NODE`}</arg>
-    </arguments>
-    </mpirun>
-    <module_system type="module" allow_error="true">
-      <init_path lang="perl">/usr/share/lmod/8.3.1/init/perl</init_path>
-      <init_path lang="python">/usr/share/lmod/8.3.1/init/python</init_path>
-      <init_path lang="sh">/usr/share/lmod/8.3.1/init/sh</init_path>
-      <init_path lang="csh">/usr/share/lmod/8.3.1/init/csh</init_path>
-      <cmd_path lang="perl">/usr/share/lmod/lmod/libexec/lmod perl</cmd_path>
-      <cmd_path lang="python">/usr/share/lmod/lmod/libexec/lmod python</cmd_path>
-      <cmd_path lang="sh">module</cmd_path>
-      <cmd_path lang="csh">module</cmd_path>
-
-      <modules>
-        <command name="unload">cray-hdf5-parallel</command>
-        <command name="unload">cray-netcdf-hdf5parallel</command>
-        <command name="unload">cray-parallel-netcdf</command>
-        <command name="unload">cray-netcdf</command>
-        <command name="unload">cray-hdf5</command>
-        <command name="unload">PrgEnv-gnu</command>
-        <command name="unload">PrgEnv-intel</command>
-        <command name="unload">PrgEnv-nvidia</command>
-        <command name="unload">PrgEnv-cray</command>
-        <command name="unload">PrgEnv-aocc</command>
-        <command name="unload">intel</command>
-        <command name="unload">intel-oneapi</command>
-        <command name="unload">nvidia</command>
-        <command name="unload">aocc</command>
-        <command name="unload">cudatoolkit</command>
-        <command name="unload">climate-utils</command>
-        <command name="unload">craype-accel-nvidia80</command>
-        <command name="unload">craype-accel-host</command>
-        <command name="unload">perftools-base</command>
-        <command name="unload">perftools</command>
-        <command name="unload">darshan</command>
-      </modules>
-
-      <modules compiler="gnu">
-        <command name="load">PrgEnv-gnu/8.3.3</command>
-        <command name="load">gcc/11.2.0</command>
-        <command name="load">cray-libsci/23.02.1.1</command>
-      </modules>
-
-      <modules compiler="intel">
-        <command name="load">PrgEnv-intel/8.3.3</command>
-        <command name="load">intel/2023.1.0</command>
-      </modules>
-
-      <modules compiler="nvidia">
-        <command name="load">PrgEnv-nvidia</command>
-        <command name="load">nvidia/22.7</command>
-        <command name="load">cray-libsci/23.02.1.1</command>
-      </modules>
-
-      <modules compiler="amdclang">
-        <command name="load">PrgEnv-aocc</command>
-        <command name="load">aocc/4.0.0</command>
-        <command name="load">cray-libsci/23.02.1.1</command>
-      </modules>
-
-      <modules>
-        <command name="load">craype-accel-host</command>
-        <command name="load">craype/2.7.20</command>
-        <command name="load">cray-mpich/8.1.25</command>
-        <command name="load">cray-hdf5-parallel/1.12.2.3</command>
-        <command name="load">cray-netcdf-hdf5parallel/4.9.0.3</command>
-        <command name="load">cray-parallel-netcdf/1.12.3.3</command>
-        <command name="load">cmake/3.24.3</command>
-      </modules>
-    </module_system>
-
-    <RUNDIR>$CIME_OUTPUT_ROOT/$CASE/run</RUNDIR>
-    <EXEROOT>$CIME_OUTPUT_ROOT/$CASE/bld</EXEROOT>
-    <TEST_TPUT_TOLERANCE>0.1</TEST_TPUT_TOLERANCE>
-    <TEST_MEMLEAK_TOLERANCE>0.20</TEST_MEMLEAK_TOLERANCE>
-
-    <environment_variables>
-      <env name="MPICH_ENV_DISPLAY">1</env>
-      <env name="MPICH_VERSION_DISPLAY">1</env>
-      <env name="OMP_STACKSIZE">128M</env>
-      <env name="OMP_PROC_BIND">spread</env>
-      <env name="OMP_PLACES">threads</env>
-      <env name="HDF5_USE_FILE_LOCKING">FALSE</env>
-      <env name="PERL5LIB">/global/cfs/cdirs/e3sm/perl/lib/perl5-only-switch</env>
-      <env name="FI_CXI_RX_MATCH_MODE">software</env>
-      <env name="MPICH_COLL_SYNC">MPI_Bcast</env>
-      <env name="Albany_ROOT">$SHELL{if [ -z "$Albany_ROOT" ]; then echo /global/common/software/e3sm/mali_tpls/albany-e3sm-serial-release-gcc; else echo "$Albany_ROOT"; fi}</env>
-      <env name="Trilinos_ROOT">$SHELL{if [ -z "$Trilinos_ROOT" ]; then echo /global/common/software/e3sm/mali_tpls/trilinos-e3sm-serial-release-gcc; else echo "$Trilinos_ROOT"; fi}</env>
-      <env name="NETCDF_PATH">$ENV{CRAY_NETCDF_HDF5PARALLEL_PREFIX}</env>
-      <env name="PNETCDF_PATH">$ENV{CRAY_PARALLEL_NETCDF_PREFIX}</env>
-    </environment_variables>
-    <environment_variables compiler="intel" mpilib="mpich">
-      <env name="ADIOS2_ROOT">$SHELL{if [ -z "$ADIOS2_ROOT" ]; then echo /global/cfs/cdirs/e3sm/3rdparty/adios2/2.9.1/cray-mpich-8.1.25/intel-2023.1.0; else echo "$ADIOS2_ROOT"; fi}</env>
-    </environment_variables>
-    <environment_variables compiler="gnu" mpilib="mpich">
-      <env name="ADIOS2_ROOT">$SHELL{if [ -z "$ADIOS2_ROOT" ]; then echo /global/cfs/cdirs/e3sm/3rdparty/adios2/2.9.1/cray-mpich-8.1.25/gcc-11.2.0; else echo "$ADIOS2_ROOT"; fi}</env>
-      <env name="BLA_VENDOR">Generic</env>
-    </environment_variables>
-    <environment_variables compiler="nvidia" mpilib="mpich">
-      <env name="ADIOS2_ROOT">$SHELL{if [ -z "$ADIOS2_ROOT" ]; then echo /global/cfs/cdirs/e3sm/3rdparty/adios2/2.9.1/cray-mpich-8.1.25/nvidia-22.7; else echo "$ADIOS2_ROOT"; fi}</env>
-    </environment_variables>
-    <environment_variables compiler="nvidia">
-      <env name="BLAS_ROOT">$SHELL{if [ -z "$BLAS_ROOT" ]; then echo /opt/nvidia/hpc_sdk/Linux_x86_64/22.7/compilers; else echo "$BLAS_ROOT"; fi}</env>
-      <env name="LAPACK_ROOT">$SHELL{if [ -z "$LAPACK_ROOT" ]; then echo /opt/nvidia/hpc_sdk/Linux_x86_64/22.7/compilers; else echo "$LAPACK_ROOT"; fi}</env>
-      <env name="BLA_VENDOR">NVHPC</env>
-    </environment_variables>
-    <environment_variables compiler="intel">
-      <env name="BLA_VENDOR">Intel10_64_dyn</env>
-    </environment_variables>
-    <environment_variables compiler="amdclang" mpilib="mpich">
-      <env name="ADIOS2_ROOT">$SHELL{if [ -z "$ADIOS2_ROOT" ]; then echo /global/cfs/cdirs/e3sm/3rdparty/adios2/2.9.1/cray-mpich-8.1.25/aocc-4.0.0; else echo "$ADIOS2_ROOT"; fi}</env>
-    </environment_variables>
-    <resource_limits>
-      <resource name="RLIMIT_STACK">-1</resource>
-    </resource_limits>
-  </machine>
-  
   <machine MACH="perlmutter">
     <DESC>Perlmutter at NERSC.  Phase1 only: Each GPU node has single AMD EPYC 7713 64-Core (Milan) and 4 nvidia A100's.</DESC>
     <NODENAME_REGEX>login</NODENAME_REGEX>
@@ -268,9 +119,14 @@
       </modules>
 
       <modules compiler="gnu.*">
-        <command name="load">PrgEnv-gnu/8.3.3</command>
-        <command name="load">gcc/11.2.0</command>
-        <command name="load">cray-libsci/23.02.1.1</command>
+	<command name="load">PrgEnv-gnu/8.2.0</command>
+	<command name="load">gcc/9.3.0</command>
+	<!--command name="load">gcc/10.3.0</command-->
+      </modules>
+
+      <modules compiler="nvidia.*">
+	<command name="load">PrgEnv-nvidia</command>
+	<command name="load">nvidia/21.9</command>
       </modules>
 
       <modules compiler="gnugpu">
@@ -279,7 +135,8 @@
       </modules>
 
       <modules compiler="nvidiagpu">
-        <command name="load">cray-libsci/23.02.1.1</command>
+	<command name="load">cudatoolkit</command>
+	<command name="load">craype-accel-nvidia80</command>
       </modules>
 
       <modules compiler="gnu">
@@ -287,20 +144,17 @@
       </modules>
 
       <modules compiler="nvidia">
-        <command name="load">PrgEnv-nvidia</command>
-        <command name="load">nvidia/22.7</command>
-        <command name="load">cudatoolkit/11.7</command>
-        <command name="load">craype-accel-nvidia80</command>
+	<command name="load">craype-accel-host</command>
       </modules>
 
       <modules>
-        <command name="load">craype-accel-host</command>
-        <command name="load">craype/2.7.20</command>
-        <command name="load">cray-mpich/8.1.25</command>
-        <command name="load">cray-hdf5-parallel/1.12.2.3</command>
-        <command name="load">cray-netcdf-hdf5parallel/4.9.0.3</command>
-        <command name="load">cray-parallel-netcdf/1.12.3.3</command>
-        <command name="load">cmake/3.24.3</command>
+	<command name="load">cray-libsci</command>
+	<command name="load">craype</command>
+	<command name="load">cray-mpich/8.1.11</command>
+	<command name="load">cray-hdf5-parallel/1.12.0.7</command>
+	<command name="load">cray-netcdf-hdf5parallel/4.7.4.7</command>
+	<command name="load">cray-parallel-netcdf/1.12.1.7</command>
+	<command name="load">cmake/3.22.0</command>
       </modules>
     </module_system>
 
@@ -825,50 +679,6 @@
     <!--    <GMAKE>make</GMAKE> <- this doesn't actually work! -->
   </machine>
 
-  <machine MACH="docker">
-     <!-- customize these fields as appropriate for your system (max tasks) and
-          desired layout (change '${HOME}/projects' to your
-          prefered location). -->
-     <DESC>Containerized E3SM-ELM</DESC>
-     <NODENAME_REGEX>docker</NODENAME_REGEX>
-     <OS>LINUX</OS>
-     <COMPILERS>gnu,nvidia,nvidiagpu</COMPILERS>
-     <MPILIBS>openmpi,mpi-serial</MPILIBS>
-     <PROJECT>docker_runs</PROJECT>
-     <CIME_OUTPUT_ROOT>/output</CIME_OUTPUT_ROOT>
-     <DIN_LOC_ROOT>/inputdata</DIN_LOC_ROOT>
-     <DIN_LOC_ROOT_CLMFORC>/inputdata/atm/datm7</DIN_LOC_ROOT_CLMFORC>
-     <DOUT_S_ROOT>$CIME_OUTPUT_ROOT/archive/$CASE</DOUT_S_ROOT>
-     <BASELINE_ROOT>/baselines</BASELINE_ROOT>
-     <CCSM_CPRNC></CCSM_CPRNC>
-     <GMAKE>make</GMAKE>
-     <!-- May want to modify this. Will require users to have 4 CPUs avail-->
-     <GMAKE_J>4</GMAKE_J>
-     <BATCH_SYSTEM>none</BATCH_SYSTEM>
-     <SUPPORTED_BY>sserbin at bnl dot gov</SUPPORTED_BY>
-     <!-- May want to modify this. Will require users to have 4 CPUs avail-->
-     <MAX_TASKS_PER_NODE>1</MAX_TASKS_PER_NODE>
-     <MAX_MPITASKS_PER_NODE>1</MAX_MPITASKS_PER_NODE>
-     <PROJECT_REQUIRED>FALSE</PROJECT_REQUIRED>
-     <!-- Do we really want to force serial here? -->
-     <mpirun mpilib="mpi-serial">
-             <executable></executable>
-     </mpirun>
-     <mpirun mpilib="default">
-             <executable>mpirun</executable>
-             <arguments>
-                   <arg name="num_tasks"> -np $TOTALPES</arg>
-                   <arg name="tasks_per_node"> -npernode $MAX_TASKS_PER_NODE --allow-run-as-root </arg>
-             </arguments>
-     </mpirun>
-     <module_system type="none"/>
-     <environment_variables>
-       <env name="HDF5_HOME">/usr/local/hdf5</env>
-       <env name="NETCDF_PATH">/usr/local/netcdf</env>
-       <env name="NETCDF_C_PATH">/usr/local/netcdf</env>
-       <env name="NETCDF_FORTRAN_PATH">/usr/local/netcdf</env>
-   </environment_variables>
-  </machine>
   <machine MACH="mymac">
     <DESC>Mac OS/X workstation or laptop</DESC>
     <NODENAME_REGEX>macbook-pro.local</NODENAME_REGEX>
@@ -3331,7 +3141,7 @@
     <DESC>ORNL Summit. Node: 2x POWER9 + 6x Volta V100, 22 cores/socket, 4 HW threads/core.</DESC>
     <NODENAME_REGEX>.*summit.*</NODENAME_REGEX>
     <OS>LINUX</OS>
-    <COMPILERS>ibm,ibmgpu,pgi,pgigpu,gnu,gnugpu,pgielmacc</COMPILERS>
+    <COMPILERS>ibm,ibmgpu,pgi,pgigpu,gnu,gnugpu</COMPILERS>
     <MPILIBS>spectrum-mpi,mpi-serial</MPILIBS>
     <PROJECT>cli115</PROJECT>
     <CHARGE_ACCOUNT>cli115</CHARGE_ACCOUNT>
@@ -3394,7 +3204,7 @@
         <command name="list"/>
       </modules>
       <modules compiler="pgi.*">
-        <command name="load">nvhpc/21.9</command>
+        <command name="load">nvhpc/21.3</command>
       </modules>
       <modules compiler="pgigpu">
         <command name="load">cuda/10.1.243</command>
@@ -3465,13 +3275,6 @@
       <env name="LTC_PRT">gpu-cpu</env>
       <env name="NUM_RS">$SHELL{echo "6*((`./xmlquery --value TOTAL_TASKS` + `./xmlquery --value TASKS_PER_NODE` - 1)/`./xmlquery --value TASKS_PER_NODE`)"|bc}</env>
     </environment_variables>
-    <environment_variables compiler="pgielmacc">
-      <env name="RS_PER_NODE">$SHELL{if [ `./xmlquery --value TOTAL_TASKS` -lt 6 ];then echo `./xmlquery --value TOTAL_TASKS`;else echo 6;fi|bc}</env>
-      <env name="CPU_PER_RS">1</env>
-      <env name="GPU_PER_RS">1</env>
-      <env name="LTC_PRT">gpu-cpu</env>
-      <env name="NUM_RS">$SHELL{echo "(`./xmlquery --value TOTAL_TASKS`)"|bc}</env>
-    </environment_variables>
   </machine>
 
   <machine MACH="summitplus">
@@ -3613,6 +3416,9 @@
   </machine>
 
 
+
+
+
   <machine MACH="ascent">
     <DESC>ORNL Ascent. Node: 2x POWER9 + 6x Volta V100, 22 cores/socket, 4 HW threads/core.</DESC>
     <NODENAME_REGEX>.*ascent.*</NODENAME_REGEX>
diff --git a/cime_config/machines/scripts/pgielmacc.cmake b/cime_config/machines/scripts/pgielmacc.cmake
deleted file mode 100644
index d2320f6bd0..0000000000
--- a/cime_config/machines/scripts/pgielmacc.cmake
+++ /dev/null
@@ -1,49 +0,0 @@
-string(APPEND CFLAGS " -time")
-if (compile_threaded)
-  string(APPEND CFLAGS " -mp")
-endif()
-string(APPEND CPPDEFS " -DFORTRANUNDERSCORE -DNO_SHR_VMATH -DNO_R16 -DCPRPGI -DCPL_BYPASS")
-set(CXX_LINKER "CXX")
-string(APPEND FC_AUTO_R8 " -r8")
-string(APPEND FFLAGS " -i4 -time -Mnostack_arrays  -Mextend -byteswapio -Mflushz -Kieee -Mallocatable=03")
-if (compile_threaded)
-  string(APPEND FFLAGS " -mp")
-endif()
-if (DEBUG)
-  string(APPEND FFLAGS " -O0 -g -Mnovect -Kieee -Mchkptr -Mchkstk")
-endif()
-if (COMP_NAME STREQUAL datm)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL dlnd)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL elm)
-  string(APPEND FFLAGS " -ta=tesla:deepcopy,ptxinfo -Minfo=accel -acc -Mcuda")
-endif()
-if (COMP_NAME STREQUAL drof)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL dwav)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL dice)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-if (COMP_NAME STREQUAL docn)
-  string(APPEND FFLAGS " -Mnovect")
-endif()
-string(APPEND FFLAGS_NOOPT " -O0")
-string(APPEND FIXEDFLAGS " -Mfixed")
-string(APPEND FREEFLAGS " -Mfree")
-set(HAS_F2008_CONTIGUOUS "FALSE")
-string(APPEND LDFLAGS " -time -Wl,--allow-multiple-definition -acc -Mcuda")
-if (compile_threaded)
-  string(APPEND LDFLAGS " -mp")
-endif()
-set(MPICC "mpicc")
-set(MPICXX "mpicxx")
-set(MPIFC "mpifort")
-set(SCC "pgcc")
-set(SCXX "pgc++")
-set(SFC "pgfortran")
diff --git a/cime_config/machines/scripts/pgielmacc_summit.cmake b/cime_config/machines/scripts/pgielmacc_summit.cmake
deleted file mode 100644
index 1c8c2cac4d..0000000000
--- a/cime_config/machines/scripts/pgielmacc_summit.cmake
+++ /dev/null
@@ -1,22 +0,0 @@
-if (NOT DEBUG)
-  string(APPEND CFLAGS " -O2 -Mvect=nosimd")
-endif()
-if (COMP_NAME STREQUAL gptl)
-  string(APPEND CPPDEFS " -DHAVE_SLASHPROC")
-endif()
-if (NOT DEBUG)
-  string(APPEND FFLAGS " -O2 -Mvect=nosimd -DSUMMITDEV_PGI")
-endif()
-string(APPEND SLIBS " -L$ENV{PNETCDF_PATH}/lib -lpnetcdf -L$ENV{HDF5_PATH}/lib -lhdf5_hl -lhdf5 -L$ENV{NETCDF_C_PATH}/lib -lnetcdf -L$ENV{NETCDF_FORTRAN_PATH}/lib -lnetcdff -L$ENV{ESSL_PATH}/lib64 -lessl -L$ENV{OLCF_NETLIB_LAPACK_ROOT}/lib -llapack")
-set(CXX_LINKER "FORTRAN")
-string(APPEND CXX_LIBS " -lstdc++")
-set(MPICC "mpicc")
-set(MPICXX "mpiCC")
-set(MPIFC "mpif90")
-set(PIO_FILESYSTEM_HINTS "gpfs")
-set(SCC "pgcc")
-set(SFC "pgfortran")
-set(NETCDF_C_PATH "$ENV{NETCDF_C_PATH}")
-set(NETCDF_FORTRAN_PATH "$ENV{NETCDF_FORTRAN_PATH}")
-set(PNETCDF_PATH "$ENV{PNETCDF_PATH}")
-set(SUPPORTS_CXX "TRUE")
diff --git a/cime_config/tests.py b/cime_config/tests.py
index 46ada7d01f..7bc22a149e 100644
--- a/cime_config/tests.py
+++ b/cime_config/tests.py
@@ -44,10 +44,7 @@ _TESTS = {
             "SMS.MOS_USRDAT.RMOSGPCC.mosart-unstructure",
             "SMS.r05_r05.IELM.elm-topounit",
             "ERS.ELM_USRDAT.I1850ELM.elm-usrdat",
-            "ERS.r05_r05.IELM.elm-V2_ELM_MOSART_features",
-            "SMS_Ln2.hcru_hcru.ICB1850CNRDCTCBC.elm-ameriflux_cplbypass",
-            "SMS_Ln2.hcru_hcru.ICBELMBC.elm-sp_cplbypass",
-            "SMS_Ln2.hcru_hcru.ICBELMBC.elm-N20_ameriflux",
+            "ERS.r05_r05.IELM.elm-V2_ELM_MOSART_features"
             )
         },
 
diff --git a/components/elm/cime_config/testdefs/testmods_dirs/elm/N20_ameriflux/shell_commands b/components/elm/cime_config/testdefs/testmods_dirs/elm/N20_ameriflux/shell_commands
deleted file mode 100644
index fc3c52dbc9..0000000000
--- a/components/elm/cime_config/testdefs/testmods_dirs/elm/N20_ameriflux/shell_commands
+++ /dev/null
@@ -1,10 +0,0 @@
-./xmlchange PIO_VERSION=2
-./xmlchange MOSART_MODE=NULL
-./xmlchange ELM_BLDNML_OPTS=" -bgc bgc -nutrient cn  -nutrient_comp_pathway rd  -soil_decomp ctc  -bgc_spinup on"
-./xmlchange ATM_DOMAIN_PATH=/inputdata/share/domains/domain.clm
-./xmlchange LND_DOMAIN_PATH=/inputdata/share/domains/domain.clm
-./xmlchange ATM_DOMAIN_FILE=domain_AMFLX_N840.nc
-./xmlchange LND_DOMAIN_FILE=domain_AMFLX_N840.nc
-./xmlchange -id RUN_STARTDATE -val 0001-01-01
-./xmlchange NTASKS=1
-./xmlchange NTHRDS=1
diff --git a/components/elm/cime_config/testdefs/testmods_dirs/elm/N20_ameriflux/user_nl_elm b/components/elm/cime_config/testdefs/testmods_dirs/elm/N20_ameriflux/user_nl_elm
deleted file mode 100644
index c23814374b..0000000000
--- a/components/elm/cime_config/testdefs/testmods_dirs/elm/N20_ameriflux/user_nl_elm
+++ /dev/null
@@ -1,17 +0,0 @@
-&clm_inparm
- hist_mfilt = 1
- hist_nhtfrq = -1
- hist_empty_htapes = .true.
- hist_dov2xy = .true.
- finidat = ''
- fsurdat = '$DIN_LOC_ROOT/lnd/clm2/surfdata_map/surfdata_AMFLX_N840.nc'
- paramfile = '$DIN_LOC_ROOT/lnd/clm2/paramdata/clm_params_lakes.nc'
- fsoilordercon = '$DIN_LOC_ROOT/lnd/clm2/paramdata/CNP_parameters_lakes.nc'
- stream_fldfilename_ndep = '$DIN_LOC_ROOT/lnd/clm2/ndepdata/fndep_clm_rcp4.5_simyr1849-2106_1.9x2.5_c100428.nc'
- nyears_ad_carbon_only = 25
- spinup_mortality_factor = 10
- metdata_type = 'gswp3'
- use_lch4 = .false. 
- metdata_bypass = '$DIN_LOC_ROOT/atm/datm7/atm_forcing.datm7.GSWP3.0.5d.v2.c180716_42FLUXNETSITES/cpl_bypass_full'
- co2_file = '$DIN_LOC_ROOT/atm/datm7/CO2/fco2_datm_rcp4.5_1765-2500_c130312.nc'
- aero_file = '$DIN_LOC_ROOT/atm/cam/chem/trop_mozart_aero/aero/aerosoldep_rcp4.5_monthly_1849-2104_1.9x2.5_c100402.nc'
diff --git a/components/elm/cime_config/testdefs/testmods_dirs/elm/ameriflux_cplbypass/shell_commands b/components/elm/cime_config/testdefs/testmods_dirs/elm/ameriflux_cplbypass/shell_commands
deleted file mode 100644
index a610a46fdf..0000000000
--- a/components/elm/cime_config/testdefs/testmods_dirs/elm/ameriflux_cplbypass/shell_commands
+++ /dev/null
@@ -1,10 +0,0 @@
-./xmlchange PIO_VERSION=2
-./xmlchange MOSART_MODE=NULL
-./xmlchange ELM_BLDNML_OPTS=" -bgc bgc -nutrient cn  -nutrient_comp_pathway rd  -soil_decomp ctc  -bgc_spinup on"
-./xmlchange ATM_DOMAIN_PATH=/inputdata/share/domains/domain.clm
-./xmlchange LND_DOMAIN_PATH=/inputdata/share/domains/domain.clm
-./xmlchange ATM_DOMAIN_FILE=domain_lakes.nc
-./xmlchange LND_DOMAIN_FILE=domain_lakes.nc
-./xmlchange -id RUN_STARTDATE -val 0001-01-01
-./xmlchange NTASKS=1
-./xmlchange NTHRDS=1
diff --git a/components/elm/cime_config/testdefs/testmods_dirs/elm/ameriflux_cplbypass/user_nl_elm b/components/elm/cime_config/testdefs/testmods_dirs/elm/ameriflux_cplbypass/user_nl_elm
deleted file mode 100644
index 8e1f0d1d9d..0000000000
--- a/components/elm/cime_config/testdefs/testmods_dirs/elm/ameriflux_cplbypass/user_nl_elm
+++ /dev/null
@@ -1,17 +0,0 @@
-&clm_inparm
- hist_mfilt = 1
- hist_nhtfrq = -1
- hist_empty_htapes = .true.
- hist_dov2xy = .true.
- finidat = ''
- fsurdat = '$DIN_LOC_ROOT/lnd/clm2/surfdata_map/surfdata_lakes.nc'
- paramfile = '$DIN_LOC_ROOT/lnd/clm2/paramdata/clm_params_lakes.nc'
- fsoilordercon = '$DIN_LOC_ROOT/lnd/clm2/paramdata/CNP_parameters_lakes.nc'
- stream_fldfilename_ndep = '$DIN_LOC_ROOT/lnd/clm2/ndepdata/fndep_clm_rcp4.5_simyr1849-2106_1.9x2.5_c100428.nc'
- nyears_ad_carbon_only = 25
- spinup_mortality_factor = 10
- metdata_type = 'gswp3'
- use_lch4 = .false. 
- metdata_bypass = '$DIN_LOC_ROOT/atm/datm7/atm_forcing.datm7.GSWP3.0.5d.v2.c180716_42FLUXNETSITES/cpl_bypass_full'
- co2_file = '$DIN_LOC_ROOT/atm/datm7/CO2/fco2_datm_rcp4.5_1765-2500_c130312.nc'
- aero_file = '$DIN_LOC_ROOT/atm/cam/chem/trop_mozart_aero/aero/aerosoldep_rcp4.5_monthly_1849-2104_1.9x2.5_c100402.nc'
diff --git a/components/elm/cime_config/testdefs/testmods_dirs/elm/sp_cplbypass/shell_commands b/components/elm/cime_config/testdefs/testmods_dirs/elm/sp_cplbypass/shell_commands
deleted file mode 100644
index bc0f650a16..0000000000
--- a/components/elm/cime_config/testdefs/testmods_dirs/elm/sp_cplbypass/shell_commands
+++ /dev/null
@@ -1,10 +0,0 @@
-./xmlchange PIO_VERSION=2
-./xmlchange MOSART_MODE=NULL
-./xmlchange ELM_BLDNML_OPTS=" -bgc sp"
-./xmlchange ATM_DOMAIN_PATH=/inputdata/share/domains/domain.clm
-./xmlchange LND_DOMAIN_PATH=/inputdata/share/domains/domain.clm
-./xmlchange ATM_DOMAIN_FILE=domain_42_FLUXNETSITES_simyr1850_c170912.nc
-./xmlchange LND_DOMAIN_FILE=domain_42_FLUXNETSITES_simyr1850_c170912.nc
-./xmlchange -id RUN_STARTDATE -val 0001-01-01
-./xmlchange NTASKS=1
-./xmlchange NTHRDS=1
diff --git a/components/elm/cime_config/testdefs/testmods_dirs/elm/sp_cplbypass/user_nl_elm b/components/elm/cime_config/testdefs/testmods_dirs/elm/sp_cplbypass/user_nl_elm
deleted file mode 100644
index 316879062e..0000000000
--- a/components/elm/cime_config/testdefs/testmods_dirs/elm/sp_cplbypass/user_nl_elm
+++ /dev/null
@@ -1,16 +0,0 @@
-&clm_inparm
- hist_mfilt = 1
- hist_nhtfrq = -1
- hist_empty_htapes = .true.
- hist_dov2xy = .true.
- finidat = ''
- fsurdat = '$DIN_LOC_ROOT/lnd/clm2/surfdata_map/surfdata_42_FLUXNETSITES_simyr1850_c170912.nc'
- paramfile = '$DIN_LOC_ROOT/lnd/clm2/paramdata/clm_params_amflx_cplbypass.nc'
- fsoilordercon = '$DIN_LOC_ROOT/lnd/clm2/paramdata/CNP_parameters_amflx_cplbypass.nc'
- nyears_ad_carbon_only = 25
- spinup_mortality_factor = 10
- metdata_type = 'gswp3'
- use_lch4 = .false. 
- metdata_bypass = '$DIN_LOC_ROOT/atm/datm7/atm_forcing.datm7.GSWP3.0.5d.v2.c180716_42FLUXNETSITES/cpl_bypass_full'
- co2_file = '$DIN_LOC_ROOT/atm/datm7/CO2/fco2_datm_rcp4.5_1765-2500_c130312.nc'
- aero_file = '$DIN_LOC_ROOT/atm/cam/chem/trop_mozart_aero/aero/aerosoldep_rcp4.5_monthly_1849-2104_1.9x2.5_c100402.nc'
diff --git a/components/elm/src/biogeochem/AllocationMod.F90 b/components/elm/src/biogeochem/AllocationMod.F90
index 7252d92618..f6665a0bca 100644
--- a/components/elm/src/biogeochem/AllocationMod.F90
+++ b/components/elm/src/biogeochem/AllocationMod.F90
@@ -1,4 +1,5 @@
 module AllocationMod
+
   !-----------------------------------------------------------------------
   ! !DESCRIPTION:
   ! Module holding routines used in allocation model for coupled carbon
@@ -13,13 +14,13 @@ module AllocationMod
   use elm_varctl          , only : use_fates
   use abortutils          , only : endrun
   use decompMod           , only : bounds_type
-  use subgridAveMod       , only : p2c, p2c_1d_filter_parallel
+  use subgridAveMod       , only : p2c
   use CanopyStateType     , only : canopystate_type
   !!! add phosphorus
-  use CNStateType               , only : cnstate_type
-  use PhotosynthesisType        , only : photosyns_type
-  use CropType                  , only : crop_type
-  use VegetationPropertiesType  , only : veg_vp
+  use CNStateType                   , only : cnstate_type
+  use PhotosynthesisType            , only : photosyns_type
+  use CropType                      , only : crop_type
+  use VegetationPropertiesType      , only : veg_vp
   use LandunitType        , only : lun_pp
   use ColumnType          , only : col_pp
   use ColumnDataType      , only : col_ws
@@ -33,9 +34,9 @@ module AllocationMod
   use elm_varctl          , only : nu_com
   use SoilStatetype       , only : soilstate_type
   use elm_varctl          , only : NFIX_PTASE_plant
-  !!!!!use ELMFatesInterfaceMod  , only : hlm_fates_interface_type
+  use ELMFatesInterfaceMod  , only : hlm_fates_interface_type
   use elm_varctl      , only: iulog
-  use shr_infnan_mod  , only: nan => shr_infnan_nan 
+  use shr_infnan_mod  , only: nan => shr_infnan_nan, assignment(=)
   
   !
   implicit none
@@ -43,8 +44,6 @@ module AllocationMod
   ! pflotran
   private :: calc_nuptake_prof
   private :: calc_puptake_prof
-  private :: NAllocationRD
-  private :: PAllocationRD
   !
   ! !PUBLIC MEMBER FUNCTIONS:
   public :: readCNAllocParams
@@ -122,9 +121,6 @@ module AllocationMod
   !$acc declare create(e_plant_scalar)
   
   !$acc declare copyin(crop_supln)
-  !!!!$acc declare create(filter_pcomp(:))
-  !$acc declare create(veg_rootc_bigleaf(:,:))
-  !$acc declare create(ft_index_bigleaf)
   !-----------------------------------------------------------------------
 
 contains
@@ -197,7 +193,7 @@ contains
   end subroutine readCNAllocParams
 
   !-----------------------------------------------------------------------
-  subroutine AllocationInit ( bounds)
+  subroutine AllocationInit ( bounds, elm_fates)
     !
     ! !DESCRIPTION:
     !
@@ -206,17 +202,17 @@ contains
     use clm_time_manager, only: get_step_size, get_curr_date
     use elm_varpar      , only: crop_prog
     use elm_varctl      , only: iulog
-    use elm_varctl      , only : carbon_only
-    use elm_varctl      , only : carbonnitrogen_only
+    use elm_varctl      , only : carbon_only          
+    use elm_varctl      , only : carbonnitrogen_only  
     use elm_varctl      , only : carbonphosphorus_only
+
+
     use elm_varpar      , only: nlevdecomp
-    use shr_infnan_mod  , only : nan => shr_infnan_nan, assignment(=),isnan => shr_infnan_isnan
-    
     !
     ! !ARGUMENTS:
     implicit none
     type(bounds_type), intent(in) :: bounds
-    !#fates_py type(hlm_fates_interface_type), intent(in) :: elm_fates  ! This will be needed in soon
+    type(hlm_fates_interface_type), intent(in) :: elm_fates  ! This will be needed in soon
                                                              ! to be released features
     !
     ! !LOCAL VARIABLES:
@@ -227,6 +223,9 @@ contains
     integer :: max_comps  ! maximum number of possible plant competitors
     ! elm big-leaf: number of pfts/patches
     ! fates: number of cohorts in the column
+    
+
+    
     !-----------------------------------------------------------------------
 
     if ( crop_prog )then
@@ -236,18 +235,6 @@ contains
 
     ! Allocate scratch space for ECA and FATES/ECA
 
-    if (nu_com .eq. 'ECA' .or. nu_com .eq. 'MIC') then
-       if (use_fates) then
-       else
-          max_comps = bounds%endp-bounds%begp+1
-          !allocate(filter_pcomp(max_comps)); filter_pcomp(:) = -1
-          allocate(ft_index_bigleaf(bounds%begp:bounds%endp)); ft_index_bigleaf(bounds%begp:bounds%endp) = -1
-          allocate(veg_rootc_bigleaf(bounds%begp:bounds%endp,1:nlevdecomp)); veg_rootc_bigleaf(bounds%begp:bounds%endp,1:nlevdecomp) = nan
-       end if
-    end if
-
-    ! Allocate scratch space for ECA and FATES/ECA
-
     if (nu_com .eq. 'ECA' .or. nu_com .eq. 'MIC') then
        if (.not.use_fates) then
           allocate(ft_index_bigleaf(bounds%begp:bounds%endp)); ft_index_bigleaf(bounds%begp:bounds%endp) = -1
@@ -330,27 +317,29 @@ contains
     if (spinup_state == 1 .and. yr .le. nyears_ad_carbon_only) then
       Carbon_only = .true.
      end if
-     write(iulog,*) "CNP variables: "
-     write(iulog,*) "carbon only:",carbon_only 
-     write(iulog,*) "CP only: ", carbonphosphorus_only
-     write(iulog,*) "CN only :", carbonnitrogen_only 
      !$acc update device(carbon_only, carbonnitrogen_only,&
      !$acc carbonphosphorus_only)
 
   end subroutine AllocationInit
 
 !-------------------------------------------------------------------------------------------------
-  subroutine Allocation1_PlantNPDemand (num_soilc, filter_soilc, num_soilp, filter_soilp, &
+  subroutine Allocation1_PlantNPDemand (bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
        photosyns_vars, crop_vars, canopystate_vars, cnstate_vars, dt, yr)
     ! PHASE-1 of Allocation: loop over patches to assess the total plant N demand and P demand
     ! !USES:
-    use elm_varctl, only : carbon_only
-    use elm_varctl, only : carbonnitrogen_only
-    use elm_varctl, only : carbonphosphorus_only
-    use elm_varpar, only : nlevdecomp
-    use elm_varcon, only : nitrif_n2o_loss_frac, secspday
+    !$acc routine seq
+    use elm_varctl       , only: iulog
+    use elm_varctl      , only : carbon_only          !
+    use elm_varctl      , only : carbonnitrogen_only  !
+    use elm_varctl      , only : carbonphosphorus_only!
+    use pftvarcon        , only: npcropmin, declfact, bfact, aleaff, arootf, astemf, noveg
+    use pftvarcon        , only: arooti, fleafi, allconsl, allconss, grperc, grpnow, nsoybean
+    use pftvarcon        , only: percrop
+    use elm_varpar       , only: nlevdecomp
+    use elm_varcon       , only: nitrif_n2o_loss_frac, secspday
     !
     ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc        ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:)  ! filter for soil columns
     integer                  , intent(in)    :: num_soilp        ! number of soil patches in filter
@@ -364,157 +353,92 @@ contains
     !
     ! !LOCAL VARIABLES:
     !
-    integer :: c,p,l,j        !indices
-    integer :: fp             !lake filter pft index
-    integer :: fc             !lake filter column index
-    real(r8):: nuptake_prof(num_soilc, 1:nlevdecomp)
-    real(r8):: puptake_prof(num_soilc, 1:nlevdecomp)
-    !-----------------------------------------------------------------------
-    associate(                &
-         nfixation_prof               => cnstate_vars%nfixation_prof_col , &
-         smin_no3_vr                  => col_ns%smin_no3_vr              , & ! Input: [real(r8) (:,:) ]  (gN/m3) soil mineral NO3
-         smin_nh4_vr                  => col_ns%smin_nh4_vr              , & ! Input: [real(r8) (:,:) ]  (gN/m3) soil mineral NH4
-         solutionp_vr                 => col_ps%solutionp_vr       , & ! Input:  [real(r8) (:,:) ]  (gP/m3) soil mineral P
-         plant_pdemand_col            => col_pf%plant_pdemand      , & ! Output:  [real(r8) (:,:) ]
-         plant_ndemand_col            => col_nf%plant_ndemand      , & ! Output:  [real(r8) (:,:) ]
-         plant_ndemand_vr_col         => col_nf%plant_ndemand_vr   , & ! Output:  [real(r8) (:,:) ]
-         plant_pdemand_vr_col         => col_pf%plant_pdemand_vr   , & ! Output:  [real(r8) (:,:) ]
-         plant_ndemand                => veg_nf%plant_ndemand      , & ! Output: [real(r8) (:)   ]  N flux required to support initial GPP (gN/m2/s)
-         plant_pdemand                => veg_pf%plant_pdemand        & ! Output: [real(r8) (:)   ]  P flux required to support initial GPP (gP/m2/s)
-         )
-
-      ! set time steps
-      if (spinup_state == 1 .and. yr .gt. nyears_ad_carbon_only) then
-         !$acc serial default(present)
-         carbon_only = .false.
-         !$acc end serial
-      end if
+    integer :: c,p,l,j                                               !indices
+    integer :: fp                                                    !lake filter pft index
+    integer :: fc                                                    !lake filter column index
+    real(r8):: mr                                                    !maintenance respiration (gC/m2/s)
+    real(r8):: f1,f2,f3,f4,g1,g2                                     !allocation parameters
+    real(r8):: cnl,cnfr,cnlw,cndw                                    !C:N ratios for leaf, fine root, and wood
 
-     ! loop over patches to assess the total plant N demand and P demand
-      call TotalNPDemand(num_soilp, filter_soilp, photosyns_vars, &
-                canopystate_vars, crop_vars, cnstate_vars, dt)
-      ! now use the p2c routine to get the column-averaged plant_ndemand
-      call p2c_1d_filter_parallel( num_soilc, filter_soilc, &
-           plant_ndemand,  plant_ndemand_col)
-
-      !!! add phosphorus
-      call p2c_1d_filter_parallel( num_soilc, filter_soilc, &
-           plant_pdemand, plant_pdemand_col)
-
-   !!! Starting resolving N limitation
-      ! pflotran will need an input from CN: modified 'sum_ndemand_vr' ('potential_immob' excluded).
-      if (use_elm_interface.and.use_pflotran .and. pf_cmode) then
-         !! new subroutines to calculate nuptake_prof & puptake_prof
-         if (nu_com .eq. 'RD') then ! 'RD' : relative demand approach
-            call calc_nuptake_prof(num_soilc, filter_soilc, cnstate_vars, nuptake_prof)
-            call calc_puptake_prof(num_soilc, filter_soilc, cnstate_vars, puptake_prof)
-         end if
-            
-            do j = 1, nlevdecomp
-               do fc=1, num_soilc
-                  c = filter_soilc(fc)
-                  plant_ndemand_vr_col(c,j) = plant_ndemand_col(c) * nuptake_prof(fc,j)
-                  plant_pdemand_vr_col(c,j) = plant_pdemand_col(c) * puptake_prof(fc,j)
-               end do
-            end do
-      endif
+    real(r8):: curmr, curmr_ratio                                    !xsmrpool temporary variables
+    real(r8):: nuptake_prof(bounds%begc:bounds%endc, 1:nlevdecomp)
 
-    end associate
+    real(r8) f5                                                      !grain allocation parameter
+    real(r8) cng                                                     !C:N ratio for grain (= cnlw for now; slevis)
+    real(r8) fleaf                                                   !fraction allocated to leaf
+    real(r8) t1                                                      !temporary variable
 
- end subroutine Allocation1_PlantNPDemand
+    !! Local P variables
+    real(r8):: cpl,cpfr,cplw,cpdw,cpg                                    !C:N ratios for leaf, fine root, and wood
+    real(r8):: puptake_prof(bounds%begc:bounds%endc, 1:nlevdecomp)
 
- subroutine TotalNPDemand(num_soilp,filter_soilp, photosyns_vars, &
-            canopystate_vars, crop_vars, cnstate_vars, dt)
-    use pftvarcon   , only: npcropmin, declfact, bfact, aleaff, arootf, astemf, noveg
-    use pftvarcon   , only: arooti, fleafi, allconsl, allconss, grperc, grpnow, nsoybean
-    use elm_varpar  , only: nlevdecomp
-    use elm_varcon  , only: nitrif_n2o_loss_frac, secspday
-    !!
-    integer  ,intent(in) :: num_soilp
-    integer , intent(in) :: filter_soilp(:)
-    type(photosyns_type)  , intent(in) :: photosyns_vars
-    type(canopystate_type), intent(in) :: canopystate_vars
-    type(crop_type)       , intent(in) :: crop_vars
-    type(cnstate_type)    , intent(inout) :: cnstate_vars
-    real(r8) , intent(in) :: dt
-    !! Local Variables
-    real(r8):: f5               !grain allocation parameter
-    real(r8):: cng              !C:N ratio for grain (= cnlw for now; slevis)
-    real(r8):: fleaf            !fraction allocated to leaf
-    real(r8):: t1               !temporary variable
-    real(r8):: mr                  !maintenance respiration (gC/m2/s)
-    real(r8):: f1,f2,f3,f4,g1,g2   !allocation parameters
-    real(r8):: cnl,cnfr,cnlw,cndw  !C:N ratios for leaf, fine root, and wood
-
-    real(r8):: curmr, curmr_ratio  !xsmrpool temporary variables
 
-    !! Local P variables
-    real(r8):: cpl,cpfr,cplw,cpdw,cpg  !C:N ratios for leaf, fine root, and wood
+  !-----------------------------------------------------------------------
 
-    integer :: ivt, fp, p
-    !-----------------------------------------------------------------------
     associate(                                                                                   &
-         woody                        => veg_vp%woody               , & ! Input:  [real(r8) (:)   ]  binary flag for woody lifeform (1=woody, 0=not woody)
-         froot_leaf                   => veg_vp%froot_leaf          , & ! Input:  [real(r8) (:)   ]  allocation parameter: new fine root C per new leaf C (gC/gC)
-         croot_stem                   => veg_vp%croot_stem          , & ! Input:  [real(r8) (:)   ]  allocation parameter: new coarse root C per new stem C (gC/gC)
-         stem_leaf                    => veg_vp%stem_leaf           , & ! Input:  [real(r8) (:)   ]  allocation parameter: new stem c per new leaf C (gC/gC)
-         flivewd                      => veg_vp%flivewd             , & ! Input:  [real(r8) (:)   ]  allocation parameter: fraction of new wood that is live (phloem and ray parenchyma) (no units)
-         leafcn                       => veg_vp%leafcn              , & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
-         frootcn                      => veg_vp%frootcn             , & ! Input:  [real(r8) (:)   ]  fine root C:N (gC/gN)
-         livewdcn                     => veg_vp%livewdcn            , & ! Input:  [real(r8) (:)   ]  live wood (phloem and ray parenchyma) C:N (gC/gN)
-         deadwdcn                     => veg_vp%deadwdcn            , & ! Input:  [real(r8) (:)   ]  dead wood (xylem and heartwood) C:N (gC/gN)
-         graincn                      => veg_vp%graincn             , & ! Input:  [real(r8) (:)   ]  grain C:N (gC/gN)
-         fleafcn                      => veg_vp%fleafcn             , & ! Input:  [real(r8) (:)   ]  leaf c:n during organ fill
-         ffrootcn                     => veg_vp%ffrootcn            , & ! Input:  [real(r8) (:)   ]  froot c:n during organ fill
-         fstemcn                      => veg_vp%fstemcn             , & ! Input:  [real(r8) (:)   ]  stem c:n during organ fill
-
-         psnsun                       => photosyns_vars%psnsun_patch        , & ! Input:  [real(r8) (:)   ]  sunlit leaf-level photosynthesis (umol CO2 /m**2/ s)
-         psnsha                       => photosyns_vars%psnsha_patch        , & ! Input:  [real(r8) (:)   ]  shaded leaf-level photosynthesis (umol CO2 /m**2/ s)
-         c13_psnsun                   => photosyns_vars%c13_psnsun_patch    , & ! Input:  [real(r8) (:)   ]  sunlit leaf-level photosynthesis (umol CO2 /m**2/ s)
-         c13_psnsha                   => photosyns_vars%c13_psnsha_patch    , & ! Input:  [real(r8) (:)   ]  shaded leaf-level photosynthesis (umol CO2 /m**2/ s)
-         c14_psnsun                   => photosyns_vars%c14_psnsun_patch    , & ! Input:  [real(r8) (:)   ]  sunlit leaf-level photosynthesis (umol CO2 /m**2/ s)
-         c14_psnsha                   => photosyns_vars%c14_psnsha_patch    , & ! Input:  [real(r8) (:)   ]  shaded leaf-level photosynthesis (umol CO2 /m**2/ s)
-
-         laisun                       => canopystate_vars%laisun_patch      , & ! Input:  [real(r8) (:)   ]  sunlit projected leaf area index
-         laisha                       => canopystate_vars%laisha_patch      , & ! Input:  [real(r8) (:)   ]  shaded projected leaf area index
-
-         hui                          => crop_vars%gddplant_patch           , & ! Input:  [real(r8) (:)   ]  =gdd since planting (gddplant)
-         leafout                      => crop_vars%gddtsoi_patch            , & ! Input:  [real(r8) (:)   ]  =gdd from top soil layer temperature
-
-         xsmrpool                     => veg_cs%xsmrpool                    , & ! Input:  [real(r8) (:)   ]  (gC/m2) temporary photosynthate C pool
-         leafc                        => veg_cs%leafc                       , & ! Input:  [real(r8) (:)   ]
-         frootc                       => veg_cs%frootc                      , & ! Input:  [real(r8) (:)   ]
-         livestemc                    => veg_cs%livestemc                   , & ! Input:  [real(r8) (:)   ]
-         plant_ndemand_col            => col_nf%plant_ndemand               , & ! Output:  [real(r8) (:,:) ]
+         ivt                          => veg_pp%itype                                             , & ! Input:  [integer  (:) ]  pft vegetation type
+
+         woody                        => veg_vp%woody                                      , & ! Input:  [real(r8) (:)   ]  binary flag for woody lifeform (1=woody, 0=not woody)
+         froot_leaf                   => veg_vp%froot_leaf                                 , & ! Input:  [real(r8) (:)   ]  allocation parameter: new fine root C per new leaf C (gC/gC)
+         croot_stem                   => veg_vp%croot_stem                                 , & ! Input:  [real(r8) (:)   ]  allocation parameter: new coarse root C per new stem C (gC/gC)
+         stem_leaf                    => veg_vp%stem_leaf                                  , & ! Input:  [real(r8) (:)   ]  allocation parameter: new stem c per new leaf C (gC/gC)
+         flivewd                      => veg_vp%flivewd                                    , & ! Input:  [real(r8) (:)   ]  allocation parameter: fraction of new wood that is live (phloem and ray parenchyma) (no units)
+         leafcn                       => veg_vp%leafcn                                     , & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
+         frootcn                      => veg_vp%frootcn                                    , & ! Input:  [real(r8) (:)   ]  fine root C:N (gC/gN)
+         livewdcn                     => veg_vp%livewdcn                                   , & ! Input:  [real(r8) (:)   ]  live wood (phloem and ray parenchyma) C:N (gC/gN)
+         deadwdcn                     => veg_vp%deadwdcn                                   , & ! Input:  [real(r8) (:)   ]  dead wood (xylem and heartwood) C:N (gC/gN)
+         graincn                      => veg_vp%graincn                                    , & ! Input:  [real(r8) (:)   ]  grain C:N (gC/gN)
+         fleafcn                      => veg_vp%fleafcn                                    , & ! Input:  [real(r8) (:)   ]  leaf c:n during organ fill
+         ffrootcn                     => veg_vp%ffrootcn                                   , & ! Input:  [real(r8) (:)   ]  froot c:n during organ fill
+         fstemcn                      => veg_vp%fstemcn                                    , & ! Input:  [real(r8) (:)   ]  stem c:n during organ fill
+
+         psnsun                       => photosyns_vars%psnsun_patch                           , & ! Input:  [real(r8) (:)   ]  sunlit leaf-level photosynthesis (umol CO2 /m**2/ s)
+         psnsha                       => photosyns_vars%psnsha_patch                           , & ! Input:  [real(r8) (:)   ]  shaded leaf-level photosynthesis (umol CO2 /m**2/ s)
+         c13_psnsun                   => photosyns_vars%c13_psnsun_patch                       , & ! Input:  [real(r8) (:)   ]  sunlit leaf-level photosynthesis (umol CO2 /m**2/ s)
+         c13_psnsha                   => photosyns_vars%c13_psnsha_patch                       , & ! Input:  [real(r8) (:)   ]  shaded leaf-level photosynthesis (umol CO2 /m**2/ s)
+         c14_psnsun                   => photosyns_vars%c14_psnsun_patch                       , & ! Input:  [real(r8) (:)   ]  sunlit leaf-level photosynthesis (umol CO2 /m**2/ s)
+         c14_psnsha                   => photosyns_vars%c14_psnsha_patch                       , & ! Input:  [real(r8) (:)   ]  shaded leaf-level photosynthesis (umol CO2 /m**2/ s)
+
+         laisun                       => canopystate_vars%laisun_patch                         , & ! Input:  [real(r8) (:)   ]  sunlit projected leaf area index
+         laisha                       => canopystate_vars%laisha_patch                         , & ! Input:  [real(r8) (:)   ]  shaded projected leaf area index
+
+         hui                          => crop_vars%gddplant_patch                              , & ! Input:  [real(r8) (:)   ]  =gdd since planting (gddplant)
+         leafout                      => crop_vars%gddtsoi_patch                               , & ! Input:  [real(r8) (:)   ]  =gdd from top soil layer temperature
+
+         xsmrpool                     => veg_cs%xsmrpool                       , & ! Input:  [real(r8) (:)   ]  (gC/m2) temporary photosynthate C pool
+         leafc                        => veg_cs%leafc                          , & ! Input:  [real(r8) (:)   ]
+         frootc                       => veg_cs%frootc                         , & ! Input:  [real(r8) (:)   ]
+         livestemc                    => veg_cs%livestemc                      , & ! Input:  [real(r8) (:)   ]
+         plant_ndemand_col            => col_nf%plant_ndemand                 , & ! Output:  [real(r8) (:,:) ]
          plant_pdemand_col            => col_pf%plant_pdemand               , & ! Output:  [real(r8) (:,:) ]
-         plant_ndemand_vr_col         => col_nf%plant_ndemand_vr            , & ! Output:  [real(r8) (:,:) ]
+         plant_ndemand_vr_col         => col_nf%plant_ndemand_vr              , & ! Output:  [real(r8) (:,:) ]
          plant_pdemand_vr_col         => col_pf%plant_pdemand_vr            , & ! Output:  [real(r8) (:,:) ]
 
-         gddmaturity                  => cnstate_vars%gddmaturity_patch      , & ! Input:  [real(r8) (:)   ]  gdd needed to harvest
-         huileaf                      => cnstate_vars%huileaf_patch          , & ! Input:  [real(r8) (:)   ]  heat unit index needed from planting to leaf emergence
-         huigrain                     => cnstate_vars%huigrain_patch         , & ! Input:  [real(r8) (:)   ]  same to reach vegetative maturity
-         croplive                     => crop_vars%croplive_patch            , & ! Input:  [logical  (:)   ]  flag, true if planted, not harvested
-         peaklai                      => cnstate_vars%peaklai_patch          , & ! Input:  [integer  (:)   ]  1: max allowed lai; 0: not at max
-         !lgsf                        => cnstate_vars%lgsf_patch             , & ! Input:  [real(r8) (:)   ]  long growing season factor [0-1]
-         aleafi                       => cnstate_vars%aleafi_patch           , & ! Output: [real(r8) (:)   ]  saved allocation coefficient from phase 2
-         astemi                       => cnstate_vars%astemi_patch           , & ! Output: [real(r8) (:)   ]  saved allocation coefficient from phase 2
-         aleaf                        => cnstate_vars%aleaf_patch            , & ! Output: [real(r8) (:)   ]  leaf allocation coefficient
-         astem                        => cnstate_vars%astem_patch            , & ! Output: [real(r8) (:)   ]  stem allocation coefficient
+         gddmaturity                  => cnstate_vars%gddmaturity_patch                        , & ! Input:  [real(r8) (:)   ]  gdd needed to harvest
+         huileaf                      => cnstate_vars%huileaf_patch                            , & ! Input:  [real(r8) (:)   ]  heat unit index needed from planting to leaf emergence
+         huigrain                     => cnstate_vars%huigrain_patch                           , & ! Input:  [real(r8) (:)   ]  same to reach vegetative maturity
+         croplive                     => crop_vars%croplive_patch                           , & ! Input:  [logical  (:)   ]  flag, true if planted, not harvested
+         peaklai                      => cnstate_vars%peaklai_patch                            , & ! Input:  [integer  (:)   ]  1: max allowed lai; 0: not at max
+         !lgsf                        => cnstate_vars%lgsf_patch                               , & ! Input:  [real(r8) (:)   ]  long growing season factor [0-1]
+         aleafi                       => cnstate_vars%aleafi_patch                             , & ! Output: [real(r8) (:)   ]  saved allocation coefficient from phase 2
+         astemi                       => cnstate_vars%astemi_patch                             , & ! Output: [real(r8) (:)   ]  saved allocation coefficient from phase 2
+         aleaf                        => cnstate_vars%aleaf_patch                              , & ! Output: [real(r8) (:)   ]  leaf allocation coefficient
+         astem                        => cnstate_vars%astem_patch                              , & ! Output: [real(r8) (:)   ]  stem allocation coefficient
 
          !!! add phosphorus
-         leafcp                       => veg_vp%leafcp              , & ! Input:  [real(r8) (:)   ]  leaf C:P (gC/gP)
-         frootcp                      => veg_vp%frootcp             , & ! Input:  [real(r8) (:)   ]  fine root C:P (gC/gP)
-         livewdcp                     => veg_vp%livewdcp            , & ! Input:  [real(r8) (:)   ]  live wood (phloem and ray parenchyma) C:P (gC/gP)
-         deadwdcp                     => veg_vp%deadwdcp            , & ! Input:  [real(r8) (:)   ]  dead wood (xylem and heartwood) C:P (gC/gP)
-         graincp                      => veg_vp%graincp             , & ! Input:  [real(r8) (:)   ]  grain C:P (gC/gP)
-
-         grain_flag                   => cnstate_vars%grain_flag_patch              , & ! Output: [real(r8) (:)   ]  1: grain fill stage; 0: not
-         c_allometry                  => cnstate_vars%c_allometry_patch             , & ! Output: [real(r8) (:)   ]  C allocation index (DIM)
-         n_allometry                  => cnstate_vars%n_allometry_patch             , & ! Output: [real(r8) (:)   ]  N allocation index (DIM)
-         tempsum_potential_gpp        => cnstate_vars%tempsum_potential_gpp_patch   , & ! Output: [real(r8) (:)   ]  temporary annual sum of potential GPP
-         tempmax_retransn             => cnstate_vars%tempmax_retransn_patch        , & ! Output: [real(r8) (:)   ]  temporary annual max of retranslocated N pool (gN/m2)
-         annsum_potential_gpp         => cnstate_vars%annsum_potential_gpp_patch    , & ! Output: [real(r8) (:)   ]  annual sum of potential GPP
-         annmax_retransn              => cnstate_vars%annmax_retransn_patch         , & ! Output: [real(r8) (:)   ]  annual max of retranslocated N pool
+         leafcp                       => veg_vp%leafcp                                     , & ! Input:  [real(r8) (:)   ]  leaf C:P (gC/gP)
+         frootcp                      => veg_vp%frootcp                                    , & ! Input:  [real(r8) (:)   ]  fine root C:P (gC/gP)
+         livewdcp                     => veg_vp%livewdcp                                   , & ! Input:  [real(r8) (:)   ]  live wood (phloem and ray parenchyma) C:P (gC/gP)
+         deadwdcp                     => veg_vp%deadwdcp                                   , & ! Input:  [real(r8) (:)   ]  dead wood (xylem and heartwood) C:P (gC/gP)
+         graincp                      => veg_vp%graincp                                    , & ! Input:  [real(r8) (:)   ]  grain C:P (gC/gP)
+
+         grain_flag                   => cnstate_vars%grain_flag_patch                         , & ! Output: [real(r8) (:)   ]  1: grain fill stage; 0: not
+         c_allometry                  => cnstate_vars%c_allometry_patch                        , & ! Output: [real(r8) (:)   ]  C allocation index (DIM)
+         n_allometry                  => cnstate_vars%n_allometry_patch                        , & ! Output: [real(r8) (:)   ]  N allocation index (DIM)
+         tempsum_potential_gpp        => cnstate_vars%tempsum_potential_gpp_patch              , & ! Output: [real(r8) (:)   ]  temporary annual sum of potential GPP
+         tempmax_retransn             => cnstate_vars%tempmax_retransn_patch                   , & ! Output: [real(r8) (:)   ]  temporary annual max of retranslocated N pool (gN/m2)
+         annsum_potential_gpp         => cnstate_vars%annsum_potential_gpp_patch               , & ! Output: [real(r8) (:)   ]  annual sum of potential GPP
+         annmax_retransn              => cnstate_vars%annmax_retransn_patch                    , & ! Output: [real(r8) (:)   ]  annual max of retranslocated N pool
 
          leaf_mr                      => veg_cf%leaf_mr                         , & ! Input:  [real(r8) (:)   ]
          froot_mr                     => veg_cf%froot_mr                        , & ! Input:  [real(r8) (:)   ]
@@ -553,385 +477,477 @@ contains
          retransp                     => veg_ps%retransp                   , & ! Input:  [real(r8) (:)   ]  (gP/m2) plant pool of retranslocated P
 
          plant_pdemand                => veg_pf%plant_pdemand               , & ! Output: [real(r8) (:)   ]  P flux required to support initial GPP (gP/m2/s)
+         plant_palloc                 => veg_pf%plant_palloc                , & ! Output: [real(r8) (:)   ]  total allocated P flux (gP/m2/s)
          avail_retransp               => veg_pf%avail_retransp              , & ! Output: [real(r8) (:)   ]  P flux available from retranslocation pool (gP/m2/s)
          retransp_to_ppool            => veg_pf%retransp_to_ppool           , & ! Output: [real(r8) (:)   ]  deployment of retranslocated P (gP/m2/s)
-         p_allometry                  => cnstate_vars%p_allometry_patch        , & ! Output: [real(r8) (:)   ]  P allocation index (DIM)
-         tempmax_retransp             => cnstate_vars%tempmax_retransp_patch   , & ! Output: [real(r8) (:)   ]  temporary annual max of retranslocated P pool (gP/m2)
-         annmax_retransp              => cnstate_vars%annmax_retransp_patch    , & ! Output: [real(r8) (:)   ]  annual max of retranslocated P pool
-         km_plant_p                   => veg_vp%km_plant_p                     , &
-         nfixation_prof               => cnstate_vars%nfixation_prof_col , &
-         smin_no3_vr                  => col_ns%smin_no3_vr              , & ! Input: [real(r8) (:,:) ]  (gN/m3) soil mineral NO3
-         smin_nh4_vr                  => col_ns%smin_nh4_vr              , & ! Input: [real(r8) (:,:) ]  (gN/m3) soil mineral NH4
-         solutionp_vr                 => col_ps%solutionp_vr               , & ! Input:  [real(r8) (:,:) ]  (gP/m3) soil mineral P
+         p_allometry                  => cnstate_vars%p_allometry_patch                        , & ! Output: [real(r8) (:)   ]  P allocation index (DIM)
+         tempmax_retransp             => cnstate_vars%tempmax_retransp_patch                   , & ! Output: [real(r8) (:)   ]  temporary annual max of retranslocated P pool (gP/m2)
+         annmax_retransp              => cnstate_vars%annmax_retransp_patch                    , & ! Output: [real(r8) (:)   ]  annual max of retranslocated P pool
+         km_plant_p                   => veg_vp%km_plant_p                                 , &
          benefit_pgpp_pleafc          => veg_ns%benefit_pgpp_pleafc     &
          )
 
-      !$acc parallel loop independent gang vector default(present) 
-      do fp = 1, num_soilp 
-         p = filter_soilp(fp) 
-         ivt = veg_pp%itype(p)
-        ! The input psn (psnsun and psnsha) are expressed per unit LAI
-        ! in the sunlit and shaded canopy, respectively. These need to be
-        ! scaled by laisun and laisha to get the total gpp for allocation
+      ! set time steps
+      if (spinup_state == 1 .and. yr .gt. nyears_ad_carbon_only) then
+         carbon_only = .false.
+      end if
 
-        ! Note that no associate statement is used for the isotope carbon fluxes below
-        ! since they are not always allocated AND nag compiler will complain if you try to
-        ! to have an associate statement with unallocated memory
+     ! loop over patches to assess the total plant N demand and P demand
+      do fp=1,num_soilp
+         p = filter_soilp(fp)
 
-        psnsun_to_cpool(p)   = psnsun(p) * laisun(p) * 12.011e-6_r8
-        psnshade_to_cpool(p) = psnsha(p) * laisha(p) * 12.011e-6_r8
+         ! get the time step total gross photosynthesis
+         ! this is coming from the canopy fluxes code, and is the
+         ! gpp that is used to control stomatal conductance.
+         ! For the nitrogen downregulation code, this is assumed
+         ! to be the potential gpp, and the actual gpp will be
+         ! reduced due to N limitation.
 
-        if ( use_c13 ) then
-           c13_veg_cf%psnsun_to_cpool(p)   = c13_psnsun(p) * laisun(p) * 12.011e-6_r8
-           c13_veg_cf%psnshade_to_cpool(p) = c13_psnsha(p) * laisha(p) * 12.011e-6_r8
-        endif
+         ! Convert psn from umol/m2/s -> gC/m2/s
 
-        if ( use_c14 ) then
-           c14_veg_cf%psnsun_to_cpool(p)   = c14_psnsun(p) * laisun(p) * 12.011e-6_r8
-           c14_veg_cf%psnshade_to_cpool(p) = c14_psnsha(p) * laisha(p) * 12.011e-6_r8
-        endif
+         ! The input psn (psnsun and psnsha) are expressed per unit LAI
+         ! in the sunlit and shaded canopy, respectively. These need to be
+         ! scaled by laisun and laisha to get the total gpp for allocation
 
-        gpp(p) = psnsun_to_cpool(p) + psnshade_to_cpool(p)
+         ! Note that no associate statement is used for the isotope carbon fluxes below
+         ! since they are not always allocated AND nag compiler will complain if you try to
+         ! to have an associate statement with unallocated memory
 
-        ! carbon return of leaf C investment
-        benefit_pgpp_pleafc(p) = max(gpp(p)  / max(leafc(p),1e-20_r8), 0.0_r8)
+         psnsun_to_cpool(p)   = psnsun(p) * laisun(p) * 12.011e-6_r8
+         psnshade_to_cpool(p) = psnsha(p) * laisha(p) * 12.011e-6_r8
 
-        ! get the time step total maintenance respiration
-        ! These fluxes should already be in gC/m2/s
+         if ( use_c13 ) then
+            c13_veg_cf%psnsun_to_cpool(p)   = c13_psnsun(p) * laisun(p) * 12.011e-6_r8
+            c13_veg_cf%psnshade_to_cpool(p) = c13_psnsha(p) * laisha(p) * 12.011e-6_r8
+         endif
 
-        mr = leaf_mr(p) + froot_mr(p)
-        if (woody(ivt) == 1.0_r8) then
-           mr = mr + livestem_mr(p) + livecroot_mr(p)
-        else if (ivt >= npcropmin) then
-           if (croplive(p)) mr = mr + livestem_mr(p) + grain_mr(p)
-        end if
+         if ( use_c14 ) then
+            c14_veg_cf%psnsun_to_cpool(p)   = c14_psnsun(p) * laisun(p) * 12.011e-6_r8
+            c14_veg_cf%psnshade_to_cpool(p) = c14_psnsha(p) * laisha(p) * 12.011e-6_r8
+         endif
 
-        ! carbon flux available for allocation
-        availc(p) = gpp(p) - mr
+         gpp(p) = psnsun_to_cpool(p) + psnshade_to_cpool(p)
 
-        ! new code added for isotope calculations, 7/1/05, PET
-        ! If mr > gpp, then some mr comes from gpp, the rest comes from
-        ! cpool (xsmr)
-        if (mr > 0._r8 .and. availc(p) < 0._r8) then
-           curmr = gpp(p)
-           curmr_ratio = curmr / mr
-        else
-           curmr_ratio = 1._r8
-        end if
+         ! carbon return of leaf C investment
+         benefit_pgpp_pleafc(p) = max(gpp(p)  / max(leafc(p),1e-20_r8), 0.0_r8)
 
-        leaf_curmr(p) = leaf_mr(p) * curmr_ratio
-        leaf_xsmr(p) = leaf_mr(p) - leaf_curmr(p)
-        froot_curmr(p) = froot_mr(p) * curmr_ratio
-        froot_xsmr(p) = froot_mr(p) - froot_curmr(p)
-        livestem_curmr(p) = livestem_mr(p) * curmr_ratio
-        livestem_xsmr(p) = livestem_mr(p) - livestem_curmr(p)
-        livecroot_curmr(p) = livecroot_mr(p) * curmr_ratio
-        livecroot_xsmr(p) = livecroot_mr(p) - livecroot_curmr(p)
-        grain_curmr(p) = grain_mr(p) * curmr_ratio
-        grain_xsmr(p) = grain_mr(p) - grain_curmr(p)
-
-        ! no allocation when available c is negative
-        availc(p) = max(availc(p),0.0_r8)
-
-        ! test for an xsmrpool deficit
-        if (xsmrpool(p) < 0.0_r8) then
-           ! Running a deficit in the xsmrpool, so the first priority is to let
-           ! some availc from this timestep accumulate in xsmrpool.
-           ! Determine rate of recovery for xsmrpool deficit
-
-           xsmrpool_recover(p) = -xsmrpool(p)/(dayscrecover*secspday)
-           if (xsmrpool_recover(p) < availc(p)) then
-             ! available carbon reduced by amount for xsmrpool recovery
-             availc(p) = availc(p) - xsmrpool_recover(p)
-           else
-             ! all of the available carbon goes to xsmrpool recovery
-             xsmrpool_recover(p) = availc(p)
-             availc(p) = 0.0_r8
-           end if
-           cpool_to_xsmrpool(p) = xsmrpool_recover(p)
-        end if
+         ! get the time step total maintenance respiration
+         ! These fluxes should already be in gC/m2/s
 
-        f1 = froot_leaf(ivt)
-        f2 = croot_stem(ivt)
+         mr = leaf_mr(p) + froot_mr(p)
+         if (woody(ivt(p)) == 1.0_r8) then
+            mr = mr + livestem_mr(p) + livecroot_mr(p)
+         else if (ivt(p) >= npcropmin) then
+            if (croplive(p)) mr = mr + livestem_mr(p) + grain_mr(p)
+         end if
 
-        ! modified wood allocation to be 2.2 at npp=800 gC/m2/yr, 0.2 at npp=0,
-        ! constrained so that it does not go lower than 0.2 (under negative annsum_npp)
-        ! This variable allocation is only for trees. Shrubs have a constant
-        ! allocation as specified in the pft-physiology file.  The value is also used
-        ! as a trigger here: -1.0 means to use the dynamic allocation (trees).
+         ! carbon flux available for allocation
+         availc(p) = gpp(p) - mr
 
-        if (stem_leaf(ivt) < 0._r8) then
-           if (stem_leaf(ivt) == -1._r8) then
-                f3 = (2.7/(1.0+exp(-0.004*(annsum_npp(p) - 300.0)))) - 0.4
-           else
-                f3 = max((-1.0_r8*stem_leaf(ivt)*2.7_r8)/(1.0_r8+exp(-0.004_r8*(annsum_npp(p) - &
-                          300.0_r8))) - 0.4_r8, 0.2_r8)
-           end if
-        else
-           f3 = stem_leaf(ivt)
-        end if
+         ! new code added for isotope calculations, 7/1/05, PET
+         ! If mr > gpp, then some mr comes from gpp, the rest comes from
+         ! cpool (xsmr)
+         if (mr > 0._r8 .and. availc(p) < 0._r8) then
+            curmr = gpp(p)
+            curmr_ratio = curmr / mr
+         else
+            curmr_ratio = 1._r8
+         end if
 
-        f4   = flivewd(ivt)
-        g1   = grperc(ivt)
-        g2   = grpnow(ivt)
-        cnl  = leafcn(ivt)
-        cnfr = frootcn(ivt)
-        cnlw = livewdcn(ivt)
-        cndw = deadwdcn(ivt)
+         leaf_curmr(p) = leaf_mr(p) * curmr_ratio
+         leaf_xsmr(p) = leaf_mr(p) - leaf_curmr(p)
+         froot_curmr(p) = froot_mr(p) * curmr_ratio
+         froot_xsmr(p) = froot_mr(p) - froot_curmr(p)
+         livestem_curmr(p) = livestem_mr(p) * curmr_ratio
+         livestem_xsmr(p) = livestem_mr(p) - livestem_curmr(p)
+         livecroot_curmr(p) = livecroot_mr(p) * curmr_ratio
+         livecroot_xsmr(p) = livecroot_mr(p) - livecroot_curmr(p)
+         grain_curmr(p) = grain_mr(p) * curmr_ratio
+         grain_xsmr(p) = grain_mr(p) - grain_curmr(p)
+
+         ! no allocation when available c is negative
+         availc(p) = max(availc(p),0.0_r8)
+
+         ! test for an xsmrpool deficit
+         if (xsmrpool(p) < 0.0_r8) then
+            ! Running a deficit in the xsmrpool, so the first priority is to let
+            ! some availc from this timestep accumulate in xsmrpool.
+            ! Determine rate of recovery for xsmrpool deficit
+
+            xsmrpool_recover(p) = -xsmrpool(p)/(dayscrecover*secspday)
+            if (xsmrpool_recover(p) < availc(p)) then
+               ! available carbon reduced by amount for xsmrpool recovery
+               availc(p) = availc(p) - xsmrpool_recover(p)
+            else
+               ! all of the available carbon goes to xsmrpool recovery
+               xsmrpool_recover(p) = availc(p)
+               availc(p) = 0.0_r8
+            end if
+            cpool_to_xsmrpool(p) = xsmrpool_recover(p)
+         end if
 
-        cpl = leafcp(ivt)
-        cpfr = frootcp(ivt)
-        cplw = livewdcp(ivt)
-        cpdw = deadwdcp(ivt)
+         f1 = froot_leaf(ivt(p))
+         f2 = croot_stem(ivt(p))
 
+         ! modified wood allocation to be 2.2 at npp=800 gC/m2/yr, 0.2 at npp=0,
+         ! constrained so that it does not go lower than 0.2 (under negative annsum_npp)
+         ! This variable allocation is only for trees. Shrubs have a constant
+         ! allocation as specified in the pft-physiology file.  The value is also used
+         ! as a trigger here: -1.0 means to use the dynamic allocation (trees).
 
-        ! calculate f1 to f5 for prog crops following AgroIBIS subr phenocrop
+         if (stem_leaf(ivt(p)) < 0._r8) then
+             if (stem_leaf(ivt(p)) == -1._r8) then
+                 f3 = (2.7/(1.0+exp(-0.004*(annsum_npp(p) - 300.0)))) - 0.4
+             else
+                 f3 = max((-1.0_r8*stem_leaf(ivt(p))*2.7_r8)/(1.0_r8+exp(-0.004_r8*(annsum_npp(p) - &
+                           300.0_r8))) - 0.4_r8, 0.2_r8)
+             end if
+         else
+             f3 = stem_leaf(ivt(p))
+         end if
 
-        f5 = 0._r8 ! continued intializations from above
+         f4   = flivewd(ivt(p))
+         g1   = grperc(ivt(p))
+         g2   = grpnow(ivt(p))
+         cnl  = leafcn(ivt(p))
+         cnfr = frootcn(ivt(p))
+         cnlw = livewdcn(ivt(p))
+         cndw = deadwdcn(ivt(p))
 
-        if (ivt >= npcropmin) then ! skip 2 generic crops
+         cpl = leafcp(ivt(p))
+         cpfr = frootcp(ivt(p))
+         cplw = livewdcp(ivt(p))
+         cpdw = deadwdcp(ivt(p))
 
-           if (croplive(p)) then
-             ! same phases appear in subroutine CropPhenology
 
-             ! Phase 1 completed:
-             ! ==================
-             ! if hui is less than the number of gdd needed for filling of grain
-             ! leaf emergence also has to have taken place for lai changes to occur
-             ! and carbon assimilation
-             ! Next phase: leaf emergence to start of leaf decline
+         ! calculate f1 to f5 for prog crops following AgroIBIS subr phenocrop
 
-             if (leafout(p) >= huileaf(p) .and. hui(p) < huigrain(p)) then
+         f5 = 0._r8 ! continued intializations from above
 
-                 ! allocation rules for crops based on maturity and linear decrease
-                 ! of amount allocated to roots over course of the growing season
+         if (ivt(p) >= npcropmin) then ! skip 2 generic crops
 
-                 if (peaklai(p) == 1) then ! lai at maximum allowed
-                    arepr(p) = 0._r8
-                    aleaf(p) = 1.e-5_r8
-                    aroot(p) = max(0._r8, min(1._r8, arooti(ivt) -   &
-                        (arooti(ivt) - arootf(ivt)) *  &
-                        min(1._r8, hui(p)/gddmaturity(p))))
-                    astem(p) = 1._r8 - arepr(p) - aleaf(p) - aroot(p)
-                 else
-                    arepr(p) = 0._r8
-                    aroot(p) = max(0._r8, min(1._r8, arooti(ivt) -   &
-                        (arooti(ivt) - arootf(ivt)) *  &
-                        min(1._r8, hui(p)/gddmaturity(p))))
-                    fleaf = fleafi(ivt) * (exp(-bfact(ivt)) -         &
-                        exp(-bfact(ivt)*hui(p)/huigrain(p))) / &
-                        (exp(-bfact(ivt))-1) ! fraction alloc to leaf (from J Norman alloc curve)
-                    aleaf(p) = max(1.e-5_r8, (1._r8 - aroot(p)) * fleaf)
-                    astem(p) = 1._r8 - arepr(p) - aleaf(p) - aroot(p)
-                 end if
+            if (croplive(p) .and. percrop(ivt(p)) == 0.0_r8 ) then
+               ! same phases appear in subroutine CropPhenology
 
-                 ! AgroIBIS included here an immediate adjustment to aleaf & astem if the
-                 ! predicted lai from the above allocation coefficients exceeded laimx.
-                 ! We have decided to live with lais slightly higher than laimx by
-                 ! enforcing the cap in the following tstep through the peaklai logic above.
-
-                 astemi(p) = astem(p) ! save for use by equations after shift
-                 aleafi(p) = aleaf(p) ! to reproductive phenology stage begins
-                 grain_flag(p) = 0._r8 ! setting to 0 while in phase 2
-
-                 ! Phase 2 completed:
-                 ! ==================
-                 ! shift allocation either when enough gdd are accumulated or maximum number
-                 ! of days has elapsed since planting
-
-             else if (hui(p) >= huigrain(p)) then
-
-                 aroot(p) = max(0._r8, min(1._r8, arooti(ivt) - &
-                      (arooti(ivt) - arootf(ivt)) * min(1._r8, hui(p)/gddmaturity(p))))
-                 if (astemi(p) > astemf(ivt)) then
-                    astem(p) = max(0._r8, max(astemf(ivt), astem(p) * &
-                        (1._r8 - min((hui(p)-                 &
-                        huigrain(p))/((gddmaturity(p)*declfact(ivt))- &
-                        huigrain(p)),1._r8)**allconss(ivt) )))
-                 end if
-                 if (aleafi(p) > aleaff(ivt)) then
-                    aleaf(p) = max(1.e-5_r8, max(aleaff(ivt), aleaf(p) * &
-                        (1._r8 - min((hui(p)-                    &
-                        huigrain(p))/((gddmaturity(p)*declfact(ivt))- &
-                        huigrain(p)),1._r8)**allconsl(ivt) )))
-                 end if
+               ! Phase 1 completed:
+               ! ==================
+               ! if hui is less than the number of gdd needed for filling of grain
+               ! leaf emergence also has to have taken place for lai changes to occur
+               ! and carbon assimilation
+               ! Next phase: leaf emergence to start of leaf decline
 
-                 !Beth's retranslocation of leafn, stemn, rootn to organ
-                 !Filter excess plant N to retransn pool for organ N
-                 !Only do one time then hold grain_flag till onset next season
-
-                 ! slevis: Will astem ever = astemf exactly?
-                 ! Beth's response: ...looks like astem can equal astemf under the right circumstances.
-                 !It might be worth a rewrite to capture what I was trying to do, but the retranslocation for
-                 !corn and wheat begins at the beginning of the grain fill stage, but for soybean I was holding it
-                 !until after the leaf and stem decline were complete. Looking at how astem is calculated, once the
-                 !stem decline is near complete, astem should (usually) be set to astemf. The reason for holding off
-                 !on soybean is that the retranslocation scheme begins at the beginning of the grain phase, when the
-                 !leaf and stem are still growing, but declining. Since carbon is still getting allocated and now
-                 !there is more nitrogen available, the nitrogen can be diverted from grain. For corn and wheat
-                 !the impact was probably enough to boost productivity, but for soybean the nitrogen was better off
-                 !fulfilling the grain fill. It seems that if the peak lai is reached for soybean though that this
-                 !would be bypassed altogether, not the intended outcome. I checked several of my output files and
-                 !they all seemed to be going through the retranslocation loop for soybean - good news.
-
-                 if (ivt /= nsoybean .or. astem(p) == astemf(ivt) .or. peaklai(p) == 1._r8) then
-                    if (grain_flag(p) == 0._r8) then
-                       t1 = 1 / dt
-                       leafn_to_retransn(p) = t1 * ((leafc(p) / leafcn(ivt)) - (leafc(p) / &
-                           fleafcn(ivt)))
-                       livestemn_to_retransn(p) = t1 * ((livestemc(p) / livewdcn(ivt)) - (livestemc(p) / &
-                           fstemcn(ivt)))
-                       frootn_to_retransn(p) = 0._r8
-                       if (ffrootcn(ivt) > 0._r8) then
-                          frootn_to_retransn(p) = t1 * ((frootc(p) / frootcn(ivt)) - (frootc(p) / &
-                              ffrootcn(ivt)))
-                       end if
-                       grain_flag(p) = 1._r8
-                    end if
-                 end if
+               if (leafout(p) >= huileaf(p) .and. hui(p) < huigrain(p)) then
 
-                 arepr(p) = 1._r8 - aroot(p) - astem(p) - aleaf(p)
+                  ! allocation rules for crops based on maturity and linear decrease
+                  ! of amount allocated to roots over course of the growing season
 
-             else                   ! pre emergence
-                 aleaf(p) = 1.e-5_r8 ! allocation coefficients should be irrelevant
-                 astem(p) = 0._r8    ! because crops have no live carbon pools;
-                 aroot(p) = 0._r8    ! this applies to this "else" and to the "else"
-                 arepr(p) = 0._r8    ! a few lines down
-             end if
+                  if (peaklai(p) == 1) then ! lai at maximum allowed
+                     arepr(p) = 0._r8
+                     aleaf(p) = 1.e-5_r8
+                     aroot(p) = max(0._r8, min(1._r8, arooti(ivt(p)) -   &
+                          (arooti(ivt(p)) - arootf(ivt(p))) *  &
+                          min(1._r8, hui(p)/gddmaturity(p))))
+                     astem(p) = 1._r8 - arepr(p) - aleaf(p) - aroot(p)
+                  else
+                     arepr(p) = 0._r8
+                     aroot(p) = max(0._r8, min(1._r8, arooti(ivt(p)) -   &
+                          (arooti(ivt(p)) - arootf(ivt(p))) *  &
+                          min(1._r8, hui(p)/gddmaturity(p))))
+                     fleaf = fleafi(ivt(p)) * (exp(-bfact(ivt(p))) -         &
+                          exp(-bfact(ivt(p))*hui(p)/huigrain(p))) / &
+                          (exp(-bfact(ivt(p)))-1) ! fraction alloc to leaf (from J Norman alloc curve)
+                     aleaf(p) = max(1.e-5_r8, (1._r8 - aroot(p)) * fleaf)
+                     astem(p) = 1._r8 - arepr(p) - aleaf(p) - aroot(p)
+                  end if
+
+                  ! AgroIBIS included here an immediate adjustment to aleaf & astem if the
+                  ! predicted lai from the above allocation coefficients exceeded laimx.
+                  ! We have decided to live with lais slightly higher than laimx by
+                  ! enforcing the cap in the following tstep through the peaklai logic above.
+
+                  astemi(p) = astem(p) ! save for use by equations after shift
+                  aleafi(p) = aleaf(p) ! to reproductive phenology stage begins
+                  grain_flag(p) = 0._r8 ! setting to 0 while in phase 2
+
+                  ! Phase 2 completed:
+                  ! ==================
+                  ! shift allocation either when enough gdd are accumulated or maximum number
+                  ! of days has elapsed since planting
+
+               else if (hui(p) >= huigrain(p)) then
+
+                  aroot(p) = max(0._r8, min(1._r8, arooti(ivt(p)) - &
+                       (arooti(ivt(p)) - arootf(ivt(p))) * min(1._r8, hui(p)/gddmaturity(p))))
+                  if (astemi(p) > astemf(ivt(p))) then
+                     astem(p) = max(0._r8, max(astemf(ivt(p)), astem(p) * &
+                          (1._r8 - min((hui(p)-                 &
+                          huigrain(p))/((gddmaturity(p)*declfact(ivt(p)))- &
+                          huigrain(p)),1._r8)**allconss(ivt(p)) )))
+                  end if
+                  if (aleafi(p) > aleaff(ivt(p))) then
+                     aleaf(p) = max(1.e-5_r8, max(aleaff(ivt(p)), aleaf(p) * &
+                          (1._r8 - min((hui(p)-                    &
+                          huigrain(p))/((gddmaturity(p)*declfact(ivt(p)))- &
+                          huigrain(p)),1._r8)**allconsl(ivt(p)) )))
+                  end if
+
+                  !Beth's retranslocation of leafn, stemn, rootn to organ
+                  !Filter excess plant N to retransn pool for organ N
+                  !Only do one time then hold grain_flag till onset next season
+
+                  ! slevis: Will astem ever = astemf exactly?
+                  ! Beth's response: ...looks like astem can equal astemf under the right circumstances.
+                  !It might be worth a rewrite to capture what I was trying to do, but the retranslocation for
+                  !corn and wheat begins at the beginning of the grain fill stage, but for soybean I was holding it
+                  !until after the leaf and stem decline were complete. Looking at how astem is calculated, once the
+                  !stem decline is near complete, astem should (usually) be set to astemf. The reason for holding off
+                  !on soybean is that the retranslocation scheme begins at the beginning of the grain phase, when the
+                  !leaf and stem are still growing, but declining. Since carbon is still getting allocated and now
+                  !there is more nitrogen available, the nitrogen can be diverted from grain. For corn and wheat
+                  !the impact was probably enough to boost productivity, but for soybean the nitrogen was better off
+                  !fulfilling the grain fill. It seems that if the peak lai is reached for soybean though that this
+                  !would be bypassed altogether, not the intended outcome. I checked several of my output files and
+                  !they all seemed to be going through the retranslocation loop for soybean - good news.
+
+                  if (ivt(p) /= nsoybean .or. astem(p) == astemf(ivt(p)) .or. peaklai(p) == 1._r8) then
+                     if (grain_flag(p) == 0._r8) then
+                        t1 = 1 / dt
+                        leafn_to_retransn(p) = t1 * ((leafc(p) / leafcn(ivt(p))) - (leafc(p) / &
+                             fleafcn(ivt(p))))
+                        livestemn_to_retransn(p) = t1 * ((livestemc(p) / livewdcn(ivt(p))) - (livestemc(p) / &
+                             fstemcn(ivt(p))))
+                        frootn_to_retransn(p) = 0._r8
+                        if (ffrootcn(ivt(p)) > 0._r8) then
+                           frootn_to_retransn(p) = t1 * ((frootc(p) / frootcn(ivt(p))) - (frootc(p) / &
+                                ffrootcn(ivt(p))))
+                        end if
+                        grain_flag(p) = 1._r8
+                     end if
+                  end if
+
+                  arepr(p) = 1._r8 - aroot(p) - astem(p) - aleaf(p)
+
+               else                   ! pre emergence
+                  aleaf(p) = 1.e-5_r8 ! allocation coefficients should be irrelevant
+                  astem(p) = 0._r8    ! because crops have no live carbon pools;
+                  aroot(p) = 0._r8    ! this applies to this "else" and to the "else"
+                  arepr(p) = 0._r8    ! a few lines down
+               end if
 
-             f1 = aroot(p) / aleaf(p)
-             f3 = astem(p) / aleaf(p)
-             f5 = arepr(p) / aleaf(p)
-             g1 = 0.25_r8
+               f1 = aroot(p) / aleaf(p)
+               f3 = astem(p) / aleaf(p)
+               f5 = arepr(p) / aleaf(p)
+               g1 = 0.25_r8
+
+            else if (croplive(p) .and. percrop(ivt(p)) == 1.0_r8) then
+               arepr(p) = 0._r8
+               aroot(p) = max(0._r8, min(1._r8, arooti(ivt(p)) -   &
+                    (arooti(ivt(p)) - arootf(ivt(p))) *  &
+                    min(1._r8, hui(p)/gddmaturity(p))))
+               fleaf = fleafi(ivt(p)) * (exp(-bfact(ivt(p))) -         &
+                    exp(-bfact(ivt(p))*hui(p)/gddmaturity(p))) / &      ! replacing huigrain with gddmaturity since huigrain does not exist for perennial crops
+                    (exp(-bfact(ivt(p)))-1) ! fraction alloc to leaf (from J Norman alloc curve)
+               aleaf(p) = max(1.e-5_r8, (1._r8 - aroot(p)) * fleaf)
+               astem(p) = 1._r8 - arepr(p) - aleaf(p) - aroot(p)
+
+               f1 = aroot(p) / aleaf(p)
+               f3 = astem(p) / aleaf(p)
+               f5 = arepr(p) / aleaf(p)
+               g1 = 0.25_r8
+
+            else   ! .not croplive
+               f1 = 0._r8
+               f3 = 0._r8
+               f5 = 0._r8
+               g1 = 0.25_r8
+            end if
+         end if
 
-           else   ! .not croplive
-             f1 = 0._r8
-             f3 = 0._r8
-             f5 = 0._r8
-             g1 = 0.25_r8
-           end if
-        end if
+         ! based on available C, use constant allometric relationships to
+         ! determine N requirements
+         ! determine P requirements   -X. YANG
+
+         if (woody(ivt(p)) == 1.0_r8) then
+            c_allometry(p) = (1._r8+g1)*(1._r8+f1+f3*(1._r8+f2))
+            n_allometry(p) = 1._r8/cnl + f1/cnfr + (f3*f4*(1._r8+f2))/cnlw + &
+                 (f3*(1._r8-f4)*(1._r8+f2))/cndw
+            p_allometry(p) = 1._r8/cpl + f1/cpfr + (f3*f4*(1._r8+f2))/cplw + &
+                 (f3*(1._r8-f4)*(1._r8+f2))/cpdw
+
+         else if (ivt(p) >= npcropmin) then ! skip generic crops
+            cng = graincn(ivt(p))
+            cpg = graincp(ivt(p))
+            c_allometry(p) = (1._r8+g1)*(1._r8+f1+f5+f3*(1._r8+f2))
+            n_allometry(p) = 1._r8/cnl + f1/cnfr + f5/cng + (f3*f4*(1._r8+f2))/cnlw + &
+                 (f3*(1._r8-f4)*(1._r8+f2))/cndw
+            p_allometry(p) = 1._r8/cpl + f1/cpfr + f5/cpg + (f3*f4*(1._r8+f2))/cplw + &
+                 (f3*(1._r8-f4)*(1._r8+f2))/cpdw
 
-        ! based on available C, use constant allometric relationships to
-        ! determine N requirements
-        ! determine P requirements   -X. YANG
-
-        if (woody(ivt) == 1.0_r8) then
-           c_allometry(p) = (1._r8+g1)*(1._r8+f1+f3*(1._r8+f2))
-           n_allometry(p) = 1._r8/cnl + f1/cnfr + (f3*f4*(1._r8+f2))/cnlw + &
-                (f3*(1._r8-f4)*(1._r8+f2))/cndw
-           p_allometry(p) = 1._r8/cpl + f1/cpfr + (f3*f4*(1._r8+f2))/cplw + &
-                (f3*(1._r8-f4)*(1._r8+f2))/cpdw
-
-        else if (ivt >= npcropmin) then ! skip generic crops
-           cng = graincn(ivt)
-           cpg = graincp(ivt)
-           c_allometry(p) = (1._r8+g1)*(1._r8+f1+f5+f3*(1._r8+f2))
-           n_allometry(p) = 1._r8/cnl + f1/cnfr + f5/cng + (f3*f4*(1._r8+f2))/cnlw + &
-                (f3*(1._r8-f4)*(1._r8+f2))/cndw
-           p_allometry(p) = 1._r8/cpl + f1/cpfr + f5/cpg + (f3*f4*(1._r8+f2))/cplw + &
-                (f3*(1._r8-f4)*(1._r8+f2))/cpdw
+         else
+            c_allometry(p) = 1._r8+g1+f1+f1*g1
+            n_allometry(p) = 1._r8/cnl + f1/cnfr
+            p_allometry(p) = 1._r8/cpl + f1/cpfr
+         end if
+         plant_ndemand(p) = availc(p)*(n_allometry(p)/c_allometry(p))
+         plant_pdemand(p) = availc(p)*(p_allometry(p)/c_allometry(p))
 
-        else
-           c_allometry(p) = 1._r8+g1+f1+f1*g1
-           n_allometry(p) = 1._r8/cnl + f1/cnfr
-           p_allometry(p) = 1._r8/cpl + f1/cpfr
-        end if
-        plant_ndemand(p) = availc(p)*(n_allometry(p)/c_allometry(p))
-        plant_pdemand(p) = availc(p)*(p_allometry(p)/c_allometry(p))
+         ! retranslocated N deployment depends on seasonal cycle of potential GPP
+         ! (requires one year run to accumulate demand)
 
-        ! retranslocated N deployment depends on seasonal cycle of potential GPP
-        ! (requires one year run to accumulate demand)
+         tempsum_potential_gpp(p) = tempsum_potential_gpp(p) + gpp(p)
 
-        tempsum_potential_gpp(p) = tempsum_potential_gpp(p) + gpp(p)
+         ! Adding the following line to carry max retransn info to CN Annual Update
+         tempmax_retransn(p) = max(tempmax_retransn(p),retransn(p))
+         tempmax_retransp(p) = max(tempmax_retransp(p),retransp(p))   !! phosphorus
 
-        ! Adding the following line to carry max retransn info to CN Annual Update
-        tempmax_retransn(p) = max(tempmax_retransn(p),retransn(p))
-        tempmax_retransp(p) = max(tempmax_retransp(p),retransp(p))   !! phosphorus
+         ! Beth's code: crops pull from retransn pool only during grain fill;
+         !              retransn pool has N from leaves, stems, and roots for
+         !              retranslocation
 
-        ! Beth's code: crops pull from retransn pool only during grain fill;
-        !              retransn pool has N from leaves, stems, and roots for
-        !              retranslocation
+         if (ivt(p) >= npcropmin .and. grain_flag(p) == 1._r8) then
+            avail_retransn(p) = plant_ndemand(p)
+            avail_retransp(p) = plant_pdemand(p)
+         else if (ivt(p) < npcropmin .and. annsum_potential_gpp(p) > 0._r8) then
+            avail_retransn(p) = (annmax_retransn(p)/2._r8)*(gpp(p)/annsum_potential_gpp(p))/dt
+            avail_retransp(p) = (annmax_retransp(p)/2._r8)*(gpp(p)/annsum_potential_gpp(p))/dt
+         else
+            avail_retransn(p) = 0.0_r8
+            avail_retransp(p) = 0.0_r8
+         end if
 
-        if (ivt >= npcropmin .and. grain_flag(p) == 1._r8) then
-           avail_retransn(p) = plant_ndemand(p)
-           avail_retransp(p) = plant_pdemand(p)
-        else if (ivt < npcropmin .and. annsum_potential_gpp(p) > 0._r8) then
-           avail_retransn(p) = (annmax_retransn(p)/2._r8)*(gpp(p)/annsum_potential_gpp(p))/dt
-           avail_retransp(p) = (annmax_retransp(p)/2._r8)*(gpp(p)/annsum_potential_gpp(p))/dt
-        else
-           avail_retransn(p) = 0.0_r8
-           avail_retransp(p) = 0.0_r8
-        end if
+         ! make sure available retrans N doesn't exceed storage
+         avail_retransn(p) = min(avail_retransn(p), retransn(p)/dt)
+         avail_retransp(p) = min(avail_retransp(p), retransp(p)/dt)    !! phosphorus
 
-        ! make sure available retrans N doesn't exceed storage
-        avail_retransn(p) = min(avail_retransn(p), retransn(p)/dt)
-        avail_retransp(p) = min(avail_retransp(p), retransp(p)/dt)    !! phosphorus
+         ! modify plant N demand according to the availability of
+         ! retranslocated N
+         ! take from retransn pool at most the flux required to meet
+         ! plant ndemand
 
-        ! modify plant N demand according to the availability of
-        ! retranslocated N
-        ! take from retransn pool at most the flux required to meet
-        ! plant ndemand
+         if (plant_ndemand(p) > avail_retransn(p)) then
+            retransn_to_npool(p) = avail_retransn(p)
+         else
+            retransn_to_npool(p) = plant_ndemand(p)
+         end if
 
-        if (plant_ndemand(p) > avail_retransn(p)) then
-           retransn_to_npool(p) = avail_retransn(p)
-        else
-           retransn_to_npool(p) = plant_ndemand(p)
-        end if
+         plant_ndemand(p) = plant_ndemand(p) - retransn_to_npool(p)
 
-        plant_ndemand(p) = plant_ndemand(p) - retransn_to_npool(p)
+         if (plant_pdemand(p) > avail_retransp(p)) then
+            retransp_to_ppool(p) = avail_retransp(p)
+         else
+            retransp_to_ppool(p) = plant_pdemand(p)
+         end if
+         plant_pdemand(p) = plant_pdemand(p) - retransp_to_ppool(p)
 
-        if (plant_pdemand(p) > avail_retransp(p)) then
-           retransp_to_ppool(p) = avail_retransp(p)
-        else
-           retransp_to_ppool(p) = plant_pdemand(p)
-        end if
-        plant_pdemand(p) = plant_pdemand(p) - retransp_to_ppool(p)
-      end do 
 
-   end associate
+      end do ! end pft loop
+
+      ! now use the p2c routine to get the column-averaged plant_ndemand
+      call p2c(bounds, num_soilc, filter_soilc, &
+           plant_ndemand(bounds%begp:bounds%endp), &
+           plant_ndemand_col(bounds%begc:bounds%endc))
+
+      !!! add phosphorus
+      call p2c(bounds, num_soilc, filter_soilc, &
+           plant_pdemand(bounds%begp:bounds%endp), &
+           plant_pdemand_col(bounds%begc:bounds%endc))
+
+   !!! Starting resolving N limitation
+      !! new subroutines to calculate nuptake_prof & puptake_prof
+      if (nu_com .eq. 'RD') then ! 'RD' : relative demand approach
+         call calc_nuptake_prof(bounds, num_soilc, filter_soilc, cnstate_vars, nuptake_prof)
+         call calc_puptake_prof(bounds, num_soilc, filter_soilc, cnstate_vars, puptake_prof)
+      end if
+
+      ! pflotran will need an input from CN: modified 'sum_ndemand_vr' ('potential_immob' excluded).
+      if (use_elm_interface.and.use_pflotran .and. pf_cmode) then
+            do j = 1, nlevdecomp
+               do fc=1, num_soilc
+                  c = filter_soilc(fc)
+                  plant_ndemand_vr_col(c,j) = plant_ndemand_col(c) * nuptake_prof(c,j)
+                  plant_pdemand_vr_col(c,j) = plant_pdemand_col(c) * puptake_prof(c,j)
+               end do
+            end do
+      endif
+
+    end associate
 
- end subroutine TotalNPDemand
+ end subroutine Allocation1_PlantNPDemand
 
 !-------------------------------------------------------------------------------------------------
 
- subroutine Allocation2_ResolveNPLimit (bounds,num_soilc, filter_soilc, &
-                                        cnstate_vars , soilstate_vars, dt )
+ subroutine Allocation2_ResolveNPLimit (bounds, num_soilc, filter_soilc  , &
+      num_soilp, filter_soilp                         , &
+      cnstate_vars                                    , &
+      soilstate_vars, dt , elm_fates)
    ! PHASE-2 of Allocation:  resolving N/P limitation
    ! !USES:
+   !$acc routine seq
    use elm_varctl      , only : carbon_only          !
    use elm_varctl      , only : carbonnitrogen_only  !
    use elm_varctl      , only : carbonphosphorus_only!
-   use pftvarcon       , only : noveg
-   use elm_varpar      , only : nlevdecomp, ndecomp_cascade_transitions
-   use elm_varcon      , only : nitrif_n2o_loss_frac, secspday
-   use elm_varcon      , only : zisoi
+   use pftvarcon        , only: noveg
+   use elm_varpar       , only: nlevdecomp, ndecomp_cascade_transitions
+   use elm_varcon       , only: nitrif_n2o_loss_frac, secspday
+   use elm_varcon       , only : zisoi
    !
    ! !ARGUMENTS:
    type(bounds_type)        , intent(in)    :: bounds
    integer                  , intent(in)    :: num_soilc        ! number of soil columns in filter
    integer                  , intent(in)    :: filter_soilc(:)  ! filter for soil columns
+   integer                  , intent(in)    :: num_soilp        ! number of soil patches in filter
+   integer                  , intent(in)    :: filter_soilp(:)  ! filter for soil patches
    type(cnstate_type)       , intent(inout) :: cnstate_vars
    type(soilstate_type)     , intent(in)    :: soilstate_vars
    real(r8)  ,  intent(in)  :: dt
+   type(hlm_fates_interface_type), intent(inout) :: elm_fates
    !
    ! !LOCAL VARIABLES:
-   real(r8) :: fpi_no3_vr(num_soilc,1:nlevdecomp) ! fraction of potential immobilization supplied by no3(no units)
-   real(r8) :: fpi_nh4_vr(num_soilc,1:nlevdecomp) ! fraction of potential immobilization supplied by nh4 (no units)
 
+   real(r8) :: excess_immob_nh4_vr(1:nlevdecomp) ! nh4 excess flux, if soil microbes are more P limited
+   real(r8) :: excess_immob_no3_vr(1:nlevdecomp) ! no3 excess flux, if soil microbes are more P limited
+   real(r8) :: excess_immob_p_vr(1:nlevdecomp)   ! P excess flux, if soil microbes are more N limited
+   real(r8) :: decompmicc(1:nlevdecomp)          ! column-level soil microbial decomposer biomass gC/m3
+   
+   real(r8) :: fpi_no3_vr(1:nlevdecomp) ! fraction of potential immobilization supplied by no3(no units)
+   real(r8) :: fpi_nh4_vr(1:nlevdecomp) ! fraction of potential immobilization supplied by nh4 (no units)
+
+   integer :: n_pcomp   ! number of plant competitors
    integer :: c,p,l,j,k ! indices
    integer :: fp        ! lake filter pft index
    integer :: fc        ! lake filter column index
+   integer :: f         ! loop index for plant competitors
+   integer :: ci, s     ! used for FATES BC (clump index, site index)
+   integer :: j_f       ! local index that maps a decomposition
+                        ! layer onto a fates uptake layer
 
    ! Fractional uptake profiles, that are proportional to root density
-   real(r8):: nuptake_prof(num_soilc,1:nlevdecomp)
-   real(r8):: puptake_prof(num_soilc,1:nlevdecomp)
-
-   real(r8) :: sum1,sum2,sum3,sum4,sum5,sum6
-   real  :: startt, stopt
-   integer :: begc, endc 
+   real(r8):: nuptake_prof(bounds%begc:bounds%endc,1:nlevdecomp)
+   real(r8):: puptake_prof(bounds%begc:bounds%endc,1:nlevdecomp)
+   integer,  allocatable :: filter_pcomp(:)               ! this is a plant competitor map for FATES/ELM-BL w/ ECA 
+   real(r8), allocatable,target :: plant_nh4demand_vr_fates(:,:) ! nh4 demand per competitor per soil layer
+   real(r8), allocatable,target :: plant_no3demand_vr_fates(:,:) ! no3 demand per competitor per soil layer
+   real(r8), allocatable,target :: plant_pdemand_vr_fates(:,:)   ! p demand per competitor per soil layer
+   
+   integer  :: nc   ! clump index
+   integer  :: pci, pcf                        ! (I)nitial and (F)inal plant competitor index
+   real(r8), pointer :: veg_rootc_ptr(:,:)     ! points to either native ELM or FATES root carbon array
+   integer, pointer  :: ft_index_ptr(:)        ! points to either native ELM or FATES PFT array
+   real(r8), pointer :: cn_scalar_ptr(:)       ! points to either native ELM or FATES C:N scalar array
+   real(r8), pointer :: cn_scalar_runmean_ptr(:)       ! points to either native ELM or FATES C:N scalar array
+   real(r8), pointer :: cp_scalar_ptr(:)       ! points to either native ELM or FATES C:P scalar array
+   real(r8), pointer :: cp_scalar_runmean_ptr(:)       ! points to either native ELM or FATES C:P scalar array
+   real(r8), pointer :: plant_nh4demand_vr_ptr(:,:)
+   real(r8), pointer :: plant_no3demand_vr_ptr(:,:)
+   real(r8), pointer :: plant_pdemand_vr_ptr(:,:)
+   real(r8), pointer :: km_p_ptr(:), km_nh4_ptr(:), km_no3_ptr(:)
+   real(r8), pointer :: vmax_p_ptr(:), vmax_nh4_ptr(:), vmax_no3_ptr(:)
+   real(r8):: cn_stoich_var=0.2    ! variability of CN ratio
+   real(r8):: cp_stoich_var=0.4    ! variability of CP ratio
+   
    !-----------------------------------------------------------------------
-   associate(        &
+
+   associate(                                                                                 &
         ivt                          => veg_pp%itype                    , & ! Input:  [integer  (:) ]  pft vegetation type
                                                                             ! new variables due to partition of Allocation to 3 subroutines: BEG
         plant_ndemand_col            => col_nf%plant_ndemand            , & ! Output:  [real(r8) (:,:) ]
@@ -947,7 +963,6 @@ contains
         fpg_no3_vr                   => cnstate_vars%fpg_no3_vr_col     , &
         fpg_vr                       => cnstate_vars%fpg_vr_col         , &
         fpg_p_vr                     => cnstate_vars%fpg_p_vr_col       , &
-        nfixation_prof               => cnstate_vars%nfixation_prof_col , &
         sminn_vr                     => col_ns%sminn_vr                 , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral N
         smin_nh4_vr                  => col_ns%smin_nh4_vr              , & ! Output: [real(r8) (:,:) ]  (gN/m3) soil mineral NH4
         smin_no3_vr                  => col_ns%smin_no3_vr              , & ! Output: [real(r8) (:,:) ]  (gN/m3) soil mineral NO3
@@ -955,68 +970,70 @@ contains
         actual_immob                 => col_nf%actual_immob             , & ! Output: [real(r8) (:)   ]
         sminn_to_plant               => col_nf%sminn_to_plant           , & ! Output: [real(r8) (:)   ]
         pot_f_nit_vr                 => col_nf%pot_f_nit_vr             , & ! Output: [real(r8) (:,:) ]  (gN/m3/s) potential soil nitrification flux
-        pot_f_denit_vr               => col_nf%pot_f_denit_vr              , & ! Output: [real(r8) (:,:) ]  (gN/m3/s) potential soil denitrification flux
-        f_nit_vr                     => col_nf%f_nit_vr                    , & ! Output: [real(r8) (:,:) ]  (gN/m3/s) soil nitrification flux
-        f_denit_vr                   => col_nf%f_denit_vr                  , & ! Output: [real(r8) (:,:) ]  (gN/m3/s) soil denitrification flux
-        actual_immob_no3_vr          => col_nf%actual_immob_no3_vr         , & ! Output: [real(r8) (:,:) ]
-        actual_immob_nh4_vr          => col_nf%actual_immob_nh4_vr         , & ! Output: [real(r8) (:,:) ]
-        smin_no3_to_plant_vr         => col_nf%smin_no3_to_plant_vr        , & ! Output: [real(r8) (:,:) ]
-        smin_nh4_to_plant_vr         => col_nf%smin_nh4_to_plant_vr        , & ! Output: [real(r8) (:,:) ]
-        n2_n2o_ratio_denit_vr        => col_nf%n2_n2o_ratio_denit_vr       , & ! Output: [real(r8) (:,:) ]  ratio of N2 to N2O production by denitrification [gN/gN]
-        f_n2o_denit_vr               => col_nf%f_n2o_denit_vr              , & ! Output: [real(r8) (:,:) ]  flux of N2O from denitrification [gN/m3/s]
-        f_n2o_nit_vr                 => col_nf%f_n2o_nit_vr                , & ! Output: [real(r8) (:,:) ]  flux of N2O from nitrification [gN/m3/s]
-        supplement_to_sminn_vr       => col_nf%supplement_to_sminn_vr      , & ! Output: [real(r8) (:,:) ]
-        sminn_to_plant_vr            => col_nf%sminn_to_plant_vr           , & ! Output: [real(r8) (:,:) ]
-        potential_immob_vr           => col_nf%potential_immob_vr          , & ! Output: [real(r8) (:,:) ]
-        actual_immob_vr              => col_nf%actual_immob_vr             , & ! Output: [real(r8) (:,:) ]
-        col_plant_ndemand_vr         => col_nf%col_plant_ndemand_vr        , &
-        col_plant_nh4demand_vr       => col_nf%col_plant_nh4demand_vr      , &
-        col_plant_no3demand_vr       => col_nf%col_plant_no3demand_vr      , &
-        col_plant_pdemand_vr         => col_pf%col_plant_pdemand_vr        , &
-        cn_scalar                    => cnstate_vars%cn_scalar             , &
-        cp_scalar                    => cnstate_vars%cp_scalar             , &
-        t_scalar                     => col_cf%t_scalar                    , &
-        plant_nh4demand_vr_patch     => veg_nf%plant_nh4demand_vr          , &
-        plant_no3demand_vr_patch     => veg_nf%plant_no3demand_vr          , &
-        plant_ndemand_vr_patch       => veg_nf%plant_ndemand_vr            , &
+        pot_f_denit_vr               => col_nf%pot_f_denit_vr                , & ! Output: [real(r8) (:,:) ]  (gN/m3/s) potential soil denitrification flux
+        f_nit_vr                     => col_nf%f_nit_vr                      , & ! Output: [real(r8) (:,:) ]  (gN/m3/s) soil nitrification flux
+        f_denit_vr                   => col_nf%f_denit_vr                    , & ! Output: [real(r8) (:,:) ]  (gN/m3/s) soil denitrification flux
+        actual_immob_no3_vr          => col_nf%actual_immob_no3_vr           , & ! Output: [real(r8) (:,:) ]
+        actual_immob_nh4_vr          => col_nf%actual_immob_nh4_vr           , & ! Output: [real(r8) (:,:) ]
+        smin_no3_to_plant_vr         => col_nf%smin_no3_to_plant_vr          , & ! Output: [real(r8) (:,:) ]
+        smin_nh4_to_plant_vr         => col_nf%smin_nh4_to_plant_vr          , & ! Output: [real(r8) (:,:) ]
+        n2_n2o_ratio_denit_vr        => col_nf%n2_n2o_ratio_denit_vr         , & ! Output: [real(r8) (:,:) ]  ratio of N2 to N2O production by denitrification [gN/gN]
+        f_n2o_denit_vr               => col_nf%f_n2o_denit_vr                , & ! Output: [real(r8) (:,:) ]  flux of N2O from denitrification [gN/m3/s]
+        f_n2o_nit_vr                 => col_nf%f_n2o_nit_vr                  , & ! Output: [real(r8) (:,:) ]  flux of N2O from nitrification [gN/m3/s]
+        supplement_to_sminn_vr       => col_nf%supplement_to_sminn_vr        , & ! Output: [real(r8) (:,:) ]
+        sminn_to_plant_vr            => col_nf%sminn_to_plant_vr             , & ! Output: [real(r8) (:,:) ]
+        potential_immob_vr           => col_nf%potential_immob_vr            , & ! Output: [real(r8) (:,:) ]
+        actual_immob_vr              => col_nf%actual_immob_vr               , & ! Output: [real(r8) (:,:) ]
+        col_plant_ndemand_vr         => col_nf%col_plant_ndemand_vr                , &
+        col_plant_nh4demand_vr       => col_nf%col_plant_nh4demand_vr              , &
+        col_plant_no3demand_vr       => col_nf%col_plant_no3demand_vr              , &
+        col_plant_pdemand_vr         => col_pf%col_plant_pdemand_vr                , &
+        cn_scalar                    => cnstate_vars%cn_scalar                                , &
+        cn_scalar_runmean            => cnstate_vars%cn_scalar_runmean                           , &
+        cp_scalar                    => cnstate_vars%cp_scalar                                , &
+        cp_scalar_runmean            => cnstate_vars%cp_scalar_runmean                                , &
+        t_scalar                     => col_cf%t_scalar                          , &
+        plant_nh4demand_vr_patch     => veg_nf%plant_nh4demand_vr            , &
+        plant_no3demand_vr_patch     => veg_nf%plant_no3demand_vr            , &
+        plant_ndemand_vr_patch       => veg_nf%plant_ndemand_vr              , &
         plant_pdemand_vr_patch       => veg_pf%plant_pdemand_vr            , &
-        pnup_pfrootc                 => veg_ns%pnup_pfrootc                , &
-        isoilorder                   => cnstate_vars%isoilorder            , &
+        pnup_pfrootc                 => veg_ns%pnup_pfrootc                 , &
+        isoilorder                   => cnstate_vars%isoilorder                               , &
         sminp_to_plant_patch         => veg_pf%sminp_to_plant              , &
-        sminn_to_plant_patch         => veg_nf%sminn_to_plant              , &
-        smin_nh4_to_plant_patch      => veg_nf%smin_nh4_to_plant           , &
-        smin_no3_to_plant_patch      => veg_nf%smin_no3_to_plant           , &
-        actual_immob_no3             => col_nf%actual_immob_no3            , &
-        actual_immob_nh4             => col_nf%actual_immob_nh4            , &
-        froot_prof                   => cnstate_vars%froot_prof_patch      , & ! fine root vertical profile Zeng, X. 2001. Global vegetation root distribution for land modeling. J. Hydrometeor. 2:525-530
-        frootc                       => veg_cs%frootc                      , & ! Input:  [real(r8) (:)   ]
-        leafc                        => veg_cs%leafc                       , & ! Input:  [real(r8) (:)   ]
-        leafcn                       => veg_vp%leafcn                      , & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
-        leafcp                       => veg_vp%leafcp                      , & ! Input:  [real(r8) (:)   ]  leaf C:P (gC/gP)
-        vmax_minsurf_p_vr            => veg_vp%vmax_minsurf_p_vr           , &
-        leafn                        => veg_ns%leafn                       , &
-        vmax_plant_nh4               => veg_vp%vmax_plant_nh4              , &
-        vmax_plant_no3               => veg_vp%vmax_plant_no3              , &
-        vmax_plant_p                 => veg_vp%vmax_plant_p                , &
-        primp_to_labilep_vr_col      => col_pf%primp_to_labilep_vr         , &
+        sminn_to_plant_patch         => veg_nf%sminn_to_plant                , &
+        smin_nh4_to_plant_patch      => veg_nf%smin_nh4_to_plant             , &
+        smin_no3_to_plant_patch      => veg_nf%smin_no3_to_plant             , &
+        actual_immob_no3             => col_nf%actual_immob_no3                , &
+        actual_immob_nh4             => col_nf%actual_immob_nh4                , &
+        froot_prof                   => cnstate_vars%froot_prof_patch                         , & ! fine root vertical profile Zeng, X. 2001. Global vegetation root distribution for land modeling. J. Hydrometeor. 2:525-530
+        frootc                       => veg_cs%frootc                         , & ! Input:  [real(r8) (:)   ]
+        leafc                        => veg_cs%leafc                          , & ! Input:  [real(r8) (:)   ]
+        leafcn                       => veg_vp%leafcn                                     , & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
+        leafcp                       => veg_vp%leafcp                                     , & ! Input:  [real(r8) (:)   ]  leaf C:P (gC/gP)
+        vmax_minsurf_p_vr            => veg_vp%vmax_minsurf_p_vr                          , &
+        leafn                        => veg_ns%leafn                        , &
+        vmax_plant_nh4               => veg_vp%vmax_plant_nh4                             , &
+        vmax_plant_no3               => veg_vp%vmax_plant_no3                             , &
+        vmax_plant_p                 => veg_vp%vmax_plant_p                               , &
+        primp_to_labilep_vr_col      => col_pf%primp_to_labilep_vr           , &
         leafp                        => veg_ps%leafp                      , &
-        km_decomp_nh4                => veg_vp%km_decomp_nh4              , &
-        km_decomp_no3                => veg_vp%km_decomp_no3              , &
-        km_decomp_p                  => veg_vp%km_decomp_p                , &
-        km_nit                       => veg_vp%km_nit                     , &
-        km_den                       => veg_vp%km_den                     , &
-        km_plant_nh4                 => veg_vp%km_plant_nh4               , &
-        km_plant_no3                 => veg_vp%km_plant_no3               , &
-        km_plant_p                   => veg_vp%km_plant_p                 , &
-        km_minsurf_p_vr              => veg_vp%km_minsurf_p_vr            , &
-        decompmicc_patch_vr          => veg_vp%decompmicc_patch_vr        , &
-        adsorb_to_labilep_vr         => col_pf%adsorb_to_labilep_vr       , &
-        desorb_to_solutionp_vr       => col_pf%desorb_to_solutionp_vr     , &
-        biochem_pmin_vr_col          => col_pf%biochem_pmin_vr            , &
-        labilep_vr                   => col_ps%labilep_vr                 , &
-        pdep_to_sminp                => col_pf%pdep_to_sminp              , &
-        pdep_prof                    => cnstate_vars%pdep_prof_col        , &
-        gross_pmin_vr                => col_pf%gross_pmin_vr              , &
+        km_decomp_nh4                => veg_vp%km_decomp_nh4                              , &
+        km_decomp_no3                => veg_vp%km_decomp_no3                              , &
+        km_decomp_p                  => veg_vp%km_decomp_p                                , &
+        km_nit                       => veg_vp%km_nit                                     , &
+        km_den                       => veg_vp%km_den                                     , &
+        km_plant_nh4                 => veg_vp%km_plant_nh4                               , &
+        km_plant_no3                 => veg_vp%km_plant_no3                               , &
+        km_plant_p                   => veg_vp%km_plant_p                                 , &
+        km_minsurf_p_vr              => veg_vp%km_minsurf_p_vr                            , &
+        decompmicc_patch_vr          => veg_vp%decompmicc_patch_vr                        , &
+        adsorb_to_labilep_vr         => col_pf%adsorb_to_labilep_vr              , &
+        desorb_to_solutionp_vr       => col_pf%desorb_to_solutionp_vr            , &
+        biochem_pmin_vr_col          => col_pf%biochem_pmin_vr               , &
+        labilep_vr                   => col_ps%labilep_vr                   , &
+        pdep_to_sminp                => col_pf%pdep_to_sminp                 , &
+        pdep_prof                    => cnstate_vars%pdep_prof_col                            , &
+        gross_pmin_vr                => col_pf%gross_pmin_vr                 , &
                                 !! add phosphorus variables  - X. YANG
         solutionp_vr                 => col_ps%solutionp_vr               , & ! Input:  [real(r8) (:,:) ]  (gP/m3) soil mineral P
         potential_immob_p            => col_pf%potential_immob_p           , & ! Output: [real(r8) (:)   ]
@@ -1026,84 +1043,279 @@ contains
         sminp_to_plant_vr            => col_pf%sminp_to_plant_vr           , & ! Output: [real(r8) (:,:) ]
         potential_immob_p_vr         => col_pf%potential_immob_p_vr        , & ! Output: [real(r8) (:,:) ]
         actual_immob_p_vr            => col_pf%actual_immob_p_vr           , & ! Output: [real(r8) (:,:) ]
-        bd                           => soilstate_vars%bd_col              , &
-        h2osoi_vol                   => col_ws%h2osoi_vol                  , &
-        pmnf_decomp_cascade          => col_nf%pmnf_decomp_cascade         , &
-        pmpf_decomp_cascade          => col_pf%pmpf_decomp_cascade         , &
-        leafc_storage                => veg_cs%leafc_storage               , &
-        leafc_xfer                   => veg_cs%leafc_xfer                  , &
+        bd                           => soilstate_vars%bd_col                               , &
+        h2osoi_vol                   => col_ws%h2osoi_vol                      , &
+        pmnf_decomp_cascade          => col_nf%pmnf_decomp_cascade               , &
+        pmpf_decomp_cascade          => col_pf%pmpf_decomp_cascade             , &
+        leafc_storage                => veg_cs%leafc_storage                , &
+        leafc_xfer                   => veg_cs%leafc_xfer                   , &
         leafn_storage                => veg_ns%leafn_storage              , &
         leafn_xfer                   => veg_ns%leafn_xfer                 , &
-        leafp_storage                => veg_ps%leafp_storage              , &
+        leafp_storage                => veg_ps%leafp_storage            , &
         leafp_xfer                   => veg_ps%leafp_xfer                 &
         )
 
-     !if (nu_com .eq. 'RD') then ! 'RD' : relative demand approach
-      ! Starting resolving N/P limitation
-      ! calculate nuptake & puptake profile
-      begc = bounds%begc 
-      endc = bounds%endc 
-      !$acc enter data create(nuptake_prof(1:num_soilc,1:nlevdecomp),puptake_prof(1:num_soilc,1:nlevdecomp),&
-      !$acc fpi_no3_vr(:,1:nlevdecomp),fpi_nh4_vr(:,1:nlevdecomp))
-
-      call calc_nuptake_prof(num_soilc, filter_soilc, cnstate_vars, nuptake_prof)
-      call calc_puptake_prof(num_soilc, filter_soilc, cnstate_vars, puptake_prof)
-
-   ! ------------------------------------------------------------------------------
-   ! PART I.
-   ! Determine the boundary conditions for the competitive allocation modules
-   ! This is mostly about pointing to either the big-leaf or FATES boundary
-   ! conditions.
-   ! ------------------------------------------------------------------------------
-      call cpu_time(startt)
-      !$acc parallel loop independent gang default(present)
-      do j = 1, nlevdecomp
-         !$acc loop vector independent private(c)
-         do fc=1,num_soilc
-           c = filter_soilc(fc)
-           col_plant_ndemand_vr(c,j) = plant_ndemand_col(c) * nuptake_prof(fc,j)
-           col_plant_pdemand_vr(c,j) = plant_pdemand_col(c) * puptake_prof(fc,j)
-        end do
-      end do
-   
-   if (nu_com .eq. 'RD') then
-   ! Estimate actual allocation rates via Relative Demand
-   ! approach (RD)
-      ! Starting resolving N limitation !!!
-      ! =============================================================
-      ! This section is modified, Aug 2015 by Q. Zhu
-      ! (1) add nitrogen and phosphorus competition
-      ! (2) nitrogen and phosphorus uptake is based on root kinetics
-      ! (3) no second pass nutrient uptake for plants
-      ! =============================================================
-       call NAllocationRD(num_soilc, filter_soilc, &
-           col_plant_ndemand_vr(begc:endc,1:nlevdecomp), & ! IN
-           potential_immob_vr(begc:endc,1:nlevdecomp),   & ! IN
-           AllocParamsInst%compet_plant_nh4,        & ! IN
-           AllocParamsInst%compet_decomp_nh4,       & ! IN
-           dt,                               & ! IN
-           smin_nh4_vr(begc:endc,1:nlevdecomp),     & ! IN
-           fpi_nh4_vr(1:num_soilc,1:nlevdecomp),    & ! OUT
-           actual_immob_nh4_vr(begc:endc,1:nlevdecomp), & ! OUT
-           smin_nh4_to_plant_vr(begc:endc,1:nlevdecomp),& ! OUT
-           smin_no3_vr(begc:endc,1:nlevdecomp),     & ! IN
-           AllocParamsInst%compet_plant_no3,        & ! IN
-           AllocParamsInst%compet_decomp_no3,       & ! IN
-           AllocParamsInst%compet_nit,              & ! IN
-           AllocParamsInst%compet_denit,            & ! IN
-           pot_f_nit_vr(begc:endc,1:nlevdecomp),    & ! IN
-           pot_f_denit_vr(begc:endc,1:nlevdecomp),  & ! IN
-           fpi_no3_vr(1:num_soilc,1:nlevdecomp),    & ! OUT
-           actual_immob_no3_vr(begc:endc,1:nlevdecomp),& ! OUT
-           smin_no3_to_plant_vr(begc:endc,1:nlevdecomp),&! OUT
-           f_nit_vr(begc:endc,1:nlevdecomp),           & ! OUT
-           f_denit_vr(begc:endc,1:nlevdecomp))           ! OUT
-   end if
-     !$acc parallel loop independent collapse(2) gang vector default(present)
-      do j = 1, nlevdecomp
-         do fc=1,num_soilc !col_loop
-           c = filter_soilc(fc)
-           l = col_pp%landunit(c)
+
+     if (nu_com .eq. 'RD') then ! 'RD' : relative demand approach
+
+        ! Starting resolving N/P limitation
+        ! calculate nuptake & puptake profile
+        call calc_nuptake_prof(bounds, num_soilc, filter_soilc, cnstate_vars, nuptake_prof)
+        call calc_puptake_prof(bounds, num_soilc, filter_soilc, cnstate_vars, puptake_prof)
+
+     elseif (nu_com .eq. 'ECA' .or. nu_com .eq. 'MIC') then
+
+        if(use_fates)then
+           n_pcomp = size(elm_fates%fates(1)%bc_out(1)%ft_index) ! max number of plant competitors
+           allocate(filter_pcomp(n_pcomp));filter_pcomp(:) = -1
+           allocate(plant_nh4demand_vr_fates(n_pcomp,nlevdecomp)); plant_nh4demand_vr_fates(:,:) = nan
+           allocate(plant_no3demand_vr_fates(n_pcomp,nlevdecomp)); plant_no3demand_vr_fates(:,:) = nan
+           allocate(plant_pdemand_vr_fates(n_pcomp,nlevdecomp));   plant_pdemand_vr_fates(:,:) = nan
+        else
+           n_pcomp = bounds%endp-bounds%begp+1   ! max number of plant competitors
+           allocate(filter_pcomp(n_pcomp));filter_pcomp(:) = -1
+           do fp=1,num_soilp
+              p = filter_soilp(fp)
+              smin_nh4_to_plant_patch(p) = 0.0_r8
+              smin_no3_to_plant_patch(p) = 0.0_r8
+              sminn_to_plant_patch(p) = 0.0_r8
+              sminp_to_plant_patch(p) = 0.0_r8
+           end do
+        end if
+
+     end if
+
+
+
+     col_loop: do fc=1,num_soilc
+
+        c = filter_soilc(fc)
+        l = col_pp%landunit(c)
+
+        ! ------------------------------------------------------------------------------
+        ! PART I.
+        ! Determine the boundary conditions for the competitive allocation modules
+        ! This is mostly about pointing to either the big-leaf or FATES boundary
+        ! conditions.
+        ! ------------------------------------------------------------------------------
+
+        if(use_fates) then
+
+           ci      = bounds%clump_index
+           s       = elm_fates%f2hmap(ci)%hsites(c)
+           n_pcomp = elm_fates%fates(ci)%bc_out(s)%num_plant_comps
+           pci     = 1
+           pcf     = n_pcomp
+           
+           if( nu_com.eq.'RD') then
+
+              ! Overwrite the column level demands, since fates plants are all sharing
+              ! the same space, in units per the same square meter, we just add demand
+              ! to scale up to column
+              plant_ndemand_col(c) = sum(elm_fates%fates(ci)%bc_out(s)%n_demand(1:n_pcomp))
+              plant_pdemand_col(c) = sum(elm_fates%fates(ci)%bc_out(s)%p_demand(1:n_pcomp))
+
+              ! We fill the vertically resolved array to simplify some jointly used code
+              do j = 1, nlevdecomp
+                 col_plant_ndemand_vr(c,j) = plant_ndemand_col(c) * nuptake_prof(c,j)
+                 col_plant_pdemand_vr(c,j) = plant_pdemand_col(c) * puptake_prof(c,j)
+              end do
+
+           else  !(ECA)
+
+              do f = 1,n_pcomp
+                 filter_pcomp(f) = f
+              end do
+
+              veg_rootc_ptr  => elm_fates%fates(ci)%bc_out(s)%veg_rootc
+              ft_index_ptr   => elm_fates%fates(ci)%bc_out(s)%ft_index      ! Should be 
+              decompmicc(:)  =  elm_fates%fates(ci)%bc_out(s)%decompmicc(:) ! Should be (nlevdecomp)
+
+              cn_scalar_ptr          => elm_fates%fates(ci)%bc_out(s)%cn_scalar          ! (i,j)
+              cn_scalar_runmean_ptr  => elm_fates%fates(ci)%bc_out(s)%cn_scalar          ! (i,j)
+              plant_nh4demand_vr_ptr => plant_nh4demand_vr_fates
+              km_nh4_ptr             => elm_fates%fates(ci)%bc_pconst%eca_km_nh4
+              vmax_nh4_ptr           => elm_fates%fates(ci)%bc_pconst%eca_vmax_nh4
+              plant_no3demand_vr_ptr => plant_no3demand_vr_fates
+              km_no3_ptr             => elm_fates%fates(ci)%bc_pconst%eca_km_no3
+              vmax_no3_ptr           => elm_fates%fates(ci)%bc_pconst%eca_vmax_no3
+              cp_scalar_ptr          => elm_fates%fates(ci)%bc_out(s)%cp_scalar
+              cp_scalar_runmean_ptr  => elm_fates%fates(ci)%bc_out(s)%cp_scalar
+              plant_pdemand_vr_ptr   => plant_pdemand_vr_fates
+              km_p_ptr               => elm_fates%fates(ci)%bc_pconst%eca_km_p
+              vmax_p_ptr             => elm_fates%fates(ci)%bc_pconst%eca_vmax_p
+
+           end if
+
+        else   ! USE ELM Native vegetation (i.e. use_cn), not FATES
+
+           pci     = col_pp%pfti(c) ! Initial plant competitor index
+           pcf     = col_pp%pftf(c) ! Final plant competitor index
+           
+           if (nu_com .eq. 'RD') then
+
+              do j = 1, nlevdecomp
+                 col_plant_ndemand_vr(c,j) = plant_ndemand_col(c) * nuptake_prof(c,j)
+                 col_plant_pdemand_vr(c,j) = plant_pdemand_col(c) * puptake_prof(c,j)
+              end do
+
+           else
+              
+              f = 0
+              decompmicc(:) = 0._r8
+              do p = col_pp%pfti(c), col_pp%pftf(c)
+                 if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
+                    f = f + 1
+                    filter_pcomp(f) = p
+                    ft_index_bigleaf(p) = ivt(p)
+                    do j = 1,nlevdecomp
+
+                       ! microbial decomposer biomass [gc/m3]
+                       decompmicc(j) = decompmicc(j) + decompmicc_patch_vr(ivt(p),j)*veg_pp%wtcol(p)
+
+                       ! [gC/m2] fine root C in column =
+                       !         fine root C in patch [gC/m2]  * fraction in layer [-] * [m2/m2] patch fraction
+                       veg_rootc_bigleaf(p,j) = frootc(p)*froot_prof(p,j)*veg_pp%wtcol(p)
+
+                    end do
+                 end if
+              end do
+              n_pcomp = f
+              
+              ft_index_ptr   => ft_index_bigleaf
+              veg_rootc_ptr  => veg_rootc_bigleaf
+
+              cn_scalar(col_pp%pfti(c):col_pp%pftf(c)) = 0._r8
+              plant_no3demand_vr_patch(col_pp%pfti(c):col_pp%pftf(c),:) = 0._r8
+              plant_nh4demand_vr_patch(col_pp%pfti(c):col_pp%pftf(c),:) = 0._r8
+
+              if (.not.(carbonphosphorus_only .or. carbon_only))then
+                 do f = 1,n_pcomp
+                    p = filter_pcomp(f)
+                    cn_scalar(p) = min(max(((leafc(p) + leafc_storage(p) + leafc_xfer(p))/ &
+                         max(leafn(p) + leafn_storage(p) + leafn_xfer(p), 1e-20_r8) - &
+                         leafcn(ivt(p))*(1- cn_stoich_var)) / &
+                         (leafcn(ivt(p)) - leafcn(ivt(p))*(1- cn_stoich_var)),0.0_r8),1.0_r8)
+                 end do
+              end if
+              
+              km_nh4_ptr    => km_plant_nh4
+              vmax_nh4_ptr  => vmax_plant_nh4
+              cn_scalar_ptr => cn_scalar
+              cn_scalar_runmean_ptr => cn_scalar_runmean
+              km_no3_ptr   => km_plant_no3
+              vmax_no3_ptr => vmax_plant_no3
+              plant_no3demand_vr_ptr => plant_no3demand_vr_patch
+              plant_nh4demand_vr_ptr => plant_nh4demand_vr_patch
+
+              cp_scalar(col_pp%pfti(c):col_pp%pftf(c)) = 0._r8
+              plant_pdemand_vr_patch(col_pp%pfti(c):col_pp%pftf(c),:) = 0._r8
+
+              if ( .not. (carbonnitrogen_only .or. carbon_only) ) then
+                 do f = 1,n_pcomp
+                    p = filter_pcomp(f)
+                    cp_scalar(p) = min(max(((leafc(p) + leafc_storage(p) + leafc_xfer(p)) / &
+                         max(leafp(p) + leafp_storage(p) + leafp_xfer(p), 1e-20_r8) - &
+                         leafcp(ivt(p))*(1- cp_stoich_var)) / &
+                         (leafcp(ivt(p)) - leafcp(ivt(p))*(1- cp_stoich_var)),0.0_r8),1.0_r8)
+                 end do
+              end if
+              plant_pdemand_vr_ptr => plant_pdemand_vr_patch
+              cp_scalar_runmean_ptr => cp_scalar_runmean
+              km_p_ptr      => km_plant_p
+              vmax_p_ptr    => vmax_plant_p
+           end if
+
+        end if
+
+
+
+
+        ! Starting resolving N limitation !!!
+        ! =============================================================
+        ! This section is modified, Aug 2015 by Q. Zhu
+        ! (1) add nitrogen and phosphorus competition
+        ! (2) nitrogen and phosphorus uptake is based on root kinetics
+        ! (3) no second pass nutrient uptake for plants
+        ! ============================================================= 
+
+        if (nu_com .eq. 'RD') then
+
+
+           ! Estimate actual allocation rates via Relative Demand
+           ! approach (RD)
+           
+           call NAllocationRD(col_plant_ndemand_vr(c,:), & ! IN
+                potential_immob_vr(c,:),                 & ! IN
+                AllocParamsInst%compet_plant_nh4,        & ! IN
+                AllocParamsInst%compet_decomp_nh4,       & ! IN
+                dt,                                      & ! IN
+                smin_nh4_vr(c,:),                        & ! IN
+                fpi_nh4_vr(:),                           & ! OUT
+                actual_immob_nh4_vr(c,:),                & ! OUT
+                smin_nh4_to_plant_vr(c,:),               & ! OUT
+                smin_no3_vr(c,:),                        & ! IN
+                AllocParamsInst%compet_plant_no3,        & ! IN
+                AllocParamsInst%compet_decomp_no3,       & ! IN
+                AllocParamsInst%compet_nit,              & ! IN
+                AllocParamsInst%compet_denit,            & ! IN
+                pot_f_nit_vr(c,:),                       & ! IN
+                pot_f_denit_vr(c,:),                     & ! IN
+                fpi_no3_vr(:),                           & ! OUT
+                actual_immob_no3_vr(c,:),                & ! OUT
+                smin_no3_to_plant_vr(c,:),               & ! OUT
+                f_nit_vr(c,:),                           & ! OUT
+                f_denit_vr(c,:))                           ! OUT
+
+        else
+
+           ! Estimate actual allocation rates via Capacitance Aquisition
+           ! approach (ECA/CA)
+           
+            call NAllocationECAMIC(pci,dt,                            & ! IN
+                                   bd(c,:),                           & ! IN
+                                   h2osoi_vol(c,:),                   & ! IN
+                                   t_scalar(c,:),                     & ! IN
+                                   n_pcomp,                           & ! IN 
+                                   filter_pcomp(1:n_pcomp),           & ! IN
+                                   veg_rootc_ptr(pci:pcf,:),          & ! IN
+                                   ft_index_ptr(pci:pcf),             & ! IN
+                                   cn_scalar_runmean_ptr(pci:pcf),     & ! IN
+                                   decompmicc,                        & ! IN
+                                   smin_nh4_vr(c,:),                  & ! IN
+                                   nu_com,                            & ! IN 
+                                   km_nh4_ptr,                        & ! IN
+                                   vmax_nh4_ptr,                      & ! IN
+                                   km_decomp_nh4,                     & ! IN
+                                   potential_immob_vr(c,:),           & ! IN
+                                   plant_nh4demand_vr_ptr(pci:pcf,:), & ! INOUT
+                                   col_plant_nh4demand_vr(c,:),       & ! OUT
+                                   fpi_nh4_vr(:),                     & ! OUT
+                                   actual_immob_nh4_vr(c,:),          & ! OUT
+                                   smin_nh4_to_plant_vr(c,:),         & ! OUT
+                                   smin_no3_vr(c,:),                  & ! IN
+                                   km_no3_ptr,                        & ! IN
+                                   vmax_no3_ptr,                      & ! IN
+                                   km_decomp_no3,                     & ! IN
+                                   km_nit,                            & ! IN
+                                   km_den,                            & ! IN
+                                   pot_f_nit_vr(c,:),                 & ! IN
+                                   pot_f_denit_vr(c,:),               & ! IN
+                                   plant_no3demand_vr_ptr(pci:pcf,:), & ! INOUT
+                                   col_plant_no3demand_vr(c,:),       & ! OUT
+                                   fpi_no3_vr(:),                     & ! OUT
+                                   actual_immob_no3_vr(c,:),          & ! OUT
+                                   smin_no3_to_plant_vr(c,:),         & ! OUT
+                                   f_nit_vr(c,:),                     & ! OUT
+                                   f_denit_vr(c,:))                     ! OUT
+
+            col_plant_ndemand_vr(c,:) = col_plant_nh4demand_vr(c,:)+col_plant_no3demand_vr(c,:)
+      
+        end if
+
+
+        do j = 1, nlevdecomp
+
            ! n2o emissions: n2o from nitr is const fraction, n2o from denitr is calculated in nitrif_denitrif
            f_n2o_nit_vr(c,j) = f_nit_vr(c,j) * nitrif_n2o_loss_frac
            f_n2o_denit_vr(c,j) = f_denit_vr(c,j) / (1._r8 + n2_n2o_ratio_denit_vr(c,j))
@@ -1114,174 +1326,312 @@ contains
            ! deficit for NO3 to meet allocation needs, is only added to the NH4 pool.
            ! Thus, the NH4 fluxes are increased, for itself and as a surrogate to meet the
            ! NO3 flux demands.
-
+           
            if (carbon_only .or. carbonphosphorus_only) then
-
-              if ( fpi_no3_vr(fc,j) + fpi_nh4_vr(fc,j) < 1._r8 ) then
+              
+              if ( fpi_no3_vr(j) + fpi_nh4_vr(j) < 1._r8 ) then
                  fpi_vr(c,j) = 1._r8
-                 fpi_nh4_vr(fc,j) = 1.0_r8 - fpi_no3_vr(fc,j)
+                 fpi_nh4_vr(j) = 1.0_r8 - fpi_no3_vr(j)
                  supplement_to_sminn_vr(c,j) = (potential_immob_vr(c,j) - actual_immob_no3_vr(c,j)) - actual_immob_nh4_vr(c,j)
                  ! update to new values that satisfy demand
                  actual_immob_nh4_vr(c,j) = potential_immob_vr(c,j) -  actual_immob_no3_vr(c,j)
               end if
 
-              !if (nu_com .eq. 'RD') then
-               if ( smin_no3_to_plant_vr(c,j) + smin_nh4_to_plant_vr(c,j) < col_plant_ndemand_vr(c,j)) then
-                   supplement_to_sminn_vr(c,j) = supplement_to_sminn_vr(c,j) + &
-                        col_plant_ndemand_vr(c,j) - (smin_no3_to_plant_vr(c,j) + smin_nh4_to_plant_vr(c,j))
-
-                   ! update to new values that satisfy demand
-                   smin_nh4_to_plant_vr(c,j) = col_plant_ndemand_vr(c,j) - smin_no3_to_plant_vr(c,j)
-               end if
-              !else
+              if (nu_com .eq. 'RD') then
+                 if ( smin_no3_to_plant_vr(c,j) + smin_nh4_to_plant_vr(c,j) < col_plant_ndemand_vr(c,j)) then
+                    supplement_to_sminn_vr(c,j) = supplement_to_sminn_vr(c,j) + &
+                         col_plant_ndemand_vr(c,j) - (smin_no3_to_plant_vr(c,j) + smin_nh4_to_plant_vr(c,j))
+                    ! update to new values that satisfy demand
+                    smin_nh4_to_plant_vr(c,j) = col_plant_ndemand_vr(c,j) - smin_no3_to_plant_vr(c,j)
+                 end if
+              else
+                 supplement_to_sminn_vr(c,j) = supplement_to_sminn_vr(c,j) + col_plant_ndemand_vr(c,j)
+                 smin_nh4_to_plant_vr(c,j) = col_plant_ndemand_vr(c,j) - smin_no3_to_plant_vr(c,j)
+              end if
+              
 
+              
            end if
 
            ! sum up nitrogen limitation to decomposition
-           fpi_vr(c,j) = fpi_nh4_vr(fc,j) + fpi_no3_vr(fc,j)
+           fpi_vr(c,j) = fpi_nh4_vr(j) + fpi_no3_vr(j)
 
            ! sum up no3 and nh4 fluxes
            sminn_to_plant_vr(c,j) = smin_no3_to_plant_vr(c,j) + smin_nh4_to_plant_vr(c,j)
            actual_immob_vr(c,j) = actual_immob_no3_vr(c,j) + actual_immob_nh4_vr(c,j)
-         end do ! col loop
-      end do ! nlevdecomp
 
+        end do
 
         ! Starting resolving P limitation !!!
         ! =============================================================
+
         if (nu_com .eq. 'RD') then
+
            ! Relative Demand (RD)
-           call PAllocationRD(num_soilc,filter_soilc, &
-                col_plant_pdemand_vr(begc:endc,1:nlevdecomp), & ! IN
-                potential_immob_p_vr(begc:endc,1:nlevdecomp),               & ! IN
-                solutionp_vr(begc:endc,1:nlevdecomp),                       & ! IN
+           
+           call PAllocationRD(col_plant_pdemand_vr(c,:), & ! IN
+                potential_immob_p_vr(c,:),               & ! IN
+                solutionp_vr(c,:),                       & ! IN
                 dt,                                      & ! IN
-                fpi_p_vr(begc:endc,1:nlevdecomp),                           & ! OUT
-                actual_immob_p_vr(begc:endc,1:nlevdecomp),                  & ! OUT
-                sminp_to_plant_vr(begc:endc,1:nlevdecomp),                  & ! OUT
-                supplement_to_sminp_vr(begc:endc,1:nlevdecomp))               ! OUT
+                fpi_p_vr(c,:),                           & ! OUT
+                actual_immob_p_vr(c,:),                  & ! OUT
+                sminp_to_plant_vr(c,:),                  & ! OUT
+                supplement_to_sminp_vr(c,:))               ! OUT
+            
+        else
+
+           call PAllocationECAMIC(pci,dt,           & ! IN
+                h2osoi_vol(c,:),                    & ! IN
+                t_scalar(c,:),                      & ! IN 
+                gross_pmin_vr(c,:),                 & ! IN  
+                potential_immob_p_vr(c,:),          & ! IN  
+                biochem_pmin_vr_col(c,:),           & ! IN  
+                primp_to_labilep_vr_col(c,:),       & ! IN  
+                pdep_to_sminp(c),                   & ! IN  
+                pdep_prof(c,:),                     & ! IN  
+                vmax_minsurf_p_vr(isoilorder(c),:), & ! IN 
+                km_minsurf_p_vr(isoilorder(c),:),   & ! IN 
+                solutionp_vr(c,:),                  & ! IN 
+                nu_com,                             & ! IN  
+                n_pcomp,                            & ! IN 
+                filter_pcomp(1:n_pcomp),            & ! IN
+                veg_rootc_ptr(pci:pcf,:),           & ! IN  
+                ft_index_ptr(pci:pcf),              & ! IN 
+                decompmicc,                         & ! IN  
+                cp_scalar_runmean_ptr(pci:pcf),     & ! IN  
+                km_p_ptr(:),                        & ! IN 
+                vmax_p_ptr(:),                      & ! IN 
+                km_decomp_p,                        & ! IN  
+                labilep_vr(c,:),                    & ! IN 
+                plant_pdemand_vr_ptr(pci:pcf,:),    & ! INOUT
+                col_plant_pdemand_vr(c,:),          & ! OUT 
+                adsorb_to_labilep_vr(c,:),          & ! OUT
+                fpi_p_vr(c,:),                      & ! OUT
+                actual_immob_p_vr(c,:),             & ! OUT
+                sminp_to_plant_vr(c,:),             & ! OUT 
+                desorb_to_solutionp_vr(c,:),        & ! OUT
+                supplement_to_sminp_vr(c,:))          ! OUT
+
+           ! This is effectively only relevant with FATES
+           ! big-leaf ECA would have 0 demand at this point
+           ! and calculates supplement and need later on in allocation3
+           if ( carbon_only .or. carbonnitrogen_only) then
+              do j = 1, nlevdecomp
+                 sminp_to_plant_vr(c,j)      = col_plant_pdemand_vr(c,j)
+                 supplement_to_sminp_vr(c,j) = col_plant_pdemand_vr(c,j)
+              end do
+           end if
+           
         end if ! end of P competition
 
          !  resolving N limitation vs. P limitation for decomposition
          !  update (1) actual immobilization for N and P (2) sminn_to_plant and sminp_to_plant
          !  We only resolve co-limitations when are supplementing neither element
+         
+         np_bothactive: if ( .not.carbon_only .and.  &
+              .not.carbonphosphorus_only .and. &
+              .not.carbonnitrogen_only ) then
 
-     np_bothactive: if ( .not.carbon_only .and.  &
-                         .not.carbonphosphorus_only .and. &
-                         .not.carbonnitrogen_only ) then
+           if (nu_com .eq. 'RD') then
+              do j = 1, nlevdecomp
+                 if( fpi_vr(c,j) <= fpi_p_vr(c,j) )then ! more N limited
+                    do k = 1, ndecomp_cascade_transitions
+                       if (pmnf_decomp_cascade(c,j,k) > 0.0_r8 .and. pmpf_decomp_cascade(c,j,k) > 0.0_r8) then
+                          actual_immob_p_vr(c,j) = actual_immob_p_vr(c,j) - pmpf_decomp_cascade(c,j,k)&
+                               *(fpi_p_vr(c,j)-fpi_vr(c,j))
+                       end if
+                    end do
+                 else
+                    if (fpi_nh4_vr(j) > fpi_p_vr(c,j)) then ! more P limited
+                       do k = 1, ndecomp_cascade_transitions
+                          if (pmnf_decomp_cascade(c,j,k) > 0.0_r8 .and. pmpf_decomp_cascade(c,j,k) > 0.0_r8) then
+                             actual_immob_nh4_vr(c,j) = actual_immob_nh4_vr(c,j) - pmnf_decomp_cascade(c,j,k) &
+                                  * (fpi_nh4_vr(j) - fpi_p_vr(c,j))
+                             actual_immob_no3_vr(c,j) = actual_immob_no3_vr(c,j) - pmnf_decomp_cascade(c,j,k) * fpi_no3_vr(j)
+                          end if
+                       end do
+                    else
+                       do k = 1, ndecomp_cascade_transitions
+                          if (pmnf_decomp_cascade(c,j,k) > 0.0_r8 .and. pmpf_decomp_cascade(c,j,k) > 0.0_r8) then
+                             actual_immob_no3_vr(c,j) = actual_immob_no3_vr(c,j) - pmnf_decomp_cascade(c,j,k) * &
+                                  (fpi_nh4_vr(j) + fpi_no3_vr(j) - fpi_p_vr(c,j) )
+                          end if
+                       end do
+                    end if
+                 endif
+                 ! sum up no3 and nh4 fluxes
+                 actual_immob_vr(c,j) = actual_immob_no3_vr(c,j) + actual_immob_nh4_vr(c,j)
 
-            !$acc enter data create(sum1,sum2,sum3,sum4,sum5,sum6)
+              end do
 
-           !if (nu_com .eq. 'RD') then
-           !$acc parallel loop independent collapse(2) gang worker private(c,sum1,sum2) default(present)
-           do fc = 1, num_soilc
+           else
+              ! ECA mode or MIC outcompete plant mode, be consistent with the idea
+              ! apply generic flux limiter based on Tang 2016 doi:10.5194/bg-13-723-2016
               do j = 1, nlevdecomp
-                 c= filter_soilc(fc)
-                 sum1 = 0._r8
-                 sum2 = 0._r8
-                 if( fpi_vr(c,j) <= fpi_p_vr(c,j) )then ! more N limited
-                    !$acc loop vector reduction(+:sum1)
+
+                 excess_immob_nh4_vr(j) = 0.0_r8
+                 excess_immob_no3_vr(j) = 0.0_r8
+                 excess_immob_p_vr(j) = 0.0_r8
+                 if( fpi_vr(c,j) <=fpi_p_vr(c,j) )then ! more N limited
                     do k = 1, ndecomp_cascade_transitions
                        if (pmnf_decomp_cascade(c,j,k) > 0.0_r8 .and. pmpf_decomp_cascade(c,j,k) > 0.0_r8) then
-                           sum1 = sum1 - pmpf_decomp_cascade(c,j,k) *(fpi_p_vr(c,j)-fpi_vr(c,j))
+                          excess_immob_p_vr(j) = excess_immob_p_vr(j) + pmpf_decomp_cascade(c,j,k) *(fpi_p_vr(c,j)&
+                               -fpi_vr(c,j))
+                          actual_immob_p_vr(c,j) = actual_immob_p_vr(c,j) - pmpf_decomp_cascade(c,j,k) *(fpi_p_vr(c,j)&
+                               -fpi_vr(c,j))
                        end if
                     end do
-                    actual_immob_p_vr(c,j) = actual_immob_p_vr(c,j) + sum1
                  else
-                    if (fpi_nh4_vr(fc,j) > fpi_p_vr(fc,j)) then ! more P limited
-                       !$acc loop vector reduction(+:sum1,sum2)
+                    if (fpi_nh4_vr(j) > fpi_p_vr(c,j)) then ! more P limited
                        do k = 1, ndecomp_cascade_transitions
                           if (pmnf_decomp_cascade(c,j,k) > 0.0_r8 .and. pmpf_decomp_cascade(c,j,k) > 0.0_r8) then
-                              sum1 = sum1 - pmnf_decomp_cascade(c,j,k) * (fpi_nh4_vr(fc,j) - fpi_p_vr(c,j))
-                              sum2 = sum2 - pmnf_decomp_cascade(c,j,k) * fpi_no3_vr(fc,j)
+                             excess_immob_nh4_vr(j) = excess_immob_nh4_vr(j) + pmnf_decomp_cascade(c,j,k) &
+                                  * (fpi_nh4_vr(j) - fpi_p_vr(c,j))
+                             excess_immob_no3_vr(j) = excess_immob_no3_vr(j) + pmnf_decomp_cascade(c,j,k) * fpi_no3_vr(j)
+                             actual_immob_nh4_vr(c,j) = actual_immob_nh4_vr(c,j) - pmnf_decomp_cascade(c,j,k) &
+                                  * (fpi_nh4_vr(j) - fpi_p_vr(c,j))
+                             actual_immob_no3_vr(c,j) = actual_immob_no3_vr(c,j) - pmnf_decomp_cascade(c,j,k) * fpi_no3_vr(j)
                           end if
                        end do
-                       actual_immob_nh4_vr(c,j) = actual_immob_nh4_vr(c,j)+ sum1
-                       actual_immob_no3_vr(c,j) = actual_immob_no3_vr(c,j)+ sum2
                     else
-                       !$acc loop vector reduction(+:sum1)
                        do k = 1, ndecomp_cascade_transitions
                           if (pmnf_decomp_cascade(c,j,k) > 0.0_r8 .and. pmpf_decomp_cascade(c,j,k) > 0.0_r8) then
-                             sum1  = actual_immob_no3_vr(c,j) - pmnf_decomp_cascade(c,j,k) * &
-                                  (fpi_nh4_vr(fc,j) + fpi_no3_vr(fc,j) - fpi_p_vr(c,j) )
+                             excess_immob_no3_vr(j) = excess_immob_no3_vr(j) + pmnf_decomp_cascade(c,j,k) &
+                                  * (fpi_nh4_vr(j) + fpi_no3_vr(j) - fpi_p_vr(c,j) )
+                             actual_immob_no3_vr(c,j) = actual_immob_no3_vr(c,j) - pmnf_decomp_cascade(c,j,k) &
+                                  * (fpi_nh4_vr(j) + fpi_no3_vr(j) - fpi_p_vr(c,j) )
                           end if
                        end do
-                       actual_immob_no3_vr(c,j) = actual_immob_no3_vr(c,j) + sum1
                     end if
                  endif
                  ! sum up no3 and nh4 fluxes
                  actual_immob_vr(c,j) = actual_immob_no3_vr(c,j) + actual_immob_nh4_vr(c,j)
+
+              end do
+
+              do j = 1, nlevdecomp
+
+                 smin_nh4_to_plant_vr(c,j) = min( smin_nh4_to_plant_vr(c,j)+excess_immob_nh4_vr(j)&
+                      ,col_plant_nh4demand_vr(c,j) )
+                 smin_no3_to_plant_vr(c,j) = min( smin_no3_to_plant_vr(c,j)+excess_immob_no3_vr(j)&
+                      ,col_plant_no3demand_vr(c,j) )
+                 sminp_to_plant_vr(c,j) = min( sminp_to_plant_vr(c,j) + excess_immob_p_vr(j),col_plant_pdemand_vr(c,j))
+
               end do
-           end do ! end col loops
-           !else
-           !end if
+           end if
         endif np_bothactive
 
-      if(carbonnitrogen_only)then
-         !$acc parallel loop independent collapse(2) gang vector private(c) default(present)
-         do fc = 1, num_soilc
+        if(carbonnitrogen_only)then
            do j = 1, nlevdecomp
-             c = filter_soilc(fc)
-             actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j) * fpi_vr(c,j)
+              actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j) * fpi_vr(c,j)
            end do
-        end do
-      end if
+        end if
 
-      if(carbonphosphorus_only)then
-         !$acc parallel loop independent collapse(2) gang vector private(c) default(present)
-         do fc = 1, num_soilc
+        if(carbonphosphorus_only)then
            do j = 1, nlevdecomp
-             c = filter_soilc(fc)
               actual_immob_vr(c,j) = potential_immob_vr(c,j) * fpi_p_vr(c,j)
            end do
-        end do
-      end if
-
-      ! sum up plant N/P uptake at column level and patch level
-      ! sum up N fluxes to plant after initial competition
-      !$acc parallel loop independent gang worker private(c,sum1,sum2) default(present)
-      do fc = 1, num_soilc
-        c = filter_soilc(fc)
-        sum1 = 0._r8
-        sum2 = 0._r8
-        !$acc loop vector reduction(+:sum1,sum2)
+        end if
+        
+        ! sum up plant N/P uptake at column level and patch level
+        ! sum up N fluxes to plant after initial competition
+        sminn_to_plant(c) = 0._r8
+        sminp_to_plant(c) = 0._r8
         do j = 1, nlevdecomp
-           sum1 = sum1  + sminn_to_plant_vr(c,j) * dzsoi_decomp(j)
-           sum2 = sum2 + sminp_to_plant_vr(c,j) * dzsoi_decomp(j)
+           sminn_to_plant(c) = sminn_to_plant(c) + sminn_to_plant_vr(c,j) * dzsoi_decomp(j)
+           sminp_to_plant(c) = sminp_to_plant(c) + sminp_to_plant_vr(c,j) * dzsoi_decomp(j)
         end do
-        sminn_to_plant(c) = sum1
-        sminp_to_plant(c) = sum2
-     end do !col_loop
+        
+        ! update column plant N/P demand, pft level plant NP uptake for ECA and MIC mode
+        eca_filter: if (nu_com .eq. 'ECA' .or. nu_com .eq. 'MIC') then
 
-     ! sum up N fluxes to immobilization
-     !$acc parallel loop independent gang worker private(c,sum1,sum2,sum3,sum4,sum5,sum6) default(present)
-     do fc=1,num_soilc
-        c = filter_soilc(fc)
-        sum1 = 0._r8; sum2 = 0._r8;
-        sum3 = 0._r8;sum4 = 0._r8;
-        sum5 = 0._r8;sum6 = 0._r8;
-        !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5,sum6)
-        do j = 1, nlevdecomp
-           sum1 = sum1 + actual_immob_vr(c,j) * dzsoi_decomp(j)
-           sum2 = sum2 + potential_immob_vr(c,j) * dzsoi_decomp(j)
-           sum3 = sum3 + actual_immob_no3_vr(c,j) * dzsoi_decomp(j)
-           sum4 = sum4 + actual_immob_nh4_vr(c,j) * dzsoi_decomp(j)
-           sum5 = sum5 + actual_immob_p_vr(c,j) * dzsoi_decomp(j)
-           sum6 = sum6 + potential_immob_p_vr(c,j) * dzsoi_decomp(j)
-        end do
-        actual_immob(c)     = sum1
-        potential_immob(c)  = sum2
-        actual_immob_no3(c) = sum3
-        actual_immob_nh4(c) = sum4
-        actual_immob_p(c)   = sum5
-        potential_immob_p(c)= sum6
-     end do
+           plant_ndemand_col(c) = 0._r8
+           plant_pdemand_col(c) = 0._r8
+           do j = 1, nlevdecomp
+              plant_ndemand_col(c) = plant_ndemand_col(c) + col_plant_ndemand_vr(c,j) * dzsoi_decomp(j)
+              plant_pdemand_col(c) = plant_pdemand_col(c) + col_plant_pdemand_vr(c,j) * dzsoi_decomp(j)
+           end do
 
-     !$acc parallel loop independent gang vector private(c) default(present)
-     do fc=1,num_soilc
-        c = filter_soilc(fc)
-        ! calculate the fraction of potential growth that can be
-        ! acheived with the N available to plants
+           do j = 1, nlevdecomp
+
+              if (col_plant_nh4demand_vr(c,j) > 0._r8 ) then
+                 fpg_nh4_vr(c,j) = smin_nh4_to_plant_vr(c,j)/col_plant_nh4demand_vr(c,j)
+              else
+                 fpg_nh4_vr(c,j) = 1.0_r8
+              end if
+              if (col_plant_no3demand_vr(c,j) > 0._r8) then
+                 fpg_no3_vr(c,j) = smin_no3_to_plant_vr(c,j)/col_plant_no3demand_vr(c,j)
+              else
+                 fpg_no3_vr(c,j) = 1.0_r8
+              end if
+              if (col_plant_pdemand_vr(c,j) > 0._r8) then
+                 fpg_p_vr(c,j) = sminp_to_plant_vr(c,j)/col_plant_pdemand_vr(c,j)
+              else
+                 fpg_p_vr(c,j) = 1.0_r8
+              end if
+              if(.not.use_fates) then
+                 do p = col_pp%pfti(c), col_pp%pftf(c)
+                    if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
+
+                       ! Convert from /m2 of the column, to /m2 of the pft
+                       plant_nh4demand_vr_patch(p,j) = plant_nh4demand_vr_patch(p,j)/veg_pp%wtcol(p)
+                       plant_no3demand_vr_patch(p,j) = plant_no3demand_vr_patch(p,j)/veg_pp%wtcol(p)
+                       plant_pdemand_vr_patch(p,j)   = plant_pdemand_vr_patch(p,j)/veg_pp%wtcol(p)
+
+                       smin_nh4_to_plant_patch(p) = smin_nh4_to_plant_patch(p) + &
+                            plant_nh4demand_vr_patch(p,j) * fpg_nh4_vr(c,j)*dzsoi_decomp(j)
+                       smin_no3_to_plant_patch(p) = smin_no3_to_plant_patch(p) + &
+                            plant_no3demand_vr_patch(p,j) * fpg_no3_vr(c,j)*dzsoi_decomp(j)
+                       sminp_to_plant_patch(p) = sminp_to_plant_patch(p) + &
+                            plant_pdemand_vr_patch(p,j) * fpg_p_vr(c,j)*dzsoi_decomp(j)
+                    end if
+                 end do
+              end if
+                 
+           end do
+
+        end if eca_filter
+
+     end do col_loop
+
+ 
+     if ((nu_com .eq. 'ECA' .or. nu_com .eq. 'MIC')) then
+        deallocate(filter_pcomp)
+        if(.not.use_fates)then
+           do fp=1,num_soilp
+              p = filter_soilp(fp)
+              sminn_to_plant_patch(p) = smin_nh4_to_plant_patch(p) + smin_no3_to_plant_patch(p)
+           end do
+        end if
+     end if
+
+     ! sum up N fluxes to immobilization
+     do fc=1,num_soilc
+        c = filter_soilc(fc)
+        actual_immob(c) = 0._r8
+        potential_immob(c) = 0._r8
+        actual_immob_no3(c) = 0._r8
+        actual_immob_nh4(c) = 0._r8
+        actual_immob_p(c) = 0._r8
+        potential_immob_p(c) = 0._r8
+     end do
+     do j = 1, nlevdecomp
+        do fc=1,num_soilc
+           c = filter_soilc(fc)
+           actual_immob(c) = actual_immob(c) + actual_immob_vr(c,j) * dzsoi_decomp(j)
+           potential_immob(c) = potential_immob(c) + potential_immob_vr(c,j) * dzsoi_decomp(j)
+           actual_immob_no3(c)= actual_immob_no3(c) + actual_immob_no3_vr(c,j) * dzsoi_decomp(j)
+           actual_immob_nh4(c)= actual_immob_nh4(c) + actual_immob_nh4_vr(c,j) * dzsoi_decomp(j)
+           actual_immob_p(c) = actual_immob_p(c) + actual_immob_p_vr(c,j) * dzsoi_decomp(j)
+           potential_immob_p(c) = potential_immob_p(c) + potential_immob_p_vr(c,j) * dzsoi_decomp(j)
+        end do
+     end do
+
+
+     do fc=1,num_soilc
+        c = filter_soilc(fc)
+        ! calculate the fraction of potential growth that can be
+        ! acheived with the N available to plants
         if (plant_ndemand_col(c) > 0.0_r8) then
            fpg(c) = sminn_to_plant(c) / plant_ndemand_col(c)
         else
@@ -1296,7 +1646,6 @@ contains
         end if
      end do ! end of column loops
 
-     !$acc parallel loop independent gang vector private(c) default(present)
      do fc=1,num_soilc
         c = filter_soilc(fc)
         ! calculate the fraction of potential growth that can be
@@ -1306,6 +1655,7 @@ contains
         else
            fpg_p(c) = 1.0_r8
         end if
+
         ! calculate the fraction of immobilization realized (for diagnostic purposes)
         if (potential_immob_p(c) > 0.0_r8) then
            fpi_p(c) = actual_immob_p(c) / potential_immob_p(c)
@@ -1313,34 +1663,138 @@ contains
            fpi_p(c) = 1.0_r8
         end if
      end do
-     !$acc exit data delete(nuptake_prof(:,:),puptake_prof(:,:),fpi_no3_vr(:,:),fpi_nh4_vr(:,:),sum1,sum2,&
-     !$acc  sum3, sum4, sum5, sum6)
+
+     ! for np imbalance (impacts fixation, NA with FATES)
+     if (nu_com .ne. 'RD' .and. .not.use_fates) then
+        do fc=1,num_soilc
+           c = filter_soilc(fc)
+           do p = col_pp%pfti(c), col_pp%pftf(c)
+              pnup_pfrootc(p) =  0.0_r8
+              if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
+                 do j = 1, nlevdecomp
+                    pnup_pfrootc(p) =  pnup_pfrootc(p) + &
+                         plant_nh4demand_vr_patch(p,j) / max(frootc(p) * froot_prof(p,j)&
+                         ,1e-20_r8) * fpg_nh4_vr(c,j) / max(cn_scalar_runmean(p),1e-20_r8) / max(t_scalar(c,j),1e-20_r8) &
+                         * dzsoi_decomp(j)
+                    pnup_pfrootc(p) =  pnup_pfrootc(p) + &
+                         plant_no3demand_vr_patch(p,j) / max(frootc(p) * froot_prof(p,j)&
+                         ,1e-20_r8) * fpg_no3_vr(c,j) / max(cn_scalar_runmean(p),1e-20_r8) / max(t_scalar(c,j),1e-20_r8) &
+                         * dzsoi_decomp(j)
+                 end do
+              end if
+              pnup_pfrootc(p) =  pnup_pfrootc(p) / zisoi(nlevdecomp-1)
+           end do
+        end do
+     end if
+
+
+     ! Set the FATES N and P uptake fluxes
+     
+     if(use_fates)then
+        do fc=1,num_soilc
+           c = filter_soilc(fc)
+           s = elm_fates%f2hmap(ci)%hsites(c)
+           n_pcomp = elm_fates%fates(ci)%bc_out(s)%num_plant_comps
+
+           if (nu_com .eq. 'RD') then
+
+              if( plant_ndemand_col(c)>tiny(plant_ndemand_col(c)) ) then
+                 do f = 1,n_pcomp
+                    do j = 1,nlevdecomp
+
+                       j_f =  elm_fates%fates(ci)%bc_pconst%j_uptake(j)
+
+                       elm_fates%fates(ci)%bc_in(s)%plant_nh4_uptake_flux(f,j_f) = & 
+                            elm_fates%fates(ci)%bc_in(s)%plant_nh4_uptake_flux(f,j_f) + &
+                            smin_nh4_to_plant_vr(c,j)*dt*dzsoi_decomp(j) * &
+                            (elm_fates%fates(ci)%bc_out(s)%n_demand(f)/plant_ndemand_col(c))
+
+                       elm_fates%fates(ci)%bc_in(s)%plant_no3_uptake_flux(f,j_f) = & 
+                            elm_fates%fates(ci)%bc_in(s)%plant_no3_uptake_flux(f,j_f) + &
+                            smin_no3_to_plant_vr(c,j)*dt*dzsoi_decomp(j) * &
+                            (elm_fates%fates(ci)%bc_out(s)%n_demand(f)/plant_ndemand_col(c))
+
+                    end do
+                 end do
+              end if
+            
+            if( plant_pdemand_col(c)>tiny(plant_pdemand_col(c)) ) then
+               do f = 1,n_pcomp
+                  do j = 1,nlevdecomp
+                     j_f =  elm_fates%fates(ci)%bc_pconst%j_uptake(j)
+                     elm_fates%fates(ci)%bc_in(s)%plant_p_uptake_flux(f,j_f) = & 
+                          elm_fates%fates(ci)%bc_in(s)%plant_p_uptake_flux(f,j_f) + &
+                          sminp_to_plant_vr(c,j)*dt*dzsoi_decomp(j) * &
+                          (elm_fates%fates(ci)%bc_out(s)%p_demand(f)/plant_pdemand_col(c))
+                     
+                  end do
+               end do
+            end if
+
+         else ! ECA or MIC mode
+
+            do f = 1,n_pcomp
+               do j = 1,nlevdecomp
+                  j_f =  elm_fates%fates(ci)%bc_pconst%j_uptake(j)
+                  
+                  elm_fates%fates(ci)%bc_in(s)%plant_nh4_uptake_flux(f,j_f) = & 
+                       elm_fates%fates(ci)%bc_in(s)%plant_nh4_uptake_flux(f,j_f) + & 
+                       plant_nh4demand_vr_fates(f,j) * fpg_nh4_vr(c,j)  * dzsoi_decomp(j) * dt
+                  
+                  elm_fates%fates(ci)%bc_in(s)%plant_no3_uptake_flux(f,j_f) = & 
+                       elm_fates%fates(ci)%bc_in(s)%plant_no3_uptake_flux(f,j_f) + & 
+                       plant_no3demand_vr_fates(f,j) * fpg_no3_vr(c,j) * dzsoi_decomp(j) * dt
+                  
+                  elm_fates%fates(ci)%bc_in(s)%plant_p_uptake_flux(f,j_f) = & 
+                       elm_fates%fates(ci)%bc_in(s)%plant_p_uptake_flux(f,j_f) + & 
+                       (plant_pdemand_vr_fates(f,j) * fpg_p_vr(c,j)) * dzsoi_decomp(j) * dt
+                  
+               end do
+            end do
+            
+         end if
+      end do
+
+      if (nu_com .eq. 'ECA' .or. nu_com .eq. 'MIC') then
+         deallocate(plant_nh4demand_vr_fates)
+         deallocate(plant_no3demand_vr_fates)
+         deallocate(plant_pdemand_vr_fates)
+      end if
+      
+    end if  ! if(use_fates)
+
     end associate
  end subroutine Allocation2_ResolveNPLimit
 
 !-------------------------------------------------------------------------------------------------
-  subroutine Allocation3_PlantCNPAlloc ( &
+  subroutine Allocation3_PlantCNPAlloc (bounds            , &
         num_soilc, filter_soilc, num_soilp, filter_soilp    , &
         canopystate_vars                                    , &
-        cnstate_vars, crop_vars , dt )
+        cnstate_vars, crop_vars , &
+        dt )
     ! PHASE-3 of Allocation: start new pft loop to distribute the available N/P between the
     ! competing patches on the basis of relative demand, and allocate C/N/P to new growth and storage
 
     ! !USES:
-    use elm_varctl  , only : carbon_only , carbonnitrogen_only ,carbonphosphorus_only!
-    use pftvarcon   , only : noveg
-    use pftvarcon   , only : npcropmin, grperc, grpnow
-    use elm_varpar  , only : nlevdecomp
-    use elm_varcon  , only : nitrif_n2o_loss_frac, secspday
+      !$acc routine seq
+    use elm_varctl       , only: iulog
+    use elm_varctl      , only : carbon_only          !
+    use elm_varctl      , only : carbonnitrogen_only  !
+    use elm_varctl      , only : carbonphosphorus_only!
+    use pftvarcon        , only: noveg
+    use pftvarcon        , only:  npcropmin, grperc, grpnow
+    use elm_varpar       , only:  nlevdecomp
+    use elm_varcon       , only: nitrif_n2o_loss_frac, secspday
     !
     ! !ARGUMENTS:
-    integer           , intent(in)    :: num_soilc        ! number of soil columns in filter
-    integer           , intent(in)    :: filter_soilc(:)  ! filter for soil columns
-    integer           , intent(in)    :: num_soilp        ! number of soil patches in filter
-    integer           , intent(in)    :: filter_soilp(:)  ! filter for soil patches
+    type(bounds_type)        , intent(in)    :: bounds
+    integer                  , intent(in)    :: num_soilc        ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:)  ! filter for soil columns
+    integer                  , intent(in)    :: num_soilp        ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:)  ! filter for soil patches
 
-    type(canopystate_type) , intent(in)    :: canopystate_vars
-    type(cnstate_type)     , intent(inout) :: cnstate_vars
+    type(canopystate_type)   , intent(in)    :: canopystate_vars
+    type(cnstate_type)       , intent(inout) :: cnstate_vars
 
     type(crop_type)          , intent(inout) :: crop_vars
     real(r8)                  , intent(in)   :: dt
@@ -1350,574 +1804,1625 @@ contains
     integer :: c,p,j                  !indices
     integer :: fp                     !lake filter pft index
     integer :: fc                     !lake filter column index
+    real(r8):: mr                     !maintenance respiration (gC/m2/s)
+    real(r8):: f1,f2,f3,f4,f5,g1,g2   !allocation parameters
+    real(r8):: cnl,cnfr,cnlw,cndw     !C:N ratios for leaf, fine root, and wood
+    real(r8):: fcur                   !fraction of current psn displayed as growth
+    real(r8):: gresp_storage          !temporary variable for growth resp to storage
+    real(r8):: nlc                    !temporary variable for total new leaf carbon allocation
+    real(r8) cng                      !C:N ratio for grain (= cnlw for now; slevis)
 
-    real(r8):: temp_sminn_to_plant(num_soilc)
-    real(r8):: temp_sminp_to_plant(num_soilc)
-    real(r8) :: sum1,sum2
+    !! Local P variables
+    real(r8):: rc, rc_p, r                  !Factors for nitrogen pool
+    real(r8):: cpl,cpfr,cplw,cpdw,cpg       !C:N ratios for leaf, fine root, and wood
+    real(r8):: puptake_prof(bounds%begc:bounds%endc, 1:nlevdecomp)
+    real(r8):: temp_sminn_to_plant(bounds%begc:bounds%endc)
+    real(r8):: temp_sminp_to_plant(bounds%begc:bounds%endc)
+    real(r8):: N_lim_factor(bounds%begp : bounds%endp)      ! N stress factor that impact dynamic C allocation
+    real(r8):: P_lim_factor(bounds%begp : bounds%endp)      ! P stress factor that impact dynamic C allocation
+    real(r8):: W_lim_factor(bounds%begp : bounds%endp)      ! water stress factor that impact dynamic C allocation
+    real(r8):: nlc_adjust_high  ! adjustment of C allocation to non-structural pools due to CNP imbalance
+    real(r8):: cn_stoich_var=0.2    ! variability of CN ratio
+    real(r8):: cp_stoich_var=0.4    ! variability of CP ratio
+    real(r8):: curmr, curmr_ratio   !xsmrpool temporary variables
+    real(r8):: xsmr_ratio           ! ratio of mr comes from non-structue carobn hydrate pool
     !-----------------------------------------------------------------------
 
-    associate(      &
-         fpg                          => cnstate_vars%fpg_col         , & ! Output: [real(r8) (:)   ]  fraction of potential gpp (no units)
-         fpg_p                        => cnstate_vars%fpg_p_col       , & ! Output: [real(r8) (:)   ]  fraction of potential gpp (no units)
-         smin_no3_to_plant_vr         => col_nf%smin_no3_to_plant_vr  , & ! Output: [real(r8) (:,:) ]
-         smin_nh4_to_plant_vr         => col_nf%smin_nh4_to_plant_vr  , & ! Output: [real(r8) (:,:) ]
-         smin_nh4_to_plant_patch      => veg_nf%smin_nh4_to_plant     , &
-         smin_no3_to_plant_patch      => veg_nf%smin_no3_to_plant     , &
-         sminp_to_plant_patch         => veg_pf%sminp_to_plant        , &
-         sminn_to_plant_patch         => veg_nf%sminn_to_plant        , &
-         sminn_to_npool               => veg_nf%sminn_to_npool        , & ! Output: [real(r8) (:)   ]  deployment of soil mineral N uptake (gN/m2/s)
-         sminp_to_ppool               => veg_pf%sminp_to_ppool        , & ! Output: [real(r8) (:)   ]  deployment of soil mineral N uptake (gN/m2/s)
-
-         sminn_to_plant               => col_nf%sminn_to_plant       , & ! Output: [real(r8) (:)   ]
-         sminp_to_plant               => col_pf%sminp_to_plant       , & ! Output: [real(r8) (:)   ]
-
-         sminn_to_plant_vr            => col_nf%sminn_to_plant_vr     , & ! Output: [real(r8) (:,:) ]
-         sminp_to_plant_vr            => col_pf%sminp_to_plant_vr   , & ! Output: [real(r8) (:,:) ]
-         plant_ndemand                => veg_nf%plant_ndemand       , & ! Output: [real(r8) (:)   ]  N flux required to support initial GPP (gN/m2/s)
-         plant_pdemand                => veg_pf%plant_pdemand       , & ! Output: [real(r8) (:)   ]  P flux required to support initial GPP (gP/m2/s)
-
-         plant_n_uptake_flux    => col_nf%plant_n_uptake_flux , &
-         plant_p_uptake_flux    => col_pf%plant_p_uptake_flux &
+    associate(                                                                                 &
+         ivt                          => veg_pp%itype                                           , & ! Input:  [integer  (:) ]  pft vegetation type
+         woody                        => veg_vp%woody                                    , & ! Input:  [real(r8) (:)   ]  binary flag for woody lifeform (1=woody, 0=not woody)
+         froot_leaf                   => veg_vp%froot_leaf                               , & ! Input:  [real(r8) (:)   ]  allocation parameter: new fine root C per new leaf C (gC/gC)
+         croot_stem                   => veg_vp%croot_stem                               , & ! Input:  [real(r8) (:)   ]  allocation parameter: new coarse root C per new stem C (gC/gC)
+         stem_leaf                    => veg_vp%stem_leaf                                , & ! Input:  [real(r8) (:)   ]  allocation parameter: new stem c per new leaf C (gC/gC)
+         flivewd                      => veg_vp%flivewd                                  , & ! Input:  [real(r8) (:)   ]  allocation parameter: fraction of new wood that is live (phloem and ray parenchyma) (no units)
+         leafcn                       => veg_vp%leafcn                                   , & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
+         frootcn                      => veg_vp%frootcn                                  , & ! Input:  [real(r8) (:)   ]  fine root C:N (gC/gN)
+         livewdcn                     => veg_vp%livewdcn                                 , & ! Input:  [real(r8) (:)   ]  live wood (phloem and ray parenchyma) C:N (gC/gN)
+         deadwdcn                     => veg_vp%deadwdcn                                 , & ! Input:  [real(r8) (:)   ]  dead wood (xylem and heartwood) C:N (gC/gN)
+         fcur2                        => veg_vp%fcur                                     , & ! Input:  [real(r8) (:)   ]  allocation parameter: fraction of allocation that goes to currently displayed growth, remainder to storage
+         graincn                      => veg_vp%graincn                                  , & ! Input:  [real(r8) (:)   ]  grain C:N (gC/gN)
+         croplive                     => crop_vars%croplive_patch                         , & ! Input:  [logical  (:)   ]  flag, true if planted, not harvested
+         aleaf                        => cnstate_vars%aleaf_patch                            , & ! Output: [real(r8) (:)   ]  leaf allocation coefficient
+         astem                        => cnstate_vars%astem_patch                            , & ! Output: [real(r8) (:)   ]  stem allocation coefficient
+         fpg                          => cnstate_vars%fpg_col                                , & ! Output: [real(r8) (:)   ]  fraction of potential gpp (no units)
+         !!! add phosphorus
+         leafcp                       => veg_vp%leafcp                                   , & ! Input:  [real(r8) (:)   ]  leaf C:P (gC/gP)
+         frootcp                      => veg_vp%frootcp                                  , & ! Input:  [real(r8) (:)   ]  fine root C:P (gC/gP)
+         livewdcp                     => veg_vp%livewdcp                                 , & ! Input:  [real(r8) (:)   ]  live wood (phloem and ray parenchyma) C:P (gC/gP)
+         deadwdcp                     => veg_vp%deadwdcp                                 , & ! Input:  [real(r8) (:)   ]  dead wood (xylem and heartwood) C:P (gC/gP)
+         graincp                      => veg_vp%graincp                                  , & ! Input:  [real(r8) (:)   ]  grain C:P (gC/gP)
+         fpg_p                        => cnstate_vars%fpg_p_col                              , & ! Output: [real(r8) (:)   ]  fraction of potential gpp (no units)
+         c_allometry                  => cnstate_vars%c_allometry_patch                      , & ! Output: [real(r8) (:)   ]  C allocation index (DIM)
+         n_allometry                  => cnstate_vars%n_allometry_patch                      , & ! Output: [real(r8) (:)   ]  N allocation index (DIM)
+         downreg                      => cnstate_vars%downreg_patch                          , & ! Output: [real(r8) (:)   ]  fractional reduction in GPP due to N limitation (DIM)
+         annsum_npp                   => veg_cf%annsum_npp                    , & ! Input:  [real(r8) (:)   ]  annual sum of NPP, for wood allocation
+         gpp                          => veg_cf%gpp_before_downreg            , & ! Output: [real(r8) (:)   ]  GPP flux before downregulation (gC/m2/s)
+         availc                       => veg_cf%availc                        , & ! Output: [real(r8) (:)   ]  C flux available for allocation (gC/m2/s)
+         excess_cflux                 => veg_cf%excess_cflux                  , & ! Output: [real(r8) (:)   ]  C flux not allocated due to downregulation (gC/m2/s)
+         plant_calloc                 => veg_cf%plant_calloc                  , & ! Output: [real(r8) (:)   ]  total allocated C flux (gC/m2/s)
+         psnsun_to_cpool              => veg_cf%psnsun_to_cpool               , & ! Output: [real(r8) (:)   ]
+         psnshade_to_cpool            => veg_cf%psnshade_to_cpool             , & ! Output: [real(r8) (:)   ]
+         cpool_to_leafc               => veg_cf%cpool_to_leafc                , & ! Output: [real(r8) (:)   ]
+         cpool_to_leafc_storage       => veg_cf%cpool_to_leafc_storage        , & ! Output: [real(r8) (:)   ]
+         cpool_to_frootc              => veg_cf%cpool_to_frootc               , & ! Output: [real(r8) (:)   ]
+         cpool_to_frootc_storage      => veg_cf%cpool_to_frootc_storage       , & ! Output: [real(r8) (:)   ]
+         cpool_to_livestemc           => veg_cf%cpool_to_livestemc            , & ! Output: [real(r8) (:)   ]
+         cpool_to_livestemc_storage   => veg_cf%cpool_to_livestemc_storage    , & ! Output: [real(r8) (:)   ]
+         cpool_to_deadstemc           => veg_cf%cpool_to_deadstemc            , & ! Output: [real(r8) (:)   ]
+         cpool_to_deadstemc_storage   => veg_cf%cpool_to_deadstemc_storage    , & ! Output: [real(r8) (:)   ]
+         cpool_to_livecrootc          => veg_cf%cpool_to_livecrootc           , & ! Output: [real(r8) (:)   ]
+         cpool_to_livecrootc_storage  => veg_cf%cpool_to_livecrootc_storage   , & ! Output: [real(r8) (:)   ]
+         cpool_to_deadcrootc          => veg_cf%cpool_to_deadcrootc           , & ! Output: [real(r8) (:)   ]
+         cpool_to_deadcrootc_storage  => veg_cf%cpool_to_deadcrootc_storage   , & ! Output: [real(r8) (:)   ]
+         cpool_to_gresp_storage       => veg_cf%cpool_to_gresp_storage        , & ! Output: [real(r8) (:)   ]  allocation to growth respiration storage (gC/m2/s)
+         cpool_to_grainc              => veg_cf%cpool_to_grainc               , & ! Output: [real(r8) (:)   ]  allocation to grain C (gC/m2/s)
+         cpool_to_grainc_storage      => veg_cf%cpool_to_grainc_storage       , & ! Output: [real(r8) (:)   ]  allocation to grain C storage (gC/m2/s)
+         npool                        => veg_ns%npool                        , & ! Input:  [real(r8) (:)   ]  (gN/m2) plant N pool storage
+         plant_ndemand                => veg_nf%plant_ndemand               , & ! Output: [real(r8) (:)   ]  N flux required to support initial GPP (gN/m2/s)
+         plant_nalloc                 => veg_nf%plant_nalloc                , & ! Output: [real(r8) (:)   ]  total allocated N flux (gN/m2/s)
+         npool_to_grainn              => veg_nf%npool_to_grainn             , & ! Output: [real(r8) (:)   ]  allocation to grain N (gN/m2/s)
+         npool_to_grainn_storage      => veg_nf%npool_to_grainn_storage     , & ! Output: [real(r8) (:)   ]  allocation to grain N storage (gN/m2/s)
+         retransn_to_npool            => veg_nf%retransn_to_npool           , & ! Output: [real(r8) (:)   ]  deployment of retranslocated N (gN/m2/s)
+         sminn_to_npool               => veg_nf%sminn_to_npool              , & ! Output: [real(r8) (:)   ]  deployment of soil mineral N uptake (gN/m2/s)
+         nfix_to_plantn               => veg_nf%nfix_to_plantn              , &
+         biochem_pmin_to_plant        => veg_pf%biochem_pmin_to_plant     , &
+         npool_to_leafn               => veg_nf%npool_to_leafn              , & ! Output: [real(r8) (:)   ]  allocation to leaf N (gN/m2/s)
+         npool_to_leafn_storage       => veg_nf%npool_to_leafn_storage      , & ! Output: [real(r8) (:)   ]  allocation to leaf N storage (gN/m2/s)
+         npool_to_frootn              => veg_nf%npool_to_frootn             , & ! Output: [real(r8) (:)   ]  allocation to fine root N (gN/m2/s)
+         npool_to_frootn_storage      => veg_nf%npool_to_frootn_storage     , & ! Output: [real(r8) (:)   ]  allocation to fine root N storage (gN/m2/s)
+         npool_to_livestemn           => veg_nf%npool_to_livestemn          , & ! Output: [real(r8) (:)   ]
+         npool_to_livestemn_storage   => veg_nf%npool_to_livestemn_storage  , & ! Output: [real(r8) (:)   ]
+         npool_to_deadstemn           => veg_nf%npool_to_deadstemn          , & ! Output: [real(r8) (:)   ]
+         npool_to_deadstemn_storage   => veg_nf%npool_to_deadstemn_storage  , & ! Output: [real(r8) (:)   ]
+         npool_to_livecrootn          => veg_nf%npool_to_livecrootn         , & ! Output: [real(r8) (:)   ]
+         npool_to_livecrootn_storage  => veg_nf%npool_to_livecrootn_storage , & ! Output: [real(r8) (:)   ]
+         npool_to_deadcrootn          => veg_nf%npool_to_deadcrootn         , & ! Output: [real(r8) (:)   ]
+         npool_to_deadcrootn_storage  => veg_nf%npool_to_deadcrootn_storage , & ! Output: [real(r8) (:)   ]
+         sminn_to_plant               => col_nf%sminn_to_plant                , & ! Output: [real(r8) (:)   ]
+         sminn_to_plant_vr            => col_nf%sminn_to_plant_vr             , & ! Output: [real(r8) (:,:) ]
+         !!! add phosphorus variables  - X. YANG
+         ppool                        => veg_ps%ppool                      , & ! Input: [real(r8)       ] Plant non-structural P storage (gP/m2)
+         plant_pdemand                => veg_pf%plant_pdemand               , & ! Output: [real(r8) (:)   ]  P flux required to support initial GPP (gP/m2/s)
+         plant_palloc                 => veg_pf%plant_palloc                , & ! Output: [real(r8) (:)   ]  total allocated P flux (gP/m2/s)
+         ppool_to_grainp              => veg_pf%ppool_to_grainp             , & ! Output: [real(r8) (:)   ]  allocation to grain P (gP/m2/s)
+         ppool_to_grainp_storage      => veg_pf%ppool_to_grainp_storage     , & ! Output: [real(r8) (:)   ]  allocation to grain P storage (gP/m2/s)
+         retransp_to_ppool            => veg_pf%retransp_to_ppool           , & ! Output: [real(r8) (:)   ]  deployment of retranslocated P (gP/m2/s)
+         sminp_to_ppool               => veg_pf%sminp_to_ppool              , & ! Output: [real(r8) (:)   ]  deployment of soil mineral P uptake (gP/m2/s)
+         ppool_to_leafp               => veg_pf%ppool_to_leafp              , & ! Output: [real(r8) (:)   ]  allocation to leaf P (gP/m2/s)
+         ppool_to_leafp_storage       => veg_pf%ppool_to_leafp_storage      , & ! Output: [real(r8) (:)   ]  allocation to leaf P storage (gP/m2/s)
+         ppool_to_frootp              => veg_pf%ppool_to_frootp             , & ! Output: [real(r8) (:)   ]  allocation to fine root P (gP/m2/s)
+         ppool_to_frootp_storage      => veg_pf%ppool_to_frootp_storage     , & ! Output: [real(r8) (:)   ]  allocation to fine root P storage (gP/m2/s)
+         ppool_to_livestemp           => veg_pf%ppool_to_livestemp          , & ! Output: [real(r8) (:)   ]
+         ppool_to_livestemp_storage   => veg_pf%ppool_to_livestemp_storage  , & ! Output: [real(r8) (:)   ]
+         ppool_to_deadstemp           => veg_pf%ppool_to_deadstemp          , & ! Output: [real(r8) (:)   ]
+         ppool_to_deadstemp_storage   => veg_pf%ppool_to_deadstemp_storage  , & ! Output: [real(r8) (:)   ]
+         ppool_to_livecrootp          => veg_pf%ppool_to_livecrootp         , & ! Output: [real(r8) (:)   ]
+         ppool_to_livecrootp_storage  => veg_pf%ppool_to_livecrootp_storage , & ! Output: [real(r8) (:)   ]
+         ppool_to_deadcrootp          => veg_pf%ppool_to_deadcrootp         , & ! Output: [real(r8) (:)   ]
+         ppool_to_deadcrootp_storage  => veg_pf%ppool_to_deadcrootp_storage , & ! Output: [real(r8) (:)   ]
+         sminp_to_plant               => col_pf%sminp_to_plant              , & ! Output: [real(r8) (:)   ]
+         sminp_to_plant_vr            => col_pf%sminp_to_plant_vr           , & ! Output: [real(r8) (:,:) ]
+         p_allometry                  => cnstate_vars%p_allometry_patch     , & ! Output: [real(r8) (:)   ]  P allocation index (DIM)
+
+         smin_no3_to_plant_vr         => col_nf%smin_no3_to_plant_vr            , & ! Output: [real(r8) (:,:) ]
+         smin_nh4_to_plant_vr         => col_nf%smin_nh4_to_plant_vr            , & ! Output: [real(r8) (:,:) ]
+         smin_nh4_to_plant_patch      => veg_nf%smin_nh4_to_plant             , &
+         smin_no3_to_plant_patch      => veg_nf%smin_no3_to_plant             , &
+         sminp_to_plant_patch         => veg_pf%sminp_to_plant              , &
+
+         sminn_to_plant_patch         => veg_nf%sminn_to_plant                , &
+         avail_retransn               => veg_nf%avail_retransn                , & ! Output: [real(r8) (:)   ]  N flux available from retranslocation pool (gN/m2/s)
+         avail_retransp               => veg_pf%avail_retransp              , & ! Output: [real(r8) (:)   ]  P flux available from retranslocation pool (gP/m2/s)
+         retransn                     => veg_ns%retransn                     , &
+         retransp                     => veg_ps%retransp                   , &
+
+         laisun                       => canopystate_vars%laisun_patch                         , & ! Input:  [real(r8) (:)   ]  sunlit projected leaf area index
+         laisha                       => canopystate_vars%laisha_patch                         , & ! Input:  [real(r8) (:)   ]  shaded projected leaf area index
+         leafc                        => veg_cs%leafc                          , &
+         leafn                        => veg_ns%leafn                        , &
+         leafp                        => veg_ps%leafp                      , &
+         ! for debug
+         plant_n_uptake_flux          => col_nf%plant_n_uptake_flux                 , &
+         plant_p_uptake_flux          => col_pf%plant_p_uptake_flux               , &
+         leafc_storage                => veg_cs%leafc_storage                  , &
+         leafc_xfer                   => veg_cs%leafc_xfer                     , &
+         leafn_storage                => veg_ns%leafn_storage                , &
+         leafn_xfer                   => veg_ns%leafn_xfer                   , &
+         leafp_storage                => veg_ps%leafp_storage              , &
+         leafp_xfer                   => veg_ps%leafp_xfer                 , &
+         annsum_potential_gpp         => cnstate_vars%annsum_potential_gpp_patch               , &
+         annmax_retransn              => cnstate_vars%annmax_retransn_patch                    , &
+         grain_flag                   => cnstate_vars%grain_flag_patch                         , &
+         cn_scalar_runmean            => cnstate_vars%cn_scalar_runmean                        , &
+         cp_scalar_runmean            => cnstate_vars%cp_scalar_runmean                        , &
+         annmax_retransp              => cnstate_vars%annmax_retransp_patch                    , &
+         cpool_to_xsmrpool            => veg_cf%cpool_to_xsmrpool               , &
+         w_scalar                     => col_cf%w_scalar                          , &
+         froot_prof                   => cnstate_vars%froot_prof_patch                         , &
+         leaf_mr                      => veg_cf%leaf_mr                         , &
+         froot_mr                     => veg_cf%froot_mr                        , &
+         livestem_mr                  => veg_cf%livestem_mr                     , &
+         livecroot_mr                 => veg_cf%livecroot_mr                    , &
+         grain_mr                     => veg_cf%grain_mr                        , &
+         xsmrpool                     => veg_cs%xsmrpool                       , &
+         xsmrpool_recover             => veg_cf%xsmrpool_recover                , &
+         leaf_curmr                   => veg_cf%leaf_curmr                      , &
+         froot_curmr                  => veg_cf%froot_curmr                     , &
+         livestem_curmr               => veg_cf%livestem_curmr                  , &
+         livecroot_curmr              => veg_cf%livecroot_curmr                 , &
+         grain_curmr                  => veg_cf%grain_curmr                     , &
+         leaf_xsmr                    => veg_cf%leaf_xsmr                       , &
+         froot_xsmr                   => veg_cf%froot_xsmr                      , &
+         livestem_xsmr                => veg_cf%livestem_xsmr                   , &
+         livecroot_xsmr               => veg_cf%livecroot_xsmr                  , &
+         grain_xsmr                   => veg_cf%grain_xsmr                      , &
+         allocation_leaf              => veg_cf%allocation_leaf                 , &
+         allocation_stem              => veg_cf%allocation_stem                 , &
+         allocation_froot             => veg_cf%allocation_froot                , &
+         xsmrpool_turnover            => veg_cf%xsmrpool_turnover               , &
+         nsc_rtime                    => veg_vp%nsc_rtime                       , &
+         supplement_to_plantn         => veg_nf%supplement_to_plantn            , &
+         supplement_to_plantp         => veg_pf%supplement_to_plantp          &
          )
 
       !-------------------------------------------------------------------
       ! set time steps
-      !$acc enter data create(sum1,sum2) 
-      !if (nu_com .eq. 'RD') then
-      !$acc parallel loop  independent gang worker private(c,sum1,sum2) default(present)
+
+      ! debug
       do fc=1,num_soilc
-         sum1=0.0_r8;sum2=0.0_r8;
          c = filter_soilc(fc)
-         !$acc loop vector reduction(+:sum1,sum2)
-         do p = col_pp%pfti(c), col_pp%pftf(c)
-            if (veg_pp%active(p) .and. (veg_pp%itype(p) .ne. noveg)) then
-               sum1 = sum1 + plant_ndemand(p) * fpg(c)*veg_pp%wtcol(p)
-                sum2= sum2 + plant_pdemand(p) * fpg_p(c)*veg_pp%wtcol(p)
-            end if
-
-         end do
-         plant_n_uptake_flux(c) = sum1
-         plant_p_uptake_flux(c) = sum2
+         plant_n_uptake_flux(c) = 0.0_r8
+         plant_p_uptake_flux(c) = 0.0_r8
       end do
 
+      if (nu_com .eq. 'RD') then
+         do fc=1,num_soilc
+            c = filter_soilc(fc)
+            do p = col_pp%pfti(c), col_pp%pftf(c)
+               if (veg_pp%active(p) .and. (veg_pp%itype(p) .ne. noveg)) then
+                  plant_n_uptake_flux(c) = plant_n_uptake_flux(c) + plant_ndemand(p) * fpg(c)*veg_pp%wtcol(p)
+                  plant_p_uptake_flux(c) = plant_p_uptake_flux(c) + plant_pdemand(p) * fpg_p(c)*veg_pp%wtcol(p)
+               end if
+            end do
+         end do
+      else ! ECA or MIC mode
+         do fc=1,num_soilc
+            c = filter_soilc(fc)
+            do p = col_pp%pfti(c), col_pp%pftf(c)
+               if (veg_pp%active(p) .and. (veg_pp%itype(p) .ne. noveg)) then
+                  plant_n_uptake_flux(c) = plant_n_uptake_flux(c) + (smin_nh4_to_plant_patch(p)+smin_no3_to_plant_patch(p))&
+                       *veg_pp%wtcol(p)
+                  plant_p_uptake_flux(c) = plant_p_uptake_flux(c) + sminp_to_plant_patch(p)*veg_pp%wtcol(p)
+               end if
+            end do
+         end do
+      end if
 
       ! start new pft loop to distribute the available N between the
       ! competing patches on the basis of relative demand, and allocate C and N to
       ! new growth and storage
 
-      call DistributeN_RD(num_soilp,filter_soilp,cnstate_vars,crop_vars)
+      do fp=1,num_soilp
+         p = filter_soilp(fp)
+         c = veg_pp%column(p)
+
+         if ( nu_com .eq. 'RD') then
+             ! set some local allocation variables
+             f1 = froot_leaf(ivt(p))
+             f2 = croot_stem(ivt(p))
+
+             ! modified wood allocation to be 2.2 at npp=800 gC/m2/yr, 0.2 at npp=0,
+             ! constrained so that it does not go lower than 0.2 (under negative annsum_npp)
+             ! There was an error in this formula in previous version, where the coefficient
+             ! was 0.004 instead of 0.0025.
+             ! This variable allocation is only for trees. Shrubs have a constant
+             ! allocation as specified in the pft-physiology file.  The value is also used
+             ! as a trigger here: -1.0 means to use the dynamic allocation (trees).
+
+             if (stem_leaf(ivt(p)) < 0._r8) then
+                 if (stem_leaf(ivt(p)) == -1._r8) then
+                     f3 = (2.7/(1.0+exp(-0.004*(annsum_npp(p) - 300.0)))) - 0.4
+                 else
+                     f3 = max((-1.0_r8*stem_leaf(ivt(p))*2.7_r8)/(1.0_r8+exp(-0.004_r8*(annsum_npp(p) - &
+                               300.0_r8))) - 0.4_r8, 0.2_r8)
+                 end if
+             else
+                 f3 = stem_leaf(ivt(p))
+             end if
+
+             f4 = flivewd(ivt(p))
+             g1 = grperc(ivt(p))
+             g2 = grpnow(ivt(p))
+             cnl = leafcn(ivt(p))
+             cnfr = frootcn(ivt(p))
+             cnlw = livewdcn(ivt(p))
+             cndw = deadwdcn(ivt(p))
+
+             cpl = leafcp(ivt(p))
+             cpfr = frootcp(ivt(p))
+             cplw = livewdcp(ivt(p))
+             cpdw = deadwdcp(ivt(p))
+
+             fcur = fcur2(ivt(p))
+
+             if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+                 if (croplive(p)) then
+                     f1 = aroot(p) / aleaf(p)
+                     f3 = astem(p) / aleaf(p)
+                     f5 = arepr(p) / aleaf(p)
+                     g1 = 0.25_r8
+                 else
+                     f1 = 0._r8
+                     f3 = 0._r8
+                     f5 = 0._r8
+                     g1 = 0.25_r8
+                 end if
+             end if
+
+             ! increase fcur linearly with ndays_active, until fcur reaches 1.0 at
+             ! ndays_active = days/year.  This prevents the continued storage of C and N.
+             ! turning off this correction (PET, 12/11/03), instead using bgtr in
+             ! phenology algorithm.
+
+
+             if (veg_vp%nstor(veg_pp%itype(p)) > 1e-6_r8) then
+               !N pool modification
+               sminn_to_npool(p) = plant_ndemand(p) * min(fpg(c), fpg_p(c))
+               sminp_to_ppool(p) = plant_pdemand(p) * min(fpg(c), fpg_p(c))
+
+               rc   = veg_vp%nstor(veg_pp%itype(p)) * max(annsum_npp(p) * n_allometry(p) / c_allometry(p), 0.01_r8)
+               rc_p = veg_vp%nstor(veg_pp%itype(p)) * max(annsum_npp(p) * p_allometry(p) / c_allometry(p), 0.01_r8)
+
+               if (.not. carbon_only  .and. .not.  carbonphosphorus_only  &
+                     .and. .not.  carbonnitrogen_only  ) then
+                   !sminn_to_npool(p) = plant_ndemand(p) * fpg(c)   / max((npool(p) / rc), 1.0_r8)  !limit uptake when pool is large
+                   !sminp_to_ppool(p) = plant_pdemand(p) * fpg_p(c) / max((ppool(p) / rc_p), 1.0_r8)  !limit uptake when pool is large
+               end if
+               if ( carbon_only  .or.  carbonphosphorus_only ) then
+                 r = 1.0_r8
+               else
+                 r  = max(1._r8,rc/max(npool(p), 1e-15_r8))
+               end if
+               plant_nalloc(p) = (plant_ndemand(p) + retransn_to_npool(p)) / r
+
+               if ( carbon_only  .or.  carbonnitrogen_only ) then
+                 r = 1.0_r8
+               else
+                 r  = max(1._r8,rc_p/max(ppool(p), 1e-15_r8))
+               end if
+               plant_palloc(p) = (plant_pdemand(p) + retransp_to_ppool(p)) / r
+
+             else
+               sminn_to_npool(p) = plant_ndemand(p) * fpg(c)
+               sminp_to_ppool(p) = plant_pdemand(p) * fpg_p(c)
+
+               plant_nalloc(p) = sminn_to_npool(p) + retransn_to_npool(p)
+               plant_palloc(p) = sminp_to_ppool(p) + retransp_to_ppool(p)
+             end if
+
+             ! calculate the associated carbon allocation, and the excess
+             ! carbon flux that must be accounted for through downregulation
+
+             if( .not.carbonphosphorus_only .and. .not.carbonnitrogen_only &
+                  .and. .not.carbon_only )then
+                 if( plant_nalloc(p) * (c_allometry(p)/n_allometry(p)) < &
+                     plant_palloc(p) * (c_allometry(p)/p_allometry(p)) )then
+
+                     plant_calloc(p) = plant_nalloc(p) * (c_allometry(p)/n_allometry(p))
+                     plant_palloc(p) = plant_nalloc(p) * (p_allometry(p)/n_allometry(p))
+                     !in case of strong N limitation, and plant_palloc(p) < retransp_to_ppool(p)
+                     if (veg_vp%nstor(veg_pp%itype(p)) < 1e-6_r8) then
+                         sminp_to_ppool(p) = max(plant_palloc(p) - retransp_to_ppool(p),0.0_r8)
+                         retransp_to_ppool(p) = min(plant_palloc(p), retransp_to_ppool(p))
+                     end if
+                 else
+                     plant_calloc(p) = plant_palloc(p) * (c_allometry(p)/p_allometry(p))
+                     plant_nalloc(p) = plant_palloc(p) * (n_allometry(p)/p_allometry(p))
+                     ! in case of strong P limitation, and plant_nalloc(p) < retransn_to_npool(p)
+                     if (veg_vp%nstor(veg_pp%itype(p)) < 1e-6_r8) then
+                         sminn_to_npool(p) = max(plant_nalloc(p) - retransn_to_npool(p), 0.0_r8)
+                         retransn_to_npool(p) = min(plant_nalloc(p) , retransn_to_npool(p))
+                     end if
+                 endif
+             endif
+
+             if(carbonphosphorus_only .or. carbon_only )then
+                 plant_calloc(p) = plant_palloc(p) * (c_allometry(p)/p_allometry(p))
+             endif
+
+             if(carbonnitrogen_only .or. carbon_only )then
+                 plant_calloc(p) = plant_nalloc(p) * (c_allometry(p)/n_allometry(p))
+                 plant_palloc(p) = plant_calloc(p) * (p_allometry(p)/c_allometry(p))
+                 if (veg_vp%nstor(veg_pp%itype(p)) < 1e-6_r8) then
+                     sminp_to_ppool(p) = max(plant_palloc(p) - retransp_to_ppool(p), 0.0_r8)
+                 end if
+             endif
+
+             excess_cflux(p) = availc(p) - plant_calloc(p)
+
+             ! reduce gpp fluxes due to N limitation
+             if (gpp(p) > 0.0_r8) then
+                 downreg(p) = excess_cflux(p)/gpp(p)
+
+                 if (veg_vp%br_xr(veg_pp%itype(p)) > 1e-9_r8) then
+                     !Excess carbon goes to temporary NSC pool instead of
+                     !instantaneous downregulation
+                     psnsun_to_cpool(p) = psnsun_to_cpool(p)
+                     psnshade_to_cpool(p) = psnshade_to_cpool(p)
+                     if ( use_c13 ) then
+                         c13_veg_cf%psnsun_to_cpool(p) = c13_veg_cf%psnsun_to_cpool(p)
+                         c13_veg_cf%psnshade_to_cpool(p) = c13_veg_cf%psnshade_to_cpool(p)
+                     endif
+
+                     if ( use_c14 ) then
+                         c14_veg_cf%psnsun_to_cpool(p) = c14_veg_cf%psnsun_to_cpool(p)
+                         c14_veg_cf%psnshade_to_cpool(p) = c14_veg_cf%psnshade_to_cpool(p)
+                     endif
+
+                 else
+                     psnsun_to_cpool(p)   = psnsun_to_cpool(p)  *(1._r8 - downreg(p))
+                     psnshade_to_cpool(p) = psnshade_to_cpool(p)*(1._r8 - downreg(p))
+                     if ( use_c13 ) then
+                         c13_veg_cf%psnsun_to_cpool(p)   = c13_veg_cf%psnsun_to_cpool(p)  *(1._r8 - downreg(p))
+                         c13_veg_cf%psnshade_to_cpool(p) = c13_veg_cf%psnshade_to_cpool(p)*(1._r8 - downreg(p))
+                     endif
+
+                     if ( use_c14 ) then
+                         c14_veg_cf%psnsun_to_cpool(p)   = c14_veg_cf%psnsun_to_cpool(p)  *(1._r8 - downreg(p))
+                         c14_veg_cf%psnshade_to_cpool(p) = c14_veg_cf%psnshade_to_cpool(p)*(1._r8 - downreg(p))
+                     endif
+                 endif
+             end if
+         else
+             ! 'ECA' or 'MIC' mode
+             ! dynamic allocation based on light limitation (more woody growth) vs nutrient limitations (more fine root growth)
+             ! set allocation coefficients
+             N_lim_factor(p) = cn_scalar_runmean(p) ! N stress factor
+             P_lim_factor(p) = cp_scalar_runmean(p) ! P stress factor
+
+             if (carbon_only) then
+                 N_lim_factor(p) = 0.0_r8
+                 P_lim_factor(p) = 0.0_r8
+             else if (carbonnitrogen_only) then
+                 P_lim_factor(p) = 0.0_r8
+             else if ( carbonphosphorus_only ) then
+                 N_lim_factor(p) = 0.0_r8
+             end if
+             W_lim_factor(p) = 0.0_r8
+             do j = 1 , nlevdecomp
+                 W_lim_factor(p) = W_lim_factor(p) + w_scalar(c,j) * froot_prof(p,j)
+             end do
+             ! N_lim_factor/P_lim_factor ones: highly limited
+             ! N_lim_factor/P_lim_factor zeros: not limited
+             ! convert to 1- X, see explanation in dynamic_plant_alloc
+             call dynamic_plant_alloc(min(1.0_r8-N_lim_factor(p),1.0_r8-P_lim_factor(p)),W_lim_factor(p), &
+                  laisun(p)+laisha(p), allocation_leaf(p), allocation_stem(p), allocation_froot(p), woody(ivt(p)))
+
+             f1 = allocation_froot(p) / allocation_leaf(p)
+             f2 = croot_stem(ivt(p))
+             f3 = allocation_stem(p) / allocation_leaf(p)
+
+             ! modified wood allocation to be 2.2 at npp=800 gC/m2/yr, 0.2 at npp=0,
+             ! constrained so that it does not go lower than 0.2 (under negative annsum_npp)
+             ! There was an error in this formula in previous version, where the coefficient
+             ! was 0.004 instead of 0.0025.
+             ! This variable allocation is only for trees. Shrubs have a constant
+             ! allocation as specified in the pft-physiology file.  The value is also used
+             ! as a trigger here: -1.0 means to use the dynamic allocation (trees).
+             !if (stem_leaf(ivt(p)) == -1._r8) then
+             !    f3 = (2.7/(1.0+exp(-0.004*(annsum_npp(p) - 300.0)))) - 0.4
+             !else
+             !    f3 = stem_leaf(ivt(p))
+             !end if
+
+             f4 = flivewd(ivt(p))
+             g1 = grperc(ivt(p))
+             g2 = grpnow(ivt(p))
+
+             cnl = leafcn(ivt(p))
+             cnfr = frootcn(ivt(p))
+             cnlw = livewdcn(ivt(p))
+             cndw = deadwdcn(ivt(p))
+
+             cpl =  leafcp(ivt(p))
+             cpfr = frootcp(ivt(p))
+             cplw = livewdcp(ivt(p))
+             cpdw = deadwdcp(ivt(p))
+
+             fcur = fcur2(ivt(p))
+
+             if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+                 if (croplive(p)) then
+                     f1 = aroot(p) / aleaf(p)
+                     f3 = astem(p) / aleaf(p)
+                     f5 = arepr(p) / aleaf(p)
+                     g1 = 0.25_r8
+                 else
+                     f1 = 0._r8
+                     f3 = 0._r8
+                     f5 = 0._r8
+                     g1 = 0.25_r8
+                 end if
+             end if
+
+             sminn_to_npool(p) = sminn_to_plant_patch(p)
+             sminp_to_ppool(p) = sminp_to_plant_patch(p)
+
+             if (ivt(p) >= npcropmin .and. grain_flag(p) == 1._r8) then
+                avail_retransn(p) = retransn(p)/dt
+                avail_retransp(p) = retransp(p)/dt
+             else if (ivt(p) < npcropmin .and. annsum_potential_gpp(p) > 0._r8) then
+                avail_retransn(p) = (annmax_retransn(p)/2._r8)*(gpp(p)/annsum_potential_gpp(p))/dt
+                avail_retransp(p) = (annmax_retransp(p)/2._r8)*(gpp(p)/annsum_potential_gpp(p))/dt
+             else
+                avail_retransn(p) = 0.0_r8
+                avail_retransp(p) = 0.0_r8
+             end if
+
+             ! make sure available retrans N doesn't exceed storage
+             avail_retransn(p) =max( min(avail_retransn(p),retransn(p)/dt),0.0_r8)
+             avail_retransp(p) =max( min(avail_retransp(p),retransp(p)/dt),0.0_r8)
+
+             retransn_to_npool(p) = avail_retransn(p)
+             retransp_to_ppool(p) = avail_retransp(p)
+
+             if (NFIX_PTASE_plant) then
+                plant_nalloc(p) = sminn_to_npool(p) + retransn_to_npool(p) + nfix_to_plantn(p)
+                plant_palloc(p) = sminp_to_ppool(p) + retransp_to_ppool(p) + biochem_pmin_to_plant(p)
+             else
+                plant_nalloc(p) = sminn_to_npool(p) + retransn_to_npool(p)
+                plant_palloc(p) = sminp_to_ppool(p) + retransp_to_ppool(p)
+             endif
+
+             mr = leaf_mr(p) + froot_mr(p)
+             if (woody(ivt(p)) == 1.0_r8) then
+                mr = mr + livestem_mr(p) + livecroot_mr(p)
+             else if (ivt(p) >= npcropmin) then
+                if (croplive(p)) mr = mr + livestem_mr(p) + grain_mr(p)
+             end if
+
+             ! take mr from xsmrpool pool first
+             if (xsmrpool(p) > 0._r8) then
+                if (mr > 0._r8 .and. (xsmrpool(p)/dt + gpp(p)) <= mr) then
+                   curmr = gpp(p)
+                   curmr_ratio = curmr / mr
+                   xsmr_ratio = xsmrpool(p)/dt/mr ! not enough non-structure carbon hydrate, limit mr
+                   availc(p) = 0.0
+                else if (mr > 0._r8 .and. (xsmrpool(p)/dt + gpp(p)) > mr .and. xsmrpool(p)/dt <= mr ) then
+                   curmr = mr - xsmrpool(p)/dt
+                   curmr_ratio = curmr / mr
+                   xsmr_ratio = xsmrpool(p)/dt/mr
+                   availc(p) = gpp(p) - (mr - xsmrpool(p)/dt)
+                else if (mr > 0._r8 .and. (xsmrpool(p)/dt + gpp(p)) > mr .and. xsmrpool(p)/dt > mr ) then
+                   curmr = 0.0
+                   curmr_ratio = curmr / mr
+                   xsmr_ratio = 1 - curmr_ratio
+                   availc(p) = gpp(p)
+                else
+                   curmr_ratio = 0._r8
+                   xsmr_ratio = 0._r8
+                end if
+             else
+                if (mr > 0._r8 .and.  gpp(p) <= mr) then
+                   curmr = gpp(p)
+                   curmr_ratio = curmr / mr
+                   xsmr_ratio = 0 ! not enough non-structure carbon hydrate, limit mr
+                   availc(p) = 0.0
+                else if (mr > 0._r8 .and. gpp(p) > mr ) then
+                   curmr = mr
+                   curmr_ratio = curmr / mr
+                   xsmr_ratio = 0
+                   availc(p) = gpp(p) - mr
+                else
+                   curmr_ratio = 0._r8
+                   xsmr_ratio = 0._r8
+                end if
+             end if
+
+             ! carbon flux available for allocation
+             leaf_curmr(p) = leaf_mr(p) * curmr_ratio
+             leaf_xsmr(p) = leaf_mr(p) * xsmr_ratio
+             leaf_mr(p) =  leaf_curmr(p) + leaf_xsmr(p)
+             froot_curmr(p) = froot_mr(p) * curmr_ratio
+             froot_xsmr(p) = froot_mr(p) * xsmr_ratio
+             froot_mr(p) =  froot_curmr(p) + froot_xsmr(p)
+             livestem_curmr(p) = livestem_mr(p) * curmr_ratio
+             livestem_xsmr(p) = livestem_mr(p) * xsmr_ratio
+             livestem_mr(p) =  livestem_curmr(p) + livestem_xsmr(p)
+             livecroot_curmr(p) = livecroot_mr(p) * curmr_ratio
+             livecroot_xsmr(p) = livecroot_mr(p) * xsmr_ratio
+             livecroot_mr(p) =  livecroot_curmr(p) + livecroot_xsmr(p)
+             grain_curmr(p) = grain_mr(p) * curmr_ratio
+             grain_xsmr(p) = grain_mr(p) * xsmr_ratio
+             grain_mr(p) =  grain_curmr(p) + grain_xsmr(p)
+
+             ! no allocation when available c is negative
+             availc(p) = max(availc(p),0.0_r8)
+
+             ! test for an xsmrpool deficit
+             if (xsmrpool(p) < 0.0_r8) then
+                ! Running a deficit in the xsmrpool, so the first priority is to let
+                ! some availc from this timestep accumulate in xsmrpool.
+                ! Determine rate of recovery for xsmrpool deficit
+
+                xsmrpool_recover(p) = -xsmrpool(p)/(dayscrecover*secspday)
+                if (xsmrpool_recover(p) < availc(p)) then
+                   ! available carbon reduced by amount for xsmrpool recovery
+                   availc(p) = availc(p) - xsmrpool_recover(p)
+                else
+                   ! all of the available carbon goes to xsmrpool recovery
+                   xsmrpool_recover(p) = availc(p)
+                   availc(p) = 0.0_r8
+                end if
+                cpool_to_xsmrpool(p) = xsmrpool_recover(p)
+
+                ! storage pool turnover
+                xsmrpool_turnover(p) = 0.0_r8
+             else
+
+                cpool_to_xsmrpool(p) = 0.0_r8
+
+                ! storage pool turnover
+                xsmrpool_turnover(p) = max(xsmrpool(p) - mr*xsmr_ratio*dt , 0.0_r8) / (nsc_rtime(ivt(p))*365.0_r8*secspday)
+             end if
+
+             plant_calloc(p) = availc(p)
+
+             ! here no down-regulation on allocatable C here, NP limitation is implemented in leaf-level NP control on GPP
+             if (woody(ivt(p)) == 1.0_r8) then
+                 c_allometry(p) = (1._r8+g1)*(1._r8+f1+f3*(1._r8+f2))
+                 n_allometry(p) = 1._r8/cnl + f1/cnfr + (f3*f4*(1._r8+f2))/cnlw + &
+                     (f3*(1._r8-f4)*(1._r8+f2))/cndw
+                 p_allometry(p) = 1._r8/cpl + f1/cpfr + (f3*f4*(1._r8+f2))/cplw + &
+                     (f3*(1._r8-f4)*(1._r8+f2))/cpdw
+
+             else if (ivt(p) >= npcropmin) then ! skip generic crops
+                 cng = graincn(ivt(p))
+                 cpg = graincp(ivt(p))
+                 c_allometry(p) = (1._r8+g1)*(1._r8+f1+f5+f3*(1._r8+f2))
+                 n_allometry(p) = 1._r8/cnl + f1/cnfr + f5/cng + (f3*f4*(1._r8+f2))/cnlw + &
+                     (f3*(1._r8-f4)*(1._r8+f2))/cndw
+                 p_allometry(p) = 1._r8/cpl + f1/cpfr + f5/cpg + (f3*f4*(1._r8+f2))/cplw + &
+                     (f3*(1._r8-f4)*(1._r8+f2))/cpdw
+
+             else
+                 c_allometry(p) = 1._r8+g1+f1+f1*g1
+                 n_allometry(p) = 1._r8/cnl + f1/cnfr
+                 p_allometry(p) = 1._r8/cpl + f1/cpfr
+             end if
+         end if
+
+         ! calculate the amount of new leaf C dictated by these allocation
+         ! decisions, and calculate the daily fluxes of C and N to current
+         ! growth and storage pools
+
+         ! fcur is the proportion of this day's growth that is displayed now,
+         ! the remainder going into storage for display next year through the
+         ! transfer pools
+
+         ! recover default coefficient for carbon allocation to leaf,  which is possibly changed due to previous time step allocation adjustment
+         nlc = plant_calloc(p) / c_allometry(p)
+         ! recover allocation fraction,  which is possibly changed due to previous time step allocation adjustment
+         !fcur = fcur2(ivt(p))
+         if (nu_com .ne. 'RD') then
+            ! under ECA or MIC mode, CNP stoichiometry is flexible
+            ! If nutrient is limited, plant will accumulate non-structural carbon hydrate (sink strength limitation)
+            ! e.g., in the model if allocatable C is too much, allocate excess C to storage pool, later could be respired
+            ! Here, adjust the fraction allocate to structure vs storage pool so that:
+            ! CN only mode adjust C allocation to maintain CN ratio within natural variability
+            ! CP only mode adjust C allocation to maintain CP ratio within natural variability
+            ! CNP mode adjust C allocation to maintain CN and CP ratio within natural variability
+
+            if (carbon_only ) then ! C only mode
+               ! nothing to adjust
+               nlc_adjust_high = nlc
+            else if ( carbonnitrogen_only) then ! CN only mode
+
+               ! maximum amount of C allocated to leaf pool that could be supported by plant N allocated to leaf pool:
+               ! plant_nalloc(p) / (n_allometry(p) )/ cnl * (cnl*(1 + cn_stoich_var ) )
+               ! maximum amount of C allocated to leaf pool that could be supported by plant P allocated to leaf pool:
+               ! plant_palloc(p) / (p_allometry(p) )/ cpl * (cpl* (1 + cp_stoich_var ) )
+               ! actual amount of C allocated to leaf pool if no adjustment occur
+               ! plant_calloc/c_allometry * x* (x*=1)
+               ! adjust fcur* to reduce the C allocated to leaf pool
+               ! x* = plant_nalloc(p) / n_allometry(p) * (1 + cn_stoich_var )  /  (plant_calloc/c_allometry)
+               ! x* = plant_palloc(p) / p_allometry(p) * (1 + cp_stoich_var )  /  (plant_calloc/c_allometry)
+
+
+               nlc_adjust_high = plant_nalloc(p) / n_allometry(p) * (1 + cn_stoich_var )  ! upper bound of allocatable C to leaf  to satisfy N allocation
+               nlc_adjust_high = nlc_adjust_high + max((leafn(p)+leafn_storage(p) + leafn_xfer(p))* cnl *  (1 + cn_stoich_var ) - &
+                  (leafc(p)+leafc_storage(p) + leafc_xfer(p)),0.0_r8)/dt ! upper bound of allocatable C to leaf account for offsetting current leaf N deficit
+            else if ( carbonphosphorus_only) then ! CP only mode
+               nlc_adjust_high = plant_palloc(p) / p_allometry(p) * (1 + cp_stoich_var )  ! upper bound of allocatable C to leaf  to satisfy P allocation
+               nlc_adjust_high = nlc_adjust_high + max((leafp(p)+leafp_storage(p) + leafp_xfer(p))* cpl *  (1 + cp_stoich_var ) - &
+                  (leafc(p)+leafc_storage(p) + leafc_xfer(p)),0.0_r8)/dt ! upper bound of allocatable C to leaf account for offsetting current leaf N deficit
+            else !  CNP mode
+               nlc_adjust_high = min(plant_nalloc(p) / n_allometry(p) * (1 + cn_stoich_var ) + max((leafn(p)+leafn_storage(p) &
+                    + leafn_xfer(p))* cnl *  (1 + cn_stoich_var ) - &
+                  (leafc(p)+leafc_storage(p) + leafc_xfer(p)),0.0_r8)/dt, &
+                  plant_palloc(p) / p_allometry(p) * (1 + cp_stoich_var ) + max((leafp(p)+leafp_storage(p) + leafp_xfer(p))* cpl * &
+                  (1 + cp_stoich_var ) - &
+                  (leafc(p)+leafc_storage(p) + leafc_xfer(p)),0.0_r8)/dt)
+            end if
+
+            ! calculate excess carbon
+            ! put excess carbon into respiration storage pool (if nlc > nlc_adjust_high)
+            nlc = max(nlc  - nlc_adjust_high,0.0_r8)
+            cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * fcur * (1 + g1)
+            cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * (1._r8 - fcur) * (1 + g1)
+            cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f1 * fcur * (1 + g1)
+            cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f1 * (1._r8 - fcur) * (1 + g1)
+            if (woody(ivt(p)) == 1._r8) then
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f3 * f4 * fcur * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f3 * f4 * (1._r8 - fcur) * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f3 * (1._r8 - f4) * fcur * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f3 * (1._r8 - f4) * (1._r8 - fcur) * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f2 * f3 * f4 * fcur * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f2 * f3 * f4 * (1._r8 - fcur) * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f2 * f3 * (1._r8 - f4) * fcur * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f2 * f3 * (1._r8 - f4) * (1._r8 - fcur) * (1 + g1)
+            end if
+            if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f3 * f4 * fcur * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f3 * f4 * (1._r8 - fcur) * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f3 * (1._r8 - f4) * fcur * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f3 * (1._r8 - f4) * (1._r8 - fcur) * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f2 * f3 * f4 * fcur * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f2 * f3 * f4 * (1._r8 - fcur) * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f2 * f3 * (1._r8 - f4) * fcur * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f2 * f3 * (1._r8 - f4) * (1._r8 - fcur) * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f5 * fcur * (1 + g1)
+               cpool_to_xsmrpool(p)  = cpool_to_xsmrpool(p) + nlc * f5 * (1._r8 -fcur) * (1 + g1)
+            end if
+
+            ! updated allocation if necessary
+            nlc = min(nlc_adjust_high ,plant_calloc(p) / c_allometry(p) )
+         end if
+
+         cpool_to_leafc(p)          = nlc * fcur
+         cpool_to_leafc_storage(p)  = nlc * (1._r8 - fcur)
+         cpool_to_frootc(p)         = nlc * f1 * fcur
+         cpool_to_frootc_storage(p) = nlc * f1 * (1._r8 - fcur)
+         if (woody(ivt(p)) == 1._r8) then
+            cpool_to_livestemc(p)          = nlc * f3 * f4 * fcur
+            cpool_to_livestemc_storage(p)  = nlc * f3 * f4 * (1._r8 - fcur)
+            cpool_to_deadstemc(p)          = nlc * f3 * (1._r8 - f4) * fcur
+            cpool_to_deadstemc_storage(p)  = nlc * f3 * (1._r8 - f4) * (1._r8 - fcur)
+            cpool_to_livecrootc(p)         = nlc * f2 * f3 * f4 * fcur
+            cpool_to_livecrootc_storage(p) = nlc * f2 * f3 * f4 * (1._r8 - fcur)
+            cpool_to_deadcrootc(p)         = nlc * f2 * f3 * (1._r8 - f4) * fcur
+            cpool_to_deadcrootc_storage(p) = nlc * f2 * f3 * (1._r8 - f4) * (1._r8 - fcur)
+         end if
+         if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+            cpool_to_livestemc(p)          = nlc * f3 * f4 * fcur
+            cpool_to_livestemc_storage(p)  = nlc * f3 * f4 * (1._r8 - fcur)
+            cpool_to_deadstemc(p)          = nlc * f3 * (1._r8 - f4) * fcur
+            cpool_to_deadstemc_storage(p)  = nlc * f3 * (1._r8 - f4) * (1._r8 - fcur)
+            cpool_to_livecrootc(p)         = nlc * f2 * f3 * f4 * fcur
+            cpool_to_livecrootc_storage(p) = nlc * f2 * f3 * f4 * (1._r8 - fcur)
+            cpool_to_deadcrootc(p)         = nlc * f2 * f3 * (1._r8 - f4) * fcur
+            cpool_to_deadcrootc_storage(p) = nlc * f2 * f3 * (1._r8 - f4) * (1._r8 - fcur)
+            cpool_to_grainc(p)             = nlc * f5 * fcur
+            cpool_to_grainc_storage(p)     = nlc * f5 * (1._r8 -fcur)
+         end if
+
+         ! corresponding N fluxes
+         ! recover default coefficient for carbon allocation to leaf,  which is possibly changed due to previous time step allocation adjustment
+         !nlc = plant_calloc(p) / c_allometry(p)
+         ! recover allocation fraction,  which is possibly changed due to previous time step allocation adjustment
+         !fcur = fcur2(ivt(p))
+         if (nu_com .ne. 'RD') then
+            if ( carbon_only) then ! C only mode
+               ! nothing to adjust
+            else ! CN/ CP/ CNP mode
+            !   ! minimum amount of C allocated to structural leaf pool that could be supported by plant N allocated to structural leaf pool:
+            !   ! plant_nalloc(p) / (n_allometry(p) )/ cnl * (cnl*(1 - cn_stoich_var ) )*x* (x*=1)
+            !   ! minimum amount of C allocated to structural leaf pool that could be supported by plant P allocated to structural leaf pool:
+            !   ! plant_palloc(p) / (p_allometry(p) )/ cpl * (cpl* (1 - cp_stoich_var ) )*x* (x*=1)
+            !   ! actual amount of C allocated to structural leaf pool if no adjustment occur
+            !   ! plant_calloc/c_allometry
+            !   ! adjust fcur* to reduce the NP allocated to structural leaf pool
+            !   ! x* = (plant_calloc/c_allometry)* fcur /(plant_nalloc(p) / n_allometry(p) * (1 - cn_stoich_var ) )
+            !   ! x* = (plant_calloc/c_allometry)* fcur /(plant_palloc(p) / p_allometry(p) * (1 - cp_stoich_var ) )
+            !
+            !   if (plant_nalloc(p) / n_allometry(p) / cnl * fcur > cpool_to_leafc(p) / (cnl *  (1 - cn_stoich_var ) ) ) then ! excess N
+            !      fcur = cpool_to_leafc(p) / (plant_nalloc(p) / n_allometry(p) * (1 - cn_stoich_var ) )
+            !   end if
+               nlc = plant_nalloc(p) / n_allometry(p)
+            end if
+         end if
+
+         npool_to_leafn(p)          = (nlc / cnl) * fcur
+         npool_to_leafn_storage(p)  = (nlc / cnl) * (1._r8 - fcur)
+         npool_to_frootn(p)         = (nlc * f1 / cnfr) * fcur
+         npool_to_frootn_storage(p) = (nlc * f1 / cnfr) * (1._r8 - fcur)
+         if (woody(ivt(p)) == 1._r8) then
+            npool_to_livestemn(p)          = (nlc * f3 * f4 / cnlw) * fcur
+            npool_to_livestemn_storage(p)  = (nlc * f3 * f4 / cnlw) * (1._r8 - fcur)
+            npool_to_deadstemn(p)          = (nlc * f3 * (1._r8 - f4) / cndw) * fcur
+            npool_to_deadstemn_storage(p)  = (nlc * f3 * (1._r8 - f4) / cndw) * (1._r8 - fcur)
+            npool_to_livecrootn(p)         = (nlc * f2 * f3 * f4 / cnlw) * fcur
+            npool_to_livecrootn_storage(p) = (nlc * f2 * f3 * f4 / cnlw) * (1._r8 - fcur)
+            npool_to_deadcrootn(p)         = (nlc * f2 * f3 * (1._r8 - f4) / cndw) * fcur
+            npool_to_deadcrootn_storage(p) = (nlc * f2 * f3 * (1._r8 - f4) / cndw) * (1._r8 - fcur)
+         end if
+         if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+            cng = graincn(ivt(p))
+            npool_to_livestemn(p)          = (nlc * f3 * f4 / cnlw) * fcur
+            npool_to_livestemn_storage(p)  = (nlc * f3 * f4 / cnlw) * (1._r8 - fcur)
+            npool_to_deadstemn(p)          = (nlc * f3 * (1._r8 - f4) / cndw) * fcur
+            npool_to_deadstemn_storage(p)  = (nlc * f3 * (1._r8 - f4) / cndw) * (1._r8 - fcur)
+            npool_to_livecrootn(p)         = (nlc * f2 * f3 * f4 / cnlw) * fcur
+            npool_to_livecrootn_storage(p) = (nlc * f2 * f3 * f4 / cnlw) * (1._r8 - fcur)
+            npool_to_deadcrootn(p)         = (nlc * f2 * f3 * (1._r8 - f4) / cndw) * fcur
+            npool_to_deadcrootn_storage(p) = (nlc * f2 * f3 * (1._r8 - f4) / cndw) * (1._r8 - fcur)
+            npool_to_grainn(p)             = (nlc * f5 / cng) * fcur
+            npool_to_grainn_storage(p)     = (nlc * f5 / cng) * (1._r8 -fcur)
+         end if
+
+         ! corresponding P fluxes
+         ! recover default coefficient for carbon allocation to leaf,  which is possibly changed due to previous time step allocation adjustment
+         !nlc = plant_calloc(p) / c_allometry(p)
+         ! recover allocation fraction,  which is possibly changed due to previous time step allocation adjustment
+         !fcur = fcur2(ivt(p))
+         if (nu_com .ne. 'RD') then
+            if ( carbon_only ) then ! C only mode
+               ! nothing to adjust
+            else ! CN/ CP/ CNP mode
+            !   if (plant_palloc(p) / p_allometry(p) / cpl * fcur > cpool_to_leafc(p) / (cpl *  (1 - cp_stoich_var ) ) ) then ! excess P
+            !      fcur = cpool_to_leafc(p) / (plant_palloc(p) / p_allometry(p) * (1 - cp_stoich_var ) )
+            !   end if
+               nlc = plant_palloc(p) / p_allometry(p)
+            end if
+         end if
+
+         ppool_to_leafp(p)          = (nlc / cpl) * fcur
+         ppool_to_leafp_storage(p)  = (nlc / cpl) * (1._r8 - fcur)
+         ppool_to_frootp(p)         = (nlc * f1 / cpfr) * fcur
+         ppool_to_frootp_storage(p) = (nlc * f1 / cpfr) * (1._r8 - fcur)
+         if (woody(ivt(p)) == 1._r8) then
+            ppool_to_livestemp(p)          = (nlc * f3 * f4 / cplw) * fcur
+            ppool_to_livestemp_storage(p)  = (nlc * f3 * f4 / cplw) * (1._r8 -fcur)
+            ppool_to_deadstemp(p)          = (nlc * f3 * (1._r8 - f4) / cpdw) *fcur
+            ppool_to_deadstemp_storage(p)  = (nlc * f3 * (1._r8 - f4) / cpdw) *(1._r8 - fcur)
+            ppool_to_livecrootp(p)         = (nlc * f2 * f3 * f4 / cplw) * fcur
+            ppool_to_livecrootp_storage(p) = (nlc * f2 * f3 * f4 / cplw) * (1._r8 -fcur)
+            ppool_to_deadcrootp(p)         = (nlc * f2 * f3 * (1._r8 - f4) / cpdw)* fcur
+            ppool_to_deadcrootp_storage(p) = (nlc * f2 * f3 * (1._r8 - f4) / cpdw)* (1._r8 - fcur)
+         end if
+         if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+            cpg = graincp(ivt(p))
+            ppool_to_livestemp(p)          = (nlc * f3 * f4 / cplw) * fcur
+            ppool_to_livestemp_storage(p)  = (nlc * f3 * f4 / cplw) * (1._r8 -fcur)
+            ppool_to_deadstemp(p)          = (nlc * f3 * (1._r8 - f4) / cpdw) * fcur
+            ppool_to_deadstemp_storage(p)  = (nlc * f3 * (1._r8 - f4) / cpdw) *(1._r8 - fcur)
+            ppool_to_livecrootp(p)         = (nlc * f2 * f3 * f4 / cplw) * fcur
+            ppool_to_livecrootp_storage(p) = (nlc * f2 * f3 * f4 / cplw) * (1._r8 -fcur)
+            ppool_to_deadcrootp(p)         = (nlc * f2 * f3 * (1._r8 - f4) / cpdw)* fcur
+            ppool_to_deadcrootp_storage(p) = (nlc * f2 * f3 * (1._r8 - f4) / cpdw)* (1._r8 - fcur)
+            ppool_to_grainp(p)             = (nlc * f5 / cpg) * fcur
+            ppool_to_grainp_storage(p)     = (nlc * f5 / cpg) * (1._r8 -fcur)
+         end if
+
+         ! Calculate the amount of carbon that needs to go into growth
+         ! respiration storage to satisfy all of the storage growth demands.
+         ! Allows for the fraction of growth respiration that is released at the
+         ! time of fixation, versus the remaining fraction that is stored for
+         ! release at the time of display. Note that all the growth respiration
+         ! fluxes that get released on a given timestep are calculated in growth_resp(),
+         ! but that the storage of C for growth resp during display of transferred
+         ! growth is assigned here.
+
+         gresp_storage = cpool_to_leafc_storage(p) + cpool_to_frootc_storage(p)
+         if (woody(ivt(p)) == 1._r8) then
+            gresp_storage = gresp_storage + cpool_to_livestemc_storage(p)
+            gresp_storage = gresp_storage + cpool_to_deadstemc_storage(p)
+            gresp_storage = gresp_storage + cpool_to_livecrootc_storage(p)
+            gresp_storage = gresp_storage + cpool_to_deadcrootc_storage(p)
+         end if
+         if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+            gresp_storage = gresp_storage + cpool_to_livestemc_storage(p)
+            gresp_storage = gresp_storage + cpool_to_grainc_storage(p)
+         end if
+         cpool_to_gresp_storage(p) = gresp_storage * g1 * (1._r8 - g2)
+
+         ! ECA root NP uptake is based on kinetics, plant CNP stoichiometry can vary even
+         ! when certain element is set to not limiting (e.g., P not limiting under CN mode)
+         ! additional supplement N/P come from first soil layer
+         ! must ensure plant get enough N or P or both to maintain its stoichiometry:
+         ! (1) maintain plant PC stoichiometry at optimal ratio under CN mode
+         ! (2) maintain plant NC stoichiometry at optimal ratio under CP mode
+         ! (3) maintain plant PC/NC stoichiometry at optimal ratios under C mode
+
+         if (nu_com .eq. 'ECA' .or. nu_com .eq. 'MIC') then
+
+             supplement_to_plantn(p)  = 0.0_r8
+             supplement_to_plantp(p)  = 0.0_r8
+
+             if ( carbon_only  .or.  carbonphosphorus_only ) then
+
+                 supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_leafc(p) / cnl - npool_to_leafn(p)
+                 supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_leafc_storage(p) / cnl -  npool_to_leafn_storage(p)
+                 supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_frootc(p) / cnfr - npool_to_frootn(p)
+                 supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_frootc_storage(p) / cnfr- npool_to_frootn_storage(p)
+
+                 npool_to_leafn(p) = cpool_to_leafc(p) / cnl
+                 npool_to_leafn_storage(p) =  cpool_to_leafc_storage(p) / cnl
+                 npool_to_frootn(p) = cpool_to_frootc(p) / cnfr
+                 npool_to_frootn_storage(p) = cpool_to_frootc_storage(p) / cnfr
+
+                 if (woody(ivt(p)) == 1._r8) then
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_livestemc(p) / cnlw - npool_to_livestemn(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_livestemc_storage(p) / cnlw &
+                          - npool_to_livestemn_storage(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_deadstemc(p) / cndw - npool_to_deadstemn(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_deadstemc_storage(p) / cndw &
+                          - npool_to_deadstemn_storage(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_livecrootc(p) / cnlw - npool_to_livecrootn(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_livecrootc_storage(p) / cnlw &
+                          - npool_to_livecrootn_storage(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_deadcrootc(p) / cndw - npool_to_deadcrootn(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_deadcrootc_storage(p) / cndw &
+                          - npool_to_deadcrootn_storage(p)
+
+                     npool_to_livestemn(p)  =  cpool_to_livestemc(p) / cnlw
+                     npool_to_livestemn_storage(p) =  cpool_to_livestemc_storage(p) / cnlw
+                     npool_to_deadstemn(p) = cpool_to_deadstemc(p) / cndw
+                     npool_to_deadstemn_storage(p) = cpool_to_deadstemc_storage(p) / cndw
+                     npool_to_livecrootn(p) =  cpool_to_livecrootc(p) / cnlw
+                     npool_to_livecrootn_storage(p) = cpool_to_livecrootc_storage(p) / cnlw
+                     npool_to_deadcrootn(p) = cpool_to_deadcrootc(p) / cndw
+                     npool_to_deadcrootn_storage(p) = cpool_to_deadcrootc_storage(p) / cndw
+                 end if
+                 if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+                     cng = graincn(ivt(p))
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_livestemc(p) / cnlw - npool_to_livestemn(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_livestemc_storage(p) / cnlw &
+                          - npool_to_livestemn_storage(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_deadstemc(p) / cndw - npool_to_deadstemn(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_deadstemc_storage(p) / cndw &
+                          - npool_to_deadstemn_storage(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_livecrootc(p) / cnlw - npool_to_livecrootn(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_livecrootc_storage(p) / cnlw &
+                          - npool_to_livecrootn_storage(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_deadcrootc(p) / cndw - npool_to_deadcrootn(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_deadcrootc_storage(p) / cndw &
+                          - npool_to_deadcrootn_storage(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_grainc(p) / cng - npool_to_grainn(p)
+                     supplement_to_plantn(p)  = supplement_to_plantn(p) + cpool_to_grainc_storage(p) / cng &
+                          - npool_to_grainn_storage(p)
+
+                     npool_to_livestemn(p) = cpool_to_livestemc(p) / cnlw
+                     npool_to_livestemn_storage(p) = cpool_to_livestemc_storage(p) / cnlw
+                     npool_to_deadstemn(p) = cpool_to_deadstemc(p) / cndw
+                     npool_to_deadstemn_storage(p) = cpool_to_deadstemc_storage(p) / cndw
+                     npool_to_livecrootn(p) = cpool_to_livecrootc(p) / cnlw
+                     npool_to_livecrootn_storage(p) = cpool_to_livecrootc_storage(p) / cnlw
+                     npool_to_deadcrootn(p) = cpool_to_deadcrootc(p) / cndw
+                     npool_to_deadcrootn_storage(p) = cpool_to_deadcrootc_storage(p) / cndw
+                     npool_to_grainn(p) = cpool_to_grainc(p) / cng
+                     npool_to_grainn_storage(p) =  cpool_to_grainc_storage(p) / cng
+                 end if
+
+             else if ( carbon_only  .or. carbonnitrogen_only ) then
+
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_leafc(p) / cpl - ppool_to_leafp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_leafc_storage(p) / cpl &
+                          - ppool_to_leafp_storage(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_frootc(p) / cpfr - ppool_to_frootp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_frootc_storage(p) / cpfr &
+                          - ppool_to_frootp_storage(p),0._r8)
+
+                     ppool_to_leafp(p) = cpool_to_leafc(p) / cpl
+                     ppool_to_leafp_storage(p) =  cpool_to_leafc_storage(p) / cpl
+                     ppool_to_frootp(p) = cpool_to_frootc(p) / cpfr
+                     ppool_to_frootp_storage(p) = cpool_to_frootc_storage(p) / cpfr
+
+                 if (woody(ivt(p)) == 1._r8) then
+
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_livestemc(p) / cplw &
+                          - ppool_to_livestemp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_livestemc_storage(p) / cplw &
+                          - ppool_to_livestemp_storage(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_deadstemc(p) /cpdw &
+                          - ppool_to_deadstemp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_deadstemc_storage(p)  / cpdw&
+                          - ppool_to_deadstemp_storage(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_livecrootc(p) / cplw &
+                          - ppool_to_livecrootp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_livecrootc_storage(p) / cplw &
+                          - ppool_to_livecrootp_storage(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_deadcrootc(p) / cpdw &
+                          - ppool_to_deadcrootp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_deadcrootc_storage(p) / cpdw &
+                          - ppool_to_deadcrootp_storage(p),0._r8)
+
+                     ppool_to_livestemp(p) = cpool_to_livestemc(p) / cplw
+                     ppool_to_livestemp_storage(p) = cpool_to_livestemc_storage(p) / cplw
+                     ppool_to_deadstemp(p) = cpool_to_deadstemc(p) / cpdw
+                     ppool_to_deadstemp_storage(p) = cpool_to_deadstemc_storage(p) / cpdw
+                     ppool_to_livecrootp(p) = cpool_to_livecrootc(p) / cplw
+                     ppool_to_livecrootp_storage(p) = cpool_to_livecrootc_storage(p) / cplw
+                     ppool_to_deadcrootp(p) = cpool_to_deadcrootc(p) / cpdw
+                     ppool_to_deadcrootp_storage(p) = cpool_to_deadcrootc_storage(p) / cpdw
+                 end if
+                 if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+                     cpg = graincp(ivt(p))
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_livestemc(p) / cplw &
+                          - ppool_to_livestemp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_livestemc_storage(p) / cplw &
+                          - ppool_to_livestemp_storage(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_deadstemc(p) /cpdw &
+                          - ppool_to_deadstemp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_deadstemc_storage(p)  / cpdw&
+                          - ppool_to_deadstemp_storage(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_livecrootc(p) / cplw &
+                          - ppool_to_livecrootp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_livecrootc_storage(p) / cplw &
+                          - ppool_to_livecrootp_storage(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_deadcrootc(p) / cpdw &
+                          - ppool_to_deadcrootp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_deadcrootc_storage(p) / cpdw &
+                          - ppool_to_deadcrootp_storage(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_grainc(p) / cpg - ppool_to_grainp(p),0._r8)
+                     supplement_to_plantp(p) = supplement_to_plantp(p) + max(cpool_to_grainc_storage(p) / cpg &
+                          - ppool_to_grainp_storage(p),0._r8)
+
+                     ppool_to_livestemp(p) = cpool_to_livestemc(p) / cplw
+                     ppool_to_livestemp_storage(p) = cpool_to_livestemc_storage(p) / cplw
+                     ppool_to_deadstemp(p) = cpool_to_deadstemc(p) / cpdw
+                     ppool_to_deadstemp_storage(p) = cpool_to_deadstemc_storage(p) / cpdw
+                     ppool_to_livecrootp(p) = cpool_to_livecrootc(p) / cplw
+                     ppool_to_livecrootp_storage(p) = cpool_to_livecrootc_storage(p) / cplw
+                     ppool_to_deadcrootp(p) = cpool_to_deadcrootc(p) / cpdw
+                     ppool_to_deadcrootp_storage(p) = cpool_to_deadcrootc_storage(p) / cpdw
+                     ppool_to_grainp(p) = cpool_to_grainc(p) / cpg
+                     ppool_to_grainp_storage(p) =  cpool_to_grainc_storage(p) / cpg
+                 end if
+
+             end if
+
+         end if
+
+      end do ! end pft loop
 
       !----------------------------------------------------------------
       ! now use the p2c routine to update column level soil mineral N and P uptake
       ! based on competition between N and P limitation       - XYANG
       !! Nitrogen
-      !if (nu_com .eq. 'RD') then
+      if (nu_com .eq. 'RD') then
+
+
         !! Phosphorus
+
         if( .not.carbonphosphorus_only .and. .not.carbonnitrogen_only .and. &
              .not. carbon_only )then
 
-             !$acc enter data create(temp_sminn_to_plant(:), temp_sminp_to_plant(:))
-             !$acc parallel loop gang worker vector private(c)
-             do fc = 1, num_soilc
-               c = filter_soilc(fc)
-               temp_sminn_to_plant(fc) = sminn_to_plant(c)
-               temp_sminp_to_plant(fc) = sminp_to_plant(c)
-            end do
+          temp_sminn_to_plant(bounds%begc:bounds%endc) = sminn_to_plant(bounds%begc:bounds%endc)
+          temp_sminp_to_plant(bounds%begc:bounds%endc) = sminp_to_plant(bounds%begc:bounds%endc)
 
-            call p2c_1d_filter_parallel(num_soilc,filter_soilc, &
-                sminn_to_npool, sminn_to_plant)
+            call p2c(bounds,num_soilc,filter_soilc, &
+                sminn_to_npool(bounds%begp:bounds%endp), &
+                sminn_to_plant(bounds%begc:bounds%endc))
 
-            call p2c_1d_filter_parallel(num_soilc,filter_soilc, &
-                sminp_to_ppool, sminp_to_plant )
+            call p2c(bounds,num_soilc,filter_soilc, &
+                sminp_to_ppool(bounds%begp:bounds%endp), &
+                sminp_to_plant(bounds%begc:bounds%endc))
 
 
-            !$acc parallel loop gang independent default(present)
             do j = 1, nlevdecomp
-               !$acc loop worker vector private(c)
                do fc=1,num_soilc
                   c = filter_soilc(fc)
-                  if ( temp_sminn_to_plant(fc) > 0._r8) then
-                     sminn_to_plant_vr(c,j)    = sminn_to_plant_vr(c,j) * ( sminn_to_plant(c)/temp_sminn_to_plant(fc) )
-                     smin_nh4_to_plant_vr(c,j) = smin_nh4_to_plant_vr(c,j) * ( sminn_to_plant(c)/temp_sminn_to_plant(fc) )
-                     smin_no3_to_plant_vr(c,j) = smin_no3_to_plant_vr(c,j) * ( sminn_to_plant(c)/temp_sminn_to_plant(fc) )
+                  if ( temp_sminn_to_plant(c) > 0._r8) then
+                     sminn_to_plant_vr(c,j)    = sminn_to_plant_vr(c,j) * ( sminn_to_plant(c)/temp_sminn_to_plant(c) )
+                     smin_nh4_to_plant_vr(c,j) = smin_nh4_to_plant_vr(c,j) * ( sminn_to_plant(c)/temp_sminn_to_plant(c) )
+                     smin_no3_to_plant_vr(c,j) = smin_no3_to_plant_vr(c,j) * ( sminn_to_plant(c)/temp_sminn_to_plant(c) )
                   else
                      sminn_to_plant_vr(c,j)    = 0._r8
                      smin_nh4_to_plant_vr(c,j) = 0._r8
                      smin_no3_to_plant_vr(c,j) = 0._r8
                   endif
 
-                  if ( temp_sminp_to_plant(fc) > 0._r8) then
-                     sminp_to_plant_vr(c,j) =  sminp_to_plant_vr(c,j) * ( sminp_to_plant(c)/temp_sminp_to_plant(fc) )
+                  if ( temp_sminp_to_plant(c) > 0._r8) then
+                     sminp_to_plant_vr(c,j) =  sminp_to_plant_vr(c,j) * ( sminp_to_plant(c)/temp_sminp_to_plant(c) )
                   else
                      sminp_to_plant_vr(c,j) = 0._r8
                   endif
                end do
             end do
-            !$acc exit data delete(temp_sminp_to_plant(:), temp_sminn_to_plant(:))
 
           end if   ! carbonnitrogenphosphorus
 
           if(  carbonnitrogen_only  )then
 
-             !$acc enter data create(temp_sminp_to_plant(:))
-             !$acc parallel loop independent gang worker vector private(c)
-             do fc = 1, num_soilc
-                c = filter_soilc(fc)
-                temp_sminp_to_plant(fc) = sminp_to_plant(c)
-            end do
+          temp_sminp_to_plant(bounds%begc:bounds%endc) = sminp_to_plant(bounds%begc:bounds%endc)
 
-            call p2c_1d_filter_parallel(num_soilc,filter_soilc, &
-                sminp_to_ppool , sminp_to_plant )
+            call p2c(bounds,num_soilc,filter_soilc, &
+                sminp_to_ppool(bounds%begp:bounds%endp), &
+                sminp_to_plant(bounds%begc:bounds%endc))
 
-            !$acc parallel loop gang independent default(present)
-            do j = 1, nlevdecomp
-               !$acc loop worker vector private(c)
+           do j = 1, nlevdecomp
                do fc=1,num_soilc
                   c = filter_soilc(fc)
-                  if ( temp_sminp_to_plant(fc) > 0._r8) then
-                     sminp_to_plant_vr(c,j) =  sminp_to_plant_vr(c,j) * ( sminp_to_plant(c)/temp_sminp_to_plant(fc) )
+
+                  if ( temp_sminp_to_plant(c) > 0._r8) then
+                     sminp_to_plant_vr(c,j) =  sminp_to_plant_vr(c,j) * ( sminp_to_plant(c)/temp_sminp_to_plant(c) )
                   else
                      sminp_to_plant_vr(c,j) = 0._r8
                   endif
                end do
             end do
-
-            !$acc exit data delete(temp_sminp_to_plant(:))
           end if  ! carbonnitrogen
 
-      !end if ! nu_com .eq. RD
+      end if ! nu_com .eq. RD
+
+
       !----------------------------------------------------------------
-      !$acc exit data delete(sum1,sum2) 
+
     end associate
 
   end subroutine Allocation3_PlantCNPAlloc
+  
+  ! ======================================================================================
 
-  subroutine DistributeN_RD(num_soilp,filter_soilp,cnstate_vars,crop_vars)
-     ! Routine called in Allocation Phase 3
-     use pftvarcon   , only : npcropmin, grperc, grpnow
-     use elm_varctl  , only : carbon_only , carbonnitrogen_only ,carbonphosphorus_only!
-     use pftvarcon   , only : noveg
-
-     !
-     integer :: num_soilp 
-     integer :: filter_soilp(:)
-     type(cnstate_type), intent(inout) :: cnstate_vars
-     type(crop_type), intent(in) :: crop_vars
-     real(r8):: f1,f2,f3,f4,f5,g1,g2   !allocation parameters
-     real(r8):: cnl,cnfr,cnlw,cndw     !C:N ratios for leaf, fine root, and wood
-     real(r8):: fcur                   !fraction of current psn displayed as growth
-     real(r8):: gresp_storage          !temporary variable for growth resp to storage
-     real(r8):: nlc                    !temporary variable for total new leaf carbon allocation
-     real(r8):: cng                      !C:N ratio for grain (= cnlw for now; slevis)
-
-     !! Local P variables
-     real(r8):: rc, rc_p, r            !Factors for nitrogen pool
-     real(r8):: cpl,cpfr,cplw,cpdw,cpg !C:N ratios for leaf, fine root, and wood
-     integer :: ivt,fp ,p,c 
-
-     associate(&
-        woody                        => veg_vp%woody                         , & ! Input:  [real(r8) (:)   ]  binary flag for woody lifeform (1=woody, 0=not woody)
-        froot_leaf                   => veg_vp%froot_leaf                    , & ! Input:  [real(r8) (:)   ]  allocation parameter: new fine root C per new leaf C (gC/gC)
-        croot_stem                   => veg_vp%croot_stem                    , & ! Input:  [real(r8) (:)   ]  allocation parameter: new coarse root C per new stem C (gC/gC)
-        stem_leaf                    => veg_vp%stem_leaf                     , & ! Input:  [real(r8) (:)   ]  allocation parameter: new stem c per new leaf C (gC/gC)
-        flivewd                      => veg_vp%flivewd                       , & ! Input:  [real(r8) (:)   ]  allocation parameter: fraction of new wood that is live (phloem and ray parenchyma) (no units)
-        leafcn                       => veg_vp%leafcn                        , & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
-        frootcn                      => veg_vp%frootcn                       , & ! Input:  [real(r8) (:)   ]  fine root C:N (gC/gN)
-        livewdcn                     => veg_vp%livewdcn                      , & ! Input:  [real(r8) (:)   ]  live wood (phloem and ray parenchyma) C:N (gC/gN)
-        deadwdcn                     => veg_vp%deadwdcn                      , & ! Input:  [real(r8) (:)   ]  dead wood (xylem and heartwood) C:N (gC/gN)
-        fcur2                        => veg_vp%fcur                          , & ! Input:  [real(r8) (:)   ]  allocation parameter: fraction of allocation that goes to currently displayed growth, remainder to storage
-        graincn                      => veg_vp%graincn                       , & ! Input:  [real(r8) (:)   ]  grain C:N (gC/gN)
-        croplive                     => crop_vars%croplive_patch             , & ! Input:  [logical  (:)   ]  flag, true if planted, not harvested
-        aleaf                        => cnstate_vars%aleaf_patch             , & ! Output: [real(r8) (:)   ]  leaf allocation coefficient
-        astem                        => cnstate_vars%astem_patch             , & ! Output: [real(r8) (:)   ]  stem allocation coefficient
-        fpg                          => cnstate_vars%fpg_col                 , & ! Output: [real(r8) (:)   ]  fraction of potential gpp (no units)
-        !!! add phosphorus
-        leafcp                       => veg_vp%leafcp                        , & ! Input:  [real(r8) (:)   ]  leaf C:P (gC/gP)
-        frootcp                      => veg_vp%frootcp                       , & ! Input:  [real(r8) (:)   ]  fine root C:P (gC/gP)
-        livewdcp                     => veg_vp%livewdcp                      , & ! Input:  [real(r8) (:)   ]  live wood (phloem and ray parenchyma) C:P (gC/gP)
-        deadwdcp                     => veg_vp%deadwdcp                      , & ! Input:  [real(r8) (:)   ]  dead wood (xylem and heartwood) C:P (gC/gP)
-        graincp                      => veg_vp%graincp                       , & ! Input:  [real(r8) (:)   ]  grain C:P (gC/gP)
-        fpg_p                        => cnstate_vars%fpg_p_col               , & ! Output: [real(r8) (:)   ]  fraction of potential gpp (no units)
-        c_allometry                  => cnstate_vars%c_allometry_patch       , & ! Output: [real(r8) (:)   ]  C allocation index (DIM)
-        n_allometry                  => cnstate_vars%n_allometry_patch       , & ! Output: [real(r8) (:)   ]  N allocation index (DIM)
-        downreg                      => cnstate_vars%downreg_patch           , & ! Output: [real(r8) (:)   ]  fractional reduction in GPP due to N limitation (DIM)
-        annsum_npp                   => veg_cf%annsum_npp                    , & ! Input:  [real(r8) (:)   ]  annual sum of NPP, for wood allocation
-        gpp                          => veg_cf%gpp_before_downreg            , & ! Output: [real(r8) (:)   ]  GPP flux before downregulation (gC/m2/s)
-        availc                       => veg_cf%availc                        , & ! Output: [real(r8) (:)   ]  C flux available for allocation (gC/m2/s)
-        excess_cflux                 => veg_cf%excess_cflux                  , & ! Output: [real(r8) (:)   ]  C flux not allocated due to downregulation (gC/m2/s)
-        plant_calloc                 => veg_cf%plant_calloc                  , & ! Output: [real(r8) (:)   ]  total allocated C flux (gC/m2/s)
-        psnsun_to_cpool              => veg_cf%psnsun_to_cpool               , & ! Output: [real(r8) (:)   ]
-        psnshade_to_cpool            => veg_cf%psnshade_to_cpool             , & ! Output: [real(r8) (:)   ]
-        cpool_to_leafc               => veg_cf%cpool_to_leafc                , & ! Output: [real(r8) (:)   ]
-        cpool_to_leafc_storage       => veg_cf%cpool_to_leafc_storage        , & ! Output: [real(r8) (:)   ]
-        cpool_to_frootc              => veg_cf%cpool_to_frootc               , & ! Output: [real(r8) (:)   ]
-        cpool_to_frootc_storage      => veg_cf%cpool_to_frootc_storage       , & ! Output: [real(r8) (:)   ]
-        cpool_to_livestemc           => veg_cf%cpool_to_livestemc            , & ! Output: [real(r8) (:)   ]
-        cpool_to_livestemc_storage   => veg_cf%cpool_to_livestemc_storage    , & ! Output: [real(r8) (:)   ]
-        cpool_to_deadstemc           => veg_cf%cpool_to_deadstemc            , & ! Output: [real(r8) (:)   ]
-        cpool_to_deadstemc_storage   => veg_cf%cpool_to_deadstemc_storage    , & ! Output: [real(r8) (:)   ]
-        cpool_to_livecrootc          => veg_cf%cpool_to_livecrootc           , & ! Output: [real(r8) (:)   ]
-        cpool_to_livecrootc_storage  => veg_cf%cpool_to_livecrootc_storage   , & ! Output: [real(r8) (:)   ]
-        cpool_to_deadcrootc          => veg_cf%cpool_to_deadcrootc           , & ! Output: [real(r8) (:)   ]
-        cpool_to_deadcrootc_storage  => veg_cf%cpool_to_deadcrootc_storage   , & ! Output: [real(r8) (:)   ]
-        cpool_to_gresp_storage       => veg_cf%cpool_to_gresp_storage        , & ! Output: [real(r8) (:)   ]  allocation to growth respiration storage (gC/m2/s)
-        cpool_to_grainc              => veg_cf%cpool_to_grainc               , & ! Output: [real(r8) (:)   ]  allocation to grain C (gC/m2/s)
-        cpool_to_grainc_storage      => veg_cf%cpool_to_grainc_storage       , & ! Output: [real(r8) (:)   ]  allocation to grain C storage (gC/m2/s)
-        npool                        => veg_ns%npool                        , & ! Input:  [real(r8) (:)   ]  (gN/m2) plant N pool storage
-        plant_ndemand                => veg_nf%plant_ndemand               , & ! Output: [real(r8) (:)   ]  N flux required to support initial GPP (gN/m2/s)
-        plant_nalloc                 => veg_nf%plant_nalloc                , & ! Output: [real(r8) (:)   ]  total allocated N flux (gN/m2/s)
-        npool_to_grainn              => veg_nf%npool_to_grainn             , & ! Output: [real(r8) (:)   ]  allocation to grain N (gN/m2/s)
-        npool_to_grainn_storage      => veg_nf%npool_to_grainn_storage     , & ! Output: [real(r8) (:)   ]  allocation to grain N storage (gN/m2/s)
-        retransn_to_npool            => veg_nf%retransn_to_npool           , & ! Output: [real(r8) (:)   ]  deployment of retranslocated N (gN/m2/s)
-        sminn_to_npool               => veg_nf%sminn_to_npool              , & ! Output: [real(r8) (:)   ]  deployment of soil mineral N uptake (gN/m2/s)
-
-        npool_to_leafn               => veg_nf%npool_to_leafn              , & ! Output: [real(r8) (:)   ]  allocation to leaf N (gN/m2/s)
-        npool_to_leafn_storage       => veg_nf%npool_to_leafn_storage      , & ! Output: [real(r8) (:)   ]  allocation to leaf N storage (gN/m2/s)
-        npool_to_frootn              => veg_nf%npool_to_frootn             , & ! Output: [real(r8) (:)   ]  allocation to fine root N (gN/m2/s)
-        npool_to_frootn_storage      => veg_nf%npool_to_frootn_storage     , & ! Output: [real(r8) (:)   ]  allocation to fine root N storage (gN/m2/s)
-        npool_to_livestemn           => veg_nf%npool_to_livestemn          , & ! Output: [real(r8) (:)   ]
-        npool_to_livestemn_storage   => veg_nf%npool_to_livestemn_storage  , & ! Output: [real(r8) (:)   ]
-        npool_to_deadstemn           => veg_nf%npool_to_deadstemn          , & ! Output: [real(r8) (:)   ]
-        npool_to_deadstemn_storage   => veg_nf%npool_to_deadstemn_storage  , & ! Output: [real(r8) (:)   ]
-        npool_to_livecrootn          => veg_nf%npool_to_livecrootn         , & ! Output: [real(r8) (:)   ]
-        npool_to_livecrootn_storage  => veg_nf%npool_to_livecrootn_storage , & ! Output: [real(r8) (:)   ]
-        npool_to_deadcrootn          => veg_nf%npool_to_deadcrootn         , & ! Output: [real(r8) (:)   ]
-        npool_to_deadcrootn_storage  => veg_nf%npool_to_deadcrootn_storage , & ! Output: [real(r8) (:)   ]
-        !!! add phosphorus variables  - X. YANG
-        ppool                        => veg_ps%ppool                      , & ! Input: [real(r8)       ] Plant non-structural P storage (gP/m2)
-        plant_pdemand                => veg_pf%plant_pdemand               , & ! Output: [real(r8) (:)   ]  P flux required to support initial GPP (gP/m2/s)
-        plant_palloc                 => veg_pf%plant_palloc                , & ! Output: [real(r8) (:)   ]  total allocated P flux (gP/m2/s)
-        ppool_to_grainp              => veg_pf%ppool_to_grainp             , & ! Output: [real(r8) (:)   ]  allocation to grain P (gP/m2/s)
-        ppool_to_grainp_storage      => veg_pf%ppool_to_grainp_storage     , & ! Output: [real(r8) (:)   ]  allocation to grain P storage (gP/m2/s)
-        retransp_to_ppool            => veg_pf%retransp_to_ppool           , & ! Output: [real(r8) (:)   ]  deployment of retranslocated P (gP/m2/s)
-        sminp_to_ppool               => veg_pf%sminp_to_ppool              , & ! Output: [real(r8) (:)   ]  deployment of soil mineral P uptake (gP/m2/s)
-        ppool_to_leafp               => veg_pf%ppool_to_leafp              , & ! Output: [real(r8) (:)   ]  allocation to leaf P (gP/m2/s)
-        ppool_to_leafp_storage       => veg_pf%ppool_to_leafp_storage      , & ! Output: [real(r8) (:)   ]  allocation to leaf P storage (gP/m2/s)
-        ppool_to_frootp              => veg_pf%ppool_to_frootp             , & ! Output: [real(r8) (:)   ]  allocation to fine root P (gP/m2/s)
-        ppool_to_frootp_storage      => veg_pf%ppool_to_frootp_storage     , & ! Output: [real(r8) (:)   ]  allocation to fine root P storage (gP/m2/s)
-        ppool_to_livestemp           => veg_pf%ppool_to_livestemp          , & ! Output: [real(r8) (:)   ]
-        ppool_to_livestemp_storage   => veg_pf%ppool_to_livestemp_storage  , & ! Output: [real(r8) (:)   ]
-        ppool_to_deadstemp           => veg_pf%ppool_to_deadstemp          , & ! Output: [real(r8) (:)   ]
-        ppool_to_deadstemp_storage   => veg_pf%ppool_to_deadstemp_storage  , & ! Output: [real(r8) (:)   ]
-        ppool_to_livecrootp          => veg_pf%ppool_to_livecrootp         , & ! Output: [real(r8) (:)   ]
-        ppool_to_livecrootp_storage  => veg_pf%ppool_to_livecrootp_storage , & ! Output: [real(r8) (:)   ]
-        ppool_to_deadcrootp          => veg_pf%ppool_to_deadcrootp         , & ! Output: [real(r8) (:)   ]
-        ppool_to_deadcrootp_storage  => veg_pf%ppool_to_deadcrootp_storage , & ! Output: [real(r8) (:)   ]
-        p_allometry                  => cnstate_vars%p_allometry_patch      & ! Output: [real(r8) (:)   ]  P allocation index (DIM)
-        )
-      
-      !$acc parallel loop independent gang vector default(present)
-      do fp = 1, num_soilp 
-         p= filter_soilp(fp) 
-         c= veg_pp%column(p)
-         ivt = veg_pp%itype(p)
-            ! set some local allocation variables
-            f1 = froot_leaf(ivt)
-            f2 = croot_stem(ivt)
-
-            ! modified wood allocation to be 2.2 at npp=800 gC/m2/yr, 0.2 at npp=0,
-            ! constrained so that it does not go lower than 0.2 (under negative annsum_npp)
-            ! There was an error in this formula in previous version, where the coefficient
-            ! was 0.004 instead of 0.0025.
-            ! This variable allocation is only for trees. Shrubs have a constant
-            ! allocation as specified in the pft-physiology file.  The value is also used
-            ! as a trigger here: -1.0 means to use the dynamic allocation (trees).
-
-            if (stem_leaf(ivt) < 0._r8) then
-                if (stem_leaf(ivt) == -1._r8) then
-                    f3 = (2.7/(1.0+exp(-0.004*(annsum_npp(p) - 300.0)))) - 0.4
-                else
-                    f3 = max((-1.0_r8*stem_leaf(ivt)*2.7_r8)/(1.0_r8+exp(-0.004_r8*(annsum_npp(p) - &
-                              300.0_r8))) - 0.4_r8, 0.2_r8)
-                end if
-            else
-                f3 = stem_leaf(ivt)
-            end if
+  subroutine NAllocationECAMIC(pci,dt,                     & ! IN
+       bd,                     & ! IN (j)
+       h2osoi_vol,             & ! IN (j)
+       t_scalar,               & ! IN (j)
+       n_pcomp,                & ! IN
+       filter_pcomp,           & ! IN (i)
+       veg_rootc,              & ! IN (icomp,j)
+       ft_index,               & ! IN (icomp)
+       cn_scalar_runmean,      & ! IN (icomp)
+       decompmicc,             & ! IN (j)
+       smin_nh4_vr,            & ! IN (j)
+       nu_com,                 & ! IN
+       km_nh4_plant,           & ! IN (pft)
+       vmax_nh4_plant,         & ! IN (pft)
+       km_decomp_nh4,          & ! IN 
+       potential_immob_vr,     & ! IN (j)
+       plant_nh4demand_vr,     & ! INOUT (i,j)
+       col_plant_nh4demand_vr, & ! OUT (j)
+       fpi_nh4_vr,             & ! OUT (j)
+       actual_immob_nh4_vr,    & ! OUT (j)
+       smin_nh4_to_plant_vr,   & ! OUT (j)
+       smin_no3_vr,            & ! IN (j) 
+       km_no3_plant,           & ! IN (pft)
+       vmax_no3_plant,         & ! IN (pft)
+       km_decomp_no3,          & ! IN (j)
+       km_nit,                 & ! IN (j)
+       km_den,                 & ! IN (j)
+       pot_f_nit_vr,           & ! IN (j)
+       pot_f_denit_vr,         & ! IN (j)
+       plant_no3demand_vr,     & ! INOUT (i,j)
+       col_plant_no3demand_vr, & ! OUT (j)
+       fpi_no3_vr,             & ! OUT (j)
+       actual_immob_no3_vr,    & ! OUT (j)
+       smin_no3_to_plant_vr,   & ! OUT (j)
+       f_nit_vr,               & ! OUT (j)
+       f_denit_vr)               ! OUT (j)
 
-            f4 = flivewd(ivt)
-            g1 = grperc(ivt)
-            g2 = grpnow(ivt)
-            cnl = leafcn(ivt)
-            cnfr = frootcn(ivt)
-            cnlw = livewdcn(ivt)
-            cndw = deadwdcn(ivt)
-
-            cpl = leafcp(ivt)
-            cpfr = frootcp(ivt)
-            cplw = livewdcp(ivt)
-            cpdw = deadwdcp(ivt)
-
-            fcur = fcur2(ivt)
-
-            if (ivt >= npcropmin) then ! skip 2 generic crops
-                if (croplive(p)) then
-                    f1 = aroot(p) / aleaf(p)
-                    f3 = astem(p) / aleaf(p)
-                    f5 = arepr(p) / aleaf(p)
-                    g1 = 0.25_r8
-                else
-                    f1 = 0._r8
-                    f3 = 0._r8
-                    f5 = 0._r8
-                    g1 = 0.25_r8
-                end if
-            end if
+    ! ------------------------------------------------------------------------------------
+    ! Competitive allocation of NH4 and NO3 nutrient species per ECA
+    ! kinetics following  Zhu et al., 2016 DOI: 10.1002/2016JG003554
+    ! ------------------------------------------------------------------------------------
+    use elm_varpar      , only: nlevdecomp
+    use elm_varctl      , only : carbon_only          !
+    use elm_varctl      , only : carbonnitrogen_only  !
+    use elm_varctl      , only : carbonphosphorus_only!
+    
+    integer,  intent(in) :: pci               ! First index of plant comp arrays
+    real(r8), intent(in) :: dt                ! Time step duration [s]
+    real(r8), intent(in) :: bd(:)             ! Bulk density of dry soil material [kg m-3]
+    real(r8), intent(in) :: h2osoi_vol(:)     ! Vol. Soil Water in each layer [m3]
+    real(r8), intent(in) :: t_scalar(:)       ! fraction by which decomposition is limited by temperature  
+    integer,  intent(in) :: n_pcomp           ! number of plant competitors
+    integer,  intent(in) :: filter_pcomp(:)   ! plant competition filter
+    real(r8), intent(in) :: veg_rootc(pci:,:) ! total fine-root biomass of each competitor [gC/m3]
+                                              ! (per area of column, not patch)
+    integer, intent(in)  :: ft_index(pci:)    ! pft index of plant competitors
+    real(r8), intent(in) :: cn_scalar_runmean(pci:)   ! scaling factor implying plant demand
+    real(r8), intent(in) :: decompmicc(:)     ! microbial decomposer biomass [gC/m3]
+    character(len=*), intent(in) :: nu_com    ! Is this ECA or MIC?
+    ! NH4 specific arguments
+    real(r8), intent(in)  :: smin_nh4_vr(:)            ! minearlized nh4 in soil [g m-3]
+    real(r8), intent(in)  :: km_nh4_plant(:)           ! km for plant type uptake
+    real(r8), intent(in)  :: vmax_nh4_plant(:)         ! vmax for plant uptake
+    real(r8), intent(in)  :: km_decomp_nh4             ! km for microbial decomposer nh4 uptake
+    real(r8), intent(in)  :: potential_immob_vr(:)     ! potential N immobilization [g/m3/s]
+    real(r8), intent(inout) :: plant_nh4demand_vr(pci:,:) ! [g m-3 s-1] (m2 of col, not patch)
+    real(r8), intent(inout) :: col_plant_nh4demand_vr(:) ! [g m-3 s-1] (m2 of col, not patch)
+    real(r8), intent(inout) :: fpi_nh4_vr(:)             ! fraction of potential immobilization supplied by nh4 (no units)
+    real(r8), intent(inout) :: actual_immob_nh4_vr(:)    ! actual nh4 immobilization [g/m3/s]
+    real(r8), intent(inout) :: smin_nh4_to_plant_vr(:)   ! nh4 flux to plant competitors [g/s]
+
+
+    ! NO3 specific arguments (all optional)
+    real(r8), intent(in)  :: smin_no3_vr(:)            ! minearlized no3 in soil [g m-3]
+    real(r8), intent(in)  :: km_no3_plant(:)           ! km for plant type uptake
+    real(r8), intent(in)  :: vmax_no3_plant(:)         ! vmax for plant uptake
+    real(r8), intent(in)  :: km_decomp_no3             ! km for microbial decomposer nh4 uptake
+    real(r8), intent(in)  :: km_nit                    ! km for nitrifier nh4 uptake
+    real(r8), intent(in)  :: km_den                    ! km for denitrifier no3 uptake
+    real(r8), intent(in)  :: pot_f_nit_vr(:)           ! potential soil nitrification flux [g/m3/s]
+    real(r8), intent(in)  :: pot_f_denit_vr(:)         ! potential soil denitrification flux [g/m3/s]
+    real(r8), intent(inout) :: plant_no3demand_vr(pci:,:) ! [gN m-3 s-1] (m2 of col, not patch)
+    real(r8), intent(inout) :: col_plant_no3demand_vr(:) ! [gN m-3 s-1] (m2 of col, not patch)
+    real(r8), intent(inout) :: fpi_no3_vr(:)             ! fraction of potential immobilization supplied by no3 (no units)
+    real(r8), intent(inout) :: actual_immob_no3_vr(:)    ! actual no3 immobilization [gN/m3/s]
+    real(r8), intent(inout) :: smin_no3_to_plant_vr(:)   ! no3 flux to plant competitors [g/s]
+    real(r8), intent(inout) :: f_nit_vr(:)               ! soil nitrification flux [g/m3/s]
+    real(r8), intent(inout) :: f_denit_vr(:)             ! soil nitrification flux [g/m3/s]
 
-            ! increase fcur linearly with ndays_active, until fcur reaches 1.0 at
-            ! ndays_active = days/year.  This prevents the continued storage of C and N.
-            ! turning off this correction (PET, 12/11/03), instead using bgtr in
-            ! phenology algorithm.
 
-            if (veg_vp%nstor(ivt) > 1e-6_r8) then
-              !N pool modification
-              sminn_to_npool(p) = plant_ndemand(p) * min(fpg(c), fpg_p(c))
-              sminp_to_ppool(p) = plant_pdemand(p) * min(fpg(c), fpg_p(c))
+    ! Locals
+    real(r8) :: sum_nh4_demand        ! Total nh4 demand over all competitors
+    real(r8) :: sum_nh4_demand_scaled ! Total nh4 demand, but scaled by competitivness
+    real(r8) :: sum_no3_demand        ! "" no3
+    real(r8) :: sum_no3_demand_scaled ! "" no3
+    real(r8) :: e_km                  ! temp variable of sum(E/KM) (different species)
+    real(r8) :: solution_conc         ! mineralized N (nh4 or no3) concentration
+                                      ! g nutrient per m3 water
+    real(r8) :: compet_plant(n_pcomp) ! (unitless) relative compettiveness of plants for NO3 or NH4
+    real(r8) :: compet_decomp         ! (unitless) relative competitiveness of immobilizers for NO3 or NH4
+    real(r8) :: compet_denit          ! (unitless) relative competitiveness of denitrifiers for NO3
+    real(r8) :: compet_nit            ! (unitless) relative competitiveness of nitrifiers for NH4
+    integer :: j                      ! loop index for soil layers
+    integer :: i,ip                   ! loop index for competitors
+    integer :: ft                     ! loop index for pfts
+
+    ! 2.76 consider soil adsorption effect on [NH4+] availability, 
+    ! based on Zhu et al., 2016 DOI: 10.1002/2016JG003554
+    real(r8), parameter :: adsorp_nh4_eff = 2.76_r8
+
+    real(r8), parameter :: m3_per_liter = 1.e-3_r8   ! m3 per liter
 
-              rc   = veg_vp%nstor(ivt) * max(annsum_npp(p) * n_allometry(p) / c_allometry(p), 0.01_r8)
-              rc_p = veg_vp%nstor(ivt) * max(annsum_npp(p) * p_allometry(p) / c_allometry(p), 0.01_r8)
+    do j = 1, nlevdecomp
 
-              if ( carbon_only  .or.  carbonphosphorus_only ) then
-                r = 1.0_r8
-              else
-                r  = max(1._r8,rc/max(npool(p), 1e-15_r8))
-              end if
-              plant_nalloc(p) = (plant_ndemand(p) + retransn_to_npool(p)) / r
+       ! Plant, microbial decomposers compete for NH4. Thus loop over each 
+       ! plant competitor in this competitive space (column).
+       ! Calculate competition coefficients for N/P, first need to convert 
+       ! concentration to per soil water based 
 
-              if ( carbon_only  .or.  carbonnitrogen_only ) then
-                r = 1.0_r8
-              else
-                r  = max(1._r8,rc_p/max(ppool(p), 1e-15_r8))
-              end if
-              plant_palloc(p) = (plant_pdemand(p) + retransp_to_ppool(p)) / r
+       ! concentration of mineralized nutrient, per soil water
+       solution_conc = smin_nh4_vr(j) / (bd(j)*adsorp_nh4_eff*m3_per_liter + h2osoi_vol(j))
+       
+       e_km = 0._r8
+       do i = 1, n_pcomp
+          ip = filter_pcomp(i)
+          ft = ft_index(ip)
+          e_km = e_km + e_plant_scalar*veg_rootc(ip,j)/km_nh4_plant(ft)
+       end do
 
-            else
-              sminn_to_npool(p) = plant_ndemand(p) * fpg(c)
-              sminp_to_ppool(p) = plant_pdemand(p) * fpg_p(c)
+       e_km = e_km + e_decomp_scalar*decompmicc(j)*(1._r8/km_decomp_nh4 + 1._r8/km_nit)
 
-              plant_nalloc(p) = sminn_to_npool(p) + retransn_to_npool(p)
-              plant_palloc(p) = sminp_to_ppool(p) + retransp_to_ppool(p)
-            end if
+       do i = 1, n_pcomp
+          ip = filter_pcomp(i)
+          ft = ft_index(ip)
+          compet_plant(i) = solution_conc / & 
+               ( km_nh4_plant(ft) * (1._r8 + solution_conc/km_nh4_plant(ft) + e_km))
+       end do
+          
+       compet_decomp = solution_conc / (km_decomp_nh4 * (1._r8 + solution_conc/km_decomp_nh4 + e_km))
 
-            ! calculate the associated carbon allocation, and the excess
-            ! carbon flux that must be accounted for through downregulation
+       compet_nit    = solution_conc / (km_nit * (1._r8 + solution_conc/km_nit + e_km))
 
-            if( .not.carbonphosphorus_only .and. .not.carbonnitrogen_only .and. .not.carbon_only )then
-                if( plant_nalloc(p) * (c_allometry(p)/n_allometry(p)) < &
-                    plant_palloc(p) * (c_allometry(p)/p_allometry(p)) )then
+       ! relative demand approach: root nutrient uptake profile is based on nutrient concentration profile
+       ! nu_com with ECA or MIC: root nutrient uptake profile is based on fine root density profile
 
-                    plant_calloc(p) = plant_nalloc(p) * (c_allometry(p)/n_allometry(p))
-                    plant_palloc(p) = plant_nalloc(p) * (p_allometry(p)/n_allometry(p))
-                    !in case of strong N limitation, and plant_palloc(p) < retransp_to_ppool(p)
-                    if (veg_vp%nstor(ivt) < 1e-6_r8) then
-                        sminp_to_ppool(p) = max(plant_palloc(p) - retransp_to_ppool(p),0.0_r8)
-                        retransp_to_ppool(p) = min(plant_palloc(p), retransp_to_ppool(p))
-                    end if
-                else
-                    plant_calloc(p) = plant_palloc(p) * (c_allometry(p)/p_allometry(p))
-                    plant_nalloc(p) = plant_palloc(p) * (n_allometry(p)/p_allometry(p))
-                    ! in case of strong P limitation, and plant_nalloc(p) < retransn_to_npool(p)
-                    if (veg_vp%nstor(ivt) < 1e-6_r8) then
-                        sminn_to_npool(p) = max(plant_nalloc(p) - retransn_to_npool(p), 0.0_r8)
-                        retransn_to_npool(p) = min(plant_nalloc(p) , retransn_to_npool(p))
-                    end if
-                endif
-            endif
-
-            if(carbonphosphorus_only .or. carbon_only )then
-                plant_calloc(p) = plant_palloc(p) * (c_allometry(p)/p_allometry(p))
-            endif
-
-            if(carbonnitrogen_only .or. carbon_only )then
-                plant_calloc(p) = plant_nalloc(p) * (c_allometry(p)/n_allometry(p))
-                plant_palloc(p) = plant_calloc(p) * (p_allometry(p)/c_allometry(p))
-                if (veg_vp%nstor(ivt) < 1e-6_r8) then
-                    sminp_to_ppool(p) = max(plant_palloc(p) - retransp_to_ppool(p), 0.0_r8)
-                end if
-            endif
+       col_plant_nh4demand_vr(j) = 0._r8
 
-            excess_cflux(p) = availc(p) - plant_calloc(p)
+       do i = 1, n_pcomp
+          ip = filter_pcomp(i)
+          ft = ft_index(ip)
 
-            ! reduce gpp fluxes due to N limitation
-            if (gpp(p) > 0.0_r8) then
-                downreg(p) = excess_cflux(p)/gpp(p)
+          ! This is the demand per m3 of the column (not patch) 
+          ! (for native ELM divide through by the patch weight to get per m3 of patch)
+          plant_nh4demand_vr(ip,j) = max(0._r8,vmax_nh4_plant(ft) * veg_rootc(ip,j) * &
+               cn_scalar_runmean(ip) * t_scalar(j) *  compet_plant(i))
 
-                if (veg_vp%br_xr(veg_pp%itype(p)) > 1e-9_r8) then
-                    !Excess carbon goes to temporary NSC pool instead of
-                    !instantaneous downregulation
-                    psnsun_to_cpool(p) = psnsun_to_cpool(p)
-                    psnshade_to_cpool(p) = psnshade_to_cpool(p)
-                    if ( use_c13 ) then
-                        c13_veg_cf%psnsun_to_cpool(p) = c13_veg_cf%psnsun_to_cpool(p)
-                        c13_veg_cf%psnshade_to_cpool(p) = c13_veg_cf%psnshade_to_cpool(p)
-                    endif
+          ! This is the total demand across all plant competitors
+          col_plant_nh4demand_vr(j) = col_plant_nh4demand_vr(j) + plant_nh4demand_vr(ip,j)
 
-                    if ( use_c14 ) then
-                        c14_veg_cf%psnsun_to_cpool(p) = c14_veg_cf%psnsun_to_cpool(p)
-                        c14_veg_cf%psnshade_to_cpool(p) = c14_veg_cf%psnshade_to_cpool(p)
-                    endif
+       end do
 
-                else
-                    psnsun_to_cpool(p)   = psnsun_to_cpool(p)  *(1._r8 - downreg(p))
-                    psnshade_to_cpool(p) = psnshade_to_cpool(p)*(1._r8 - downreg(p))
-                    if ( use_c13 ) then
-                        c13_veg_cf%psnsun_to_cpool(p)   = c13_veg_cf%psnsun_to_cpool(p)  *(1._r8 - downreg(p))
-                        c13_veg_cf%psnshade_to_cpool(p) = c13_veg_cf%psnshade_to_cpool(p)*(1._r8 - downreg(p))
-                    endif
-
-                    if ( use_c14 ) then
-                        c14_veg_cf%psnsun_to_cpool(p)   = c14_veg_cf%psnsun_to_cpool(p)  *(1._r8 - downreg(p))
-                        c14_veg_cf%psnshade_to_cpool(p) = c14_veg_cf%psnshade_to_cpool(p)*(1._r8 - downreg(p))
-                    endif
-                endif
-            end if
+       sum_nh4_demand = col_plant_nh4demand_vr(j) + potential_immob_vr(j) + pot_f_nit_vr(j)
 
-       ! calculate the amount of new leaf C dictated by these allocation
-       ! decisions, and calculate the daily fluxes of C and N to current
-       ! growth and storage pools
-
-       ! fcur is the proportion of this day's growth that is displayed now,
-       ! the remainder going into storage for display next year through the
-       ! transfer pools
-
-       ! recover default coefficient for carbon allocation to leaf,  which is possibly changed due to previous time step allocation adjustment
-       nlc = plant_calloc(p) / c_allometry(p)
-       ! recover allocation fraction,  which is possibly changed due to previous time step allocation adjustment
-       !fcur = fcur2(ivt)
-
-       cpool_to_leafc(p)          = nlc * fcur
-       cpool_to_leafc_storage(p)  = nlc * (1._r8 - fcur)
-       cpool_to_frootc(p)         = nlc * f1 * fcur
-       cpool_to_frootc_storage(p) = nlc * f1 * (1._r8 - fcur)
-       if (woody(ivt) == 1._r8) then
-          cpool_to_livestemc(p)          = nlc * f3 * f4 * fcur
-          cpool_to_livestemc_storage(p)  = nlc * f3 * f4 * (1._r8 - fcur)
-          cpool_to_deadstemc(p)          = nlc * f3 * (1._r8 - f4) * fcur
-          cpool_to_deadstemc_storage(p)  = nlc * f3 * (1._r8 - f4) * (1._r8 - fcur)
-          cpool_to_livecrootc(p)         = nlc * f2 * f3 * f4 * fcur
-          cpool_to_livecrootc_storage(p) = nlc * f2 * f3 * f4 * (1._r8 - fcur)
-          cpool_to_deadcrootc(p)         = nlc * f2 * f3 * (1._r8 - f4) * fcur
-          cpool_to_deadcrootc_storage(p) = nlc * f2 * f3 * (1._r8 - f4) * (1._r8 - fcur)
-       end if
-       if (ivt >= npcropmin) then ! skip 2 generic crops
-          cpool_to_livestemc(p)          = nlc * f3 * f4 * fcur
-          cpool_to_livestemc_storage(p)  = nlc * f3 * f4 * (1._r8 - fcur)
-          cpool_to_deadstemc(p)          = nlc * f3 * (1._r8 - f4) * fcur
-          cpool_to_deadstemc_storage(p)  = nlc * f3 * (1._r8 - f4) * (1._r8 - fcur)
-          cpool_to_livecrootc(p)         = nlc * f2 * f3 * f4 * fcur
-          cpool_to_livecrootc_storage(p) = nlc * f2 * f3 * f4 * (1._r8 - fcur)
-          cpool_to_deadcrootc(p)         = nlc * f2 * f3 * (1._r8 - f4) * fcur
-          cpool_to_deadcrootc_storage(p) = nlc * f2 * f3 * (1._r8 - f4) * (1._r8 - fcur)
-          cpool_to_grainc(p)             = nlc * f5 * fcur
-          cpool_to_grainc_storage(p)     = nlc * f5 * (1._r8 -fcur)
-       end if
+       if (nu_com .eq. 'ECA') then
+
+          sum_nh4_demand_scaled = col_plant_nh4demand_vr(j) + &
+               potential_immob_vr(j)*compet_decomp + &
+               pot_f_nit_vr(j)*compet_nit
+
+       else ! 'MIC' mode
+
+          sum_nh4_demand_scaled = potential_immob_vr(j)*compet_decomp + & 
+               pot_f_nit_vr(j)*compet_nit
 
-       ! corresponding N fluxes
-       ! recover default coefficient for carbon allocation to leaf,  which is possibly changed due to previous time step allocation adjustment
-       !nlc = plant_calloc(p) / c_allometry(p)
-       ! recover allocation fraction,  which is possibly changed due to previous time step allocation adjustment
-       !fcur = fcur2(ivt)
-
-       npool_to_leafn(p)          = (nlc / cnl) * fcur
-       npool_to_leafn_storage(p)  = (nlc / cnl) * (1._r8 - fcur)
-       npool_to_frootn(p)         = (nlc * f1 / cnfr) * fcur
-       npool_to_frootn_storage(p) = (nlc * f1 / cnfr) * (1._r8 - fcur)
-       if (woody(ivt) == 1._r8) then
-          npool_to_livestemn(p)          = (nlc * f3 * f4 / cnlw) * fcur
-          npool_to_livestemn_storage(p)  = (nlc * f3 * f4 / cnlw) * (1._r8 - fcur)
-          npool_to_deadstemn(p)          = (nlc * f3 * (1._r8 - f4) / cndw) * fcur
-          npool_to_deadstemn_storage(p)  = (nlc * f3 * (1._r8 - f4) / cndw) * (1._r8 - fcur)
-          npool_to_livecrootn(p)         = (nlc * f2 * f3 * f4 / cnlw) * fcur
-          npool_to_livecrootn_storage(p) = (nlc * f2 * f3 * f4 / cnlw) * (1._r8 - fcur)
-          npool_to_deadcrootn(p)         = (nlc * f2 * f3 * (1._r8 - f4) / cndw) * fcur
-          npool_to_deadcrootn_storage(p) = (nlc * f2 * f3 * (1._r8 - f4) / cndw) * (1._r8 - fcur)
        end if
-       if (ivt >= npcropmin) then ! skip 2 generic crops
-          cng = graincn(ivt)
-          npool_to_livestemn(p)          = (nlc * f3 * f4 / cnlw) * fcur
-          npool_to_livestemn_storage(p)  = (nlc * f3 * f4 / cnlw) * (1._r8 - fcur)
-          npool_to_deadstemn(p)          = (nlc * f3 * (1._r8 - f4) / cndw) * fcur
-          npool_to_deadstemn_storage(p)  = (nlc * f3 * (1._r8 - f4) / cndw) * (1._r8 - fcur)
-          npool_to_livecrootn(p)         = (nlc * f2 * f3 * f4 / cnlw) * fcur
-          npool_to_livecrootn_storage(p) = (nlc * f2 * f3 * f4 / cnlw) * (1._r8 - fcur)
-          npool_to_deadcrootn(p)         = (nlc * f2 * f3 * (1._r8 - f4) / cndw) * fcur
-          npool_to_deadcrootn_storage(p) = (nlc * f2 * f3 * (1._r8 - f4) / cndw) * (1._r8 - fcur)
-          npool_to_grainn(p)             = (nlc * f5 / cng) * fcur
-          npool_to_grainn_storage(p)     = (nlc * f5 / cng) * (1._r8 -fcur)
+
+       if (sum_nh4_demand*dt < smin_nh4_vr(j)) then
+
+          ! NH4 availability is not limiting immobilization or plant
+          ! uptake, and all can proceed at their potential rates
+          fpi_nh4_vr(j) = 1.0_r8
+          actual_immob_nh4_vr(j) = potential_immob_vr(j)
+          smin_nh4_to_plant_vr(j) = col_plant_nh4demand_vr(j)
+          f_nit_vr(j) = pot_f_nit_vr(j)
+
+       else
+
+          ! NH4 availability can not satisfy the sum of immobilization, nitrification, and
+          ! plant growth demands, so these three demands compete for available
+          ! soil mineral NH4 resource.
+          if (sum_nh4_demand > 0.0_r8 .and. smin_nh4_vr(j) > 0.0_r8  &
+               .and. sum_nh4_demand_scaled > 0.0_r8) then
+             actual_immob_nh4_vr(j) = min((smin_nh4_vr(j)/dt)*(potential_immob_vr(j)* &
+                  compet_decomp / sum_nh4_demand_scaled), potential_immob_vr(j))
+
+             if (nu_com .eq. 'ECA') smin_nh4_to_plant_vr(j) = min((smin_nh4_vr(j)/dt)*(col_plant_nh4demand_vr(j)/ &
+                  sum_nh4_demand_scaled), col_plant_nh4demand_vr(j))
+
+             f_nit_vr(j) =  min((smin_nh4_vr(j)/dt)*(pot_f_nit_vr(j)*compet_nit / &
+                  sum_nh4_demand_scaled), pot_f_nit_vr(j))
+
+          else
+             actual_immob_nh4_vr(j) = 0.0_r8
+             smin_nh4_to_plant_vr(j) = 0.0_r8
+             f_nit_vr(j) = 0.0_r8
+
+          end if
+
+          if (potential_immob_vr(j) > 0.0_r8) then
+             fpi_nh4_vr(j) = actual_immob_nh4_vr(j) / potential_immob_vr(j)
+          else
+             fpi_nh4_vr(j) = 1.0_r8
+          end if
+
+          if (nu_com .eq. 'MIC') smin_nh4_to_plant_vr(j) = min( max( 0._r8, &
+               (smin_nh4_vr(j)/dt) - actual_immob_nh4_vr(j) - f_nit_vr(j) ) ,col_plant_nh4demand_vr(j) )
+
        end if
 
-       ! corresponding P fluxes
-       ! recover default coefficient for carbon allocation to leaf,  which is possibly changed due to previous time step allocation adjustment
-       !nlc = plant_calloc(p) / c_allometry(p)
-       ! recover allocation fraction,  which is possibly changed due to previous time step allocation adjustment
-       !fcur = fcur2(ivt)
-       ppool_to_leafp(p)          = (nlc / cpl) * fcur
-       ppool_to_leafp_storage(p)  = (nlc / cpl) * (1._r8 - fcur)
-       ppool_to_frootp(p)         = (nlc * f1 / cpfr) * fcur
-       ppool_to_frootp_storage(p) = (nlc * f1 / cpfr) * (1._r8 - fcur)
-       if (woody(ivt) == 1._r8) then
-          ppool_to_livestemp(p)          = (nlc * f3 * f4 / cplw) * fcur
-          ppool_to_livestemp_storage(p)  = (nlc * f3 * f4 / cplw) * (1._r8 -fcur)
-          ppool_to_deadstemp(p)          = (nlc * f3 * (1._r8 - f4) / cpdw) *fcur
-          ppool_to_deadstemp_storage(p)  = (nlc * f3 * (1._r8 - f4) / cpdw) *(1._r8 - fcur)
-          ppool_to_livecrootp(p)         = (nlc * f2 * f3 * f4 / cplw) * fcur
-          ppool_to_livecrootp_storage(p) = (nlc * f2 * f3 * f4 / cplw) * (1._r8 -fcur)
-          ppool_to_deadcrootp(p)         = (nlc * f2 * f3 * (1._r8 - f4) / cpdw)* fcur
-          ppool_to_deadcrootp_storage(p) = (nlc * f2 * f3 * (1._r8 - f4) / cpdw)* (1._r8 - fcur)
+       ! ---------------------------------------------------------------------------------
+       ! (2) plants, microbial decomposers and denitrifiers, compete for NO3
+       ! loop over each pft within the same column
+       ! calculate competition coefficients for NO3
+       ! first need to convert concentration to per soil water based
+       ! ---------------------------------------------------------------------------------
+
+       solution_conc = smin_no3_vr(j) / h2osoi_vol(j) ! convert to per soil water based
+
+       e_km = 0._r8
+       do i = 1, n_pcomp
+          ip = filter_pcomp(i)
+          ft = ft_index(ip)
+          e_km = e_km + e_plant_scalar*veg_rootc(ip,j)/km_no3_plant(ft)
+       end do
+       ! Note we do NOT need to re-compute decompmicc_layer (aready calculated)
+       e_km = e_km + e_decomp_scalar*decompmicc(j)*(1._r8/km_decomp_no3 + 1._r8/km_den)
+
+       do i = 1, n_pcomp
+          ip = filter_pcomp(i)
+          ft = ft_index(ip)
+          compet_plant(i) = solution_conc / & 
+               ( km_no3_plant(ft) * (1._r8 + solution_conc/km_no3_plant(ft) + e_km))
+       end do
+       
+       compet_decomp = solution_conc / (km_decomp_no3 * (1._r8 + solution_conc/km_decomp_no3 + e_km))
+       compet_denit = solution_conc / (km_den * (1._r8 + solution_conc/km_den + e_km))
+
+       ! relative demand approach: root nutrient uptake profile is based on nutrient concentration profile
+       ! nu_com with ECA or MIC: root nutrient uptake profile is based on fine root density profile
+
+
+       col_plant_no3demand_vr(j) = 0._r8
+       do i = 1, n_pcomp
+          ip = filter_pcomp(i)
+          ft = ft_index(ip)
+
+          ! This is the demand per m3 of the column (not patch) 
+          ! (for native ELM divide through by the patch weight to get per m3 of patch)
+          plant_no3demand_vr(ip,j) = max(0._r8,vmax_no3_plant(ft) * veg_rootc(ip,j) * &
+               cn_scalar_runmean(ip) * t_scalar(j) *  compet_plant(i))
+
+          ! This is the total demand across all plant competitors  (weighted in native, because
+          ! demand is per m2 of patch
+          col_plant_no3demand_vr(j) = col_plant_no3demand_vr(j) + plant_no3demand_vr(ip,j)
+
+       end do
+
+       ! next compete for no3
+       sum_no3_demand = col_plant_no3demand_vr(j) + &
+            (potential_immob_vr(j)-actual_immob_nh4_vr(j)) + pot_f_denit_vr(j)
+       if (nu_com .eq. 'ECA') then
+          sum_no3_demand_scaled = col_plant_no3demand_vr(j) + &
+               (potential_immob_vr(j)-actual_immob_nh4_vr(j))*compet_decomp + pot_f_denit_vr(j)*compet_denit
+       else ! 'MIC' mode
+          sum_no3_demand_scaled = (potential_immob_vr(j)-actual_immob_nh4_vr(j)) * &
+               compet_decomp + pot_f_denit_vr(j)*compet_denit
        end if
-       if (ivt >= npcropmin) then ! skip 2 generic crops
-          cpg = graincp(ivt)
-          ppool_to_livestemp(p)          = (nlc * f3 * f4 / cplw) * fcur
-          ppool_to_livestemp_storage(p)  = (nlc * f3 * f4 / cplw) * (1._r8 -fcur)
-          ppool_to_deadstemp(p)          = (nlc * f3 * (1._r8 - f4) / cpdw) * fcur
-          ppool_to_deadstemp_storage(p)  = (nlc * f3 * (1._r8 - f4) / cpdw) *(1._r8 - fcur)
-          ppool_to_livecrootp(p)         = (nlc * f2 * f3 * f4 / cplw) * fcur
-          ppool_to_livecrootp_storage(p) = (nlc * f2 * f3 * f4 / cplw) * (1._r8 -fcur)
-          ppool_to_deadcrootp(p)         = (nlc * f2 * f3 * (1._r8 - f4) / cpdw)* fcur
-          ppool_to_deadcrootp_storage(p) = (nlc * f2 * f3 * (1._r8 - f4) / cpdw)* (1._r8 - fcur)
-          ppool_to_grainp(p)             = (nlc * f5 / cpg) * fcur
-          ppool_to_grainp_storage(p)     = (nlc * f5 / cpg) * (1._r8 -fcur)
+
+       if (sum_no3_demand*dt < smin_no3_vr(j)) then
+          ! NO3 availability is not limiting immobilization or plant
+          ! uptake, and all can proceed at their potential rates
+          fpi_no3_vr(j) = 1.0_r8 -  fpi_nh4_vr(j)
+          actual_immob_no3_vr(j) = (potential_immob_vr(j)-actual_immob_nh4_vr(j))
+          smin_no3_to_plant_vr(j) = col_plant_no3demand_vr(j)
+          f_denit_vr(j) = pot_f_denit_vr(j)
+
+       else 
+
+          ! NO3 availability can not satisfy the sum of immobilization, denitrification, and
+          ! plant growth demands, so these three demands compete for available
+          ! soil mineral NO3 resource.
+          if (sum_no3_demand > 0.0_r8 .and. smin_no3_vr(j) > 0.0_r8 &
+               .and. sum_no3_demand_scaled > 0.0_r8) then
+             actual_immob_no3_vr(j) = min((smin_no3_vr(j)/dt)*((potential_immob_vr(j)- &
+                  actual_immob_nh4_vr(j))*compet_decomp / sum_no3_demand_scaled), &
+                  potential_immob_vr(j)-actual_immob_nh4_vr(j))
+             if (nu_com .eq. 'ECA') smin_no3_to_plant_vr(j) = min((smin_no3_vr(j)/dt)* &
+                  (col_plant_no3demand_vr(j)/ sum_no3_demand_scaled), col_plant_no3demand_vr(j))
+             f_denit_vr(j) =  min((smin_no3_vr(j)/dt)*(pot_f_denit_vr(j)*compet_denit / &
+                  sum_no3_demand_scaled), pot_f_denit_vr(j))
+          else
+             actual_immob_no3_vr(j) = 0.0_r8
+             smin_no3_to_plant_vr(j) = 0.0_r8
+             f_denit_vr(j) = 0.0_r8
+          end if
+
+          if (potential_immob_vr(j) > 0.0_r8) then
+             fpi_no3_vr(j) = actual_immob_no3_vr(j) / potential_immob_vr(j)
+          else
+             fpi_no3_vr(j) = 0.0_r8
+          end if
+
+          if (nu_com .eq. 'MIC') smin_no3_to_plant_vr(j) = min( max( 0._r8, &
+               (smin_no3_vr(j)/dt) - actual_immob_no3_vr(j) - f_denit_vr(j) ), col_plant_no3demand_vr(j))
        end if
 
-       ! Calculate the amount of carbon that needs to go into growth
-       ! respiration storage to satisfy all of the storage growth demands.
-       ! Allows for the fraction of growth respiration that is released at the
-       ! time of fixation, versus the remaining fraction that is stored for
-       ! release at the time of display. Note that all the growth respiration
-       ! fluxes that get released on a given timestep are calculated in growth_resp(),
-       ! but that the storage of C for growth resp during display of transferred
-       ! growth is assigned here.
-
-       gresp_storage = cpool_to_leafc_storage(p) + cpool_to_frootc_storage(p)
-       if (woody(ivt) == 1._r8) then
-          gresp_storage = gresp_storage + cpool_to_livestemc_storage(p)
-          gresp_storage = gresp_storage + cpool_to_deadstemc_storage(p)
-          gresp_storage = gresp_storage + cpool_to_livecrootc_storage(p)
-          gresp_storage = gresp_storage + cpool_to_deadcrootc_storage(p)
+    end do
+
+    return
+  end subroutine NAllocationECAMIC
+
+  ! ======================================================================================
+
+  subroutine PAllocationECAMIC(pci, &
+       dt, &
+       h2osoi_vol, & 
+       t_scalar, & 
+       gross_pmin_vr, & 
+       potential_immob_p_vr, & 
+       biochem_pmin_vr_col, & 
+       primp_to_labilep_vr_col, & 
+       pdep_to_sminp, & 
+       pdep_prof, & 
+       vmax_minsurf_p_vr, &
+       km_minsurf_p_vr, &
+       solutionp_vr, &
+       nu_com,  &
+       n_pcomp, &
+       filter_pcomp, & 
+       veg_rootc, & 
+       ft_index, &
+       decompmicc, &
+       cp_scalar_runmean,  & 
+       km_plant_p, &
+       vmax_plant_p, &
+       km_decomp_p,  & 
+       labilep_vr, &
+       plant_pdemand_vr_patch, & 
+       col_plant_pdemand_vr, & 
+       adsorb_to_labilep_vr, &
+       fpi_p_vr, &
+       actual_immob_p_vr, &
+       sminp_to_plant_vr, & 
+       desorb_to_solutionp_vr,  &
+       supplement_to_sminp_vr)
+
+    use elm_varpar , only : nlevdecomp
+    use elm_varctl , only : carbon_only          !
+    use elm_varctl , only : carbonnitrogen_only  !
+
+    integer,  intent(in) :: pci     ! initial and final index of plant competitors
+    real(r8), intent(in) :: dt      ! integration timestep length (s)
+    real(r8), intent(in) :: h2osoi_vol(:)
+    real(r8), intent(in) :: t_scalar(:)
+    real(r8), intent(in) :: gross_pmin_vr(:)
+    real(r8), intent(in) :: potential_immob_p_vr(:)
+    real(r8), intent(in) :: biochem_pmin_vr_col(:)
+    real(r8), intent(in) :: primp_to_labilep_vr_col(:)
+    real(r8), intent(in) :: pdep_to_sminp
+    real(r8), intent(in) :: pdep_prof(:)
+    real(r8), intent(in) :: vmax_minsurf_p_vr(:)
+    real(r8), intent(in) :: km_minsurf_p_vr(:)
+    real(r8), intent(in) :: solutionp_vr(:)
+    character(len=*), intent(in) :: nu_com
+    integer,  intent(in) :: n_pcomp
+    integer,  intent(in) :: filter_pcomp(:)
+    real(r8), intent(in) :: veg_rootc(pci:,:)
+    integer, intent(in)  :: ft_index(pci:)
+    real(r8), intent(in) :: decompmicc(:)
+    real(r8), intent(in) :: cp_scalar_runmean(pci:)
+    real(r8), intent(in) :: km_plant_p(:)
+    real(r8), intent(in) :: vmax_plant_p(:)
+    real(r8), intent(in) :: km_decomp_p
+    real(r8), intent(in) :: labilep_vr(:)
+
+    real(r8), intent(inout) :: plant_pdemand_vr_patch(pci:,:)
+    real(r8), intent(inout) :: col_plant_pdemand_vr(:)
+    real(r8), intent(inout) :: adsorb_to_labilep_vr(:)
+
+    real(r8), intent(inout) :: fpi_p_vr(:)
+    real(r8), intent(inout) :: actual_immob_p_vr(:)
+    real(r8), intent(inout) :: sminp_to_plant_vr(:)
+    real(r8), intent(inout) :: desorb_to_solutionp_vr(:)
+    real(r8), intent(inout) :: supplement_to_sminp_vr(:)
+
+    ! Locals
+    integer :: i,ip
+    integer :: j
+    integer :: ft
+    real(r8) :: compet_plant(n_pcomp)
+    real(r8) :: sum_pdemand
+    real(r8) :: sum_pdemand_scaled
+    real(r8) :: solution_pconc          ! concentration of P in soil water
+    real(r8) :: e_km_P
+    real(r8) :: compet_decomp_p         ! (unitless) relative competitiveness of immobilizer for P
+    real(r8) :: compet_minsurf_p        ! (unitless) relative competitiveness of mineral surface for P
+    real(r8) :: dsolutionp_dt           ! dsolutionp_dt
+
+    ! ECA and MIC mode assume mineral surface adsorption flux is a potential competitor of solution P
+    ! assume solutionP - labileP not equilibrate within 30 min, due to instantaneous
+    ! plant P uptake, microbial P uptake/release
+    ! secondary P desorption is assumed to go into solution P pool
+
+    do j = 1, nlevdecomp  
+
+       ! plant, microbial decomposer, mineral surface compete for P
+       ! loop over each pft within the same column
+       ! calculate competition coefficients for N/P
+       solution_pconc  = max(0._r8,solutionp_vr(j)/h2osoi_vol(j)) ! convert to per soil water based
+
+       e_km_p = 0._r8
+       do i = 1,n_pcomp
+          ip = filter_pcomp(i)
+          ft = ft_index(ip)
+          e_km_p = e_km_p + e_plant_scalar*veg_rootc(ip,j)/km_plant_p(ft)
+       end do
+
+       e_km_p = e_km_p + e_decomp_scalar*decompmicc(j)/km_decomp_p + &
+            max(0._r8,vmax_minsurf_p_vr(j)-labilep_vr(j))/km_minsurf_p_vr(j)
+
+!       if(carbon_only .or. carbonnitrogen_only) then
+!          do i = 1, n_pcomp
+!             compet_plant(i) = 1._r8
+!          end do
+!       else
+          do i = 1,n_pcomp
+             ip = filter_pcomp(i)
+             ft = ft_index(ip)
+             compet_plant(i) = solution_pconc / & 
+                  (km_plant_p(ft)*(1._r8 + solution_pconc/km_plant_p(ft) + e_km_p))
+          end do
+!       end if
+       
+       compet_decomp_p = solution_pconc / &
+            (km_decomp_p * (1._r8 + solution_pconc/km_decomp_p + e_km_p))
+
+       compet_minsurf_p = solution_pconc/ & 
+            (km_minsurf_p_vr(j) * (1._r8 + solution_pconc/km_minsurf_p_vr(j) + e_km_p))
+
+       col_plant_pdemand_vr(j) = 0._r8
+       do i = 1,n_pcomp
+          ip = filter_pcomp(i)
+          ft = ft_index(ip)
+          plant_pdemand_vr_patch(ip,j) = max(0._r8,vmax_plant_p(ft) * veg_rootc(ip,j) * & 
+               cp_scalar_runmean(ip) * t_scalar(j) * compet_plant(i))
+          col_plant_pdemand_vr(j) = col_plant_pdemand_vr(j) + plant_pdemand_vr_patch(ip,j)
+       end do
+
+       ! potential adsorption rate without plant and microbial interaction
+       ! including weathering, deposition, phosphatase, mineralization, 
+       ! immobilization, plant uptake
+       dsolutionp_dt  = gross_pmin_vr(j) -potential_immob_p_vr(j) - &
+            col_plant_pdemand_vr(j) + biochem_pmin_vr_col(j) + &
+            primp_to_labilep_vr_col(j) + pdep_to_sminp *pdep_prof(j)
+
+       adsorb_to_labilep_vr(j) = (vmax_minsurf_p_vr(j)* km_minsurf_p_vr(j)) / &
+            ((km_minsurf_p_vr(j)+max(solutionp_vr(j),0._r8))**2._r8 ) * dsolutionp_dt
+
+       ! sign convention: if adsorb_to_labilep_vr(j) < 0, then it's desorption
+       if (adsorb_to_labilep_vr(j) >= 0) then
+          adsorb_to_labilep_vr(j) = max(min(adsorb_to_labilep_vr(j), &
+               (vmax_minsurf_p_vr(j) - labilep_vr(j))/dt),0.0_r8)
+          desorb_to_solutionp_vr(j) = 0.0_r8
+       else
+          desorb_to_solutionp_vr(j) = min(-1.0*adsorb_to_labilep_vr(j), labilep_vr(j)/dt)
+          adsorb_to_labilep_vr(j) = 0.0_r8
        end if
-       if (ivt >= npcropmin) then ! skip 2 generic crops
-          gresp_storage = gresp_storage + cpool_to_livestemc_storage(p)
-          gresp_storage = gresp_storage + cpool_to_grainc_storage(p)
+
+
+       ! compete for phosphorus
+       sum_pdemand  = col_plant_pdemand_vr(j) + potential_immob_p_vr(j) + adsorb_to_labilep_vr(j)
+       if (nu_com .eq. 'ECA') then ! ECA mode
+          sum_pdemand_scaled  = col_plant_pdemand_vr(j) + potential_immob_p_vr(j)*compet_decomp_p + &
+               adsorb_to_labilep_vr(j)*compet_minsurf_p
+       else ! 'MIC' mode
+          sum_pdemand_scaled = potential_immob_p_vr(j)*compet_decomp_p + &
+               adsorb_to_labilep_vr(j)*compet_minsurf_p
        end if
-       cpool_to_gresp_storage(p) = gresp_storage * g1 * (1._r8 - g2)
 
-       ! ECA root NP uptake is based on kinetics, plant CNP stoichiometry can vary even
-       ! when certain element is set to not limiting (e.g., P not limiting under CN mode)
-       ! additional supplement N/P come from first soil layer
-       ! must ensure plant get enough N or P or both to maintain its stoichiometry:
-       ! (1) maintain plant PC stoichiometry at optimal ratio under CN mode
-       ! (2) maintain plant NC stoichiometry at optimal ratio under CP mode
-       ! (3) maintain plant PC/NC stoichiometry at optimal ratios under C mode
-      end do 
+       if (sum_pdemand*dt < solutionp_vr(j)) then
+          ! P availability is not limiting immobilization or plant
+          ! uptake, and both can proceed at their potential rates
+          fpi_p_vr(j) = 1.0_r8
+          actual_immob_p_vr(j) = potential_immob_p_vr(j)
+          sminp_to_plant_vr(j) = col_plant_pdemand_vr(j)
+          adsorb_to_labilep_vr(j) = adsorb_to_labilep_vr(j)
+       elseif ( carbon_only .or. carbonnitrogen_only ) then !.or. &
+          fpi_p_vr(j) = 1.0_r8
+          actual_immob_p_vr(j) = potential_immob_p_vr(j)
+          sminp_to_plant_vr(j) =  col_plant_pdemand_vr(j)
+          adsorb_to_labilep_vr(j) = adsorb_to_labilep_vr(j)
+          supplement_to_sminp_vr(j) = sum_pdemand - solutionp_vr(j)/dt
+       else
+          ! P availability can not satisfy the sum of immobilization and
+          ! plant growth demands, so these two demands compete for
+          ! available soil mineral solution P resource.
+          if (sum_pdemand > 0.0_r8 .and. solutionp_vr(j) >0._r8 .and. sum_pdemand_scaled > 0.0) then
+             if (nu_com .eq. 'ECA') sminp_to_plant_vr(j) = min(solutionp_vr(j)/dt * &
+                  col_plant_pdemand_vr(j)/ sum_pdemand_scaled,col_plant_pdemand_vr(j))
+             actual_immob_p_vr(j) = min(solutionp_vr(j)/dt * potential_immob_p_vr(j) * compet_decomp_p /&
+                  sum_pdemand_scaled, potential_immob_p_vr(j))
+             adsorb_to_labilep_vr(j) = min(solutionp_vr(j)/dt * adsorb_to_labilep_vr(j) * compet_minsurf_p /&
+                  sum_pdemand_scaled, adsorb_to_labilep_vr(j))
+          else
+             sminp_to_plant_vr(j) = 0.0_r8
+             actual_immob_p_vr(j) = 0.0_r8
+             adsorb_to_labilep_vr(j) = 0.0_r8
+          end if
+          if (potential_immob_p_vr(j) > 0.0_r8) then
+             fpi_p_vr(j) = actual_immob_p_vr(j) / potential_immob_p_vr(j)
+          else
+             fpi_p_vr(j) = 1.0_r8
+          end if
 
-     end associate
-  end subroutine DistributeN_RD
+          if (nu_com .eq. 'MIC') sminp_to_plant_vr(j) = min(max( 0._r8, &
+               (solutionp_vr(j)/dt) - actual_immob_p_vr(j) - adsorb_to_labilep_vr(j) ), &
+               col_plant_pdemand_vr(j)) 
+       end if
+
+    end do
+    return
+  end subroutine PAllocationECAMIC
 
   ! ======================================================================================
 
-  subroutine NAllocationRD( num_soilc, filter_soilc, &
-       col_plant_ndemand_vr,   &! IN (j)
+  subroutine NAllocationRD(col_plant_ndemand_vr,   &! IN (j)
        potential_immob_vr,  &    ! IN (j)
-       compet_plants_nh4,   &    ! IN
+       compet_plants_nh4,   &    ! IN 
        compet_decomp_nh4,   &    ! IN
        dt,                  &    ! IN
        smin_nh4_vr,         &    ! IN (j)
@@ -1939,360 +3444,331 @@ contains
 
     use elm_varpar, only : nlevdecomp
     ! Arguments
-    integer , intent(in)  :: num_soilc 
-    integer , intent(in)  :: filter_soilc(:) 
-    real(r8), intent(in)  :: col_plant_ndemand_vr(:,:)    ! How much N all plants demand as group [g/m3]
-    real(r8), intent(in)  :: potential_immob_vr(:,:)      ! potential N immobilization [g/m3/s]
+    real(r8), intent(in)  :: col_plant_ndemand_vr(:) ! How much N all plants demand as group [g/m3]
+    real(r8), intent(in)  :: potential_immob_vr(:)   ! potential N immobilization [g/m3/s]
     real(r8), intent(in)  :: compet_plants_nh4       ! relative competability of plants (unitless)
     real(r8), intent(in)  :: compet_decomp_nh4       ! relative competability of decomposers (unitless)
     real(r8), intent(in)  :: dt                      ! timestep [seconds]
-    real(r8), intent(in)  :: smin_nh4_vr(:,:)             ! mineralized nh4 [g/m3]
-    real(r8), intent(inout) :: fpi_nh4_vr (:,:)             ! fraction of potential immobilization supplied by nh4 (no units)
-    real(r8), intent(inout) :: actual_immob_nh4_vr(:,:)     ! actual nh4 immobilization [g/m3/s]
-    real(r8), intent(inout) :: smin_nh4_to_plant_vr(:,:)    ! nh4 flux to plant competitors [g/m3/s]
+    real(r8), intent(in)  :: smin_nh4_vr(:)          ! mineralized nh4 [g/m3]
+    real(r8), intent(inout) :: fpi_nh4_vr(:)           ! fraction of potential immobilization supplied by nh4 (no units)
+    real(r8), intent(inout) :: actual_immob_nh4_vr(:)  ! actual nh4 immobilization [g/m3/s]
+    real(r8), intent(inout) :: smin_nh4_to_plant_vr(:) ! nh4 flux to plant competitors [g/m3/s]
 
     ! Optional (for NO3)
-    real(r8), intent(in)  :: smin_no3_vr(:,:)             ! mineralized no3 [g/m3]
+    real(r8), intent(in)  :: smin_no3_vr(:)          ! mineralized no3 [g/m3]
     real(r8), intent(in)  :: compet_plants_no3       ! relative competability of plants (unitless)
     real(r8), intent(in)  :: compet_decomp_no3       ! relative competability of decomposers (unitless)
     real(r8), intent(in)  :: compet_nit              ! relative competitiveness of nitrifiers for NH4
     real(r8), intent(in)  :: compet_denit            ! relative competitiveness of denitrifiers for NO3
-    real(r8), intent(in)  :: pot_f_nit_vr(:,:)            ! potential soil nitrification flux [g/m3/s]
-    real(r8), intent(in)  :: pot_f_denit_vr(:,:)          ! potential soil denitrification flux [g/m3/s]
-    real(r8), intent(inout) :: fpi_no3_vr(:,:)            ! fraction of potential immobilization supplied by NO3
-    real(r8), intent(inout) :: actual_immob_no3_vr(:,:)   ! actual no3 immobilization [g/m3/s]
-    real(r8), intent(inout) :: smin_no3_to_plant_vr(:,:)  ! no3 flux to plant competitors [g/m3/s]
-    real(r8), intent(inout) :: f_nit_vr(:,:)              ! soil nitrification flux [g/m3/s]
-    real(r8), intent(inout) :: f_denit_vr(:,:)            ! soil denitrification flux [g/m3/s]
+    real(r8), intent(in)  :: pot_f_nit_vr(:)         ! potential soil nitrification flux [g/m3/s]
+    real(r8), intent(in)  :: pot_f_denit_vr(:)       ! potential soil denitrification flux [g/m3/s]
+    real(r8), intent(inout) :: fpi_no3_vr(:)           ! fraction of potential immobilization supplied by NO3
+    real(r8), intent(inout) :: actual_immob_no3_vr(:)  ! actual no3 immobilization [g/m3/s]
+    real(r8), intent(inout) :: smin_no3_to_plant_vr(:) ! no3 flux to plant competitors [g/m3/s]
+    real(r8), intent(inout) :: f_nit_vr(:)             ! soil nitrification flux [g/m3/s]
+    real(r8), intent(inout) :: f_denit_vr(:)           ! soil denitrification flux [g/m3/s]
 
     ! Locals
     real(r8) :: sum_nh4_demand        ! Total nh4 demand over all competitors
     real(r8) :: sum_nh4_demand_scaled ! Total nh4 demand, but scaled by competitivness
     real(r8) :: sum_no3_demand        ! "" no3
     real(r8) :: sum_no3_demand_scaled ! "" no3
-    integer  :: j,fc,c                ! soil decomp layer loop
+    integer  :: j                     ! soil decomp layer loop
+
 
-    !$acc parallel loop independent gang vector default(present) collapse(2) 
     do j = 1, nlevdecomp
-       do fc=1,num_soilc !col_loop
-         c = filter_soilc(fc)
 
-         sum_nh4_demand        = col_plant_ndemand_vr(c,j) + potential_immob_vr(c,j) + pot_f_nit_vr(c,j)
-         sum_nh4_demand_scaled = col_plant_ndemand_vr(c,j) * compet_plants_nh4 + &
-                                     potential_immob_vr(c,j)*compet_decomp_nh4 + pot_f_nit_vr(c,j)*compet_nit
+       sum_nh4_demand        = col_plant_ndemand_vr(j) + potential_immob_vr(j) + pot_f_nit_vr(j)
+       sum_nh4_demand_scaled = col_plant_ndemand_vr(j) * compet_plants_nh4 + &
+            potential_immob_vr(j)*compet_decomp_nh4 + pot_f_nit_vr(j)*compet_nit
 
-         if (sum_nh4_demand*dt < smin_nh4_vr(c,j)) then
-             ! NH4 availability is not limiting immobilization or plant
-             ! uptake, and all can proceed at their potential rates
-             fpi_nh4_vr(fc,j) = 1.0_r8
-             actual_immob_nh4_vr(c,j) = potential_immob_vr(c,j)
-             smin_nh4_to_plant_vr(c,j) = col_plant_ndemand_vr(c,j)
-             f_nit_vr(c,j) = pot_f_nit_vr(c,j)
+       if (sum_nh4_demand*dt < smin_nh4_vr(j)) then
+          ! NH4 availability is not limiting immobilization or plant
+          ! uptake, and all can proceed at their potential rates
+          fpi_nh4_vr(j) = 1.0_r8
+          actual_immob_nh4_vr(j) = potential_immob_vr(j)
+          smin_nh4_to_plant_vr(j) = col_plant_ndemand_vr(j)
+          f_nit_vr(j) = pot_f_nit_vr(j)
 
-         else
+       else
 
-            ! NH4 availability can not satisfy the sum of immobilization, nitrification, and
-            ! plant growth demands, so these three demands compete for available
-            ! soil mineral NH4 resource.
-            if (sum_nh4_demand > 0.0_r8 .and. smin_nh4_vr(c,j) > 0.0_r8 &
-                 .and. sum_nh4_demand_scaled > 0.0_r8) then
-               actual_immob_nh4_vr(c,j) = min((smin_nh4_vr(c,j)/dt)*(potential_immob_vr(c,j)* &
-                    compet_decomp_nh4 / sum_nh4_demand_scaled), potential_immob_vr(c,j))
-               smin_nh4_to_plant_vr(c,j) = min((smin_nh4_vr(c,j)/dt)*&
-                    (col_plant_ndemand_vr(c,j)*compet_plants_nh4 / sum_nh4_demand_scaled), &
-                    col_plant_ndemand_vr(c,j))
-               f_nit_vr(c,j) =  min((smin_nh4_vr(c,j)/dt)*(pot_f_nit_vr(c,j)*compet_nit / &
-                    sum_nh4_demand_scaled), pot_f_nit_vr(c,j))
-            else
-               actual_immob_nh4_vr(c,j) = 0.0_r8
-               smin_nh4_to_plant_vr(c,j) = 0.0_r8
-               f_nit_vr(c,j) = 0.0_r8
-            end if
+          ! NH4 availability can not satisfy the sum of immobilization, nitrification, and
+          ! plant growth demands, so these three demands compete for available
+          ! soil mineral NH4 resource.
+          if (sum_nh4_demand > 0.0_r8 .and. smin_nh4_vr(j) > 0.0_r8 &
+               .and. sum_nh4_demand_scaled > 0.0_r8) then
+             actual_immob_nh4_vr(j) = min((smin_nh4_vr(j)/dt)*(potential_immob_vr(j)* &
+                  compet_decomp_nh4 / sum_nh4_demand_scaled), potential_immob_vr(j))
+             smin_nh4_to_plant_vr(j) = min((smin_nh4_vr(j)/dt)*&
+                  (col_plant_ndemand_vr(j)*compet_plants_nh4 / sum_nh4_demand_scaled), &
+                  col_plant_ndemand_vr(j))
+             f_nit_vr(j) =  min((smin_nh4_vr(j)/dt)*(pot_f_nit_vr(j)*compet_nit / &
+                  sum_nh4_demand_scaled), pot_f_nit_vr(j))
+          else
+             actual_immob_nh4_vr(j) = 0.0_r8
+             smin_nh4_to_plant_vr(j) = 0.0_r8
+             f_nit_vr(j) = 0.0_r8
+          end if
 
-            if (potential_immob_vr(c,j) > 0.0_r8) then
-               fpi_nh4_vr(fc,j) = actual_immob_nh4_vr(c,j) / potential_immob_vr(c,j)
-            else
-               fpi_nh4_vr(fc,j)= 0.0_r8
-            end if
+          if (potential_immob_vr(j) > 0.0_r8) then
+             fpi_nh4_vr(j) = actual_immob_nh4_vr(j) / potential_immob_vr(j)
+          else
+             fpi_nh4_vr(j) = 0.0_r8
+          end if
+
+       end if    ! if (sum_nh4_demand*dt < smin_nh4_vr(j)) then
 
-         end if    ! if (sum_nh4_demand*dt < smin_nh4_vr) then
-       !
        ! If we passed in parameters and mineralized no3, then
        ! we are free to calculate competitive allocation rates on it
        ! ------------------------------------------------------------------------
-       
+
        ! next compete for no3
-       sum_no3_demand = (col_plant_ndemand_vr(c,j)-smin_nh4_to_plant_vr(c,j)) + &
-            (potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j)) + pot_f_denit_vr(c,j)
+       sum_no3_demand = (col_plant_ndemand_vr(j)-smin_nh4_to_plant_vr(j)) + &
+            (potential_immob_vr(j)-actual_immob_nh4_vr(j)) + pot_f_denit_vr(j)
 
-       sum_no3_demand_scaled = (col_plant_ndemand_vr(c,j)-smin_nh4_to_plant_vr(c,j)) &
-            * compet_plants_no3 + (potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j))*compet_decomp_no3 &
-            + pot_f_denit_vr(c,j)*compet_denit
+       sum_no3_demand_scaled = (col_plant_ndemand_vr(j)-smin_nh4_to_plant_vr(j)) &
+            * compet_plants_no3 + (potential_immob_vr(j)-actual_immob_nh4_vr(j))*compet_decomp_no3 &
+            + pot_f_denit_vr(j)*compet_denit
 
-       if (sum_no3_demand*dt < smin_no3_vr(c,j)) then
+       if (sum_no3_demand*dt < smin_no3_vr(j)) then
 
           ! NO3 availability is not limiting immobilization or plant
           ! uptake, and all can proceed at their potential rates
-          fpi_no3_vr(fc,j) = 1.0_r8 -  fpi_nh4_vr(fc,j)
-          actual_immob_no3_vr(c,j) = (potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j))
-          smin_no3_to_plant_vr(c,j) = (col_plant_ndemand_vr(c,j)-smin_nh4_to_plant_vr(c,j))
-          f_denit_vr(c,j) = pot_f_denit_vr(c,j)
+          fpi_no3_vr(j) = 1.0_r8 -  fpi_nh4_vr(j)
+          actual_immob_no3_vr(j) = (potential_immob_vr(j)-actual_immob_nh4_vr(j))
+          smin_no3_to_plant_vr(j) = (col_plant_ndemand_vr(j)-smin_nh4_to_plant_vr(j))
+          f_denit_vr(j) = pot_f_denit_vr(j)
 
        else
 
           ! NO3 availability can not satisfy the sum of immobilization, denitrification, and
           ! plant growth demands, so these three demands compete for available
           ! soil mineral NO3 resource.
-          if (sum_no3_demand > 0.0_r8 .and. smin_no3_vr(c,j) > 0.0_r8 &
+          if (sum_no3_demand > 0.0_r8 .and. smin_no3_vr(j) > 0.0_r8 &
                .and. sum_no3_demand_scaled > 0.0_r8) then
-             actual_immob_no3_vr(c,j) = min((smin_no3_vr(c,j)/dt)*((potential_immob_vr(c,j)- &
-                  actual_immob_nh4_vr(c,j))*compet_decomp_no3 / sum_no3_demand_scaled), &
-                  potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j))
-             smin_no3_to_plant_vr(c,j) = min((smin_no3_vr(c,j)/dt) * &
-                  ((col_plant_ndemand_vr(c,j)-smin_nh4_to_plant_vr(c,j)) * &
+             actual_immob_no3_vr(j) = min((smin_no3_vr(j)/dt)*((potential_immob_vr(j)- &
+                  actual_immob_nh4_vr(j))*compet_decomp_no3 / sum_no3_demand_scaled), &
+                  potential_immob_vr(j)-actual_immob_nh4_vr(j))
+             smin_no3_to_plant_vr(j) = min((smin_no3_vr(j)/dt) * &
+                  ((col_plant_ndemand_vr(j)-smin_nh4_to_plant_vr(j)) * &
                   compet_plants_no3 / sum_no3_demand_scaled), &
-                  col_plant_ndemand_vr(c,j)-smin_nh4_to_plant_vr(c,j))
-             f_denit_vr(c,j) =  min((smin_no3_vr(c,j)/dt)*(pot_f_denit_vr(c,j)*compet_denit / &
-                  sum_no3_demand_scaled), pot_f_denit_vr(c,j))
+                  col_plant_ndemand_vr(j)-smin_nh4_to_plant_vr(j))
+             f_denit_vr(j) =  min((smin_no3_vr(j)/dt)*(pot_f_denit_vr(j)*compet_denit / &
+                  sum_no3_demand_scaled), pot_f_denit_vr(j))
           else
-             actual_immob_no3_vr(c,j) = 0.0_r8
-             smin_no3_to_plant_vr(c,j) = 0.0_r8
-             f_denit_vr (c,j)= 0.0_r8
+             actual_immob_no3_vr(j) = 0.0_r8
+             smin_no3_to_plant_vr(j) = 0.0_r8
+             f_denit_vr(j) = 0.0_r8
           end if
 
-          if (potential_immob_vr(c,j) > 0.0_r8) then
-             fpi_no3_vr(fc,j) = actual_immob_no3_vr(c,j) / potential_immob_vr(c,j)
+          if (potential_immob_vr(j) > 0.0_r8) then
+             fpi_no3_vr(j) = actual_immob_no3_vr(j) / potential_immob_vr(j)
           else
-             fpi_no3_vr(fc,j) = 0.0_r8
+             fpi_no3_vr(j) = 0.0_r8
           end if
-       end if ! if sum_no3_demand*dt < smin_no3_vr
-     end do    ! j = 1,nlevdecomp
-    end do 
+
+       end if ! if sum_no3_demand*dt < smin_no3_vr(j)
+    end do    ! j = 1,nlevdecomp
+
+    return
   end subroutine NAllocationRD
 
   ! ======================================================================================
 
-  subroutine PAllocationRD( num_soilc, filter_soilc, &
-       col_plant_pdemand_vr, &    ! IN
-       potential_immob_p_vr, &    ! IN 
-       solutionp_vr,         &    ! IN 
+  subroutine PAllocationRD(col_plant_pdemand_vr, &    ! IN 
+       potential_immob_p_vr, &    ! IN (j)
+       solutionp_vr,         &    ! IN (j)
        dt,                   &    ! IN
-       fpi_p_vr,             &    ! OUT 
-       actual_immob_p_vr,    &    ! OUT 
-       sminp_to_plant_vr,    &    ! OUT 
-       supplement_to_sminp_vr)    ! OUT 
+       fpi_p_vr,             &    ! OUT (j)
+       actual_immob_p_vr,    &    ! OUT (j)
+       sminp_to_plant_vr,    &    ! OUT (j)
+       supplement_to_sminp_vr)    ! OUT (j)
 
     use elm_varctl       , only:  carbon_only, carbonnitrogen_only
     use elm_varpar, only : nlevdecomp
 
     ! Arguments
-    integer , intent(in) :: num_soilc
-    integer , intent(in) :: filter_soilc(:)
-    real(r8), intent(in) :: col_plant_pdemand_vr(:,:) ! demand on phos, all plant grouped [g/m3]
-    real(r8), intent(in) :: potential_immob_p_vr(:,:)  ! potential P immobilization [g/m3/s]
-    real(r8), intent(in) :: solutionp_vr(:,:)          ! soil mineral P   [g/m3]
-    real(r8), intent(in) :: dt      ! timestep in seconds
-    real(r8), intent(inout) :: fpi_p_vr(:,:)             ! fraction of potential immobilization supplied by p
-    real(r8), intent(inout) :: actual_immob_p_vr(:,:)    ! actual P immobilization [g/m3/s]
-    real(r8), intent(inout) :: sminp_to_plant_vr(:,:)    ! P flux to plant competitors [g/m3/s]
-    real(r8), intent(inout) :: supplement_to_sminp_vr(:,:)
+    real(r8), intent(in) :: col_plant_pdemand_vr(:)  ! demand on phos, all plant grouped [g/m3]
+    real(r8), intent(in) :: potential_immob_p_vr(:)  ! potential P immobilization [g/m3/s]
+    real(r8), intent(in) :: solutionp_vr(:)          ! soil mineral P   [g/m3]
+    real(r8), intent(in) :: dt                       ! timestep in seconds
+    real(r8), intent(inout) :: fpi_p_vr(:)             ! fraction of potential immobilization supplied by p
+    real(r8), intent(inout) :: actual_immob_p_vr(:)    ! actual P immobilization [g/m3/s]
+    real(r8), intent(inout) :: sminp_to_plant_vr(:)      ! P flux to plant competitors [g/m3/s]
+    real(r8), intent(inout) :: supplement_to_sminp_vr(:)
 
     ! Locals
     real(r8) :: sum_pdemand          ! Total phos demand over all competitors
-    integer :: j, fc ,c 
-   !$acc parallel loop independent collapse(2) gang vector default(present)
+    integer  :: j                     ! soil decomp layer loop
+
     do j = 1, nlevdecomp
-      do fc = 1, num_soilc
-         c = filter_soilc(fc)
-          
-         sum_pdemand = col_plant_pdemand_vr(c,j) + potential_immob_p_vr(c,j)
 
-        if (sum_pdemand*dt < solutionp_vr(c,j)) then
+       sum_pdemand = col_plant_pdemand_vr(j) + potential_immob_p_vr(j)
 
-            ! P availability is not limiting immobilization or plant
-            ! uptake, and both can proceed at their potential rates
-            fpi_p_vr(c,j) = 1.0_r8
-            actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j)
-            sminp_to_plant_vr(c,j) = col_plant_pdemand_vr(c,j)
+       if (sum_pdemand*dt < solutionp_vr(j)) then
 
-         elseif(carbon_only .or. carbonnitrogen_only    ) then
+          ! P availability is not limiting immobilization or plant
+          ! uptake, and both can proceed at their potential rates
+          fpi_p_vr(j) = 1.0_r8
+          actual_immob_p_vr(j) = potential_immob_p_vr(j)
+          sminp_to_plant_vr(j) = col_plant_pdemand_vr(j)
 
-            fpi_p_vr(c,j) = 1.0_r8
-            actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j)
-            sminp_to_plant_vr(c,j) =  col_plant_pdemand_vr(c,j)
-            supplement_to_sminp_vr(c,j) = sum_pdemand - (solutionp_vr(c,j)/dt)
+       elseif(carbon_only .or. carbonnitrogen_only    ) then
 
-         else
-            ! P availability can not satisfy the sum of immobilization and
-            ! plant growth demands, so these two demands compete for
-            ! available soil mineral solution P resource.
-            if (sum_pdemand > 0.0_r8 .and. solutionp_vr(c,j) >0._r8) then
-               actual_immob_p_vr(c,j) = (solutionp_vr(c,j)/dt)*(potential_immob_p_vr(c,j) / sum_pdemand)
-            else
-               actual_immob_p_vr(c,j) = 0.0_r8
-            end if
+          fpi_p_vr(j) = 1.0_r8
+          actual_immob_p_vr(j) = potential_immob_p_vr(j)
+          sminp_to_plant_vr(j) =  col_plant_pdemand_vr(j)
+          supplement_to_sminp_vr(j) = sum_pdemand - (solutionp_vr(j)/dt)
+          
+       else
+          ! P availability can not satisfy the sum of immobilization and
+          ! plant growth demands, so these two demands compete for
+          ! available soil mineral solution P resource.
 
-            if (potential_immob_p_vr(c,j) > 0.0_r8) then
-               fpi_p_vr(c,j) = actual_immob_p_vr(c,j) / potential_immob_p_vr(c,j)
-            else
-               fpi_p_vr(c,j) = 0.0_r8
-            end if
+          if (sum_pdemand > 0.0_r8 .and. solutionp_vr(j) >0._r8) then
+             actual_immob_p_vr(j) = (solutionp_vr(j)/dt)*(potential_immob_p_vr(j) / sum_pdemand)
+          else
+             actual_immob_p_vr(j) = 0.0_r8
+          end if
 
-            sminp_to_plant_vr(c,j) = max( 0._r8,(solutionp_vr(c,j)/dt) - actual_immob_p_vr(c,j) )
-         end if
-      end do 
-   end do 
+          if (potential_immob_p_vr(j) > 0.0_r8) then
+             fpi_p_vr(j) = actual_immob_p_vr(j) / potential_immob_p_vr(j)
+          else
+             fpi_p_vr(j) = 0.0_r8
+          end if
+
+          sminp_to_plant_vr(j) = max( 0._r8,(solutionp_vr(j)/dt) - actual_immob_p_vr(j) ) 
+       end if
+
+    end do
+
+    return
   end subroutine PAllocationRD
 
   !-------------------------------------------------------------------------------------------------
-  subroutine calc_nuptake_prof(num_soilc, filter_soilc, cnstate_vars, nuptake_prof)
-     ! bgc interface & pflotran:
-     ! nuptake_prof is used in Allocation1, 2, 3
-     ! !USES:
-     use elm_varpar       , only: nlevdecomp
-     ! !ARGUMENTS:
-     integer              , intent(in)    :: num_soilc        ! number of soil columns in filter
-     integer              , intent(in)    :: filter_soilc(:)  ! filter for soil columns
-     type(cnstate_type)   , intent(in)    :: cnstate_vars
-     real(r8)             , intent(inout) :: nuptake_prof(1:num_soilc, 1:nlevdecomp)
-
-     integer :: c,j,fc                                            !indices
-     real(r8):: sminn_tot(num_soilc)
-     real(r8):: sminn_vr_loc, sum1
-     !-----------------------------------------------------------------------
-
-     associate( &
-          nfixation_prof               => cnstate_vars%nfixation_prof_col      , & ! Input: [real(r8) (:,:) ]
-          smin_no3_vr                  => col_ns%smin_no3_vr                  , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral N
-          smin_nh4_vr                  => col_ns%smin_nh4_vr                    & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral N
-          )
-
-          ! column loops to resolve plant/heterotroph competition for mineral N
-
-          !NOTE:  This data creation can be pipelined if need be
-          !$acc enter data create(sminn_tot(1:num_soilc))
-         if(not (use_pflotran .and. pf_cmode) ) then
-
-          !$acc parallel loop independent gang worker default(present) private(sum1,c)
-          do fc=1,num_soilc
-             sum1 = 0._r8
-             c = filter_soilc(fc)
-             !$acc loop vector reduction(+:sum1) private(sminn_vr_loc)
-             do j = 1, nlevdecomp
-                sminn_vr_loc = smin_no3_vr(c,j) + smin_nh4_vr(c,j)
-                sum1 = sum1 + sminn_vr_loc * dzsoi_decomp(j)
-             end do
-             sminn_tot(fc) = sum1
-          end do
 
-          !$acc parallel loop independent gang default(present)
-          do j = 1, nlevdecomp
-             !$acc loop worker vector independent private(c,sminn_vr_loc)
-             do fc=1,num_soilc
-                c = filter_soilc(fc)
-                sminn_vr_loc = smin_no3_vr(c,j) + smin_nh4_vr(c,j)
-                if (sminn_tot(fc)  >  0._r8) then
-                    !original:  nuptake_prof(c,j) = sminn_vr(c,j) / sminn_tot(c)
-                   nuptake_prof(fc,j) = sminn_vr_loc / sminn_tot(fc)
-                else
-                   nuptake_prof(fc,j) = nfixation_prof(c,j)
-                end if
-             end do
-          end do
+ subroutine calc_nuptake_prof(bounds, num_soilc, filter_soilc, cnstate_vars, nuptake_prof)
+    ! bgc interface & pflotran:
+    ! nuptake_prof is used in Allocation1, 2, 3
+    ! !USES:
+      !$acc routine seq
+    use elm_varpar       , only: nlevdecomp
+    ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
+    integer                  , intent(in)    :: num_soilc        ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:)  ! filter for soil columns
+    type(cnstate_type)       , intent(in)    :: cnstate_vars
+    real(r8)                 , intent(inout) :: nuptake_prof(bounds%begc:bounds%endc, 1:nlevdecomp)
 
-          end if
-          if(use_pflotran .and. pf_cmode) then
+    integer :: c,j,fc                                            !indices
+    real(r8):: sminn_vr_loc(bounds%begc:bounds%endc, 1:nlevdecomp)
+    real(r8):: sminn_tot(bounds%begc:bounds%endc)
+    !-----------------------------------------------------------------------
+
+    associate( &
+         nfixation_prof               => cnstate_vars%nfixation_prof_col                     , & ! Output: [real(r8) (:,:) ]
+         sminn_vr                     => col_ns%sminn_vr                     , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral N
+         smin_no3_vr                  => col_ns%smin_no3_vr                  , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral N
+         smin_nh4_vr                  => col_ns%smin_nh4_vr                    & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral N
+         )
+
+         ! column loops to resolve plant/heterotroph competition for mineral N
+         ! init sminn_tot
+         do fc=1,num_soilc
+            c = filter_soilc(fc)
+            sminn_tot(c) = 0.
+         end do
+
+         do j = 1, nlevdecomp
             do fc=1,num_soilc
-               sum1 = 0._r8
                c = filter_soilc(fc)
-               do j = 1, nlevdecomp
-                  sminn_vr_loc = smin_no3_vr(c,j) + smin_nh4_vr(c,j)
-                  sum1 = sum1 + sminn_vr_loc * dzsoi_decomp(j) &
-                           *(nfixation_prof(c,j)*dzsoi_decomp(j))         ! weighted by froot fractions in annual max. active layers
-               end do
-               sminn_tot(fc) = sum1
-             end do
-            !
-             do j = 1, nlevdecomp
-              do fc=1,num_soilc
-                 c = filter_soilc(fc)
-                 sminn_vr_loc = smin_no3_vr(c,j) + smin_nh4_vr(c,j)
-
-                 if (sminn_tot(fc)  >  0._r8) then
-                    nuptake_prof(fc,j) = sminn_vr_loc/ sminn_tot(fc) &
-                          *(nfixation_prof(c,j)*dzsoi_decomp(j))         ! weighted by froot fractions in annual max. active layers
-                 else
-                    nuptake_prof(fc,j) = nfixation_prof(c,j)
-                 end if
-              end do
-           end do
-         end if
-       !$acc exit data delete(sminn_tot(1:num_soilc))
 
-     end associate
+               sminn_vr_loc(c,j) = smin_no3_vr(c,j) + smin_nh4_vr(c,j)
+               
+               if(use_pflotran .and. pf_cmode) then
+                    sminn_tot(c) = sminn_tot(c) + sminn_vr_loc(c,j) * dzsoi_decomp(j) &
+                       *(nfixation_prof(c,j)*dzsoi_decomp(j))         ! weighted by froot fractions in annual max. active layers
+               else
+                    sminn_tot(c) = sminn_tot(c) + sminn_vr_loc(c,j) * dzsoi_decomp(j)
+               end if
+            end do
+         end do
 
-  end subroutine calc_nuptake_prof
+         do j = 1, nlevdecomp
+            do fc=1,num_soilc
+               c = filter_soilc(fc)
+               if (sminn_tot(c)  >  0.) then
+                  if(use_pflotran .and. pf_cmode) then
+                     nuptake_prof(c,j) = sminn_vr_loc(c,j) / sminn_tot(c) &
+                        *(nfixation_prof(c,j)*dzsoi_decomp(j))         ! weighted by froot fractions in annual max. active layers
+                  else
+                     nuptake_prof(c,j) = sminn_vr_loc(c,j) / sminn_tot(c)   !original:  nuptake_prof(c,j) = sminn_vr(c,j) / sminn_tot(c)
+                  end if
+               else
+                  nuptake_prof(c,j) = nfixation_prof(c,j)
+               end if
 
-!-------------------------------------------------------------------------------------------------
-subroutine calc_puptake_prof(num_soilc, filter_soilc, cnstate_vars, puptake_prof)
-  ! bgc interface & pflotran:
-  ! puptake_prof is used in Allocation1, 2, & 3
-  ! !USES:
-  use elm_varpar       , only: nlevdecomp
-  ! !ARGUMENTS:
-  integer                  , intent(in)    :: num_soilc        ! number of soil columns in filter
-  integer                  , intent(in)    :: filter_soilc(:)  ! filter for soil columns
-  type(cnstate_type)       , intent(in)    :: cnstate_vars
-  real(r8)                 , intent(inout) :: puptake_prof(1:num_soilc, 1:nlevdecomp)
+            end do
+         end do
 
-  integer :: c,j,fc                                            !indices
-  real(r8):: solutionp_tot(num_soilc), sum1
+    end associate
 
-  !-----------------------------------------------------------------------
-  associate( &
-       nfixation_prof               => cnstate_vars%nfixation_prof_col , & ! Output: [real(r8) (:,:) ]
-       solutionp_vr                 => col_ps%solutionp_vr  & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral N
-       )
-       ! column loops to resolve plant/heterotroph competition for mineral N
-       ! init sminn_tot
-       ! do fc=1,num_soilc
-       !    solutionp_tot(fc) = 0.
-       ! end do
-       !$acc enter data create(solutionp_tot(1:num_soilc))
-
-       !$acc parallel loop independent gang worker default(present) private(c,sum1)
-       do fc=1,num_soilc
-          c = filter_soilc(fc)
-          sum1 = 0._r8
-          !$acc loop vector reduction(+:sum1)
-          do j = 1, nlevdecomp
-             sum1 = sum1 + solutionp_vr(c,j) * dzsoi_decomp(j)
-          end do
-          solutionp_tot(fc) = sum1
-       end do
+ end subroutine calc_nuptake_prof
 
-       !$acc parallel loop independent gang default(present)
-       do j = 1, nlevdecomp
-          !$acc loop vector independent private(c)
-          do fc=1,num_soilc
-             c = filter_soilc(fc)
-             !!! add P demand calculation
-             if (solutionp_tot(fc)  >  0.) then
-                puptake_prof(fc,j) = solutionp_vr(c,j) / solutionp_tot(fc)
-             else
-                puptake_prof(fc,j) = nfixation_prof(c,j)      ! need modifications
-             endif
+!-------------------------------------------------------------------------------------------------
+  subroutine calc_puptake_prof(bounds, num_soilc, filter_soilc, cnstate_vars, puptake_prof)
+    ! bgc interface & pflotran:
+    ! puptake_prof is used in Allocation1, 2, & 3
+    ! !USES:
+      !$acc routine seq
+    use elm_varpar       , only: nlevdecomp
+    ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
+    integer                  , intent(in)    :: num_soilc        ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:)  ! filter for soil columns
+    type(cnstate_type)       , intent(in)    :: cnstate_vars
+    real(r8)                 , intent(inout) :: puptake_prof(bounds%begc:bounds%endc, 1:nlevdecomp)
 
-          end do
-       end do
+    integer :: c,j,fc                                            !indices
+    real(r8):: solutionp_tot(bounds%begc:bounds%endc)
+
+    !-----------------------------------------------------------------------
+    associate( &
+         nfixation_prof               => cnstate_vars%nfixation_prof_col                     , & ! Output: [real(r8) (:,:) ]
+         solutionp_vr                 => col_ps%solutionp_vr                 & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral N
+         )
+         ! column loops to resolve plant/heterotroph competition for mineral N
+         ! init sminn_tot
+         do fc=1,num_soilc
+            c = filter_soilc(fc)
+            solutionp_tot(c) = 0.
+         end do
 
-       !$acc exit data delete(solutionp_tot(:))
+         do j = 1, nlevdecomp
+            do fc=1,num_soilc
+               c = filter_soilc(fc)
+               solutionp_tot(c) = solutionp_tot(c) + solutionp_vr(c,j) * dzsoi_decomp(j)
+            end do
+         end do
 
-  end associate
+         do j = 1, nlevdecomp
+            do fc=1,num_soilc
+               c = filter_soilc(fc)
+               !!! add P demand calculation
+               if (solutionp_tot(c)  >  0.) then
+                  puptake_prof(c,j) = solutionp_vr(c,j) / solutionp_tot(c)
+               else
+                  puptake_prof(c,j) = nfixation_prof(c,j)      ! need modifications
+               endif
+
+            end do
+         end do
+    end associate
 
-end subroutine calc_puptake_prof
+ end subroutine calc_puptake_prof
 
 !-----------------------------------------------------------------------
+
     subroutine dynamic_plant_alloc( nutrient_scalar, water_scalar, laindex, alloc_leaf, alloc_stem, alloc_froot, woody)
 
     ! !DESCRIPTION
diff --git a/components/elm/src/biogeochem/C14DecayMod.F90 b/components/elm/src/biogeochem/C14DecayMod.F90
index caaad9f165..2da65a8b02 100644
--- a/components/elm/src/biogeochem/C14DecayMod.F90
+++ b/components/elm/src/biogeochem/C14DecayMod.F90
@@ -13,7 +13,7 @@ module C14DecayMod
   use elm_varctl             , only : nu_com
   use ColumnDataType         , only : c14_col_cs
   use VegetationDataType     , only : c14_veg_cs
-  #define is_active_betr_bgc .false.
+
   use timeInfoMod
   !
   implicit none
@@ -48,6 +48,7 @@ contains
     ! On the radiation time step, calculate the radioactive decay of C14
     !
       !$acc routine seq
+    use tracer_varcon, only : is_active_betr_bgc
     ! !ARGUMENTS:
     integer                , intent(in)    :: num_soilc       ! number of soil columns filter
     integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
diff --git a/components/elm/src/biogeochem/CH4Mod.F90 b/components/elm/src/biogeochem/CH4Mod.F90
index 2260f912ce..140f0edc1d 100644
--- a/components/elm/src/biogeochem/CH4Mod.F90
+++ b/components/elm/src/biogeochem/CH4Mod.F90
@@ -1,6 +1,7 @@
 module CH4Mod
 
-   #include "shr_assert.h"
+#include "shr_assert.h"
+
   !-----------------------------------------------------------------------
   ! !DESCRIPTION:
   ! Module holding routines to calculate methane fluxes
@@ -16,7 +17,7 @@ module CH4Mod
   use elm_varcon         , only : catomw, s_con, d_con_w, d_con_g, c_h_inv, kh_theta, kh_tbase
   use landunit_varcon    , only : istdlak
   use clm_time_manager   , only : get_step_size, get_nstep
-  use elm_varctl         , only : iulog, use_cn, use_lch4
+  use elm_varctl         , only : iulog, use_cn, use_lch4, use_fates
   use abortutils         , only : endrun
   use decompMod          , only : bounds_type
   use SharedParamsMod    , only : ParamsShareInst
@@ -35,7 +36,9 @@ module CH4Mod
   use VegetationType     , only : veg_pp
   use VegetationDataType , only : veg_wf, veg_cs, veg_cf
   use timeinfoMod
-
+  use topounit_varcon    , only : max_topounits  
+  use ELMFatesInterfaceMod, only : hlm_fates_interface_type
+  
   !
   implicit none
   save
@@ -111,6 +114,7 @@ module CH4Mod
   end type CH4ParamsType
   type(CH4ParamsType), public ::  CH4ParamsInst
   !$acc declare create(CH4ParamsInst)
+
   type, public :: ch4_type
      real(r8), pointer :: ch4_prod_depth_sat_col     (:,:) =>null()! col CH4 production rate from methanotrophs (mol/m3/s) (nlevsoi)
      real(r8), pointer :: ch4_prod_depth_unsat_col   (:,:) =>null()! col CH4 production rate from methanotrophs (mol/m3/s) (nlevsoi)
@@ -131,8 +135,6 @@ module CH4Mod
      real(r8), pointer :: ch4_surf_ebul_sat_col      (:)   =>null()! col CH4 ebullition flux to atmosphere (after oxidation) (mol/m2/s)
      real(r8), pointer :: ch4_surf_ebul_unsat_col    (:)   =>null()! col CH4 ebullition flux to atmosphere (after oxidation) (mol/m2/s)
      real(r8), pointer :: ch4_surf_ebul_lake_col     (:)   =>null()! col CH4 ebullition flux to atmosphere (after oxidation) (mol/m2/s)
-     real(r8), pointer :: co2_aere_depth_sat_col     (:,:) =>null()! col CO2 loss rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
-     real(r8), pointer :: co2_aere_depth_unsat_col   (:,:) =>null()! col CO2 loss rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
      real(r8), pointer :: o2_oxid_depth_sat_col      (:,:) =>null()! col O2 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
      real(r8), pointer :: o2_oxid_depth_unsat_col    (:,:) =>null()! col O2 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
      real(r8), pointer :: o2_aere_depth_sat_col      (:,:) =>null()! col O2 gain rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
@@ -195,10 +197,12 @@ module CH4Mod
      procedure, public  :: Restart
 
   end type ch4_type
-contains 
+  !------------------------------------------------------------------------
+
+contains
 
   !------------------------------------------------------------------------
-  subroutine Init( this, bounds,cellorg_col )
+  subroutine Init( this, bounds, cellorg_col )
 
     class(ch4_type)               :: this
     type(bounds_type), intent(in) :: bounds
@@ -219,7 +223,7 @@ contains
     ! Allocate module variables and data structures
     !
     ! !USES:
-    use shr_infnan_mod, only: nan => shr_infnan_nan, assignment(=)
+    use shr_infnan_mod, only: spval => shr_infnan_nan, assignment(=)
     use elm_varpar    , only: nlevgrnd
     !
     ! !ARGUMENTS:
@@ -254,8 +258,6 @@ contains
     allocate(this%ch4_aere_depth_unsat_col   (begc:endc,1:nlevgrnd)) ;  this%ch4_aere_depth_unsat_col   (:,:) = nan
     allocate(this%ch4_tran_depth_sat_col     (begc:endc,1:nlevgrnd)) ;  this%ch4_tran_depth_sat_col     (:,:) = nan
     allocate(this%ch4_tran_depth_unsat_col   (begc:endc,1:nlevgrnd)) ;  this%ch4_tran_depth_unsat_col   (:,:) = nan
-    allocate(this%co2_aere_depth_sat_col     (begc:endc,1:nlevgrnd)) ;  this%co2_aere_depth_sat_col     (:,:) = nan
-    allocate(this%co2_aere_depth_unsat_col   (begc:endc,1:nlevgrnd)) ;  this%co2_aere_depth_unsat_col   (:,:) = nan
     allocate(this%ch4_surf_aere_sat_col      (begc:endc))            ;  this%ch4_surf_aere_sat_col      (:)   = nan
     allocate(this%ch4_surf_aere_unsat_col    (begc:endc))            ;  this%ch4_surf_aere_unsat_col    (:)   = nan
     allocate(this%ch4_ebul_depth_sat_col     (begc:endc,1:nlevgrnd)) ;  this%ch4_ebul_depth_sat_col     (:,:) = nan
@@ -684,13 +686,13 @@ contains
     real(r8)          , intent(in) :: cellorg_col (bounds%begc:, 1:)
     !
     ! !LOCAL VARIABLES:
-    integer               :: j ,g, l,c,p ! indices
+    integer               :: j ,g,l,c,p,t,ti,topi ! indices
     type(file_desc_t)     :: ncid        ! netcdf id
-    real(r8)     ,pointer :: zwt0_in (:) ! read in - zwt0
-    real(r8)     ,pointer :: f0_in (:)   ! read in - f0
-    real(r8)     ,pointer :: p3_in (:)   ! read in - p3
-    real(r8)     ,pointer :: pH_in (:)   ! read in - pH
-    logical               :: readvar
+    real(r8)     ,pointer :: zwt0_in (:,:) ! read in - zwt0 
+    real(r8)     ,pointer :: f0_in (:,:)   ! read in - f0 
+    real(r8)     ,pointer :: p3_in (:,:)   ! read in - p3 
+    real(r8)     ,pointer :: pH_in (:,:)   ! read in - pH 
+    logical               :: readvar 
     character(len=256)    :: locfn
     !-----------------------------------------------------------------------
 
@@ -700,10 +702,10 @@ contains
     ! Initialize time constant variables
     !----------------------------------------
 
-    allocate(zwt0_in(bounds%begg:bounds%endg))
-    allocate(f0_in(bounds%begg:bounds%endg))
-    allocate(p3_in(bounds%begg:bounds%endg))
-    if (usephfact) allocate(ph_in(bounds%begg:bounds%endg))
+    allocate(zwt0_in(bounds%begg:bounds%endg,1:max_topounits))
+    allocate(f0_in(bounds%begg:bounds%endg,1:max_topounits))
+    allocate(p3_in(bounds%begg:bounds%endg,1:max_topounits))
+    if (usephfact) allocate(ph_in(bounds%begg:bounds%endg,1:max_topounits))
 
     ! Methane code parameters for finundated
 
@@ -738,13 +740,16 @@ contains
 
     do c = bounds%begc, bounds%endc
        g = col_pp%gridcell(c)
+       t = col_pp%topounit(c)
+       topi = grc_pp%topi(g)
+       ti = t - topi + 1
 
        if (.not. fin_use_fsat) then
-          this%zwt0_col(c) = zwt0_in(g)
-          this%f0_col(c)   = f0_in(g)
-          this%p3_col(c)   = p3_in(g)
+          this%zwt0_col(c) = zwt0_in(g,ti)
+          this%f0_col(c)   = f0_in(g,ti)
+          this%p3_col(c)   = p3_in(g,ti)
        end if
-       if (usephfact) this%pH_col(c) = pH_in(g)
+       if (usephfact) this%pH_col(c) = pH_in(g,ti)
     end do
 
     deallocate(zwt0_in, f0_in, p3_in)
@@ -839,8 +844,6 @@ contains
        this%ch4_aere_depth_unsat_col   (c,nlevsoi+1:nlevgrnd) = 0._r8
        this%ch4_tran_depth_sat_col     (c,nlevsoi+1:nlevgrnd) = 0._r8
        this%ch4_tran_depth_unsat_col   (c,nlevsoi+1:nlevgrnd) = 0._r8
-       this%co2_aere_depth_sat_col     (c,nlevsoi+1:nlevgrnd) = 0._r8
-       this%co2_aere_depth_unsat_col   (c,nlevsoi+1:nlevgrnd) = 0._r8
        this%ch4_ebul_depth_sat_col     (c,nlevsoi+1:nlevgrnd) = 0._r8
        this%ch4_ebul_depth_unsat_col   (c,nlevsoi+1:nlevgrnd) = 0._r8
        this%conc_ch4_lake_col          (c,nlevsoi+1:nlevgrnd) = 0._r8
@@ -868,7 +871,6 @@ contains
           this%co2_oxid_depth_unsat_col   (c,:) = spval
           this%ch4_aere_depth_unsat_col   (c,:) = spval
           this%ch4_tran_depth_unsat_col   (c,:) = spval
-          this%co2_aere_depth_unsat_col   (c,:) = spval
           this%ch4_surf_aere_unsat_col    (c)   = spval
           this%ch4_ebul_depth_unsat_col   (c,:) = spval
           this%ch4_ebul_total_unsat_col   (c)   = spval
@@ -903,8 +905,6 @@ contains
           this%ch4_aere_depth_unsat_col   (c,:) = spval
           this%ch4_tran_depth_sat_col     (c,:) = spval
           this%ch4_tran_depth_unsat_col   (c,:) = spval
-          this%co2_aere_depth_sat_col     (c,:) = spval
-          this%co2_aere_depth_unsat_col   (c,:) = spval
           this%ch4_surf_aere_sat_col      (c)   = spval
           this%ch4_surf_aere_unsat_col    (c)   = spval
           this%ch4_ebul_depth_sat_col     (c,:) = spval
@@ -1057,7 +1057,7 @@ contains
     !
     ! !USES:
     use shr_kind_mod , only : r8 => shr_kind_r8
-    use shr_infnan_mod, only: nan => shr_infnan_nan, assignment(=)
+    use shr_infnan_mod, only: spval => shr_infnan_nan, assignment(=)
     use ncdio_pio    , only : file_desc_t,ncd_io
     use CH4varcon    , only : use_aereoxid_prog
     !
@@ -1303,18 +1303,19 @@ contains
        num_soilc, filter_soilc, &
        num_lakec, filter_lakec, &
        num_soilp, filter_soilp, &
-       lakestate_vars, canopystate_vars, soilstate_vars, soilhydrology_vars, &
-       energyflux_vars, ch4_vars, lnd2atm_vars )
+       atm2lnd_vars, lakestate_vars, canopystate_vars, soilstate_vars, soilhydrology_vars, &
+       energyflux_vars, ch4_vars, lnd2atm_vars, elm_fates )
     !
     ! !DESCRIPTION:
     ! Driver for the methane emissions model
     !
     ! !USES:
-    use subgridAveMod , only : p2c_1d_filter_parallel, p2c_2d_parallel, c2g_1d_parallel, unity 
-    use elm_varpar    , only : nlevgrnd, nlevdecomp
-    use pftvarcon     , only : noveg
-    use CH4varcon     , only : replenishlakec, allowlakeprod, ch4offline, fin_use_fsat
-    use elm_varcon    , only : secspday
+      !$acc routine seq
+    use subgridAveMod      , only : p2c, c2g
+    use elm_varpar         , only : nlevgrnd, nlevdecomp
+    use pftvarcon          , only : noveg
+    use CH4varcon          , only : replenishlakec, allowlakeprod, ch4offline, fin_use_fsat
+    use elm_varcon         , only : secspday
     !
     ! !ARGUMENTS:
     type(bounds_type)        , intent(in)    :: bounds
@@ -1324,6 +1325,7 @@ contains
     integer                  , intent(in)    :: filter_lakec(:)    ! column filter for lake points
     integer                  , intent(in)    :: num_soilp          ! number of soil points in pft filter
     integer                  , intent(in)    :: filter_soilp(:)    ! patch filter for soil points
+    type(atm2lnd_type)       , intent(inout) :: atm2lnd_vars       ! output ONLY for forcp_ch4 in ch4offline mode
     type(lakestate_type)     , intent(in)    :: lakestate_vars
     type(canopystate_type)   , intent(in)    :: canopystate_vars
     type(soilstate_type)     , intent(inout) :: soilstate_vars
@@ -1331,11 +1333,15 @@ contains
     type(energyflux_type)    , intent(inout) :: energyflux_vars
     type(ch4_type)           , intent(inout) :: ch4_vars
     type(lnd2atm_type)       , intent(inout) :: lnd2atm_vars
+    type(hlm_fates_interface_type), intent(inout) :: elm_fates
+    
+    real(r8)  :: dtime                                  ! land model time step (sec)
+
     !
     ! !LOCAL VARIABLES:
     integer  :: sat                                    ! 0 = unsatured, 1 = saturated
     logical  :: lake                                   ! lake or not lake
-    integer  :: j,fc,c,g,fp,p,t                        ! indices
+    integer  :: j,fc,c,g,fp,p,t,pf,s                   ! indices
     real(r8) :: dtime_ch4                              ! ch4 model time step (sec)
     integer  :: nstep
     integer  :: jwt(bounds%begc:bounds%endc)           ! index of the soil layer right above the water table (-)
@@ -1345,9 +1351,8 @@ contains
     real(r8) :: totalsat
     real(r8) :: totalunsat
     real(r8) :: dfsat
-    real(r8) :: rootfraction(1:num_soilp, 1:nlevgrnd)
-    real(r8) :: totsoilcolch4_bef(1:num_soilc) ! g C / m^2
-    real(r8) :: totlakecolch4_bef(1:num_lakec) ! g C / m^2
+    real(r8) :: rootfraction(bounds%begp:bounds%endp, 1:nlevgrnd)
+    real(r8) :: totcolch4_bef(bounds%begc:bounds%endc) ! g C / m^2
     real(r8) :: errch4                                 ! g C / m^2
     real(r8) :: zwt_actual
     real(r8) :: qflxlags                               ! Time to lag qflx_surf_lag (s)
@@ -1360,16 +1365,13 @@ contains
     real(r8) :: qflxlagd                               ! days to lag qflx_surf_lag in the tropics (days)
     real(r8) :: highlatfact                            ! multiple of qflxlagd for high latitudes
     integer  :: dummyfilter(1)                         ! empty filter
-    integer  :: erridx
-    real(r8) :: sum1,sum2,sum3
-    integer  :: begg,endg,begc,endc,begp,endp
-    real :: startt, stopt
+    integer  :: nc                                     ! clump index
     !-----------------------------------------------------------------------
 
     associate(                                                                 &
-         dz                   =>   col_pp%dz                                 , & ! Input:  [real(r8) (:,:) ]  layer thickness (m)  (-nlevsno+1:nlevsoi)
-         zi                   =>   col_pp%zi                                 , & ! Input:  [real(r8) (:,:) ]  interface level below a "z" level (m)
-         z                    =>   col_pp%z                                  , & ! Input:  [real(r8) (:,:) ]  layer depth (m) (-nlevsno+1:nlevsoi)
+         dz                   =>   col_pp%dz                                    , & ! Input:  [real(r8) (:,:) ]  layer thickness (m)  (-nlevsno+1:nlevsoi)
+         zi                   =>   col_pp%zi                                    , & ! Input:  [real(r8) (:,:) ]  interface level below a "z" level (m)
+         z                    =>   col_pp%z                                     , & ! Input:  [real(r8) (:,:) ]  layer depth (m) (-nlevsno+1:nlevsoi)
 
          forc_t               =>   top_as%tbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric temperature (Kelvin)
          forc_pbot            =>   top_as%pbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)
@@ -1383,7 +1385,7 @@ contains
          rootfr               =>   soilstate_vars%rootfr_patch               , & ! Input:  [real(r8) (:,:) ]  fraction of roots in each soil layer  (nlevgrnd)
          rootfr_col           =>   soilstate_vars%rootfr_col                 , & ! Output: [real(r8) (:,:) ]  fraction of roots in each soil layer  (nlevgrnd) (p2c)
 
-         frac_h2osfc          =>   col_ws%frac_h2osfc            , & ! Input:  [real(r8) (:)   ]  fraction of ground covered by surface water (0 to 1)
+         frac_h2osfc          =>   col_ws%frac_h2osfc           , & ! Input:  [real(r8) (:)   ]  fraction of ground covered by surface water (0 to 1)
          qflx_surf            =>   col_wf%qflx_surf              , & ! Input:  [real(r8) (:)   ]  surface runoff (mm H2O /s)
 
          conc_o2_sat          =>   ch4_vars%conc_o2_sat_col                  , & ! Input:  [real(r8) (:,:) ]  O2 conc  in each soil layer (mol/m3) (nlevsoi)
@@ -1425,81 +1427,41 @@ contains
          ch4co2f              =>   ch4_vars%ch4co2f_grc                      , & ! Output: [real(r8) (:)   ]  gridcell CO2 production from CH4 oxidation (g C/m**2/s)
          ch4prodg             =>   ch4_vars%ch4prodg_grc                     , & ! Output: [real(r8) (:)   ]  gridcell average CH4 production (g C/m^2/s)
          ch4_surf_flux_tot    =>   ch4_vars%ch4_surf_flux_tot_col            , & ! Output: [real(r8) (:)   ]  col CH4 flux to atm. (kg C/m**2/s)
-         !Added to pass directly to sat, unsat routines 
-         o2_decomp_depth_unsat  => ch4_vars%o2_decomp_depth_unsat_col , &
-         o2stress_unsat         => ch4_vars%o2stress_unsat_col        , &
-         ch4_aere_depth_unsat   => ch4_vars%ch4_aere_depth_unsat_col  , &
-         ch4_tran_depth_unsat   => ch4_vars%ch4_tran_depth_unsat_col  , &
-         ch4_ebul_depth_unsat   => ch4_vars%ch4_ebul_depth_unsat_col  , &
-         ch4_ebul_total_unsat   => ch4_vars%ch4_ebul_total_unsat_col  , &
-         co2_oxid_depth_unsat   => ch4_vars%co2_oxid_depth_unsat_col  , &
-         o2_oxid_depth_unsat    => ch4_vars%o2_oxid_depth_unsat_col   , &
-         o2_aere_depth_unsat    => ch4_vars%o2_aere_depth_unsat_col   , &
-         co2_aere_depth_unsat    => ch4_vars%co2_aere_depth_unsat_col , &
-         ch4stress_unsat        => ch4_vars%ch4stress_unsat_col       , &
-         co2_decomp_depth_unsat => ch4_vars%co2_decomp_depth_unsat_col, &
-         conc_o2_unsat          => ch4_vars%conc_o2_unsat_col         , &
-         ! Sat variables 
-         o2_decomp_depth_sat  => ch4_vars%o2_decomp_depth_sat_col  , &
-         o2stress_sat         => ch4_vars%o2stress_sat_col         , &
-         co2_aere_depth_sat   => ch4_vars%co2_aere_depth_sat_col   , &
-         ch4_aere_depth_sat   => ch4_vars%ch4_aere_depth_sat_col   , &
-         ch4_tran_depth_sat   => ch4_vars%ch4_tran_depth_sat_col   , &
-         ch4_ebul_depth_sat   => ch4_vars%ch4_ebul_depth_sat_col   , &
-         ch4_ebul_total_sat   => ch4_vars%ch4_ebul_total_sat_col   , &
-         co2_oxid_depth_sat   => ch4_vars%co2_oxid_depth_sat_col   , &
-         o2_oxid_depth_sat    => ch4_vars%o2_oxid_depth_sat_col    , &
-         o2_aere_depth_sat    => ch4_vars%o2_aere_depth_sat_col    , &
-         ch4stress_sat        => ch4_vars%ch4stress_sat_col        , &
-         co2_decomp_depth_sat => ch4_vars%co2_decomp_depth_sat_col , &
-         !
-         nem_grc              =>   lnd2atm_vars%nem_grc            , & ! Output: [real(r8) (:)   ]  gridcell average net methane correction to CO2 flux (g C/m^2/s)
-         redoxlag             => CH4ParamsInst%redoxlag , &
-         redoxlag_vertical    => CH4ParamsInst%redoxlag_vertical , &
-         atmch4               => CH4ParamsInst%atmch4      , &
-         qflxlagd             => CH4ParamsInst%qflxlagd    , &
-         highlatfact          => CH4ParamsInst%highlatfact   &
+
+         nem_grc              =>   lnd2atm_vars%nem_grc                      , & ! Output: [real(r8) (:)   ]  gridcell average net methane correction to CO2 flux (g C/m^2/s)
+
+         begg                 =>   bounds%begg                               , &
+         endg                 =>   bounds%endg                               , &
+         begc                 =>   bounds%begc                               , &
+         endc                 =>   bounds%endc                               , &
+         begp                 =>   bounds%begp                               , &
+         endp                 =>   bounds%endp                                 &
          )
-      
-      call cpu_time(startt) 
-      !$acc enter data create(&
-      !$acc jwt(:), &
-      !$acc ch4_prod_tot(:), &
-      !$acc ch4_oxid_tot(:), &
-      !$acc nem_col(:), &
-      !$acc rootfraction(:,:), &
-      !$acc totsoilcolch4_bef(:), &
-      !$acc totlakecolch4_bef(:), &
-      !$acc dummyfilter(:))
-      !$acc enter data create(sum1,sum2,sum3)
-
-      begg =   bounds%begg
-      endg =   bounds%endg
-      begc =   bounds%begc
-      endc =   bounds%endc
-      begp =   bounds%begp
-      endp =   bounds%endp
-
-      dtime_ch4 = dtime_mod
+
+      redoxlag          = CH4ParamsInst%redoxlag
+      redoxlag_vertical = CH4ParamsInst%redoxlag_vertical
+      atmch4            = CH4ParamsInst%atmch4
+      qflxlagd          = CH4ParamsInst%qflxlagd
+      highlatfact       = CH4ParamsInst%highlatfact
+
+      dtime = dtime_mod !get_step_size()
+      dtime_ch4 = dtime
       redoxlags = redoxlag*secspday ! days --> s
       redoxlags_vertical = redoxlag_vertical*secspday ! days --> s
       rgasm = rgas / 1000._r8
-      lake = .false.; sat = 0 
-      !$acc enter data copyin(redoxlags,redoxlags_vertical, dtime_ch4, lake, sat)
-      !$acc update device(rgasm) 
+
+      jwt(begc:endc)            = huge(1)
+      totcolch4_bef(begc:endc)  = spval
 
       ! Initialize local fluxes to zero: necessary for columns outside the filters because averaging up to gridcell will be done
-      ! ch4_surf_flux_tot(begc:endc) = 0._r8
-      ! Adjustment to NEE for methane production - oxidation
-      ! nem_col(begc:endc)           = 0._r8
+      ch4_surf_flux_tot(begc:endc) = 0._r8
+      ch4_prod_tot(begc:endc)      = 0._r8
+      ch4_oxid_tot(begc:endc)      = 0._r8
+      rootfraction(begp:endp,:)    = spval
 
-      !$acc parallel loop independent gang vector default(present)
-      do c = begc , endc 
-         ch4_surf_flux_tot(c) = 0._r8 
-         nem_col(c) = 0._r8
-      end do 
+      ! Adjustment to NEE for methane production - oxidation
+      nem_col(begc:endc)           = 0._r8
 
-      !$acc parallel loop independent gang vector default(present)
       do g= begg, endg
          ! using the first topounit on this gridcell for access to atmospheric forcing
          ! PET 8/10/2018 - replace this later once gas concentrations (c_atm) are also being tracked at
@@ -1509,24 +1471,23 @@ contains
             forc_pch4(t) = atmch4*forc_pbot(t)
          else
             if (forc_pch4(t) == 0._r8) then
-               !write(iulog,*) 'not using ch4offline, but methane concentration not passed from the atmosphere'//&
-               !      'to land model! CLM Model is stopping.'
-               !call endrun(msg=' ERROR: Methane not being passed to atmosphere'//errMsg(__FILE__, __LINE__))
-               print *, ' ERROR: Methane not being passed to atmosphere'
+               write(iulog,*) 'not using ch4offline, but methane concentration not passed from the atmosphere'//&
+                     'to land model! CLM Model is stopping.'
+               call endrun(msg=' ERROR: Methane not being passed to atmosphere'//&
+                     errMsg(__FILE__, __LINE__))
             end if
          end if
          c_atm(g,1) =  forc_pch4(t) / rgasm / forc_t(t) ! [mol/m3 air]
          c_atm(g,2) =  forc_po2(t)  / rgasm / forc_t(t) ! [mol/m3 air]
          c_atm(g,3) =  forc_pco2(t) / rgasm / forc_t(t) ! [mol/m3 air]
       end do
-      
+
       ! Initialize CH4 balance and calculate finundated
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_soilc
          c = filter_soilc(fc)
          g = col_pp%gridcell(c)
 
-         totsoilcolch4_bef(fc) = totcolch4(c)
+         totcolch4_bef(c) = totcolch4(c)
          totcolch4(c) = 0._r8
 
          ! Update lagged surface runoff
@@ -1536,8 +1497,8 @@ contains
          else
             qflxlags = qflxlagd * secspday * highlatfact ! 60 days
          end if
-         qflx_surf_lag(c) = qflx_surf_lag(c) * exp(-dtime_mod/qflxlags) &
-              + qflx_surf(c) * (1._r8 - exp(-dtime_mod/qflxlags))
+         qflx_surf_lag(c) = qflx_surf_lag(c) * exp(-dtime/qflxlags) &
+              + qflx_surf(c) * (1._r8 - exp(-dtime/qflxlags))
 
          !There may be ways to improve this for irrigated crop columns...
          if (fin_use_fsat) then
@@ -1558,81 +1519,90 @@ contains
 
          ! Update lagged finundated for redox calculation
          if (redoxlags > 0._r8) then
-            finundated_lag(c) = finundated_lag(c) * exp(-dtime_mod/redoxlags) &
-                 + finundated(c) * (1._r8 - exp(-dtime_mod/redoxlags))
+            finundated_lag(c) = finundated_lag(c) * exp(-dtime/redoxlags) &
+                 + finundated(c) * (1._r8 - exp(-dtime/redoxlags))
          else
             finundated_lag(c) = finundated(c)
          end if
 
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_lakec
          c = filter_lakec(fc)
 
-         totlakecolch4_bef(fc) = totcolch4(c)
+         totcolch4_bef(c) = totcolch4(c)
          totcolch4(c) = 0._r8
       end do
 
       ! Check to see if finundated changed since the last timestep.  If it increased, then reduce conc_ch4_sat
       ! proportionally.  If it decreased, then add flux to atm.
-      !$acc parallel loop independent gang worker default(present) private(sum1)
-      do fc = 1, num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8
-         if (fsat_bef(c) /= spval .and. finundated(c) > fsat_bef(c)) then !Reduce conc_ch4_sat
-            !$acc loop independent vector 
-            do j=1,nlevsoi
+
+      do j=1,nlevsoi
+         do fc = 1, num_soilc
+            c = filter_soilc(fc)
+
+            if (j==1) then
+               ch4_dfsat_flux(c) = 0._r8
+            end if
+
+            if (fsat_bef(c) /= spval .and. finundated(c) > fsat_bef(c)) then !Reduce conc_ch4_sat
                dfsat = finundated(c) - fsat_bef(c)
                conc_ch4_sat(c,j) = (fsat_bef(c)*conc_ch4_sat(c,j) + dfsat*conc_ch4_unsat(c,j)) / finundated(c)
-            end do 
-
-         else if (fsat_bef(c) /= spval .and. finundated(c) < fsat_bef(c)) then
-            !$acc loop vector reduction(+:sum1)
-            do j=1,nlevsoi 
-               sum1 = sum1 + (fsat_bef(c) - finundated(c))*(conc_ch4_sat(c,j) - conc_ch4_unsat(c,j)) * &
-                    dz(c,j) / dtime_mod * catomw / 1000._r8 ! mol --> kg
-            end do
-         end if
-         ch4_dfsat_flux(c) = sum1 
+            else if (fsat_bef(c) /= spval .and. finundated(c) < fsat_bef(c)) then
+               ch4_dfsat_flux(c) = ch4_dfsat_flux(c) + (fsat_bef(c) - finundated(c))*(conc_ch4_sat(c,j) - conc_ch4_unsat(c,j)) * &
+                    dz(c,j) / dtime * catomw / 1000._r8 ! mol --> kg
+            end if
+         end do
       end do
 
       !!!! Begin biochemistry
-      
+
       ! First for soil
       lake = .false.
+
       ! Do CH4 Annual Averages
       call ch4_annualupdate(bounds, &
            num_soilc, filter_soilc, &
-           num_soilp, filter_soilp, ch4_vars, dtime_mod, 365.d0)
+           num_soilp, filter_soilp, ch4_vars, dtime, 365.d0)
 
       ! Determine rootfr_col and also check for inactive columns
 
       if (nlevdecomp == 1) then
 
+         nc = bounds%clump_index
+         
          ! Set rootfraction to spval for non-veg points, unless veg_pp%wtcol > 0.99,
          ! in which case set it equal to uniform dist.
-         !$acc parallel loop independent gang vector default(present) collapse(2) 
-         do j=1, nlevsoi
-            do fp = 1, num_soilp
-               p = filter_soilp(fp)
-               c = veg_pp%column(p)
-
-               if (veg_pp%itype(p) /= noveg) then
-                  rootfraction(fp,j) = rootfr(p,j)
-               else if (veg_pp%wtcol(p) < 0.99_r8) then
-                  rootfraction(fp,j) = spval
-               else
-                  rootfraction(fp,j) = dz(c,j) / zi(c,nlevsoi)   ! Set equal to uniform distribution
-               end if
-            end do
+
+         do fp = 1, num_soilp
+            p = filter_soilp(fp)
+            c = veg_pp%column(p)
+
+            if(.not. col_pp%is_fates(c) ) then
+               do j=1, nlevsoi
+                  if (veg_pp%itype(p) /= noveg) then
+                     rootfraction(p,j) = rootfr(p,j)
+                  else if (veg_pp%wtcol(p) < 0.99_r8) then
+                     rootfraction(p,j) = spval
+                  else
+                     rootfraction(p,j) = dz(c,j) / zi(c,nlevsoi)   ! Set equal to uniform distribution
+                  end if
+               end do
+            else
+               pf = p-col_pp%pfti(c)
+               s = elm_fates%f2hmap(nc)%hsites(c)
+               do j=1, elm_fates%fates(nc)%bc_in(s)%nlevsoil
+                  rootfraction(p,j) = elm_fates%fates(nc)%bc_out(s)%rootfr_pa(pf,j)
+               end do
+            end if
          end do
 
-         call p2c_2d_parallel(bounds, nlevgrnd, &
+         
+         call p2c (bounds, nlevgrnd, &
               rootfraction(bounds%begp:bounds%endp, :), &
-              rootfr_col(bounds%begc:bounds%endc, :))
+              rootfr_col(bounds%begc:bounds%endc, :), &
+              0)
 
-         !$acc parallel loop independent gang vector default(present) collapse(2) 
          do j=1, nlevsoi
             do fc = 1, num_soilc
                c = filter_soilc(fc)
@@ -1644,12 +1614,11 @@ contains
       ! Determine grnd_ch4_cond_col
       ! Needed to use non-filter form above so that spval would be treated properly.
 
-      call p2c_1d_filter_parallel(num_soilc, filter_soilc, &
+      call p2c (bounds, num_soilc, filter_soilc, &
            grnd_ch4_cond_patch(bounds%begp:bounds%endp), &
            grnd_ch4_cond_col(bounds%begc:bounds%endc))
 
       ! Set the gridcell atmospheric CH4 and O2 concentrations
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_soilc
          c = filter_soilc(fc)
          g = col_pp%gridcell(c)
@@ -1667,187 +1636,79 @@ contains
       ! Loop over saturated and unsaturated, non-lakes
       !------------------------------------------------
 
-      ! do sat = 0, 1 ! 0 == unsaturated; 1 = saturated
+      do sat = 0, 1 ! 0 == unsaturated; 1 = saturated
 
-      ! Get index of water table
-      ! if (sat == 0) then ! unsaturated
-      sat = 0 
-      call get_jwt (bounds, num_soilc, filter_soilc, jwt(begc:endc), &
-           soilstate_vars )
+         ! Get index of water table
+         if (sat == 0) then ! unsaturated
 
-      !$acc parallel loop independent gang vector default(present)
-      do fc = 1, num_soilc
-         c = filter_soilc(fc)
-         zwt_ch4_unsat(c) = zi(c,jwt(c))
-      end do
+            call get_jwt (bounds, num_soilc, filter_soilc, jwt(begc:endc), &
+                 soilstate_vars )
 
-      ! Update lagged saturation status of layer
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
-      do j=1,nlevsoi
-         do fc = 1, num_soilc
-            c = filter_soilc(fc)
+            do fc = 1, num_soilc
+               c = filter_soilc(fc)
+               zwt_ch4_unsat(c) = zi(c,jwt(c))
 
-            if (j > jwt(c) .and. redoxlags_vertical > 0._r8) then ! saturated currently
-               layer_sat_lag(c,j) = layer_sat_lag(c,j) * exp(-dtime_mod/redoxlags_vertical) &
-                    + (1._r8 - exp(-dtime_mod/redoxlags_vertical))
-            else if (redoxlags_vertical > 0._r8) then
-               layer_sat_lag(c,j) = layer_sat_lag(c,j) * exp(-dtime_mod/redoxlags_vertical)
-            else if (j > jwt(c)) then  ! redoxlags_vertical = 0
-               layer_sat_lag(c,j) = 1._r8
-            else
-               layer_sat_lag(c,j) = 0._r8
-            end if
-         end do
-      end do
+            end do
 
+            ! Update lagged saturation status of layer
+            do j=1,nlevsoi
+               do fc = 1, num_soilc
+                  c = filter_soilc(fc)
+
+                  if (j > jwt(c) .and. redoxlags_vertical > 0._r8) then ! saturated currently
+                     layer_sat_lag(c,j) = layer_sat_lag(c,j) * exp(-dtime/redoxlags_vertical) &
+                          + (1._r8 - exp(-dtime/redoxlags_vertical))
+                  else if (redoxlags_vertical > 0._r8) then
+                     layer_sat_lag(c,j) = layer_sat_lag(c,j) * exp(-dtime/redoxlags_vertical)
+                  else if (j > jwt(c)) then  ! redoxlags_vertical = 0
+                     layer_sat_lag(c,j) = 1._r8
+                  else
+                     layer_sat_lag(c,j) = 0._r8
+                  end if
+               end do
+            end do
 
+         else ! saturated
+            do fc = 1, num_soilc
+               c = filter_soilc(fc)
+               jwt(c) = 0
+            end do
+         endif
 
-      ! calculate CH4 production in each soil layer
-      call ch4_prod (bounds, &
-           num_soilc, filter_soilc, &
-           num_soilp, filter_soilp, &
-           jwt(begc:endc), sat, lake, &
-           soilstate_vars, ch4_vars, dtime_mod, &
-           conc_o2_unsat(begc:endc,:), ch4_prod_depth_unsat(begc:endc,:), &
-           o2_decomp_depth_unsat(begc:endc,:), co2_decomp_depth_unsat(begc:endc,:) &
-           )
-      
-
-      ! calculate CH4 oxidation in each soil layer
-      call ch4_oxid (bounds, &
-           num_soilc, filter_soilc, &
-           jwt(begc:endc), sat, lake, &
-           soilstate_vars, dtime_mod,&
-           ch4_oxid_depth_unsat(begc:endc,:), &
-           o2_oxid_depth_unsat(begc:endc,:),&
-           co2_oxid_depth_unsat(begc:endc,:), &   
-           conc_ch4_unsat(begc:endc,:), conc_o2_unsat(begc:endc,:), &
-           o2_decomp_depth_unsat(begc:endc,:)  )
-
-      
-
-      ! calculate CH4 aerenchyma losses in each soil layer
-      call ch4_aere (bounds, &
-           num_soilc, filter_soilc, &
-           num_soilp, filter_soilp, &
-           jwt(begc:endc), sat, lake, &
-           canopystate_vars, soilstate_vars,&
-           energyflux_vars, ch4_vars,dtime_mod, &
-           ch4_aere_depth_unsat(begc:endc,:), ch4_tran_depth_unsat(begc:endc,:), &
-           o2_aere_depth_unsat(begc:endc,:), &
-           co2_aere_depth_unsat(begc:endc,:), conc_ch4_unsat(begc:endc,:), &
-           conc_o2_unsat(begc:endc,:), ch4_oxid_depth_unsat(begc:endc,:),&
-           ch4_prod_depth_unsat(begc:endc,:))
-
-      ! calculate CH4 ebullition losses in each soil layer
-      call ch4_ebul (bounds, &
-           num_soilc, filter_soilc, &
-           jwt(begc:endc), sat, lake, &
-           lakestate_vars, soilstate_vars, ch4_vars, dtime_mod, &
-           ch4_ebul_depth_unsat(begc:endc,:), ch4_ebul_total_unsat(begc:endc),&
-           conc_ch4_unsat(begc:endc,:), &    
-           ch4_aere_depth_unsat(begc:endc,:), ch4_oxid_depth_unsat(begc:endc,:))
+         ! calculate CH4 production in each soil layer
+         call ch4_prod (bounds, &
+              num_soilc, filter_soilc, &
+              num_soilp, filter_soilp, &
+              jwt(begc:endc), sat, lake, &
+              soilstate_vars, ch4_vars, dtime, elm_fates)
 
+         ! calculate CH4 oxidation in each soil layer
+         call ch4_oxid (bounds, &
+              num_soilc, filter_soilc, &
+              jwt(begc:endc), sat, lake, &
+              soilstate_vars, ch4_vars, dtime)
 
-      ! Solve CH4 reaction/diffusion equation
-      ! Competition for oxygen will occur here.
-      call ch4_tran (bounds, &
-           num_soilc, filter_soilc, &
-           jwt(begc:endc), dtime_mod, sat, lake, &
-           soilstate_vars, energyflux_vars, ch4_vars, dtime_mod,&
-           o2_decomp_depth_unsat(begc:endc,:), o2stress_unsat(begc:endc,:), &
-           ch4_oxid_depth_unsat(begc:endc,:) ,& 
-           ch4_prod_depth_unsat(begc:endc,:), ch4_aere_depth_unsat(begc:endc,:), &
-           ch4_surf_aere_unsat(begc:endc) ,&
-           ch4_ebul_depth_unsat(begc:endc,:) ,&
-           ch4_ebul_total_unsat(begc:endc) ,&
-           ch4_surf_ebul_unsat(begc:endc) ,&   
-           ch4_surf_diff_unsat(begc:endc), o2_oxid_depth_unsat(begc:endc,:), &
-           o2_aere_depth_unsat(begc:endc,:), & 
-           ch4stress_unsat(begc:endc,:), co2_decomp_depth_unsat(begc:endc,:), &
-           conc_ch4_unsat(begc:endc,:), conc_o2_unsat(begc:endc,:) &
-           )
-
-      ! Saturated
-      sat = 1 
-      !$acc update device(sat)
-      !$acc parallel loop independent gang vector default(present)
-      do fc = 1, num_soilc
-         c = filter_soilc(fc)
-         jwt(c) = 0
-      end do
+         ! calculate CH4 aerenchyma losses in each soil layer
+         call ch4_aere (bounds, &
+              num_soilc, filter_soilc, &
+              num_soilp, filter_soilp, &
+              jwt(begc:endc), sat, lake, &
+              canopystate_vars, soilstate_vars, energyflux_vars, ch4_vars, dtime, elm_fates)
 
-      ! calculate CH4 production in each soil layer
-      call ch4_prod (bounds, &
-           num_soilc, filter_soilc, &
-           num_soilp, filter_soilp, &
-           jwt(begc:endc), sat, lake, &
-           soilstate_vars, ch4_vars, dtime_mod, &
-           conc_o2_sat(begc:endc,:), &
-           ch4_prod_depth_sat(begc:endc,:),&
-           o2_decomp_depth_sat(begc:endc,:), &
-           co2_decomp_depth_sat(begc:endc,:) &
-           )
-
-      ! calculate CH4 oxidation in each soil layer
-      call ch4_oxid (bounds, &
-           num_soilc, filter_soilc, &
-           jwt(begc:endc), sat, lake, &
-           soilstate_vars, dtime_mod,&
-           ch4_oxid_depth_sat(begc:endc,:), o2_oxid_depth_sat(begc:endc,:),&
-           co2_oxid_depth_sat(begc:endc,:), &   
-           conc_ch4_sat(begc:endc,:), conc_o2_sat(begc:endc,:), &
-           o2_decomp_depth_sat(begc:endc,:) )
-
-      ! calculate CH4 aerenchyma losses in each soil layer
-      call ch4_aere (bounds, &
-           num_soilc, filter_soilc, &
-           num_soilp, filter_soilp, &
-           jwt(begc:endc), sat, lake, &
-           canopystate_vars, soilstate_vars, energyflux_vars, ch4_vars,dtime_mod, &
-           ch4_aere_depth_sat(begc:endc,:), &
-           ch4_tran_depth_sat(begc:endc,:),&
-           o2_aere_depth_sat(begc:endc,:), &
-           co2_aere_depth_sat(begc:endc,:), & 
-           conc_ch4_sat(begc:endc,:), &
-           conc_o2_sat(begc:endc,:), &
-           ch4_oxid_depth_sat(begc:endc,:), &
-           ch4_prod_depth_sat(begc:endc,:))
-      
-      ! calculate CH4 ebullition losses in each soil layer
-      call ch4_ebul (bounds, &
-           num_soilc, filter_soilc, &
-           jwt(begc:endc), sat, lake, &
-           lakestate_vars, soilstate_vars, ch4_vars, dtime_mod, &
-           ch4_ebul_depth_sat(begc:endc,:), &
-           ch4_ebul_total_sat(begc:endc), &
-           conc_ch4_sat(begc:endc,:), &    
-           ch4_aere_depth_sat(begc:endc,:), &
-           ch4_oxid_depth_sat(begc:endc,:))
-      
-      ! Solve CH4 reaction/diffusion equation
-      ! Competition for oxygen will occur here.
-      call ch4_tran (bounds, &
-           num_soilc, filter_soilc, &
-           jwt(begc:endc), dtime_mod, sat, lake, &
-           soilstate_vars, energyflux_vars, ch4_vars, dtime_mod, &
-           o2_decomp_depth_sat(begc:endc,:), &
-           o2stress_sat(begc:endc,:), &
-           ch4_oxid_depth_sat(begc:endc,:),& 
-           ch4_prod_depth_sat(begc:endc,:), &
-           ch4_aere_depth_sat(begc:endc,:), &
-           ch4_surf_aere_sat(begc:endc), &
-           ch4_ebul_depth_sat(begc:endc,:),&
-           ch4_ebul_total_sat(begc:endc),&
-           ch4_surf_ebul_sat(begc:endc), &   
-           ch4_surf_diff_sat(begc:endc), &
-           o2_oxid_depth_sat(begc:endc,:), &
-           o2_aere_depth_sat(begc:endc,:), & 
-           ch4stress_sat(begc:endc,:), &
-           co2_decomp_depth_sat(begc:endc,:), &
-           conc_ch4_sat(begc:endc,:), &
-           conc_o2_sat(begc:endc,:) &
-           )
+         ! calculate CH4 ebullition losses in each soil layer
+         call ch4_ebul (bounds, &
+              num_soilc, filter_soilc, &
+              jwt(begc:endc), sat, lake, &
+              atm2lnd_vars, lakestate_vars, soilstate_vars, ch4_vars, dtime)
+
+         ! Solve CH4 reaction/diffusion equation
+         ! Competition for oxygen will occur here.
+         call ch4_tran (bounds, &
+              num_soilc, filter_soilc, &
+              jwt(begc:endc), dtime_ch4, sat, lake, &
+              soilstate_vars, energyflux_vars, ch4_vars, dtime)
+
+      enddo ! sat/unsat
 
       !-------------------------------------------------
       ! Now do over lakes
@@ -1856,8 +1717,6 @@ contains
       if (allowlakeprod) then
          lake = .true.
          sat = 1
-         !$acc update device(lake,sat)
-         !$acc parallel loop independent gang vector default(present)
          do fc = 1, num_lakec
             c = filter_lakec(fc)
             jwt(c) = 0
@@ -1867,68 +1726,32 @@ contains
          call ch4_prod (bounds, &
               num_lakec, filter_lakec, &
               0, dummyfilter, jwt(begc:endc), sat, lake, &
-              soilstate_vars, ch4_vars, dtime_mod, &
-              conc_o2_sat(begc:endc,:), ch4_prod_depth_sat(begc:endc,:), &
-              o2_decomp_depth_sat(begc:endc,:), co2_decomp_depth_sat(begc:endc,:) &
-              )
+              soilstate_vars, ch4_vars, dtime, elm_fates)
 
          ! calculate CH4 oxidation in each lake layer
          call ch4_oxid (bounds, &
               num_lakec, filter_lakec, &
-              jwt(begc:endc), sat, lake, soilstate_vars, dtime_mod,&
-              ch4_oxid_depth_sat(begc:endc,:), o2_oxid_depth_sat(begc:endc,:), &
-              co2_oxid_depth_sat(begc:endc,:), &   
-              conc_ch4_sat(begc:endc,:), &
-              conc_o2_sat(begc:endc,:), &
-              o2_decomp_depth_sat(begc:endc,:) )
+              jwt(begc:endc), sat, lake, soilstate_vars, ch4_vars, dtime)
 
          ! calculate CH4 aerenchyma losses in each lake layer
          ! The p filter will not be used here; the relevant column vars will just be set to 0.
          call ch4_aere (bounds, &
               num_lakec, filter_lakec, &
               0, dummyfilter, jwt(begc:endc), sat, lake, &
-              canopystate_vars, soilstate_vars, energyflux_vars, ch4_vars, dtime_mod, &
-              ch4_aere_depth_sat(begc:endc,:), &
-              ch4_tran_depth_sat(begc:endc,:), &
-              o2_aere_depth_sat(begc:endc,:), &
-              co2_aere_depth_sat(begc:endc,:), &
-              conc_ch4_sat(begc:endc,:), &
-              conc_o2_sat(begc:endc,:), &
-              ch4_oxid_depth_sat(begc:endc,:), &
-              ch4_prod_depth_sat(begc:endc,:))
+              canopystate_vars, soilstate_vars, energyflux_vars, ch4_vars, dtime, elm_fates)
 
          ! calculate CH4 ebullition losses in each lake layer
          call ch4_ebul (bounds, &
               num_lakec, filter_lakec, &
               jwt(begc:endc), sat, lake, &
-              lakestate_vars, soilstate_vars,ch4_vars, dtime_mod, &
-              ch4_ebul_depth_sat(begc:endc,:), &
-              ch4_ebul_total_sat(begc:endc), &
-              conc_ch4_sat(begc:endc,:), &    
-              ch4_aere_depth_sat(begc:endc,:), &
-              ch4_oxid_depth_sat(begc:endc,:))
+              atm2lnd_vars, lakestate_vars, soilstate_vars,ch4_vars, dtime)
 
          ! Solve CH4 reaction/diffusion equation
          ! Competition for oxygen will occur here.
          call ch4_tran (bounds, &
               num_lakec, filter_lakec, &
-              jwt(begc:endc), dtime_mod, sat, lake, &
-              soilstate_vars, energyflux_vars, ch4_vars, dtime_mod, &
-              o2_decomp_depth_sat(begc:endc,:), &
-              o2stress_sat(begc:endc,:), &
-              ch4_oxid_depth_sat(begc:endc,:),& 
-              ch4_prod_depth_sat(begc:endc,:), &
-              ch4_aere_depth_sat(begc:endc,:), ch4_surf_aere_sat(begc:endc), &
-              ch4_ebul_depth_sat(begc:endc,:),ch4_ebul_total_sat(begc:endc), &
-              ch4_surf_ebul_sat(begc:endc), &   
-              ch4_surf_diff_sat(begc:endc), &
-              o2_oxid_depth_sat(begc:endc,:), &
-              o2_aere_depth_sat(begc:endc,:), & 
-              ch4stress_sat(begc:endc,:), &
-              co2_decomp_depth_sat(begc:endc,:), &
-              conc_ch4_sat(begc:endc,:),&
-              conc_o2_sat(begc:endc,:) &
-              )
+              jwt(begc:endc), dtime_ch4, sat, lake, &
+              soilstate_vars, energyflux_vars, ch4_vars, dtime)
 
       end if
 
@@ -1937,39 +1760,36 @@ contains
       !-------------------------------------------------
 
       ! First weight the soil columns by finundated.
-      !$acc parallel loop independent gang worker default(present) private(totalsat, totalunsat,sum1,sum2)
-      do fc = 1, num_soilc
-         c = filter_soilc(fc)
-         
-         totalsat = ch4_surf_diff_sat(c) + ch4_surf_aere_sat(c) + ch4_surf_ebul_sat(c)
-         totalunsat = ch4_surf_diff_unsat(c) + ch4_surf_aere_unsat(c) + ch4_surf_ebul_unsat(c)
-         ch4_surf_flux_tot(c) = (finundated(c)*totalsat + (1._r8 - finundated(c))*totalunsat) * catomw / 1000._r8
-
-         !Convert from mol to kg C
-         ! ch4_oxid_tot and ch4_prod_tot are initialized to zero above 
-         sum1 = 0._r8 
-         sum2 = 0._r8
-         !$acc loop vector reduction(+:sum1,sum2)
-         do j=1,nlevsoi
+      do j=1,nlevsoi
+         do fc = 1, num_soilc
+            c = filter_soilc(fc)
 
-            sum1 = sum1 + (finundated(c)*ch4_oxid_depth_sat(c,j) + &
+            if (j == 1) then
+               totalsat = ch4_surf_diff_sat(c) + ch4_surf_aere_sat(c) + ch4_surf_ebul_sat(c)
+               totalunsat = ch4_surf_diff_unsat(c) + ch4_surf_aere_unsat(c) + ch4_surf_ebul_unsat(c)
+               ch4_surf_flux_tot(c) = (finundated(c)*totalsat + (1._r8 - finundated(c))*totalunsat) * &
+                    catomw / 1000._r8
+               !Convert from mol to kg C
+               ! ch4_oxid_tot and ch4_prod_tot are initialized to zero above
+            end if
+
+            ch4_oxid_tot(c) = ch4_oxid_tot(c) + (finundated(c)*ch4_oxid_depth_sat(c,j) + &
                  (1._r8 - finundated(c))*ch4_oxid_depth_unsat(c,j))*dz(c,j) * catomw
             !Convert from mol to g C
-            sum2 = sum2 + (finundated(c)*ch4_prod_depth_sat(c,j) + &
+            ch4_prod_tot(c) = ch4_prod_tot(c) + (finundated(c)*ch4_prod_depth_sat(c,j) + &
                  (1._r8 - finundated(c))*ch4_prod_depth_unsat(c,j))*dz(c,j) * catomw
-
+            !Convert from mol to g C
+            if (j == nlevsoi) then
+               ! Adjustment to NEE flux to atm. for methane production
+               nem_col(c) = nem_col(c) - ch4_prod_tot(c)
+               ! Adjustment to NEE flux to atm. for methane oxidation
+               nem_col(c) = nem_col(c) + ch4_oxid_tot(c)
+            end if
          end do
-         ch4_oxid_tot(c) = sum1
-         ch4_prod_tot(c) = sum2  
-         ! Adjustment to NEE flux to atm. for methane production
-         nem_col(c) = nem_col(c) - ch4_prod_tot(c)
-         ! Adjustment to NEE flux to atm. for methane oxidation
-         nem_col(c) = nem_col(c) + ch4_oxid_tot(c)
       end do
 
       ! Correct for discrepancies in CH4 concentration from changing finundated
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_soilc
          c = filter_soilc(fc)
 
@@ -1980,145 +1800,117 @@ contains
       end do
 
       if (allowlakeprod) then
-         !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-         do fc = 1, num_lakec
-            c = filter_lakec(fc)
-            ! ch4_oxid_tot and ch4_prod_tot are initialized to zero above
-            totalsat = ch4_surf_diff_sat(c) + ch4_surf_aere_sat(c) + ch4_surf_ebul_sat(c)
-            ch4_surf_flux_tot(c) = totalsat*catomw / 1000._r8
+         do j=1,nlevsoi
+            do fc = 1, num_lakec
+               c = filter_lakec(fc)
 
-            ch4_surf_diff_lake(c) = ch4_surf_diff_sat(c)
-            ch4_surf_ebul_lake(c) = ch4_surf_ebul_sat(c)
-            
-            sum1 = 0._r8
-            sum2 = 0._r8 
-            !$acc loop vector reduction(+:sum1,sum2)
-            do j=1,nlevsoi
-               sum1 = sum1 + ch4_oxid_depth_sat(c,j)*dz(c,j)*catomw
-               sum2 = sum2 + ch4_prod_depth_sat(c,j)*dz(c,j)*catomw
-            end do 
-
-            ch4_oxid_tot(c) = ch4_oxid_tot(c) + sum1
-            ch4_prod_tot(c) = ch4_prod_tot(c) + sum2
-
-            ! Adjustment to NEE flux to atm. for methane production
-            if (.not. replenishlakec) then
-               nem_col(c) = nem_col(c) + ch4_prod_tot(c)
-               ! Here this is positive because it is actually the CO2 that comes off with the methane
-               ! NOTE THIS MODE ASSUMES TRANSIENT CARBON SUPPLY FROM LAKES; COUPLED MODEL WILL NOT CONSERVE CARBON
-               ! IN THIS MODE.
-            else ! replenishlakec
-               nem_col(c) = nem_col(c) - ch4_prod_tot(c)
-               ! Keep total C constant, just shift from CO2 to methane
-            end if
+               if (j == 1) then
+                  ! ch4_oxid_tot and ch4_prod_tot are initialized to zero above
+                  totalsat = ch4_surf_diff_sat(c) + ch4_surf_aere_sat(c) + ch4_surf_ebul_sat(c)
+                  ch4_surf_flux_tot(c) = totalsat*catomw / 1000._r8
+               end if
 
-            ! Adjustment to NEE flux to atm. for methane oxidation
-            nem_col(c) = nem_col(c) + ch4_oxid_tot(c)
-         end do
+               ch4_oxid_tot(c) = ch4_oxid_tot(c) + ch4_oxid_depth_sat(c,j)*dz(c,j)*catomw
+               ch4_prod_tot(c) = ch4_prod_tot(c) + ch4_prod_depth_sat(c,j)*dz(c,j)*catomw
 
-         !$acc parallel loop independent gang vector collapse(2) default(present) 
-         do j=1,nlevsoi 
-            do fc = 1, num_lakec 
-               c = filter_lakec(fc) 
                if (.not. replenishlakec) then
                   !Adjust lake_soilc for production.
-                  lake_soilc(c,j) = lake_soilc(c,j) - 2._r8*ch4_prod_depth_sat(c,j)*dtime_mod*catomw
+                  lake_soilc(c,j) = lake_soilc(c,j) - 2._r8*ch4_prod_depth_sat(c,j)*dtime*catomw
                   ! Factor of 2 is for CO2 that comes off with CH4 because of stoichiometry
                end if
+
+               if (j == nlevsoi) then
+                  ! Adjustment to NEE flux to atm. for methane production
+                  if (.not. replenishlakec) then
+                     nem_col(c) = nem_col(c) + ch4_prod_tot(c)
+                     ! Here this is positive because it is actually the CO2 that comes off with the methane
+                     ! NOTE THIS MODE ASSUMES TRANSIENT CARBON SUPPLY FROM LAKES; COUPLED MODEL WILL NOT CONSERVE CARBON
+                     ! IN THIS MODE.
+                  else ! replenishlakec
+                     nem_col(c) = nem_col(c) - ch4_prod_tot(c)
+                     ! Keep total C constant, just shift from CO2 to methane
+                  end if
+
+                  ! Adjustment to NEE flux to atm. for methane oxidation
+                  nem_col(c) = nem_col(c) + ch4_oxid_tot(c)
+
+               end if
+
+
                !Set lake diagnostic output variables
                ch4_prod_depth_lake(c,j) = ch4_prod_depth_sat(c,j)
                conc_ch4_lake(c,j)       = conc_ch4_sat(c,j)
                conc_o2_lake(c,j)        = conc_o2_sat(c,j)
                ch4_oxid_depth_lake(c,j) = ch4_oxid_depth_sat(c,j)
-            end do 
-         end do 
+               if (j == 1) then
+                  ch4_surf_diff_lake(c) = ch4_surf_diff_sat(c)
+                  ch4_surf_ebul_lake(c) = ch4_surf_ebul_sat(c)
+               end if
 
+            end do
+         end do
       end if  ! ch4_surf_flux_tot, ch4_oxid_tot, and ch4_prod_tot should be initialized to 0 above if .not. allowlakeprod
 
       ! Finalize CH4 balance and check for errors
-      erridx = 0 
-      !$acc parallel loop independent gang worker default(present) private(sum1) copy(erridx)
-      do fc = 1, num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8
-
-         !$acc loop vector reduction(+:sum1) 
-         do j=1,nlevsoi
-            sum1 = sum1 + (finundated(c)*conc_ch4_sat(c,j) + (1._r8-finundated(c))*conc_ch4_unsat(c,j))*dz(c,j)*catomw
-            ! mol CH4 --> g C
-         end do
-         totcolch4(c) = totcolch4(c) + sum1 
-
-         if (totsoilcolch4_bef(fc) /= spval) then ! not first timestep
-            ! Check balance
-            errch4 = totcolch4(c) - totsoilcolch4_bef(fc) - dtime_mod*(ch4_prod_tot(c) - ch4_oxid_tot(c) &
-                 - ch4_surf_flux_tot(c)*1000._r8) ! kg C --> g C
-            
-            if (abs(errch4) > 1.e-7_r8) then ! g C / m^2 / timestep
-               erridx = c
-            end if
-         end if
-      end do 
-      if(erridx > 0) then 
-         c = erridx 
-         g = col_pp%gridcell(erridx)
-         write(iulog, *) 'CH4 Conservation Error in CH4Mod driver, nstep, c, errch4 (gC /m^2.timestep)',nstep,c
-         write(iulog,*) 'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
-         ! call endrun(msg=' ERROR: Methane conservation error'//errMsg(__FILE__, __LINE__))
-      end if 
 
-      if (allowlakeprod) then
-         erridx = 0
-         !$acc parallel loop independent gang worker default(present) private(sum1,errch4) copy(erridx)
-         do fc = 1, num_lakec
-            c = filter_lakec(fc)
-            sum1 = 0._r8
+      do j=1,nlevsoi
+         do fc = 1, num_soilc
+            c = filter_soilc(fc)
 
-            !$acc loop vector reduction(+:sum1) 
-            do j=1,nlevsoi
-               sum1 = sum1 + conc_ch4_sat(c,j)*dz(c,j)*catomw ! mol CH4 --> g C
-            end do 
-            totcolch4(c) = totcolch4(c) + sum1 
+            totcolch4(c) = totcolch4(c) + &
+                 (finundated(c)*conc_ch4_sat(c,j) + (1._r8-finundated(c))*conc_ch4_unsat(c,j))*dz(c,j)*catomw
+            ! mol CH4 --> g C
 
-            if (totlakecolch4_bef(fc) /= spval) then ! not first timestep
+            if (j == nlevsoi .and. totcolch4_bef(c) /= spval) then ! not first timestep
                ! Check balance
-               errch4 = totcolch4(c) - totlakecolch4_bef(fc) - dtime_mod*(ch4_prod_tot(c) - ch4_oxid_tot(c) &
+               errch4 = totcolch4(c) - totcolch4_bef(c) - dtime*(ch4_prod_tot(c) - ch4_oxid_tot(c) &
                     - ch4_surf_flux_tot(c)*1000._r8) ! kg C --> g C
                if (abs(errch4) > 1.e-7_r8) then ! g C / m^2 / timestep
-                  erridx = c 
+                  write(iulog, *) 'CH4 Conservation Error in CH4Mod driver, nstep, c, errch4 (gC /m^2.timestep)',&
+                       nstep,c,errch4
+                  g = col_pp%gridcell(c)
+                  write(iulog,*) 'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
+                  call endrun(msg=' ERROR: Methane conservation error'//errMsg(__FILE__, __LINE__))
                end if
             end if
+
          end do
-         if(erridx > 0) then 
-            c = erridx 
-            g = col_pp%gridcell(c)
-            write(iulog,*)'CH4 Conservation Error in CH4Mod driver for lake column, nstep, c, errch4 (gC/m^2.timestep)',nstep,c
-            write(iulog,*) 'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
-            ! call endrun(msg=' ERROR: Methane conservation error, allowlakeprod'//errMsg(__FILE__, __LINE__))
-         end if 
+         if (allowlakeprod) then
+            do fc = 1, num_lakec
+               c = filter_lakec(fc)
+
+               totcolch4(c) = totcolch4(c) + conc_ch4_sat(c,j)*dz(c,j)*catomw ! mol CH4 --> g C
+
+               if (j == nlevsoi .and. totcolch4_bef(c) /= spval) then ! not first timestep
+                  ! Check balance
+                  errch4 = totcolch4(c) - totcolch4_bef(c) - dtime*(ch4_prod_tot(c) - ch4_oxid_tot(c) &
+                       - ch4_surf_flux_tot(c)*1000._r8) ! kg C --> g C
+                  if (abs(errch4) > 1.e-7_r8) then ! g C / m^2 / timestep
+                     write(iulog,*)'CH4 Conservation Error in CH4Mod driver for lake column, nstep, c, errch4 (gC/m^2.timestep)',&
+                           nstep,c,errch4
+                     g = col_pp%gridcell(c)
+                     write(iulog,*) 'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
+                     call endrun(msg=' ERROR: Methane conservation error, allowlakeprod'//&
+                          errMsg(__FILE__, __LINE__))
+                  end if
+               end if
 
-      end if
+            end do
+         end if
+      end do
 
       ! Now average up to gridcell for fluxes
-      call c2g_1d_parallel( bounds, ch4_oxid_tot(begc:endc), ch4co2f(begg:endg),&
-           c2l_scale_type=unity, l2g_scale_type=unity,para=.true.)
-
-      call c2g_1d_parallel( bounds, ch4_prod_tot(begc:endc), ch4prodg(begg:endg),&
-           c2l_scale_type=unity, l2g_scale_type=unity,para=.true.)
-
-      call c2g_1d_parallel( bounds, nem_col(begc:endc), nem_grc(begg:endg), &
-           c2l_scale_type=unity, l2g_scale_type=unity,para=.true.)
-
-    !$acc exit data delete(&
-    !$acc jwt(:), &
-    !$acc ch4_prod_tot(:), &
-    !$acc ch4_oxid_tot(:), &
-    !$acc nem_col(:), &
-    !$acc rootfraction(:,:), &
-    !$acc totsoilcolch4_bef(:), &
-    !$acc totlakecolch4_bef(:), &
-    !$acc dummyfilter(:),sum1,sum2,sum3)
-   !$acc exit data delete(redoxlags,redoxlags_vertical,rgasm, dtime_ch4, lake, sat)
+      call c2g( bounds, &
+           ch4_oxid_tot(begc:endc), ch4co2f(begg:endg),        &
+           c2l_scale_type= 0, l2g_scale_type=0 )
+
+      call c2g( bounds, &
+           ch4_prod_tot(begc:endc), ch4prodg(begg:endg),       &
+           c2l_scale_type= 0, l2g_scale_type=0 )
+
+      call c2g( bounds, &
+           nem_col(begc:endc), nem_grc(begg:endg),               &
+           c2l_scale_type= 0, l2g_scale_type=0 )
 
     end associate
 
@@ -2126,8 +1918,8 @@ contains
 
   !-----------------------------------------------------------------------
   subroutine ch4_prod (bounds, num_methc, filter_methc, num_methp, &
-       filter_methp, jwt, sat, lake, soilstate_vars, ch4_vars, dtime, &
-       conc_o2, ch4_prod_depth, o2_decomp_depth, co2_decomp_depth )
+       filter_methp, jwt, sat, lake, &
+       soilstate_vars, ch4_vars, dtime, elm_fates)
     !
     ! !DESCRIPTION:
     ! Production is done below the water table, based on CN heterotrophic respiration.
@@ -2136,6 +1928,7 @@ contains
     ! pH (optional), & redox lag factor.
     !
     ! !USES:
+      !$acc routine seq
     use CH4varcon          , only: usephfact, anoxicmicrosites, ch4rmcnlim
     use elm_varctl         , only: anoxia
     use elm_varpar         , only: nlevdecomp, nlevdecomp_full
@@ -2154,39 +1947,60 @@ contains
     type(soilstate_type)    , intent(inout) :: soilstate_vars
     type(ch4_type)          , intent(inout) :: ch4_vars
     real(r8), intent(in) :: dtime
-    real(r8), intent(inout) :: conc_o2(:,:)           ! Input:  [real(r8) (:,:)]  O2 conc in each soil layer (mol/m3) (nlevsoi)
-    real(r8), intent(inout) :: ch4_prod_depth(:,:)    ! Output: [real(r8) (:,:)]  production of CH4 in each soil layer (nlevsoi) (mol/m3/s)
-    real(r8), intent(inout) :: o2_decomp_depth(:,:)   ! Output: [real(r8) (:,:)]  O2 consumption during decomposition in each soil layer (nlevsoi) (mol/m3/s)
-    real(r8), intent(inout) :: co2_decomp_depth(:,:)  ! Output: [real(r8) (:,:)]  CO2 production during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+    type(hlm_fates_interface_type), intent(inout) :: elm_fates
+    
     !
     ! !LOCAL VARIABLES:
-    integer  :: p,c,j,g        ! indices
-    integer  :: fc             ! column index
-    integer  :: fp             ! PATCH index
-    real(r8) :: base_decomp    ! base rate (mol/m2/s)
-    real(r8) :: q10lake          
-    real(r8) :: partition_z      
-    real(r8) :: pH_fact_ch4    ! pH factor in methane production
+    integer  :: p,c,j,g,s        ! indices
+    integer  :: nc
+    integer  :: fc               ! column index
+    integer  :: fp               ! PATCH index
+    real(r8) :: base_decomp      ! base rate (mol/m2/s)
+    real(r8) :: q10lake          ! For now, take to be the same as q10ch4 * 1.5.
+    real(r8) :: q10lakebase      ! (K) base temperature for lake CH4 production
+    real(r8) :: partition_z
+    real(r8) :: mino2lim         ! minimum anaerobic decomposition rate as a fraction of potential aerobic rate
+    real(r8) :: q10ch4           ! additional Q10 for methane production ABOVE the soil decomposition temperature relationship
+    real(r8) :: q10ch4base       ! temperature at which the effective f_ch4 actually equals the constant f_ch4
+    real(r8) :: f_ch4            ! ratio of CH4 production to total C mineralization
+    real(r8) :: rootlitfrac      ! Fraction of soil organic matter associated with roots
+    real(r8) :: cnscalefactor    ! scale factor on CN decomposition for assigning methane flux
+    real(r8) :: lake_decomp_fact ! Base decomposition rate (1/s) at 25C
+
+    ! added by Lei Meng to account for pH influence of CH4 production
+    real(r8) :: pHmax
+    real(r8) :: pHmin
+    real(r8) :: pH_fact_ch4      ! pH factor in methane production
+
     ! Factors for methanogen temperature dependence being greater than soil aerobes
-    real(r8) :: f_ch4_adj      ! Adjusted f_ch4
-    real(r8) :: t_fact_ch4     ! Temperature factor calculated using additional Q10
+    real(r8)            :: f_ch4_adj                      ! Adjusted f_ch4
+    real(r8)            :: t_fact_ch4                     ! Temperature factor calculated using additional Q10
     ! O2 limitation on decomposition and methanogenesis
-    real(r8) :: seasonalfin    ! finundated in excess of respiration-weighted annual average
+    real(r8)            :: seasonalfin                    ! finundated in excess of respiration-weighted annual average
+    real(r8)            :: oxinhib                        ! inhibition of methane production by oxygen (m^3/mol)
+
     ! For calculating column average (rootfrac(p,j)*rr(p,j))
-    real(r8) :: rr_vr(1:num_methc, 1:nlevsoi) ! vertically resolved column-mean root respiration (g C/m^2/s)
-    real(r8) :: sum1 
+    real(r8) :: rr_vr(bounds%begc:bounds%endc, 1:nlevsoi) ! vertically resolved column-mean root respiration (g C/m^2/s)
+    real(r8), pointer :: ch4_prod_depth(:,:)              ! backwards compatibility
+    real(r8), pointer :: o2_decomp_depth(:,:)             ! backwards compatibility
+    real(r8), pointer :: co2_decomp_depth(:,:)            ! backwards compatibility
+    real(r8), pointer :: conc_o2(:,:)                     ! backwards compatibility
+
     !-----------------------------------------------------------------------
-    associate(                                        &
-         wtcol          =>    veg_pp%wtcol          , & ! Input:  [real(r8) (:)    ]  weight (relative to column)
-         dz             =>    col_pp%dz             , & ! Input:  [real(r8) (:,:)  ]  layer thickness (m)  (-nlevsno+1:nlevsoi)
-         z              =>    col_pp%z              , & ! Input:  [real(r8) (:,:)  ]  layer depth (m) (-nlevsno+1:nlevsoi)
-         zi             =>    col_pp%zi             , & ! Input:  [real(r8) (:,:)  ]  interface level below a "z" level (m)
- 
-         t_soisno       =>    col_es%t_soisno       , & ! Input:  [real(r8) (:,:)  ]  soil temperature (Kelvin)  (-nlevsno+1:nlevsoi)
+
+    ! Enforce expected array sizes
+
+    associate(                                                     &
+         wtcol          =>    veg_pp%wtcol                          , & ! Input:  [real(r8) (:)    ]  weight (relative to column)
+         dz             =>    col_pp%dz                             , & ! Input:  [real(r8) (:,:)  ]  layer thickness (m)  (-nlevsno+1:nlevsoi)
+         z              =>    col_pp%z                              , & ! Input:  [real(r8) (:,:)  ]  layer depth (m) (-nlevsno+1:nlevsoi)
+         zi             =>    col_pp%zi                             , & ! Input:  [real(r8) (:,:)  ]  interface level below a "z" level (m)
+
+         t_soisno       =>    col_es%t_soisno      , & ! Input:  [real(r8) (:,:)  ]  soil temperature (Kelvin)  (-nlevsno+1:nlevsoi)
 
          h2osoi_vol     =>    col_ws%h2osoi_vol     , & ! Input:  [real(r8) (:,:)  ]  volumetric soil water (0<=h2osoi_vol<=watsat) [m3/m3]
 
-         rr             =>    veg_cf%rr             , & ! Input:  [real(r8) (:)    ]  (gC/m2/s) root respiration (fine root MR + total root GR)
+         rr             =>    veg_cf%rr           , & ! Input:  [real(r8) (:)    ]  (gC/m2/s) root respiration (fine root MR + total root GR)
          somhr          =>    col_cf%somhr          , & ! Input:  [real(r8) (:)    ]  (gC/m2/s) soil organic matter heterotrophic respiration
          lithr          =>    col_cf%lithr          , & ! Input:  [real(r8) (:)    ]  (gC/m2/s) litter heterotrophic respiration
          hr_vr          =>    col_cf%hr_vr          , & ! Input:  [real(r8) (:,:)  ]  total vertically-resolved het. resp. from decomposing C pools (gC/m3/s)
@@ -2196,74 +2010,93 @@ contains
 
          pot_f_nit_vr   =>    col_nf%pot_f_nit_vr , & ! Input:  [real(r8) (:,:)  ]  (gN/m3/s) potential soil nitrification flux
 
-         watsat         =>    soilstate_vars%watsat_col      , & ! Input:  [real(r8) (:,:)  ]  volumetric soil water at saturation (porosity)
-         rootfr         =>    soilstate_vars%rootfr_patch    , & ! Input:  [real(r8) (:,:)  ]  fraction of roots in each soil layer  (nlevsoi)
-         rootfr_col     =>    soilstate_vars%rootfr_col      , & ! Input:  [real(r8) (:,:)  ]  fraction of roots in each soil layer  (nlevsoi)
-
-         finundated     =>    ch4_vars%finundated_col        , & ! Input:  [real(r8) (:)    ]  fractional inundated area in soil column
-         pH             =>    ch4_vars%pH_col                , & ! Input:  [real(r8) (:)    ]  soil water pH
-         lake_soilc     =>    ch4_vars%lake_soilc_col        , & ! Input:  [real(r8) (:,:)  ]  total soil organic matter found in level (g C / m^3) (nlevsoi)
-         annavg_finrw   =>    ch4_vars%annavg_finrw_col      , & ! Input:  [real(r8) (:)    ]  respiration-weighted annual average of finundated
-         finundated_lag =>    ch4_vars%finundated_lag_col    , & ! Input:  [real(r8) (:)    ]  time-lagged fractional inundated area
-         layer_sat_lag  =>    ch4_vars%layer_sat_lag_col     , & ! Input:  [real(r8) (: ,:) ]  Lagged saturation status of soil layer in the unsaturated zone (1 = sat)
-         sif            =>    ch4_vars%sif_col               , & ! Output: [real(r8) (:)    ]  (unitless) ratio applied to sat. prod. to account for seasonal inundation
-         q10ch4           => CH4ParamsInst%q10ch4      , &  ! additional Q10 for methane production ABOVE the soil decomposition temperature relationship
-         q10ch4base       => CH4ParamsInst%q10ch4base  , &  ! temperature at which the effective f_ch4 actually equals the constant f_ch4
-         f_ch4            => CH4ParamsInst%f_ch4       , &  ! ratio of CH4 production to total C mineralization
-         rootlitfrac      => CH4ParamsInst%rootlitfrac , &  ! Fraction of soil organic matter associated with roots
-         cnscalefactor    => CH4ParamsInst%cnscalefactor, & ! scale factor on CN decomposition for assigning methane flux
-         lake_decomp_fact => CH4ParamsInst%lake_decomp_fact , & ! Base decomposition rate (1/s) at 25C
-         ! added by Lei Meng to account for pH influence of CH4 production
-         pHmax            => CH4ParamsInst%pHmax , &
-         pHmin            => CH4ParamsInst%pHmin , &
-         oxinhib          => CH4ParamsInst%oxinhib , &    ! inhibition of methane production by oxygen (m^3/mol)
-         q10lakebase      => CH4ParamsInst%q10lakebase ,& ! (K) base temperature for lake CH4 production
-         ! Shared constant with other modules
-         mino2lim => ParamsShareInst%mino2lim & ! minimum anaerobic decomposition rate as a fraction of potential aerobic rate
+         watsat         =>    soilstate_vars%watsat_col          , & ! Input:  [real(r8) (:,:)  ]  volumetric soil water at saturation (porosity)
+         rootfr         =>    soilstate_vars%rootfr_patch        , & ! Input:  [real(r8) (:,:)  ]  fraction of roots in each soil layer  (nlevsoi)
+         rootfr_col     =>    soilstate_vars%rootfr_col          , & ! Input:  [real(r8) (:,:)  ]  fraction of roots in each soil layer  (nlevsoi)
+
+         finundated     =>    ch4_vars%finundated_col            , & ! Input:  [real(r8) (:)    ]  fractional inundated area in soil column
+         pH             =>    ch4_vars%pH_col                    , & ! Input:  [real(r8) (:)    ]  soil water pH
+         lake_soilc     =>    ch4_vars%lake_soilc_col            , & ! Input:  [real(r8) (:,:)  ]  total soil organic matter found in level (g C / m^3) (nlevsoi)
+         annavg_finrw   =>    ch4_vars%annavg_finrw_col          , & ! Input:  [real(r8) (:)    ]  respiration-weighted annual average of finundated
+         finundated_lag =>    ch4_vars%finundated_lag_col        , & ! Input:  [real(r8) (:)    ]  time-lagged fractional inundated area
+         layer_sat_lag  =>    ch4_vars%layer_sat_lag_col         , & ! Input:  [real(r8) (: ,:) ]  Lagged saturation status of soil layer in the unsaturated zone (1 = sat)
+         sif            =>    ch4_vars%sif_col                     & ! Output: [real(r8) (:)    ]  (unitless) ratio applied to sat. prod. to account for seasonal inundation
          )
 
-      !$acc enter data create(&
-      !$acc rr_vr(:,:), &
-      !$acc base_decomp, &
-      !$acc f_ch4_adj)
-
-      q10lake = q10ch4 * 1.5_r8 ! For now, take to be the same as q10ch4 * 1.5.
-      !$acc enter data copyin(q10lake)
+      if (sat == 0) then                                    ! unsaturated
+         conc_o2          => ch4_vars%conc_o2_unsat_col          ! Input:  [real(r8) (:,:)]  O2 conc in each soil layer (mol/m3) (nlevsoi)
+         ch4_prod_depth   => ch4_vars%ch4_prod_depth_unsat_col   ! Output: [real(r8) (:,:)]  production of CH4 in each soil layer (nlevsoi) (mol/m3/s)
+         o2_decomp_depth  => ch4_vars%o2_decomp_depth_unsat_col  ! Output: [real(r8) (:,:)]  O2 consumption during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+         co2_decomp_depth => ch4_vars%co2_decomp_depth_unsat_col ! Output: [real(r8) (:,:)]  CO2 production during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+      else                                                  ! saturated
+         conc_o2          => ch4_vars%conc_o2_sat_col            ! Input:  [real(r8) (:,:)]  O2 conc in each soil layer (mol/m3) (nlevsoi)
+         ch4_prod_depth   => ch4_vars%ch4_prod_depth_sat_col     ! Output: [real(r8) (:,:)]  production of CH4 in each soil layer (nlevsoi) (mol/m3/s)
+         o2_decomp_depth  => ch4_vars%o2_decomp_depth_sat_col    ! Output: [real(r8) (:,:)]  O2 consumption during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+         co2_decomp_depth => ch4_vars%co2_decomp_depth_sat_col   ! Output: [real(r8) (:,:)]  CO2 production during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+      endif
+
+      q10ch4           = CH4ParamsInst%q10ch4
+      q10ch4base       = CH4ParamsInst%q10ch4base
+      f_ch4            = CH4ParamsInst%f_ch4
+      rootlitfrac      = CH4ParamsInst%rootlitfrac
+      cnscalefactor    = CH4ParamsInst%cnscalefactor
+      lake_decomp_fact = CH4ParamsInst%lake_decomp_fact
+      pHmax            = CH4ParamsInst%pHmax
+      pHmin            = CH4ParamsInst%pHmin
+      oxinhib          = CH4ParamsInst%oxinhib
+      q10lakebase      = CH4ParamsInst%q10lakebase
+
+      ! Shared constant with other modules
+      mino2lim = ParamsShareInst%mino2lim
+
+      q10lake = q10ch4 * 1.5_r8
 
       ! PATCH loop to calculate vertically resolved column-averaged root respiration
       if (.not. lake) then
-         ! rr_vr(bounds%begc:bounds%endc,:) = spval
+         rr_vr(bounds%begc:bounds%endc,:) = spval
 
-         !$acc parallel loop independent collapse(2) gang worker default(present) private(sum1) 
-         do j=1,nlevsoi
-            do fc = 1, num_methc
-               c = filter_methc(fc)
-               sum1 = 0._r8 
-               !$acc loop vector reduction(+:sum1) 
-               do p = col_pp%pfti(c), col_pp%pftf(c) 
-                  if (wtcol(p) > 0._r8 .and. veg_pp%itype(p) /= noveg) then
-                     sum1 = sum1 + rr(p)*rootfr(p,j)*wtcol(p)
-                  end if
+         do fp = 1, num_methc
+            c = filter_methc(fp)
+            rr_vr(c,:) = 0.0_r8
+         end do
+
+         do fp = 1, num_methp
+            p = filter_methp(fp)
+            c = veg_pp%column(p)
+            if(.not.col_pp%is_fates(c)) then
+               if (wtcol(p) > 0._r8 .and. veg_pp%itype(p) /= noveg) then
+                  do j=1,nlevsoi
+                     rr_vr(c,j) = rr_vr(c,j) + rr(p)*rootfr(p,j)*wtcol(p)
+                  enddo
+               end if
+            end if
+         end do
+         
+         if(use_fates) then
+            nc = bounds%clump_index
+            do s = 1,elm_fates%fates(nc)%nsites 
+               c = elm_fates%f2hmap(nc)%fcolumn(s)
+               do j=1, elm_fates%fates(nc)%bc_in(s)%nlevsoil
+                  rr_vr(c,j) = elm_fates%fates(nc)%bc_out(s)%root_resp(j)
                end do
-               rr_vr(fc,j) = sum1  
             end do
-         end do
-      end if
+            
+         end if
 
+      end if
 
+      partition_z = 1._r8
+      base_decomp = 0.0_r8
 
       ! column loop to partition decomposition_rate into each soil layer
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j=1,nlevsoi
          do fc = 1, num_methc
             c = filter_methc (fc)
             g = col_pp%gridcell(c)
-            partition_z = 1._r8
-            base_decomp = 0.0_r8
-            
+
             if (.not. lake) then
 
-               if (use_cn) then
+               if (use_cn.or. use_fates) then
                   ! Use soil heterotrophic respiration (based on Wania)
                   base_decomp = (somhr(c)+lithr(c)) / catomw
                   ! Convert from gC to molC
@@ -2284,10 +2117,8 @@ contains
                      end if ! anoxia
                   end if
                else
-                  #ifndef _OPENACC 
                   call endrun(msg=' ERROR: No source for decomp rate in CH4Prod.'//&
-                       ' CH4 model currently requires CN.'//errMsg(__FILE__, __LINE__))
-                  #endif 
+                       ' CH4 model currently requires CN or FATES.'//errMsg(__FILE__, __LINE__))
                end if ! use_cn
 
                ! For sensitivity studies
@@ -2378,6 +2209,7 @@ contains
             ! electron acceptors would predict no more than 0.5 b/c some oxygen is present in organic matter.
             ! e.g. 2CH2O --> CH4 + CO2.
 
+
             ! Decomposition uses 1 mol O2 per mol CO2 produced (happens below WT also, to deplete O2 below WT)
             ! o2_decomp_depth is the demand in the absense of O2 supply limitation, in addition to autotrophic respiration.
             ! Competition will be done in ch4_oxid
@@ -2399,7 +2231,7 @@ contains
             ! Add root respiration
             if (.not. lake) then
                !o2_decomp_depth(c,j) = o2_decomp_depth(c,j) + col_rr(c)*rootfr(c,j)/catomw/dz(c,j) ! mol/m^3/s
-               o2_decomp_depth(c,j) = o2_decomp_depth(c,j) + rr_vr(fc,j)/catomw/dz(c,j) ! mol/m^3/s
+               o2_decomp_depth(c,j) = o2_decomp_depth(c,j) + rr_vr(c,j)/catomw/dz(c,j) ! mol/m^3/s
                ! g C/m2/s ! gC/mol O2 ! m
             end if
 
@@ -2425,11 +2257,6 @@ contains
          end do ! fc
       end do ! nlevsoi
 
-      !$acc exit data delete(&
-      !$acc rr_vr(:,:), &
-      !$acc base_decomp, &
-      !$acc f_ch4_adj,q10lake)
-
     end associate
 
   end subroutine ch4_prod
@@ -2437,9 +2264,7 @@ contains
   !-----------------------------------------------------------------------
   subroutine ch4_oxid (bounds, &
        num_methc, filter_methc, &
-       jwt, sat, lake, soilstate_vars, dtime,&
-       ch4_oxid_depth, o2_oxid_depth, co2_oxid_depth, &   
-       conc_ch4, conc_o2, o2_decomp_depth  )
+       jwt, sat, lake, soilstate_vars, ch4_vars, dtime)
     !
     ! !DESCRIPTION:
     ! Oxidation is based on double Michaelis-Mentin kinetics, and is adjusted for low soil moisture.
@@ -2448,6 +2273,7 @@ contains
     ! !USES:
     !
     ! !ARGUMENTS:
+      !$acc routine seq
     type(bounds_type)      , intent(in) :: bounds
     integer                , intent(in) :: num_methc           ! number of column soil points in column filter
     integer                , intent(in) :: filter_methc(:)     ! column filter for soil points
@@ -2455,18 +2281,13 @@ contains
     integer                , intent(in) :: sat                 ! 0 = unsaturated; 1 = saturated
     logical                , intent(in) :: lake                ! function called with lake filter
     type(soilstate_type)   , intent(inout) :: soilstate_vars
+    type(ch4_type)         , intent(in) :: ch4_vars
     real(r8), intent(in) :: dtime                         ! land model time step (sec)
-    real(r8) , intent(inout) :: ch4_oxid_depth(:,:) 
-    real(r8) , intent(inout) :: o2_oxid_depth (:,:) 
-    real(r8) , intent(inout) :: co2_oxid_depth(:,:) 
-    real(r8) , intent(inout) :: conc_ch4(:,:) 
-    real(r8) , intent(inout) :: conc_o2 (:,:) 
-    real(r8) , intent(inout) :: o2_decomp_depth(:,:)
     !
     ! !LOCAL VARIABLES:
     integer :: c,j                            ! indices
     integer :: fc                             ! column index
-    real(r8), parameter :: t0 = tfrz+12._r8 ! Base temperature for Q10  ! Walter, for Michigan site where the 45 M/h comes from
+    real(r8):: t0                             ! Base temperature for Q10
     real(r8):: porevol                        ! air-filled volume ratio to total soil volume
     real(r8):: h2osoi_vol_min                 ! h2osoi_vol restricted to be below watsat
     real(r8):: conc_ch4_rel                   ! concentration with respect to water volume (mol/m^3 water)
@@ -2486,6 +2307,12 @@ contains
     real(r8) :: k_m_unsat                     ! Michaelis-Menten oxidation rate constant for CH4 concentration
     real(r8) :: vmax_oxid_unsat               ! (= 45.e-6_r8 * 1000._r8 / 3600._r8 / 10._r8) [mol/m3-w/s]
     !
+    real(r8), pointer :: ch4_oxid_depth(:,:)
+    real(r8), pointer :: o2_oxid_depth(:,:)
+    real(r8), pointer :: co2_oxid_depth(:,:)
+    real(r8), pointer :: o2_decomp_depth(:,:)
+    real(r8), pointer :: conc_o2(:,:)
+    real(r8), pointer :: conc_ch4(:,:)
     !-----------------------------------------------------------------------
 
     ! Enforce expected array sizes
@@ -2496,20 +2323,37 @@ contains
          smp_l      => soilstate_vars%smp_l_col       , & ! Input:  [real(r8) (: ,:) ]  soil matrix potential [mm]
          watsat     => soilstate_vars%watsat_col      , & ! Input:  [real(r8) (:,:)  ]  volumetric soil water at saturation (porosity)
 
-         t_soisno   => col_es%t_soisno   , & ! Input:  [real(r8) (:,:)  ]  soil temperature (Kelvin)  (-nlevsno+1:nlevsoi)
-            ! Set oxidation parameters
-         vmax_ch4_oxid   => CH4ParamsInst%vmax_ch4_oxid , &
-         k_m             => CH4ParamsInst%k_m , &
-         q10_ch4oxid     => CH4ParamsInst%q10_ch4oxid , &
-         smp_crit        => CH4ParamsInst%smp_crit , &
-         k_m_o2          => CH4ParamsInst%k_m_o2   , &
-         k_m_unsat       => CH4ParamsInst%k_m_unsat, &
-         vmax_oxid_unsat => CH4ParamsInst%vmax_oxid_unsat &
+         t_soisno   => col_es%t_soisno    & ! Input:  [real(r8) (:,:)  ]  soil temperature (Kelvin)  (-nlevsno+1:nlevsoi)
          )
 
+      if (sat == 0) then                                   ! unsaturated
+         ch4_oxid_depth   => ch4_vars%ch4_oxid_depth_unsat_col  ! Output: [real(r8) (:,:)]  CH4 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         o2_oxid_depth    => ch4_vars%o2_oxid_depth_unsat_col   ! Output: [real(r8) (:,:)]  O2 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         co2_oxid_depth   => ch4_vars%co2_oxid_depth_unsat_col  ! Output: [real(r8) (:,:)]  CO2 production rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         conc_ch4         => ch4_vars%conc_ch4_unsat_col        ! Input:  [real(r8) (:,:)]  CH4 conc in each soil layer (mol/m3) (nlevsoi)
+         conc_o2          => ch4_vars%conc_o2_unsat_col         ! Input:  [real(r8) (:,:)]  O2 conc in each soil layer (mol/m3) (nlevsoi)
+         o2_decomp_depth  => ch4_vars%o2_decomp_depth_unsat_col ! Output: [real(r8) (:,:)]  O2 consumption during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+      else                                                 ! saturated
+         ch4_oxid_depth   => ch4_vars%ch4_oxid_depth_sat_col    ! Output: [real(r8) (:,:)]  CH4 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         o2_oxid_depth    => ch4_vars%o2_oxid_depth_sat_col     ! Output: [real(r8) (:,:)]  O2 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         co2_oxid_depth   => ch4_vars%co2_oxid_depth_sat_col    ! Output: [real(r8) (:,:)]  CO2 production rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         conc_ch4         => ch4_vars%conc_ch4_sat_col          ! Input:  [real(r8) (:,:)]  CH4 conc in each soil layer (mol/m3) (nlevsoi)
+         conc_o2          => ch4_vars%conc_o2_sat_col           ! Input:  [real(r8) (:,:)]  O2 conc in each soil layer (mol/m3) (nlevsoi)
+         o2_decomp_depth  => ch4_vars%o2_decomp_depth_sat_col   ! Output: [real(r8) (:,:)]  O2 consumption during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+      endif
+
+      ! Set oxidation parameters
+      vmax_ch4_oxid   = CH4ParamsInst%vmax_ch4_oxid
+      k_m             = CH4ParamsInst%k_m
+      q10_ch4oxid     = CH4ParamsInst%q10_ch4oxid
+      smp_crit        = CH4ParamsInst%smp_crit
+      k_m_o2          = CH4ParamsInst%k_m_o2
+      k_m_unsat       = CH4ParamsInst%k_m_unsat
+      vmax_oxid_unsat = CH4ParamsInst%vmax_oxid_unsat
+
+      t0 = tfrz + 12._r8 ! Walter, for Michigan site where the 45 M/h comes from
 
       ! Loop to determine oxidation in each layer
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j=1,nlevsoi
          do fc = 1, num_methc
             c = filter_methc(fc)
@@ -2546,8 +2390,8 @@ contains
                conc_o2_rel  = conc_o2(c,j) / watsat(c,j)
             endif
 
-            ![mol/m3-t/s]         [mol/m3-w/s]    [m3-w/m3-t]     [mol/m3-w]    [mol/m3-w]  [mol/m3-w]
             oxid_a              = vmax_eff     * h2osoi_vol_min* conc_ch4_rel / (k_m_eff + conc_ch4_rel) &
+                                ![mol/m3-t/s]         [mol/m3-w/s]    [m3-w/m3-t]     [mol/m3-w]    [mol/m3-w]  [mol/m3-w]
                  * conc_o2_rel / (k_m_o2 + conc_o2_rel) &
                  * q10_ch4oxid ** ((t_soisno(c,j) - t0) / 10._r8) * smp_fact
 
@@ -2568,9 +2412,7 @@ contains
        num_methc, filter_methc, &
        num_methp, filter_methp, &
        jwt, sat, lake, &
-       canopystate_vars, soilstate_vars, energyflux_vars, ch4_vars, dtime, &
-       ch4_aere_depth, ch4_tran_depth, o2_aere_depth , &
-       co2_aere_depth, conc_ch4, conc_o2, ch4_oxid_depth, ch4_prod_depth)
+       canopystate_vars, soilstate_vars, energyflux_vars, ch4_vars, dtime, elm_fates)
     !
     ! !DESCRIPTION:
     ! Arctic c3 grass (which is often present in fens) and all vegetation in inundated areas is assumed to have
@@ -2580,6 +2422,7 @@ contains
     ! By default upland veg. has small 5% porosity but this can be switched to be equal to inundated porosity.
 
     ! !USES:
+      !$acc routine seq
     use elm_varcon       , only : rpi
     use pftvarcon        , only : nc3_arctic_grass, crop, nc3_nonarctic_grass, nc4_grass, noveg
     use CH4varcon        , only : transpirationloss, usefrootc, use_aereoxid_prog
@@ -2598,41 +2441,49 @@ contains
     type(energyflux_type)  , intent(inout) :: energyflux_vars
     type(ch4_type)         , intent(inout) :: ch4_vars
     real(r8)               , intent(in) :: dtime
-    real(r8), intent(inout) :: ch4_aere_depth(:,:)
-    real(r8), intent(inout) :: ch4_tran_depth(:,:)
-    real(r8), intent(inout) :: o2_aere_depth(:,:)
-    real(r8), intent(inout) :: co2_aere_depth(:,:)
-    real(r8), intent(inout) :: ch4_oxid_depth(:,:)
-    real(r8), intent(inout) :: ch4_prod_depth(:,:)
-    real(r8), intent(inout) :: conc_o2(:,:)
-    real(r8), intent(inout) :: conc_ch4(:,:)
-    !
+    type(hlm_fates_interface_type), intent(inout) :: elm_fates
+
+        !
     ! !LOCAL VARIABLES:
-    integer  :: p,c,g,j                ! indices
-    integer  :: fc,fp                  ! soil filter column index
-    real(r8) :: f_oxid                 ! fraction of CH4 oxidized in oxic zone around roots
-    real(r8) :: diffus_aere            ! gas diffusivity through aerenchyma (m^2/s)
-    real(r8) :: m_tiller
-    real(r8) :: n_tiller
-    real(r8) :: poros_tiller
-    real(r8) :: rob                    ! root obliquity, e.g. csc of root angle relative to vertical
-                                       ! (ratio of root total length to depth)
-    real(r8) :: area_tiller            ! cross-sectional area of tillers (m^2/m^2)
-    real(r8) :: tranloss               ! loss due to transpiration (mol / m3 /s)
-    real(r8) :: aere, aeretran, oxaere ! (mol / m3 /s)
-    real(r8) :: k_h_cc, k_h_inv, oxdiffus, anpp, nppratio, h2osoi_vol_min, conc_ch4_wat
-    real(r8) :: aerecond               ! aerenchyma conductance (m/s)
+    integer  :: nc
+    integer  :: p,c,g,j,s            ! indices
+    integer  :: fc,fp                ! soil filter column index
+    integer  :: pf                   ! fates patch index
+    integer  :: nlevsoil_f           ! number of root layers tracked by fates
+    real(r8) :: tranloss(1:nlevsoi)  ! loss due to transpiration (mol / m3 /s)
+    real(r8) :: aere(1:nlevsoi) 
+    real(r8) :: oxaere(1:nlevsoi)    ! (mol / m3 /s)
+    real(r8) :: rootfr_vr(1:nlevsoi) ! Root fraction over depth
+    real(r8) :: aeretran
+
+    logical :: is_vegetated ! is this a vegetated patch?
+    
     ! ch4 aerenchyma parameters
-    real(r8) :: aereoxid               ! fraction of methane flux entering aerenchyma rhizosphere
+    real(r8) :: aereoxid               ! fraction of methane flux entering aerenchyma rhizosphere 
     real(r8) :: scale_factor_aere      ! scale factor on the aerenchyma area for sensitivity tests
     real(r8) :: nongrassporosratio     ! Ratio of root porosity in non-grass to grass, used for aerenchyma transport
     real(r8) :: unsat_aere_ratio       ! Ratio to multiply upland vegetation aerenchyma porosity by compared to inundated systems (= 0.05_r8 / 0.3_r8)
     real(r8) :: porosmin               ! minimum aerenchyma porosity (unitless)(= 0.05_r8)
+    real(r8) :: wfrac                  ! fraction (by crown area) of plants that are woody
+    real(r8) :: poros_tiller 
+
+    ! These pointers help us swap between big-leaf and fates boundary conditions
+    real(r8), pointer :: annavg_agnpp_ptr
+    real(r8), pointer :: annavg_bgnpp_ptr
+    real(r8), pointer :: annsum_npp_ptr
+    real(r8), pointer :: frootc_ptr
+
+    ! These pointers help us swap between saturated and unsaturated boundary conditions
+    real(r8), pointer :: ch4_aere_depth(:,:) 
+    real(r8), pointer :: ch4_tran_depth(:,:) 
+    real(r8), pointer :: o2_aere_depth(:,:)  
+    real(r8), pointer :: ch4_oxid_depth(:,:) 
+    real(r8), pointer :: ch4_prod_depth(:,:) 
+    real(r8), pointer :: conc_o2(:,:)        
+    real(r8), pointer :: conc_ch4(:,:)
 
-    real(r8), parameter :: smallnumber = 1.e-12_r8
-    real(r8) :: sum1, sum2, sum3
-    
     !-----------------------------------------------------------------------
+
     ! Enforce expected array sizes
 
     associate(                                                     &
@@ -2662,187 +2513,289 @@ contains
          annavg_bgnpp  =>    veg_cf%annavg_bgnpp  , & ! Input:  [real(r8) (:)    ]  (gC/m2/s) annual average belowground NPP
 
          grnd_ch4_cond =>    ch4_vars%grnd_ch4_cond_patch        , & ! Input:  [real(r8) (:)    ]  tracer conductance for boundary layer [m/s]
-         c_atm         =>    ch4_vars%c_atm_grc                  , & ! Input:  [real(r8) (: ,:) ]  CH4, O2, CO2 atmospheric conc  (mol/m3)
-
-         ! Set aerenchyma parameters
-         aereoxid           => CH4ParamsInst%aereoxid  ,& 
-         scale_factor_aere  => CH4ParamsInst%scale_factor_aere ,&
-         nongrassporosratio => CH4ParamsInst%nongrassporosratio ,&
-         unsat_aere_ratio   => CH4ParamsInst%unsat_aere_ratio ,&
-         porosmin           => CH4ParamsInst%porosmin ,&
-         rob                => CH4ParamsInst%rob &
+         c_atm         =>    ch4_vars%c_atm_grc                    & ! Input:  [real(r8) (: ,:) ]  CH4, O2, CO2 atmospheric conc  (mol/m3)
          )
 
+      if (sat == 0) then                                   ! unsaturated
+         ch4_aere_depth   =>  ch4_vars%ch4_aere_depth_unsat_col ! Output: [real(r8) (:,:)]  CH4 loss rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_tran_depth   =>  ch4_vars%ch4_tran_depth_unsat_col ! Output: [real(r8) (:,:)]  CH4 loss rate via transpiration in each soil layer (mol/m3/s) (nlevsoi)
+         o2_aere_depth    =>  ch4_vars%o2_aere_depth_unsat_col  ! Output: [real(r8) (:,:)]  O2 gain rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         conc_ch4         =>  ch4_vars%conc_ch4_unsat_col       ! Input:  [real(r8) (:,:)]  CH4 conc in each soil layer (mol/m3) (nlevsoi)
+         conc_o2          =>  ch4_vars%conc_o2_unsat_col        ! Input:  [real(r8) (:,:)]  O2 conc in each soil layer (mol/m3) (nlevsoi)
+         ch4_oxid_depth   =>  ch4_vars%ch4_oxid_depth_unsat_col ! Input:  [real(r8) (:,:)]  CH4 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_prod_depth   =>  ch4_vars%ch4_prod_depth_unsat_col ! Input:  [real(r8) (:,:)]  production of CH4 in each soil layer (nlevsoi) (mol/m3/s)
+      else                                                 ! saturated
+         ch4_aere_depth   =>  ch4_vars%ch4_aere_depth_sat_col   ! Output: [real(r8) (:,:)]  CH4 loss rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_tran_depth   =>  ch4_vars%ch4_tran_depth_sat_col   ! Output: [real(r8) (:,:)]  CH4 loss rate via transpiration in each soil layer (mol/m3/s) (nlevsoi)
+         o2_aere_depth    =>  ch4_vars%o2_aere_depth_sat_col    ! Output: [real(r8) (:,:)]  O2 gain rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         conc_ch4         =>  ch4_vars%conc_ch4_sat_col         ! Input:  [real(r8) (:,:)]  CH4 conc in each soil layer (mol/m3) (nlevsoi)
+         conc_o2          =>  ch4_vars%conc_o2_sat_col          ! Input:  [real(r8) (:,:)]  O2 conc in each soil layer (mol/m3) (nlevsoi)
+         ch4_oxid_depth   =>  ch4_vars%ch4_oxid_depth_sat_col   ! Input:  [real(r8) (:,:)]  CH4 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_prod_depth   =>  ch4_vars%ch4_prod_depth_sat_col   ! Input:  [real(r8) (:,:)]  production of CH4 in each soil layer (nlevsoi) (mol/m3/s)
+      endif
+
+      ! Initialize ch4_aere_depth
+      do j=1,nlevsoi
+         do fc = 1, num_methc
+            c = filter_methc (fc)
+            ch4_aere_depth(c,j) = 0._r8
+            ch4_tran_depth(c,j) = 0._r8
+            o2_aere_depth(c,j) = 0._r8
+         end do
+      end do
 
-    !$acc enter data create(&
-    !$acc ch4_aere_depth(:,:), &
-    !$acc ch4_tran_depth(:,:), &
-    !$acc o2_aere_depth(:,:), &
-    !$acc co2_aere_depth(:,:), &
-    !$acc ch4_oxid_depth(:,:), &
-    !$acc ch4_prod_depth(:,:), &
-    !$acc conc_o2(:,:), &
-    !$acc conc_ch4(:,:), &
-    !$acc poros_tiller, &
-    !$acc tranloss, &
-    !$acc aere, &
-    !$acc oxaere, &
-    !$acc anpp, &
-    !$acc aerecond, &
-    !$acc sum1, &
-    !$acc sum2, &
-    !$acc sum3 )
+      nc = bounds%clump_index
 
       ! point loop to partition aerenchyma flux into each soil layer
       if (.not. lake) then
-         !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1,sum2,sum3,c,g)
-         do j=1,nlevsoi
-            do fc = 1, num_methc
-               c = filter_methc(fc) 
-               g = col_pp%gridcell(c)
-               sum1 = 0._r8 
-               sum2 = 0._r8 
-               sum3 = 0._r8 
-               !$acc loop vector reduction(+:sum1,sum2,sum3)
-               do p = col_pp%pfti(c), col_pp%pftf(c) 
-                  if(.not. veg_pp%active(p)) continue 
-
-                  ! This parameter is poorly constrained and should be done on a PFT-specific basis...
-                  diffus_aere = d_con_g(1,1)*1.e-4_r8  ! for CH4: m^2/s
-                  
-                  ! Calculate transpiration loss
-                  if (transpirationloss .and. veg_pp%itype(p) /= noveg) then !allow tloss above WT ! .and. j > jwt(c)) then
-                     ! Calculate water concentration
-                     h2osoi_vol_min = min(watsat(c,j), h2osoi_vol(c,j))
-                     k_h_inv = exp(-c_h_inv(1) * (1._r8 / t_soisno(c,j) - 1._r8 / kh_tbase) + log (kh_theta(1)))
-                     k_h_cc = t_soisno(c,j) / k_h_inv * rgasLatm
-                     conc_ch4_wat = conc_ch4(c,j) / ( (watsat(c,j)-h2osoi_vol_min)/k_h_cc + h2osoi_vol_min)
-                     tranloss = conc_ch4_wat *             rootr(p,j)*qflx_tran_veg(p) / dz(c,j) / 1000._r8
-                     ! mol/m3/s    mol/m3                                   mm / s         m           mm/m
-                     ! Use rootr here for effective per-layer transpiration, which may not be the same as rootfr
-                     tranloss = max(tranloss, 0._r8) ! in case transpiration is pathological
-                  else
-                     tranloss = 0._r8
-                  end if
 
-                  ! Calculate aerenchyma diffusion
-                  if (j > jwt(c) .and. t_soisno(c,j) > tfrz .and. veg_pp%itype(p) /= noveg) then
-                     ! Attn EK: This calculation of aerenchyma properties is very uncertain. Let's check in once all
-                     ! the new components are in; if there is any tuning to be done to get a realistic global flux,
-                     ! this would probably be the place.  We will have to document clearly in the Tech Note
-                     ! any major changes from the Riley et al. 2011 version. (There are a few other minor ones.)
+         do fp = 1, num_methp
+            p = filter_methp (fp)
+            c = veg_pp%column(p)
+            g = col_pp%gridcell(c)
 
-                     anpp = annsum_npp(p) ! g C / m^2/yr
-                     anpp = max(anpp, 0._r8) ! NPP can be negative b/c of consumption of storage pools
+            if(.not.col_pp%is_fates(c) ) then
+               if(veg_pp%itype(p) /= noveg) then
+                  is_vegetated = .true.
+               else
+                  is_vegetated = .false.
+               end if
 
-                     if (annavg_agnpp(p) /= spval .and. annavg_bgnpp(p) /= spval .and. &
-                           annavg_agnpp(p) > 0._r8 .and. annavg_bgnpp(p) > 0._r8) then
-                        nppratio = annavg_bgnpp(p) / (annavg_agnpp(p) + annavg_bgnpp(p))
-                     else
-                        nppratio = 0.5_r8
-                     end if
+               if (veg_pp%itype(p) == nc3_arctic_grass .or. crop(veg_pp%itype(p)) == 1 .or. &
+                    veg_pp%itype(p) == nc3_nonarctic_grass .or. veg_pp%itype(p) == nc4_grass) then
+                  poros_tiller = 0.3_r8  ! Colmer 2003
+               else
+                  poros_tiller = 0.3_r8 * CH4ParamsInst%nongrassporosratio
+               end if
 
-                     ! Estimate area of tillers (see Wania thesis)
-                     ! m_tiller = anpp * r_leaf_root * lai ! (4.17 Wania)
-                     ! m_tiller = 600._r8 * 0.5_r8 * 2._r8  ! used to be 300
-                     ! Note: this calculation is based on Arctic graminoids, and should be refined for woody plants, if not
-                     ! done on a PFT-specific basis.
+               annsum_npp_ptr   => annsum_npp(p)
+               annavg_agnpp_ptr => annavg_agnpp(p)
+               annavg_bgnpp_ptr => annavg_bgnpp(p)
+               frootc_ptr       => frootc(p)
+               rootfr_vr(1:nlevsoi) = rootfr(p,1:nlevsoi)
 
-                     if (usefrootc) then
-                        m_tiller = frootc(p) ! This will yield much smaller aere area.
-                     else
-                        m_tiller = anpp * nppratio * elai(p)
-                     end if
+            else
 
-                     n_tiller = m_tiller / 0.22_r8
+               pf = p-col_pp%pfti(c)
+               s  = elm_fates%f2hmap(nc)%hsites(c)
 
-                     if (veg_pp%itype(p) == nc3_arctic_grass .or. crop(veg_pp%itype(p)) == 1 .or. &
-                          veg_pp%itype(p) == nc3_nonarctic_grass .or. veg_pp%itype(p) == nc4_grass) then
-                        poros_tiller = 0.3_r8  ! Colmer 2003
-                     else
-                        poros_tiller = 0.3_r8 * nongrassporosratio
-                     end if
+               wfrac = elm_fates%fates(nc)%bc_out(s)%woody_frac_aere_pa(pf)
+               poros_tiller = wfrac*0.3_r8 + (1._r8-wfrac)*0.3_r8*CH4ParamsInst%nongrassporosratio
+               if(veg_pp%is_bareground(p)) then
+                  is_vegetated = .false.
+               else
+                  is_vegetated = .true.
+               end if
 
-                     if (sat == 0) then
-                        poros_tiller = poros_tiller * unsat_aere_ratio
-                     end if
+               annsum_npp_ptr   => elm_fates%fates(nc)%bc_out(s)%annsum_npp_pa(pf)
+               annavg_agnpp_ptr => elm_fates%fates(nc)%bc_out(s)%annavg_agnpp_pa(pf)
+               annavg_bgnpp_ptr => elm_fates%fates(nc)%bc_out(s)%annavg_bgnpp_pa(pf)
+               frootc_ptr       => elm_fates%fates(nc)%bc_out(s)%frootc_pa(pf)
+               nlevsoil_f = elm_fates%fates(nc)%bc_in(s)%nlevsoil
+               rootfr_vr(1:nlevsoi) = 0._r8
+               rootfr_vr(1:nlevsoil_f) = elm_fates%fates(nc)%bc_out(s)%rootfr_pa(pf,1:nlevsoil_f)
 
-                     poros_tiller = max(poros_tiller, porosmin)
-
-                     area_tiller = scale_factor_aere * n_tiller * poros_tiller * rpi * 2.9e-3_r8**2._r8 ! (m2/m2)
-
-                     k_h_inv = exp(-c_h_inv(1) * (1._r8 / t_soisno(c,j) - 1._r8 / kh_tbase) + log (kh_theta(1))) ! (4.12) Wania (L atm/mol)
-                     k_h_cc = t_soisno(c,j) / k_h_inv * rgasLatm ! (4.21) Wania [(mol/m3w) / (mol/m3g)]
-                     aerecond = area_tiller * rootfr(p,j) * diffus_aere / (z(c,j)*rob)
-                     ! Add in boundary layer resistance
-                     aerecond = 1._r8 / (1._r8/(aerecond+smallnumber) + 1._r8/(grnd_ch4_cond(p)+smallnumber))
-
-                     aere = aerecond * (conc_ch4(c,j)/watsat(c,j)/k_h_cc - c_atm(g,1)) / dz(c,j) ![mol/m3-total/s]
-                     !ZS: Added watsat & Henry's const.
-                     aere = max(aere, 0._r8) ! prevent backwards diffusion
-
-                     ! Do oxygen diffusion into layer
-                     k_h_inv = exp(-c_h_inv(2) * (1._r8 / t_soisno(c,j) - 1._r8 / kh_tbase) + log (kh_theta(2)))
-                     k_h_cc = t_soisno(c,j) / k_h_inv * rgasLatm ! (4.21) Wania [(mol/m3w) / (mol/m3g)]
-                     oxdiffus = diffus_aere * d_con_g(2,1) / d_con_g(1,1) ! adjust for O2:CH4 molecular diffusion
-                     aerecond = area_tiller * rootfr(p,j) * oxdiffus / (z(c,j)*rob)
-                     aerecond = 1._r8 / (1._r8/(aerecond+smallnumber) + 1._r8/(grnd_ch4_cond(p)+smallnumber))
-                     oxaere = -aerecond *(conc_o2(c,j)/watsat(c,j)/k_h_cc - c_atm(g,2)) / dz(c,j) ![mol/m3-total/s]
-                     oxaere = max(oxaere, 0._r8)
-                     ! Diffusion in is positive; prevent backwards diffusion
-                     if ( .not. use_aereoxid_prog ) then ! fixed aere oxid proportion; will be done in ch4_tran
-                        oxaere = 0._r8
-                     end if
-                  else
-                     aere = 0._r8
-                     oxaere = 0._r8
-                  end if ! veg type, below water table, & above freezing
-
-                  ! Impose limitation based on available methane during timestep
-                  ! By imposing the limitation here, don't allow aerenchyma access to methane from other Patches.
-                  aeretran = min(aere+tranloss, conc_ch4(c,j)/dtime + ch4_prod_depth(c,j))
-                  sum1 = sum1 + aeretran*wtcol(p) !pft weight in col.
-                  sum2 = sum2 + min(tranloss, aeretran)*wtcol(p)
-                  sum3 = sum3 + oxaere*wtcol(p)
-               end do ! p loop
-               ch4_aere_depth (c, j) = sum1 
-               ch4_tran_depth (c, j) = sum2
-               o2_aere_depth  (c, j) = sum3 
-            end do ! c filter
-         end do ! over levels
-      end if ! not lake
+            end if
 
+            call SiteOxAere(is_vegetated, watsat(c,1:nlevsoi), h2osoi_vol(c,1:nlevsoi), t_soisno(c,1:nlevsoi), & 
+                 conc_ch4(c,1:nlevsoi), rootr(p,1:nlevsoi), qflx_tran_veg(p), jwt(c), &
+                 annsum_npp_ptr, annavg_agnpp_ptr, annavg_bgnpp_ptr, &
+                 elai(p), frootc_ptr, poros_tiller, rootfr_vr(1:nlevsoi), &
+                 grnd_ch4_cond(p), conc_o2(c,1:nlevsoi), c_atm(g,1:2), &
+                 z(c,1:nlevsoi), dz(c,1:nlevsoi), sat, & 
+                 tranloss(1:nlevsoi), &    ! Out
+                 aere(1:nlevsoi), &         ! Out
+                 oxaere(1:nlevsoi))         ! Out
+               
+            do j=1,nlevsoi
+               ! Impose limitation based on available methane during timestep
+               ! By imposing the limitation here, don't allow aerenchyma access to methane from other Patches.
+               aeretran = min(aere(j)+tranloss(j), conc_ch4(c,j)/dtime + ch4_prod_depth(c,j))
+               ch4_aere_depth (c, j) = ch4_aere_depth(c,j) + aeretran*wtcol(p) !pft weight in col.
+               ch4_tran_depth (c, j) = ch4_tran_depth(c,j) + min(tranloss(j), aeretran)*wtcol(p)
+               o2_aere_depth  (c, j) = o2_aere_depth (c,j) + oxaere(j)*wtcol(p)
+            end do
 
-    !$acc exit data delete(&
-    !$acc ch4_aere_depth(:,:), &
-    !$acc ch4_tran_depth(:,:), &
-    !$acc o2_aere_depth(:,:), &
-    !$acc co2_aere_depth(:,:), &
-    !$acc ch4_oxid_depth(:,:), &
-    !$acc ch4_prod_depth(:,:), &
-    !$acc conc_o2(:,:), &
-    !$acc conc_ch4(:,:), &
-    !$acc poros_tiller, &
-    !$acc tranloss, &
-    !$acc aere, &
-    !$acc oxaere, &
-    !$acc anpp, &
-    !$acc aerecond, &
-    !$acc sum1, &
-    !$acc sum2, &
-    !$acc sum3 )
+         end do ! p filter
+
+      end if ! not lake
 
     end associate
 
   end subroutine ch4_aere
+  
+  !--------------------------------------------------------------------------------------
+  
+  subroutine SiteOxAere(is_vegetated, & 
+                    watsat,           &  
+                    h2osoi_vol,       &
+                    t_soisno,         & 
+                    conc_ch4,         &
+                    rootr,            &
+                    qflx_tran_veg,    &
+                    jwt,              &
+                    annsum_npp,       &
+                    annavg_agnpp,     &
+                    annavg_bgnpp,     &
+                    elai,             &
+                    frootc,           &
+                    poros_tiller,     &
+                    rootfr,           &
+                    grnd_ch4_cond,    &
+                    conc_o2,          &
+                    c_atm,            &
+                    z,                &
+                    dz,               &
+                    sat,              &
+                    tranloss,         & ! Out
+                    aere,             & ! Out
+                    oxaere)             ! Out  
 
+
+    use elm_varcon       , only : rpi
+    use CH4varcon        , only : transpirationloss, usefrootc, use_aereoxid_prog
+    
+    ! Arguments (in)
+    
+    logical, intent(in)  :: is_vegetated
+    real(r8), intent(in) :: watsat(:)
+    real(r8), intent(in) :: h2osoi_vol(:)
+    real(r8), intent(in) :: t_soisno(:) 
+    real(r8), intent(in) :: conc_ch4(:)
+    real(r8), intent(in) :: rootr(:)
+    real(r8), intent(in) :: qflx_tran_veg
+    integer, intent(in)  :: jwt
+    real(r8), intent(in) :: annsum_npp
+    real(r8), intent(in) :: annavg_agnpp
+    real(r8), intent(in) :: annavg_bgnpp
+    real(r8), intent(in) :: elai
+    real(r8), intent(in) :: frootc
+    real(r8)             :: poros_tiller
+    real(r8), intent(in) :: rootfr(:)
+    real(r8), intent(in) :: grnd_ch4_cond
+    real(r8), intent(in) :: conc_o2(:)
+    real(r8), intent(in) :: c_atm(:)
+    real(r8), intent(in) :: z(:)
+    real(r8), intent(in) :: dz(:)
+    integer,  intent(in) :: sat
+
+    ! Arguments (out)
+    real(r8), intent(out) :: tranloss(:)
+    real(r8), intent(out) :: aere(:)
+    real(r8), intent(out) :: oxaere(:)            
+
+    integer  :: j,pf
+    real(r8) :: oxdiffus
+    real(r8) :: area_tiller ! cross-sectional area of tillers (m^2/m^2)
+    real(r8) :: diffus_aere ! gas diffusivity through aerenchyma (m^2/s)
+    real(r8) :: m_tiller 
+    real(r8) :: n_tiller 
+    real(r8) :: h2osoi_vol_min
+    real(r8) :: k_h_cc, k_h_inv
+    real(r8) :: anpp, nppratio
+    real(r8) :: conc_ch4_wat
+    real(r8) :: aerecond    ! aerenchyma conductance (m/s)
+    real(r8), parameter :: smallnumber = 1.e-12_r8
+    
+    diffus_aere = d_con_g(1,1)*1.e-4_r8  ! for CH4: m^2/s
+    ! This parameter is poorly constrained and should be done on a PFT-specific basis...
+
+
+    do j=1,nlevsoi
+
+       ! Calculate transpiration loss
+       if (transpirationloss .and. is_vegetated) then
+          ! Calculate water concentration
+          h2osoi_vol_min = min(watsat(j), h2osoi_vol(j))
+          k_h_inv = exp(-c_h_inv(1) * (1._r8 / t_soisno(j) - 1._r8 / kh_tbase) + log (kh_theta(1)))
+          k_h_cc = t_soisno(j) / k_h_inv * rgasLatm
+          conc_ch4_wat = conc_ch4(j) / ( (watsat(j)-h2osoi_vol_min)/k_h_cc + h2osoi_vol_min)
+
+          tranloss(j) = conc_ch4_wat * rootr(j)*qflx_tran_veg / dz(j) / 1000._r8
+          ! mol/m3/s    mol/m3                                   mm / s         m           mm/m
+          ! Use rootr here for effective per-layer transpiration, which may not be the same as rootfr
+          tranloss(j) = max(tranloss(j), 0._r8) ! in case transpiration is pathological
+       else
+          tranloss(j) = 0._r8
+       end if
+
+       ! Calculate aerenchyma diffusion
+       if (j > jwt .and. t_soisno(j) > tfrz .and. is_vegetated) then
+          ! Attn EK: This calculation of aerenchyma properties is very uncertain. Let's check in once all
+          ! the new components are in; if there is any tuning to be done to get a realistic global flux,
+          ! this would probably be the place.  We will have to document clearly in the Tech Note
+          ! any major changes from the Riley et al. 2011 version. (There are a few other minor ones.)
+
+          anpp = annsum_npp ! g C / m^2/yr
+          anpp = max(anpp, 0._r8) ! NPP can be negative b/c of consumption of storage pools
+
+          if (annavg_agnpp /= spval .and. annavg_bgnpp /= spval .and. &
+               annavg_agnpp > 0._r8 .and. annavg_bgnpp > 0._r8) then
+             nppratio = annavg_bgnpp / (annavg_agnpp + annavg_bgnpp)
+          else
+             nppratio = 0.5_r8
+          end if
+
+          ! Estimate area of tillers (see Wania thesis)
+          !m_tiller = anpp * r_leaf_root * lai ! (4.17 Wania)
+          !m_tiller = 600._r8 * 0.5_r8 * 2._r8  ! used to be 300
+          ! Note: this calculation is based on Arctic graminoids, and should be refined for woody plants, if not
+          ! done on a PFT-specific basis.
+
+          if (usefrootc) then
+             m_tiller = frootc ! This will yield much smaller aere area.
+          else
+             m_tiller = anpp * nppratio * elai
+          end if
+
+          n_tiller = m_tiller / 0.22_r8
+
+          if (sat == 0) then
+             poros_tiller = poros_tiller * CH4ParamsInst%unsat_aere_ratio
+          end if
+
+          poros_tiller = max(poros_tiller, CH4ParamsInst%porosmin)
+
+          area_tiller = CH4ParamsInst%scale_factor_aere * n_tiller * poros_tiller * rpi * 2.9e-3_r8**2._r8 ! (m2/m2)
+
+          k_h_inv = exp(-c_h_inv(1) * (1._r8 / t_soisno(j) - 1._r8 / kh_tbase) + log (kh_theta(1))) ! (4.12) Wania (L atm/mol)
+          k_h_cc = t_soisno(j) / k_h_inv * rgasLatm ! (4.21) Wania [(mol/m3w) / (mol/m3g)]
+          aerecond = area_tiller * rootfr(j) * diffus_aere / (z(j)*CH4ParamsInst%rob)
+          ! Add in boundary layer resistance
+          aerecond = 1._r8 / (1._r8/(aerecond+smallnumber) + 1._r8/(grnd_ch4_cond+smallnumber))
+
+          aere(j) = aerecond * (conc_ch4(j)/watsat(j)/k_h_cc - c_atm(1)) / dz(j) ![mol/m3-total/s]
+          !ZS: Added watsat & Henry's const.
+          aere(j) = max(aere(j), 0._r8) ! prevent backwards diffusion
+
+          ! Do oxygen diffusion into layer
+          k_h_inv = exp(-c_h_inv(2) * (1._r8 / t_soisno(j) - 1._r8 / kh_tbase) + log (kh_theta(2)))
+          k_h_cc = t_soisno(j) / k_h_inv * rgasLatm ! (4.21) Wania [(mol/m3w) / (mol/m3g)]
+          oxdiffus = diffus_aere * d_con_g(2,1) / d_con_g(1,1) ! adjust for O2:CH4 molecular diffusion
+          aerecond = area_tiller * rootfr(j) * oxdiffus / (z(j)*CH4ParamsInst%rob)
+          aerecond = 1._r8 / (1._r8/(aerecond+smallnumber) + 1._r8/(grnd_ch4_cond+smallnumber))
+          oxaere(j) = -aerecond *(conc_o2(j)/watsat(j)/k_h_cc - c_atm(2)) / dz(j) ![mol/m3-total/s]
+          oxaere(j) = max(oxaere(j), 0._r8)
+          ! Diffusion in is positive; prevent backwards diffusion
+          if ( .not. use_aereoxid_prog ) then ! fixed aere oxid proportion; will be done in ch4_tran
+             oxaere(j) = 0._r8
+          end if
+       else
+          aere(j) = 0._r8
+          oxaere(j) = 0._r8
+       end if ! veg type, below water table, & above freezing
+
+    end do
+
+    return
+  end subroutine SiteOxAere
+  
   !-----------------------------------------------------------------------
+
   subroutine ch4_ebul (bounds, &
        num_methc, filter_methc, &
        jwt, sat, lake, &
-       lakestate_vars, soilstate_vars, ch4_vars, dtime, &
-       ch4_ebul_depth, ch4_ebul_total, conc_ch4, &    
-       ch4_aere_depth, ch4_oxid_depth)
+       atm2lnd_vars, lakestate_vars, soilstate_vars, ch4_vars, dtime)
     !
     ! !DESCRIPTION:
     ! Bubbling is based on temperature & pressure dependent solubility (k_h_cc),
@@ -2851,24 +2804,22 @@ contains
     ! Bubbles are released to the water table surface in ch4_tran.
 
     ! !USES:
+      !$acc routine seq
     use LakeCon
     !
     ! !ARGUMENTS:
-    type(bounds_type)    , intent(in)    :: bounds
-    integer              , intent(in)    :: num_methc           ! number of column soil points in column filter
-    integer              , intent(in)    :: filter_methc(:)     ! column filter for soil points
-    integer              , intent(in)    :: jwt( bounds%begc: ) ! index of the soil layer right above the water table (-) [col]
-    integer              , intent(in)    :: sat                 ! 0 = unsaturated; 1 = saturated
-    logical              , intent(in)    :: lake                ! function called with lake filter
-    type(lakestate_type) , intent(in)    :: lakestate_vars
-    type(soilstate_type) , intent(in)    :: soilstate_vars
-    type(ch4_type)       , intent(inout) :: ch4_vars
+    type(bounds_type)      , intent(in)    :: bounds
+    integer                , intent(in)    :: num_methc           ! number of column soil points in column filter
+    integer                , intent(in)    :: filter_methc(:)     ! column filter for soil points
+    integer                , intent(in)    :: jwt( bounds%begc: ) ! index of the soil layer right above the water table (-) [col]
+    integer                , intent(in)    :: sat                 ! 0 = unsaturated; 1 = saturated
+    logical                , intent(in)    :: lake             ! function called with lake filter
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
+    type(lakestate_type)   , intent(in)    :: lakestate_vars
+    type(soilstate_type)   , intent(in)    :: soilstate_vars
+    type(ch4_type)         , intent(inout) :: ch4_vars
     real(r8) ,intent(in)  :: dtime   ! land model time step (sec)
-    real(r8), intent(inout) :: ch4_ebul_depth(:,:) ! Output: [real(r8) (:,:)]  CH4 loss rate via ebullition in each soil layer (mol/m3/s) (nlevsoi)
-    real(r8), intent(inout) :: ch4_ebul_total(:)   ! Output: [real(r8) (:)]  Total column CH4 ebullition (mol/m2/s)
-    real(r8), intent(inout) :: conc_ch4(:,:)       ! Output: [real(r8) (:,:)]  CH4 conc in each soil layer (mol/m3) (nlevsoi)
-    real(r8), intent(in   ) :: ch4_aere_depth(:,:) ! Input:  [real(r8) (:,:)]  CH4 loss rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
-    real(r8), intent(in   ) :: ch4_oxid_depth(:,:) ! Input:  [real(r8) (:,:)]  CH4 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+
     !
     ! !LOCAL VARIABLES:
     integer :: c,j,t    ! indices
@@ -2880,12 +2831,16 @@ contains
     real(r8) :: k_h     !
     real(r8) :: k_h_cc  !
     real(r8) :: pressure! sum atmospheric and hydrostatic pressure
-    real(r8),parameter :: bubble_f = 0.57_r8 ! CH4 content in gas bubbles (Kellner et al. 2006)
-
+    real(r8) :: bubble_f! CH4 content in gas bubbles (Kellner et al. 2006)
     real(r8) :: ebul_timescale
     real(r8) :: vgc_max   ! ratio of saturation pressure triggering ebullition
-    
+    real(r8), pointer :: ch4_ebul_depth(:,:) ! backwards compatibility
+    real(r8), pointer :: ch4_ebul_total(:)   ! backwards compatibility
+    real(r8), pointer :: conc_ch4(:,:)       ! backwards compatibility
+    real(r8), pointer :: ch4_aere_depth(:,:) ! backwards compatibility
+    real(r8), pointer :: ch4_oxid_depth(:,:) ! backwards compatibility
     !-----------------------------------------------------------------------
+
     ! Enforce expected array sizes
 
     associate(                                                      &
@@ -2899,25 +2854,31 @@ contains
          watsat       =>    soilstate_vars%watsat_col             , & ! Input:  [real(r8) (:,:) ]  volumetric soil water at saturation (porosity)
          h2osoi_vol   =>    col_ws%h2osoi_vol        , & ! Input:  [real(r8) (:,:) ]  volumetric soil water (0<=h2osoi_vol<=watsat) [m3/m3]
          h2osfc       =>    col_ws%h2osfc            , & ! Input:  [real(r8) (:)   ]  surface water (mm)
-         frac_h2osfc  =>    col_ws%frac_h2osfc       , & ! Input:  [real(r8) (:)   ]  fraction of ground covered by surface water (0 to 1)
-         vgc_max => CH4ParamsInst%vgc_max &
+         frac_h2osfc  =>    col_ws%frac_h2osfc         & ! Input:  [real(r8) (:)   ]  fraction of ground covered by surface water (0 to 1)
          )
 
-    !$acc enter data create(&
-    !$acc ch4_ebul_depth(:,:), &
-    !$acc ch4_ebul_total(:), &
-    !$acc conc_ch4(:,:), &
-    !$acc ch4_aere_depth(:,:), &
-    !$acc ch4_oxid_depth(:,:), &
-    !$acc pressure)
-
+      if (sat == 0) then                                   ! unsaturated
+         ch4_ebul_depth =>    ch4_vars%ch4_ebul_depth_unsat_col ! Output: [real(r8) (:,:)]  CH4 loss rate via ebullition in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_ebul_total =>    ch4_vars%ch4_ebul_total_unsat_col ! Output: [real(r8) (:)]  Total column CH4 ebullition (mol/m2/s)
+         conc_ch4       =>    ch4_vars%conc_ch4_unsat_col       ! Output: [real(r8) (:,:)]  CH4 conc in each soil layer (mol/m3) (nlevsoi)
+         ch4_aere_depth =>    ch4_vars%ch4_aere_depth_unsat_col ! Input:  [real(r8) (:,:)]  CH4 loss rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_oxid_depth =>    ch4_vars%ch4_oxid_depth_unsat_col ! Input:  [real(r8) (:,:)]  CH4 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+      else                                                 ! saturated
+         ch4_ebul_depth =>    ch4_vars%ch4_ebul_depth_sat_col   ! Output: [real(r8) (:,:)]  CH4 loss rate via ebullition in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_ebul_total =>    ch4_vars%ch4_ebul_total_sat_col   ! Output: [real(r8) (:)]  Total column CH4 ebullition (mol/m2/s)
+         conc_ch4       =>    ch4_vars%conc_ch4_sat_col         ! Output: [real(r8) (:,:)]  CH4 conc in each soil layer (mol/m3) (nlevsoi)
+         ch4_aere_depth =>    ch4_vars%ch4_aere_depth_sat_col   ! Input:  [real(r8) (:,:)]  CH4 loss rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_oxid_depth =>    ch4_vars%ch4_oxid_depth_sat_col   ! Input:  [real(r8) (:,:)]  CH4 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+      endif
+
+      ! Get land model time step
+      vgc_max = CH4ParamsInst%vgc_max
+
+      bubble_f = 0.57_r8 ! CH4 content in gas bubbles (Kellner et al. 2006)
       vgc_min = vgc_max
       ebul_timescale = dtime ! Allow fast bubbling
-      !NOTE: Seems redundant/wasteful to have these local variables 
-      !$acc enter data copyin(vgc_min, ebul_timescale) 
 
       ! column loop to estimate ebullition CH4 flux from each soil layer
-      !$acc parallel loop independent gang vector collapse(2) default(present) 
       do j=1,nlevsoi
          do fc = 1, num_methc
             c = filter_methc (fc)
@@ -2960,15 +2921,6 @@ contains
          end do ! fc
       end do ! j
 
-
-    !$acc exit data delete(&
-    !$acc ch4_ebul_depth(:,:), &
-    !$acc ch4_ebul_total(:), &
-    !$acc conc_ch4(:,:), &
-    !$acc ch4_aere_depth(:,:), &
-    !$acc ch4_oxid_depth(:,:), &
-    !$acc pressure)
-
     end associate
 
   end subroutine ch4_ebul
@@ -2977,13 +2929,7 @@ contains
   subroutine ch4_tran (bounds, &
        num_methc, filter_methc, &
        jwt, dtime_ch4, sat, lake, &
-       soilstate_vars, energyflux_vars, ch4_vars, dtime ,&
-       o2_decomp_depth, o2stress, ch4_oxid_depth ,& 
-       ch4_prod_depth, ch4_aere_depth, ch4_surf_aere, &
-       ch4_ebul_depth,ch4_ebul_total,ch4_surf_ebul, &   
-       ch4_surf_diff, o2_oxid_depth, o2_aere_depth, & 
-       ch4stress, co2_decomp_depth, conc_ch4, conc_o2 &
-       )
+       soilstate_vars, energyflux_vars, ch4_vars, dtime)
     !
     ! !DESCRIPTION:
     ! Solves the reaction & diffusion equation for the timestep.  First "competition" between processes for
@@ -2995,7 +2941,8 @@ contains
     ! Then CH4 diffusive flux is calculated and consistency is checked.
 
     ! !USES:
-    use TridiagonalMod     , only : Tridiagonal_filter
+      !$acc routine seq
+    use TridiagonalMod     , only : Tridiagonal
     use CH4varcon          , only : ch4frzout, use_aereoxid_prog
     !
     ! !ARGUMENTS:
@@ -3010,67 +2957,52 @@ contains
     type(energyflux_type)  , intent(in)    :: energyflux_vars
     type(ch4_type)         , intent(inout) :: ch4_vars
     real(r8) ,intent(in)  :: dtime                               ! land model time step (sec)
-    real(r8), intent(inout) :: ch4_prod_depth   (:,:)
-    real(r8), intent(inout) :: ch4_oxid_depth   (:,:)
-    real(r8), intent(inout) :: ch4_aere_depth   (:,:)
-    real(r8), intent(inout) :: ch4_surf_aere    (:)
-    real(r8), intent(inout) :: ch4_ebul_depth   (:,:)
-    real(r8), intent(inout) :: ch4_ebul_total   (:)
-    real(r8), intent(inout) :: ch4_surf_ebul    (:)
-    real(r8), intent(inout) :: ch4_surf_diff    (:)
-    real(r8), intent(inout) :: o2_oxid_depth    (:,:)
-    real(r8), intent(inout) :: o2_decomp_depth  (:,:)
-    real(r8), intent(inout) :: o2_aere_depth    (:,:)
-    real(r8), intent(inout) :: o2stress         (:,:)
-    real(r8), intent(inout) :: ch4stress        (:,:)
-    real(r8), intent(inout) :: co2_decomp_depth (:,:)
-    real(r8), intent(inout) :: conc_o2          (:,:)
-    real(r8), intent(inout) :: conc_ch4         (:,:)
+
     !
     ! !LOCAL VARIABLES:
-    integer :: c,j,g,p,s,i,ll                                  ! indices
-    integer :: fc                                              ! soil filter column index
-    integer :: fp                                              ! soil filter pft index
-    integer,parameter  :: jtop = 0                             ! top level at each column
-    integer :: iter                                            ! iteration counter when dtime_ch4 < dtime
-    real(r8) :: at (1:num_methc,0:nlevsoi)                     ! "a" vector for tridiagonal matrix
-    real(r8) :: bt (1:num_methc,0:nlevsoi)                     ! "b" vector for tridiagonal matrix
-    real(r8) :: ct (1:num_methc,0:nlevsoi)                     ! "c" vector for tridiagonal matrix
-    real(r8) :: rt (1:num_methc,0:nlevsoi)                     ! "r" vector for tridiagonal solution
-    real(r8) :: f_a                                            ! air-filled fraction of available pore space
-    real(r8) :: diffus (1:num_methc,0:nlevsoi)                 ! diffusivity (m2/s)
-    real(r8) :: k_h_inv                                        ! 1/Henry's Law Constant in Latm/mol
-    real(r8) :: k_h_cc(1:num_methc,0:nlevsoi,ngases)           ! ratio of mol/m3 in liquid to mol/m3 in gas
-    real(r8) :: dzj                                            !
-    real(r8) :: dp1_zp1 (1:num_methc,0:nlevsoi)                ! diffusivity/delta_z for next j
-    real(r8) :: dm1_zm1 (1:num_methc,0:nlevsoi)                ! diffusivity/delta_z for previous j
-    real(r8) :: t_soisno_c                                     ! soil temperature (C)  (-nlevsno+1:nlevsoi)
-    real(r8) :: eps                                            ! either epsilon_a or epsilon_w, depending on where in soil, wrt WT
-    real(r8) :: deficit                                        ! mol CH4 /m^2 that must be subtracted from diffusive flux to atm. to make up
+    integer :: c,j,g,p,s,i,ll                                              ! indices
+    integer :: fc                                                          ! soil filter column index
+    integer :: fp                                                          ! soil filter pft index
+    integer  :: jtop(bounds%begc:bounds%endc)                              ! top level at each column
+    integer :: iter                                                        ! iteration counter when dtime_ch4 < dtime
+    real(r8) :: at (bounds%begc:bounds%endc,0:nlevsoi)                     ! "a" vector for tridiagonal matrix
+    real(r8) :: bt (bounds%begc:bounds%endc,0:nlevsoi)                     ! "b" vector for tridiagonal matrix
+    real(r8) :: ct (bounds%begc:bounds%endc,0:nlevsoi)                     ! "c" vector for tridiagonal matrix
+    real(r8) :: rt (bounds%begc:bounds%endc,0:nlevsoi)                     ! "r" vector for tridiagonal solution
+    real(r8) :: f_a                                                        ! air-filled fraction of available pore space
+    real(r8) :: diffus (bounds%begc:bounds%endc,0:nlevsoi)                 ! diffusivity (m2/s)
+    real(r8) :: k_h_inv                                                    ! 1/Henry's Law Constant in Latm/mol
+    real(r8) :: k_h_cc(bounds%begc:bounds%endc,0:nlevsoi,ngases)           ! ratio of mol/m3 in liquid to mol/m3 in gas
+    real(r8) :: dzj                                                        !
+    real(r8) :: dp1_zp1 (bounds%begc:bounds%endc,0:nlevsoi)                ! diffusivity/delta_z for next j
+    real(r8) :: dm1_zm1 (bounds%begc:bounds%endc,0:nlevsoi)                ! diffusivity/delta_z for previous j
+    real(r8) :: t_soisno_c                                                 ! soil temperature (C)  (-nlevsno+1:nlevsoi)
+    real(r8) :: eps                                                        ! either epsilon_a or epsilon_w, depending on where in soil, wrt WT
+    real(r8) :: deficit                                                    ! mol CH4 /m^2 that must be subtracted from diffusive flux to atm. to make up
     ! for keeping concentrations always above zero
-    real(r8) :: conc_ch4_bef(1:num_methc,1:nlevsoi)            ! concentration at the beginning of the timestep
-    real(r8) :: errch4(1:num_methc)                            ! Error (Mol CH4 /m^2) [+ = too much CH4]
-    real(r8) :: conc_ch4_rel(1:num_methc,0:nlevsoi)            ! Concentration per volume of air or water
-    real(r8) :: conc_o2_rel(1:num_methc,0:nlevsoi)             ! Concentration per volume of air or water
-    real(r8) :: conc_ch4_rel_old(1:num_methc,0:nlevsoi)        ! Concentration during last Crank-Nich. loop
-    real(r8) :: h2osoi_vol_min(1:num_methc,1:nlevsoi)          ! h2osoi_vol restricted to be <= watsat
+    real(r8) :: conc_ch4_bef(bounds%begc:bounds%endc,1:nlevsoi)            ! concentration at the beginning of the timestep
+    real(r8) :: errch4(bounds%begc:bounds%endc)                            ! Error (Mol CH4 /m^2) [+ = too much CH4]
+    real(r8) :: conc_ch4_rel(bounds%begc:bounds%endc,0:nlevsoi)            ! Concentration per volume of air or water
+    real(r8) :: conc_o2_rel(bounds%begc:bounds%endc,0:nlevsoi)             ! Concentration per volume of air or water
+    real(r8) :: conc_ch4_rel_old(bounds%begc:bounds%endc,0:nlevsoi)        ! Concentration during last Crank-Nich. loop
+    real(r8) :: h2osoi_vol_min(bounds%begc:bounds%endc,1:nlevsoi)          ! h2osoi_vol restricted to be <= watsat
     real(r8), parameter :: smallnumber = 1.e-12_r8
-    real(r8) :: snowdiff                                       ! snow diffusivity (m^2/s)
-    real(r8) :: snowres                           ! Cumulative Snow resistance (s/m). Also includes
-    real(r8) :: pondres                                        ! Additional resistance from ponding, up to pondmx water on top of top soil layer (s/m)
-    real(r8) :: pondz                                          ! Depth of ponding (m)
-    real(r8) :: ponddiff                                       ! Pondwater diffusivity (m^2/s)
-    real(r8) :: spec_grnd_cond(1:num_methc,1:ngases)           ! species grnd conductance (s/m)
+    real(r8) :: snowdiff                                                   ! snow diffusivity (m^2/s)
+    real(r8) :: snowres(bounds%begc:bounds%endc)                           ! Cumulative Snow resistance (s/m). Also includes
+    real(r8) :: pondres                                                    ! Additional resistance from ponding, up to pondmx water on top of top soil layer (s/m)
+    real(r8) :: pondz                                                      ! Depth of ponding (m)
+    real(r8) :: ponddiff                                                   ! Pondwater diffusivity (m^2/s)
+    real(r8) :: spec_grnd_cond(bounds%begc:bounds%endc,1:ngases)           ! species grnd conductance (s/m)
     real(r8) :: airfrac                                                    ! air fraction in snow
     real(r8) :: waterfrac                                                  ! water fraction in snow
     real(r8) :: icefrac                                                    ! ice fraction in snow
-    real(r8) :: epsilon_t (1:num_methc,1:nlevsoi,1:ngases)     !
-    real(r8) :: epsilon_t_old (1:num_methc,1:nlevsoi,1:ngases) ! epsilon_t from last time step !Currently deprecated
-    real(r8) :: source (1:num_methc,1:nlevsoi,1:ngases)        ! source
-    real(r8) :: source_old (1:num_methc,1:nlevsoi,1:ngases)    ! source from last time step !Currently deprecated
+    real(r8) :: epsilon_t (bounds%begc:bounds%endc,1:nlevsoi,1:ngases)     !
+    real(r8) :: epsilon_t_old (bounds%begc:bounds%endc,1:nlevsoi,1:ngases) ! epsilon_t from last time step !Currently deprecated
+    real(r8) :: source (bounds%begc:bounds%endc,1:nlevsoi,1:ngases)        ! source
+    real(r8) :: source_old (bounds%begc:bounds%endc,1:nlevsoi,1:ngases)    ! source from last time step !Currently deprecated
     real(r8) :: om_frac                                                    ! organic matter fraction
     real(r8) :: o2demand, ch4demand                                        ! mol/m^3/s
-    real(r8) :: liqfrac(1:num_methc, 1:nlevsoi)
+    real(r8) :: liqfrac(bounds%begc:bounds%endc, 1:nlevsoi)
     real(r8) :: capthick                                                   ! (mm) min thickness before assuming h2osfc is impermeable
     real(r8) :: satpow                                                     ! exponent on watsat for saturated soil solute diffusion
     real(r8) :: scale_factor_gasdiff                                       ! For sensitivity tests; convection would allow this to be > 1
@@ -3078,12 +3010,28 @@ contains
     real(r8) :: organic_max                                                ! organic matter content (kg/m3) where soil is assumed to act like peat
     real(r8) :: aereoxid                                                   ! fraction of methane flux entering aerenchyma rhizosphere
 
+    real(r8), pointer :: ch4_prod_depth   (:,:)
+    real(r8), pointer :: ch4_oxid_depth   (:,:)
+    real(r8), pointer :: ch4_aere_depth   (:,:)
+    real(r8), pointer :: ch4_surf_aere    (:)
+    real(r8), pointer :: ch4_ebul_depth   (:,:)
+    real(r8), pointer :: ch4_ebul_total   (:)
+    real(r8), pointer :: ch4_surf_ebul    (:)
+    real(r8), pointer :: ch4_surf_diff    (:)
+    real(r8), pointer :: o2_oxid_depth    (:,:)
+    real(r8), pointer :: o2_decomp_depth  (:,:)
+    real(r8), pointer :: o2_aere_depth    (:,:)
+    real(r8), pointer :: o2stress         (:,:)
+    real(r8), pointer :: ch4stress        (:,:)
+    real(r8), pointer :: co2_decomp_depth (:,:)
+    real(r8), pointer :: conc_o2          (:,:)
+    real(r8), pointer :: conc_ch4         (:,:)
+
     integer  :: nstep                       ! time step number
     character(len=32) :: subname='ch4_tran' ! subroutine name
-    real(r8) :: sum1 
-    integer  :: erridx 
     !-----------------------------------------------------------------------
-    
+
+
     associate(                                                 &
          z             =>    col_pp%z                           , & ! Input:  [real(r8) (:,:) ]  soil layer depth (m)
          dz            =>    col_pp%dz                          , & ! Input:  [real(r8) (:,:) ]  layer thickness (m)  (-nlevsno+1:nlevsoi)
@@ -3107,48 +3055,61 @@ contains
          h2osfc        =>    col_ws%h2osfc      , & ! Input:  [real(r8) (:)   ]  surface water (mm)
 
          c_atm         =>    ch4_vars%c_atm_grc              , & ! Input:  [real(r8) (:,:) ]  CH4, O2, CO2 atmospheric conc  (mol/m3)
-         grnd_ch4_cond =>    ch4_vars%grnd_ch4_cond_col      ,  & ! Output: [real(r8) (:)   ]  tracer conductance for boundary layer [m/s]
-
-         ! Set transport parameters
-         satpow               => CH4ParamsInst%satpow , &
-         scale_factor_gasdiff => CH4ParamsInst%scale_factor_gasdiff,&
-         scale_factor_liqdiff => CH4ParamsInst%scale_factor_liqdiff,&
-         capthick             => CH4ParamsInst%capthick, &
-         aereoxid             => CH4ParamsInst%aereoxid, &
 
-         ! Set shared constant
-         organic_max => ParamsShareInst%organic_max &
+         grnd_ch4_cond =>    ch4_vars%grnd_ch4_cond_col        & ! Output: [real(r8) (:)   ]  tracer conductance for boundary layer [m/s]
          )
 
-    !$acc enter data create(&
-    !$acc at(:,:), &
-    !$acc bt(:,:), &
-    !$acc ct(:,:), &
-    !$acc rt(:,:), &
-    !$acc diffus(:,:), &
-    !$acc k_h_cc(:,:,:), &
-    !$acc dp1_zp1(:,:), &
-    !$acc dm1_zm1(:,:), &
-    !$acc conc_ch4_bef(:,:), &
-    !$acc errch4(:), &
-    !$acc conc_ch4_rel(:,:), &
-    !$acc conc_o2_rel(:,:), &
-    !$acc conc_ch4_rel_old(:,:), &
-    !$acc h2osoi_vol_min(:,:), &
-    !$acc snowres, &
-    !$acc spec_grnd_cond(:,:), &
-    !$acc epsilon_t(:,:,:), &
-    !$acc epsilon_t_old(:,:,:), &
-    !$acc source(:,:,:), &
-    !$acc source_old(:,:,:), &
-    !$acc liqfrac(:,:), &
-    !$acc snowdiff, &
-    !$acc pondres)
-   
+      if (sat == 0) then                                    ! unsaturated
+         o2_decomp_depth  => ch4_vars%o2_decomp_depth_unsat_col  ! Output: [real(r8) (:,:) ]  O2 consumption during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+         o2stress         => ch4_vars%o2stress_unsat_col         ! Output: [real(r8) (:,:) ]  Ratio of oxygen available to that demanded by roots, aerobes, & methanotrophs (nlevsoi)
+         ch4_oxid_depth   => ch4_vars%ch4_oxid_depth_unsat_col   ! Output: [real(r8) (:,:) ]  CH4 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_prod_depth   => ch4_vars%ch4_prod_depth_unsat_col   ! Output: [real(r8) (:,:) ]  CH4 production rate from methanotrophs (mol/m3/s) (nlevsoi)
+         ch4_aere_depth   => ch4_vars%ch4_aere_depth_unsat_col   ! Output: [real(r8) (:,:) ]  CH4 loss rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_surf_aere    => ch4_vars%ch4_surf_aere_unsat_col    ! Output: [real(r8) (:)   ]  Total column CH4 aerenchyma (mol/m2/s)
+         ch4_ebul_depth   => ch4_vars%ch4_ebul_depth_unsat_col   ! Output: [real(r8) (:,:) ]  CH4 loss rate via ebullition in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_ebul_total   => ch4_vars%ch4_ebul_total_unsat_col   ! Output: [real(r8) (:)   ]  Total column CH4 ebullition (mol/m2/s)
+         ch4_surf_ebul    => ch4_vars%ch4_surf_ebul_unsat_col    ! Output: [real(r8) (:)   ]  CH4 ebullition to atmosphere (mol/m2/s)
+         ch4_surf_diff    => ch4_vars%ch4_surf_diff_unsat_col    ! Output: [real(r8) (:)   ]  CH4 surface flux (mol/m2/s)
+         o2_oxid_depth    => ch4_vars%o2_oxid_depth_unsat_col    ! Output: [real(r8) (:,:) ]  O2 loss rate via ebullition in each soil layer (mol/m3/s) (nlevsoi)
+         o2_aere_depth    => ch4_vars%o2_aere_depth_unsat_col    ! Output: [real(r8) (:,:) ]  O2 gain rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         ch4stress        => ch4_vars%ch4stress_unsat_col        ! Output: [real(r8) (:,:) ]  Ratio of methane available to the total per-timestep methane sinks (nlevsoi)
+         co2_decomp_depth => ch4_vars%co2_decomp_depth_unsat_col ! Output: [real(r8) (:,:) ]  CO2 production during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+         conc_ch4         => ch4_vars%conc_ch4_unsat_col         ! Output: [real(r8) (:,:) ]  CH4 conc in each soil layer (mol/m3) (nlevsoi)
+         conc_o2          => ch4_vars%conc_o2_unsat_col          ! Output: [real(r8) (:,:) ]  O2 conc in each soil layer (mol/m3) (nlevsoi)
+      else                                                  ! saturated
+         o2_decomp_depth  => ch4_vars%o2_decomp_depth_sat_col    ! Output: [real(r8) (:,:) ]  O2 consumption during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+         o2stress         => ch4_vars%o2stress_sat_col           ! Output: [real(r8) (:,:) ]  Ratio of oxygen available to that demanded by roots, aerobes, & methanotrophs (nlevsoi)
+         ch4_oxid_depth   => ch4_vars%ch4_oxid_depth_sat_col     ! Output: [real(r8) (:,:) ]  CH4 consumption rate via oxidation in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_prod_depth   => ch4_vars%ch4_prod_depth_sat_col     ! Output: [real(r8) (:,:) ]  CH4 production rate from methanotrophs (mol/m3/s) (nlevsoi)
+         ch4_aere_depth   => ch4_vars%ch4_aere_depth_sat_col     ! Output: [real(r8) (:,:) ]  CH4 loss rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_surf_aere    => ch4_vars%ch4_surf_aere_sat_col      ! Output: [real(r8) (:)   ]  Total column CH4 aerenchyma (mol/m2/s)
+         ch4_ebul_depth   => ch4_vars%ch4_ebul_depth_sat_col     ! Output: [real(r8) (:,:) ]  CH4 loss rate via ebullition in each soil layer (mol/m3/s) (nlevsoi)
+         ch4_ebul_total   => ch4_vars%ch4_ebul_total_sat_col     ! Output: [real(r8) (:)   ]  Total column CH4 ebullition (mol/m2/s)
+         ch4_surf_ebul    => ch4_vars%ch4_surf_ebul_sat_col      ! Output: [real(r8) (:)   ]  CH4 ebullition to atmosphere (mol/m2/s)
+         ch4_surf_diff    => ch4_vars%ch4_surf_diff_sat_col      ! Output: [real(r8) (:)   ]  CH4 surface flux (mol/m2/s)
+         o2_oxid_depth    => ch4_vars%o2_oxid_depth_sat_col      ! Output: [real(r8) (:,:) ]  O2 loss rate via ebullition in each soil layer (mol/m3/s) (nlevsoi)
+         o2_aere_depth    => ch4_vars%o2_aere_depth_sat_col      ! Output: [real(r8) (:,:) ]  O2 gain rate via aerenchyma in each soil layer (mol/m3/s) (nlevsoi)
+         ch4stress        => ch4_vars%ch4stress_sat_col          ! Output: [real(r8) (:,:) ]  Ratio of methane available to the total per-timestep methane sinks (nlevsoi)
+         co2_decomp_depth => ch4_vars%co2_decomp_depth_sat_col   ! Output: [real(r8) (:,:) ]  CO2 production during decomposition in each soil layer (nlevsoi) (mol/m3/s)
+         conc_ch4         => ch4_vars%conc_ch4_sat_col           ! Output: [real(r8) (:,:) ]  CH4 conc in each soil layer (mol/m3) (nlevsoi)
+         conc_o2          => ch4_vars%conc_o2_sat_col            ! Output: [real(r8) (:,:) ]  O2 conc in each soil layer (mol/m3) (nlevsoi)
+      endif
+
+      ! Get land model time step
+
+      ! Set transport parameters
+      satpow               = CH4ParamsInst%satpow
+      scale_factor_gasdiff = CH4ParamsInst%scale_factor_gasdiff
+      scale_factor_liqdiff = CH4ParamsInst%scale_factor_liqdiff
+      capthick             = CH4ParamsInst%capthick
+      aereoxid             = CH4ParamsInst%aereoxid
+
+      ! Set shared constant
+      organic_max = ParamsShareInst%organic_max
+
       ! Perform competition for oxygen and methane in each soil layer if demands over the course of the timestep
       ! exceed that available. Assign to each process in proportion to the quantity demanded in the absense of
       ! the limitation.
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = 1,nlevsoi
          do fc = 1, num_methc
             c = filter_methc (fc)
@@ -3210,34 +3171,29 @@ contains
 
 
       ! Accumulate ebullition to place in first layer above water table, or directly to atmosphere
-      !$acc parallel loop independent gang worker default(present) private(sum1) 
-      do fc = 1, num_methc
-         c = filter_methc (fc)
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1) 
-         do j = 1,nlevsoi
-            sum1 = sum1 + ch4_ebul_depth(c,j) * dz(c,j)
+      do j = 1,nlevsoi
+         do fc = 1, num_methc
+            c = filter_methc (fc)
+            if (j == 1) ch4_ebul_total(c) = 0._r8
+            ch4_ebul_total(c) = ch4_ebul_total(c) + ch4_ebul_depth(c,j) * dz(c,j)
          enddo
-         ch4_ebul_total(c) = sum1 
       enddo
 
 
       ! Set the Henry's Law coefficients
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = 0,nlevsoi
          do fc = 1, num_methc
             c = filter_methc (fc)
 
-            !$acc loop seq
             do s=1,2
                if (j == 0) then
                   k_h_inv = exp(-c_h_inv(s) * (1._r8 / t_grnd(c) - 1._r8 / kh_tbase) + log (kh_theta(s)))
                   ! (4.12) Wania (L atm/mol)
-                  k_h_cc(fc,j,s) = t_grnd(c) / k_h_inv * rgasLatm ! (4.21) Wania [(mol/m3w) / (mol/m3g)]
+                  k_h_cc(c,j,s) = t_grnd(c) / k_h_inv * rgasLatm ! (4.21) Wania [(mol/m3w) / (mol/m3g)]
                else
                   k_h_inv = exp(-c_h_inv(s) * (1._r8 / t_soisno(c,j) - 1._r8 / kh_tbase) + log (kh_theta(s)))
                   ! (4.12) Wania (L atm/mol)
-                  k_h_cc(fc,j,s) = t_soisno(c,j) / k_h_inv * rgasLatm ! (4.21) Wania [(mol/m3w) / (mol/m3g)]
+                  k_h_cc(c,j,s) = t_soisno(c,j) / k_h_inv * rgasLatm ! (4.21) Wania [(mol/m3w) / (mol/m3g)]
                end if
             end do
          end do
@@ -3249,7 +3205,6 @@ contains
       ! sources, occasionally negative concentration will result. In this case it is brought to zero and the
       ! surface flux is adjusted to conserve. This results in some inaccuracy as compared to a shorter timestep
       ! or iterative solution.
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = 1,nlevsoi
          do fc = 1, num_methc
             c = filter_methc (fc)
@@ -3260,19 +3215,18 @@ contains
                ch4_aere_depth(c,j) = ch4_aere_depth(c,j) - aereoxid * ch4_aere_depth(c,j)
             end if ! else oxygen is allowed to diffuse in via aerenchyma
 
-            source(fc,j,1) = ch4_prod_depth(c,j) - ch4_oxid_depth(c,j) - &
+            source(c,j,1) = ch4_prod_depth(c,j) - ch4_oxid_depth(c,j) - &
                  ch4_aere_depth(c,j) - ch4_ebul_depth(c,j) ! [mol/m3-total/s]
             ! aerenchyma added to surface flux below
             ! ebul added to soil depth just above WT
-#ifndef _OPENACC
-            if (source(fc,j,1) + conc_ch4(c,j) / dtime < -1.e-12_r8) then
+            if (source(c,j,1) + conc_ch4(c,j) / dtime < -1.e-12_r8) then
                write(iulog,*) 'Methane demands exceed methane available. Error in methane competition (mol/m^3/s), c,j:',&
                     source(c,j,1) + conc_ch4(c,j) / dtime, c, j
                g = col_pp%gridcell(c)
                write(iulog,*)'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
                call endrun(msg=' ERROR: Methane demands exceed methane available.'&
                     //errMsg(__FILE__, __LINE__))
-            else if (ch4stress(c,j) < 1._r8 .and. source(fc,j,1) + conc_ch4(c,j) / dtime > 1.e-12_r8) then
+            else if (ch4stress(c,j) < 1._r8 .and. source(c,j,1) + conc_ch4(c,j) / dtime > 1.e-12_r8) then
                write(iulog,*) 'Methane limited, yet some left over. Error in methane competition (mol/m^3/s), c,j:',&
                     source(c,j,1) + conc_ch4(c,j) / dtime, c, j
                g = col_pp%gridcell(c)
@@ -3280,102 +3234,92 @@ contains
                call endrun(msg=' ERROR: Methane limited, yet some left over.'//&
                     errMsg(__FILE__, __LINE__))
             end if
-#endif
-            source(fc,j,2) = -o2_oxid_depth(c,j) - o2_decomp_depth(c,j) + o2_aere_depth(c,j) ! O2 [mol/m3/s]
-#ifndef _OPENACC
-            if (source(fc,j,2) + conc_o2(c,j) / dtime < -1.e-12_r8) then
+
+            source(c,j,2) = -o2_oxid_depth(c,j) - o2_decomp_depth(c,j) + o2_aere_depth(c,j) ! O2 [mol/m3/s]
+            if (source(c,j,2) + conc_o2(c,j) / dtime < -1.e-12_r8) then
                write(iulog,*) 'Oxygen demands exceed oxygen available. Error in oxygen competition (mol/m^3/s), c,j:',&
                     source(c,j,2) + conc_o2(c,j) / dtime, c, j
                g = col_pp%gridcell(c)
                write(iulog,*) 'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
                call endrun(msg=' ERROR: Oxygen demands exceed oxygen available.'//&
                     errMsg(__FILE__, __LINE__) )
-            else if (o2stress(c,j) < 1._r8 .and. source(fc,j,2) + conc_o2(c,j) / dtime > 1.e-12_r8) then
+            else if (o2stress(c,j) < 1._r8 .and. source(c,j,2) + conc_o2(c,j) / dtime > 1.e-12_r8) then
                write(iulog,*)  'Oxygen limited, yet some left over. Error in oxygen competition (mol/m^3/s), c,j:',&
                     source(c,j,2) + conc_o2(c,j) / dtime, c, j
                g = col_pp%gridcell(c)
                write(iulog,*)  'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
                call endrun(msg=' ERROR: Oxygen limited, yet some left over.'//errMsg(__FILE__, __LINE__))
             end if
-#endif 
-            conc_ch4_bef(fc,j) = conc_ch4(c,j) !For Balance Check
+
+            conc_ch4_bef(c,j) = conc_ch4(c,j) !For Balance Check
          enddo ! fc
       enddo ! j
 
       ! Accumulate aerenchyma to add directly to atmospheric flux
-      !$acc parallel loop independent gang worker default(present) private(sum1) 
-      do fc = 1, num_methc
-         c = filter_methc (fc)
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1)
-         do j = 1,nlevsoi
-            sum1 = sum1 + ch4_aere_depth(c,j) * dz(c,j)
+      do j = 1,nlevsoi
+         do fc = 1, num_methc
+            c = filter_methc (fc)
+            if (j==1) ch4_surf_aere(c) = 0._r8
+            ch4_surf_aere(c) = ch4_surf_aere(c) + ch4_aere_depth(c,j) * dz(c,j)
          enddo
-         ch4_surf_aere(c) = sum1 
       enddo
 
       ! Add in ebullition to source at depth just above WT
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_methc
          c = filter_methc(fc)
          if (jwt(c) /= 0) then
-            source(fc,jwt(c),1) = source(fc,jwt(c),1) + ch4_ebul_total(c)/dz(c,jwt(c))
+            source(c,jwt(c),1) = source(c,jwt(c),1) + ch4_ebul_total(c)/dz(c,jwt(c))
          endif
       enddo ! fc
 
       ! Calculate concentration relative to m^3 of air or water: needed for the diffusion
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = 0,nlevsoi
          do fc = 1, num_methc
             c = filter_methc (fc)
             g = col_pp%gridcell(c)
 
             if (j == 0) then
-               conc_ch4_rel(fc,j) = c_atm(g,1)
-               conc_o2_rel(fc,j)  = c_atm(g,2)
+               conc_ch4_rel(c,j) = c_atm(g,1)
+               conc_o2_rel(c,j)  = c_atm(g,2)
             else
-               h2osoi_vol_min(fc,j) = min(watsat(c,j), h2osoi_vol(c,j))
+               h2osoi_vol_min(c,j) = min(watsat(c,j), h2osoi_vol(c,j))
                if (ch4frzout) then
-                  liqfrac(fc,j) = max(0.05_r8, (h2osoi_liq(c,j)/denh2o+smallnumber)/ &
+                  liqfrac(c,j) = max(0.05_r8, (h2osoi_liq(c,j)/denh2o+smallnumber)/ &
                        (h2osoi_liq(c,j)/denh2o+h2osoi_ice(c,j)/denice+smallnumber))
                else
-                  liqfrac(fc,j) = 1._r8
+                  liqfrac(c,j) = 1._r8
                end if
                if (j <= jwt(c)) then  ! Above the WT
-                  !$acc loop seq
                   do s=1,2
-                     epsilon_t(fc,j,s) = watsat(c,j)- (1._r8-k_h_cc(fc,j,s))*h2osoi_vol_min(fc,j)*liqfrac(fc,j)
+                     epsilon_t(c,j,s) = watsat(c,j)- (1._r8-k_h_cc(c,j,s))*h2osoi_vol_min(c,j)*liqfrac(c,j)
                   end do
                   ! Partition between the liquid and gas phases. The gas phase will drive the diffusion.
                else ! Below the WT
-                  !$acc loop seq
                   do s=1,2
-                     epsilon_t(fc,j,s) = watsat(c,j)*liqfrac(fc,j)
+                     epsilon_t(c,j,s) = watsat(c,j)*liqfrac(c,j)
                   end do
                end if
-               conc_ch4_rel(fc,j) = conc_ch4(c,j)/epsilon_t(fc,j,1)
-               conc_o2_rel(fc,j)  = conc_o2(c,j) /epsilon_t(fc,j,2)
+               conc_ch4_rel(c,j) = conc_ch4(c,j)/epsilon_t(c,j,1)
+               conc_o2_rel(c,j)  = conc_o2(c,j) /epsilon_t(c,j,2)
             end if
          end do
       end do
 
-      !$acc enter data create(s) 
+
       ! Loop over species
       do s = 1, 2 ! 1=CH4; 2=O2; 3=CO2
 
-         !$acc update device(s) 
 
          ! Adjust the grnd_ch4_cond to keep it positive, and add the snow resistance & pond resistance
-         !$acc parallel loop independent gang worker default(present) private(snowres)
-         do fc = 1, num_methc
-            c = filter_methc (fc)
-            
-            if (grnd_ch4_cond(c) < smallnumber .and. s==1) grnd_ch4_cond(c) = smallnumber
-            ! Needed to prevent overflow when ground is frozen, e.g. for lakes
-            snowres = 0._r8
+         do j = -nlevsno + 1,0
+            do fc = 1, num_methc
+               c = filter_methc (fc)
 
-            !$acc loop vector reduction(+:snowres)
-            do j = -nlevsno + 1,-1
+               if (j == -nlevsno + 1) then
+                  if (grnd_ch4_cond(c) < smallnumber .and. s==1) grnd_ch4_cond(c) = smallnumber
+                  ! Needed to prevent overflow when ground is frozen, e.g. for lakes
+                  snowres(c) = 0._r8
+               end if
 
                ! Add snow resistance
                if (j >= snl(c) + 1) then
@@ -3389,56 +3333,58 @@ contains
                      eps = airfrac ! Air-filled fraction of total snow volume
                      ! Use Millington-Quirk Expression, as hydraulic properties (bsw) not available
                      snowdiff = (d_con_g(s,1) + d_con_g(s,2)*t_soisno_c) * 1.e-4_r8 * &
-                          f_a**(10._r8/3._r8) / (airfrac+waterfrac)**2 * scale_factor_gasdiff
+                          f_a**(10._r8/3._r8) / (airfrac+waterfrac)**2 &
+                          * scale_factor_gasdiff
                   else !solute diffusion in water only
                      eps = waterfrac  ! Water-filled fraction of total soil volume
                      snowdiff = eps**satpow * (d_con_w(s,1) + d_con_w(s,2)*t_soisno_c + d_con_w(s,3)*t_soisno_c**2) * 1.e-9_r8 &
                           * scale_factor_liqdiff
                   end if
                   snowdiff = max(snowdiff, smallnumber)
-                  snowres = snowres + dz(c,j)/snowdiff
-               end if
-            end do 
-
-            ! Add pond resistance
-            pondres = 0._r8
-
-            ! First old pond formulation up to pondmx
-            if (.not. lake .and. snl(c) == 0 .and. h2osoi_vol(c,1) > watsat(c,1)) then
-               t_soisno_c = t_soisno(c,1) - tfrz
-               if (t_soisno(c,1) <= tfrz) then
-                  ponddiff = (d_con_w(s,1) + d_con_w(s,2)*t_soisno_c + d_con_w(s,3)*t_soisno_c**2) * 1.e-9_r8 &
-                       * (h2osoi_liq(c,1)/denh2o+smallnumber)/ &
-                       (h2osoi_liq(c,1)/denh2o+h2osoi_ice(c,1)/denice+smallnumber) &
-                       * scale_factor_liqdiff
-               else ! Unfrozen
-                  ponddiff = (d_con_w(s,1) + d_con_w(s,2)*t_soisno_c + d_con_w(s,3)*t_soisno_c**2) * 1.e-9_r8 &
-                       * scale_factor_liqdiff
+                  snowres(c) = snowres(c) + dz(c,j)/snowdiff
                end if
-               pondz = dz(c,1) * (h2osoi_vol(c,1) - watsat(c,1))
-               pondres = pondz / ponddiff
-            end if
 
-            ! Now add new h2osfc form
-            if (.not. lake .and. sat == 1 .and. frac_h2osfc(c) > 0._r8 .and. t_h2osfc(c) >= tfrz) then
-               t_soisno_c = t_h2osfc(c) - tfrz
-               ponddiff = (d_con_w(s,1) + d_con_w(s,2)*t_soisno_c + d_con_w(s,3)*t_soisno_c**2) * 1.e-9_r8 &
-                    * scale_factor_liqdiff
-               pondz = h2osfc(c) / 1000._r8 / frac_h2osfc(c) ! Assume all h2osfc corresponds to sat area
-               ! mm      /  mm/m
-               pondres = pondres + pondz / ponddiff
-            else if (.not. lake .and. sat == 1 .and. frac_h2osfc(c) > 0._r8 .and. &
-                 h2osfc(c)/frac_h2osfc(c) > capthick) then ! Assuming short-circuit logic will avoid FPE here.
-               ! assume surface ice is impermeable
-               pondres = 1/smallnumber
-            end if
+               if (j == 0) then ! final loop
+                  ! Add pond resistance
+                  pondres = 0._r8
+
+                  ! First old pond formulation up to pondmx
+                  if (.not. lake .and. snl(c) == 0 .and. h2osoi_vol(c,1) > watsat(c,1)) then
+                     t_soisno_c = t_soisno(c,1) - tfrz
+                     if (t_soisno(c,1) <= tfrz) then
+                        ponddiff = (d_con_w(s,1) + d_con_w(s,2)*t_soisno_c + d_con_w(s,3)*t_soisno_c**2) * 1.e-9_r8 &
+                             * (h2osoi_liq(c,1)/denh2o+smallnumber)/ &
+                             (h2osoi_liq(c,1)/denh2o+h2osoi_ice(c,1)/denice+smallnumber) &
+                             * scale_factor_liqdiff
+                     else ! Unfrozen
+                        ponddiff = (d_con_w(s,1) + d_con_w(s,2)*t_soisno_c + d_con_w(s,3)*t_soisno_c**2) * 1.e-9_r8 &
+                             * scale_factor_liqdiff
+                     end if
+                     pondz = dz(c,1) * (h2osoi_vol(c,1) - watsat(c,1))
+                     pondres = pondz / ponddiff
+                  end if
+
+                  ! Now add new h2osfc form
+                  if (.not. lake .and. sat == 1 .and. frac_h2osfc(c) > 0._r8 .and. t_h2osfc(c) >= tfrz) then
+                     t_soisno_c = t_h2osfc(c) - tfrz
+                     ponddiff = (d_con_w(s,1) + d_con_w(s,2)*t_soisno_c + d_con_w(s,3)*t_soisno_c**2) * 1.e-9_r8 &
+                          * scale_factor_liqdiff
+                     pondz = h2osfc(c) / 1000._r8 / frac_h2osfc(c) ! Assume all h2osfc corresponds to sat area
+                     ! mm      /  mm/m
+                     pondres = pondres + pondz / ponddiff
+                  else if (.not. lake .and. sat == 1 .and. frac_h2osfc(c) > 0._r8 .and. &
+                       h2osfc(c)/frac_h2osfc(c) > capthick) then ! Assuming short-circuit logic will avoid FPE here.
+                     ! assume surface ice is impermeable
+                     pondres = 1/smallnumber
+                  end if
 
-            spec_grnd_cond(fc,s) = 1._r8/(1._r8/grnd_ch4_cond(c) + snowres + pondres)
+                  spec_grnd_cond(c,s) = 1._r8/(1._r8/grnd_ch4_cond(c) + snowres(c) + pondres)
+               end if
 
-         end do ! fc 
+            end do ! fc
+         end do ! j
 
          ! Determine gas diffusion and fraction of open pore (f_a)
-         !$acc parallel loop independent gang vector default(present) collapse(2) 
          do j = 1,nlevsoi
             do fc = 1, num_methc
                c = filter_methc (fc)
@@ -3447,17 +3393,17 @@ contains
                t_soisno_c = t_soisno(c,j) - tfrz
 
                if (j <= jwt(c)) then  ! Above the WT
-                  f_a = 1._r8 - h2osoi_vol_min(fc,j) / watsat(c,j)
+                  f_a = 1._r8 - h2osoi_vol_min(c,j) / watsat(c,j)
                   ! Provisionally calculate diffusivity as linear combination of the Millington-Quirk
                   ! expression in Wania (for peat) & Moldrup (for mineral soil)
-                  eps =  watsat(c,j)-h2osoi_vol_min(fc,j) ! Air-filled fraction of total soil volume
+                  eps =  watsat(c,j)-h2osoi_vol_min(c,j) ! Air-filled fraction of total soil volume
                   if (organic_max > 0._r8) then
                      om_frac = min(cellorg(c,j)/organic_max, 1._r8)
                      ! Use first power, not square as in iniTimeConst
                   else
                      om_frac = 1._r8
                   end if
-                  diffus(fc,j) = (d_con_g(s,1) + d_con_g(s,2)*t_soisno_c) * 1.e-4_r8 * &
+                  diffus (c,j) = (d_con_g(s,1) + d_con_g(s,2)*t_soisno_c) * 1.e-4_r8 * &
                        (om_frac * f_a**(10._r8/3._r8) / watsat(c,j)**2._r8 + &
                        (1._r8-om_frac) * eps**2._r8 * f_a**(3._r8 / bsw(c,j)) ) &
                        * scale_factor_gasdiff
@@ -3465,163 +3411,166 @@ contains
                   ! Note the following is not currently corrected for the effect on diffusivity of excess ice in soil under
                   ! lakes (which is currently experimental only).
                   eps = watsat(c,j)  ! Water-filled fraction of total soil volume
-                  diffus(fc,j) = eps**satpow * (d_con_w(s,1) + d_con_w(s,2)*t_soisno_c + d_con_w(s,3)*t_soisno_c**2) * 1.e-9_r8 &
+                  diffus (c,j) = eps**satpow * (d_con_w(s,1) + d_con_w(s,2)*t_soisno_c + d_con_w(s,3)*t_soisno_c**2) * 1.e-9_r8 &
                        * scale_factor_liqdiff
                   if (t_soisno(c,j)<=tfrz) then
-                     diffus(fc,j) = diffus(fc,j)*(h2osoi_liq(c,j)/denh2o+smallnumber)/ &
+                     diffus(c,j) = diffus(c,j)*(h2osoi_liq(c,j)/denh2o+smallnumber)/ &
                           (h2osoi_liq(c,j)/denh2o+h2osoi_ice(c,j)/denice+smallnumber)
                   end if
                endif ! Above/below the WT
-               diffus(fc,j) = max(diffus(fc,j), smallnumber) ! Prevent overflow
+               diffus(c,j) = max(diffus(c,j), smallnumber) ! Prevent overflow
 
             enddo ! fp
          enddo ! j
 
-         !$acc parallel loop independent gang vector default(present) collapse(2) 
          do j = 1,nlevsoi
             do fc = 1, num_methc
                c = filter_methc (fc)
 
                ! Set up coefficients for tridiagonal solver.
                if (j == 1 .and. j /= jwt(c) .and. j /= jwt(c)+1) then
-                  dm1_zm1(fc,j) = 1._r8/(1._r8/spec_grnd_cond(fc,s)+dz(c,j)/(diffus(fc,j)*2._r8))
+                  dm1_zm1(c,j) = 1._r8/(1._r8/spec_grnd_cond(c,s)+dz(c,j)/(diffus(c,j)*2._r8))
                   ! replace Diffusivity / Delta_z by conductance (grnd_ch4_cond) for top layer
-                  dp1_zp1(fc,j) = 2._r8/(dz(c,j)/diffus(fc,j)+dz(c,j+1)/diffus(fc,j+1))
+                  dp1_zp1(c,j) = 2._r8/(dz(c,j)/diffus(c,j)+dz(c,j+1)/diffus(c,j+1))
                else if (j == 1 .and. j == jwt(c)) then
-                  dm1_zm1(fc,j) = 1._r8/(1._r8/spec_grnd_cond(fc,s)+dz(c,j)/(diffus(fc,j)*2._r8))
+                  dm1_zm1(c,j) = 1._r8/(1._r8/spec_grnd_cond(c,s)+dz(c,j)/(diffus(c,j)*2._r8))
                   ! layer resistance mult. by k_h_cc for dp1_zp1 term
-                  dp1_zp1(fc,j) = 2._r8/(dz(c,j)*k_h_cc(fc,j,s)/diffus(fc,j)+dz(c,j+1)/diffus(fc,j+1))
+                  dp1_zp1(c,j) = 2._r8/(dz(c,j)*k_h_cc(c,j,s)/diffus(c,j)+dz(c,j+1)/diffus(c,j+1))
                else if (j == 1) then ! water table at surface: multiply ground resistance by k_h_cc
-                  dm1_zm1(fc,j) = 1._r8/(k_h_cc(fc,j-1,s)/spec_grnd_cond(fc,s)+dz(c,j)/(diffus(fc,j)*2._r8))
+                  dm1_zm1(c,j) = 1._r8/(k_h_cc(c,j-1,s)/spec_grnd_cond(c,s)+dz(c,j)/(diffus(c,j)*2._r8))
                   ! air concentration will be mult. by k_h_cc below
-                  dp1_zp1(fc,j) = 2._r8/(dz(c,j)/diffus(fc,j)+dz(c,j+1)/diffus(fc,j+1))
+                  dp1_zp1(c,j) = 2._r8/(dz(c,j)/diffus(c,j)+dz(c,j+1)/diffus(c,j+1))
                else if (j <= nlevsoi-1 .and. j /= jwt(c) .and. j /= jwt(c)+1) then
-                  dm1_zm1(fc,j) = 2._r8/(dz(c,j)/diffus(fc,j)+dz(c,j-1)/diffus(fc,j-1))
-                  dp1_zp1(fc,j) = 2._r8/(dz(c,j)/diffus(fc,j)+dz(c,j+1)/diffus(fc,j+1))
+                  dm1_zm1(c,j) = 2._r8/(dz(c,j)/diffus(c,j)+dz(c,j-1)/diffus(c,j-1))
+                  dp1_zp1(c,j) = 2._r8/(dz(c,j)/diffus(c,j)+dz(c,j+1)/diffus(c,j+1))
                else if (j <= nlevsoi-1 .and. j == jwt(c)) then ! layer resistance mult. by k_h_cc for dp1_zp1 term
-                  dm1_zm1(fc,j) = 2._r8/(dz(c,j)/diffus(fc,j)+dz(c,j-1)/diffus(fc,j-1))
-                  dp1_zp1(fc,j) = 2._r8/(dz(c,j)*k_h_cc(fc,j,s)/diffus(fc,j)+dz(c,j+1)/diffus(fc,j+1))
+                  dm1_zm1(c,j) = 2._r8/(dz(c,j)/diffus(c,j)+dz(c,j-1)/diffus(c,j-1))
+                  dp1_zp1(c,j) = 2._r8/(dz(c,j)*k_h_cc(c,j,s)/diffus(c,j)+dz(c,j+1)/diffus(c,j+1))
                   ! Concentration in layer will be mult. by k_h_cc below
                else if (j <= nlevsoi-1) then ! j==jwt+1: layer above resistance mult. by k_h_cc for dm1_zm1 term
-                  dm1_zm1(fc,j) = 2._r8/(dz(c,j)/diffus(fc,j)+dz(c,j-1)*k_h_cc(fc,j-1,s)/diffus(fc,j-1))
+                  dm1_zm1(c,j) = 2._r8/(dz(c,j)/diffus(c,j)+dz(c,j-1)*k_h_cc(c,j-1,s)/diffus(c,j-1))
                   ! Concentration in layer above will be mult. by k_h_cc below
-                  dp1_zp1(fc,j) = 2._r8/(dz(c,j)/diffus(fc,j)+dz(c,j+1)/diffus(fc,j+1))
+                  dp1_zp1(c,j) = 2._r8/(dz(c,j)/diffus(c,j)+dz(c,j+1)/diffus(c,j+1))
                else if (j /= jwt(c)+1) then ! j ==nlevsoi
-                  dm1_zm1(fc,j) = 2._r8/(dz(c,j)/diffus(fc,j)+dz(c,j-1)/diffus(fc,j-1))
+                  dm1_zm1(c,j) = 2._r8/(dz(c,j)/diffus(c,j)+dz(c,j-1)/diffus(c,j-1))
                else                    ! jwt == nlevsoi-1: layer above resistance mult. by k_h_cc for dm1_zm1 term
-                  dm1_zm1(fc,j) = 2._r8/(dz(c,j)/diffus(fc,j)+dz(c,j-1)*k_h_cc(fc,j-1,s)/diffus(fc,j-1))
+                  dm1_zm1(c,j) = 2._r8/(dz(c,j)/diffus(c,j)+dz(c,j-1)*k_h_cc(c,j-1,s)/diffus(c,j-1))
                end if
             enddo ! fp; pft
          end do ! j; nlevsoi
 
          ! Perform a second loop for the tridiagonal coefficients since need dp1_zp1 and dm1_z1 at each depth
-         !$acc parallel loop independent gang vector default(present) collapse(2) 
          do j = 0,nlevsoi
             do fc = 1, num_methc
                c = filter_methc (fc)
                g = col_pp%gridcell(c)
-               conc_ch4_rel_old(fc,j) = conc_ch4_rel(fc,j)
+               conc_ch4_rel_old(c,j) = conc_ch4_rel(c,j)
 
                if (j > 0) dzj = dz(c,j)
                if (j == 0) then ! top layer (atmosphere) doesn't change regardless of where WT is
-                  at(fc,j) = 0._r8
-                  bt(fc,j) = 1._r8
-                  ct(fc,j) = 0._r8
-                  rt(fc,j) = c_atm(g,s) ! 0th level stays at constant atmospheric conc
+                  at(c,j) = 0._r8
+                  bt(c,j) = 1._r8
+                  ct(c,j) = 0._r8
+                  rt(c,j) = c_atm(g,s) ! 0th level stays at constant atmospheric conc
                elseif (j < nlevsoi .and. j == jwt(c)) then ! concentration inside needs to be mult. by k_h_cc for dp1_zp1 term
-                  at(fc,j) = -0.5_r8 / dzj * dm1_zm1(fc,j)
-                  bt(fc,j) = epsilon_t(fc,j,s) / dtime_ch4 + 0.5_r8 / dzj * (dp1_zp1(fc,j)*k_h_cc(fc,j,s) + dm1_zm1(fc,j))
-                  ct(fc,j) = -0.5_r8 / dzj * dp1_zp1(fc,j)
+                  at(c,j) = -0.5_r8 / dzj * dm1_zm1(c,j)
+                  bt(c,j) = epsilon_t(c,j,s) / dtime_ch4 + 0.5_r8 / dzj * (dp1_zp1(c,j)*k_h_cc(c,j,s) + dm1_zm1(c,j))
+                  ct(c,j) = -0.5_r8 / dzj * dp1_zp1(c,j)
                elseif (j < nlevsoi .and. j == jwt(c)+1) then
                   ! concentration above needs to be mult. by k_h_cc for dm1_zm1 term
-                  at(fc,j) = -0.5_r8 / dzj * dm1_zm1(fc,j) * k_h_cc(fc,j-1,s)
-                  bt(fc,j) = epsilon_t(fc,j,s) / dtime_ch4 + 0.5_r8 / dzj * (dp1_zp1(fc,j) + dm1_zm1(fc,j))
-                  ct(fc,j) = -0.5_r8 / dzj * dp1_zp1(fc,j)
+                  at(c,j) = -0.5_r8 / dzj * dm1_zm1(c,j) * k_h_cc(c,j-1,s)
+                  bt(c,j) = epsilon_t(c,j,s) / dtime_ch4 + 0.5_r8 / dzj * (dp1_zp1(c,j) + dm1_zm1(c,j))
+                  ct(c,j) = -0.5_r8 / dzj * dp1_zp1(c,j)
                elseif (j < nlevsoi) then
-                  at(fc,j) = -0.5_r8 / dzj * dm1_zm1(fc,j)
-                  bt(fc,j) = epsilon_t(fc,j,s) / dtime_ch4 + 0.5_r8 / dzj * (dp1_zp1(fc,j) + dm1_zm1(fc,j))
-                  ct(fc,j) = -0.5_r8 / dzj * dp1_zp1(fc,j)
+                  at(c,j) = -0.5_r8 / dzj * dm1_zm1(c,j)
+                  bt(c,j) = epsilon_t(c,j,s) / dtime_ch4 + 0.5_r8 / dzj * (dp1_zp1(c,j) + dm1_zm1(c,j))
+                  ct(c,j) = -0.5_r8 / dzj * dp1_zp1(c,j)
                else if (j == nlevsoi .and. j== jwt(c)+1) then
                   ! concentration above needs to be mult. by k_h_cc for dm1_zm1 term
-                  at(fc,j) = -0.5_r8 / dzj * dm1_zm1(fc,j) * k_h_cc(fc,j-1,s)
-                  bt(fc,j) = epsilon_t(fc,j,s) / dtime_ch4 + 0.5_r8 / dzj * dm1_zm1(fc,j)
-                  ct(fc,j) = 0._r8
+                  at(c,j) = -0.5_r8 / dzj * dm1_zm1(c,j) * k_h_cc(c,j-1,s)
+                  bt(c,j) = epsilon_t(c,j,s) / dtime_ch4 + 0.5_r8 / dzj * dm1_zm1(c,j)
+                  ct(c,j) = 0._r8
                else ! j==nlevsoi and jwt<nlevsoi-1 or jwt==nlevsoi: 0 flux at bottom
-                  at(fc,j) = -0.5_r8 / dzj * dm1_zm1(fc,j)
-                  bt(fc,j) = epsilon_t(fc,j,s) / dtime_ch4 + 0.5_r8 / dzj * dm1_zm1(fc,j)
-                  ct(fc,j) = 0._r8
+                  at(c,j) = -0.5_r8 / dzj * dm1_zm1(c,j)
+                  bt(c,j) = epsilon_t(c,j,s) / dtime_ch4 + 0.5_r8 / dzj * dm1_zm1(c,j)
+                  ct(c,j) = 0._r8
                endif
             enddo ! fp; pft
          enddo ! j; nlevsoi
 
+         do fc = 1, num_methc
+            c = filter_methc (fc)
+            jtop(c) = 0
+         end do
+
          if (s == 1) then  ! CH4
 
             ! Set rt, since it depends on conc
-            !$acc parallel loop independent gang vector default(present) collapse(2) 
             do j = 1,nlevsoi
                do fc = 1, num_methc
                   c = filter_methc (fc)
 
                   ! For correct balance, deprecate source_old.
                   ! The source terms are effectively constant over the timestep.
-                  source_old(fc,j,s) = source(fc,j,s)
+                  source_old(c,j,s) = source(c,j,s)
                   ! source_old could be removed later
-                  epsilon_t_old(fc,j,s) = epsilon_t(fc,j,s)
+                  epsilon_t_old(c,j,s) = epsilon_t(c,j,s)
                   ! epsilon_t acts like source also
                   dzj = dz(c,j)
                   if (j < nlevsoi .and. j == jwt(c)) then ! concentration inside needs to be mult. by k_h_cc for dp1_zp1 term
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_ch4_rel(fc,j) +           &
-                          0.5_r8 / dzj * (dp1_zp1(fc,j) * (conc_ch4_rel(fc,j+1)-conc_ch4_rel(fc,j)*k_h_cc(fc,j,s)) - &
-                          dm1_zm1(fc,j) * (conc_ch4_rel(fc,j)  -conc_ch4_rel(fc,j-1))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_ch4_rel(c,j) +           &
+                          0.5_r8 / dzj * (dp1_zp1(c,j) * (conc_ch4_rel(c,j+1)-conc_ch4_rel(c,j)*k_h_cc(c,j,s)) - &
+                          dm1_zm1(c,j) * (conc_ch4_rel(c,j)  -conc_ch4_rel(c,j-1))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   elseif (j < nlevsoi .and. j == jwt(c)+1) then
                      ! concentration above needs to be mult. by k_h_cc for dm1_zm1 term
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_ch4_rel(fc,j) +           &
-                          0.5_r8 / dzj * (dp1_zp1(fc,j) * (conc_ch4_rel(fc,j+1)-conc_ch4_rel(fc,j)) - &
-                          dm1_zm1(fc,j) * (conc_ch4_rel(fc,j) -conc_ch4_rel(fc,j-1)*k_h_cc(fc,j-1,s))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_ch4_rel(c,j) +           &
+                          0.5_r8 / dzj * (dp1_zp1(c,j) * (conc_ch4_rel(c,j+1)-conc_ch4_rel(c,j)) - &
+                          dm1_zm1(c,j) * (conc_ch4_rel(c,j) -conc_ch4_rel(c,j-1)*k_h_cc(c,j-1,s))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   elseif (j < nlevsoi) then
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_ch4_rel(fc,j) +           &
-                          0.5_r8 / dzj * (dp1_zp1(fc,j) * (conc_ch4_rel(fc,j+1)-conc_ch4_rel(fc,j)) - &
-                          dm1_zm1(fc,j) * (conc_ch4_rel(fc,j)  -conc_ch4_rel(fc,j-1))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_ch4_rel(c,j) +           &
+                          0.5_r8 / dzj * (dp1_zp1(c,j) * (conc_ch4_rel(c,j+1)-conc_ch4_rel(c,j)) - &
+                          dm1_zm1(c,j) * (conc_ch4_rel(c,j)  -conc_ch4_rel(c,j-1))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   else if (j == nlevsoi .and. j== jwt(c)+1) then
                      ! concentration above needs to be mult. by k_h_cc for dm1_zm1 term
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_ch4_rel(fc,j) +           &
-                          0.5_r8 / dzj * ( - dm1_zm1(fc,j) * (conc_ch4_rel(fc,j) -conc_ch4_rel(fc,j-1)*k_h_cc(fc,j-1,s))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_ch4_rel(c,j) +           &
+                          0.5_r8 / dzj * ( - dm1_zm1(c,j) * (conc_ch4_rel(c,j) -conc_ch4_rel(c,j-1)*k_h_cc(c,j-1,s))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   else  !j==nlevsoi
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_ch4_rel(fc,j) +           &
-                          0.5_r8 / dzj * ( - dm1_zm1(fc,j) * (conc_ch4_rel(fc,j)  -conc_ch4_rel(fc,j-1))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_ch4_rel(c,j) +           &
+                          0.5_r8 / dzj * ( - dm1_zm1(c,j) * (conc_ch4_rel(c,j)  -conc_ch4_rel(c,j-1))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   endif
-                  epsilon_t_old(fc,j,s) = epsilon_t(fc,j,s)
-                  source_old(fc,j,s) = source(fc,j,s)
+                  epsilon_t_old(c,j,s) = epsilon_t(c,j,s)
+                  source_old(c,j,s) = source(c,j,s)
 
                enddo ! fc; column
             enddo ! j; nlevsoi
 
-            call Tridiagonal_filter( 0, nlevsoi, jtop, num_methc, filter_methc, &
-                 at, &
-                 bt, &
-                 ct, &
-                 rt, &
-                 conc_ch4_rel)
+            call Tridiagonal(bounds, 0, nlevsoi, &
+                 jtop(bounds%begc:bounds%endc), &
+                 num_methc, filter_methc, &
+                 at(bounds%begc:bounds%endc, :), &
+                 bt(bounds%begc:bounds%endc, :), &
+                 ct(bounds%begc:bounds%endc, :), &
+                 rt(bounds%begc:bounds%endc, :), &
+                 conc_ch4_rel(bounds%begc:bounds%endc, 0:nlevsoi))
 
             ! Calculate net ch4 flux to the atmosphere from the surface (+ to atm)
-            !$acc parallel loop independent gang vector default(present)
             do fc = 1, num_methc
                c = filter_methc (fc)
                g = col_pp%gridcell(c)
                if (jwt(c) /= 0) then ! WT not at the surface
-                  ch4_surf_diff(c) = dm1_zm1(fc,1) * ( (conc_ch4_rel(fc,1)+conc_ch4_rel_old(fc,1))/2._r8 &
+                  ch4_surf_diff(c) = dm1_zm1(c,1) * ( (conc_ch4_rel(c,1)+conc_ch4_rel_old(c,1))/2._r8 &
                        - c_atm(g,s)) ! [mol/m2/s]
                   ch4_surf_ebul(c) = 0._r8 ! all the ebullition has already come out in the soil column (added to source)
                   ! Try adding directly to atm. to prevent destabilization of diffusion
                   !ch4_surf_ebul(c) = ch4_ebul_total(c) ! [mol/m2/s]
                else ! WT at the surface; i.e., jwt(c)==0
-                  ch4_surf_diff(c) = dm1_zm1(fc,1) * ( (conc_ch4_rel(fc,1)+conc_ch4_rel_old(fc,1))/2._r8 &
-                       - c_atm(g,s)*k_h_cc(fc,0,s)) ! [mol/m2/s]
+                  ch4_surf_diff(c) = dm1_zm1(c,1) * ( (conc_ch4_rel(c,1)+conc_ch4_rel_old(c,1))/2._r8 &
+                       - c_atm(g,s)*k_h_cc(c,0,s)) ! [mol/m2/s]
                   ! atmospheric concentration gets mult. by k_h_cc as above
                   ch4_surf_ebul(c) = ch4_ebul_total(c) ! [mol/m2/s]
                endif
@@ -3629,14 +3578,12 @@ contains
 
             ! Ensure that concentrations stay above 0
             ! This should be done after the flux, so that the flux calculation is consistent.
-            !$acc parallel loop independent gang vector collapse(2) default(present)
             do j = 1,nlevsoi
                do fc = 1, num_methc
                   c = filter_methc (fc)
 
-                  if (conc_ch4_rel(fc,j) < 0._r8) then
-                     deficit = - conc_ch4_rel(fc,j)*epsilon_t(fc,j,1)*dz(c,j)  ! Mol/m^2 added
-                     #ifndef _OPENACC 
+                  if (conc_ch4_rel(c,j) < 0._r8) then
+                     deficit = - conc_ch4_rel(c,j)*epsilon_t(c,j,1)*dz(c,j)  ! Mol/m^2 added
                      if (deficit > 1.e-3_r8 * scale_factor_gasdiff) then
                         if (deficit > 1.e-2_r8) then
                            write(iulog,*)  'Note: sink > source in ch4_tran, sources are changing '// &
@@ -3647,10 +3594,9 @@ contains
                            write(iulog,*) 'If this occurs frequently, consider reducing land model (or  methane model) timestep, or reducing the max. sink per timestep in the methane model.'
                         end if
                      end if
-                     #endif 
-                     conc_ch4_rel(fc,j) = 0._r8
+                     conc_ch4_rel(c,j) = 0._r8
                      ! Subtract deficit
-                     ch4_surf_diff(c) = ch4_surf_diff(c) - deficit/dtime_mod
+                     ch4_surf_diff(c) = ch4_surf_diff(c) - deficit/dtime_ch4
                   end if
                enddo
             enddo
@@ -3659,148 +3605,111 @@ contains
          elseif (s == 2) then  ! O2
 
             ! Set rt, since it depends on conc
-            !$acc parallel loop independent collapse(2) gang vector default(present) 
             do j = 1,nlevsoi
                do fc = 1, num_methc
                   c = filter_methc (fc)
 
                   ! For correct balance, deprecate source_old.
-                  source_old(fc,j,s) = source(fc,j,s)
+                  source_old(c,j,s) = source(c,j,s)
                   ! source_old could be removed later
-                  epsilon_t_old(fc,j,s) = epsilon_t(fc,j,s)
+                  epsilon_t_old(c,j,s) = epsilon_t(c,j,s)
                   ! epsilon_t acts like source also
                   dzj     = dz(c,j)
                   if (j < nlevsoi .and. j == jwt(c)) then ! concentration inside needs to be mult. by k_h_cc for dp1_zp1 term
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_o2_rel(fc,j) +           &
-                          0.5_r8 / dzj * (dp1_zp1(fc,j) * (conc_o2_rel(fc,j+1)-conc_o2_rel(fc,j)*k_h_cc(fc,j,s)) - &
-                          dm1_zm1(fc,j) * (conc_o2_rel(fc,j)  -conc_o2_rel(fc,j-1))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_o2_rel(c,j) +           &
+                          0.5_r8 / dzj * (dp1_zp1(c,j) * (conc_o2_rel(c,j+1)-conc_o2_rel(c,j)*k_h_cc(c,j,s)) - &
+                          dm1_zm1(c,j) * (conc_o2_rel(c,j)  -conc_o2_rel(c,j-1))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   elseif (j < nlevsoi .and. j == jwt(c)+1) then
                      ! concentration above needs to be mult. by k_h_cc for dm1_zm1 term
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_o2_rel(fc,j) +           &
-                          0.5_r8 / dzj * (dp1_zp1(fc,j) * (conc_o2_rel(fc,j+1)-conc_o2_rel(fc,j)) - &
-                          dm1_zm1(fc,j) * (conc_o2_rel(fc,j) -conc_o2_rel(fc,j-1)*k_h_cc(fc,j-1,s))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_o2_rel(c,j) +           &
+                          0.5_r8 / dzj * (dp1_zp1(c,j) * (conc_o2_rel(c,j+1)-conc_o2_rel(c,j)) - &
+                          dm1_zm1(c,j) * (conc_o2_rel(c,j) -conc_o2_rel(c,j-1)*k_h_cc(c,j-1,s))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   elseif (j < nlevsoi) then
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_o2_rel(fc,j) +           &
-                          0.5_r8 / dzj * (dp1_zp1(fc,j) * (conc_o2_rel(fc,j+1)-conc_o2_rel(fc,j)) - &
-                          dm1_zm1(fc,j) * (conc_o2_rel(fc,j)  -conc_o2_rel(fc,j-1))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_o2_rel(c,j) +           &
+                          0.5_r8 / dzj * (dp1_zp1(c,j) * (conc_o2_rel(c,j+1)-conc_o2_rel(c,j)) - &
+                          dm1_zm1(c,j) * (conc_o2_rel(c,j)  -conc_o2_rel(c,j-1))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   else if (j == nlevsoi .and. j== jwt(c)+1) then
                      ! concentration above needs to be mult. by k_h_cc for dm1_zm1 term
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_o2_rel(fc,j) +           &
-                          0.5_r8 / dzj * ( - dm1_zm1(fc,j) * (conc_o2_rel(fc,j) -conc_o2_rel(fc,j-1)*k_h_cc(fc,j-1,s))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_o2_rel(c,j) +           &
+                          0.5_r8 / dzj * ( - dm1_zm1(c,j) * (conc_o2_rel(c,j) -conc_o2_rel(c,j-1)*k_h_cc(c,j-1,s))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   else  !j==nlevsoi
-                     rt(fc,j) = epsilon_t_old(fc,j,s) / dtime_ch4 * conc_o2_rel(fc,j) +           &
-                          0.5_r8 / dzj * ( - dm1_zm1(fc,j) * (conc_o2_rel(fc,j)  -conc_o2_rel(fc,j-1))) + &
-                          0.5_r8 * (source(fc,j,s) + source_old(fc,j,s))
+                     rt(c,j) = epsilon_t_old(c,j,s) / dtime_ch4 * conc_o2_rel(c,j) +           &
+                          0.5_r8 / dzj * ( - dm1_zm1(c,j) * (conc_o2_rel(c,j)  -conc_o2_rel(c,j-1))) + &
+                          0.5_r8 * (source(c,j,s) + source_old(c,j,s))
                   endif
-                  epsilon_t_old(fc,j,s) = epsilon_t(fc,j,s)
-                  source_old(fc,j,s) = source(fc,j,s)
+                  epsilon_t_old(c,j,s) = epsilon_t(c,j,s)
+                  source_old(c,j,s) = source(c,j,s)
 
                enddo ! fc; column
             enddo ! j; nlevsoi
 
-            call Tridiagonal_filter( 0, nlevsoi, jtop, &
+            call Tridiagonal(bounds, 0, nlevsoi, jtop(bounds%begc:bounds%endc), &
                  num_methc, filter_methc, &
-                 at, &
-                 bt, &
-                 ct, &
-                 rt, &
-                 conc_o2_rel)
+                 at(bounds%begc:bounds%endc, :), &
+                 bt(bounds%begc:bounds%endc, :), &
+                 ct(bounds%begc:bounds%endc, :), &
+                 rt(bounds%begc:bounds%endc, :), &
+                 conc_o2_rel(bounds%begc:bounds%endc,0:nlevsoi))
 
             ! Ensure that concentrations stay above 0
-            !$acc parallel loop independent gang vector default(present) collapse(2) 
             do j = 1,nlevsoi
                do fc = 1, num_methc
                   c = filter_methc (fc)
                   g = col_pp%gridcell(c)
-                  conc_o2_rel(fc,j) = max (conc_o2_rel(fc,j), 1.e-12_r8)
+                  conc_o2_rel(c,j) = max (conc_o2_rel(c,j), 1.e-12_r8)
                   ! In case of pathologically large aerenchyma conductance. Should be OK in general but
                   ! this will maintain stability even if a PFT with very small weight somehow has an absurd NPP or LAI.
                   ! Also, oxygen above ambient will probably bubble.
-                  conc_o2_rel(fc,j) = min (conc_o2_rel(fc,j), c_atm(g,2)/epsilon_t(fc,j,2))
+                  conc_o2_rel(c,j) = min (conc_o2_rel(c,j), c_atm(g,2)/epsilon_t(c,j,2))
                enddo
             enddo
 
          endif  ! species
 
       enddo  ! species
-      !$acc exit data delete(s) 
 
       ! Update absolute concentrations per unit volume
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = 1,nlevsoi ! No need to update the atm. level concentrations
          do fc = 1, num_methc
             c = filter_methc (fc)
-            conc_ch4(c,j) = conc_ch4_rel(fc,j)*epsilon_t(fc,j,1)
-            conc_o2(c,j)  = conc_o2_rel(fc,j) *epsilon_t(fc,j,2)
+            conc_ch4(c,j) = conc_ch4_rel(c,j)*epsilon_t(c,j,1)
+            conc_o2(c,j)  = conc_o2_rel(c,j) *epsilon_t(c,j,2)
          end do
       end do
 
       ! Do Balance Check and absorb small
       !    discrepancy into surface flux.
-      !$acc parallel loop independent gang worker default(present) private(sum1)
-      do fc = 1, num_methc
-         c = filter_methc (fc)
-         sum1 = 0._r8
-         !$acc loop vector reduction(+:sum1)
-         do j = 1,nlevsoi
-            sum1 = sum1 + (conc_ch4(c,j) - conc_ch4_bef(fc,j))*dz(c,j)
-            sum1 = sum1 - ch4_prod_depth(c,j)*dz(c,j)*dtime_mod
-            sum1 = sum1 + ch4_oxid_depth(c,j)*dz(c,j)*dtime_mod
+      do j = 1,nlevsoi
+         do fc = 1, num_methc
+            c = filter_methc (fc)
+
+            if (j == 1) errch4(c) = 0._r8
+            errch4(c) = errch4(c) + (conc_ch4(c,j) - conc_ch4_bef(c,j))*dz(c,j)
+            errch4(c) = errch4(c) - ch4_prod_depth(c,j)*dz(c,j)*dtime
+            errch4(c) = errch4(c) + ch4_oxid_depth(c,j)*dz(c,j)*dtime
          end do
-         errch4(fc) = sum1 
       end do
 
-      erridx = 0
-      !$acc parallel loop independent gang vector copy(erridx)
       do fc = 1, num_methc
          c = filter_methc (fc)
 
          ! For history make sure that grnd_ch4_cond includes snow, for methane diffusivity
-         grnd_ch4_cond(c) = spec_grnd_cond(fc,1)
-         errch4(fc) = errch4(fc) + (ch4_surf_aere(c) + ch4_surf_ebul(c) + ch4_surf_diff(c))*dtime
+         grnd_ch4_cond(c) = spec_grnd_cond(c,1)
+         errch4(c) = errch4(c) + (ch4_surf_aere(c) + ch4_surf_ebul(c) + ch4_surf_diff(c))*dtime
 
-         if (abs(errch4(fc)) < 1.e-8_r8) then
-            ch4_surf_diff(c) = ch4_surf_diff(c) - errch4(fc)/dtime
+         if (abs(errch4(c)) < 1.e-8_r8) then
+            ch4_surf_diff(c) = ch4_surf_diff(c) - errch4(c)/dtime
          else ! errch4 > 1e-8 mol / m^2 / timestep
-            erridx = c
+            write(iulog,*) 'CH4 Conservation Error in CH4Mod during diffusion, nstep, c, errch4 (mol /m^2.timestep)'
+            g = col_pp%gridcell(c)
+            write(iulog,*) 'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
          end if
       end do
 
-      if(erridx > 0 ) then 
-         g = col_pp%gridcell(erridx)
-         write(iulog,*) 'CH4 Conservation Error in CH4Mod during diffusion', nstep, erridx, '(mol /m^2.timestep)'
-         write(iulog,*) 'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
-      end if 
-
-    !$acc exit data delete(&
-    !$acc at(:,:), &
-    !$acc bt(:,:), &
-    !$acc ct(:,:), &
-    !$acc rt(:,:), &
-    !$acc diffus(:,:), &
-    !$acc k_h_cc(:,:,:), &
-    !$acc dp1_zp1(:,:), &
-    !$acc dm1_zm1(:,:), &
-    !$acc conc_ch4_bef(:,:), &
-    !$acc errch4(:), &
-    !$acc conc_ch4_rel(:,:), &
-    !$acc conc_o2_rel(:,:), &
-    !$acc conc_ch4_rel_old(:,:), &
-    !$acc h2osoi_vol_min(:,:), &
-    !$acc snowres, &
-    !$acc spec_grnd_cond(:,:), &
-    !$acc epsilon_t(:,:,:), &
-    !$acc epsilon_t_old(:,:,:), &
-    !$acc source(:,:,:), &
-    !$acc source_old(:,:,:), &
-    !$acc liqfrac(:,:), &
-    !$acc snowdiff, &
-    !$acc pondres)
-
     end associate
 
   end subroutine ch4_tran
@@ -3813,6 +3722,7 @@ contains
     ! Finds the first unsaturated layer going up. Also allows a perched water table over ice.
     !
     ! !ARGUMENTS:
+      !$acc routine seq
     type(bounds_type)      , intent(in)  :: bounds
     integer                , intent(in)  :: num_methc           ! number of column soil points in column filter
     integer                , intent(in)  :: filter_methc(:)     ! column filter for soil points
@@ -3837,7 +3747,6 @@ contains
       ! The layer index of the first unsaturated layer, i.e., the layer right above
       ! the water table.
       ! ZS: Loop is currently not vectorized.
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_methc
          c = filter_methc(fc)
 
@@ -3845,7 +3754,6 @@ contains
          ! such layer.  This is potentially important for perched water tables in the Tundra.
 
          perch = nlevsoi
-         !$acc loop seq
          do j = nlevsoi, 1, -1
             if (t_soisno(c,j) < tfrz .and. h2osoi_vol(c,j) > f_sat * watsat(c,j)) then
                ! strictly less than freezing because it could be permeable otherwise
@@ -3854,7 +3762,6 @@ contains
          end do
          jwt(c) = perch
 
-         !$acc loop seq
          do j = perch, 2, -1
             if(h2osoi_vol(c,j) > f_sat * watsat(c,j) .and. h2osoi_vol(c,j-1) < f_sat * watsat(c,j-1)) then
                jwt(c) = j-1
@@ -3878,6 +3785,7 @@ contains
     ! !DESCRIPTION: Annual mean fields.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon      , only: secspday
     !
     ! !ARGUMENTS:
@@ -3923,7 +3831,6 @@ contains
       newrun = .false.
 
       ! column loop
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1,num_methc
          c = filter_methc(fc)
 
@@ -3940,19 +3847,20 @@ contains
       end do
 
       ! patch loop
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_methp
          p = filter_methp(fp)
-
-         if (newrun .or. tempavg_agnpp(p) == spval) then ! Extra check needed because for back-compatibility
-            tempavg_agnpp(p) = 0._r8
-            tempavg_bgnpp(p) = 0._r8
+         c = veg_pp%column(p)
+         if(.not.col_pp%is_fates(c)) then
+            if (newrun .or. tempavg_agnpp(p) == spval) then ! Extra check needed because for back-compatibility
+               tempavg_agnpp(p) = 0._r8
+               tempavg_bgnpp(p) = 0._r8
+            end if
          end if
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1,num_methc
          c = filter_methc(fc)
+         
          if (annsum_counter(c) >= secsperyear) then
 
             ! update annual average somhr
@@ -3972,26 +3880,26 @@ contains
          end if
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_methp
          p = filter_methp(fp)
          c = veg_pp%column(p)
-         if (annsum_counter(c) >= secsperyear) then
-
-            annavg_agnpp(p) = tempavg_agnpp(p)
-            tempavg_agnpp(p) = 0._r8
-
-            annavg_bgnpp(p) = tempavg_bgnpp(p)
-            tempavg_bgnpp(p) = 0._r8
-
-         else
-            tempavg_agnpp(p) = tempavg_agnpp(p) + dt/secsperyear * agnpp(p)
-            tempavg_bgnpp(p) = tempavg_bgnpp(p) + dt/secsperyear * bgnpp(p)
+         if(.not.col_pp%is_fates(c)) then
+            if (annsum_counter(c) >= secsperyear) then
+               
+               annavg_agnpp(p) = tempavg_agnpp(p)
+               tempavg_agnpp(p) = 0._r8
+               
+               annavg_bgnpp(p) = tempavg_bgnpp(p)
+               tempavg_bgnpp(p) = 0._r8
+               
+            else
+               tempavg_agnpp(p) = tempavg_agnpp(p) + dt/secsperyear * agnpp(p)
+               tempavg_bgnpp(p) = tempavg_bgnpp(p) + dt/secsperyear * bgnpp(p)
+            end if
          end if
       end do
 
       ! column loop
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1,num_methc
          c = filter_methc(fc)
          if (annsum_counter(c) >= secsperyear) annsum_counter(c) = 0._r8
diff --git a/components/elm/src/biogeochem/CNCarbonFluxType.F90 b/components/elm/src/biogeochem/CNCarbonFluxType.F90
index d8e3e99484..828665f2a2 100644
--- a/components/elm/src/biogeochem/CNCarbonFluxType.F90
+++ b/components/elm/src/biogeochem/CNCarbonFluxType.F90
@@ -880,6 +880,7 @@ contains
     use elm_varpar , only : nlevdecomp, nlevdecomp_full, crop_prog, nlevgrnd
     use elm_varctl , only : hist_wrtch4diag
     use histFileMod, only : hist_addfld1d, hist_addfld2d, hist_addfld_decomp 
+    use tracer_varcon    , only : is_active_betr_bgc
     use elm_varctl,  only : get_carbontag
     !
     ! !ARGUMENTS:
@@ -1587,6 +1588,7 @@ contains
     use elm_varcon       , only : secspday
     use elm_varpar       , only : nlevdecomp, ndecomp_pools, ndecomp_cascade_transitions
     use subgridAveMod    , only : p2c
+    use tracer_varcon    , only : is_active_betr_bgc
     use MathfuncMod      , only : dot_sum
     use elm_varpar       , only : nlevdecomp_full
     !
@@ -1994,7 +1996,7 @@ contains
        this%som_c_leached_col(c)      = 0._r8
     end do
 
-    if ( (.not. .false.           ) .and. &
+    if ( (.not. is_active_betr_bgc           ) .and. &
          (.not. (use_pflotran .and. pf_cmode))) then
 
        ! vertically integrate HR and decomposition cascade fluxes
@@ -2012,7 +2014,7 @@ contains
        end do
 
 
-    elseif (.false.) then
+    elseif (is_active_betr_bgc) then
 
        do fc = 1, num_soilc
           c = filter_soilc(fc)
@@ -2206,7 +2208,7 @@ contains
        end do
     end do
 
-    if  (.not. .false.) then
+    if  (.not. is_active_betr_bgc) then
 
        ! _col(cWDC_HR) - coarse woody debris heterotrophic respiration
        do fc = 1,num_soilc
@@ -2555,6 +2557,7 @@ end subroutine CSummary_interface
 
   !summarize heterotrophic respiration for methane calculation
   !
+    use tracer_varcon    , only : is_active_betr_bgc
     use elm_varpar       , only : nlevdecomp, ndecomp_pools, ndecomp_cascade_transitions
   ! !ARGUMENTS:
     class(carbonflux_type) :: this
@@ -2628,7 +2631,7 @@ end subroutine CSummary_interface
        end if
     enddo
 
-    if ( (.not. .false.           ) .and. &
+    if ( (.not. is_active_betr_bgc           ) .and. &
          (.not. (use_pflotran .and. pf_cmode))) then
       ! vertically integrate HR and decomposition cascade fluxes
       do k = 1, ndecomp_cascade_transitions
diff --git a/components/elm/src/biogeochem/CNDecompCascadeConType.F90 b/components/elm/src/biogeochem/CNDecompCascadeConType.F90
index dab442af06..275922f6b9 100644
--- a/components/elm/src/biogeochem/CNDecompCascadeConType.F90
+++ b/components/elm/src/biogeochem/CNDecompCascadeConType.F90
@@ -18,7 +18,7 @@ module CNDecompCascadeConType
   public :: init_decomp_cascade_constants
   !
   type, public :: decomp_cascade_type
-     !-- properties of each pathway along decomposition cascade
+     !-- properties of each pathway along decomposition cascade 
      character(len=8)  , pointer :: cascade_step_name(:)               ! name of transition
      integer           , pointer :: cascade_donor_pool(:)              ! which pool is C taken from for a given decomposition step
      integer           , pointer :: cascade_receiver_pool(:)           ! which pool is C added to for a given decomposition step
@@ -44,8 +44,6 @@ module CNDecompCascadeConType
   end type decomp_cascade_type
 
   type(decomp_cascade_type), public :: decomp_cascade_con
-  !$acc declare create(decomp_cascade_con)
-
   !------------------------------------------------------------------------
 
 contains
@@ -57,7 +55,7 @@ contains
     ! Initialize decomposition cascade state
     !------------------------------------------------------------------------
 
-    !-- properties of each pathway along decomposition cascade
+    !-- properties of each pathway along decomposition cascade 
     allocate(decomp_cascade_con%cascade_step_name(1:ndecomp_cascade_transitions))
     allocate(decomp_cascade_con%cascade_donor_pool(1:ndecomp_cascade_transitions))
     allocate(decomp_cascade_con%cascade_receiver_pool(1:ndecomp_cascade_transitions))
@@ -81,7 +79,7 @@ contains
     allocate(decomp_cascade_con%spinup_factor(0:ndecomp_pools))
     allocate(decomp_cascade_con%decomp_k_pools(0:ndecomp_pools))
 
-    !-- properties of each pathway along decomposition cascade
+    !-- properties of each pathway along decomposition cascade 
     decomp_cascade_con%cascade_step_name(1:ndecomp_cascade_transitions) = ''
     decomp_cascade_con%cascade_donor_pool(1:ndecomp_cascade_transitions) = 0
     decomp_cascade_con%cascade_receiver_pool(1:ndecomp_cascade_transitions) = 0
diff --git a/components/elm/src/biogeochem/CNEcosystemDynBetrMod.F90 b/components/elm/src/biogeochem/CNEcosystemDynBetrMod.F90
index 6d25d72dda..e97cb54299 100644
--- a/components/elm/src/biogeochem/CNEcosystemDynBetrMod.F90
+++ b/components/elm/src/biogeochem/CNEcosystemDynBetrMod.F90
@@ -74,18 +74,19 @@ module CNEcosystemDynBetrMod
     ! setup fluxes and parameters for plant-microbe coupling in soibgc
     !
     ! !USES:
-    use NitrogenDynamicsMod          , only : NitrogenDeposition,NitrogenFixation, NitrogenFert, CNSoyfix
-    use MaintenanceRespMod           , only : MaintenanceResp
-    use SoilLittDecompMod            , only : SoilLittDecompAlloc
-    use CNPhenologyBeTRMod           , only : CNPhenology
+    use NitrogenDynamicsMod            , only : NitrogenDeposition,NitrogenFixation, NitrogenFert, CNSoyfix
+    use MaintenanceRespMod                , only : MaintenanceResp
+    use SoilLittDecompMod               , only : SoilLittDecompAlloc
+    use CNPhenologyBeTRMod            , only : CNPhenology
     use GrowthRespMod                , only : GrowthResp
-    use CNNStateUpdate1BeTRMod       , only : NStateUpdate1
-    use CNGapMortalityBeTRMod        , only : CNGapMortality
+    use CarbonStateUpdate1Mod        , only : CarbonStateUpdate1,CarbonStateUpdate0
+    use CNNStateUpdate1BeTRMod        , only : NStateUpdate1
+    use CNGapMortalityBeTRMod         , only : CNGapMortality
     use CarbonStateUpdate2Mod        , only : CarbonStateUpdate2, CarbonStateUpdate2h
-    use CNNStateUpdate2BeTRMod       , only : NStateUpdate2, NStateUpdate2h
+    use CNNStateUpdate2BeTRMod        , only : NStateUpdate2, NStateUpdate2h
     use FireMod                 , only : FireArea, FireFluxes
-    use CarbonStateUpdate3Mod   , only : CarbonStateUpdate3
-    use CarbonIsoFluxMod        , only : CarbonIsoFlux1, CarbonIsoFlux2, CarbonIsoFlux2h, CarbonIsoFlux3
+    use CarbonStateUpdate3Mod        , only : CarbonStateUpdate3
+    use CarbonIsoFluxMod             , only : CarbonIsoFlux1, CarbonIsoFlux2, CarbonIsoFlux2h, CarbonIsoFlux3
     use C14DecayMod             , only : C14Decay, C14BombSpike
     use WoodProductsMod         , only : WoodProducts
     use DecompCascadeBGCMod     , only : decomp_rate_constants_bgc
@@ -96,13 +97,14 @@ module CNEcosystemDynBetrMod
     use CropHarvestPoolsMod       , only : CropHarvestPools
     use PlantMicKineticsMod       , only : PlantMicKinetics_type
     use CNAllocationBetrMod       , only : SetPlantMicNPDemand, Allocation3_PlantCNPAlloc
-    use CNNStateUpdate3BeTRMod    , only : NStateUpdate3
-    use NitrogenDynamicsMod       , only : NitrogenFixation_balance
-    use PhosphorusStateUpdate2Mod , only : PhosphorusStateUpdate2, PhosphorusStateUpdate2h
-    use PhosphorusDynamicsMod     , only : PhosphorusBiochemMin_balance,PhosphorusDeposition,PhosphorusWeathering
-    use VerticalProfileMod        , only : decomp_vertprofiles
-    use RootDynamicsMod           , only : RootDynamics
-    use clm_time_manager , only : get_step_size
+    use CNNStateUpdate3BeTRMod        , only : NStateUpdate3
+    use NitrogenDynamicsMod            , only : NitrogenFixation_balance
+    use PhosphorusStateUpdate1Mod          , only : PhosphorusStateUpdate1
+    use PhosphorusStateUpdate2Mod          , only : PhosphorusStateUpdate2, PhosphorusStateUpdate2h
+    use PhosphorusDynamicsMod              , only : PhosphorusBiochemMin_balance,PhosphorusDeposition,PhosphorusWeathering
+    use VerticalProfileMod      , only : decomp_vertprofiles
+    use RootDynamicsMod              , only : RootDynamics
+    use clm_time_manager , only : get_step_size 
     implicit none
 
 
@@ -138,9 +140,9 @@ module CNEcosystemDynBetrMod
     type(PlantMicKinetics_type)      , intent(inout) :: PlantMicKinetics_vars
     type(phosphorusflux_type)        , intent(inout) :: phosphorusflux_vars
     type(phosphorusstate_type)       , intent(inout) :: phosphorusstate_vars
-
-    real(r8) :: dt
-    integer :: c13= 0, c14=1, fp, p
+    
+    real(r8) :: dt 
+    integer :: c13= 0, c14=1
     dt = real(get_step_size(),r8)
     if(.not. use_fates)then
        ! --------------------------------------------------
@@ -149,12 +151,107 @@ module CNEcosystemDynBetrMod
 
        call t_startf('CNZero')
 
+       call col_cf%SetValues(num_soilc, filter_soilc, 0._r8)
+       call veg_cf%SetValues(num_soilp, filter_soilp, 0._r8)
+
+       if ( use_c13 ) then
+          call c13_col_cf%SetValues(num_soilc, filter_soilc, 0._r8)
+          call c13_veg_cf%SetValues(num_soilp, filter_soilp, 0._r8)
+       end if
+
+       if ( use_c14 ) then
+          call c14_col_cf%SetValues(num_soilc, filter_soilc, 0._r8)
+          call c14_veg_cf%SetValues(num_soilp, filter_soilp, 0._r8)
+       end if
+       
+       call col_nf%SetValues (num_soilc, filter_soilc, 0._r8)
+       call veg_nf%SetValues (num_soilp, filter_soilp, 0._r8)
+
+       call col_pf%SetValues (num_soilc, filter_soilc, 0._r8)
+       call veg_pf%SetValues (num_soilp, filter_soilp, 0._r8)
 
        call t_stopf('CNZero')
 
+       ! --------------------------------------------------
+       ! Nitrogen Deposition, Fixation and Respiration, phosphorus dynamics
+       ! --------------------------------------------------
+
+       call t_startf('CNDeposition')
+       call NitrogenDeposition(bounds, &
+            atm2lnd_vars, dt )
+       call t_stopf('CNDeposition')
+
+       call t_startf('MaintenanceResp')
+       if (crop_prog) then
+          call NitrogenFert(bounds, num_soilc,filter_soilc )
+
+       end if
+       call MaintenanceResp(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            canopystate_vars, soilstate_vars, photosyns_vars )
+       call t_stopf('MaintenanceResp')
+
+       ! for P competition purpose, calculate P fluxes that will potentially increase solution P pool
+       ! then competitors take up solution P
+       call t_startf('PhosphorusWeathering')
+       call PhosphorusWeathering(num_soilc, filter_soilc, &
+               cnstate_vars, dt)
+       call t_stopf('PhosphorusWeathering')
+
+
+       ! --------------------------------------------------
+       ! Phosphorus Deposition ! X.SHI
+       ! --------------------------------------------------
+
+       call t_startf('PhosphorusDeposition')
+       call PhosphorusDeposition(bounds, &
+            atm2lnd_vars)
+       call t_stopf('PhosphorusDeposition')
+
        !This specifies the vertical distribution of deposition fluxes and
        !root exudates
-      
+       call decomp_vertprofiles(bounds,                      &
+           num_soilc, filter_soilc, num_soilp, filter_soilp, &
+           soilstate_vars, canopystate_vars, cnstate_vars)
+!!--------------------------------------------------------------
+
+       call t_startf('CNAllocation - phase-1')
+       call SetPlantMicNPDemand (bounds                                     , &
+                num_soilc, filter_soilc, num_soilp, filter_soilp            , &
+                photosyns_vars, crop_vars, canopystate_vars, cnstate_vars   , &
+                carbonstate_vars, carbonflux_vars, c13_carbonflux_vars      , &
+                c14_carbonflux_vars, nitrogenstate_vars, nitrogenflux_vars  , &
+                phosphorusstate_vars, phosphorusflux_vars, PlantMicKinetics_vars)
+
+       call t_stopf('CNAllocation - phase-1')
+
+       call t_startf('CNFixation')
+       !nfixation comes after SetPlantMicNPDemand because it needs cnp ratio
+       !computed first
+       call NitrogenFixation_balance( num_soilc, filter_soilc, &
+               cnstate_vars )
+       call t_stopf('CNFixation')
+
+       ! nu_com_phosphatase is true
+       call t_startf('PhosphorusBiochemMin')
+       call PhosphorusBiochemMin_balance(bounds,num_soilc, filter_soilc, &
+                  cnstate_vars, dt)
+       call t_stopf('PhosphorusBiochemMin')
+
+       if (crop_prog) then
+          !be careful about CNSoyfix, it is coded by using CTC-RD formulation
+          !of CN interactions
+          call CNSoyfix(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               crop_vars, cnstate_vars)
+      endif
+      call t_startf('CNAllocation - phase-3')
+      call Allocation3_PlantCNPAlloc (bounds                      , &
+                num_soilc, filter_soilc, num_soilp, filter_soilp    , &
+                canopystate_vars                                    , &
+                cnstate_vars, carbonstate_vars, carbonflux_vars     , &
+                c13_carbonflux_vars, c14_carbonflux_vars            , &
+                nitrogenstate_vars, nitrogenflux_vars               , &
+                phosphorusstate_vars, phosphorusflux_vars, crop_vars)
+      call t_stopf('CNAllocation - phase-3')
 
        !--------------------------------------------
        ! Phenology
@@ -178,6 +275,18 @@ module CNEcosystemDynBetrMod
        ! Growth respiration
        !--------------------------------------------
 
+       call t_startf('GrowthResp')
+       call GrowthResp(num_soilp, filter_soilp )
+       call t_stopf('CNGResp')
+       
+       call veg_cf%SummaryRR(bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, col_cf)
+       if(use_c13) then
+         call c13_veg_cf%SummaryRR(bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, c13_col_cf)
+       endif
+
+       if(use_c14) then
+         call c14_veg_cf%SummaryRR(bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, c14_col_cf)
+       endif
        !--------------------------------------------
        ! Dynamic Roots
        !--------------------------------------------
@@ -194,9 +303,16 @@ module CNEcosystemDynBetrMod
        !--------------------------------------------
        ! C State Update 0
        !--------------------------------------------
-
-       dt = real(get_step_size(), r8)
+       
+       dt = real(get_step_size(), r8) 
        call t_startf('CarbonStateUpdate0')
+       call CarbonStateUpdate0(num_soilp, filter_soilp, veg_cs, veg_cf,dt)
+       if ( use_c13 ) then
+          call CarbonStateUpdate0(num_soilp, filter_soilp, c13_veg_cs, c13_veg_cf,dt)
+       end if
+       if ( use_c14 ) then
+          call CarbonStateUpdate0(num_soilp, filter_soilp, c14_veg_cs, c14_veg_cf,dt)
+       end if
        call t_stopf('CarbonStateUpdate0')
 
        !--------------------------------------------
@@ -217,9 +333,24 @@ module CNEcosystemDynBetrMod
                isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
        end if
 
+       call CarbonStateUpdate1(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            crop_vars, col_cs, veg_cs, col_cf, veg_cf, dt)
+
+       if ( use_c13 ) then
+          call CarbonStateUpdate1(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               crop_vars, c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf,dt)
+       end if
+       if ( use_c14 ) then
+          call CarbonStateUpdate1(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               crop_vars, c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf,dt)
+       end if
+
        call NStateUpdate1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
             cnstate_vars,nitrogenflux_vars, nitrogenstate_vars)
 
+       call PhosphorusStateUpdate1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            cnstate_vars, dt)
+
        call t_stopf('CNUpdate1')
 
        call t_startf('CNGapMortality')
@@ -247,6 +378,23 @@ module CNEcosystemDynBetrMod
                isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
        end if
 
+       call CarbonStateUpdate2( num_soilc, filter_soilc, num_soilp, filter_soilp, &
+             col_cs, veg_cs, col_cf, veg_cf, dt )
+
+       if ( use_c13 ) then
+          call CarbonStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf, dt)
+       end if
+       if ( use_c14 ) then
+          call CarbonStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf, dt)
+       end if
+       call NStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            nitrogenflux_vars, nitrogenstate_vars)
+
+       call PhosphorusStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            dt)
+
        if (get_do_harvest()) then
           call CNHarvest(num_soilc, filter_soilc, num_soilp, filter_soilp, &
                cnstate_vars)
@@ -263,7 +411,28 @@ module CNEcosystemDynBetrMod
                isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
        end if
 
-       call FireArea( bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+       call CarbonStateUpdate2h( num_soilc, filter_soilc,  num_soilp, filter_soilp, &
+             col_cs, veg_cs, col_cf, veg_cf, dt)
+       if ( use_c13 ) then
+          call CarbonStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf, dt)
+       end if
+       if ( use_c14 ) then
+          call CarbonStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               c14_col_cs, c13_veg_cs, c14_col_cf, c14_veg_cf, dt)
+       end if
+
+       call NStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            nitrogenflux_vars, nitrogenstate_vars)
+
+       call PhosphorusStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            dt)
+
+       call WoodProducts(num_soilc, filter_soilc )
+
+       call CropHarvestPools(num_soilc, filter_soilc, dt)
+
+       call FireArea(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
             atm2lnd_vars, energyflux_vars, soilhydrology_vars, &
             cnstate_vars )
 
@@ -349,7 +518,47 @@ module CNEcosystemDynBetrMod
 
     call t_startf('CNsumBetr')
 
+    call PrecisionControl(num_soilc, filter_soilc, num_soilp, filter_soilp )
+            
+
+    call veg_cf%Summary(bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, 'bulk', col_cf)
+    call col_cf%Summary(bounds, num_soilc, filter_soilc, 'bulk')
+    if ( use_c13 ) then
+       call c13_veg_cf%Summary(bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, 'c13', c13_col_cf)
+       call c13_col_cf%Summary(bounds, num_soilc, filter_soilc, 'c13')
+
+    end if
+    if ( use_c14 ) then
+       call C14_veg_cf%Summary(bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, 'c14', c14_col_cf)
+       call c14_col_cf%Summary(bounds, num_soilc, filter_soilc, 'c14')
+    end if
+
+    call veg_cs%Summary(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_cs)
+    call col_cs%Summary(bounds, num_soilc, filter_soilc)
+    if ( use_c13 ) then
+       call c13_veg_cs%Summary(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, c13_col_cs)
+       call c13_col_cs%Summary(bounds, num_soilc, filter_soilc)
+    end if
+    if ( use_c14 ) then
+       call c14_veg_cs%Summary(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, c14_col_cs)
+       call c14_col_cs%Summary(bounds, num_soilc, filter_soilc)
+
+    end if
+
+    call update_plant_nutrient_buffer(bounds, col, pft, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+      nitrogenflux_vars, nitrogenstate_vars, phosphorusflux_vars, phosphorusstate_vars)
+
+    call veg_nf%Summary(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_nf)
+    call col_nf%Summary(bounds, num_soilc, filter_soilc)
+
+    call veg_ns%Summary(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_ns)
+    call col_ns%Summary(bounds, num_soilc, filter_soilc)
+
+    call veg_pf%Summary(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_pf)
+    call col_pf%Summary(bounds, num_soilc, filter_soilc)
 
+    call veg_ps%Summary(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_ps)
+    call col_ps%Summary(bounds, num_soilc, filter_soilc)
 
     call t_stopf('CNsumBetr')
 
diff --git a/components/elm/src/biogeochem/CarbonIsoFluxMod.F90 b/components/elm/src/biogeochem/CarbonIsoFluxMod.F90
index d4a801dd91..9def36df40 100644
--- a/components/elm/src/biogeochem/CarbonIsoFluxMod.F90
+++ b/components/elm/src/biogeochem/CarbonIsoFluxMod.F90
@@ -20,7 +20,6 @@ module CarbonIsoFluxMod
   use VegetationType         , only : veg_pp
   use VegetationDataType     , only : vegetation_carbon_state, vegetation_carbon_flux
   use VegetationDataType     , only : veg_cs, veg_cf
-  #define is_active_betr_bgc .false.
   !
   implicit none
   save
@@ -52,6 +51,7 @@ contains
     ! On the radiation time step, set the carbon isotopic flux
     ! variables (except for gap-phase mortality and fire fluxes)
       !$acc routine seq
+    use tracer_varcon, only : is_active_betr_bgc
     !
     ! !ARGUMENTS:
     integer                , intent(in)    :: num_soilc       ! number of soil columns filter
@@ -427,6 +427,7 @@ contains
     ! On the radiation time step, set the carbon isotopic fluxes for gap mortality
     !
       !$acc routine seq
+    use tracer_varcon, only : is_active_betr_bgc
     ! !ARGUMENTS:
     integer                , intent(in)    :: num_soilc       ! number of soil columns filter
     integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
@@ -710,6 +711,7 @@ contains
     ! !DESCRIPTION:
     ! On the radiation time step, set the carbon isotopic fluxes for fire mortality
       !$acc routine seq
+    use tracer_varcon, only : is_active_betr_bgc
     !
     ! !ARGUMENTS:
     integer                , intent(in)    :: num_soilc       ! number of soil columns filter
diff --git a/components/elm/src/biogeochem/CarbonStateUpdate1Mod.F90 b/components/elm/src/biogeochem/CarbonStateUpdate1Mod.F90
index 05442cae64..057fd0e56b 100644
--- a/components/elm/src/biogeochem/CarbonStateUpdate1Mod.F90
+++ b/components/elm/src/biogeochem/CarbonStateUpdate1Mod.F90
@@ -25,7 +25,7 @@ module CarbonStateUpdate1Mod
   use VegetationType          , only : veg_pp
   use VegetationDataType      , only : vegetation_carbon_state, vegetation_carbon_flux
   use VegetationPropertiesType, only : veg_vp
-  use timeInfoMod             , only : year_curr, mon_curr, day_curr, secs_curr 
+
   !
   implicit none
   save
@@ -33,185 +33,193 @@ module CarbonStateUpdate1Mod
   !
   ! !PUBLIC MEMBER FUNCTIONS:
   public :: CarbonStateUpdateDynPatch
+  public :: CarbonStateUpdate1
   public :: CarbonStateUpdate0
-  public :: CarbonStateUpdate_Phase1_COL
-  public :: CarbonStateUpdate_Phase1_PFT
-  public :: CarbonStateDynGridUpdate 
   !-----------------------------------------------------------------------
 
 contains
 
-!-------------------------------------------------------------------------
-subroutine CarbonStateDynGridUpdate(bounds, dt)
-   !
-   ! !DESCRIPTION: 
-   ! Update gridcell carbon states based on fluxes form dyn_cnbal_patch 
-   ! !ARGUMENTS 
-   type(bounds_type), intent(in) :: bounds  
-   real(r8), intent(in) :: dt 
-   ! 
-   integer :: begg, endg 
-   integer :: g
-      
-   begg = bounds%begg; endg = bounds%endg 
-
-   !$acc parallel loop independent gang vector default(present)  
-   do g =begg, endg  
-      grc_cs%seedc(g) = grc_cs%seedc(g) &
-         - grc_cf%dwt_seedc_to_leaf(g) * dt &
-         - grc_cf%dwt_seedc_to_deadstem(g) * dt
-
-      if (use_c13) then
-         c13_grc_cs%seedc(g) = c13_grc_cs%seedc(g) &
-            - c13_grc_cf%dwt_seedc_to_leaf(g)     * dt &
-            - c13_grc_cf%dwt_seedc_to_deadstem(g) * dt
-       end if
-
-       if (use_c14) then
-         c14_grc_cs%seedc(g) = c14_grc_cs%seedc(g) &
-            - c14_grc_cf%dwt_seedc_to_leaf(g)     * dt &
-            - c14_grc_cf%dwt_seedc_to_deadstem(g) * dt
-       end if
-    end do 
-end subroutine CarbonStateDynGridUpdate
-
-!-----------------------------------------------------------------------
-subroutine CarbonStateUpdateDynPatch(num_soilc_with_inactive, filter_soilc_with_inactive, dt)
- !
- ! !DESCRIPTION:
- ! Update carbon states based on fluxes from dyn_cnbal_patch
- ! !ARGUMENTS:
- integer          , intent(in) :: num_soilc_with_inactive       ! number of columns in soil filter
- integer          , intent(in) :: filter_soilc_with_inactive(:) ! soil column filter that includes inactive points
- real(r8)         , intent(in) :: dt  ! time step (seconds)
-
- !
- ! !LOCAL VARIABLES:
- integer  :: c   ! column index
- integer  :: fc  ! column filter index
- integer  :: j   ! level index
-
-   !$acc parallel loop independent gang vector default(present)
-   do fc = 1, num_soilc_with_inactive
-
-      c = filter_soilc_with_inactive(fc)
-      col_cs%prod10c(c) = col_cs%prod10c(c) + col_cf%dwt_prod10c_gain(c)*dt
-      col_cs%prod100c(c) = col_cs%prod100c(c) + col_cf%dwt_prod100c_gain(c)*dt
-      col_cs%prod1c(c) = col_cs%prod1c(c) + col_cf%dwt_crop_productc_gain(c)*dt
-
-      if (use_c13) then
-         c13_col_cs%prod10c(c) = c13_col_cs%prod10c(c) + c13_col_cf%dwt_prod10c_gain(c)*dt
-         c13_col_cs%prod100c(c) = c13_col_cs%prod100c(c) + c13_col_cf%dwt_prod100c_gain(c)*dt
-         c13_col_cs%prod1c(c) = c13_col_cs%prod1c(c) + c13_col_cf%dwt_crop_productc_gain(c)*dt
-      end if
-
-      if (use_c14) then
-         c14_col_cs%prod10c(c) = c14_col_cs%prod10c(c) + c14_col_cf%dwt_prod10c_gain(c)*dt
-         c14_col_cs%prod100c(c) = c14_col_cs%prod100c(c) + c14_col_cf%dwt_prod100c_gain(c)*dt
-         c14_col_cs%prod1c(c) = c14_col_cs%prod1c(c) + c14_col_cf%dwt_crop_productc_gain(c)*dt
-      end if
-   end do 
-
-!$acc parallel loop independent gang vector collapse(2) default(present) 
-do j = 1,nlevdecomp
-   do fc = 1, num_soilc_with_inactive
-      c = filter_soilc_with_inactive(fc)
-      col_cs%decomp_cpools_vr(c,j,i_met_lit) = col_cs%decomp_cpools_vr(c,j,i_met_lit) + &
-         col_cf%dwt_frootc_to_litr_met_c(c,j) * dt
-      col_cs%decomp_cpools_vr(c,j,i_cel_lit) = col_cs%decomp_cpools_vr(c,j,i_cel_lit) + &
-         col_cf%dwt_frootc_to_litr_cel_c(c,j) * dt
-      col_cs%decomp_cpools_vr(c,j,i_lig_lit) = col_cs%decomp_cpools_vr(c,j,i_lig_lit) + &
-         col_cf%dwt_frootc_to_litr_lig_c(c,j) * dt
-      col_cs%decomp_cpools_vr(c,j,i_cwd) = col_cs%decomp_cpools_vr(c,j,i_cwd) + &
-         ( col_cf%dwt_livecrootc_to_cwdc(c,j) + col_cf%dwt_deadcrootc_to_cwdc(c,j) ) * dt
-
-      if (use_c13) then
-         c13_col_cs%decomp_cpools_vr(c,j,i_met_lit) = c13_col_cs%decomp_cpools_vr(c,j,i_met_lit) + &
-            c13_col_cf%dwt_frootc_to_litr_met_c(c,j) * dt
-         c13_col_cs%decomp_cpools_vr(c,j,i_cel_lit) = c13_col_cs%decomp_cpools_vr(c,j,i_cel_lit) + &
-            c13_col_cf%dwt_frootc_to_litr_cel_c(c,j) * dt
-         c13_col_cs%decomp_cpools_vr(c,j,i_lig_lit) = c13_col_cs%decomp_cpools_vr(c,j,i_lig_lit) + &
-            c13_col_cf%dwt_frootc_to_litr_lig_c(c,j) * dt
-         c13_col_cs%decomp_cpools_vr(c,j,i_cwd) = c13_col_cs%decomp_cpools_vr(c,j,i_cwd) + &
-            ( c13_col_cf%dwt_livecrootc_to_cwdc(c,j) + c13_col_cf%dwt_deadcrootc_to_cwdc(c,j) ) * dt
-      end if
-
-      if (use_c14) then
-         c14_col_cs%decomp_cpools_vr(c,j,i_met_lit) = c14_col_cs%decomp_cpools_vr(c,j,i_met_lit) + &
-            c14_col_cf%dwt_frootc_to_litr_met_c(c,j) * dt
-         c14_col_cs%decomp_cpools_vr(c,j,i_cel_lit) = c14_col_cs%decomp_cpools_vr(c,j,i_cel_lit) + &
-            c14_col_cf%dwt_frootc_to_litr_cel_c(c,j) * dt
-         c14_col_cs%decomp_cpools_vr(c,j,i_lig_lit) = c14_col_cs%decomp_cpools_vr(c,j,i_lig_lit) + &
-            c14_col_cf%dwt_frootc_to_litr_lig_c(c,j) * dt
-         c14_col_cs%decomp_cpools_vr(c,j,i_cwd) = c14_col_cs%decomp_cpools_vr(c,j,i_cwd) + &
-            ( c14_col_cf%dwt_livecrootc_to_cwdc(c,j) + c14_col_cf%dwt_deadcrootc_to_cwdc(c,j) ) * dt
-      end if
-   end do
-end do
-
-end subroutine CarbonStateUpdateDynPatch
+  !-----------------------------------------------------------------------
+  subroutine CarbonStateUpdateDynPatch(bounds, num_soilc_with_inactive, filter_soilc_with_inactive, dt)
+    !
+    ! !DESCRIPTION:
+    ! Update carbon states based on fluxes from dyn_cnbal_patch
+    !$acc routine seq
+    ! !ARGUMENTS:
+    type(bounds_type)      , intent(in)    :: bounds
+    integer                , intent(in)    :: num_soilc_with_inactive       ! number of columns in soil filter
+    integer                , intent(in)    :: filter_soilc_with_inactive(:) ! soil column filter that includes inactive points
+    real(r8), intent(in) :: dt  ! time step (seconds)
+
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: c   ! column index
+    integer  :: fc  ! column filter index
+    integer  :: g   ! gridcell index
+    integer  :: j   ! level index
+
+    if (.not.use_fates) then
+
+       do g = bounds%begg, bounds%endg
+          grc_cs%seedc(g) = grc_cs%seedc(g) &
+               - grc_cf%dwt_seedc_to_leaf(g)     * dt &
+               - grc_cf%dwt_seedc_to_deadstem(g) * dt
+
+          if (use_c13) then
+            c13_grc_cs%seedc(g) = c13_grc_cs%seedc(g) &
+               - c13_grc_cf%dwt_seedc_to_leaf(g)     * dt &
+               - c13_grc_cf%dwt_seedc_to_deadstem(g) * dt
+          end if
+
+          if (use_c14) then
+            c14_grc_cs%seedc(g) = c14_grc_cs%seedc(g) &
+               - c14_grc_cf%dwt_seedc_to_leaf(g)     * dt &
+               - c14_grc_cf%dwt_seedc_to_deadstem(g) * dt
+          end if
+       end do
+
+       do fc = 1, num_soilc_with_inactive
+
+          c = filter_soilc_with_inactive(fc)
+          col_cs%prod10c(c) = col_cs%prod10c(c) + col_cf%dwt_prod10c_gain(c)*dt
+          col_cs%prod100c(c) = col_cs%prod100c(c) + col_cf%dwt_prod100c_gain(c)*dt
+          col_cs%prod1c(c) = col_cs%prod1c(c) + col_cf%dwt_crop_productc_gain(c)*dt
+
+          if (use_c13) then
+             c13_col_cs%prod10c(c) = c13_col_cs%prod10c(c) + c13_col_cf%dwt_prod10c_gain(c)*dt
+             c13_col_cs%prod100c(c) = c13_col_cs%prod100c(c) + c13_col_cf%dwt_prod100c_gain(c)*dt
+             c13_col_cs%prod1c(c) = c13_col_cs%prod1c(c) + c13_col_cf%dwt_crop_productc_gain(c)*dt
+          end if
+
+          if (use_c14) then
+             c14_col_cs%prod10c(c) = c14_col_cs%prod10c(c) + c14_col_cf%dwt_prod10c_gain(c)*dt
+             c14_col_cs%prod100c(c) = c14_col_cs%prod100c(c) + c14_col_cf%dwt_prod100c_gain(c)*dt
+             c14_col_cs%prod1c(c) = c14_col_cs%prod1c(c) + c14_col_cf%dwt_crop_productc_gain(c)*dt
+          end if
+
+          do j = 1,nlevdecomp
+
+             col_cs%decomp_cpools_vr(c,j,i_met_lit) = col_cs%decomp_cpools_vr(c,j,i_met_lit) + &
+                  col_cf%dwt_frootc_to_litr_met_c(c,j) * dt
+             col_cs%decomp_cpools_vr(c,j,i_cel_lit) = col_cs%decomp_cpools_vr(c,j,i_cel_lit) + &
+                  col_cf%dwt_frootc_to_litr_cel_c(c,j) * dt
+             col_cs%decomp_cpools_vr(c,j,i_lig_lit) = col_cs%decomp_cpools_vr(c,j,i_lig_lit) + &
+                  col_cf%dwt_frootc_to_litr_lig_c(c,j) * dt
+             col_cs%decomp_cpools_vr(c,j,i_cwd) = col_cs%decomp_cpools_vr(c,j,i_cwd) + &
+                  ( col_cf%dwt_livecrootc_to_cwdc(c,j) + col_cf%dwt_deadcrootc_to_cwdc(c,j) ) * dt
+
+             if (use_c13) then
+                c13_col_cs%decomp_cpools_vr(c,j,i_met_lit) = c13_col_cs%decomp_cpools_vr(c,j,i_met_lit) + &
+                     c13_col_cf%dwt_frootc_to_litr_met_c(c,j) * dt
+                c13_col_cs%decomp_cpools_vr(c,j,i_cel_lit) = c13_col_cs%decomp_cpools_vr(c,j,i_cel_lit) + &
+                     c13_col_cf%dwt_frootc_to_litr_cel_c(c,j) * dt
+                c13_col_cs%decomp_cpools_vr(c,j,i_lig_lit) = c13_col_cs%decomp_cpools_vr(c,j,i_lig_lit) + &
+                     c13_col_cf%dwt_frootc_to_litr_lig_c(c,j) * dt
+                c13_col_cs%decomp_cpools_vr(c,j,i_cwd) = c13_col_cs%decomp_cpools_vr(c,j,i_cwd) + &
+                     ( c13_col_cf%dwt_livecrootc_to_cwdc(c,j) + c13_col_cf%dwt_deadcrootc_to_cwdc(c,j) ) * dt
+             end if
+
+             if (use_c14) then
+                c14_col_cs%decomp_cpools_vr(c,j,i_met_lit) = c14_col_cs%decomp_cpools_vr(c,j,i_met_lit) + &
+                     c14_col_cf%dwt_frootc_to_litr_met_c(c,j) * dt
+                c14_col_cs%decomp_cpools_vr(c,j,i_cel_lit) = c14_col_cs%decomp_cpools_vr(c,j,i_cel_lit) + &
+                     c14_col_cf%dwt_frootc_to_litr_cel_c(c,j) * dt
+                c14_col_cs%decomp_cpools_vr(c,j,i_lig_lit) = c14_col_cs%decomp_cpools_vr(c,j,i_lig_lit) + &
+                     c14_col_cf%dwt_frootc_to_litr_lig_c(c,j) * dt
+                c14_col_cs%decomp_cpools_vr(c,j,i_cwd) = c14_col_cs%decomp_cpools_vr(c,j,i_cwd) + &
+                     ( c14_col_cf%dwt_livecrootc_to_cwdc(c,j) + c14_col_cf%dwt_deadcrootc_to_cwdc(c,j) ) * dt
+             end if
+
+          end do
+       end do
+    end if
+
+  end subroutine CarbonStateUpdateDynPatch
 
   !-----------------------------------------------------------------------
-  subroutine CarbonStateUpdate0(num_soilp, filter_soilp,veg_cs, veg_cf, dt)
+  subroutine CarbonStateUpdate0(num_soilp, filter_soilp, veg_cs, veg_cf, dt)
     !
     ! !DESCRIPTION:
     ! On the radiation time step, update cpool carbon state
     !
 
     ! !ARGUMENTS:
-    integer, intent(in) :: num_soilp 
-    integer , intent(in) :: filter_soilp(:) 
+      !$acc routine seq
+    integer                , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                , intent(in)    :: filter_soilp(:) ! filter for soil patches
     type(vegetation_carbon_state),intent(inout) :: veg_cs
     type(vegetation_carbon_flux) ,intent(inout) :: veg_cf
     real(r8),     intent(in)    :: dt
     !
-    integer :: p, fp 
+    ! !LOCAL VARIABLES:
+    integer :: p  ! indices
+    integer :: fp ! lake filter indices
     !-----------------------------------------------------------------------
 
     ! patch loop
-    !$acc parallel loop independent gang vector default(present) 
-    do fp =1 ,num_soilp 
-      p = filter_soilp(fp)
-      ! gross photosynthesis fluxes
-      veg_cs%cpool(p) = veg_cs%cpool(p) + veg_cf%psnsun_to_cpool(p)*dt
-      veg_cs%cpool(p) = veg_cs%cpool(p) + veg_cf%psnshade_to_cpool(p)*dt
+    do fp = 1,num_soilp
+       p = filter_soilp(fp)
+       ! gross photosynthesis fluxes
+       veg_cs%cpool(p) = veg_cs%cpool(p) + veg_cf%psnsun_to_cpool(p)*dt
+       veg_cs%cpool(p) = veg_cs%cpool(p) + veg_cf%psnshade_to_cpool(p)*dt
     end do
+
   end subroutine CarbonStateUpdate0
 
   !-----------------------------------------------------------------------
-  subroutine CarbonStateUpdate_Phase1_col(num_soilc, filter_soilc, col_cs, col_cf, dt)
+  subroutine CarbonStateUpdate1(bounds, &
+       num_soilc, filter_soilc, &
+       num_soilp, filter_soilp, &
+       crop_vars, col_cs, veg_cs, col_cf, veg_cf, dt)
     !
     ! !DESCRIPTION:
     ! On the radiation time step, update all the prognostic carbon state
     ! variables (except for gap-phase mortality and fire fluxes)
     !
+      !$acc routine seq
     use tracer_varcon       , only : is_active_betr_bgc
-    implicit none 
+    use decompMod           , only : bounds_type
     ! !ARGUMENTS:
+    type(bounds_type)            , intent(in)    :: bounds
     integer                      , intent(in)    :: num_soilc       ! number of soil columns filter
     integer                      , intent(in)    :: filter_soilc(:) ! filter for soil columns
+    integer                      , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                      , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    type(crop_type)              , intent(inout) :: crop_vars
     type(column_carbon_state)    , intent(inout) :: col_cs
+    type(vegetation_carbon_state), intent(inout) :: veg_cs
     type(column_carbon_flux)     , intent(inout) :: col_cf
+    type(vegetation_carbon_flux) , intent(inout) :: veg_cf
     real(r8), intent(in) :: dt        ! radiation time step (seconds)
 
     !
     ! !LOCAL VARIABLES:
-    integer  :: c,j,k,l ! indices
-    integer  :: fc     ! lake filter indices
+    integer  :: c,p,j,k,l ! indices
+    integer  :: fp,fc     ! lake filter indices
     !-----------------------------------------------------------------------
 
-    associate(  &
+    associate(                                                                                 &
+         ivt                   =>    veg_pp%itype                               , & ! Input:  [integer  (:)     ]  pft vegetation type
+         woody                 =>    veg_vp%woody                               , & ! Input:  [real(r8) (:)     ]  binary flag for woody lifeform (1=woody, 0=not woody)
          cascade_donor_pool    =>    decomp_cascade_con%cascade_donor_pool      , & ! Input:  [integer  (:)     ]  which pool is C taken from for a given decomposition step
-         cascade_receiver_pool =>    decomp_cascade_con%cascade_receiver_pool    & ! Input:  [integer  (:)     ]  which pool is C added to for a given decomposition step
+         cascade_receiver_pool =>    decomp_cascade_con%cascade_receiver_pool   , & ! Input:  [integer  (:)     ]  which pool is C added to for a given decomposition step
+         harvdate              =>    crop_vars%harvdate_patch                     & ! Input:  [integer  (:)     ]  harvest date
          )
 
+      ! set time steps
+
+
       ! column level fluxes
 
+      do fc = 1,num_soilc
+          c = filter_soilc(fc)
+          col_cs%decomp_som2c_vr(c,1:nlevdecomp) = col_cs%decomp_cpools_vr(c,1:nlevdecomp,6)
+      end do
+
       if (.not. is_active_betr_bgc .and. .not.(use_pflotran .and. pf_cmode) ) then
 
          ! plant to litter fluxes
          if(.not.use_fates)then
-            !$acc parallel loop independent gang vector collapse(2) default(present)
             do j = 1,nlevdecomp
                ! column loop
                do fc = 1,num_soilc
@@ -223,77 +231,41 @@ end subroutine CarbonStateUpdateDynPatch
                        col_cf%phenology_c_to_litr_cel_c(c,j) * dt
                   col_cf%decomp_cpools_sourcesink(c,j,i_lig_lit) = &
                        col_cf%phenology_c_to_litr_lig_c(c,j) * dt
-
-                  col_cs%decomp_som2c_vr(c,j) = col_cs%decomp_cpools_vr(c,j,6)
-
                end do
             end do
          end if
 
          ! litter and SOM HR fluxes
-         !$acc parallel loop independent gang worker collapse(2) default(present)
-         do j = 1,nlevdecomp
-            do fc = 1,num_soilc
+         do k = 1, ndecomp_cascade_transitions
+            do j = 1,nlevdecomp
                ! column loop
-               c = filter_soilc(fc)
-               !$acc loop vector independent
-               do k = 1, ndecomp_cascade_transitions
-                  !$acc atomic update 
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
                   col_cf%decomp_cpools_sourcesink(c,j,cascade_donor_pool(k)) = &
                        col_cf%decomp_cpools_sourcesink(c,j,cascade_donor_pool(k)) &
                        - ( col_cf%decomp_cascade_hr_vr(c,j,k) + col_cf%decomp_cascade_ctransfer_vr(c,j,k)) *dt
-                  !$acc end atomic 
                end do
             end do
          end do
-
-         !$acc parallel loop independent gang worker collapse(2) default(present)
-         do j = 1,nlevdecomp
-            do fc = 1,num_soilc
-               ! column loop
-               !$acc loop vector independent
-               do k = 1, ndecomp_cascade_transitions
-                  if ( cascade_receiver_pool(k) /= 0 ) then  ! skip terminal transitions
+         do k = 1, ndecomp_cascade_transitions
+            if ( cascade_receiver_pool(k) /= 0 ) then  ! skip terminal transitions
+               do j = 1,nlevdecomp
+                  ! column loop
+                  do fc = 1,num_soilc
                      c = filter_soilc(fc)
-                     !$acc atomic update 
                      col_cf%decomp_cpools_sourcesink(c,j,cascade_receiver_pool(k)) = &
                           col_cf%decomp_cpools_sourcesink(c,j,cascade_receiver_pool(k)) &
                           + col_cf%decomp_cascade_ctransfer_vr(c,j,k)*dt
-                     !$acc end atomic 
-                    end if
+                  end do
                end do
-            end do
+            end if
          end do
 
       endif   !end if is_active_betr_bgc()
 
-  end associate
+      if (.not.use_fates) then
 
-  end subroutine CarbonStateUpdate_Phase1_COL
-
-  subroutine CarbonStateUpdate_Phase1_PFT(num_soilp,filter_soilp,crop_vars, veg_cs, veg_cf,dt)
-     implicit none
-
-     integer                      , intent(in)    :: num_soilp       ! number of soil patches in filter
-     integer                      , intent(in)    :: filter_soilp(:) ! filter for soil patches
-     real(r8), intent(in) :: dt
-     type(crop_type)              , intent(inout) :: crop_vars
-     type(vegetation_carbon_state), intent(inout) :: veg_cs
-     type(vegetation_carbon_flux) , intent(inout) :: veg_cf
-
-     !
-     ! !LOCAL VARIABLES:
-     integer  :: l ! indices
-     integer  :: fp,p      ! lake filter indices
-     associate(  &
-          ivt                   =>    veg_pp%itype                               , & ! Input:  [integer  (:)     ]  pft vegetation type
-          woody                 =>    veg_vp%woody                               , & ! Input:  [real(r8) (:)     ]  binary flag for woody lifeform (1=woody, 0=not woody)
-          harvdate              =>    crop_vars%harvdate_patch                     & ! Input:  [integer  (:)     ]  harvest date
-          )
-      !
-      !if (.not.use_fates) then
       ! patch loop
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_soilp
          p = filter_soilp(fp)
 
@@ -302,7 +274,7 @@ end subroutine CarbonStateUpdateDynPatch
          veg_cs%leafc_xfer(p)      = veg_cs%leafc_xfer(p)  - veg_cf%leafc_xfer_to_leafc(p)*dt
          veg_cs%frootc(p)          = veg_cs%frootc(p)      + veg_cf%frootc_xfer_to_frootc(p)*dt
          veg_cs%frootc_xfer(p)     = veg_cs%frootc_xfer(p) - veg_cf%frootc_xfer_to_frootc(p)*dt
-         if (woody(ivt(p)) == 1._r8) then
+             if (woody(ivt(p)) == 1._r8) then
                 veg_cs%livestemc(p)       = veg_cs%livestemc(p)       + veg_cf%livestemc_xfer_to_livestemc(p)*dt
                 veg_cs%livestemc_xfer(p)  = veg_cs%livestemc_xfer(p)  - veg_cf%livestemc_xfer_to_livestemc(p)*dt
                 veg_cs%deadstemc(p)       = veg_cs%deadstemc(p)       + veg_cf%deadstemc_xfer_to_deadstemc(p)*dt
@@ -485,8 +457,10 @@ end subroutine CarbonStateUpdateDynPatch
 
       end do ! end of patch loop
 
-       end associate
+   end if
+
+  end associate
 
-  end subroutine CarbonStateUpdate_Phase1_PFT
+  end subroutine CarbonStateUpdate1
 
 end module CarbonStateUpdate1Mod
diff --git a/components/elm/src/biogeochem/CarbonStateUpdate2Mod.F90 b/components/elm/src/biogeochem/CarbonStateUpdate2Mod.F90
index 77add9f879..48174fb8dd 100644
--- a/components/elm/src/biogeochem/CarbonStateUpdate2Mod.F90
+++ b/components/elm/src/biogeochem/CarbonStateUpdate2Mod.F90
@@ -17,7 +17,6 @@ module CarbonStateUpdate2Mod
   use ColumnDataType         , only : column_carbon_state, column_carbon_flux
   use VegetationDataType     , only : vegetation_carbon_state, vegetation_carbon_flux
   !
-  use timeInfoMod , only : dtime_mod
   implicit none
   save
   private
@@ -31,12 +30,13 @@ contains
 
   !-----------------------------------------------------------------------
   subroutine CarbonStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-       col_cs, veg_cs, col_cf, veg_cf)
+       col_cs, veg_cs, col_cf, veg_cf, dt)
     !
     ! !DESCRIPTION:
     ! On the radiation time step, update all the prognostic carbon state
     ! variables affected by gap-phase mortality fluxes
     !
+      !$acc routine seq
     use tracer_varcon, only : is_active_betr_bgc
     ! !ARGUMENTS:
     integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
@@ -47,31 +47,33 @@ contains
     type(vegetation_carbon_state),intent(inout) :: veg_cs
     type(column_carbon_flux)     ,intent(inout) :: col_cf
     type(vegetation_carbon_flux) ,intent(inout) :: veg_cf
+    real(r8), intent(in) :: dt     ! radiation time step (seconds)
+
     !
     ! !LOCAL VARIABLES:
     integer  :: c ,p,j ! indices
     integer  :: fp,fc  ! lake filter indices
     !-----------------------------------------------------------------------
 
+
+
      if (  .not. is_active_betr_bgc          .and. &
           (.not.(use_pflotran .and. pf_cmode))) then
          ! column level carbon fluxes from gap-phase mortality
-         !$acc parallel loop independent gang default(present)
          do j = 1,nlevdecomp
             ! column loop
-            !$acc loop vector independent private(c)
             do fc = 1,num_soilc
                c = filter_soilc(fc)
 
                ! column gap mortality fluxes
                col_cs%decomp_cpools_vr(c,j,i_met_lit) = &
-                    col_cs%decomp_cpools_vr(c,j,i_met_lit) + col_cf%gap_mortality_c_to_litr_met_c(c,j) * dtime_mod
+                    col_cs%decomp_cpools_vr(c,j,i_met_lit) + col_cf%gap_mortality_c_to_litr_met_c(c,j) * dt
                col_cs%decomp_cpools_vr(c,j,i_cel_lit) = &
-                    col_cs%decomp_cpools_vr(c,j,i_cel_lit) + col_cf%gap_mortality_c_to_litr_cel_c(c,j) * dtime_mod
+                    col_cs%decomp_cpools_vr(c,j,i_cel_lit) + col_cf%gap_mortality_c_to_litr_cel_c(c,j) * dt
                col_cs%decomp_cpools_vr(c,j,i_lig_lit) = &
-                    col_cs%decomp_cpools_vr(c,j,i_lig_lit) + col_cf%gap_mortality_c_to_litr_lig_c(c,j) * dtime_mod
+                    col_cs%decomp_cpools_vr(c,j,i_lig_lit) + col_cf%gap_mortality_c_to_litr_lig_c(c,j) * dt
                col_cs%decomp_cpools_vr(c,j,i_cwd) = &
-                    col_cs%decomp_cpools_vr(c,j,i_cwd) + col_cf%gap_mortality_c_to_cwdc(c,j) * dtime_mod
+                    col_cs%decomp_cpools_vr(c,j,i_cwd) + col_cf%gap_mortality_c_to_cwdc(c,j) * dt
 
             end do
          end do
@@ -79,48 +81,48 @@ contains
 
 
       ! patch loop
-      !$acc parallel loop independent gang vector default(present) private(p)
       do fp = 1,num_soilp
          p = filter_soilp(fp)
 
          ! patch-level carbon fluxes from gap-phase mortality
          ! displayed pools
-         veg_cs%leafc(p)               = veg_cs%leafc(p)              - veg_cf%m_leafc_to_litter(p)              * dtime_mod
-         veg_cs%frootc(p)              = veg_cs%frootc(p)             - veg_cf%m_frootc_to_litter(p)             * dtime_mod
-         veg_cs%livestemc(p)           = veg_cs%livestemc(p)          - veg_cf%m_livestemc_to_litter(p)          * dtime_mod
-         veg_cs%deadstemc(p)           = veg_cs%deadstemc(p)          - veg_cf%m_deadstemc_to_litter(p)          * dtime_mod
-         veg_cs%livecrootc(p)          = veg_cs%livecrootc(p)         - veg_cf%m_livecrootc_to_litter(p)         * dtime_mod
-         veg_cs%deadcrootc(p)          = veg_cs%deadcrootc(p)         - veg_cf%m_deadcrootc_to_litter(p)         * dtime_mod
+         veg_cs%leafc(p)               = veg_cs%leafc(p)              - veg_cf%m_leafc_to_litter(p)              * dt
+         veg_cs%frootc(p)              = veg_cs%frootc(p)             - veg_cf%m_frootc_to_litter(p)             * dt
+         veg_cs%livestemc(p)           = veg_cs%livestemc(p)          - veg_cf%m_livestemc_to_litter(p)          * dt
+         veg_cs%deadstemc(p)           = veg_cs%deadstemc(p)          - veg_cf%m_deadstemc_to_litter(p)          * dt
+         veg_cs%livecrootc(p)          = veg_cs%livecrootc(p)         - veg_cf%m_livecrootc_to_litter(p)         * dt
+         veg_cs%deadcrootc(p)          = veg_cs%deadcrootc(p)         - veg_cf%m_deadcrootc_to_litter(p)         * dt
          ! storage pools
-         veg_cs%leafc_storage(p)       = veg_cs%leafc_storage(p)      - veg_cf%m_leafc_storage_to_litter(p)      * dtime_mod
-         veg_cs%frootc_storage(p)      = veg_cs%frootc_storage(p)     - veg_cf%m_frootc_storage_to_litter(p)     * dtime_mod
-         veg_cs%livestemc_storage(p)   = veg_cs%livestemc_storage(p)  - veg_cf%m_livestemc_storage_to_litter(p)  * dtime_mod
-         veg_cs%deadstemc_storage(p)   = veg_cs%deadstemc_storage(p)  - veg_cf%m_deadstemc_storage_to_litter(p)  * dtime_mod
-         veg_cs%livecrootc_storage(p)  = veg_cs%livecrootc_storage(p) - veg_cf%m_livecrootc_storage_to_litter(p) * dtime_mod
-         veg_cs%deadcrootc_storage(p)  = veg_cs%deadcrootc_storage(p) - veg_cf%m_deadcrootc_storage_to_litter(p) * dtime_mod
-         veg_cs%gresp_storage(p)       = veg_cs%gresp_storage(p)      - veg_cf%m_gresp_storage_to_litter(p)      * dtime_mod
-         veg_cs%cpool(p)               = veg_cs%cpool(p)              - veg_cf%m_cpool_to_litter(p)              * dtime_mod
+         veg_cs%leafc_storage(p)       = veg_cs%leafc_storage(p)      - veg_cf%m_leafc_storage_to_litter(p)      * dt
+         veg_cs%frootc_storage(p)      = veg_cs%frootc_storage(p)     - veg_cf%m_frootc_storage_to_litter(p)     * dt
+         veg_cs%livestemc_storage(p)   = veg_cs%livestemc_storage(p)  - veg_cf%m_livestemc_storage_to_litter(p)  * dt
+         veg_cs%deadstemc_storage(p)   = veg_cs%deadstemc_storage(p)  - veg_cf%m_deadstemc_storage_to_litter(p)  * dt
+         veg_cs%livecrootc_storage(p)  = veg_cs%livecrootc_storage(p) - veg_cf%m_livecrootc_storage_to_litter(p) * dt
+         veg_cs%deadcrootc_storage(p)  = veg_cs%deadcrootc_storage(p) - veg_cf%m_deadcrootc_storage_to_litter(p) * dt
+         veg_cs%gresp_storage(p)       = veg_cs%gresp_storage(p)      - veg_cf%m_gresp_storage_to_litter(p)      * dt
+         veg_cs%cpool(p)               = veg_cs%cpool(p)              - veg_cf%m_cpool_to_litter(p)              * dt
 
          ! transfer pools
-         veg_cs%leafc_xfer(p)          = veg_cs%leafc_xfer(p)         - veg_cf%m_leafc_xfer_to_litter(p)         * dtime_mod
-         veg_cs%frootc_xfer(p)         = veg_cs%frootc_xfer(p)        - veg_cf%m_frootc_xfer_to_litter(p)        * dtime_mod
-         veg_cs%livestemc_xfer(p)      = veg_cs%livestemc_xfer(p)     - veg_cf%m_livestemc_xfer_to_litter(p)     * dtime_mod
-         veg_cs%deadstemc_xfer(p)      = veg_cs%deadstemc_xfer(p)     - veg_cf%m_deadstemc_xfer_to_litter(p)     * dtime_mod
-         veg_cs%livecrootc_xfer(p)     = veg_cs%livecrootc_xfer(p)    - veg_cf%m_livecrootc_xfer_to_litter(p)    * dtime_mod
-         veg_cs%deadcrootc_xfer(p)     = veg_cs%deadcrootc_xfer(p)    - veg_cf%m_deadcrootc_xfer_to_litter(p)    * dtime_mod
-         veg_cs%gresp_xfer(p)          = veg_cs%gresp_xfer(p)         - veg_cf%m_gresp_xfer_to_litter(p)         * dtime_mod
+         veg_cs%leafc_xfer(p)          = veg_cs%leafc_xfer(p)         - veg_cf%m_leafc_xfer_to_litter(p)         * dt
+         veg_cs%frootc_xfer(p)         = veg_cs%frootc_xfer(p)        - veg_cf%m_frootc_xfer_to_litter(p)        * dt
+         veg_cs%livestemc_xfer(p)      = veg_cs%livestemc_xfer(p)     - veg_cf%m_livestemc_xfer_to_litter(p)     * dt
+         veg_cs%deadstemc_xfer(p)      = veg_cs%deadstemc_xfer(p)     - veg_cf%m_deadstemc_xfer_to_litter(p)     * dt
+         veg_cs%livecrootc_xfer(p)     = veg_cs%livecrootc_xfer(p)    - veg_cf%m_livecrootc_xfer_to_litter(p)    * dt
+         veg_cs%deadcrootc_xfer(p)     = veg_cs%deadcrootc_xfer(p)    - veg_cf%m_deadcrootc_xfer_to_litter(p)    * dt
+         veg_cs%gresp_xfer(p)          = veg_cs%gresp_xfer(p)         - veg_cf%m_gresp_xfer_to_litter(p)         * dt
       end do ! end of patch loop
 
   end subroutine CarbonStateUpdate2
 
   !-----------------------------------------------------------------------
   subroutine CarbonStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-       col_cs, veg_cs, col_cf, veg_cf)
+       col_cs, veg_cs, col_cf, veg_cf, dt)
     !
     ! !DESCRIPTION:
     ! Update all the prognostic carbon state
     ! variables affected by harvest mortality fluxes
     !
+      !$acc routine seq
     use tracer_varcon,  only : is_active_betr_bgc
     ! !ARGUMENTS:
     integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
@@ -131,6 +133,7 @@ contains
     type(vegetation_carbon_state),intent(inout) :: veg_cs
     type(column_carbon_flux)     ,intent(inout) :: col_cf
     type(vegetation_carbon_flux) ,intent(inout) :: veg_cf
+    real(r8),    intent(in)    :: dt        ! radiation time step (seconds)
 
     !
     ! !LOCAL VARIABLES:
@@ -147,22 +150,20 @@ contains
       if ( (.not. is_active_betr_bgc) .and. &
            .not.(use_pflotran .and. pf_cmode)) then
          ! column level carbon fluxes from harvest mortality
-         !$acc parallel loop independent gang default(present)
          do j = 1, nlevdecomp
             ! column loop
-            !$acc loop vector independent
             do fc = 1,num_soilc
                c = filter_soilc(fc)
 
                ! column harvest fluxes
                col_cs%decomp_cpools_vr(c,j,i_met_lit) = &
-                    col_cs%decomp_cpools_vr(c,j,i_met_lit) + col_cf%harvest_c_to_litr_met_c(c,j) * dtime_mod
+                    col_cs%decomp_cpools_vr(c,j,i_met_lit) + col_cf%harvest_c_to_litr_met_c(c,j) * dt
                col_cs%decomp_cpools_vr(c,j,i_cel_lit) = &
-                    col_cs%decomp_cpools_vr(c,j,i_cel_lit) + col_cf%harvest_c_to_litr_cel_c(c,j) * dtime_mod
+                    col_cs%decomp_cpools_vr(c,j,i_cel_lit) + col_cf%harvest_c_to_litr_cel_c(c,j) * dt
                col_cs%decomp_cpools_vr(c,j,i_lig_lit) = &
-                    col_cs%decomp_cpools_vr(c,j,i_lig_lit) + col_cf%harvest_c_to_litr_lig_c(c,j) * dtime_mod
+                    col_cs%decomp_cpools_vr(c,j,i_lig_lit) + col_cf%harvest_c_to_litr_lig_c(c,j) * dt
                col_cs%decomp_cpools_vr(c,j,i_cwd) = &
-                    col_cs%decomp_cpools_vr(c,j,i_cwd) + col_cf%harvest_c_to_cwdc(c,j)  * dtime_mod
+                    col_cs%decomp_cpools_vr(c,j,i_cwd) + col_cf%harvest_c_to_cwdc(c,j)  * dt
 
                ! wood to product pools - states updated in WoodProducts()
             end do
@@ -171,47 +172,46 @@ contains
       endif
 
       ! patch loop
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_soilp
          p = filter_soilp(fp)
 
          ! patch-level carbon fluxes from harvest mortality
          ! displayed pools
-         veg_cs%leafc(p)               = veg_cs%leafc(p)              - veg_cf%hrv_leafc_to_litter(p)              * dtime_mod
-         veg_cs%frootc(p)              = veg_cs%frootc(p)             - veg_cf%hrv_frootc_to_litter(p)             * dtime_mod
-         veg_cs%livestemc(p)           = veg_cs%livestemc(p)          - veg_cf%hrv_livestemc_to_litter(p)          * dtime_mod
-         veg_cs%deadstemc(p)           = veg_cs%deadstemc(p)          - veg_cf%hrv_deadstemc_to_prod10c(p)         * dtime_mod
-         veg_cs%deadstemc(p)           = veg_cs%deadstemc(p)          - veg_cf%hrv_deadstemc_to_prod100c(p)        * dtime_mod
-         veg_cs%livecrootc(p)          = veg_cs%livecrootc(p)         - veg_cf%hrv_livecrootc_to_litter(p)         * dtime_mod
-         veg_cs%deadcrootc(p)          = veg_cs%deadcrootc(p)         - veg_cf%hrv_deadcrootc_to_litter(p)         * dtime_mod
+         veg_cs%leafc(p)               = veg_cs%leafc(p)              - veg_cf%hrv_leafc_to_litter(p)              * dt
+         veg_cs%frootc(p)              = veg_cs%frootc(p)             - veg_cf%hrv_frootc_to_litter(p)             * dt
+         veg_cs%livestemc(p)           = veg_cs%livestemc(p)          - veg_cf%hrv_livestemc_to_litter(p)          * dt
+         veg_cs%deadstemc(p)           = veg_cs%deadstemc(p)          - veg_cf%hrv_deadstemc_to_prod10c(p)         * dt
+         veg_cs%deadstemc(p)           = veg_cs%deadstemc(p)          - veg_cf%hrv_deadstemc_to_prod100c(p)        * dt
+         veg_cs%livecrootc(p)          = veg_cs%livecrootc(p)         - veg_cf%hrv_livecrootc_to_litter(p)         * dt
+         veg_cs%deadcrootc(p)          = veg_cs%deadcrootc(p)         - veg_cf%hrv_deadcrootc_to_litter(p)         * dt
 
          ! crops
          if (ivt(p) >= npcropmin) then ! skip 2 generic crops
-             veg_cs%livestemc(p)       = veg_cs%livestemc(p)          - veg_cf%hrv_livestemc_to_prod1c(p)          *dtime_mod
-             veg_cs%leafc(p)           = veg_cs%leafc(p)              - veg_cf%hrv_leafc_to_prod1c(p)              *dtime_mod
-             veg_cs%grainc(p)          = veg_cs%grainc(p)             - veg_cf%hrv_grainc_to_prod1c(p)             *dtime_mod
+             veg_cs%livestemc(p)       = veg_cs%livestemc(p)          - veg_cf%hrv_livestemc_to_prod1c(p)          *dt
+             veg_cs%leafc(p)           = veg_cs%leafc(p)              - veg_cf%hrv_leafc_to_prod1c(p)              *dt
+             veg_cs%grainc(p)          = veg_cs%grainc(p)             - veg_cf%hrv_grainc_to_prod1c(p)             *dt
          end if
 
          ! xsmrpool
-         veg_cs%xsmrpool(p)            = veg_cs%xsmrpool(p)           - veg_cf%hrv_xsmrpool_to_atm(p)              * dtime_mod
+         veg_cs%xsmrpool(p)            = veg_cs%xsmrpool(p)           - veg_cf%hrv_xsmrpool_to_atm(p)              * dt
          ! storage pools
-         veg_cs%leafc_storage(p)       = veg_cs%leafc_storage(p)      - veg_cf%hrv_leafc_storage_to_litter(p)      * dtime_mod
-         veg_cs%frootc_storage(p)      = veg_cs%frootc_storage(p)     - veg_cf%hrv_frootc_storage_to_litter(p)     * dtime_mod
-         veg_cs%livestemc_storage(p)   = veg_cs%livestemc_storage(p)  - veg_cf%hrv_livestemc_storage_to_litter(p)  * dtime_mod
-         veg_cs%deadstemc_storage(p)   = veg_cs%deadstemc_storage(p)  - veg_cf%hrv_deadstemc_storage_to_litter(p)  * dtime_mod
-         veg_cs%livecrootc_storage(p)  = veg_cs%livecrootc_storage(p) - veg_cf%hrv_livecrootc_storage_to_litter(p) * dtime_mod
-         veg_cs%deadcrootc_storage(p)  = veg_cs%deadcrootc_storage(p) - veg_cf%hrv_deadcrootc_storage_to_litter(p) * dtime_mod
-         veg_cs%gresp_storage(p)       = veg_cs%gresp_storage(p)      - veg_cf%hrv_gresp_storage_to_litter(p)      * dtime_mod
-         veg_cs%cpool(p)               = veg_cs%cpool(p)              - veg_cf%hrv_cpool_to_litter(p)              * dtime_mod
+         veg_cs%leafc_storage(p)       = veg_cs%leafc_storage(p)      - veg_cf%hrv_leafc_storage_to_litter(p)      * dt
+         veg_cs%frootc_storage(p)      = veg_cs%frootc_storage(p)     - veg_cf%hrv_frootc_storage_to_litter(p)     * dt
+         veg_cs%livestemc_storage(p)   = veg_cs%livestemc_storage(p)  - veg_cf%hrv_livestemc_storage_to_litter(p)  * dt
+         veg_cs%deadstemc_storage(p)   = veg_cs%deadstemc_storage(p)  - veg_cf%hrv_deadstemc_storage_to_litter(p)  * dt
+         veg_cs%livecrootc_storage(p)  = veg_cs%livecrootc_storage(p) - veg_cf%hrv_livecrootc_storage_to_litter(p) * dt
+         veg_cs%deadcrootc_storage(p)  = veg_cs%deadcrootc_storage(p) - veg_cf%hrv_deadcrootc_storage_to_litter(p) * dt
+         veg_cs%gresp_storage(p)       = veg_cs%gresp_storage(p)      - veg_cf%hrv_gresp_storage_to_litter(p)      * dt
+         veg_cs%cpool(p)               = veg_cs%cpool(p)              - veg_cf%hrv_cpool_to_litter(p)              * dt
 
          ! transfer pools
-         veg_cs%leafc_xfer(p)          = veg_cs%leafc_xfer(p)         - veg_cf%hrv_leafc_xfer_to_litter(p)         * dtime_mod
-         veg_cs%frootc_xfer(p)         = veg_cs%frootc_xfer(p)        - veg_cf%hrv_frootc_xfer_to_litter(p)        * dtime_mod
-         veg_cs%livestemc_xfer(p)      = veg_cs%livestemc_xfer(p)     - veg_cf%hrv_livestemc_xfer_to_litter(p)     * dtime_mod
-         veg_cs%deadstemc_xfer(p)      = veg_cs%deadstemc_xfer(p)     - veg_cf%hrv_deadstemc_xfer_to_litter(p)     * dtime_mod
-         veg_cs%livecrootc_xfer(p)     = veg_cs%livecrootc_xfer(p)    - veg_cf%hrv_livecrootc_xfer_to_litter(p)    * dtime_mod
-         veg_cs%deadcrootc_xfer(p)     = veg_cs%deadcrootc_xfer(p)    - veg_cf%hrv_deadcrootc_xfer_to_litter(p)    * dtime_mod
-         veg_cs%gresp_xfer(p)          = veg_cs%gresp_xfer(p)         - veg_cf%hrv_gresp_xfer_to_litter(p)         * dtime_mod
+         veg_cs%leafc_xfer(p)          = veg_cs%leafc_xfer(p)         - veg_cf%hrv_leafc_xfer_to_litter(p)         * dt
+         veg_cs%frootc_xfer(p)         = veg_cs%frootc_xfer(p)        - veg_cf%hrv_frootc_xfer_to_litter(p)        * dt
+         veg_cs%livestemc_xfer(p)      = veg_cs%livestemc_xfer(p)     - veg_cf%hrv_livestemc_xfer_to_litter(p)     * dt
+         veg_cs%deadstemc_xfer(p)      = veg_cs%deadstemc_xfer(p)     - veg_cf%hrv_deadstemc_xfer_to_litter(p)     * dt
+         veg_cs%livecrootc_xfer(p)     = veg_cs%livecrootc_xfer(p)    - veg_cf%hrv_livecrootc_xfer_to_litter(p)    * dt
+         veg_cs%deadcrootc_xfer(p)     = veg_cs%deadcrootc_xfer(p)    - veg_cf%hrv_deadcrootc_xfer_to_litter(p)    * dt
+         veg_cs%gresp_xfer(p)          = veg_cs%gresp_xfer(p)         - veg_cf%hrv_gresp_xfer_to_litter(p)         * dt
 
       end do ! end of patch loop
 
diff --git a/components/elm/src/biogeochem/CarbonStateUpdate3Mod.F90 b/components/elm/src/biogeochem/CarbonStateUpdate3Mod.F90
index 0c473b0d38..f8d8c9e196 100644
--- a/components/elm/src/biogeochem/CarbonStateUpdate3Mod.F90
+++ b/components/elm/src/biogeochem/CarbonStateUpdate3Mod.F90
@@ -10,6 +10,8 @@ module CarbonStateUpdate3Mod
   use abortutils       , only : endrun
   use elm_varpar       , only : nlevdecomp, ndecomp_pools, i_cwd, i_met_lit, i_cel_lit, i_lig_lit
   use elm_varctl       , only : use_erosion, ero_ccycle
+  use CNCarbonStateType, only : carbonstate_type
+  use CNCarbonFluxType , only : carbonflux_type
   use CNDecompCascadeConType , only : decomp_cascade_con
   use ColumnDataType         , only : column_carbon_state, column_carbon_flux
   use VegetationDataType     , only : vegetation_carbon_state, vegetation_carbon_flux
@@ -34,6 +36,7 @@ contains
     ! On the radiation time step, update all the prognostic carbon state
     ! variables affected by fire fluxes and also erosion flux
     !
+      !$acc routine seq
     use tracer_varcon       , only : is_active_betr_bgc
     ! !ARGUMENTS:
     integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
@@ -55,9 +58,7 @@ contains
       if ( .not.is_active_betr_bgc )then
          ! column level carbon fluxes from fire
          if (.not.(use_pflotran .and. pf_cmode)) then
-            !$acc parallel loop independent gang default(present)
              do j = 1, nlevdecomp
-                !$acc loop vector private(c)
                 do fc = 1,num_soilc
                    c = filter_soilc(fc)
                    ! pft-level wood to column-level CWD (uncombusted wood)
@@ -76,14 +77,11 @@ contains
          end if !(.not.(use_pflotran .and. pf_cmode))
 
          ! litter and CWD losses to fire
-         !$acc parallel loop independent collapse(2) gang default(present)
          do l = 1, ndecomp_pools
             do j = 1, nlevdecomp
-               !$acc loop vector private(c)
                do fc = 1,num_soilc
                   c = filter_soilc(fc)
-                  col_cs%decomp_cpools_vr(c,j,l) = col_cs%decomp_cpools_vr(c,j,l) &
-                              - col_cf%m_decomp_cpools_to_fire_vr(c,j,l) * dt
+                  col_cs%decomp_cpools_vr(c,j,l) = col_cs%decomp_cpools_vr(c,j,l) - col_cf%m_decomp_cpools_to_fire_vr(c,j,l) * dt
                end do
             end do
          end do
@@ -96,8 +94,7 @@ contains
                do j = 1, nlevdecomp
                   do fc = 1, num_soilc
                      c = filter_soilc(fc)
-                     col_cs%decomp_cpools_vr(c,j,l) = col_cs%decomp_cpools_vr(c,j,l)&
-                                 - col_cf%decomp_cpools_yield_vr(c,j,l) * dt
+                     col_cs%decomp_cpools_vr(c,j,l) = col_cs%decomp_cpools_vr(c,j,l) - col_cf%decomp_cpools_yield_vr(c,j,l) * dt
                   end do
                end do
             end if
@@ -106,9 +103,9 @@ contains
 
 
       ! patch loop
-      !$acc parallel loop independent gang vector private(p) default(present)
       do fp = 1,num_soilp
          p = filter_soilp(fp)
+
          ! pft-level carbon fluxes from fire
          ! displayed pools
          veg_cs%leafc(p)              = veg_cs%leafc(p)               - veg_cf%m_leafc_to_fire(p)            * dt
@@ -157,6 +154,8 @@ contains
          veg_cs%gresp_xfer(p)         = veg_cs%gresp_xfer(p)          - veg_cf%m_gresp_xfer_to_litter_fire(p)     * dt
          veg_cs%cpool(p)              = veg_cs%cpool(p)               - veg_cf%m_cpool_to_fire(p)                 * dt
          veg_cs%cpool(p)              = veg_cs%cpool(p)               - veg_cf%m_cpool_to_litter_fire(p)          * dt
+
+
       end do ! end of pft loop
 
   end subroutine CarbonStateUpdate3
diff --git a/components/elm/src/biogeochem/CropHarvestPoolsMod.F90 b/components/elm/src/biogeochem/CropHarvestPoolsMod.F90
index 0e6d49e9a9..6ba9e73bc2 100644
--- a/components/elm/src/biogeochem/CropHarvestPoolsMod.F90
+++ b/components/elm/src/biogeochem/CropHarvestPoolsMod.F90
@@ -33,20 +33,22 @@ contains
     ! associated with crop harvest.
     !
     ! !ARGUMENTS:
-    !! $acc routine seq
+      !$acc routine seq
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
     real(r8)                 , intent(in)     :: dt        ! time step (seconds)
     ! !LOCAL VARIABLES:
     integer :: fc        ! lake filter indices
     integer :: c         ! indices
-    real(r8),parameter :: kprod1=7.2e-9       ! decay constant for 1-year product pool
+    real(r8) :: kprod1       ! decay constant for 1-year product pool
     !-----------------------------------------------------------------------
+
+
     ! calculate column-level losses from product pools
     ! the following (1/s) rate constants result in ~90% loss of initial state over 1 year,
     ! using a discrete-time fractional decay algorithm.
+    kprod1 = 7.2e-9
 
-    !$acc parallel loop independent gang vector default(present)
     do fc = 1,num_soilc
        c = filter_soilc(fc)
 
@@ -67,7 +69,6 @@ contains
 
 
    ! update wood product state variables
-   !$acc parallel loop independent gang vector default(present)
     do fc = 1,num_soilc
        c = filter_soilc(fc)
 
diff --git a/components/elm/src/biogeochem/CropMod.F90 b/components/elm/src/biogeochem/CropMod.F90
index 2185806f6e..1c0bddb9a1 100644
--- a/components/elm/src/biogeochem/CropMod.F90
+++ b/components/elm/src/biogeochem/CropMod.F90
@@ -35,7 +35,7 @@ contains
     ! The basic equation looks like this:
     ! ETo = (0.408*delta*(Rn-G) + gamma*(900/(T+273))*u2*(es-ea))/
     !         (delta + gamma*(1+0.34*u2))
-    !$acc routine seq 
+
     ! !USES:
     use elm_varcon       , only : tfrz
 
@@ -95,11 +95,10 @@ contains
 
     ! !DESCRIPTION
     ! calculates the plant month based on the type of seasonality
-    !$acc routine seq 
+
     ! !USES:
     use pftvarcon        , only : planttemp
     use CropType          , only : tcvp, tcvt, cst
-    use SimpleMathMod  , only : MAXLOC_
     ! !ARGUMENTS:
     implicit none
     integer,  intent(in)  :: p
@@ -133,10 +132,10 @@ contains
           if (minval(temp) .lt. cst)then ! cold season exists
               plantmonth = t_m
           else                            ! no cold season
-              plantmonth = month(maxloc_(p2e))
+              plantmonth = month(maxloc(p2e))
           end if
        else                     ! precipitation seasonality
-         plantmonth = month(maxloc_(p2e))
+         plantmonth = month(maxloc(p2e))
        end if
     else if (cvt > tcvt) then   ! temperature seasonality
        plantmonth = t_m
diff --git a/components/elm/src/biogeochem/DUSTMod.F90 b/components/elm/src/biogeochem/DUSTMod.F90
index 5a422a13d9..88ff22504e 100644
--- a/components/elm/src/biogeochem/DUSTMod.F90
+++ b/components/elm/src/biogeochem/DUSTMod.F90
@@ -61,13 +61,13 @@ module DUSTMod
   type, public :: dust_type
 
      real(r8), pointer, PUBLIC  :: flx_mss_vrt_dst_patch     (:,:)  ! surface dust emission (kg/m**2/s) [ + = to atm] (ndst)
-     real(r8), pointer, public :: flx_mss_vrt_dst_tot_patch (:)    ! total dust flux into atmosphere
-     real(r8), pointer, public :: vlc_trb_patch             (:,:)  ! turbulent deposition velocity  (m/s) (ndst)
-     real(r8), pointer, public :: vlc_trb_1_patch           (:)    ! turbulent deposition velocity 1(m/s)
-     real(r8), pointer, public :: vlc_trb_2_patch           (:)    ! turbulent deposition velocity 2(m/s)
-     real(r8), pointer, public :: vlc_trb_3_patch           (:)    ! turbulent deposition velocity 3(m/s)
-     real(r8), pointer, public :: vlc_trb_4_patch           (:)    ! turbulent deposition velocity 4(m/s)
-     real(r8), pointer, public :: mbl_bsn_fct_col           (:)    ! basin factor
+     real(r8), pointer, private :: flx_mss_vrt_dst_tot_patch (:)    ! total dust flux into atmosphere
+     real(r8), pointer, private :: vlc_trb_patch             (:,:)  ! turbulent deposition velocity  (m/s) (ndst)
+     real(r8), pointer, private :: vlc_trb_1_patch           (:)    ! turbulent deposition velocity 1(m/s)
+     real(r8), pointer, private :: vlc_trb_2_patch           (:)    ! turbulent deposition velocity 2(m/s)
+     real(r8), pointer, private :: vlc_trb_3_patch           (:)    ! turbulent deposition velocity 3(m/s)
+     real(r8), pointer, private :: vlc_trb_4_patch           (:)    ! turbulent deposition velocity 4(m/s)
+     real(r8), pointer, private :: mbl_bsn_fct_col           (:)    ! basin factor
 
    contains
 
@@ -139,9 +139,9 @@ contains
     begp = bounds%begp; endp = bounds%endp
 
     this%flx_mss_vrt_dst_tot_patch(begp:endp) = spval
-   call hist_addfld1d (fname='DSTFLXT', units='kg/m2/s',  &
-        avgflag='A', long_name='total surface dust emission', &
-        ptr_patch=this%flx_mss_vrt_dst_tot_patch, set_lake=0._r8, set_urb=0._r8)
+    call hist_addfld1d (fname='DSTFLXT', units='kg/m2/s',  &
+         avgflag='A', long_name='total surface dust emission', &
+         ptr_patch=this%flx_mss_vrt_dst_tot_patch, set_lake=0._r8, set_urb=0._r8)
 
     this%vlc_trb_1_patch(begp:endp) = spval
     call hist_addfld1d (fname='DPVLTRB1', units='m/s',  &
@@ -191,7 +191,7 @@ contains
   !------------------------------------------------------------------------
   subroutine DustEmission (bounds, &
        num_nolakep, filter_nolakep, &
-       soilstate_vars, canopystate_vars, &
+       atm2lnd_vars, soilstate_vars, canopystate_vars, &
        frictionvel_vars, dust_vars)
     !
     ! !DESCRIPTION:
@@ -202,12 +202,14 @@ contains
     ! Source: C. Zender's dust model
     !
     ! !USES
+      !$acc routine seq
     use shr_const_mod, only : SHR_CONST_RHOFW
     !
     ! !ARGUMENTS:
     type(bounds_type)      , intent(in)    :: bounds
     integer                , intent(in)    :: num_nolakep                 ! number of column non-lake points in pft filter
     integer                , intent(in)    :: filter_nolakep(num_nolakep) ! patch filter for non-lake points
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(soilstate_type)   , intent(in)    :: soilstate_vars
     type(canopystate_type) , intent(in)    :: canopystate_vars
     type(frictionvel_type) , intent(in)    :: frictionvel_vars
@@ -222,21 +224,20 @@ contains
     real(r8) :: wnd_rfr_dlt         ! [m s-1] Reference windspeed excess over threshld
     real(r8) :: dst_slt_flx_rat_ttl
     real(r8) :: flx_mss_hrz_slt_ttl
-    real(r8) :: flx_mss_vrt_dst_ttl(1:num_nolakep)
+    real(r8) :: flx_mss_vrt_dst_ttl(bounds%begp:bounds%endp)
     real(r8) :: frc_thr_wet_fct
     real(r8) :: frc_thr_rgh_fct
     real(r8) :: wnd_frc_thr_slt
     real(r8) :: wnd_rfr_thr_slt
     real(r8) :: wnd_frc_slt
-    real(r8) :: lnd_frc_mbl(1:num_nolakep)
+    real(r8) :: lnd_frc_mbl(bounds%begp:bounds%endp)
     real(r8) :: bd
     real(r8) :: gwc_sfc
     real(r8) :: ttlai(bounds%begp:bounds%endp)
     real(r8) :: tlai_lu(bounds%begl:bounds%endl)
-   !  real(r8) :: sumwt(bounds%begl:bounds%endl) ! sum of weights
+    real(r8) :: sumwt(bounds%begl:bounds%endl) ! sum of weights
     logical  :: found                          ! temporary for error check
     integer  :: index
-    real(r8) :: sum1, sum2 
     !
     ! constants
     !
@@ -267,57 +268,47 @@ contains
          flx_mss_vrt_dst     => dust_vars%flx_mss_vrt_dst_patch      , & ! Output: [real(r8) (:,:) ]  surface dust emission (kg/m**2/s)
          flx_mss_vrt_dst_tot => dust_vars%flx_mss_vrt_dst_tot_patch    & ! Output: [real(r8) (:)   ]  total dust flux back to atmosphere (pft)
          )
-    !$acc enter data create(&
-    !$acc flx_mss_vrt_dst_ttl(:), &
-    !$acc lnd_frc_mbl(:), &
-    !$acc ttlai(:), &
-    !$acc tlai_lu(:), &
-    !$acc flx_mss_hrz_slt_ttl, &
-    !$acc sum1, &
-    !$acc sum2)
 
       ttlai(bounds%begp : bounds%endp) = 0._r8
       ! make lai average at landunit level
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_nolakep
          p = filter_nolakep(fp)
          ttlai(p) = tlai(p)+tsai(p)
       enddo
 
-      !$acc parallel loop independent gang worker default(present) create(sum1,sum2) private(sum1,sum2)
-      do l = bounds%begl,bounds%endl
-         sum1 = 0._r8 
-         sum2 = 0._r8 
-         !$acc loop reduction(+:sum1,sum2)
-         do p = lun_pp%pfti(l), lun_pp%pftf(l) 
-            ! Can active pfts have a weight of 0?
-            if (veg_pp%active(p) .and. veg_pp%wtlunit(p) /= 0._r8) then
-               sum1 = sum1 + ttlai(p) * veg_pp%wtlunit(p)
-               sum2 = sum2 + veg_pp%wtlunit(p)
-            end if
-         end do 
-         tlai_lu(l) = sum1
-         if(sum2 > 1.0_r8 + 1.e-6_r8) then 
-            stop
-         end if 
-         if(sum2 /= 0._r8) then 
-            tlai_lu(l) = tlai_lu(l)/sum2
-         end if 
+      tlai_lu(bounds%begl : bounds%endl) = spval
+      sumwt(bounds%begl : bounds%endl) = 0._r8
+      do p = bounds%begp,bounds%endp
+         if (ttlai(p) /= spval .and. veg_pp%active(p) .and. veg_pp%wtlunit(p) /= 0._r8) then
+            c = veg_pp%column(p)
+            l = veg_pp%landunit(p)
+            if (sumwt(l) == 0._r8) tlai_lu(l) = 0._r8
+            tlai_lu(l) = tlai_lu(l) + ttlai(p) * veg_pp%wtlunit(p)
+            sumwt(l) = sumwt(l) + veg_pp%wtlunit(p)
+         end if
       end do
-      
-      !pds NOTE: need to copyout found from gpu region.
       found = .false.
+      do l = bounds%begl,bounds%endl
+         if (sumwt(l) > 1.0_r8 + 1.e-6_r8) then
+            found = .true.
+            index = l
+            exit
+         else if (sumwt(l) /= 0._r8) then
+            tlai_lu(l) = tlai_lu(l)/sumwt(l)
+         end if
+      end do
       if (found) then
-         write(iulog,*)  'p2l_1d error: sumwt is greater than 1.0 at l= '
+#ifndef _OPENACC
+         write(iulog,*)  'p2l_1d error: sumwt is greater than 1.0 at l= ',index
          call endrun(msg=errMsg(__FILE__, __LINE__))
+#endif
       end if
 
       ! Loop through patches
 
       ! initialize variables which get passed to the atmosphere
       flx_mss_vrt_dst(bounds%begp:bounds%endp,:)=0._r8
-      
-      !$acc parallel loop independent gang vector default(present)
+
       do fp = 1,num_nolakep
          p = filter_nolakep(fp)
          c = veg_pp%column(p)
@@ -332,22 +323,20 @@ contains
 
          if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
             if (tlai_lu(l) < vai_mbl_thr) then
-               lnd_frc_mbl(fp) = 1.0_r8 - (tlai_lu(l))/vai_mbl_thr
+               lnd_frc_mbl(p) = 1.0_r8 - (tlai_lu(l))/vai_mbl_thr
             else
-               lnd_frc_mbl(fp) = 0.0_r8
+               lnd_frc_mbl(p) = 0.0_r8
             endif
-            lnd_frc_mbl(fp) = lnd_frc_mbl(fp) * (1.0_r8 - frac_sno(c))
+            lnd_frc_mbl(p) = lnd_frc_mbl(p) * (1.0_r8 - frac_sno(c))
          else
-            lnd_frc_mbl(fp) = 0.0_r8
+            lnd_frc_mbl(p) = 0.0_r8
          end if
-
       end do
 
 #ifndef _OPENACC
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_nolakep
          p = filter_nolakep(fp)
-         if (lnd_frc_mbl(fp)>1.0_r8 .or. lnd_frc_mbl(fp)<0.0_r8) then
+         if (lnd_frc_mbl(p)>1.0_r8 .or. lnd_frc_mbl(p)<0.0_r8) then
             write(iulog,*)'Error dstmbl: pft= ',p,' lnd_frc_mbl(p)= ',lnd_frc_mbl(p)
             call endrun(msg=errMsg(__FILE__, __LINE__))
          end if
@@ -356,20 +345,17 @@ contains
 
       ! reset history output variables before next if-statement to avoid output = inf
 
-      ! !$acc parallel loop independent gang vector default(present)
-      ! do fp = 1,num_nolakep
-      !    p = filter_nolakep(fp)
-      !    flx_mss_vrt_dst_tot(p) = 0.0_r8
-      ! end do
-      ! !$acc parallel loop independent gang vector default(present) collapse(2) 
-      ! do n = 1, ndst
-      !    do fp = 1,num_nolakep
-      !       p = filter_nolakep(fp)
-      !       flx_mss_vrt_dst(p,n) = 0.0_r8
-      !    end do
-      ! end do
-
-      !$acc parallel loop independent gang vector default(present)
+      do fp = 1,num_nolakep
+         p = filter_nolakep(fp)
+         flx_mss_vrt_dst_tot(p) = 0.0_r8
+      end do
+      do n = 1, ndst
+         do fp = 1,num_nolakep
+            p = filter_nolakep(fp)
+            flx_mss_vrt_dst(p,n) = 0.0_r8
+         end do
+      end do
+
       do fp = 1,num_nolakep
          p = filter_nolakep(fp)
          c = veg_pp%column(p)
@@ -379,7 +365,7 @@ contains
 
          ! only perform the following calculations if lnd_frc_mbl is non-zero
 
-         if (lnd_frc_mbl(fp) > 0.0_r8) then
+         if (lnd_frc_mbl(p) > 0.0_r8) then
 
             ! the following comes from subr. frc_thr_rgh_fct_get
             ! purpose: compute factor by which surface roughness increases threshold
@@ -417,7 +403,7 @@ contains
 
             wnd_frc_slt = fv(p)
             flx_mss_hrz_slt_ttl = 0.0_r8
-            flx_mss_vrt_dst_ttl(fp) = 0.0_r8
+            flx_mss_vrt_dst_ttl(p) = 0.0_r8
 
             ! the following line comes from subr. dst_mbl
             ! purpose: threshold saltation wind speed
@@ -447,7 +433,7 @@ contains
                ! slevis: multiply flx_mss_hrz_slt_ttl by liqfrac to incude the effect
                ! of frozen soil
 
-               flx_mss_hrz_slt_ttl = flx_mss_hrz_slt_ttl * lnd_frc_mbl(fp) * mbl_bsn_fct(c) * &
+               flx_mss_hrz_slt_ttl = flx_mss_hrz_slt_ttl * lnd_frc_mbl(p) * mbl_bsn_fct(c) * &
                     flx_mss_fdg_fct * liqfrac
             end if
 
@@ -456,7 +442,7 @@ contains
             !          integrated streamwise mass flux
 
             dst_slt_flx_rat_ttl = 100.0_r8 * exp( log(10.0_r8) * (13.4_r8 * mss_frc_cly_vld(c) - 6.0_r8) )
-            flx_mss_vrt_dst_ttl(fp) = flx_mss_hrz_slt_ttl * dst_slt_flx_rat_ttl
+            flx_mss_vrt_dst_ttl(p) = flx_mss_hrz_slt_ttl * dst_slt_flx_rat_ttl
 
          end if   ! lnd_frc_mbl > 0.0
 
@@ -464,53 +450,34 @@ contains
 
       ! the following comes from subr. flx_mss_vrt_dst_prt in C. Zender's code
       ! purpose: partition total vertical mass flux of dust into transport bins
-      
-      !$acc parallel loop independent gang worker collapse(2) default(present) 
+
+      do n = 1, ndst
+         do m = 1, dst_src_nbr
+            do fp = 1,num_nolakep
+               p = filter_nolakep(fp)
+               if (lnd_frc_mbl(p) > 0.0_r8) then
+                  flx_mss_vrt_dst(p,n) = flx_mss_vrt_dst(p,n) +  ovr_src_snk_mss(m,n) * flx_mss_vrt_dst_ttl(p)
+               end if
+            end do
+         end do
+      end do
+
       do n = 1, ndst
          do fp = 1,num_nolakep
             p = filter_nolakep(fp)
-            sum1 = 0._r8 
-
-            if (lnd_frc_mbl(fp) > 0.0_r8) then
-               !$acc loop reduction(+:sum1 )
-               do m = 1, dst_src_nbr
-                  sum1 = sum1 +  ovr_src_snk_mss(m,n) * flx_mss_vrt_dst_ttl(fp)
-               end do
+            if (lnd_frc_mbl(p) > 0.0_r8) then
+               flx_mss_vrt_dst_tot(p) = flx_mss_vrt_dst_tot(p) + flx_mss_vrt_dst(p,n)
             end if
-            flx_mss_vrt_dst(p,n) = + sum1 
          end do
       end do
 
-      !$acc parallel loop independent gang worker default(present) 
-      do fp = 1,num_nolakep
-         p = filter_nolakep(fp)
-         sum1 = 0._r8 
-         
-         if (lnd_frc_mbl(fp) > 0.0_r8) then
-            !$acc loop reduction(+:sum1)
-            do n = 1, ndst
-               sum1 = sum1 + flx_mss_vrt_dst(p,n)
-            end do
-         end if
-         flx_mss_vrt_dst_tot(p) = sum1 
-      end do
-
-
-    !$acc exit data delete(&
-    !$acc flx_mss_vrt_dst_ttl(:), &
-    !$acc lnd_frc_mbl(:), &
-    !$acc ttlai(:), &
-    !$acc tlai_lu(:), &
-    !$acc flx_mss_hrz_slt_ttl, &
-    !$acc sum1, &
-    !$acc sum2)
-
     end associate
 
   end subroutine DustEmission
 
    !------------------------------------------------------------------------
-  subroutine DustDryDep (bounds, frictionvel_vars, dust_vars)
+  subroutine DustDryDep (bounds, &
+       atm2lnd_vars, frictionvel_vars, dust_vars)
     !
     ! !DESCRIPTION:
     !
@@ -528,10 +495,12 @@ contains
     ! Source: C. Zender's dry deposition code
     !
     ! !USES
+      !$acc routine seq
     use shr_const_mod, only : SHR_CONST_PI, SHR_CONST_RDAIR, SHR_CONST_BOLTZ
     !
     ! !ARGUMENTS:
     type(bounds_type)      , intent(in)    :: bounds
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(frictionvel_type) , intent(in)    :: frictionvel_vars
     type(dust_type)        , intent(inout) :: dust_vars
     !
@@ -556,8 +525,10 @@ contains
          forc_pbot =>    top_as%pbot                           , & ! Input:  [real(r8)  (:)   ]  atm pressure (Pa)
          forc_rho  =>    top_as%rhobot                         , & ! Input:  [real(r8)  (:)   ]  atm density (kg/m**3)
          forc_t    =>    top_as%tbot                           , & ! Input:  [real(r8)  (:)   ]  atm temperature (K)
+
          ram1      =>    frictionvel_vars%ram1_patch           , & ! Input:  [real(r8)  (:)   ]  aerodynamical resistance (s/m)
          fv        =>    frictionvel_vars%fv_patch             , & ! Input:  [real(r8)  (:)   ]  friction velocity (m/s)
+
          vlc_trb   =>    dust_vars%vlc_trb_patch               , & ! Output:  [real(r8) (:,:) ]  Turbulent deposn velocity (m/s)
          vlc_trb_1 =>    dust_vars%vlc_trb_1_patch             , & ! Output:  [real(r8) (:)   ]  Turbulent deposition velocity 1
          vlc_trb_2 =>    dust_vars%vlc_trb_2_patch             , & ! Output:  [real(r8) (:)   ]  Turbulent deposition velocity 2
@@ -565,14 +536,6 @@ contains
          vlc_trb_4 =>    dust_vars%vlc_trb_4_patch               & ! Output:  [real(r8) (:)   ]  Turbulent deposition velocity 4
          )
 
-      !$acc enter data create(&
-      !$acc vsc_dyn_atm(:), &
-      !$acc vsc_knm_atm(:), &
-      !$acc slp_crc(:,:), &
-      !$acc vlc_grv(:,:), &
-      !$acc rss_lmn(:,:))
-
-      !$acc parallel loop independent gang vector default(present)
       do p = bounds%begp,bounds%endp
          if (veg_pp%active(p)) then
             g = veg_pp%gridcell(p)
@@ -592,7 +555,6 @@ contains
                  (forc_pbot(t)*sqrt(8.0_r8/(SHR_CONST_PI*SHR_CONST_RDAIR*forc_t(t))))
             vsc_knm_atm(p) = vsc_dyn_atm(p) / forc_rho(t) ![m2 s-1] Kinematic viscosity of air
 
-            !$acc loop seq
             do m = 1, ndst
                slp_crc(p,m) = 1.0_r8 + 2.0_r8 * mfp_atm * &
                     (1.257_r8+0.4_r8*exp(-1.1_r8*dmt_vwr(m)/(2.0_r8*mfp_atm))) / &
@@ -604,7 +566,6 @@ contains
          end if
       end do
 
-      !$acc parallel loop independent gang vector default(present) collapse(2)
       do m = 1, ndst
          do p = bounds%begp,bounds%endp
             if (veg_pp%active(p)) then
@@ -633,7 +594,6 @@ contains
 
       ! Lowest layer: Turbulent deposition (CAM will calc. gravitational dep)
 
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do m = 1, ndst
          do p = bounds%begp,bounds%endp
             if (veg_pp%active(p)) then
@@ -643,7 +603,6 @@ contains
          end do
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do p = bounds%begp,bounds%endp
          if (veg_pp%active(p)) then
             vlc_trb_1(p) = vlc_trb(p,1)
@@ -653,13 +612,6 @@ contains
          end if
       end do
 
-    !$acc exit data delete(&
-    !$acc vsc_dyn_atm(:), &
-    !$acc vsc_knm_atm(:), &
-    !$acc slp_crc(:,:), &
-    !$acc vlc_grv(:,:), &
-    !$acc rss_lmn(:,:))
-
     end associate
 
   end subroutine DustDryDep
@@ -680,6 +632,7 @@ contains
      !
      ! !USES
      use shr_const_mod , only: SHR_CONST_PI, SHR_CONST_RDAIR
+     use shr_spfn_mod  , only: erf => shr_spfn_erf
      use decompMod     , only : get_proc_bounds
      !
      ! !ARGUMENTS:
@@ -981,11 +934,11 @@ contains
       do m = 1, ndst
          stk_crc(m) = vlc_grv(m) / vlc_stk(m)
       end do
-      !! !$acc update device(ovr_src_snk_mss(:,:))
-      !! !$acc update device(dmt_vwr(:)          )
-      !! !$acc update device(stk_crc(:)          )
-      !! !$acc update device(tmp1)
-      !! !$acc update device(dns_aer)
+      !$acc update device(ovr_src_snk_mss(:,:))
+      !$acc update device(dmt_vwr(:)          )
+      !$acc update device(stk_crc(:)          )
+      !$acc update device(tmp1)
+      !$acc update device(dns_aer)
     end associate
 
   end subroutine InitDustVars
diff --git a/components/elm/src/biogeochem/DecompCascadeCNMod.F90 b/components/elm/src/biogeochem/DecompCascadeCNMod.F90
index edba690e85..c657cb8367 100644
--- a/components/elm/src/biogeochem/DecompCascadeCNMod.F90
+++ b/components/elm/src/biogeochem/DecompCascadeCNMod.F90
@@ -620,10 +620,10 @@ contains
 
     end associate
 
-end subroutine init_decompcascade_cn
+   end subroutine init_decompcascade_cn
 
    !-----------------------------------------------------------------------
-   subroutine decomp_rate_constants_cn( &
+   subroutine decomp_rate_constants_cn(bounds, &
         num_soilc, filter_soilc, &
         canopystate_vars, soilstate_vars, ch4_vars, cnstate_vars)
      !
@@ -633,10 +633,12 @@ end subroutine init_decompcascade_cn
      ! written by C. Koven based on original CLM4 decomposition cascade by P. Thornton
      !
      ! !USES:
+      !$acc routine seq
      use elm_varcon      , only : secspday
      use elm_varpar      , only : i_cwd
      !
      ! !ARGUMENTS:
+     type(bounds_type)      , intent(in)    :: bounds
      integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
      integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
      type(canopystate_type) , intent(in)    :: canopystate_vars
@@ -645,10 +647,12 @@ end subroutine init_decompcascade_cn
      type(cnstate_type)     , intent(inout) :: cnstate_vars
      real(r8)   :: dt                           ! decomp timestep (seconds)
      integer  :: year, mon, day, sec          ! fraction of potential aerobic rate
+
+
      !
      ! !LOCAL VARIABLES:
      real(r8):: dtd                          ! decomp timestep (days)
-     real(r8):: frw(num_soilc) ! rooting fraction weight
+     real(r8):: frw(bounds%begc:bounds%endc) ! rooting fraction weight
      real(r8), allocatable:: fr(:,:)         ! column-level rooting fraction by soil depth
      real(r8):: minpsi, maxpsi               ! limits for soil water scalar for decomp
      real(r8):: psi                          ! temporary soilpsi for water scalar
@@ -661,6 +665,16 @@ end subroutine init_decompcascade_cn
      real(r8):: k_s3                         ! decomposition rate constant SOM 3
      real(r8):: k_s4                         ! decomposition rate constant SOM 4
      real(r8):: k_frag                       ! fragmentation rate constant CWD
+     real(r8):: ck_l1                        ! corrected decomposition rate constant litter 1
+     real(r8):: ck_l2                        ! corrected decomposition rate constant litter 2
+     real(r8):: ck_l3                        ! corrected decomposition rate constant litter 3
+     real(r8):: ck_s1                        ! corrected decomposition rate constant SOM 1
+     real(r8):: ck_s2                        ! corrected decomposition rate constant SOM 2
+     real(r8):: ck_s3                        ! corrected decomposition rate constant SOM 3
+     real(r8):: ck_s4                        ! corrected decomposition rate constant SOM 4
+     real(r8):: ck_frag                      ! corrected fragmentation rate constant CWD
+     real(r8):: cwdc_loss                    ! fragmentation rate for CWD carbon (gC/m2/s)
+     real(r8):: cwdn_loss                    ! fragmentation rate for CWD nitrogen (gN/m2/s)
      integer :: i_litr1
      integer :: i_litr2
      integer :: i_litr3
@@ -672,15 +686,18 @@ end subroutine init_decompcascade_cn
      real(r8):: Q10                          ! temperature dependence
      real(r8):: froz_q10                     ! separate q10 for frozen soil respiration rates.  default to same as above zero rates
      real(r8):: decomp_depth_efolding        ! (meters) e-folding depth for reduction in decomposition [
-     real(r8):: depth_scalar(num_soilc,1:nlevdecomp)
+     real(r8):: depth_scalar(bounds%begc:bounds%endc,1:nlevdecomp)
      real(r8) :: mino2lim                    ! minimum anaerobic decomposition rate as a
      !-----------------------------------------------------------------------
 
      associate(                                             &
           dz             => col_pp%dz                        , & ! Input:  [real(r8) (:,:)   ]  soil layer thickness (m)
+
           sucsat         => soilstate_vars%sucsat_col     , & ! Input:  [real(r8) (:,:)   ]  minimum soil suction (mm)
           soilpsi        => soilstate_vars%soilpsi_col    , & ! Input:  [real(r8) (:,:)   ]  soil water potential in each soil layer (MPa)
+
           alt_indx       => canopystate_vars%alt_indx_col , & ! Input:  [integer  (:)     ]  current depth of thaw
+
           t_soisno       => col_es%t_soisno , & ! Input:  [real(r8) (:,:)   ]  soil temperature (Kelvin)  (-nlevsno+1:nlevgrnd)
 
           o2stress_sat   => ch4_vars%o2stress_sat_col     , & ! Input:  [real(r8) (:,:)   ]  Ratio of oxygen available to that demanded by roots, aerobes, & methanotrophs (nlevsoi)
@@ -770,38 +787,31 @@ end subroutine init_decompcascade_cn
           k_frag = k_frag * DecompCNParamsInst%spinup_vector(8)
        endif
 
-       !$acc enter data copyin(froz_q10,Q10,minpsi, mino2lim, decomp_depth_efolding, &
-       !$acc   k_l1,k_l2,k_l3,k_s1,k_s2,k_s3,k_s4, k_frag,&
-       !$acc   i_litr1,i_litr2, i_litr3, i_soil1, i_soil2, i_soil3, i_soil4)
-       !$acc enter data create(depth_scalar(1:num_soilc,1:nlevdecomp))
        !--- time dependent coefficients-----!
        if ( nlevdecomp .eq. 1 ) then
 
           ! calculate function to weight the temperature and water potential scalars
           ! for decomposition control.
 
-         #ifndef _OPENACC
-            print *, " WARNING nlevdecomp = 1, not supported with OpenACC!"
-            stop
-         #endif
+
           ! the following normalizes values in fr so that they
           ! sum to 1.0 across top nlevdecomp levels on a column
-          frw(1:num_soilc) = 0._r8
+          frw(bounds%begc:bounds%endc) = 0._r8
           nlev_soildecomp_standard=5
-          allocate(fr(1:num_soilc,nlev_soildecomp_standard))
+          allocate(fr(bounds%begc:bounds%endc,nlev_soildecomp_standard))
           do j=1,nlev_soildecomp_standard
              do fc = 1,num_soilc
                 c = filter_soilc(fc)
-                frw(fc) = frw(fc) + dz(c,j)
+                frw(c) = frw(c) + dz(c,j)
              end do
           end do
           do j = 1,nlev_soildecomp_standard
              do fc = 1,num_soilc
                 c = filter_soilc(fc)
-                if (frw(fc) /= 0._r8) then
-                   fr(fc,j) = dz(c,j) / frw(fc)
+                if (frw(c) /= 0._r8) then
+                   fr(c,j) = dz(c,j) / frw(c)
                 else
-                   fr(fc,j) = 0._r8
+                   fr(c,j) = 0._r8
                 end if
              end do
           end do
@@ -822,10 +832,10 @@ end subroutine init_decompcascade_cn
                 !! t_scalar(c,1)=t_scalar(c,1) + (1.5**((t_soisno(c,j)-(SHR_CONST_TKFRZ+25._r8))/10._r8))*fr(c,j)
                 if (t_soisno(c,j) >= SHR_CONST_TKFRZ) then
                    t_scalar(c,1)=t_scalar(c,1) + &
-                        (Q10**((t_soisno(c,j)-(SHR_CONST_TKFRZ+25._r8))/10._r8))*fr(fc,j)
+                        (Q10**((t_soisno(c,j)-(SHR_CONST_TKFRZ+25._r8))/10._r8))*fr(c,j)
                 else
                    t_scalar(c,1)=t_scalar(c,1) + &
-                        (Q10**(-25._r8/10._r8))*(froz_q10**((t_soisno(c,j)-SHR_CONST_TKFRZ)/10._r8))*fr(fc,j)
+                        (Q10**(-25._r8/10._r8))*(froz_q10**((t_soisno(c,j)-SHR_CONST_TKFRZ)/10._r8))*fr(c,j)
                 endif
              end do
           end do
@@ -846,7 +856,7 @@ end subroutine init_decompcascade_cn
                 psi = min(soilpsi(c,j),maxpsi)
                 ! decomp only if soilpsi is higher than minpsi
                 if (psi > minpsi) then
-                   w_scalar(c,1) = w_scalar(c,1) + (log(minpsi/psi)/log(minpsi/maxpsi))*fr(fc,j)
+                   w_scalar(c,1) = w_scalar(c,1) + (log(minpsi/psi)/log(minpsi/maxpsi))*fr(c,j)
                 end if
              end do
           end do
@@ -866,6 +876,7 @@ end subroutine init_decompcascade_cn
              ! Calculate ANOXIA
              if (anoxia) then
                 ! Check for anoxia w/o LCH4 now done in controlMod.
+
                 do j = 1,nlev_soildecomp_standard
                    do fc = 1,num_soilc
                       c = filter_soilc(fc)
@@ -873,19 +884,19 @@ end subroutine init_decompcascade_cn
                       if (j==1) o_scalar(c,:) = 0._r8
 
                       if (.not. anoxia_wtsat) then
-                         o_scalar(c,1) = o_scalar(c,1) + fr(fc,j) * max(o2stress_unsat(c,j), mino2lim)
+                         o_scalar(c,1) = o_scalar(c,1) + fr(c,j) * max(o2stress_unsat(c,j), mino2lim)
                       else
-                         o_scalar(c,1) = o_scalar(c,1) + fr(fc,j) * &
+                         o_scalar(c,1) = o_scalar(c,1) + fr(c,j) * &
                               (max(o2stress_unsat(c,j), mino2lim)*(1._r8 - finundated(c)) + &
                               max(o2stress_sat(c,j), mino2lim)*finundated(c) )
                       end if
                    end do
                 end do
              else
-                o_scalar(:,1:nlevdecomp) = 1._r8
+                o_scalar(bounds%begc:bounds%endc,1:nlevdecomp) = 1._r8
              end if
           else
-             o_scalar(:,1:nlevdecomp) = 1._r8
+             o_scalar(bounds%begc:bounds%endc,1:nlevdecomp) = 1._r8
           end if
 
           deallocate(fr)
@@ -901,10 +912,7 @@ end subroutine init_decompcascade_cn
           ! atmospheric CO2 concentration in global simulations. This does not impact
           ! the base rates at 25 C, which are calibrated from microcosm studies.
 
-
-          !$acc parallel loop independent gang default(present) async(1)
           do j = 1, nlevdecomp
-             !$acc loop vector independent private(c)
              do fc = 1,num_soilc
                 c = filter_soilc(fc)
                 !! use separate (possibly equal) t funcs above and below freezing point
@@ -926,9 +934,7 @@ end subroutine init_decompcascade_cn
           ! Orchard, V.A., and F.J. Cook, 1983. Relationship between soil respiration
           ! and soil moisture. Soil Biol. Biochem., 15(4):447-453.
 
-          !$acc parallel loop independent gang default(present) async(2)
           do j = 1,nlevdecomp
-             !$acc loop vector independent private(c,maxpsi,psi)
              do fc = 1,num_soilc
                 c = filter_soilc(fc)
                 maxpsi = sucsat(c,j) * (-9.8e-6_r8)
@@ -939,14 +945,14 @@ end subroutine init_decompcascade_cn
                 else
                    w_scalar(c,j) = 0._r8
                 end if
-                if (use_lch4 .and. anoxia_wtsat) then
-                   if ( t_soisno(c,j) > SHR_CONST_TKFRZ) then ! wet area will have w_scalar of 1 if unfrozen
+                if (use_lch4) then
+                   if (anoxia_wtsat .and. t_soisno(c,j) > SHR_CONST_TKFRZ) then ! wet area will have w_scalar of 1 if unfrozen
                       w_scalar(c,j) = w_scalar(c,j)*(1._r8 - finundated(c)) + finundated(c)
                    end if
                 end if
              end do
           end do
-          !$acc wait
+
        end if
 
        if (use_lch4) then
@@ -954,9 +960,7 @@ end subroutine init_decompcascade_cn
           ! Check for anoxia w/o LCH4 now done in controlMod.
 
           if (anoxia) then
-             !$acc parallel loop independent gang default(present) async(1)
              do j = 1,nlevdecomp
-                !$acc loop vector independent private(c)
                 do fc = 1,num_soilc
                    c = filter_soilc(fc)
 
@@ -969,116 +973,85 @@ end subroutine init_decompcascade_cn
                 end do
              end do
           else
-             !$acc parallel loop independent gang default(present) async(1)
-            do j = 1,nlevdecomp
-               !$acc loop vector independent private(c)
-               do fc = 1,num_soilc
-                  c = filter_soilc(fc)
-                  o_scalar(c,j) = 1._r8
-               end do
-            end do
-
+             o_scalar(bounds%begc:bounds%endc,1:nlevdecomp) = 1._r8
           end if
        else
-          !$acc parallel loop independent gang default(present) async(1)
-         do j = 1,nlevdecomp
-            !$acc loop vector independent private(c)
-            do fc = 1,num_soilc
-               c = filter_soilc(fc)
-               o_scalar(c,j) = 1._r8
-            end do
-         end do
+          o_scalar(bounds%begc:bounds%endc,1:nlevdecomp) = 1._r8
        end if
 
        if (use_vertsoilc) then
           ! add a term to reduce decomposition rate at depth
           ! for now used a fixed e-folding depth
-         !$acc parallel loop independent gang default(present) async(2)
-         do j = 1,nlevdecomp
-            !$acc loop vector independent
-            do fc = 1,num_soilc
-                depth_scalar(fc,j) = exp(-zsoi(j)/decomp_depth_efolding)
+          do j = 1, nlevdecomp
+             do fc = 1,num_soilc
+                c = filter_soilc(fc)
+                depth_scalar(c,j) = exp(-zsoi(j)/decomp_depth_efolding)
              end do
           end do
        end if
 
        !Calcluate location and depth-specific acceleration factors
-       if (year < 20 .and. spinup_state == 1) then
-          !$acc parallel loop independent gang default(present) async(3)
-          do j = 1,nlevdecomp
-             !$acc loop vector independent private(c)
-             do fc = 1,num_soilc
-                 c = filter_soilc(fc)
-                 cnstate_vars%scalaravg_col(c,j) = 0._r8
-             end do
-          end do
-       else if (year < 40 .and. spinup_state == 1) then
-          !$acc parallel loop independent gang default(present) async(3)
-          do j = 1,nlevdecomp
-             !$acc loop vector independent private(c)
-             do fc = 1,num_soilc
-                 c = filter_soilc(fc)
-                 cnstate_vars%scalaravg_col(c,j) = cnstate_vars%scalaravg_col(c,j) + &
-                     (t_scalar(c,4) * w_scalar(c,4) * o_scalar(c,4) * depth_scalar(fc,4) ) &
+       do fc=1,num_soilc
+           c = filter_soilc(fc)
+           if (year < 20 .and. spinup_state == 1) then
+               cnstate_vars%scalaravg_col(c,:) = 0._r8
+           else if (year < 40 .and. spinup_state == 1) then
+               cnstate_vars%scalaravg_col(c,:) = cnstate_vars%scalaravg_col(c,:) + &
+                     (t_scalar(c,4) * w_scalar(c,4) * o_scalar(c,4) * depth_scalar(c,4) ) &
                      * dt / (86400._r8 * 365._r8 * 20._r8)
-             end do
-          end do
-       else
-          !$acc parallel loop independent gang default(present) async(3)
-          do j = 1,nlevdecomp
-             !$acc loop vector independent private(c)
-             do fc = 1,num_soilc
-                 c = filter_soilc(fc)
-                 if (cnstate_vars%scalaravg_col(c,4) < 1.0e-3) then
-                    cnstate_vars%scalaravg_col(c,j) = 1.0_r8
-                 end if
-             end do
-          end do
-       end if
-
-      !$acc wait
+           else
+               if (cnstate_vars%scalaravg_col(c,4) < 1.0e-3) then
+                    cnstate_vars%scalaravg_col(c,:) = 1.0_r8
+               end if
+           end if
+       end do
 
        if (use_vertsoilc) then
-          !$acc parallel loop independent gang default(present)
           do j = 1,nlevdecomp
-             !$acc loop vector independent private(c)
              do fc = 1,num_soilc
                 c = filter_soilc(fc)
-                decomp_k(c,j,i_litr1) = k_l1 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(fc,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_litr2) = k_l2 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(fc,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_litr3) = k_l3 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(fc,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_soil1) = k_s1 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(fc,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_soil2) = k_s2 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(fc,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_soil3) = k_s3 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(fc,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_soil4) = k_s4 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(fc,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_cwd) = k_frag * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(fc,j) * o_scalar(c,j) / dtime_mod
+                decomp_k(c,j,i_litr1) = k_l1 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_litr2) = k_l2 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_litr3) = k_l3 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_soil1) = k_s1 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_soil2) = k_s2 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_soil3) = k_s3 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_soil4) = k_s4 * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(c,j) * o_scalar(c,j) / dt
+
 
              end do
           end do
+          do j = 1,nlevdecomp
+              do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                  decomp_k(c,j,i_cwd) = k_frag * t_scalar(c,j) * w_scalar(c,j) * depth_scalar(c,j) * o_scalar(c,j) / dt
+              end do
+          end do
        else
-          !$acc parallel loop independent gang default(present)
           do j = 1,nlevdecomp
-             !$acc loop vector independent private(c)
              do fc = 1,num_soilc
                 c = filter_soilc(fc)
-                decomp_k(c,j,i_litr1) = k_l1 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_litr2) = k_l2 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_litr3) = k_l3 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_soil1) = k_s1 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_soil2) = k_s2 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_soil3) = k_s3 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_cwd) = k_frag * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dtime_mod
-                decomp_k(c,j,i_soil4) = k_s4 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dtime_mod
+                decomp_k(c,j,i_litr1) = k_l1 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_litr2) = k_l2 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_litr3) = k_l3 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_soil1) = k_s1 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_soil2) = k_s2 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_soil3) = k_s3 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dt
+                decomp_k(c,j,i_soil4) = k_s4 * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dt
              end do
           end do
+          do j = 1,nlevdecomp
+              do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                  decomp_k(c,j,i_cwd) = k_frag * t_scalar(c,j) * w_scalar(c,j) * o_scalar(c,j) / dt
+              end do
+          end do
        end if
 
 
        if (spinup_state == 1 .and. year >= 40) then
          !adjust decomposition factors based on scalar factors from first 20 years of simulation
-         !$acc parallel loop independent gang default(present)
          do j=1,nlevdecomp
-           !$acc loop vector independent private(c)
            do fc = 1, num_soilc
              c = filter_soilc(fc)
              if ( decomp_cascade_con%spinup_factor(i_litr1) > 1._r8) decomp_k(c,j,i_litr1) = decomp_k(c,j,i_litr1)  &
@@ -1100,9 +1073,6 @@ end subroutine init_decompcascade_cn
            end do
          end do
        end if
-       !$acc exit data delete(froz_q10,Q10,minpsi, mino2lim, decomp_depth_efolding, &
-       !$acc   k_l1,k_l2,k_l3,k_s1,k_s2,k_s3,k_s4, k_frag,&
-       !$acc   i_litr1,i_litr2, i_litr3, i_soil1, i_soil2, i_soil3, i_soil4, depth_scalar(:,:) )
      end associate
    end subroutine decomp_rate_constants_cn
 
diff --git a/components/elm/src/biogeochem/DryDepVelocity.F90 b/components/elm/src/biogeochem/DryDepVelocity.F90
index 4df5b9ee16..f693f58165 100644
--- a/components/elm/src/biogeochem/DryDepVelocity.F90
+++ b/components/elm/src/biogeochem/DryDepVelocity.F90
@@ -49,12 +49,11 @@ Module DryDepVelocity
   use abortutils           , only : endrun
   use clm_time_manager     , only : get_nstep, get_curr_date, get_curr_time
   use spmdMod              , only : masterproc
-  use seq_drydep_mod       , only : DD_XLND
-  use seq_drydep_mod_elm       , only : n_drydep, drydep_list
-  use seq_drydep_mod_elm       , only : drydep_method
-  use seq_drydep_mod_elm       , only : index_o3=>o3_ndx, index_o3a=>o3a_ndx, index_so2=>so2_ndx, index_h2=>h2_ndx
-  use seq_drydep_mod_elm       , only : index_co=>co_ndx, index_ch4=>ch4_ndx, index_pan=>pan_ndx
-  use seq_drydep_mod_elm       , only : index_xpan=>xpan_ndx
+  use seq_drydep_mod       , only : n_drydep, drydep_list
+  use seq_drydep_mod       , only : drydep_method, DD_XLND
+  use seq_drydep_mod       , only : index_o3=>o3_ndx, index_o3a=>o3a_ndx, index_so2=>so2_ndx, index_h2=>h2_ndx
+  use seq_drydep_mod       , only : index_co=>co_ndx, index_ch4=>ch4_ndx, index_pan=>pan_ndx
+  use seq_drydep_mod       , only : index_xpan=>xpan_ndx
   use decompMod            , only : bounds_type
   use elm_varcon           , only : namep
   use atm2lndType          , only : atm2lnd_type
@@ -103,7 +102,7 @@ CONTAINS
     !
     ! !USES:
       use shr_infnan_mod , only : nan => shr_infnan_nan, assignment(=)
-    use seq_drydep_mod_elm , only : n_drydep, drydep_method
+    use seq_drydep_mod , only : n_drydep, drydep_method, DD_XLND
     use elm_varcon , only : spval
     !
     ! !ARGUMENTS:
@@ -134,8 +133,8 @@ CONTAINS
     ! !USES:
       !$acc routine seq
     use shr_const_mod  , only : tmelt => shr_const_tkfrz
-    use seq_drydep_mod_elm , only : seq_drydep_setHCoeff, mapping, drat, foxd
-    use seq_drydep_mod_elm , only : rcls, h2_a, h2_b, h2_c, ri, rac, rclo, rlu, rgss, rgso
+    use seq_drydep_mod , only : seq_drydep_setHCoeff, mapping, drat, foxd
+    use seq_drydep_mod , only : rcls, h2_a, h2_b, h2_c, ri, rac, rclo, rlu, rgss, rgso
     use landunit_varcon, only : istsoil, istice, istice_mec, istdlak, istwet
     use elm_varctl     , only : iulog
     use pftvarcon      , only : noveg, ndllf_evr_tmp_tree, ndllf_evr_brl_tree
@@ -209,13 +208,13 @@ CONTAINS
 
     ! jfl : mods for PAN
     real(r8)                  :: dv_pan
-    real(r8),parameter :: c0_pan(11) = (/ 0.000_r8, 0.006_r8, 0.002_r8, 0.009_r8, 0.015_r8, &
+    real(r8) :: c0_pan(11) = (/ 0.000_r8, 0.006_r8, 0.002_r8, 0.009_r8, 0.015_r8, &
                                 0.006_r8, 0.000_r8, 0.000_r8, 0.000_r8, 0.002_r8, 0.002_r8 /)
-    real(r8),parameter :: k_pan (11) = (/ 0.000_r8, 0.010_r8, 0.005_r8, 0.004_r8, 0.003_r8, &
+    real(r8) :: k_pan (11) = (/ 0.000_r8, 0.010_r8, 0.005_r8, 0.004_r8, 0.003_r8, &
                                 0.005_r8, 0.000_r8, 0.000_r8, 0.000_r8, 0.075_r8, 0.002_r8 /)
     !-----------------------------------------------------------------------
 
-    !if ( n_drydep == 0 .or. drydep_method /= DD_XLND ) return
+    if ( n_drydep == 0 .or. drydep_method /= DD_XLND ) return
 
     associate(                                                    &
          forc_solai =>    top_af%solai                          , & ! Input:  [real(r8) (:,:) ] direct beam radiation (W/m**2)
@@ -354,11 +353,9 @@ CONTAINS
                endif
             endif
 
-#ifndef _OPENACC
             if (index_season<0) then
                call endrun('ERROR: not able to determine season'//errmsg(__FILE__, __LINE__))
             endif
-#endif _OPENACC
 
             ! saturation specific humidity
             !
diff --git a/components/elm/src/biogeochem/EcosystemBalanceCheckMod.F90 b/components/elm/src/biogeochem/EcosystemBalanceCheckMod.F90
index 1fecf37a89..a2cdaf2eb0 100644
--- a/components/elm/src/biogeochem/EcosystemBalanceCheckMod.F90
+++ b/components/elm/src/biogeochem/EcosystemBalanceCheckMod.F90
@@ -6,7 +6,7 @@ module EcosystemBalanceCheckMod
   !
   ! !USES:
   use shr_kind_mod        , only : r8 => shr_kind_r8
-  use shr_infnan_mod      , only : nan => shr_infnan_nan!, assignment(=)
+  use shr_infnan_mod      , only : nan => shr_infnan_nan, assignment(=)
   use shr_log_mod         , only : errMsg => shr_log_errMsg
   use decompMod           , only : bounds_type
   use abortutils          , only : endrun
@@ -41,11 +41,10 @@ module EcosystemBalanceCheckMod
   use ColumnDataType      , only : column_phosphorus_state, column_phosphorus_flux
   use VegetationType      , only : veg_pp
   use VegetationDataType  , only : veg_cf, veg_nf, veg_pf
-   
+
   use timeinfoMod
-  use subgridAveMod , only : unity
+
   !
-  #define is_active_betr_bgc .false.  
   implicit none
   save
   private
@@ -177,14 +176,15 @@ contains
   end subroutine BeginColPBalance
 
   !-----------------------------------------------------------------------
-  subroutine ColCBalanceCheck(  &
+  subroutine ColCBalanceCheck(bounds, &
        num_soilc, filter_soilc, &
        col_cs, col_cf)
     !
     ! !DESCRIPTION:
     ! On the radiation time step, perform carbon mass conservation check for column and pft
-    !$acc routine seq 
+    !
     ! !ARGUMENTS:
+    type(bounds_type)         , intent(in)    :: bounds
     integer                   , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                   , intent(in)    :: filter_soilc(:) ! filter for soil columns
     type(column_carbon_state) , intent(inout) :: col_cs
@@ -219,10 +219,10 @@ contains
          litfall                   =>    col_cf%litfall )                     ! Input: carbon flux from litterfall (particularly fates) ( gc/m2/s)
 
 
-      ! set time stepsi
+      ! set time steps
+      dt = real( get_step_size(), r8 )
+      nstep = get_nstep()
 
-      dt = dtime_mod 
-      nstep = nstep_mod 
       err_found = .false.
       ! column loop
       do fc = 1,num_soilc
@@ -293,13 +293,12 @@ contains
             write(iulog,*)'Latdeg,Londeg         = ',grc_pp%latdeg(col_pp%gridcell(c)),grc_pp%londeg(col_pp%gridcell(c))
             write(iulog,*)'input                 = ',col_cinputs(c)*dt
             write(iulog,*)'output                = ',col_coutputs(c)*dt
-            write(iulog,*)'er                    = ',er(c)*dt
-            write(iulog,*)'hr                    = ',col_cf%hr(c)*dt
+            write(iulog,*)'er                    = ',er(c)*dt,col_cf%hr(c)*dt
             write(iulog,*)'fire                  = ',col_fire_closs(c)*dt
             write(iulog,*)'hrv_to_atm            = ',col_hrv_xsmrpool_to_atm(c)*dt
             write(iulog,*)'leach                 = ',som_c_leached(c)*dt
             write(iulog,*)'begcb                 = ',col_begcb(c)
-            write(iulog,*)'endcb                 = ',col_endcb(c)
+            write(iulog,*)'endcb                 = ',col_endcb(c),col_cs%totsomc(c)
             write(iulog,*)'totsomc               = ',col_cs%totsomc(c)
             write(iulog,*)'delta store           = ',col_endcb(c)-col_begcb(c)
 
@@ -341,7 +340,8 @@ contains
     ! !DESCRIPTION:
     ! On the radiation time step, perform nitrogen mass conservation check
     ! for column and pft
-    !$acc routine seq 
+    !
+    use tracer_varcon,  only : is_active_betr_bgc
     ! !ARGUMENTS:
     type(bounds_type)         , intent(in)    :: bounds
     integer                   , intent(in)    :: num_soilc       ! number of soil columns in filter
@@ -556,7 +556,7 @@ contains
     ! !DESCRIPTION:
     ! On the radiation time step, perform phosphorus mass conservation check
     ! for column and pft
-    !$acc routine seq 
+    !
     ! !ARGUMENTS:
     type(bounds_type)         , intent(in)    :: bounds
     integer                   , intent(in)    :: num_soilc       ! number of soil columns in filter
@@ -776,7 +776,7 @@ contains
     ! !DESCRIPTION:
     ! Calculate the beginning carbon balance for mass conservation checks
     ! at grid cell level
-    !$acc routine seq 
+    !
     ! !ARGUMENTS:
     type(bounds_type)          , intent(in)  :: bounds
     type(column_carbon_state)  , intent(in)  :: col_cs
@@ -804,31 +804,31 @@ contains
          )
 
       call c2g(bounds, totcolc(bounds%begc:bounds%endc), begcb_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type = unity, l2g_scale_type = unity)
+           c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
       call c2g(bounds, totcolc(bounds%begc:bounds%endc), beg_totc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
       call c2g(bounds, totpftc(bounds%begc:bounds%endc), beg_totpftc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
       call c2g(bounds, cwdc(bounds%begc:bounds%endc), beg_cwdc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
       call c2g(bounds, totlitc(bounds%begc:bounds%endc), beg_totlitc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
       call c2g(bounds, totsomc(bounds%begc:bounds%endc), beg_totsomc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
       call c2g(bounds, totprodc(bounds%begc:bounds%endc), beg_totprodc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
       call c2g(bounds, ctrunc(bounds%begc:bounds%endc), beg_ctrunc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
       call c2g(bounds, cropseedc_deficit(bounds%begc:bounds%endc), beg_cropseedc_deficit(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
     end associate
 
@@ -840,7 +840,7 @@ contains
     ! !DESCRIPTION:
     ! Calculate the beginning carbon balance for mass conservation checks
     ! at grid cell level
-    !$acc routine seq 
+    !
     use GridcellDataType, only : gridcell_carbon_flux
     use ColumnDataType  , only : column_carbon_flux
     !
@@ -904,44 +904,44 @@ contains
 
       ! c2g states
       call c2g(bounds, col_totc(bounds%begc:bounds%endc), end_totc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_totpftc(bounds%begc:bounds%endc), end_totpftc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_cwdc(bounds%begc:bounds%endc), end_cwdc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_totlitc(bounds%begc:bounds%endc), end_totlitc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_totsomc(bounds%begc:bounds%endc), end_totsomc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_totprodc(bounds%begc:bounds%endc), end_totprodc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_ctrunc(bounds%begc:bounds%endc), end_ctrunc(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_cropseedc_deficit(bounds%begc:bounds%endc), end_cropseedc_deficit(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
       ! c2g fluxes
       call c2g(bounds, col_gpp(bounds%begc:bounds%endc), grc_gpp(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_er(bounds%begc:bounds%endc), grc_er(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_fire_closs(bounds%begc:bounds%endc), grc_fire_closs(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_prod1c_loss(bounds%begc:bounds%endc), grc_prod1c_loss(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_prod10c_loss(bounds%begc:bounds%endc), grc_prod10c_loss(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_prod100c_loss(bounds%begc:bounds%endc), grc_prod100c_loss(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_hrv_xsmrpool_to_atm(bounds%begc:bounds%endc), grc_hrv_xsmrpool_to_atm(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_som_c_leached(bounds%begc:bounds%endc), grc_som_c_leached(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
       call c2g(bounds, col_som_c_yield(bounds%begc:bounds%endc), grc_som_c_yield(bounds%begg:bounds%endg), &
-               c2l_scale_type = unity, l2g_scale_type = unity)
+               c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
-      dt = dtime_mod !real( get_step_size(), r8 )
-      nstep =  nstep_mod !get_nstep()
+      dt = real( get_step_size(), r8 )
+      nstep = get_nstep()
 
       do g = bounds%begg, bounds%endg
          grc_cinputs(g) = grc_gpp(g) + grc_dwt_seedc_to_leaf(g) + grc_dwt_seedc_to_deadstem(g)
@@ -955,7 +955,7 @@ contains
          end if
 
          grc_errcb(g) = (grc_cinputs(g) - grc_coutputs(g))*dt - (end_totc(g) - beg_totc(g))
-#ifndef _OPENACC
+
          if (grc_errcb(g) > error_tol .and. nstep > 1) then
             write(iulog,*)'grid cbalance error = ', grc_errcb(g), g
             write(iulog,*)'Latdeg,Londeg       = ', grc_pp%latdeg(g), grc_pp%londeg(g)
@@ -976,7 +976,6 @@ contains
 
             call endrun(msg=errMsg(__FILE__, __LINE__))
          end if
-#endif 
       end do
 
     end associate
@@ -989,7 +988,7 @@ contains
     ! !DESCRIPTION:
     ! Calculate the beginning nitrogen balance for mass conservation checks
     ! at grid cell level
-    !$acc routine seq 
+    !
     ! !ARGUMENTS:
     type(bounds_type)             , intent(in)    :: bounds
     type(column_nitrogen_state)   , intent(in)    :: col_ns
@@ -1002,7 +1001,7 @@ contains
          )
 
       call c2g(bounds, totcoln(bounds%begc:bounds%endc), begnb_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type=unity, l2g_scale_type=unity)
+           c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
     end associate
 
@@ -1014,7 +1013,7 @@ contains
     ! !DESCRIPTION:
     ! Calculate the beginning phosphorus balance for mass conservation checks
     ! at grid cell level
-    !$acc routine seq 
+    !
     ! !ARGUMENTS:
     type(bounds_type)               , intent(in)    :: bounds
     type(column_phosphorus_state)   , intent(in)    :: col_ps
@@ -1028,7 +1027,7 @@ contains
          )
 
       call c2g(bounds, totcolp(bounds%begc:bounds%endc), begpb_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type=unity, l2g_scale_type=unity)
+           c2l_scale_type = 'unity', l2g_scale_type = 'unity')
 
 
     end associate
@@ -1038,7 +1037,7 @@ contains
   !-----------------------------------------------------------------------
   subroutine EndGridCBalanceAfterDynSubgridDriver(bounds, &
        num_soilc, filter_soilc, col_cs, grc_cs, grc_cf)
-    !$acc routine seq 
+    !
     ! !DESCRIPTION:
     ! On the radiation time step, perform carbon mass conservation check
     ! at grid level after dynamic subgrid driver has been called
@@ -1124,7 +1123,6 @@ contains
   subroutine EndGridNBalanceAfterDynSubgridDriver(bounds, &
        num_soilc, filter_soilc, col_ns, grc_ns, grc_nf)
     !
-    !$acc routine seq 
     ! !DESCRIPTION:
     ! On the radiation time step, perform nitrogen mass conservation check
     ! at grid level after dynamic subgrid driver has been called
@@ -1216,7 +1214,6 @@ contains
   subroutine EndGridPBalanceAfterDynSubgridDriver(bounds, &
        num_soilc, filter_soilc, col_ps, grc_ps, grc_pf)
     !
-    !$acc routine seq 
     ! !DESCRIPTION:
     ! On the radiation time step, perform phosphorus mass conservation check
     ! at grid level after dynamic subgrid driver has been called
diff --git a/components/elm/src/biogeochem/EcosystemDynMod.F90 b/components/elm/src/biogeochem/EcosystemDynMod.F90
index e4d688340f..0251a2fb7e 100644
--- a/components/elm/src/biogeochem/EcosystemDynMod.F90
+++ b/components/elm/src/biogeochem/EcosystemDynMod.F90
@@ -28,7 +28,7 @@ module EcosystemDynMod
   use ColumnDataType      , only : col_cs, c13_col_cs, c14_col_cs
   use ColumnDataType      , only : col_cf, c13_col_cf, c14_col_cf
   use ColumnDataType      , only : col_ns, col_nf
-  use ColumnDataType      , only : col_ps, col_pf, col_ws
+  use ColumnDataType      , only : col_ps, col_pf
   use VegetationDataType  , only : veg_cs, c13_veg_cs, c14_veg_cs
   use VegetationDataType  , only : veg_cf, c13_veg_cf, c14_veg_cf
   use VegetationDataType  , only : veg_ns, veg_nf
@@ -52,11 +52,8 @@ module EcosystemDynMod
   use ColumnDataType , only : col_cf_summary, col_nf_summary, col_pf_Summary
   use ColumnDataType , only : col_cs_summary, col_ns_summary, col_ps_summary
   use ColumnDataType , only : col_cf_summary_for_ch4
-  use ColumnDataType , only : col_cf_setvalues, col_nf_setvalues, col_pf_setvalues
+  use ColumnDataType , only : col_cf_setvalues, col_nf_setvalues, col_pf_setvalues 
 
-  use VegetationSummaryRoutinesMod
-  use ColumnWorkRoutinesMod
-  use filterMod , only : clumpfilter
 
   !
   ! !PUBLIC TYPES:
@@ -93,7 +90,7 @@ contains
     type(hlm_fates_interface_type), intent(in) :: elm_fates
     !-----------------------------------------------------------------------
 
-    call AllocationInit (bounds )
+    call AllocationInit (bounds, elm_fates)
 
     if(use_fates) return
 
@@ -110,654 +107,767 @@ contains
 
   end subroutine EcosystemDynInit
 
+
   !-----------------------------------------------------------------------
-  subroutine EcosystemDynLeaching( num_soilc, filter_soilc, &
-       num_soilp, filter_soilp, &
-       cnstate_vars )
+
+  subroutine EcosystemDynLeaching(bounds, num_soilc, filter_soilc, &
+       num_soilp, filter_soilp, num_pcropp, filter_pcropp, doalb, &
+       cnstate_vars,  &
+       frictionvel_vars, canopystate_vars )
     !
     ! !DESCRIPTION:
     ! The core CN code is executed here. Calculates fluxes for maintenance
     ! respiration, decomposition, allocation, phenology, and growth respiration.
     ! These routines happen on the radiation time step so that canopy structure
     ! stays synchronized with albedo calculations.
+    !
     ! !USES:
-    use PhosphorusDynamicsMod     , only: PhosphorusMinFluxes
-    use PhosphorusDynamicsMod     , only: PhosphorusBiochemMin,PhosphorusLeaching
+    use spmdMod              , only: masterproc
+    use PhosphorusDynamicsMod         , only: PhosphorusWeathering,PhosphorusAdsportion,PhosphorusDesoprtion,PhosphorusOcclusion
+    use PhosphorusDynamicsMod         , only: PhosphorusBiochemMin,PhosphorusLeaching
     use NitrogenDynamicsMod       , only: NitrogenLeaching
     use NitrogenStateUpdate3Mod   , only: NitrogenStateUpdate3
-    use PhosphorusStateUpdate3Mod , only: PhosphorusStateUpdate3
-    use PrecisionControlMod       , only: PrecisionControl
-    use PhosphorusDynamicsMod     , only: PhosphorusBiochemMin_balance
-    use elm_varctl , only : iulog 
+    use PhosphorusStateUpdate3Mod     , only: PhosphorusStateUpdate3
+    use PrecisionControlMod  , only: PrecisionControl
+    use perf_mod             , only: t_startf, t_stopf
+    use shr_sys_mod          , only: shr_sys_flush
+    use PhosphorusDynamicsMod         , only: PhosphorusBiochemMin_balance
 
     !
     ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc         ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:)   ! filter for soil columns
     integer                  , intent(in)    :: num_soilp         ! number of soil patches in filter
     integer                  , intent(in)    :: filter_soilp(:)   ! filter for soil patches
+    integer                  , intent(in)    :: num_pcropp        ! number of prog. crop patches in filter
+    integer                  , intent(in)    :: filter_pcropp(:)  ! filter for prognostic crop patches
+    logical                  , intent(in)    :: doalb             ! true = surface albedo calculation time step
     type(cnstate_type)       , intent(inout) :: cnstate_vars
+    type(frictionvel_type)   , intent(in)    :: frictionvel_vars
+    type(canopystate_type)   , intent(inout) :: canopystate_vars
 
     character(len=64) :: event
-    character(len=4) :: isotope
-
-    real :: startt, stopt 
-    integer :: nlevbed,c,fc,j,p,fp
+    real(r8) :: dt
     !-----------------------------------------------------------------------
-    call PhosphorusMinFluxes(num_soilc, filter_soilc, cnstate_vars, dtime_mod)
+    dt = dtime_mod;
+
+    ! only do if ed is off
+    event = 'PhosphorusWeathering'
+    call t_start_lnd(event)
+    call PhosphorusWeathering(num_soilc, filter_soilc, &
+         cnstate_vars, dt)
+    call t_stop_lnd(event)
+
+    event = 'PhosphorusAdsportion'
+    call t_start_lnd(event)
+    call PhosphorusAdsportion(num_soilc, filter_soilc, &
+         cnstate_vars, dt)
+    call t_stop_lnd(event)
+
+    event = 'PhosphorusDesoprtion'
+    call t_start_lnd(event)
+    call PhosphorusDesoprtion(num_soilc, filter_soilc, &
+         cnstate_vars, dt)
+    call t_stop_lnd(event)
+
+    event = 'PhosphorusOcclusion'
+    call t_start_lnd(event)
+    call PhosphorusOcclusion(num_soilc, filter_soilc, &
+         cnstate_vars, dt)
+    call t_stop_lnd(event)
+
     if (.not. nu_com_phosphatase) then
       event = 'PhosphorusBiochemMin'
        call t_start_lnd(event)
-       call PhosphorusBiochemMin(num_soilc, filter_soilc, &
-            cnstate_vars, dtime_mod)
+       call PhosphorusBiochemMin(bounds,num_soilc, filter_soilc, &
+            cnstate_vars, dt)
        call t_stop_lnd(event)
+    else
+      ! nu_com_phosphatase is true
+      !call t_startf('PhosphorusBiochemMin')
+      !call PhosphorusBiochemMin_balance(bounds,num_soilc, filter_soilc, &
+      !     cnstate_vars,nitrogenstate_vars,phosphorusstate_vars,phosphorusflux_vars)
+      !call t_stopf('PhosphorusBiochemMin')
     end if
+
     !-----------------------------------------------------------------------
-    ! pflotran: when both 'pf-bgc' and 'pf-h' on, no need to call ELM-CN's N leaching module
+    ! pflotran: when both 'pf-bgc' and 'pf-h' on, no need to call CLM-CN's N leaching module
     if (.not. (pf_cmode .and. pf_hmode)) then
+     call NitrogenLeaching(bounds, num_soilc, filter_soilc, dt)
 
+     call PhosphorusLeaching(bounds, num_soilc, filter_soilc, dt)
+    end if !(.not. (pf_cmode .and. pf_hmode))
+       !-----------------------------------------------------------------------
 
-     call NitrogenLeaching(num_soilc, filter_soilc, dtime_mod)
-
-     call PhosphorusLeaching(num_soilc, filter_soilc, dtime_mod)
+    event = 'CNUpdate3'
+    call t_start_lnd(event)
+    call NitrogenStateUpdate3(num_soilc, filter_soilc, num_soilp, filter_soilp,dt)
+    call t_stop_lnd(event)
 
-    end if !(.not. (pf_cmode .and. pf_hmode))
-      !-----------------------------------------------------------------------
-   event = 'CNUpdate3'
-   call t_start_lnd(event)
-   call NitrogenStateUpdate3(num_soilc, filter_soilc, num_soilp, filter_soilp,dtime_mod)
-   call t_stop_lnd(event)
+    event = 'PUpdate3'
+    call t_start_lnd(event)
+    call PhosphorusStateUpdate3(bounds,num_soilc, filter_soilc, num_soilp, filter_soilp, &
+        cnstate_vars, dt)
+    call t_stop_lnd(event)
 
-   event = 'PUpdate3'
-   call t_start_lnd(event)
-   call PhosphorusStateUpdate3(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-       cnstate_vars, dtime_mod)
-   call t_stop_lnd(event)
+    event = 'CNPsum'
+    call t_start_lnd(event)
+    call PrecisionControl(num_soilc, filter_soilc, num_soilp, filter_soilp  )
 
-   event = 'CNPsum'
-   call t_start_lnd(event)
-   call PrecisionControl(num_soilc, filter_soilc, num_soilp, filter_soilp) 
+    call col_cf_summary_for_ch4(col_cf,bounds, num_soilc, filter_soilc)
 
     ! Only update the veg_ data structures if we are using cn
     if(.not.use_fates) then
-      call veg_cf_summary_for_ch4_acc(veg_cf,num_soilp, filter_soilp)
-      call veg_cf_summary_acc(veg_cf, num_soilp,filter_soilp, 2)
-      call veg_nf_summary_acc(veg_nf, num_soilp,filter_soilp )
-      call veg_pf_summary_acc(veg_pf,num_soilp,filter_soilp )
-
-     call summary_veg_flux_p2c(num_soilc, filter_soilc, veg_cf, col_cf,&
-                    veg_pf,col_pf, veg_nf, col_nf)
-
-      call veg_cs_summary_acc(veg_cs, num_soilp, filter_soilp)
-      call veg_ns_summary_acc(veg_ns, num_soilp, filter_soilp)
-      call veg_ps_summary_acc(veg_ps, num_soilp, filter_soilp)
-      call summary_veg_state_p2c (num_soilc, filter_soilc,veg_cs, col_cs, &
-            veg_ps,col_ps, veg_ns, col_ns)
+       call veg_cf_summary_for_ch4(veg_cf,bounds, num_soilp, filter_soilp)
+       call veg_cf_Summary(veg_cf,bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, 'bulk', col_cf)
+       if ( use_c13 ) then
+          call veg_cf_Summary(veg_cf,bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, 'c13', c13_col_cf)
+          call col_cf_Summary(col_cf,bounds, num_soilc, filter_soilc, 'c13')
+       end if
+       if ( use_c14 ) then
+          call veg_cf_Summary(veg_cf,bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, 'c14', c14_col_cf)
+          call col_cf_Summary(col_cf,bounds, num_soilc, filter_soilc, 'c14')
+       end if
+       call veg_cs_Summary(veg_cs,bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_cs)
+       if ( use_c13 ) then
+          call veg_cs_Summary(c13_veg_cs,bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, c13_col_cs)
+          call col_cs_Summary(c13_col_cs,bounds, num_soilc, filter_soilc)
+       end if
+       if ( use_c14 ) then
+          call veg_cs_Summary(c14_veg_cs,bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, c14_col_cs)
+          call col_cs_Summary(c14_col_cs,bounds, num_soilc, filter_soilc)
+       end if
+       call veg_nf_Summary(veg_nf, bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_nf)
+       call veg_ns_Summary(veg_ns, bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_ns)
+       call veg_pf_Summary(veg_pf, bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_pf)
+       call veg_ps_Summary(veg_ps, bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_ps)
+    else
+       ! In this scenario, we simply zero all of the
+       ! column level variables that would had been upscaled
+       ! in the veg summary with p2c
+       call col_cs%ZeroForFates(bounds,num_soilc, filter_soilc)
+       call col_ns%ZeroForFates(bounds,num_soilc, filter_soilc)
+       call col_ps%ZeroForFates(bounds,num_soilc, filter_soilc)
+       call col_cf%ZeroForFates(bounds,num_soilc, filter_soilc)
+       call col_nf%ZeroForFates(bounds,num_soilc, filter_soilc)
+       call col_pf%ZeroForFates(bounds,num_soilc, filter_soilc)
     end if
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    call col_cf_summary_for_ch4_acc(col_cf, num_soilc, filter_soilc)
-    isotope = 'bulk'
-    call col_cf_summary_acc(col_cf, num_soilc, filter_soilc, isotope)
-    call col_cs_summary_acc(col_cs, num_soilc, filter_soilc)
+
+    call col_cf_Summary(col_cf,bounds, num_soilc, filter_soilc, 'bulk')
+    call col_cs_Summary(col_cs,bounds, num_soilc, filter_soilc)
+
+    call col_nf_Summary(col_nf,bounds, num_soilc, filter_soilc)
+    call col_ns_Summary(col_ns,bounds, num_soilc, filter_soilc)
+
+    call col_pf_Summary(col_pf,bounds, num_soilc, filter_soilc)
+    call col_ps_Summary(col_ps,bounds, num_soilc, filter_soilc)
+
+    call t_stop_lnd(event)
+
+  end subroutine EcosystemDynLeaching
+
+
+!-------------------------------------------------------------------------------------------------
+  subroutine EcosystemDynNoLeaching1(bounds,                          &
+       num_soilc, filter_soilc,                                         &
+       num_soilp, filter_soilp,                                         &
+       cnstate_vars,  atm2lnd_vars,           &
+       canopystate_vars, soilstate_vars, crop_vars,   &
+       ch4_vars, photosyns_vars     )
+    !-------------------------------------------------------------------
+    ! bgc interface
+    ! Phase-1 of EcosystemDynNoLeaching
+    ! call Allocation1_PlantNPDemand before soil_bgc
+    !-------------------------------------------------------------------
+
+    ! !DESCRIPTION:
+    ! The core CN code is executed here. Calculates fluxes for maintenance
+    ! respiration, decomposition, allocation, phenology, and growth respiration.
+    ! These routines happen on the radiation time step so that canopy structure
+    ! stays synchronized with albedo calculations.
     !
-    call col_nf_summary_acc(col_nf, num_soilc, filter_soilc)
-    call col_ns_summary_acc(col_ns, num_soilc, filter_soilc)
+    ! !USES:
+    use NitrogenDynamicsMod         , only: NitrogenDeposition,NitrogenFixation, NitrogenFert, CNSoyfix
+    use PhosphorusDynamicsMod       , only: PhosphorusDeposition
+    use MaintenanceRespMod          , only: MaintenanceResp
+    use DecompCascadeBGCMod   , only: decomp_rate_constants_bgc
+    use DecompCascadeCNMod    , only: decomp_rate_constants_cn
+    use CropType              , only: crop_type
+    use elm_varpar            , only: crop_prog
+    use AllocationMod         , only: Allocation1_PlantNPDemand ! Phase-1 of CNAllocation
+    use NitrogenDynamicsMod   , only: NitrogenLeaching
+    use PhosphorusDynamicsMod       , only: PhosphorusLeaching
+    use NitrogenDynamicsMod         , only: NitrogenFixation_balance
+    use PhosphorusDynamicsMod       , only: PhosphorusWeathering,PhosphorusAdsportion,PhosphorusDesoprtion,PhosphorusOcclusion
+    use PhosphorusDynamicsMod       , only: PhosphorusBiochemMin,PhosphorusBiochemMin_balance
+
     !
-    call col_pf_summary_acc(col_pf, num_soilc, filter_soilc)
-    call col_ps_summary_acc(col_ps, num_soilc, filter_soilc)
+    ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
+    integer                  , intent(in)    :: num_soilc         ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:)   ! filter for soil columns
+    integer                  , intent(in)    :: num_soilp         ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:)   ! filter for soil patches
+    type(cnstate_type)       , intent(inout) :: cnstate_vars
+    type(atm2lnd_type)       , intent(in)    :: atm2lnd_vars
+    type(canopystate_type)   , intent(in)    :: canopystate_vars
+    type(soilstate_type)     , intent(inout) :: soilstate_vars
+    type(crop_type)          , intent(in)    :: crop_vars
+    type(ch4_type)           , intent(in)    :: ch4_vars
+    type(photosyns_type)     , intent(in)    :: photosyns_vars
+
+    character(len=64) :: event
+    real(r8) :: dt, dayspyr
+    integer  :: year, mon, day, sec
+    !-----------------------------------------------------------------------
+    dt = dtime_mod;
+    year = year_curr; mon = mon_curr; day = day_curr; sec= secs_curr
+    dayspyr = dayspyr_mod
+    !-----------------------------------------------------------------------
+
+    ! Call the main CN routines
+
+    ! --------------------------------------------------
+    ! zero the C and N fluxes
+    ! --------------------------------------------------
+
+    event = 'CNZero'
+    call t_start_lnd(event)
+
+    if(.not.use_fates) then
+       call veg_cf_SetValues(veg_cf, num_soilp, filter_soilp, 0._r8)
+       if ( use_c13 ) then
+          call veg_cf_setvalues(c13_veg_cf,num_soilp, filter_soilp, 0._r8)
+          call col_cf_SetValues(c13_col_cf,num_soilc, filter_soilc, 0._r8)
+       end if
+       if ( use_c14 ) then
+          call veg_cf_setvalues(c14_veg_cf,num_soilp, filter_soilp, 0._r8)
+          call col_cf_SetValues(c14_col_cf,num_soilc, filter_soilc, 0._r8)
+       end if
+       call veg_nf_setvalues (veg_nf,num_soilp, filter_soilp, 0._r8)
+       call veg_pf_SetValues (veg_pf,num_soilp, filter_soilp, 0._r8)
+    end if
+
+    call col_cf_SetValues(col_cf,num_soilc, filter_soilc, 0._r8)
+    call col_nf_SetValues(col_nf,num_soilc, filter_soilc, 0._r8)
+    call col_pf_SetValues(col_pf,num_soilc, filter_soilc, 0._r8)
 
     call t_stop_lnd(event)
 
-  end subroutine EcosystemDynLeaching
+    ! --------------------------------------------------
+    ! Nitrogen Deposition, Fixation and Respiration, phosphorus dynamics
+    ! --------------------------------------------------
+
+    event = 'CNDeposition'
+    call t_start_lnd(event)
+    call NitrogenDeposition(bounds, &
+         atm2lnd_vars, dt )
+    call t_stop_lnd(event)
+
+    event = 'CNFixation'
+    if ( (.not. nu_com_nfix) .or. use_fates) then
+      call t_start_lnd(event)
+       call NitrogenFixation( num_soilc, filter_soilc, dayspyr)
+       call t_stop_lnd(event)
+    else
+       ! nu_com_nfix is true
+       call t_start_lnd(event)
+       call NitrogenFixation_balance( num_soilc, filter_soilc, cnstate_vars )
+       call t_stop_lnd(event)
+    end if
 
+   if(.not.use_fates)then
 
+       event = 'MaintenanceResp'
+       call t_start_lnd(event)
+       if (crop_prog) then
+          call NitrogenFert(bounds, num_soilc,filter_soilc )
+
+          call CNSoyfix(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+                         crop_vars, cnstate_vars )
+       end if
+       ! This is auto-trophic respiration, thus don't call this for FATES
+       call MaintenanceResp(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            canopystate_vars, soilstate_vars,  photosyns_vars )
+       call t_stop_lnd(event)
 
-!-------------------------------------------------------------------------------------------------
- ! subroutine EcosystemDynNoLeaching1(bounds,                          &
- !      num_soilc, filter_soilc,                                         &
- !      num_soilp, filter_soilp,                                         &
- !      cnstate_vars,  atm2lnd_vars,           &
- !      canopystate_vars, soilstate_vars, crop_vars,   &
- !      ch4_vars, photosyns_vars     )
- !   !-------------------------------------------------------------------
- !   ! bgc interface
- !   ! Phase-1 of EcosystemDynNoLeaching
- !   ! call Allocation1_PlantNPDemand before soil_bgc
- !   !-------------------------------------------------------------------
-
- !   ! !DESCRIPTION:
- !   ! The core CN code is executed here. Calculates fluxes for maintenance
- !   ! respiration, decomposition, allocation, phenology, and growth respiration.
- !   ! These routines happen on the radiation time step so that canopy structure
- !   ! stays synchronized with albedo calculations.
- !   ! !USES:
- !   use NitrogenDynamicsMod   , only: NitrogenDeposition,NitrogenFixation, NitrogenFert, CNSoyfix
- !   use PhosphorusDynamicsMod , only: PhosphorusDeposition
- !   use MaintenanceRespMod    , only: MaintenanceResp
- !   use DecompCascadeBGCMod   , only: decomp_rate_constants_bgc
- !   use DecompCascadeCNMod    , only: decomp_rate_constants_cn
- !   use CropType              , only: crop_type
- !   use elm_varpar            , only: crop_prog
- !   use AllocationMod         , only: Allocation1_PlantNPDemand ! Phase-1 of CNAllocation
- !   use NitrogenDynamicsMod   , only: NitrogenFixation_balance
- !   use PhosphorusDynamicsMod , only: PhosphorusBiochemMin,PhosphorusBiochemMin_balance
- !   !
- !   ! !ARGUMENTS:
- !   type(bounds_type)     , intent(in)    :: bounds
- !   integer               , intent(in)    :: num_soilc         ! number of soil columns in filter
- !   integer               , intent(in)    :: filter_soilc(:)   ! filter for soil columns
- !   integer               , intent(in)    :: num_soilp         ! number of soil patches in filter
- !   integer               , intent(in)    :: filter_soilp(:)   ! filter for soil patches
- !   type(cnstate_type)    , intent(inout) :: cnstate_vars
- !   type(atm2lnd_type)    , intent(in)    :: atm2lnd_vars
- !   type(canopystate_type), intent(in)    :: canopystate_vars
- !   type(soilstate_type)  , intent(inout) :: soilstate_vars
- !   type(crop_type)       , intent(in)    :: crop_vars
- !   type(ch4_type)        , intent(in)    :: ch4_vars
- !   type(photosyns_type)  , intent(in)    :: photosyns_vars
-
- !   character(len=64) :: event
- !   real(r8) :: dt, dayspyr
- !   integer  :: year, mon, day, sec,c, fc, j
- !   !-----------------------------------------------------------------------
- !   dt = dtime_mod;
- !   year = year_curr; mon = mon_curr; day = day_curr; sec= secs_curr
- !   dayspyr = dayspyr_mod
- !   !-----------------------------------------------------------------------
- !   ! Call the main CN routines
- !   ! --------------------------------------------------
- !   ! zero the C and N fluxes
- !   ! --------------------------------------------------
- !   event = 'CNZero'
- !   call t_start_lnd(event)
-
- !   if(.not.use_fates) then
- !     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
- !      call veg_cf_SetValues(veg_cf, num_soilp, filter_soilp, 0._r8)
- !      if ( use_c13 ) then
- !         call veg_cf_setvalues(c13_veg_cf,num_soilp, filter_soilp, 0._r8)
- !         call col_cf_SetValues(c13_col_cf,num_soilc, filter_soilc, 0._r8)
- !      end if
- !      if ( use_c14 ) then
- !         call veg_cf_setvalues(c14_veg_cf,num_soilp, filter_soilp, 0._r8)
- !         call col_cf_SetValues(c14_col_cf,num_soilc, filter_soilc, 0._r8)
- !      end if
- !      call veg_nf_setvalues(veg_nf,num_soilp, filter_soilp, 0._r8)
- !      call veg_pf_SetValues(veg_pf,num_soilp, filter_soilp, 0._r8)
- !      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
- !   end if
-
- !   call col_cf_SetValues(col_cf,num_soilc, filter_soilc, 0._r8)
- !   call col_nf_SetValues(col_nf,num_soilc, filter_soilc, 0._r8)
- !   call col_pf_SetValues(col_pf,num_soilc, filter_soilc, 0._r8)
-
- !   call t_stop_lnd(event)
-
- !   ! --------------------------------------------------
- !   ! Nitrogen Deposition, Fixation and Respiration, phosphorus dynamics
- !   ! --------------------------------------------------
-
- !   event = 'CNDeposition'
- !   call t_start_lnd(event)
- !   call NitrogenDeposition(num_soilc, filter_soilc, &
- !        atm2lnd_vars, dtime_mod )
- !   call t_stop_lnd(event)
-
- !   event = 'CNFixation'
- !   if ( (.not. nu_com_nfix) .or. use_fates) then
- !     call t_start_lnd(event)
- !      call NitrogenFixation( num_soilc, filter_soilc, dayspyr)
- !      call t_stop_lnd(event)
- !   else
- !      ! nu_com_nfix is true
- !      call t_start_lnd(event)
- !      call NitrogenFixation_balance( num_soilc, filter_soilc, cnstate_vars )
- !      call t_stop_lnd(event)
- !   end if
-
- !  if(.not.use_fates)then
-
- !      event = 'MaintenanceResp'
- !      call t_start_lnd(event)
- !      if (crop_prog) then
- !         call NitrogenFert( num_soilc,filter_soilc )
-
- !         call CNSoyfix( num_soilc, filter_soilc, num_soilp, filter_soilp, &
- !                        crop_vars, cnstate_vars )
- !      end if
- !      ! This is auto-trophic respiration, thus don't call this for FATES
- !      call MaintenanceResp(num_soilc, filter_soilc, num_soilp, filter_soilp, &
- !           canopystate_vars, soilstate_vars,  photosyns_vars )
- !      call t_stop_lnd(event)
-
- !   end if
-
-
- !   if ( nu_com .ne. 'RD') then
- !      ! for P competition purpose, calculate P fluxes that will potentially increase solution P pool
- !      ! then competitors take up solution P
- !     #ifdef OPENACC 
- !     call endrun("only nu_com == RD is support for OpenACC runs")
- !     #endif 
- !      event ='PhosphorusWeathering'
- !      call t_start_lnd(event)
- !     !  do j = 1, nlevdecomp
- !     !    do fc = 1, num_soilc 
- !     !       c = filter_soilc(fc) 
- !     !       call PhosphorusWeathering(c,fc,j, cnstate_vars%isoilorder(c), dtime_mod)
- !     !    end do
- !     ! end do         
- !     call t_stop_lnd(event)
-
- !      event = 'PhosphorusBiochemMin'
- !      if (.not. nu_com_phosphatase) then
- !          call t_start_lnd(event)
- !          call PhosphorusBiochemMin(num_soilc, filter_soilc, &
- !               cnstate_vars, dt)
- !          call t_stop_lnd(event)
- !      else
- !          ! nu_com_phosphatase is true
- !          call t_start_lnd(event)
- !          call PhosphorusBiochemMin_balance(bounds,num_soilc, filter_soilc, &
- !               cnstate_vars, dt)
- !          call t_stop_lnd(event)
- !      end if
- !   end if
-
- !   ! --------------------------------------------------
- !   ! Phosphorus Deposition ! X.SHI
- !   ! --------------------------------------------------
-
- !   event = 'PhosphorusDeposition'
- !   call t_start_lnd(event)
- !   call PhosphorusDeposition(num_soilc,filter_soilc, atm2lnd_vars )
- !   call t_stop_lnd(event)
-
- !   !-------------------------------------------------------------------------------------------------
- !   ! plfotran: 'decomp_rate_constants' must be calculated before entering "clm_interface"
- !   if (use_century_decomp) then
- !     call decomp_rate_constants_bgc(bounds, num_soilc, filter_soilc, &
- !          canopystate_vars, soilstate_vars, ch4_vars, cnstate_vars)
- !   else
- !     call decomp_rate_constants_cn( num_soilc, filter_soilc, &
- !          canopystate_vars, soilstate_vars,  ch4_vars, cnstate_vars)
- !   end if
-
- !   !-------------------------------------------------------------------------------------------------
- !   ! 'decomp_vertprofiles' (calc nfixation_prof) is moved from SoilLittDecompAlloc:
- !   ! ------------------------------------------------------------------------------------------------
- !   call decomp_vertprofiles(bounds,                        &
- !         num_soilc, filter_soilc, num_soilp, filter_soilp, &
- !         soilstate_vars, canopystate_vars, cnstate_vars)
- !   !-------------------------------------------------------------------------------------------------
- !   ! Allocation1 is always called (w/ or w/o use_elm_interface)
- !   ! pflotran: call 'Allocation1' to obtain potential N demand for support initial GPP
- !   if(.not.use_fates)then
- !      event = 'CNAllocation - phase-1'
- !      call t_start_lnd(event)
- !      call Allocation1_PlantNPDemand ( &
- !               num_soilc, filter_soilc, num_soilp, filter_soilp            , &
- !               photosyns_vars, crop_vars, canopystate_vars, cnstate_vars   , &
- !              dt, year )
- !      call t_stop_lnd(event)
- !   end if
-
-
- ! end subroutine EcosystemDynNoLeaching1
+    end if
+
+
+    if ( nu_com .ne. 'RD') then
+       ! for P competition purpose, calculate P fluxes that will potentially increase solution P pool
+       ! then competitors take up solution P
+       event ='PhosphorusWeathering'
+       call t_start_lnd(event)
+       call PhosphorusWeathering(num_soilc, filter_soilc, cnstate_vars, dt)
+       call t_stop_lnd(event)
+
+       event = 'PhosphorusBiochemMin'
+       if (.not. nu_com_phosphatase) then
+           call t_start_lnd(event)
+           call PhosphorusBiochemMin(bounds,num_soilc, filter_soilc, &
+                cnstate_vars, dt)
+           call t_stop_lnd(event)
+       else
+           ! nu_com_phosphatase is true
+           call t_start_lnd(event)
+           call PhosphorusBiochemMin_balance(bounds,num_soilc, filter_soilc, &
+                cnstate_vars, dt)
+           call t_stop_lnd(event)
+       end if
+    end if
+
+    ! --------------------------------------------------
+    ! Phosphorus Deposition ! X.SHI
+    ! --------------------------------------------------
+
+    event = 'PhosphorusDeposition'
+    call t_start_lnd(event)
+    call PhosphorusDeposition(bounds,  atm2lnd_vars )
+    call t_stop_lnd(event)
+
+    !-------------------------------------------------------------------------------------------------
+    ! plfotran: 'decomp_rate_constants' must be calculated before entering "clm_interface"
+    if (use_century_decomp) then
+      call decomp_rate_constants_bgc(bounds, num_soilc, filter_soilc, &
+           canopystate_vars, soilstate_vars, ch4_vars, cnstate_vars)
+    else
+      call decomp_rate_constants_cn(bounds, num_soilc, filter_soilc, &
+           canopystate_vars, soilstate_vars,  ch4_vars, cnstate_vars)
+    end if
+
+    !-------------------------------------------------------------------------------------------------
+    ! 'decomp_vertprofiles' (calc nfixation_prof) is moved from SoilLittDecompAlloc:
+    ! ------------------------------------------------------------------------------------------------
+    call decomp_vertprofiles(bounds,                        &
+          num_soilc, filter_soilc, num_soilp, filter_soilp, &
+          soilstate_vars, canopystate_vars, cnstate_vars)
+
+    !-------------------------------------------------------------------------------------------------
+    ! Allocation1 is always called (w/ or w/o use_elm_interface)
+    ! pflotran: call 'Allocation1' to obtain potential N demand for support initial GPP
+    if(.not.use_fates)then
+
+       event = 'CNAllocation - phase-1'
+       call t_start_lnd(event)
+       call Allocation1_PlantNPDemand (bounds                             , &
+                num_soilc, filter_soilc, num_soilp, filter_soilp            , &
+                photosyns_vars, crop_vars, canopystate_vars, cnstate_vars   , &
+               dt, year )
+       call t_stop_lnd(event)
+    end if
+
+
+  end subroutine EcosystemDynNoLeaching1
 
 !-------------------------------------------------------------------------------------------------
-!   subroutine EcosystemDynNoLeaching2(bounds,                                  &
-!        num_soilc, filter_soilc,                                                 &
-!        num_soilp, filter_soilp, num_pcropp, filter_pcropp,&
-!        num_ppercropp, filter_ppercropp, doalb,               &
-!        cnstate_vars,                                              &
-!        atm2lnd_vars,               &
-!        canopystate_vars, soilstate_vars,  crop_vars, ch4_vars, &
-!        photosyns_vars, soilhydrology_vars, energyflux_vars,          &
-!        sedflux_vars)
-!     !-------------------------------------------------------------------
-!     ! bgc interface
-!     ! Phase-2 of EcosystemDynNoLeaching
-!     ! call SoilLittDecompAlloc (w/o bgc_interface) & SoilLittDecompAlloc2
-!     !-------------------------------------------------------------------
-! 
-!     ! !DESCRIPTION:
-!     ! The core CN code is executed here. Calculates fluxes for maintenance
-!     ! respiration, decomposition, allocation, phenology, and growth respiration.
-!     ! These routines happen on the radiation time step so that canopy structure
-!     ! stays synchronized with albedo calculations.
-!     ! !USES:
-!     use PhenologyMod         , only: Phenology, CNLitterToColumn
-!     use GrowthRespMod             , only: GrowthResp
-!     use GapMortalityMod           , only: GapMortality
-!     use CarbonStateUpdate2Mod     , only: CarbonStateUpdate2, CarbonStateUpdate2h
-!     use NitrogenStateUpdate2Mod   , only: NitrogenStateUpdate2, NitrogenStateUpdate2h
-!     use PhosphorusStateUpdate2Mod , only: PhosphorusStateUpdate2, PhosphorusStateUpdate2h
-!     use FireMod              , only: FireArea, FireFluxes
-!     use ErosionMod           , only: ErosionFluxes
-!     use CarbonStateUpdate3Mod     , only: CarbonStateUpdate3
-!     use CarbonIsoFluxMod          , only: CarbonIsoFlux1, CarbonIsoFlux2, CarbonIsoFlux2h, CarbonIsoFlux3
-!     use C14DecayMod          , only: C14Decay, C14BombSpike
-!     use WoodProductsMod      , only: WoodProducts
-!     use CropHarvestPoolsMod  , only: CropHarvestPools
-!     use SoilLittVertTranspMod, only: SoilLittVertTransp
-!     use CropType             , only: crop_type
-!     use dynHarvestMod        , only: CNHarvest
-!     use RootDynamicsMod      , only: RootDynamics
-!     use SoilLittDecompMod    , only: SoilLittDecompAlloc
-!     use SoilLittDecompMod    , only: SoilLittDecompAlloc2 !after SoilLittDecompAlloc
-! 
-!     !
-!     ! !ARGUMENTS:
-!     type(bounds_type)        , intent(in)    :: bounds
-!     integer                  , intent(in)    :: num_soilc         ! number of soil columns in filter
-!     integer                  , intent(in)    :: filter_soilc(:)   ! filter for soil columns
-!     integer                  , intent(in)    :: num_soilp         ! number of soil patches in filter
-!     integer                  , intent(in)    :: filter_soilp(:)   ! filter for soil patches
-!     integer                  , intent(in)    :: num_pcropp        ! number of prog. crop patches in filter
-!     integer                  , intent(in)    :: filter_pcropp(:)  ! filter for prognostic crop patches
-!     integer                  , intent(in)    :: num_ppercropp 
-!     integer                  , intent(in)    :: filter_ppercropp(:)
-!     logical                  , intent(in)    :: doalb             ! true = surface albedo calculation time step
-!     type(cnstate_type)       , intent(inout) :: cnstate_vars
-!     type(atm2lnd_type)       , intent(in)    :: atm2lnd_vars
-!     type(canopystate_type)   , intent(in)    :: canopystate_vars
-!     type(soilstate_type)     , intent(inout) :: soilstate_vars
-!     type(crop_type)          , intent(inout) :: crop_vars
-!     type(ch4_type)           , intent(in)    :: ch4_vars
-!     type(photosyns_type)     , intent(in)    :: photosyns_vars
-!     type(soilhydrology_type) , intent(in)    :: soilhydrology_vars
-!     type(energyflux_type)    , intent(in)    :: energyflux_vars
-!     type(sedflux_type)       , intent(in)    :: sedflux_vars
-! 
-!     character(len=64) :: event
-!     real(r8) :: dt
-!     integer :: c13, c14, fp, p
-!     c13 = 0
-!     c14 = 1
-!     !-----------------------------------------------------------------------
-!     dt = dtime_mod
-!     ! Call the main CN routines
-! 
-!     !event = 'SoilLittDecompAlloc'
-!     !call t_start_lnd(event)
-!     !----------------------------------------------------------------
-!     if(.not.use_elm_interface) then
-!        ! directly run elm-bgc
-!        ! if (use_elm_interface & use_elm_bgc), then CNDecomAlloc is called in elm_driver
-!        call SoilLittDecompAlloc( num_soilc, filter_soilc,    &
-!                   num_soilp, filter_soilp,                    &
-!                   canopystate_vars, soilstate_vars,           &
-!                   cnstate_vars, ch4_vars, dt)
-!     end if !if(.not.use_elm_interface)
-! 
-!     !call t_stopf('SoilLittDecompAlloc')
-! 
-!     event = 'SoilLittDecompAlloc2'
-!     call t_start_lnd(event)
-!     !----------------------------------------------------------------
-!     ! SoilLittDecompAlloc2 is called by both elm-bgc & pflotran
-!     ! pflotran: call 'SoilLittDecompAlloc2' to calculate some diagnostic variables and 'fpg' for plant N uptake
-!     ! pflotran & elm-bgc : 'Allocation3_AG' and vertically integrate net and gross mineralization fluxes
-!     call SoilLittDecompAlloc2 ( num_soilc, filter_soilc, num_soilp, filter_soilp,           &
-!              canopystate_vars, soilstate_vars,         &
-!              cnstate_vars, crop_vars, dt )
-!     call t_stop_lnd(event)
-! 
-!     !----------------------------------------------------------------
-! 
-!     if(.not.use_fates)then
-!         !--------------------------------------------
-!         ! Phenology
-!         !--------------------------------------------
-!         ! Phenology needs to be called after SoilLittDecompAlloc, because it
-!         ! depends on current time-step fluxes to new growth on the last
-!         ! litterfall timestep in deciduous systems
-!         event = 'Phenology'
-!         call t_start_lnd(event)
-!         call Phenology(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!              num_pcropp, filter_pcropp, num_ppercropp, filter_ppercropp, doalb, &
-!              crop_vars, canopystate_vars, soilstate_vars, &
-!              cnstate_vars )
-!         call t_stop_lnd(event)
-! 
-!         !--------------------------------------------
-!         ! Growth respiration
-!         !--------------------------------------------
-! 
-!         event = 'GrowthResp'
-!         call t_start_lnd(event)
-!         do fp = 1, num_soilp
-!            p = filter_soilp(fp)
-!            call GrowthResp(p)
-!         end do
-!         call t_stop_lnd(event)
-!         call veg_cf_summary_rr(veg_cf, num_soilp, filter_soilp, num_soilc, filter_soilc, col_cf)
-!         if(use_c13) then
-!            call veg_cf_summary_rr(c13_veg_cf, num_soilp, filter_soilp, num_soilc, filter_soilc, c13_col_cf)
-!         endif
-!         if(use_c14) then
-!            call veg_cf_summary_rr(c14_veg_cf, num_soilp, filter_soilp, num_soilc, filter_soilc, c14_col_cf)
-!         endif
-! 
-! 
-!         !--------------------------------------------
-!         ! Dynamic Roots
-!         !--------------------------------------------
-! 
-!         if( use_dynroot ) then
-!             event = 'RootDynamics'
-!             call t_start_lnd(event)
-!             call RootDynamics(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                   canopystate_vars,   &
-!                   cnstate_vars, crop_vars, energyflux_vars, soilstate_vars)
-!             call t_stop_lnd(event)
-!         end if
-! 
-!         !--------------------------------------------
-!         ! CNUpdate0
-!         !--------------------------------------------
-!        call t_stop_lnd(event)
-! 
-!         !-------------------------------------------
-! #ifndef _OPENACC
-!         if(use_pheno_flux_limiter)then
-!           event = 'phenology_flux_limiter'
-!           call t_start_lnd(event)
-!           call phenology_flux_limiter(bounds, num_soilc, filter_soilc,&
-!             num_soilp, filter_soilp, crop_vars, cnstate_vars,  &
-!             veg_cf, veg_cs, &
-!             c13_veg_cf, c13_veg_cs, &
-!             c14_veg_cf, c14_veg_cs, &
-!             veg_nf, veg_ns, veg_pf, veg_ps)
-!           call t_stop_lnd(event)
-!         endif
-! #endif
-!         event = 'CNLitterToColumn'
-!         call t_start_lnd(event)
-!         call CNLitterToColumn(num_soilp, filter_soilp, cnstate_vars )
-!         call t_stop_lnd(event)
-! 
-!         !--------------------------------------------
-!         ! Update1
-!         !--------------------------------------------
-!         event = 'CNUpdate1'
-!         call t_start_lnd(event)
-! 
-!         if ( use_c13 ) then
-!           call CarbonIsoFlux1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                cnstate_vars, &
-!                isotope=c13, isocol_cs=c13_col_cs, isoveg_cs=c13_veg_cs, isocol_cf=c13_col_cf, isoveg_cf=c13_veg_cf)
-!         end if
-! 
-!         if ( use_c14 ) then
-!           call CarbonIsoFlux1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                cnstate_vars , &
-!                isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
-!          end if
-!          call t_stop_lnd(event)
-! 
-!     end if  ! if(.not.use_fates)
-! 
-! #ifndef _OPENACC
-!     if(use_fates) then
-!        ! In this scenario, we simply zero all of the
-!        ! column level variables that would had been upscaled
-!        ! in the veg summary with p2c
-!        call col_cf%ZeroForFatesRR(bounds,num_soilc, filter_soilc)
-! 
-!        ! Transfer fates litter fluxes into ELM source arrays
-!        call alm_fates%UpdateLitterFluxes(bounds)
-!     end if
-! #endif
-! 
-!    event = 'CNUpdate1'
-!    call t_start_lnd(event)
-! 
-! 
-!    call t_stop_lnd(event)
-! 
-!    event = 'SoilLittVertTransp'
-!    call t_start_lnd(event)
-!    call SoilLittVertTransp( num_soilc, filter_soilc, &
-!             canopystate_vars, cnstate_vars )
-!        call t_stop_lnd(event)
-! 
-!    if(.not.use_fates)then
-!        event = 'CNGapMortality'
-!        call t_start_lnd(event)
-!        call GapMortality( num_soilc, filter_soilc, num_soilp, filter_soilp,&
-!                               cnstate_vars )
-!        call t_stop_lnd(event)
-! 
-!        !--------------------------------------------
-!        ! Update2
-!        !--------------------------------------------
-!        event = 'CNUpdate2'
-!        call t_start_lnd(event)
-! 
-!        if ( use_c13 ) then
-!            call CarbonIsoFlux2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                 cnstate_vars, isotope=c13, isocol_cs=c13_col_cs, isoveg_cs=c13_veg_cs, &
-!                 isocol_cf=c13_col_cf, isoveg_cf=c13_veg_cf)
-!        end if
-! 
-!        if ( use_c14 ) then
-!            call CarbonIsoFlux2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                 cnstate_vars, &
-!                 isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
-!        end if
-! 
-!        call CarbonStateUpdate2( num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!             col_cs, veg_cs, col_cf, veg_cf)
-! 
-!        if ( use_c13 ) then
-!           call CarbonStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                 c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf)
-!        end if
-!        if ( use_c14 ) then
-!           call CarbonStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf)
-!        end if
-!        call NitrogenStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp )
-! 
-!        call PhosphorusStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp)
-! 
-!       ! if (get_do_harvest()) then
-!       !    call CNHarvest(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!       !         cnstate_vars )
-!       ! end if
-! 
-!        if ( use_c13 ) then
-!           call CarbonIsoFlux2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                cnstate_vars, &
-!                isotope=c13, isocol_cs=c13_col_cs, isoveg_cs=c13_veg_cs, isocol_cf=c13_col_cf, isoveg_cf=c13_veg_cf)
-!        end if
-!        if ( use_c14 ) then
-!           call CarbonIsoFlux2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                cnstate_vars , &
-!                isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
-!        end if
-! 
-!        call CarbonStateUpdate2h( num_soilc, filter_soilc,  num_soilp, filter_soilp, &
-!              col_cs, veg_cs, col_cf, veg_cf)
-!        if ( use_c13 ) then
-!           call CarbonStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf)
-!        end if
-!        if ( use_c14 ) then
-!           call CarbonStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf)
-!        end if
-!        call NitrogenStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp)
-!        call PhosphorusStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp)
-!        call WoodProducts(num_soilc, filter_soilc )
-!        call CropHarvestPools(num_soilc, filter_soilc, dt)
-! 
-!        call FireArea(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!             atm2lnd_vars, energyflux_vars, soilhydrology_vars, &
-!             cnstate_vars )
-!        call FireFluxes(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!             cnstate_vars)
-!        call t_stop_lnd(event)
-! 
-!    end if
-! 
-!    if ( use_erosion ) then
-!        event = 'ErosionFluxes'
-!        call t_start_lnd(event)
-!        call ErosionFluxes(bounds, num_soilc, filter_soilc, soilstate_vars, sedflux_vars )
-!        call t_stop_lnd(event)
-!    end if
-!    !--------------------------------------------
-!    ! Update3
-!    !--------------------------------------------
-!    if(.not.use_fates)then
-!        if ( use_c13 ) then
-!        call CarbonIsoFlux3(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!             cnstate_vars, &
-!             isotope=c13, isocol_cs=c13_col_cs, isoveg_cs=c13_veg_cs, isocol_cf=c13_col_cf, isoveg_cf=c13_veg_cf)
-!        end if
-!        if ( use_c14 ) then
-!           call CarbonIsoFlux3(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                cnstate_vars , &
-!                isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
-!        end if
-! 
-!        call CarbonStateUpdate3( num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!             col_cs, veg_cs, col_cf, veg_cf, dt)
-! 
-!        if ( use_c13 ) then
-!           call CarbonStateUpdate3( num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf, dt)
-!        end if
-!        if ( use_c14 ) then
-!           call CarbonStateUpdate3( num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf, dt)
-!        end if
-!        if ( use_c14 ) then
-!           call C14Decay(num_soilc, filter_soilc, num_soilp, filter_soilp, &
-!                cnstate_vars )
-! 
-!           call C14BombSpike(num_soilp, filter_soilp, &
-!                cnstate_vars)
-!        end if
-! 
-!        call veg_cf_summary_for_ch4(veg_cf,bounds, num_soilp, filter_soilp)
-!        if( use_c13 ) then
-!           call col_cf_summary_for_ch4(c13_col_cf,bounds, num_soilc, filter_soilc)
-!           call veg_cf_summary_for_ch4(c13_veg_cf,bounds, num_soilp, filter_soilp)
-!        endif
-!        if( use_c14 ) then
-!           call col_cf_summary_for_ch4(c14_col_cf,bounds, num_soilc, filter_soilc)
-!           call veg_cf_summary_for_ch4(c14_veg_cf,bounds, num_soilp, filter_soilp)
-!        endif
-! 
-!    end if !end of if not use_fates block
-! 
-!   call col_cf_summary_for_ch4(col_cf,bounds, num_soilc, filter_soilc)
-! 
-! end subroutine EcosystemDynNoLeaching2
+  subroutine EcosystemDynNoLeaching2(bounds,                                  &
+       num_soilc, filter_soilc,                                                 &
+       num_soilp, filter_soilp, num_pcropp, filter_pcropp, doalb,               &
+       num_ppercropp, filter_ppercropp,                                         &
+       cnstate_vars,                                              &
+       atm2lnd_vars,               &
+       canopystate_vars, soilstate_vars,  crop_vars, ch4_vars, &
+       photosyns_vars, soilhydrology_vars, energyflux_vars,          &
+       sedflux_vars)
+    !-------------------------------------------------------------------
+    ! bgc interface
+    ! Phase-2 of EcosystemDynNoLeaching
+    ! call SoilLittDecompAlloc (w/o bgc_interface) & SoilLittDecompAlloc2
+    !-------------------------------------------------------------------
+
+    ! !DESCRIPTION:
+    ! The core CN code is executed here. Calculates fluxes for maintenance
+    ! respiration, decomposition, allocation, phenology, and growth respiration.
+    ! These routines happen on the radiation time step so that canopy structure
+    ! stays synchronized with albedo calculations.
+    !
+    ! !USES:
+    use PhenologyMod         , only: Phenology, CNLitterToColumn
+    use GrowthRespMod             , only: GrowthResp
+    use CarbonStateUpdate1Mod     , only: CarbonStateUpdate1,CarbonStateUpdate0
+    use NitrogenStateUpdate1Mod     , only: NitrogenStateUpdate1
+    use PhosphorusStateUpdate1Mod       , only: PhosphorusStateUpdate1
+    use GapMortalityMod        , only: GapMortality
+    use CarbonStateUpdate2Mod     , only: CarbonStateUpdate2, CarbonStateUpdate2h
+    use NitrogenStateUpdate2Mod     , only: NitrogenStateUpdate2, NitrogenStateUpdate2h
+    use PhosphorusStateUpdate2Mod       , only: PhosphorusStateUpdate2, PhosphorusStateUpdate2h
+    use FireMod              , only: FireArea, FireFluxes
+    use ErosionMod           , only: ErosionFluxes
+    use CarbonStateUpdate3Mod     , only: CarbonStateUpdate3
+    use CarbonIsoFluxMod          , only: CarbonIsoFlux1, CarbonIsoFlux2, CarbonIsoFlux2h, CarbonIsoFlux3
+    use C14DecayMod          , only: C14Decay, C14BombSpike
+    use WoodProductsMod      , only: WoodProducts
+    use CropHarvestPoolsMod  , only: CropHarvestPools
+    use SoilLittVertTranspMod, only: SoilLittVertTransp
+    use CropType               , only: crop_type
+    use dynHarvestMod          , only: CNHarvest
+    use RootDynamicsMod        , only: RootDynamics
+    use SoilLittDecompMod            , only: SoilLittDecompAlloc
+    use SoilLittDecompMod            , only: SoilLittDecompAlloc2 !after SoilLittDecompAlloc
+
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
+    integer                  , intent(in)    :: num_soilc         ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:)   ! filter for soil columns
+    integer                  , intent(in)    :: num_soilp         ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:)   ! filter for soil patches
+    integer                  , intent(in)    :: num_pcropp        ! number of prog. crop patches in filter
+    integer                  , intent(in)    :: filter_pcropp(:)  ! filter for prognostic crop patches
+    integer                  , intent(in)    :: num_ppercropp     ! number of prog perennial crop patches in filter
+    integer                  , intent(in)    :: filter_ppercropp(:) ! filter for prognostic perennial crop patches
+    logical                  , intent(in)    :: doalb             ! true = surface albedo calculation time step
+    type(cnstate_type)       , intent(inout) :: cnstate_vars
+    type(atm2lnd_type)       , intent(in)    :: atm2lnd_vars
+    type(canopystate_type)   , intent(in)    :: canopystate_vars
+    type(soilstate_type)     , intent(inout) :: soilstate_vars
+    type(crop_type)          , intent(inout) :: crop_vars
+    type(ch4_type)           , intent(in)    :: ch4_vars
+    type(photosyns_type)     , intent(in)    :: photosyns_vars
+    type(soilhydrology_type) , intent(in)    :: soilhydrology_vars
+    type(energyflux_type)    , intent(in)    :: energyflux_vars
+!
+    type(sedflux_type)       , intent(in)    :: sedflux_vars
+    character(len=64) :: event
+    real(r8) :: dt
+    integer :: c13, c14
+    c13 = 0
+    c14 = 1
+    !-----------------------------------------------------------------------
+    dt = dtime_mod
+    ! Call the main CN routines
+
+    event = 'SoilLittDecompAlloc'
+    call t_start_lnd(event)
+    !----------------------------------------------------------------
+    if(.not.use_elm_interface) then
+       ! directly run elm-bgc
+       ! if (use_elm_interface & use_elm_bgc), then CNDecomAlloc is called in elm_driver
+       call SoilLittDecompAlloc (bounds, num_soilc, filter_soilc,    &
+                  num_soilp, filter_soilp,                     &
+                  canopystate_vars, soilstate_vars,            &
+                  cnstate_vars, ch4_vars,                      &
+                  dt)
+    end if !if(.not.use_elm_interface)
+
+    call t_stopf('SoilLittDecompAlloc')
+
+    event = 'SoilLittDecompAlloc2'
+    call t_start_lnd(event)
+    !----------------------------------------------------------------
+    ! SoilLittDecompAlloc2 is called by both elm-bgc & pflotran
+    ! pflotran: call 'SoilLittDecompAlloc2' to calculate some diagnostic variables and 'fpg' for plant N uptake
+    ! pflotran & elm-bgc : 'Allocation3_AG' and vertically integrate net and gross mineralization fluxes
+    call SoilLittDecompAlloc2 (bounds, num_soilc, filter_soilc, num_soilp, filter_soilp,           &
+             photosyns_vars, canopystate_vars, soilstate_vars,         &
+             cnstate_vars, ch4_vars,                  &
+             crop_vars, atm2lnd_vars,                 &
+             dt )
+    call t_stop_lnd(event)
+
+    !----------------------------------------------------------------
+
+    if(.not.use_fates)then
+
+        !--------------------------------------------
+        ! Phenology
+        !--------------------------------------------
+
+        ! Phenology needs to be called after SoilLittDecompAlloc, because it
+        ! depends on current time-step fluxes to new growth on the last
+        ! litterfall timestep in deciduous systems
+
+        event = 'Phenology'
+        call t_start_lnd(event)
+        call Phenology(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+             num_pcropp, filter_pcropp, num_ppercropp, filter_ppercropp, doalb, atm2lnd_vars, &
+             crop_vars, canopystate_vars, soilstate_vars, &
+             cnstate_vars )
+        call t_stop_lnd(event)
+
+        !--------------------------------------------
+        ! Growth respiration
+        !--------------------------------------------
+
+        event = 'GrowthResp'
+        call t_start_lnd(event)
+        call GrowthResp(num_soilp, filter_soilp )
+        call t_stop_lnd(event)
+
+        call veg_cf_summary_rr(veg_cf,bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, col_cf)
+        if(use_c13) then
+           call veg_cf_summary_rr(c13_veg_cf,bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, c13_col_cf)
+        endif
+        if(use_c14) then
+           call veg_cf_summary_rr(c14_veg_cf,bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, c14_col_cf)
+        endif
+
+
+        !--------------------------------------------
+        ! Dynamic Roots
+        !--------------------------------------------
+
+        if( use_dynroot ) then
+            event = 'RootDynamics'
+            call t_start_lnd(event)
+
+            call RootDynamics(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+                  canopystate_vars,   &
+                  cnstate_vars, crop_vars, energyflux_vars, soilstate_vars)
+            call t_stop_lnd(event)
+        end if
+
+        !--------------------------------------------
+        ! CNUpdate0
+        !--------------------------------------------
+
+       event = 'CNUpdate0'
+       call t_start_lnd(event)
+       call CarbonStateUpdate0(num_soilp, filter_soilp,veg_cs,veg_cf, dt)
+       if ( use_c13 ) then
+          call CarbonStateUpdate0(num_soilp, filter_soilp,c13_veg_cs,c13_veg_cf, dt)
+       end if
+       if ( use_c14 ) then
+          call CarbonStateUpdate0(num_soilp, filter_soilp,c14_veg_cs,c14_veg_cf ,dt)
+       end if
+       call t_stop_lnd(event)
+
+        !--------------------------------------------
+        if(use_pheno_flux_limiter)then
+          event = 'phenology_flux_limiter'
+          call t_start_lnd(event)
+          call phenology_flux_limiter(bounds, num_soilc, filter_soilc,&
+            num_soilp, filter_soilp, crop_vars, cnstate_vars,  &
+            veg_cf, veg_cs, &
+            c13_veg_cf, c13_veg_cs, &
+            c14_veg_cf, c14_veg_cs, &
+            veg_nf, veg_ns, veg_pf, veg_ps)
+          call t_stop_lnd(event)
+        endif
+        event = 'CNLitterToColumn'
+        call t_start_lnd(event)
+        call CNLitterToColumn(num_soilp, filter_soilp, cnstate_vars )
+        call t_stop_lnd(event)
+
+        !--------------------------------------------
+        ! Update1
+        !--------------------------------------------
+        event = 'CNUpdate1'
+        call t_start_lnd(event)
+
+        if ( use_c13 ) then
+          call CarbonIsoFlux1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               cnstate_vars, &
+               isotope=c13, isocol_cs=c13_col_cs, isoveg_cs=c13_veg_cs, isocol_cf=c13_col_cf, isoveg_cf=c13_veg_cf)
+        end if
+
+        if ( use_c14 ) then
+          call CarbonIsoFlux1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               cnstate_vars , &
+               isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
+         end if
+         call t_stop_lnd(event) 
+
+    end if  ! if(.not.use_fates)
+
+    if(use_fates) then
+       ! In this scenario, we simply zero all of the
+       ! column level variables that would had been upscaled
+       ! in the veg summary with p2c
+       call col_cf%ZeroForFatesRR(bounds,num_soilc, filter_soilc)
+
+       ! Transfer fates litter fluxes into ELM source arrays
+       call alm_fates%UpdateLitterFluxes(bounds)
+    end if
+    
+   event = 'CNUpdate1'
+   call t_start_lnd(event)
+
+   call CarbonStateUpdate1(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+         crop_vars, col_cs, veg_cs, col_cf, veg_cf, dt)
+
+   if ( use_c13 ) then
+      call CarbonStateUpdate1(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+           crop_vars, c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf,dt)
+   end if
+   if ( use_c14 ) then
+      call CarbonStateUpdate1(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+           crop_vars, c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf,dt)
+   end if
+
+   call NitrogenStateUpdate1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+        cnstate_vars, dt)
+
+   call PhosphorusStateUpdate1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+        cnstate_vars, dt)
+
+
+   call t_stop_lnd(event)
+
+   event = 'SoilLittVertTransp'
+   call t_start_lnd(event)
+   call SoilLittVertTransp(bounds, &
+            num_soilc, filter_soilc, &
+            canopystate_vars, cnstate_vars )
+       call t_stop_lnd(event)
+   if(.not.use_fates)then
+       event = 'CNGapMortality'
+       call t_start_lnd(event)
+       call GapMortality( num_soilc, filter_soilc, num_soilp, filter_soilp,&
+                              cnstate_vars )
+       call t_stop_lnd(event)
+
+       !--------------------------------------------
+       ! Update2
+       !--------------------------------------------
+       event = 'CNUpdate2'
+       call t_start_lnd(event)
+
+       if ( use_c13 ) then
+           call CarbonIsoFlux2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+                cnstate_vars,  &
+                isotope=c13, isocol_cs=c13_col_cs, isoveg_cs=c13_veg_cs, isocol_cf=c13_col_cf, isoveg_cf=c13_veg_cf)
+       end if
+
+       if ( use_c14 ) then
+           call CarbonIsoFlux2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+                cnstate_vars, &
+                isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
+       end if
+
+
+
+       call CarbonStateUpdate2( num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            col_cs, veg_cs, col_cf, veg_cf, dt)
+
+       if ( use_c13 ) then
+          call CarbonStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+                c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf,dt)
+       end if
+       if ( use_c14 ) then
+          call CarbonStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf, dt)
+       end if
+       call NitrogenStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            dt )
+
+       call PhosphorusStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            dt)
+
+       if (get_do_harvest()) then
+          call CNHarvest(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               cnstate_vars )
+       end if
+
+       if ( use_c13 ) then
+          call CarbonIsoFlux2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               cnstate_vars, &
+               isotope=c13, isocol_cs=c13_col_cs, isoveg_cs=c13_veg_cs, isocol_cf=c13_col_cf, isoveg_cf=c13_veg_cf)
+       end if
+       if ( use_c14 ) then
+          call CarbonIsoFlux2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               cnstate_vars , &
+               isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
+       end if
+
+
+
+       call CarbonStateUpdate2h( num_soilc, filter_soilc,  num_soilp, filter_soilp, &
+             col_cs, veg_cs, col_cf, veg_cf, dt)
+       if ( use_c13 ) then
+          call CarbonStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf, dt)
+       end if
+       if ( use_c14 ) then
+          call CarbonStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf, dt)
+       end if
+
+       call NitrogenStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            dt)
+
+       call PhosphorusStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            dt)
+
+       call WoodProducts(num_soilc, filter_soilc )
+
+       call CropHarvestPools(num_soilc, filter_soilc, dt)
+
+       call FireArea(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            atm2lnd_vars, energyflux_vars, soilhydrology_vars, &
+            cnstate_vars )
+
+       call FireFluxes(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            cnstate_vars)
+
+
+       call t_stop_lnd(event)
+
+   end if
+
+   if ( use_erosion ) then
+       event = 'ErosionFluxes'
+       call t_start_lnd(event)
+       call ErosionFluxes(bounds, num_soilc, filter_soilc, soilstate_vars, sedflux_vars )
+       call t_stop_lnd(event)
+   end if
+
+   !--------------------------------------------
+   ! Update3
+   !--------------------------------------------
+
+   if(.not.use_fates)then
+       if ( use_c13 ) then
+       call CarbonIsoFlux3(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            cnstate_vars, &
+            isotope=c13, isocol_cs=c13_col_cs, isoveg_cs=c13_veg_cs, isocol_cf=c13_col_cf, isoveg_cf=c13_veg_cf)
+       end if
+       if ( use_c14 ) then
+          call CarbonIsoFlux3(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               cnstate_vars , &
+               isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
+       end if
+
+       call CarbonStateUpdate3( num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            col_cs, veg_cs, col_cf, veg_cf, dt)
+
+       if ( use_c13 ) then
+          call CarbonStateUpdate3( num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf, dt)
+       end if
+       if ( use_c14 ) then
+          call CarbonStateUpdate3( num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf, dt)
+       end if
+
+
+       if ( use_c14 ) then
+          call C14Decay(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+               cnstate_vars )
+
+          call C14BombSpike(num_soilp, filter_soilp, &
+               cnstate_vars)
+       end if
+
+       call veg_cf_summary_for_ch4(veg_cf,bounds, num_soilp, filter_soilp)
+       if( use_c13 ) then
+          call col_cf_summary_for_ch4(c13_col_cf,bounds, num_soilc, filter_soilc)
+          call veg_cf_summary_for_ch4(c13_veg_cf,bounds, num_soilp, filter_soilp)
+       endif
+       if( use_c14 ) then
+          call col_cf_summary_for_ch4(c14_col_cf,bounds, num_soilc, filter_soilc)
+          call veg_cf_summary_for_ch4(c14_veg_cf,bounds, num_soilp, filter_soilp)
+       endif
+
+  end if !end of if not use_fates block
+
+  call col_cf_summary_for_ch4(col_cf,bounds, num_soilc, filter_soilc)
+
+
+
+end subroutine EcosystemDynNoLeaching2
 
 
 end  module EcosystemDynMod
diff --git a/components/elm/src/biogeochem/FireMod.F90 b/components/elm/src/biogeochem/FireMod.F90
index b4912eed94..a22b3e23d3 100644
--- a/components/elm/src/biogeochem/FireMod.F90
+++ b/components/elm/src/biogeochem/FireMod.F90
@@ -20,7 +20,7 @@ module FireMod
   use shr_log_mod            , only : errMsg => shr_log_errMsg
   use elm_varctl             , only : iulog
   use elm_varpar             , only : nlevdecomp, ndecomp_pools
-  use elm_varcon             , only : dzsoi_decomp, spval
+  use elm_varcon             , only : dzsoi_decomp
   use pftvarcon              , only : fsr_pft, fd_pft, noveg
   use spmdMod                , only : masterproc, mpicom, comp_id
   use fileutils              , only : getavu, relavu
@@ -121,17 +121,17 @@ contains
     ! !DESCRIPTION:
     ! Computes column-level burned area
     !
+      !$acc routine seq
     ! !USES:
     use elm_varpar           , only: max_patch_per_col
     use elm_varcon           , only: secspday
     use elm_varctl           , only: use_nofire, spinup_state, spinup_mortality_factor
+    use dynSubgridControlMod , only: run_has_transient_landcover
     use pftvarcon            , only: nc4_grass, nc3crop, ndllf_evr_tmp_tree
     use pftvarcon            , only: nbrdlf_evr_trp_tree, nbrdlf_dcd_trp_tree, nbrdlf_evr_shrub
-    use subgridAveMod        , only: p2c_1d_filter_parallel
-    use dynSubgridControlMod , only: dyn_subgrid_control_inst
     !
     ! !ARGUMENTS:
-    type(bounds_type)        , intent(in)    :: bounds   
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
     integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
@@ -141,6 +141,12 @@ contains
     type(soilhydrology_type) , intent(in)    :: soilhydrology_vars
     type(cnstate_type)       , intent(inout) :: cnstate_vars
 
+    !!
+    real(r8)  :: dt       ! time step variable (s)
+    real(r8)  :: dayspyr  ! days per year
+    integer  :: kyr, kmo, kda, mcsec, nstep
+
+    !
     ! !LOCAL VARIABLES:
     real(r8), parameter  :: lfuel=75._r8    ! lower threshold of fuel mass (gC/m2) for ignition, Li et al.(2014)
     real(r8), parameter  :: ufuel=1050._r8  ! upper threshold of fuel mass(gC/m2) for ignition
@@ -156,11 +162,11 @@ contains
     !
     ! non-boreal peat fires (was different in paper)
     real(r8), parameter :: non_boreal_peatfire_c = 0.001_r8
-    real(r8), parameter ::cli_scale = 0.035_r8   !global constant for deforestation fires (/d)
     !
     integer  :: g,t,l,c,p,pi,j,fc,fp  ! index variables
     real(r8) :: m        ! top-layer soil moisture (proportion)
     real(r8) :: cli      ! effect of climate on deforestation fires (0-1)
+    real(r8), parameter ::cli_scale = 0.035_r8   !global constant for deforestation fires (/d)
     real(r8) :: cri      ! thresholds used for cli, (mm/d), see Eq.(7) in Li et al.(2013)
     real(r8) :: fb       ! availability of fuel for regs A and C
     real(r8) :: fhd      ! impact of hd on agricultural fire
@@ -169,15 +175,12 @@ contains
     real(r8) :: spread_m ! combustability of fuel for fire spread
     real(r8) :: Lb_lf    ! length-to-breadth ratio added by Lifang
     integer  :: i_cwd    ! cwd pool
-    integer  :: begc, endc, begp, endp 
     real(r8) :: lh       ! anthro. ignitions (count/km2/hr)
     real(r8) :: fs       ! hd-dependent fires suppression (0-1)
     real(r8) :: ig       ! total ignitions (count/km2/hr)
     real(r8) :: hdmlf    ! human density
-    real(r8) :: sum1,sum2,sum3,sum4
-    real(r8) :: btran_col(num_soilc)
+    real(r8) :: btran_col(bounds%begc:bounds%endc)
     logical  :: transient_landcover  ! whether this run has any prescribed transient landcover
-    real :: startt,stopt
     !-----------------------------------------------------------------------
 
     associate(                                                                &
@@ -252,24 +255,31 @@ contains
          fuelc_crop         =>    col_cs%fuelc_crop             & ! Output: [real(r8) (:)     ]  fuel avalability factor for Reg.A
          )
 
+      transient_landcover = run_has_transient_landcover()
 
-      transient_landcover = (dyn_subgrid_control_inst%do_transient_pfts .or. &
-                  dyn_subgrid_control_inst%do_transient_crops)
-      begp = bounds%begp; endp = bounds%endp
-      begc = bounds%begc; endc = bounds%endc 
-      
       !pft to column average
-      call p2c_1d_filter_parallel( num_soilc, filter_soilc, &
-           totvegc(begp:endp), totvegc_col(begc:endc))
-      call p2c_1d_filter_parallel( num_soilc, filter_soilc, &
-           leafc(begp:endp), leafc_col(begc:endc))
-      call p2c_1d_filter_parallel(num_soilc, filter_soilc, &
-           deadstemc(begp:endp), deadstemc_col(begc:endc))
+      call p2c(bounds, num_soilc, filter_soilc, &
+           totvegc(bounds%begp:bounds%endp), &
+           totvegc_col(bounds%begc:bounds%endc))
+
+      call p2c(bounds, num_soilc, filter_soilc, &
+           leafc(bounds%begp:bounds%endp), &
+           leafc_col(bounds%begc:bounds%endc))
+
+      call p2c(bounds, num_soilc, filter_soilc, &
+           deadstemc(bounds%begp:bounds%endp), &
+           deadstemc_col(bounds%begc:bounds%endc))
+
+      dt = dtime_mod        ! time step variable (s)
+      dayspyr = dayspyr_mod ! days per year
+      kyr = year_curr   ; kmo   = mon_curr;
+      kda = day_curr    ; mcsec = secs_curr;
+      nstep = nstep_mod
 
+     !
      ! On first time-step, just set area burned to zero and exit
      !
-     if ( nstep_mod == 0 )then
-        !$acc parallel loop independent gang vector private(c) default(present)
+     if ( nstep == 0 )then
         do fc = 1,num_soilc
            c = filter_soilc(fc)
            farea_burned(c) = 0._r8
@@ -280,216 +290,178 @@ contains
            cropf_col(c)    = 0._r8
         end do
         return
-      end if
-      
-     !$acc enter data create(sum1,sum2,sum3,sum4,btran_col(:), i_cwd, transient_landcover)
-     ! find which pool is the cwd pool
-     i_cwd = 0
-     do l = 1, ndecomp_pools
-        if ( is_cwd(l) ) then
-           i_cwd = l
-        endif
-     end do
-     !$acc update device(i_cwd, transient_landcover)
+     end if
      !
      ! Calculate fraction of crop (cropf_col) and non-crop and non-bare-soil
      ! vegetation (lfwt) in vegetated column
      !
-     !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8; sum2 = 0.0_r8;
-         !$acc loop vector reduction(+:sum1,sum2)
-         do p = col_pp%pfti(c), col_pp%pftf(c)
-            ! For crop veg types
-            if(veg_pp%wtcol(p)  >  0._r8) then 
-               if( veg_pp%itype(p) > nc4_grass )then
-                  sum1 = sum1 + veg_pp%wtcol(p)
-               end if
-               ! For natural vegetation (non-crop and non-bare-soil)
-               if( veg_pp%itype(p) >= ndllf_evr_tmp_tree .and. veg_pp%itype(p) <= nc4_grass )then
-                  sum2 = sum2 + veg_pp%wtcol(p)
-               end if
-            end if 
+     do fc = 1,num_soilc
+        c = filter_soilc(fc)
+        cropf_col(c) = 0._r8
+        lfwt(c)      = 0._r8
+     end do
+     do pi = 1,max_patch_per_col
+        do fc = 1,num_soilc
+           c = filter_soilc(fc)
+           if (pi <=  col_pp%npfts(c)) then
+              p = col_pp%pfti(c) + pi - 1
+              ! For crop veg types
+              if( veg_pp%itype(p) > nc4_grass )then
+                 cropf_col(c) = cropf_col(c) + veg_pp%wtcol(p)
+              end if
+              ! For natural vegetation (non-crop and non-bare-soil)
+              if( veg_pp%itype(p) >= ndllf_evr_tmp_tree .and. veg_pp%itype(p) <= nc4_grass )then
+                 lfwt(c) = lfwt(c) + veg_pp%wtcol(p)
+              end if
+           end if
         end do
-        cropf_col(c) = sum1
-        lfwt(c)      = sum2
      end do
      !
      ! Calculate crop fuel
      !
-     !$acc parallel loop independent gang worker default(present) private(c,sum1)
      do fc = 1,num_soilc
         c = filter_soilc(fc)
-        sum1 = 0._r8
-        if(leafc_col(c) > 0._r8) then
-           !$acc loop vector reduction(+:sum1)
-           do p = col_pp%pfti(c), col_pp%pftf(c)
-             ! For crop PFTs, fuel load includes leaf and litter; only
-             ! column-level litter carbon
-             ! is available, so we use leaf carbon to estimate the
-             ! litter carbon for crop PFTs
-             if( veg_pp%itype(p) > nc4_grass .and. veg_pp%wtcol(p) > 0._r8  .and. veg_pp%wtcol(p)  >  0._r8 )then
-                sum1 = sum1 + (leafc(p) + leafc_storage(p) + &
-                     leafc_xfer(p))*veg_pp%wtcol(p)/cropf_col(c)     + &
-                     totlitc(c)*leafc(p)/leafc_col(c)*veg_pp%wtcol(p)/cropf_col(c)
+        fuelc_crop(c)=0._r8
+     end do
+     do pi = 1,max_patch_per_col
+        do fc = 1,num_soilc
+           c = filter_soilc(fc)
+           if (pi <=  col_pp%npfts(c)) then
+              p = col_pp%pfti(c) + pi - 1
+              ! For crop PFTs, fuel load includes leaf and litter; only
+              ! column-level litter carbon
+              ! is available, so we use leaf carbon to estimate the
+              ! litter carbon for crop PFTs
+              if( veg_pp%itype(p) > nc4_grass .and. veg_pp%wtcol(p) > 0._r8 .and. leafc_col(c) > 0._r8 )then
+                 fuelc_crop(c)=fuelc_crop(c) + (leafc(p) + leafc_storage(p) + &
+                      leafc_xfer(p))*veg_pp%wtcol(p)/cropf_col(c)     + &
+                      totlitc(c)*leafc(p)/leafc_col(c)*veg_pp%wtcol(p)/cropf_col(c)
               end if
-           end do
-        end if
-        fuelc_crop(c) = sum1
+           end if
+        end do
      end do
      !
      ! Calculate noncrop column variables
      ! 5/22/2018, PET: switched the use of column-weight-on-gridcell, to column-weight-on-topounit
      ! in the calculation of summed weight for tropical trees
      !
-     !
-     !$acc parallel loop gang worker default(present) private(c,sum1,sum2,sum4,sum4)
      do fc = 1,num_soilc
         c = filter_soilc(fc)
-        sum1 = 0._r8; sum2=0._r8;
-        sum3 = 0._r8; sum4=0._r8;
-        !$acc loop vector reduction(+:sum1,sum2,sum3,sum4)
-        do p = col_pp%pfti(c), col_pp%pftf(c)
+        fsr_col(c)   = 0._r8
+        fd_col(c)    = 0._r8
+        rootc_col(c) = 0._r8
+        lgdp_col(c)  = 0._r8
+        lgdp1_col(c) = 0._r8
+        lpop_col(c)  = 0._r8
+        btran_col(c) = 0._r8
+        wtlf(c)      = 0._r8
+        trotr1_col(c)= 0._r8
+        trotr2_col(c)= 0._r8
+        if (transient_landcover) then    !true when landuse data is used
+           dtrotr_col(c)=0._r8
+        end if
+     end do
+     do pi = 1,max_patch_per_col
+        do fc = 1,num_soilc
+           c = filter_soilc(fc)
+           g = col_pp%gridcell(c)
+           if (pi <=  col_pp%npfts(c)) then
+              p = col_pp%pfti(c) + pi - 1
+
               ! For non-crop -- natural vegetation and bare-soil
-              if( veg_pp%itype(p)  <  nc3crop .and. cropf_col(c)  <  1.0_r8 .and. veg_pp%wtcol(p)  >  0._r8 )then
-                 if( btran2(p) .ne. spval )then !check if btran2 is NaN
+              if( veg_pp%itype(p)  <  nc3crop .and. cropf_col(c)  <  1.0_r8 )then
+                 if( .not. (btran2(p) .ne. btran2(p)))then !?shr_infnan_isnan(btran2(p))) then
                     if (btran2(p)  <=  1._r8 ) then
-                      sum1 = sum1 + btran2(p)*veg_pp%wtcol(p)
-                      sum2 = sum2 + veg_pp%wtcol(p)
+                       btran_col(c) = btran_col(c)+btran2(p)*veg_pp%wtcol(p)
+                       wtlf(c)      = wtlf(c)+veg_pp%wtcol(p)
                     end if
                  end if
                  if( veg_pp%itype(p) == nbrdlf_evr_trp_tree .and. veg_pp%wtcol(p)  >  0._r8 )then
-                    sum3 = sum3 + veg_pp%wtcol(p)*col_pp%wttopounit(c)
+                    trotr1_col(c)=trotr1_col(c)+veg_pp%wtcol(p)*col_pp%wttopounit(c)
                  end if
                  if( veg_pp%itype(p) == nbrdlf_dcd_trp_tree .and. veg_pp%wtcol(p)  >  0._r8 )then
-                    sum4 = sum4 + veg_pp%wtcol(p)*col_pp%wttopounit(c)
+                    trotr2_col(c)=trotr2_col(c)+veg_pp%wtcol(p)*col_pp%wttopounit(c)
                  end if
-              end if
-        end do
-        btran_col(fc) = sum1
-        wtlf(c) = sum2
-        trotr1_col(c) = sum3
-        trotr2_col(c) = sum4
-      end do
-      !
-      if (transient_landcover) then    !true when landuse data is used
-         !$acc parallel loop gang worker default(present) private(c,sum1)
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            sum1 = 0._r8;
-            !$acc loop vector reduction(+:sum1)
-            do p = col_pp%pfti(c), col_pp%pftf(c)
-               ! For non-crop -- natural vegetation and bare-soil
-               if( veg_pp%itype(p)  <  nc3crop .and. cropf_col(c)  <  1.0_r8 .and. veg_pp%wtcol(p)  >  0._r8 )then
-                  if( veg_pp%itype(p) == nbrdlf_evr_trp_tree .or. veg_pp%itype(p) == nbrdlf_dcd_trp_tree )then
-                     if(lfpftd(p) > 0._r8)then
-                        sum1 = sum1 + lfpftd(p)*col_pp%wttopounit(c)
-                     end if
-                  end if
-               end if
-            end do
-            dtrotr_col(c) = sum1
-         end do
-      end if
-
-      !$acc parallel loop gang worker default(present) private(c,sum1,sum2)
-     do fc = 1,num_soilc
-        c = filter_soilc(fc)
-        sum1 = 0._r8;sum2=0.0_r8;
-        !$acc loop vector reduction(+:sum1,sum2)
-        do p = col_pp%pfti(c), col_pp%pftf(c)
-              ! For non-crop -- natural vegetation and bare-soil
-              if( veg_pp%itype(p)  <  nc3crop .and. cropf_col(c)  <  1.0_r8 .and. veg_pp%wtcol(p)  >  0._r8 )then
-                  sum1 = sum1 + (frootc(p) + frootc_storage(p) + &
+                 if (transient_landcover) then    !true when landuse data is used
+                    if( veg_pp%itype(p) == nbrdlf_evr_trp_tree .or. veg_pp%itype(p) == nbrdlf_dcd_trp_tree )then
+                       if(lfpftd(p) > 0._r8)then
+                          dtrotr_col(c)=dtrotr_col(c)+lfpftd(p)*col_pp%wttopounit(c)
+                       end if
+                    end if
+                 end if
+                 rootc_col(c) = rootc_col(c) + (frootc(p) + frootc_storage(p) + &
                       frootc_xfer(p) + deadcrootc(p) +                &
                       deadcrootc_storage(p) + deadcrootc_xfer(p) +    &
                       livecrootc(p)+livecrootc_storage(p) +           &
                       livecrootc_xfer(p))*veg_pp%wtcol(p)
 
-                 sum2 = sum2 + fsr_pft(veg_pp%itype(p))*veg_pp%wtcol(p)/(1.0_r8-cropf_col(c))
-              end if
-        end do
-        rootc_col(c) = sum1
-        fsr_col(c) = sum2
-      end do
+                 fsr_col(c) = fsr_col(c) + fsr_pft(veg_pp%itype(p))*veg_pp%wtcol(p)/(1.0_r8-cropf_col(c))
 
-      !$acc parallel loop gang worker default(present) private(c,g,sum1,sum2,sum4,sum4)
-     do fc = 1,num_soilc
-        c = filter_soilc(fc)
-        g = col_pp%gridcell(c)
-        sum1 = 0._r8;sum2=0.0_r8;
-        sum3 = 0._r8;sum4=0.0_r8;
-        !$acc loop vector reduction(+:sum1,sum2,sum3,sum4)
-        do p = col_pp%pfti(c), col_pp%pftf(c)
-              ! For non-crop -- natural vegetation and bare-soil
-              if( veg_pp%itype(p)  <  nc3crop .and. cropf_col(c)  <  1.0_r8 .and. veg_pp%wtcol(p)  >  0._r8 )then
                  if( lfwt(c)  /=  0.0_r8 )then
                     hdmlf=forc_hdm(g)
+
                     ! all these constants are in Li et al. BG (2012a,b;2013)
+
                     if( hdmlf  >  0.1_r8 )then
                        ! For NOT bare-soil
                        if( veg_pp%itype(p)  /=  noveg )then
                           ! For shrub and grass (crop already excluded above)
                           if( veg_pp%itype(p)  >=  nbrdlf_evr_shrub )then      !for shurb and grass
-                             sum1 = sum1 + (0.1_r8 + 0.9_r8*    &
+                             lgdp_col(c)  = lgdp_col(c) + (0.1_r8 + 0.9_r8*    &
                                   exp(-1._r8*SHR_CONST_PI* &
                                   (gdp_lf(c)/8._r8)**0.5_r8))*veg_pp%wtcol(p) &
                                   /(1.0_r8 - cropf_col(c))
-                             sum2 = sum2 + (0.2_r8 + 0.8_r8*   &
+                             lgdp1_col(c) = lgdp1_col(c) + (0.2_r8 + 0.8_r8*   &
                                   exp(-1._r8*SHR_CONST_PI* &
                                   (gdp_lf(c)/7._r8)))*veg_pp%wtcol(p)/lfwt(c)
-                             sum3 = sum3 + (0.2_r8 + 0.8_r8*    &
+                             lpop_col(c)  = lpop_col(c) + (0.2_r8 + 0.8_r8*    &
                                   exp(-1._r8*SHR_CONST_PI* &
                                   (hdmlf/450._r8)**0.5_r8))*veg_pp%wtcol(p)/lfwt(c)
                           else   ! for trees
                              if( gdp_lf(c)  >  20._r8 )then
-                                sum1 = sum1 + 0.39_r8*veg_pp%wtcol(p)/(1.0_r8 - cropf_col(c))
+                                lgdp_col(c)  =lgdp_col(c)+0.39_r8*veg_pp%wtcol(p)/(1.0_r8 - cropf_col(c))
                              else
-                                sum1 = sum1 + veg_pp%wtcol(p)/(1.0_r8 - cropf_col(c))
+                                lgdp_col(c) = lgdp_col(c)+veg_pp%wtcol(p)/(1.0_r8 - cropf_col(c))
                              end if
                              if( gdp_lf(c)  >  20._r8 )then
-                                sum2 = sum2 + 0.62_r8*veg_pp%wtcol(p)/lfwt(c)
+                                lgdp1_col(c) = lgdp1_col(c)+0.62_r8*veg_pp%wtcol(p)/lfwt(c)
                              else
                                 if( gdp_lf(c)  >  8._r8 ) then
-                                   sum2 = sum2 + 0.83_r8*veg_pp%wtcol(p)/lfwt(c)
+                                   lgdp1_col(c)=lgdp1_col(c)+0.83_r8*veg_pp%wtcol(p)/lfwt(c)
                                 else
-                                   sum2 = sum2 + veg_pp%wtcol(p)/lfwt(c)
+                                   lgdp1_col(c)=lgdp1_col(c)+veg_pp%wtcol(p)/lfwt(c)
                                 end if
                              end if
-                             sum3 = sum3 + (0.4_r8 + 0.6_r8*    &
+                             lpop_col(c) = lpop_col(c) + (0.4_r8 + 0.6_r8*    &
                                   exp(-1._r8*SHR_CONST_PI* &
                                   (hdmlf/125._r8)))*veg_pp%wtcol(p)/lfwt(c)
                           end if
                        end if
                     else
-                       sum1 = sum1 + veg_pp%wtcol(p)/(1.0_r8 - cropf_col(c))
-                       sum2 = sum2 + veg_pp%wtcol(p)/lfwt(c)
-                       sum3 = sum3 + veg_pp%wtcol(p)/lfwt(c)
+                       lgdp_col(c)  = lgdp_col(c)+veg_pp%wtcol(p)/(1.0_r8 - cropf_col(c))
+                       lgdp1_col(c) = lgdp1_col(c)+veg_pp%wtcol(p)/lfwt(c)
+                       lpop_col(c)  = lpop_col(c)+veg_pp%wtcol(p)/lfwt(c)
                     end if
                  end if
-                 sum4 = sum4 + fd_pft(veg_pp%itype(p)) * veg_pp%wtcol(p) * secsphr / (1.0_r8-cropf_col(c))
+
+                 fd_col(c) = fd_col(c) + fd_pft(veg_pp%itype(p)) * veg_pp%wtcol(p) * secsphr / (1.0_r8-cropf_col(c))
               end if
+           end if
         end do
-        lgdp_col(c)  = sum1
-        lgdp1_col(c) = sum2
-        lpop_col(c)  = sum3
-        fd_col(c)    = sum4
      end do
 
      ! estimate annual decreased fractional coverage of BET+BDT
      ! land cover conversion in CLM4.5 is the same for each timestep except for the beginning
 
      if (transient_landcover) then    !true when landuse data is used
-        !$acc parallel loop gang vector default(present) private(c)
         do fc = 1,num_soilc
            c = filter_soilc(fc)
            if( dtrotr_col(c)  >  0._r8 )then
-              if( mon_curr == 1 .and. day_curr == 1 .and. secs_curr == 0)then
+              if( kmo == 1 .and. kda == 1 .and. mcsec == 0)then
                  lfc(c) = 0._r8
               end if
-              if( mon_curr == 1 .and. day_curr == 1 .and. secs_curr == dtime_mod)then
-                 lfc(c) = dtrotr_col(c)*dayspyr_mod*secspday/dtime_mod
+              if( kmo == 1 .and. kda == 1 .and. mcsec == dt)then
+                 lfc(c) = dtrotr_col(c)*dayspyr*secspday/dt
               end if
            else
               lfc(c)=0._r8
@@ -498,45 +470,54 @@ contains
      end if
      !
      ! calculate burned area fraction in cropland
-     if( mon_curr == 1 .and. day_curr == 1 .and. secs_curr == 0 )then
-        !$acc parallel loop independent gang vector default(present) private(p)
-        do fp = 1,num_soilp
-           p = filter_soilp(fp)
-           burndate(p) = 10000 ! init. value; actual range [0 365]
-        end do
-     end if
-
-     !$acc parallel loop gang worker private(c,g,t,hdmlf,sum1) default(present)
+     !
      do fc = 1,num_soilc
         c = filter_soilc(fc)
-        g = col_pp%gridcell(c)
-        t = col_pp%topounit(c)
-        hdmlf=forc_hdm(g)
-        sum1 = 0._r8
-        !$acc loop vector reduction(+:sum1) private(fhd,fgdp,fb)
-        do p = col_pp%pfti(c),col_pp%pftf(c)
-           ! For crop
-           if( forc_t(t)  >=  SHR_CONST_TKFRZ .and. veg_pp%itype(p)  >  nc4_grass .and.  &
-                   mon_curr == abm_lf(c) .and. forc_rain(t)+forc_snow(t) == 0._r8  .and. &
+        baf_crop(c)=0._r8
+     end do
+
+     do fp = 1,num_soilp
+        p = filter_soilp(fp)
+        if( kmo == 1 .and. kda == 1 .and. mcsec == 0 )then
+           burndate(p) = 10000 ! init. value; actual range [0 365]
+        end if
+     end do
+
+     do pi = 1,max_patch_per_col
+        do fc = 1,num_soilc
+           c = filter_soilc(fc)
+           g = col_pp%gridcell(c)
+           t = col_pp%topounit(c)
+           hdmlf=forc_hdm(g)
+           if (pi <=  col_pp%npfts(c)) then
+              p = col_pp%pfti(c) + pi - 1
+              ! For crop
+              if( forc_t(t)  >=  SHR_CONST_TKFRZ .and. veg_pp%itype(p)  >  nc4_grass .and.  &
+                   kmo == abm_lf(c) .and. forc_rain(t)+forc_snow(t) == 0._r8  .and. &
                    burndate(p) >= 999 .and. veg_pp%wtcol(p)  >  0._r8 )then ! catch  crop burn time
-              ! calculate human density impact on ag. fire
-              fhd = 0.04_r8+0.96_r8*exp(-1._r8*SHR_CONST_PI*(hdmlf/350._r8)**0.5_r8)
-              ! calculate impact of GDP on ag. fire
-              fgdp = 0.01_r8+0.99_r8*exp(-1._r8*SHR_CONST_PI*(gdp_lf(c)/10._r8))
-              ! calculate burned area
-              fb   = max(0.0_r8,min(1.0_r8,(fuelc_crop(c)-lfuel)/(ufuel-lfuel)))
-              ! crop fire only for generic crop types at this time
-              ! managed crops are treated as grasses if crop model is turned on
-              sum1 = sum1 + cropfire_a1/secsphr*fb*fhd*fgdp*veg_pp%wtcol(p)
-              if( fb*fhd*fgdp*veg_pp%wtcol(p)  >  0._r8) burndate(p) = day_curr
+
+                 ! calculate human density impact on ag. fire
+                 fhd = 0.04_r8+0.96_r8*exp(-1._r8*SHR_CONST_PI*(hdmlf/350._r8)**0.5_r8)
+
+                 ! calculate impact of GDP on ag. fire
+                 fgdp = 0.01_r8+0.99_r8*exp(-1._r8*SHR_CONST_PI*(gdp_lf(c)/10._r8))
+
+                 ! calculate burned area
+                 fb   = max(0.0_r8,min(1.0_r8,(fuelc_crop(c)-lfuel)/(ufuel-lfuel)))
+
+                 ! crop fire only for generic crop types at this time
+                 ! managed crops are treated as grasses if crop model is turned on
+                 baf_crop(c) = baf_crop(c) + cropfire_a1/secsphr*fb*fhd*fgdp*veg_pp%wtcol(p)
+                 if( fb*fhd*fgdp*veg_pp%wtcol(p)  >  0._r8)then
+                    burndate(p)=kda
+                 end if
+              end if
            end if
         end do
-        baf_crop(c) = sum1
      end do
      !
      ! calculate peatland fire
      !
-     !$acc parallel loop independent gang vector default(present) private(c,t,g)
      do fc = 1, num_soilc
         c = filter_soilc(fc)
         t = col_pp%topounit(c)
@@ -551,58 +532,48 @@ contains
                 (1._r8-fsat(c))
         end if
      end do
-
      !
      ! calculate other fires
      !
+
      ! Set the number of timesteps for e-folding.
      ! When the simulation has run fewer than this number of steps,
      ! re-scale the e-folding time to get a stable early estimate.
 
-     ! begin column loop to calculate fractional area affected by fire
-     !$acc parallel loop independent gang worker default(present) private(c,sum1)
-     do fc = 1, num_soilc
-        c = filter_soilc(fc)
-        sum1 = 0._r8
-        if( cropf_col(c)  <  1.0 )then
-           sum1 = totlitc(c)+totvegc_col(c)-rootc_col(c)-fuelc_crop(c)*cropf_col(c)
-
-           if (spinup_state == 1) sum1 = sum1 + ((spinup_mortality_factor - 1._r8)*deadstemc_col(c))
-
-           if (spinup_state == 1 .and. year_curr < 40) then
-             !$acc loop vector reduction(+:sum1)
-             do j = 1, nlevdecomp
-                sum1 = sum1 + decomp_cpools_vr(c,j,i_cwd) * dzsoi_decomp(j) * &
-                     decomp_cascade_con%spinup_factor(i_cwd)
-             end do
-
-           else if (spinup_state == 1 .and. year_curr >= 40) then
-             !$acc loop vector reduction(+:sum1)
-             do j=1,nlevdecomp
-                sum1 = sum1 + decomp_cpools_vr(c,j,i_cwd) *dzsoi_decomp(j) * &
-                            decomp_cascade_con%spinup_factor(i_cwd) / cnstate_vars%scalaravg_col(c,j)
-             enddo
-           else
-               sum1 = sum1 + decomp_cpools_vr(c,j,i_cwd) * dzsoi_decomp(j)
-           end if
-
-           fuelc(c) = sum1/(1._r8-cropf_col(c))
-        end if
-
+     ! find which pool is the cwd pool
+     i_cwd = 0
+     do l = 1, ndecomp_pools
+        if ( is_cwd(l) ) then
+           i_cwd = l
+        endif
      end do
 
-
-     !$acc parallel loop independent gang vector default(present)
+     !
+     ! begin column loop to calculate fractional area affected by fire
+     !
      do fc = 1, num_soilc
         c = filter_soilc(fc)
         g = col_pp%gridcell(c)
         t = col_pp%topounit(c)
         hdmlf=forc_hdm(g)
-        !
         if( cropf_col(c)  <  1.0 )then
            if (trotr1_col(c)+trotr2_col(c)>0.6_r8) then
               farea_burned(c)=min(1.0_r8,baf_crop(c)+baf_peatf(c))
            else
+              fuelc(c) = totlitc(c)+totvegc_col(c)-rootc_col(c)-fuelc_crop(c)*cropf_col(c)
+              if (spinup_state == 1) fuelc(c) = fuelc(c) + ((spinup_mortality_factor - 1._r8)*deadstemc_col(c))
+              do j = 1, nlevdecomp
+                if (spinup_state == 1 .and. kyr < 40) then
+                  fuelc(c) = fuelc(c)+decomp_cpools_vr(c,j,i_cwd) *dzsoi_decomp(j) * &
+                    decomp_cascade_con%spinup_factor(i_cwd)
+                else if (spinup_state == 1 .and. kyr >= 40) then
+                  fuelc(c) = fuelc(c)+decomp_cpools_vr(c,j,i_cwd) *dzsoi_decomp(j) * &
+                    decomp_cascade_con%spinup_factor(i_cwd) / cnstate_vars%scalaravg_col(c,j)
+                else
+                  fuelc(c) = fuelc(c)+decomp_cpools_vr(c,j,i_cwd) * dzsoi_decomp(j)
+                end if
+              end do
+              fuelc(c) = fuelc(c)/(1._r8-cropf_col(c))
               fb       = max(0.0_r8,min(1.0_r8,(fuelc(c)-lfuel)/(ufuel-lfuel)))
               m        = max(0._r8,wf(c))
               fire_m   = exp(-SHR_CONST_PI *(m/0.69_r8)**2)*(1.0_r8 - max(0._r8, &
@@ -614,7 +585,7 @@ contains
               nfire(c) = ig/secsphr*fb*fire_m*lgdp_col(c) !fire counts/km2/sec
               Lb_lf    = 1._r8+10.0_r8*(1._r8-EXP(-0.06_r8*forc_wind(t)))
               if ( wtlf(c) > 0.0_r8 )then
-                 spread_m = (1.0_r8 - max(0._r8,min(1._r8,(btran_col(fc)/wtlf(c)-0.3_r8)/ &
+                 spread_m = (1.0_r8 - max(0._r8,min(1._r8,(btran_col(c)/wtlf(c)-0.3_r8)/ &
                       (0.7_r8-0.3_r8))))*(1.0_r8-max(0._r8, &
                       min(1._r8,(forc_rh(t)-30._r8)/(80._r8-30._r8))))
               else
@@ -631,19 +602,19 @@ contains
            !
            if (transient_landcover) then    !true when landuse change data is used
               if( trotr1_col(c)+trotr2_col(c) > 0.6_r8 )then
-                 if(( mon_curr == 1 .and. day_curr == 1 .and. secs_curr == 0) .or. dtrotr_col(c) <= 0._r8 )then
+                 if(( kmo == 1 .and. kda == 1 .and. mcsec == 0) .or. &
+                      dtrotr_col(c) <=0._r8 )then
                     fbac1(c)        = 0._r8
                     farea_burned(c) = baf_crop(c)+baf_peatf(c)
                  else
                     cri = (4.0_r8*trotr1_col(c)+1.8_r8*trotr2_col(c))/(trotr1_col(c)+trotr2_col(c))
                     cli = (max(0._r8,min(1._r8,(cri-prec60(t)*secspday)/cri))**0.5)* &
-                          (max(0._r8,min(1._r8,(cri-prec10(t)*secspday)/cri))**0.5)* &
-                          max(0.0005_r8,min(1._r8,19._r8*dtrotr_col(c)*dayspyr_mod*secspday/dtime_mod-0.001_r8))* &
-                          max(0._r8,min(1._r8,(0.25_r8-(forc_rain(t)+forc_snow(t))*secsphr)/0.25_r8))
-
+                         (max(0._r8,min(1._r8,(cri-prec10(t)*secspday)/cri))**0.5)* &
+                         max(0.0005_r8,min(1._r8,19._r8*dtrotr_col(c)*dayspyr*secspday/dt-0.001_r8))* &
+                         max(0._r8,min(1._r8,(0.25_r8-(forc_rain(t)+forc_snow(t))*secsphr)/0.25_r8))
                     farea_burned(c) = cli*(cli_scale/secspday)+baf_crop(c)+baf_peatf(c)
                     ! burned area out of conversion region due to land use fire
-                    fbac1(c) = max(0._r8,cli*(cli_scale/secspday) - 2.0_r8*lfc(c)/dtime_mod)
+                    fbac1(c) = max(0._r8,cli*(cli_scale/secspday) - 2.0_r8*lfc(c)/dt)
                  end if
                  ! total burned area out of conversion
                  fbac(c) = fbac1(c)+baf_crop(c)+baf_peatf(c)
@@ -669,8 +640,6 @@ contains
         end if
 
      end do  ! end of column loop
-     !$acc exit data delete(i_cwd, &
-     !$acc       sum1,sum2,sum3,sum4,btran_col(:), transient_landcover)
 
    end associate
 
@@ -691,12 +660,14 @@ contains
    ! seconds_per_year is the number of seconds in a year.
    !
    ! !USES:
+      !$acc routine seq
    use pftvarcon            , only: cc_leaf,cc_lstem,cc_dstem,cc_other,fm_leaf,fm_lstem,fm_other,fm_root,fm_lroot,fm_droot
    use pftvarcon            , only: nc3crop,lf_flab,lf_fcel,lf_flig,fr_flab,fr_fcel,fr_flig
    use elm_varpar           , only: max_patch_per_col
    use elm_varctl           , only: spinup_state, spinup_mortality_factor
-   use dynSubgridControlMod , only: get_flanduse_timeseries,dyn_subgrid_control_inst
+   use dynSubgridControlMod , only: get_flanduse_timeseries
    use elm_varcon           , only: secspday
+   use dynSubgridControlMod , only: run_has_transient_landcover
    !
    ! !ARGUMENTS:
    integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
@@ -704,18 +675,22 @@ contains
    integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
    integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
    type(cnstate_type)       , intent(inout) :: cnstate_vars
+   real(r8)  :: dt                   ! time step variable (s)
+   real(r8)  :: dayspyr              ! days per year
+   integer   :: kyr, kmo, kda, mcsec
    !
    ! !LOCAL VARIABLES:
-   integer  :: g,c,p,j,l,pi   ! indices
-   real(r8) :: m_veg                ! speedup factor for accelerated decomp
-   integer  :: fp,fc                ! filter indices
-   real(r8) :: f                    ! rate for fire effects (1/s)
-   integer  :: itype
-   real(r8) :: cc_other_sc, wt_col, baf_crop_sc,lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj
-   real(r8) :: sum1,sum2,sum3
-   real :: startt, stopt
+   integer :: g,c,p,j,l,pi   ! indices
+   real(r8):: m_veg                ! speedup factor for accelerated decomp
+   integer :: fp,fc                ! filter indices
+   real(r8):: f                    ! rate for fire effects (1/s)
+   integer :: itype
+   real(r8):: cc_other_sc, wt_col, baf_crop_sc,lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj
+
    logical           :: transient_landcover  ! whether this run has any prescribed transient landcover
+
    !-----------------------------------------------------------------------
+
    ! NOTE: VR      = Vertically Resolved
    !       conv.   = conversion
    !       frac.   = fraction
@@ -972,23 +947,25 @@ contains
         )
 
 
-     transient_landcover = (dyn_subgrid_control_inst%do_transient_pfts .or. &
-               dyn_subgrid_control_inst%do_transient_crops)
+     transient_landcover = run_has_transient_landcover()
 
-     m_veg = 1.0_r8
-     if (spinup_state == 1) m_veg = spinup_mortality_factor
-     !$acc enter data copyin (m_veg,transient_landcover)
-     !$acc enter data create(sum1,sum2,sum3)
+     ! Get model step size
+     dt = dtime_mod        ! time step variable (s)
+     dayspyr = dayspyr_mod ! days per year
+     kyr = year_curr   ; kmo   = mon_curr;
+     kda = day_curr    ; mcsec = secs_curr;
      ! calculate burned area fraction per sec
      !
      ! patch loop
      !
-     !$acc parallel loop independent gang vector default(present) private(p,c,itype,f,cc_other_sc)
+     m_veg = 1.0_r8
+     if (spinup_state == 1) m_veg = spinup_mortality_factor
+
      do fp = 1,num_soilp
         p = filter_soilp(fp)
         c = veg_pp%column(p)
+
         itype = veg_pp%itype(p)
-        !
         if( itype < nc3crop .and. cropf_col(c) < 1.0_r8)then
            ! For non-crop (bare-soil and natural vegetation)
            if (transient_landcover) then    !true when landuse data is used
@@ -1004,9 +981,11 @@ contains
              f = 0._r8
            end if
         end if
+
         ! apply this rate to the pft state variables to get flux rates
         ! biomass burning
         ! carbon fluxes
+
         cc_other_sc = cc_other(itype)
 
         m_leafc_to_fire(p)               =  leafc(p)              * f * cc_leaf(itype)
@@ -1025,7 +1004,7 @@ contains
         m_livecrootc_storage_to_fire(p)  =  livecrootc_storage(p) * f * cc_other_sc
         m_livecrootc_xfer_to_fire(p)     =  livecrootc_xfer(p)    * f * cc_other_sc
         m_deadcrootc_to_fire(p)          =  deadcrootc(p)         * m_veg * f * 0._r8
-        m_deadcrootc_storage_to_fire(p)  =  deadcrootc_storage(p) * f * cc_other_sc
+        m_deadcrootc_storage_to_fire(p)  =  deadcrootc_storage(p) * f*  cc_other_sc
         m_deadcrootc_xfer_to_fire(p)     =  deadcrootc_xfer(p)    * f * cc_other_sc
         m_gresp_storage_to_fire(p)       =  gresp_storage(p)      * f * cc_other_sc
         m_gresp_xfer_to_fire(p)          =  gresp_xfer(p)         * f * cc_other_sc
@@ -1080,27 +1059,37 @@ contains
         ! mortality due to fire
         ! carbon pools
         m_leafc_to_litter_fire(p)                   =  leafc(p) * f * &
-             (1._r8 - cc_leaf(itype)) * fm_leaf(itype)
+             (1._r8 - cc_leaf(itype)) * &
+             fm_leaf(itype)
         m_leafc_storage_to_litter_fire(p)           =  leafc_storage(p) * f * &
-             (1._r8 - cc_other_sc) * fm_other(itype)
+             (1._r8 - cc_other_sc) * &
+             fm_other(itype)
         m_leafc_xfer_to_litter_fire(p)              =  leafc_xfer(p) * f * &
-             (1._r8 - cc_other_sc) * fm_other(itype)
+             (1._r8 - cc_other_sc) * &
+             fm_other(itype)
         m_livestemc_to_litter_fire(p)               =  livestemc(p) * f * &
-             (1._r8 - cc_lstem(itype)) * fm_droot(itype)
+             (1._r8 - cc_lstem(itype)) * &
+             fm_droot(itype)
         m_livestemc_storage_to_litter_fire(p)       =  livestemc_storage(p) * f * &
-             (1._r8 - cc_other_sc) * fm_other(itype)
+             (1._r8 - cc_other_sc) * &
+             fm_other(itype)
         m_livestemc_xfer_to_litter_fire(p)          =  livestemc_xfer(p) * f * &
-             (1._r8 - cc_other_sc) * fm_other(itype)
+             (1._r8 - cc_other_sc) * &
+             fm_other(itype)
         m_livestemc_to_deadstemc_fire(p)            =  livestemc(p) * f * &
-             (1._r8 - cc_lstem(itype)) *(fm_lstem(itype)-fm_droot(itype))
+             (1._r8 - cc_lstem(itype)) * &
+             (fm_lstem(itype)-fm_droot(itype))
         m_deadstemc_to_litter_fire(p)               =  deadstemc(p) * m_veg * f * &
-             (1._r8 - cc_dstem(itype)) * fm_droot(itype)
+             (1._r8 - cc_dstem(itype)) * &
+             fm_droot(itype)
         m_deadstemc_storage_to_litter_fire(p)       =  deadstemc_storage(p) * f * &
-             (1._r8 - cc_other_sc) * fm_other(itype)
+             (1._r8 - cc_other_sc) * &
+             fm_other(itype)
         m_deadstemc_xfer_to_litter_fire(p)          =  deadstemc_xfer(p) * f * &
-             (1._r8 - cc_other_sc) * fm_other(itype)
-        m_frootc_to_litter_fire(p)                  =  frootc(p)  * f * fm_root(itype)
-
+             (1._r8 - cc_other_sc) * &
+             fm_other(itype)
+        m_frootc_to_litter_fire(p)                  =  frootc(p)             * f * &
+             fm_root(itype)
         m_frootc_storage_to_litter_fire(p)          =  frootc_storage(p)     * f * &
              fm_other(itype)
         m_frootc_xfer_to_litter_fire(p)             =  frootc_xfer(p)        * f * &
@@ -1246,65 +1235,53 @@ contains
              fm_other(itype)
 
      end do  ! end of patches loop
+
      ! fire-induced transfer of carbon and nitrogen pools to litter and cwd
      ! add phosphorus transfer fluxes -X.YANG
-     !NOTE:  restructuring store and FP ops. so likely non-BFB
-     !$acc parallel loop independent gang worker collapse(2) default(present) private(c,sum1,sum2,sum3)
-     do j = 1,nlevdecomp
-        do fc = 1,num_soilc
-           c = filter_soilc(fc)
-           sum1 = fire_mortality_c_to_cwdc(c,j);
-           sum2 = fire_mortality_n_to_cwdn(c,j);
-           sum3 = fire_mortality_p_to_cwdp(c,j);
-
-           !$acc loop vector reduction(+:sum1,sum2,sum3) &
-           !$acc     private(wt_col, lprof_pj, fr_prof_pj, cr_prof_pj, st_prof_pj)
-           do p = col_pp%pfti(c), col_pp%pftf(c)
-             wt_col = veg_pp%wtcol(p)
-             if(wt_col == 0._r8) cycle 
-             lprof_pj   = leaf_prof(p,j)
-             fr_prof_pj = froot_prof(p,j)
-             cr_prof_pj = croot_prof(p,j)
-             st_prof_pj = stem_prof(p,j)
-
-             sum1 = sum1 &
-                +(m_deadstemc_to_litter_fire(p) +m_livestemc_to_litter_fire(p) )*wt_col*st_prof_pj &
-                +(m_deadcrootc_to_litter_fire(p)+m_livecrootc_to_litter_fire(p))*wt_col*cr_prof_pj
-
-             sum2 = sum2 + &
-                  (m_deadstemn_to_litter_fire(p) + m_livestemn_to_litter_fire(p) )*wt_col*st_prof_pj &
-                + (m_deadcrootn_to_litter_fire(p)+ m_livecrootn_to_litter_fire(p))*wt_col*cr_prof_pj
-            ! add phosphorus
-             sum3 = sum3 + &
-                 (m_deadstemp_to_litter_fire(p) +m_livestemp_to_litter_fire(p) )*wt_col*st_prof_pj &
-                +(m_deadcrootp_to_litter_fire(p)+m_livecrootp_to_litter_fire(p))*wt_col*cr_prof_pj
-
-           end do
-           fire_mortality_c_to_cwdc(c,j) = sum1
-           fire_mortality_n_to_cwdn(c,j) = sum2
-           fire_mortality_p_to_cwdp(c,j) = sum3
-        end do
-     end do
-
-     !$acc parallel loop independent gang worker collapse(2) default(present) private(c,sum1,sum2,sum3)
-     do j = 1,nlevdecomp
-        do fc = 1,num_soilc
-           c = filter_soilc(fc)
-           sum1 = m_c_to_litr_met_fire(c,j);
-           sum2 = m_c_to_litr_cel_fire(c,j);
-           sum3 = m_c_to_litr_lig_fire(c,j);
-
-           !$acc loop vector reduction(+:sum1,sum2,sum3) private(wt_col,itype,lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj)
-           do p = col_pp%pfti(c), col_pp%pftf(c)
-             wt_col     = veg_pp%wtcol(p)
-             if(wt_col == 0._r8) cycle 
-             itype      = veg_pp%itype(p)
-             lprof_pj   = leaf_prof(p,j)
-             fr_prof_pj = froot_prof(p,j)
-             cr_prof_pj = croot_prof(p,j)
-             st_prof_pj = stem_prof(p,j)
-
-             sum1 = sum1 + &
+     do fp = 1,num_soilp
+       p = filter_soilp(fp)
+       c = veg_pp%column(p)
+       wt_col = veg_pp%wtcol(p)
+       itype = veg_pp%itype(p)
+
+       do j = 1,nlevdecomp
+         lprof_pj   = leaf_prof(p,j)
+         fr_prof_pj = froot_prof(p,j)
+         cr_prof_pj = croot_prof(p,j)
+         st_prof_pj = stem_prof(p,j)
+
+
+         fire_mortality_c_to_cwdc(c,j) = fire_mortality_c_to_cwdc(c,j) + &
+              m_deadstemc_to_litter_fire(p) * wt_col * st_prof_pj
+         fire_mortality_c_to_cwdc(c,j) = fire_mortality_c_to_cwdc(c,j) + &
+              m_deadcrootc_to_litter_fire(p) * wt_col * cr_prof_pj
+         fire_mortality_n_to_cwdn(c,j) = fire_mortality_n_to_cwdn(c,j) + &
+              m_deadstemn_to_litter_fire(p) * wt_col * st_prof_pj
+         fire_mortality_n_to_cwdn(c,j) = fire_mortality_n_to_cwdn(c,j) + &
+              m_deadcrootn_to_litter_fire(p) * wt_col * cr_prof_pj
+         ! add phosphorus
+         fire_mortality_p_to_cwdp(c,j) = fire_mortality_p_to_cwdp(c,j) + &
+              m_deadstemp_to_litter_fire(p) * wt_col * st_prof_pj
+         fire_mortality_p_to_cwdp(c,j) = fire_mortality_p_to_cwdp(c,j) + &
+              m_deadcrootp_to_litter_fire(p) * wt_col * cr_prof_pj
+
+
+         fire_mortality_c_to_cwdc(c,j) = fire_mortality_c_to_cwdc(c,j) + &
+              m_livestemc_to_litter_fire(p) * wt_col * st_prof_pj
+         fire_mortality_c_to_cwdc(c,j) = fire_mortality_c_to_cwdc(c,j) + &
+              m_livecrootc_to_litter_fire(p) * wt_col * cr_prof_pj
+         fire_mortality_n_to_cwdn(c,j) = fire_mortality_n_to_cwdn(c,j) + &
+              m_livestemn_to_litter_fire(p) * wt_col * st_prof_pj
+         fire_mortality_n_to_cwdn(c,j) = fire_mortality_n_to_cwdn(c,j) + &
+              m_livecrootn_to_litter_fire(p) * wt_col * cr_prof_pj
+         ! add phosphorus
+         fire_mortality_p_to_cwdp(c,j) = fire_mortality_p_to_cwdp(c,j) + &
+              m_livestemp_to_litter_fire(p) * wt_col * st_prof_pj
+         fire_mortality_p_to_cwdp(c,j) = fire_mortality_p_to_cwdp(c,j) + &
+              m_livecrootp_to_litter_fire(p) * wt_col * cr_prof_pj
+
+
+          m_c_to_litr_met_fire(c,j)=m_c_to_litr_met_fire(c,j) + &
                ((m_leafc_to_litter_fire(p)*lf_flab(itype) &
                +m_leafc_storage_to_litter_fire(p) + &
                m_leafc_xfer_to_litter_fire(p) + m_cpool_to_litter_fire(p) + &
@@ -1316,47 +1293,20 @@ contains
                +(m_livestemc_storage_to_litter_fire(p) + &
                m_livestemc_xfer_to_litter_fire(p) &
                +m_deadstemc_storage_to_litter_fire(p) + &
-               m_deadstemc_xfer_to_litter_fire(p))*st_prof_pj &
+               m_deadstemc_xfer_to_litter_fire(p))* st_prof_pj&
                +(m_livecrootc_storage_to_litter_fire(p) + &
                m_livecrootc_xfer_to_litter_fire(p) &
                +m_deadcrootc_storage_to_litter_fire(p) + &
                m_deadcrootc_xfer_to_litter_fire(p))* cr_prof_pj)* wt_col
 
-            sum2 = sum2 + &
-               (m_leafc_to_litter_fire(p)*lf_fcel(itype)*lprof_pj + &
-               m_frootc_to_litter_fire(p)*fr_fcel(itype)*fr_prof_pj)* wt_col
-
-            sum3 = sum3 + &
-               (m_leafc_to_litter_fire(p)*lf_flig(itype)*lprof_pj + &
-                m_frootc_to_litter_fire(p)*fr_flig(itype)*fr_prof_pj)* wt_col
-         end do
+       m_c_to_litr_cel_fire(c,j)=m_c_to_litr_cel_fire(c,j) + &
+            (m_leafc_to_litter_fire(p)*lf_fcel(itype)*lprof_pj + &
+            m_frootc_to_litter_fire(p)*fr_fcel(itype)*fr_prof_pj)* wt_col
+       m_c_to_litr_lig_fire(c,j)=m_c_to_litr_lig_fire(c,j) + &
+            (m_leafc_to_litter_fire(p)*lf_flig(itype)*lprof_pj + &
+            m_frootc_to_litter_fire(p)*fr_flig(itype)*fr_prof_pj)* wt_col
 
-         m_c_to_litr_met_fire(c,j) = sum1;
-         m_c_to_litr_cel_fire(c,j) = sum2;
-         m_c_to_litr_lig_fire(c,j) = sum3;
-
-        end do
-     end do
-
-   !$acc parallel loop independent gang worker collapse(2) default(present) private(c,sum1,sum2,sum3)
-   do j = 1,nlevdecomp
-     do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = m_n_to_litr_met_fire(c,j);
-         sum2 = m_n_to_litr_cel_fire(c,j);
-         sum3 = m_n_to_litr_lig_fire(c,j);
-
-         !$acc loop vector reduction(+:sum1,sum2,sum3) private(wt_col,itype,lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj)
-         do p = col_pp%pfti(c), col_pp%pftf(c)
-          wt_col     = veg_pp%wtcol(p)
-          if(wt_col == 0._r8) cycle 
-          itype      = veg_pp%itype(p)
-          lprof_pj   = leaf_prof(p,j)
-          fr_prof_pj = froot_prof(p,j)
-          cr_prof_pj = croot_prof(p,j)
-          st_prof_pj = stem_prof(p,j)
-
-          sum1 = sum1 + &
+       m_n_to_litr_met_fire(c,j)=m_n_to_litr_met_fire(c,j) + &
             ((m_leafn_to_litter_fire(p)*lf_flab(itype) &
             +m_leafn_storage_to_litter_fire(p) + m_npool_to_litter_fire(p) + &
             m_leafn_xfer_to_litter_fire(p)+m_retransn_to_litter_fire(p)) &
@@ -1371,40 +1321,16 @@ contains
             m_livecrootn_xfer_to_litter_fire(p) &
             +m_deadcrootn_storage_to_litter_fire(p) + &
             m_deadcrootn_xfer_to_litter_fire(p))* cr_prof_pj)* wt_col
+       m_n_to_litr_cel_fire(c,j)=m_n_to_litr_cel_fire(c,j) + &
+            (m_leafn_to_litter_fire(p)*lf_fcel(itype)*lprof_pj + &
+            m_frootn_to_litter_fire(p)*fr_fcel(itype)*fr_prof_pj)* wt_col
 
-          sum2 = sum2 + &
-             (m_leafn_to_litter_fire(p)*lf_fcel(itype)*lprof_pj + &
-              m_frootn_to_litter_fire(p)*fr_fcel(itype)*fr_prof_pj)* wt_col
-
-          sum3 = sum3 + &
+        m_n_to_litr_lig_fire(c,j)=m_n_to_litr_lig_fire(c,j) + &
              (m_leafn_to_litter_fire(p)*lf_flig(itype)*lprof_pj + &
-              m_frootn_to_litter_fire(p)*fr_flig(itype)*fr_prof_pj)* wt_col
-          end do
-          m_n_to_litr_met_fire(c,j) = sum1
-          m_n_to_litr_cel_fire(c,j) = sum2
-          m_n_to_litr_lig_fire(c,j) = sum3
-     end do
-   end do
+             m_frootn_to_litter_fire(p)*fr_flig(itype)*fr_prof_pj)* wt_col
 
-   !$acc parallel loop independent gang worker collapse(2) default(present) private(c,sum1,sum2,sum3)
-   do j = 1,nlevdecomp
-     do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = m_p_to_litr_met_fire(c,j);
-         sum2 = m_p_to_litr_cel_fire(c,j);
-         sum3 = m_p_to_litr_lig_fire(c,j);
-
-         !$acc loop vector reduction(+:sum1,sum2,sum3) private(wt_col,itype,lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj)
-         do p = col_pp%pfti(c), col_pp%pftf(c)
-          wt_col     = veg_pp%wtcol(p)
-          if(wt_col == 0._r8) cycle 
-          itype      = veg_pp%itype(p)
-          lprof_pj   = leaf_prof(p,j)
-          fr_prof_pj = froot_prof(p,j)
-          cr_prof_pj = croot_prof(p,j)
-          st_prof_pj = stem_prof(p,j)
-          ! add phosphorus
-          sum1 = sum1 + &
+         ! add phosphorus
+         m_p_to_litr_met_fire(c,j)=m_p_to_litr_met_fire(c,j) + &
               ((m_leafp_to_litter_fire(p)*lf_flab(itype) &
               +m_leafp_storage_to_litter_fire(p) + m_ppool_to_litter_fire(p) + &
               m_leafp_xfer_to_litter_fire(p)+m_retransp_to_litter_fire(p)) &
@@ -1419,81 +1345,93 @@ contains
               m_livecrootp_xfer_to_litter_fire(p) &
               +m_deadcrootp_storage_to_litter_fire(p) + &
               m_deadcrootp_xfer_to_litter_fire(p))* cr_prof_pj)* wt_col
-
-           sum2 = sum2 + &
+         m_p_to_litr_cel_fire(c,j)=m_p_to_litr_cel_fire(c,j) + &
               (m_leafp_to_litter_fire(p)*lf_fcel(itype)*lprof_pj + &
               m_frootp_to_litter_fire(p)*fr_fcel(itype)*fr_prof_pj)* wt_col
-
-           sum3 = sum3 + &
+         m_p_to_litr_lig_fire(c,j)=m_p_to_litr_lig_fire(c,j) + &
               (m_leafp_to_litter_fire(p)*lf_flig(itype)*lprof_pj + &
               m_frootp_to_litter_fire(p)*fr_flig(itype)*fr_prof_pj)* wt_col
-         end do
-         m_p_to_litr_met_fire(c,j) = sum1;
-         m_p_to_litr_cel_fire(c,j) = sum2;
-         m_p_to_litr_lig_fire(c,j) = sum3;
+
+        end do
      end do
-   end do
+     !
+     ! vertically-resolved decomposing C/N fire loss
+     ! column loop
+     ! add phosphorus
+     do fc = 1,num_soilc
+        c = filter_soilc(fc)
 
-   ! vertically-resolved decomposing C/N fire loss
-   ! column loop
-   ! add phosphorus
-   !$acc parallel loop independent gang worker collapse(2) default(present)
-   do l = 1, ndecomp_pools
-     do j = 1, nlevdecomp
-        !$acc loop vector independent private(c,baf_crop_sc,f)
-        do fc = 1,num_soilc
-             ! change CC for litter from 0.4_r8 to 0.5_r8 and CC for CWD from 0.2_r8
-             ! to 0.25_r8 according to Li et al.(2014)
-             c = filter_soilc(fc)
-             baf_crop_sc = baf_crop(c)
-             f = farea_burned(c)
+        baf_crop_sc = baf_crop(c)
+        f = farea_burned(c)
+
+        ! change CC for litter from 0.4_r8 to 0.5_r8 and CC for CWD from 0.2_r8
+        ! to 0.25_r8 according to Li et al.(2014)
+        do j = 1, nlevdecomp
+           ! carbon fluxes
+           do l = 1, ndecomp_pools
               if ( is_litter(l) ) then
                  m_decomp_cpools_to_fire_vr(c,j,l) = decomp_cpools_vr(c,j,l) * f * 0.5_r8
-                 m_decomp_npools_to_fire_vr(c,j,l) = decomp_npools_vr(c,j,l) * f * 0.5_r8
-                 m_decomp_ppools_to_fire_vr(c,j,l) = decomp_ppools_vr(c,j,l) * f * 0.5_r8
               end if
               if ( is_cwd(l) ) then
-                 m_decomp_cpools_to_fire_vr(c,j,l) = decomp_cpools_vr(c,j,l)*(f-baf_crop_sc) * 0.25_r8
-                 m_decomp_npools_to_fire_vr(c,j,l) = decomp_npools_vr(c,j,l)*(f-baf_crop_sc) * 0.25_r8
-                 m_decomp_ppools_to_fire_vr(c,j,l) = decomp_ppools_vr(c,j,l)*(f-baf_crop_sc) * 0.25_r8
+                 m_decomp_cpools_to_fire_vr(c,j,l) = decomp_cpools_vr(c,j,l) * &
+                      (f-baf_crop_sc) * 0.25_r8
 
                  if (spinup_state == 1) then
                    m_decomp_cpools_to_fire_vr(c,j,l) = m_decomp_cpools_to_fire_vr(c,j,l) * &
-                        decomp_cascade_con%spinup_factor(l)
-                   !
+                     decomp_cascade_con%spinup_factor(l)
+                   if (kyr >= 40) m_decomp_cpools_to_fire_vr(c,j,l) = &
+                     m_decomp_cpools_to_fire_vr(c,j,l) / cnstate_vars%scalaravg_col(c,j)
+                 end if
+              end if
+           end do
+
+           ! nitrogen fluxes
+           do l = 1, ndecomp_pools
+              if ( is_litter(l) ) then
+                 m_decomp_npools_to_fire_vr(c,j,l) = decomp_npools_vr(c,j,l) * f * 0.5_r8
+              end if
+              if ( is_cwd(l) ) then
+                 m_decomp_npools_to_fire_vr(c,j,l) = decomp_npools_vr(c,j,l) * &
+                      (f-baf_crop_sc) * 0.25_r8
+                 if (spinup_state == 1) then
                    m_decomp_npools_to_fire_vr(c,j,l) = m_decomp_npools_to_fire_vr(c,j,l) * &
-                        decomp_cascade_con%spinup_factor(l)
-                   if (year_curr >= 40) then
-                      m_decomp_cpools_to_fire_vr(c,j,l) = &
-                              m_decomp_cpools_to_fire_vr(c,j,l) / cnstate_vars%scalaravg_col(c,j)
-                      !
-                      m_decomp_npools_to_fire_vr(c,j,l) = &
-                              m_decomp_npools_to_fire_vr(c,j,l) / cnstate_vars%scalaravg_col(c,j)
-                   end if
+                     decomp_cascade_con%spinup_factor(l)
+                   if (kyr >= 40) m_decomp_npools_to_fire_vr(c,j,l) = &
+                     m_decomp_npools_to_fire_vr(c,j,l) / cnstate_vars%scalaravg_col(c,j)
                  end if
+             end if
+           end do
+
+           ! phosphorus fluxes - loss due to fire
+           do l = 1, ndecomp_pools
+              if ( is_litter(l) ) then
+                 m_decomp_ppools_to_fire_vr(c,j,l) = decomp_ppools_vr(c,j,l) * f * 0.5_r8
+              end if
+              if ( is_cwd(l) ) then
+                 m_decomp_ppools_to_fire_vr(c,j,l) = decomp_ppools_vr(c,j,l) * &
+                      (f-baf_crop_sc) * 0.25_r8
               end if
-           end do ! end of column loop
+           end do
 
-        end do !end of nlevdecomp loop
-     end do  ! decomp_pools loop
+        end do
+     end do  ! end of column loop
 
      ! carbon loss due to deforestation fires
+
      if (transient_landcover) then    !true when landuse data is used
-        if( .not. (mon_curr == 1 .and. day_curr == 1 .and. secs_curr == 0) )then
-           !$acc parallel loop gang vector independent default(present)
-           do fc = 1,num_soilc
-             c = filter_soilc(fc)
-             lfc2(c)=0._r8
-             if( trotr1_col(c)+trotr2_col(c) > 0.6_r8 .and. dtrotr_col(c) > 0._r8 .and. &
+        do fc = 1,num_soilc
+           c = filter_soilc(fc)
+           lfc2(c)=0._r8
+           if( .not. (kmo == 1 .and. kda == 1 .and. mcsec == 0) )then
+              if( trotr1_col(c)+trotr2_col(c) > 0.6_r8 .and. dtrotr_col(c) > 0._r8 .and. &
                    lfc(c) > 0._r8 .and. fbac1(c) == 0._r8) then
-                 !
                  lfc2(c) = max(0._r8, min(lfc(c), (farea_burned(c)-baf_crop(c) - &
-                      baf_peatf(c))/2.0*dtime_mod))/(dtrotr_col(c)*dayspyr_mod*secspday/dtime_mod)/dtime_mod
+                      baf_peatf(c))/2.0*dt))/(dtrotr_col(c)*dayspyr*secspday/dt)/dt
                  lfc(c)  = lfc(c) - max(0._r8, min(lfc(c), (farea_burned(c)-baf_crop(c) - &
-                      baf_peatf(c))*dtime_mod/2.0_r8))
-             end if
-          end do
-        end if
+                      baf_peatf(c))*dt/2.0_r8))
+              end if
+           end if
+        end do
      end if
      !
      ! Carbon loss due to peat fires
@@ -1501,7 +1439,6 @@ contains
      ! somc_fire is not connected to clm45 soil carbon pool, ie does not decrease
      ! soil carbon b/c clm45 soil carbon was very low in several peatland grids
      !
-     !$acc parallel loop independent gang vector private(c) default(present)
      do fc = 1,num_soilc
         c = filter_soilc(fc)
         g = col_pp%gridcell(c)
@@ -1516,8 +1453,6 @@ contains
      ! They will be added here in proportion to the carbon emission
      ! Emission factors differ for various fire types
 
-     !$acc exit data delete(m_veg,transient_landcover,sum1,sum2,sum3)
-
    end associate
 
  end subroutine FireFluxes
diff --git a/components/elm/src/biogeochem/GapMortalityMod.F90 b/components/elm/src/biogeochem/GapMortalityMod.F90
index e0c12fa94c..90648ebcc3 100644
--- a/components/elm/src/biogeochem/GapMortalityMod.F90
+++ b/components/elm/src/biogeochem/GapMortalityMod.F90
@@ -18,7 +18,7 @@ module GapMortalityMod
   use VegetationDataType  , only : veg_cs, veg_cf, veg_ns, veg_nf
   use VegetationDataType  , only : veg_ps, veg_pf
 
-  use elm_varctl          , only : nu_com, iulog 
+  use elm_varctl          , only : nu_com
   use timeinfoMod , only : dayspyr_mod
   !
   implicit none
@@ -84,6 +84,7 @@ contains
     ! Gap-phase mortality routine for coupled carbon-nitrogen code (CN)
     !
     ! !USES:
+    !$acc routine seq
     use elm_varcon       , only: secspday
     use pftvarcon        , only: npcropmin
     use elm_varctl       , only: spinup_state, spinup_mortality_factor
@@ -96,32 +97,32 @@ contains
     type(cnstate_type)       , intent(inout) :: cnstate_vars
     !
     ! !LOCAL VARIABLES:
-    integer :: p,c           ! patch and column index
+    integer :: p             ! patch index
     integer :: fp            ! patch filter index
+    real(r8):: am            ! rate for fractional mortality (1/yr)
     real(r8):: m             ! rate for fractional mortality (1/s)
     real(r8):: mort_max      ! asymptotic max mortality rate (/yr)
-    real(r8):: am            ! rate for fractional mortality (1/yr)
+    real(r8):: k_mort = 0.3  ! coeff of growth efficiency in mortality equation
+    real(r8):: dayspyr
     !-----------------------------------------------------------------------
 
     associate(                                                       &
-         ivt      =>  veg_pp%itype    , & ! Input:  [integer  (:) ]  pft vegetation type
-         woody    =>  veg_vp%woody    , & ! Input:  [real(r8) (:) ]  binary flag for woody lifeform
-         k_mort   =>  CNGapMortParamsInst%k_mort & ! set coeff of growth efficiency in mortality equation
+         ivt                                 =>    veg_pp%itype    , & ! Input:  [integer  (:) ]  pft vegetation type
+         woody                               =>    veg_vp%woody      & ! Input:  [real(r8) (:) ]  binary flag for woody lifeform
          )
 
-      ! ! set the mortality rate based on annual rate
+      dayspyr = dayspyr_mod
+      ! set the mortality rate based on annual rate
       am = CNGapMortParamsInst%am
-      ! ! set coeff of growth efficiency in mortality equation
-      ! k_mort = CNGapMortParamsInst%k_mort
-      !$acc enter data create(am, m)
+      ! set coeff of growth efficiency in mortality equation
+      k_mort = CNGapMortParamsInst%k_mort
 
       if (nu_com .eq. 'RD') then
-         call mortality_rate_soilorder(num_soilp,filter_soilp, cnstate_vars)
+          call mortality_rate_soilorder(num_soilp,filter_soilp,cnstate_vars)
       end if
 
 
       ! patch loop
-      !$acc parallel loop independent gang vector default(present) private(p,am,m)
       do fp = 1,num_soilp
          p = filter_soilp(fp)
 
@@ -130,7 +131,7 @@ contains
          end if
 
 
-        m  = am/(dayspyr_mod * secspday)
+        m  = am/(dayspyr * secspday)
 
          !------------------------------------------------------
          ! patch-level gap mortality carbon fluxes
@@ -247,7 +248,6 @@ contains
 
       end do ! end of pft loop
 
-      !$acc exit data delete(am, m)
       ! gather all pft-level litterfall fluxes to the column
       ! for litter C and N inputs
 
@@ -261,6 +261,7 @@ contains
   subroutine CNGapPftToColumn ( &
        num_soilc, filter_soilc, &
        cnstate_vars)
+    !$acc routine seq
     ! !DESCRIPTION:
     ! called in the middle of CNGapMoratlity to gather all pft-level gap mortality fluxes
     ! to the column level and assign them to the three litter pools
@@ -274,9 +275,7 @@ contains
     type(cnstate_type)      , intent(in)    :: cnstate_vars
     !
     ! !LOCAL VARIABLES:
-    real(r8) :: wt_col, lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj
-    integer  :: fp,c,pi,p,j,i_ivt,fc   ! indices
-    real(r8) :: sum1, sum2, sum3, sum4 ! reduction variables
+    integer :: fc,c,pi,p,j               ! indices
     !-----------------------------------------------------------------------
 
     associate(                                                                              &
@@ -377,247 +376,203 @@ contains
 
          )
 
-      !$acc enter data create(sum1,sum2,sum3,sum4)
-
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1,sum2,sum3,sum4,c)
       do j = 1,nlevdecomp
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            sum1 = gap_mortality_c_to_litr_met_c(c,j)
-            sum2 = gap_mortality_c_to_litr_cel_c(c,j)
-            sum3 = gap_mortality_c_to_litr_lig_c(c,j)
-            sum4 = gap_mortality_c_to_cwdc(c,j)
-            !$acc loop vector reduction(+:sum1,sum2,sum3,sum4) private(wt_col,i_ivt,lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj)
-            do p = col_pp%pfti(c), col_pp%pftf(c)
-               if ( veg_pp%active(p) ) then
-                  i_ivt = ivt(p)
-                  wt_col = wtcol(p)
-                  lprof_pj   = wt_col * leaf_prof(p,j)
-                  fr_prof_pj = wt_col * froot_prof(p,j)
-                  cr_prof_pj = wt_col * croot_prof(p,j)
-                  st_prof_pj = wt_col * stem_prof(p,j)
-
-                  sum1 = sum1 +  m_leafc_to_litter(p) * lf_flab(i_ivt) * lprof_pj &
-                       +  m_frootc_to_litter(p) * fr_flab(i_ivt)* fr_prof_pj &
-                       + (m_cpool_to_litter(p) + m_leafc_storage_to_litter(p) + m_gresp_storage_to_litter(p)) * lprof_pj &
-                       +  m_frootc_storage_to_litter(p) *  fr_prof_pj &
-                       + (m_livestemc_storage_to_litter(p) + m_deadstemc_storage_to_litter(p))  *  st_prof_pj &
-                       + (m_livecrootc_storage_to_litter(p) + m_deadcrootc_storage_to_litter(p))*  cr_prof_pj &
-                       + (m_leafc_xfer_to_litter(p) + m_gresp_xfer_to_litter(p)) *  lprof_pj &
-                       +  m_frootc_xfer_to_litter(p) * fr_prof_pj &
-                       + (m_livestemc_xfer_to_litter(p) + m_deadstemc_xfer_to_litter(p))  *  st_prof_pj  &
-                       + (m_livecrootc_xfer_to_litter(p) + m_deadcrootc_xfer_to_litter(p)) *  cr_prof_pj
-
-                  sum2 = sum2 + m_leafc_to_litter(p) * lf_fcel(i_ivt) * lprof_pj &
-                        + m_frootc_to_litter(p) * fr_fcel(i_ivt) * fr_prof_pj
-                  !
-                  sum3 = sum3 + m_leafc_to_litter(p) * lf_flig(i_ivt) *  lprof_pj &
-                        + m_frootc_to_litter(p) * fr_flig(i_ivt) *  fr_prof_pj
-                  !
-                  ! wood gap mortality carbon fluxes
-                  sum4 = sum4 + (m_livestemc_to_litter(p) + m_deadstemc_to_litter(p)) * st_prof_pj &
-                     + (m_livecrootc_to_litter(p) + m_deadcrootc_to_litter(p)) *  cr_prof_pj
+         do pi = 1,maxpatch_pft
+            do fc = 1,num_soilc
+               c = filter_soilc(fc)
+
+               if (pi <=  col_pp%npfts(c)) then
+                  p = col_pp%pfti(c) + pi - 1
+
+                  if (veg_pp%active(p)) then
+
+                     ! leaf gap mortality carbon fluxes
+                     gap_mortality_c_to_litr_met_c(c,j) = gap_mortality_c_to_litr_met_c(c,j) + &
+                          m_leafc_to_litter(p) * lf_flab(ivt(p)) * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_c_to_litr_cel_c(c,j) = gap_mortality_c_to_litr_cel_c(c,j) + &
+                          m_leafc_to_litter(p) * lf_fcel(ivt(p)) * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_c_to_litr_lig_c(c,j) = gap_mortality_c_to_litr_lig_c(c,j) + &
+                          m_leafc_to_litter(p) * lf_flig(ivt(p)) * wtcol(p) * leaf_prof(p,j)
+
+                     ! fine root gap mortality carbon fluxes
+                     gap_mortality_c_to_litr_met_c(c,j) = gap_mortality_c_to_litr_met_c(c,j) + &
+                          m_frootc_to_litter(p) * fr_flab(ivt(p)) * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_c_to_litr_cel_c(c,j) = gap_mortality_c_to_litr_cel_c(c,j) + &
+                          m_frootc_to_litter(p) * fr_fcel(ivt(p)) * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_c_to_litr_lig_c(c,j) = gap_mortality_c_to_litr_lig_c(c,j) + &
+                          m_frootc_to_litter(p) * fr_flig(ivt(p)) * wtcol(p) * froot_prof(p,j)
+
+                     ! wood gap mortality carbon fluxes
+                     gap_mortality_c_to_cwdc(c,j)  = gap_mortality_c_to_cwdc(c,j)  + &
+                          (m_livestemc_to_litter(p) + m_deadstemc_to_litter(p))  * wtcol(p) * stem_prof(p,j)
+                     gap_mortality_c_to_cwdc(c,j) = gap_mortality_c_to_cwdc(c,j) + &
+                          (m_livecrootc_to_litter(p) + m_deadcrootc_to_litter(p)) * wtcol(p) * croot_prof(p,j)
+                     ! storage gap mortality carbon fluxes
+                     gap_mortality_c_to_litr_met_c(c,j)      = gap_mortality_c_to_litr_met_c(c,j)      + &
+                          (m_cpool_to_litter(p) + m_leafc_storage_to_litter(p) + m_gresp_storage_to_litter(p)) * wtcol(p)&
+                          * leaf_prof(p,j)
+                     gap_mortality_c_to_litr_met_c(c,j)     = gap_mortality_c_to_litr_met_c(c,j)     + &
+                          m_frootc_storage_to_litter(p)     * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_c_to_litr_met_c(c,j)  = gap_mortality_c_to_litr_met_c(c,j)  + &
+                          (m_livestemc_storage_to_litter(p) + m_deadstemc_storage_to_litter(p))  * wtcol(p) * stem_prof(p,j)
+                     gap_mortality_c_to_litr_met_c(c,j) = gap_mortality_c_to_litr_met_c(c,j) + &
+                          (m_livecrootc_storage_to_litter(p) + m_deadcrootc_storage_to_litter(p)) * wtcol(p) * croot_prof(p,j)
+
+                     ! transfer gap mortality carbon fluxes
+                     gap_mortality_c_to_litr_met_c(c,j)      = gap_mortality_c_to_litr_met_c(c,j)      + &
+                          (m_leafc_xfer_to_litter(p) + m_gresp_xfer_to_litter(p))     * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_c_to_litr_met_c(c,j)     = gap_mortality_c_to_litr_met_c(c,j)     + &
+                          m_frootc_xfer_to_litter(p)     * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_c_to_litr_met_c(c,j)  = gap_mortality_c_to_litr_met_c(c,j)  + &
+                          (m_livestemc_xfer_to_litter(p) + m_deadstemc_xfer_to_litter(p))  * wtcol(p) * stem_prof(p,j)
+                     gap_mortality_c_to_litr_met_c(c,j) = gap_mortality_c_to_litr_met_c(c,j) + &
+                          (m_livecrootc_xfer_to_litter(p) + m_deadcrootc_xfer_to_litter(p)) * wtcol(p) * croot_prof(p,j)
+
+                     ! leaf gap mortality nitrogen fluxes
+                     gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
+                          m_leafn_to_litter(p) * lf_flab(ivt(p)) * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_n_to_litr_cel_n(c,j) = gap_mortality_n_to_litr_cel_n(c,j) + &
+                          m_leafn_to_litter(p) * lf_fcel(ivt(p)) * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_n_to_litr_lig_n(c,j) = gap_mortality_n_to_litr_lig_n(c,j) + &
+                          m_leafn_to_litter(p) * lf_flig(ivt(p)) * wtcol(p) * leaf_prof(p,j)
+
+                     ! fine root litter nitrogen fluxes
+                     gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
+                          m_frootn_to_litter(p) * fr_flab(ivt(p)) * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_n_to_litr_cel_n(c,j) = gap_mortality_n_to_litr_cel_n(c,j) + &
+                          m_frootn_to_litter(p) * fr_fcel(ivt(p)) * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_n_to_litr_lig_n(c,j) = gap_mortality_n_to_litr_lig_n(c,j) + &
+                          m_frootn_to_litter(p) * fr_flig(ivt(p)) * wtcol(p) * froot_prof(p,j)
+
+                     ! wood gap mortality nitrogen fluxes
+                     gap_mortality_n_to_cwdn(c,j)  = gap_mortality_n_to_cwdn(c,j)  + &
+                          (m_livestemn_to_litter(p) + m_deadstemn_to_litter(p))  * wtcol(p) * stem_prof(p,j)
+                     gap_mortality_n_to_cwdn(c,j) = gap_mortality_n_to_cwdn(c,j) + &
+                          (m_livecrootn_to_litter(p) + m_deadcrootn_to_litter(p)) * wtcol(p) * croot_prof(p,j)
+
+                     ! retranslocated N pool gap mortality fluxes
+                     gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
+                          m_retransn_to_litter(p) * wtcol(p) * leaf_prof(p,j)
+                     ! storage N pool gap mortality fluxes
+                     gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
+                          m_npool_to_litter(p) * wtcol(p) * leaf_prof(p,j)
+
+                     ! storage gap mortality nitrogen fluxes
+                     gap_mortality_n_to_litr_met_n(c,j)      = gap_mortality_n_to_litr_met_n(c,j)      + &
+                          m_leafn_storage_to_litter(p)      * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_n_to_litr_met_n(c,j)     = gap_mortality_n_to_litr_met_n(c,j)     + &
+                          m_frootn_storage_to_litter(p)     * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_n_to_litr_met_n(c,j)  = gap_mortality_n_to_litr_met_n(c,j)  + &
+                          (m_livestemn_storage_to_litter(p) + m_deadstemn_storage_to_litter(p))  * wtcol(p) * stem_prof(p,j)
+                     gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
+                          (m_livecrootn_storage_to_litter(p) + m_deadcrootn_storage_to_litter(p)) * wtcol(p) * croot_prof(p,j)
+
+                     ! transfer gap mortality nitrogen fluxes
+                     gap_mortality_n_to_litr_met_n(c,j)      = gap_mortality_n_to_litr_met_n(c,j)      + &
+                          m_leafn_xfer_to_litter(p)      * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_n_to_litr_met_n(c,j)     = gap_mortality_n_to_litr_met_n(c,j)     + &
+                          m_frootn_xfer_to_litter(p)     * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_n_to_litr_met_n(c,j)  = gap_mortality_n_to_litr_met_n(c,j)  + &
+                          (m_livestemn_xfer_to_litter(p) + m_deadstemn_xfer_to_litter(p))  * wtcol(p) * stem_prof(p,j)
+                     gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
+                          (m_livecrootn_xfer_to_litter(p) + m_deadcrootn_xfer_to_litter(p)) * wtcol(p) * croot_prof(p,j)
+
+                     ! leaf gap mortality phosphorus fluxes
+                     gap_mortality_p_to_litr_met_p(c,j) = gap_mortality_p_to_litr_met_p(c,j) + &
+                          m_leafp_to_litter(p) * lf_flab(ivt(p)) * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_p_to_litr_cel_p(c,j) = gap_mortality_p_to_litr_cel_p(c,j) + &
+                          m_leafp_to_litter(p) * lf_fcel(ivt(p)) * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_p_to_litr_lig_p(c,j) = gap_mortality_p_to_litr_lig_p(c,j) + &
+                          m_leafp_to_litter(p) * lf_flig(ivt(p)) * wtcol(p) * leaf_prof(p,j)
+
+                     ! fine root litter phosphorus fluxes
+                     gap_mortality_p_to_litr_met_p(c,j) = gap_mortality_p_to_litr_met_p(c,j) + &
+                          m_frootp_to_litter(p) * fr_flab(ivt(p)) * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_p_to_litr_cel_p(c,j) = gap_mortality_p_to_litr_cel_p(c,j) + &
+                          m_frootp_to_litter(p) * fr_fcel(ivt(p)) * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_p_to_litr_lig_p(c,j) = gap_mortality_p_to_litr_lig_p(c,j) + &
+                          m_frootp_to_litter(p) * fr_flig(ivt(p)) * wtcol(p) * froot_prof(p,j)
+
+                     ! wood gap mortality phosphorus fluxes
+                     gap_mortality_p_to_cwdp(c,j)  = gap_mortality_p_to_cwdp(c,j)  + &
+                          (m_livestemp_to_litter(p) + m_deadstemp_to_litter(p))  * wtcol(p) * stem_prof(p,j)
+                     gap_mortality_p_to_cwdp(c,j) = gap_mortality_p_to_cwdp(c,j) + &
+                          (m_livecrootp_to_litter(p) + m_deadcrootp_to_litter(p)) * wtcol(p) * croot_prof(p,j)
+
+                     ! retranslocated N pool gap mortality fluxes
+                     gap_mortality_p_to_litr_met_p(c,j) = gap_mortality_p_to_litr_met_p(c,j) + &
+                          m_retransp_to_litter(p) * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_p_to_litr_met_p(c,j) = gap_mortality_p_to_litr_met_p(c,j) + &
+                          m_ppool_to_litter(p) * wtcol(p) * leaf_prof(p,j)
+
+
+                     ! storage gap mortality phosphorus fluxes
+                     gap_mortality_p_to_litr_met_p(c,j)      = gap_mortality_p_to_litr_met_p(c,j)      + &
+                          m_leafp_storage_to_litter(p)      * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_p_to_litr_met_p(c,j)     = gap_mortality_p_to_litr_met_p(c,j)     + &
+                          m_frootp_storage_to_litter(p)     * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_p_to_litr_met_p(c,j)  = gap_mortality_p_to_litr_met_p(c,j)  + &
+                          (m_livestemp_storage_to_litter(p) + m_deadstemp_storage_to_litter(p))  * wtcol(p) * stem_prof(p,j)
+                     gap_mortality_p_to_litr_met_p(c,j) = gap_mortality_p_to_litr_met_p(c,j) + &
+                          (m_livecrootp_storage_to_litter(p) + m_deadcrootp_storage_to_litter(p)) * wtcol(p) * croot_prof(p,j)
+
+                     ! transfer gap mortality phosphorus fluxes
+                     gap_mortality_p_to_litr_met_p(c,j)      = gap_mortality_p_to_litr_met_p(c,j)      + &
+                          m_leafp_xfer_to_litter(p)      * wtcol(p) * leaf_prof(p,j)
+                     gap_mortality_p_to_litr_met_p(c,j)     = gap_mortality_p_to_litr_met_p(c,j)     + &
+                          m_frootp_xfer_to_litter(p)     * wtcol(p) * froot_prof(p,j)
+                     gap_mortality_p_to_litr_met_p(c,j)  = gap_mortality_p_to_litr_met_p(c,j)  + &
+                          (m_livestemp_xfer_to_litter(p) + m_deadstemp_xfer_to_litter(p))  * wtcol(p) * stem_prof(p,j)
+                     gap_mortality_p_to_litr_met_p(c,j) = gap_mortality_p_to_litr_met_p(c,j) + &
+                          (m_livecrootp_xfer_to_litter(p) + m_deadcrootp_xfer_to_litter(p)) * wtcol(p) * croot_prof(p,j)
+
+                  end if
                end if
-            end do
-            gap_mortality_c_to_litr_met_c(c,j) = sum1;
-            gap_mortality_c_to_litr_cel_c(c,j) = sum2;
-            gap_mortality_c_to_litr_lig_c(c,j) = sum3;
-            gap_mortality_c_to_cwdc(c,j)       = sum4;
-         end do
-      end do
-
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1,sum2,sum3,sum4,c)
-      do j = 1,nlevdecomp
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            sum1 = gap_mortality_n_to_litr_met_n(c,j)
-            sum2 = gap_mortality_n_to_litr_cel_n(c,j)
-            sum3 = gap_mortality_n_to_litr_lig_n(c,j)
-            sum4 = gap_mortality_n_to_cwdn(c,j)
-
-            !$acc loop vector reduction(+:sum1,sum2,sum3,sum4) private(wt_col,i_ivt,lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj)
-            do p = col_pp%pfti(c), col_pp%pftf(c)
-               if ( veg_pp%active(p) ) then
-                  i_ivt = ivt(p)
-                  wt_col = wtcol(p)
-                  lprof_pj   = wt_col * leaf_prof(p,j)
-                  fr_prof_pj = wt_col * froot_prof(p,j)
-                  cr_prof_pj = wt_col * croot_prof(p,j)
-                  st_prof_pj = wt_col * stem_prof(p,j)
-                  ! leaf gap mortality nitrogen fluxes
-                  sum1 = sum1 + &
-                       m_leafn_to_litter(p) * lf_flab(i_ivt) *  lprof_pj &
-                     + m_frootn_to_litter(p) * fr_flab(i_ivt) *  fr_prof_pj &
-                     + m_retransn_to_litter(p) * lprof_pj &
-                     + m_npool_to_litter(p) * lprof_pj &
-                     + m_leafn_storage_to_litter(p) * lprof_pj &
-                     + m_frootn_storage_to_litter(p)* fr_prof_pj &
-                     +(m_livestemn_storage_to_litter(p) + m_deadstemn_storage_to_litter(p)) * st_prof_pj &
-                     +(m_livecrootn_storage_to_litter(p) + m_deadcrootn_storage_to_litter(p))* cr_prof_pj &
-                     + m_leafn_xfer_to_litter(p) * lprof_pj &
-                     + m_frootn_xfer_to_litter(p)* fr_prof_pj &
-                     +(m_livestemn_xfer_to_litter(p) + m_deadstemn_xfer_to_litter(p)) * st_prof_pj &
-                     +(m_livecrootn_xfer_to_litter(p) + m_deadcrootn_xfer_to_litter(p)) * cr_prof_pj
-                  !
-                  sum2 = sum2  &
-                      + m_leafn_to_litter(p) * lf_fcel(i_ivt) * lprof_pj &
-                      + m_frootn_to_litter(p) * fr_fcel(i_ivt)* fr_prof_pj
-                  !
-                  sum3 = sum3 &
-                      + m_leafn_to_litter(p) * lf_flig(i_ivt) * lprof_pj &
-                      + m_frootn_to_litter(p) * fr_flig(i_ivt) * fr_prof_pj
-                  !
-                  sum4 = sum4 &
-                      + (m_livestemn_to_litter(p) + m_deadstemn_to_litter(p))  *  st_prof_pj &
-                      +(m_livecrootn_to_litter(p) + m_deadcrootn_to_litter(p)) *  cr_prof_pj
 
-               end if
             end do
-            gap_mortality_n_to_litr_met_n(c,j) = sum1
-            gap_mortality_n_to_litr_cel_n(c,j) = sum2
-            gap_mortality_n_to_litr_lig_n(c,j) = sum3
-            gap_mortality_n_to_cwdn(c,j)  = sum4
          end do
       end do
 
-
-                 !  !NOTE: these cause nonBFB errors.
-                 ! ! retranslocated N pool gap mortality fluxes
-                 ! gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
-                 !      m_retransn_to_litter(p) * wtcol(p) * leaf_prof(p,j)
-                 ! ! storage N pool gap mortality fluxes
-                 ! gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
-                 !      m_npool_to_litter(p) * wtcol(p) * leaf_prof(p,j)
-
-                 ! storage gap mortality nitrogen fluxes
-                 ! gap_mortality_n_to_litr_met_n(c,j)      = gap_mortality_n_to_litr_met_n(c,j)      + &
-                 !     m_leafn_storage_to_litter(p)      * wtcol(p) * leaf_prof(p,j)
-                 ! gap_mortality_n_to_litr_met_n(c,j)     = gap_mortality_n_to_litr_met_n(c,j)     + &
-                 !     m_frootn_storage_to_litter(p)     * wtcol(p) * froot_prof(p,j)
-                 ! gap_mortality_n_to_litr_met_n(c,j)  = gap_mortality_n_to_litr_met_n(c,j)  + &
-                 !     (m_livestemn_storage_to_litter(p) + m_deadstemn_storage_to_litter(p))  * wtcol(p) * stem_prof(p,j)
-                 ! gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
-                 !     (m_livecrootn_storage_to_litter(p) + m_deadcrootn_storage_to_litter(p)) * wtcol(p) * croot_prof(p,j)
-
-                 ! transfer gap mortality nitrogen fluxes
-                 ! gap_mortality_n_to_litr_met_n(c,j)      = gap_mortality_n_to_litr_met_n(c,j)      + &
-                 !     m_leafn_xfer_to_litter(p)      * wtcol(p) * leaf_prof(p,j)
-                 ! gap_mortality_n_to_litr_met_n(c,j)     = gap_mortality_n_to_litr_met_n(c,j)     + &
-                 !     m_frootn_xfer_to_litter(p)     * wtcol(p) * froot_prof(p,j)
-                 ! gap_mortality_n_to_litr_met_n(c,j)  = gap_mortality_n_to_litr_met_n(c,j)  + &
-                 !     (m_livestemn_xfer_to_litter(p) + m_deadstemn_xfer_to_litter(p))  * wtcol(p) * stem_prof(p,j)
-                 ! gap_mortality_n_to_litr_met_n(c,j) = gap_mortality_n_to_litr_met_n(c,j) + &
-                 !     (m_livecrootn_xfer_to_litter(p) + m_deadcrootn_xfer_to_litter(p)) * wtcol(p) * croot_prof(p,j)
-
-               ! gap_mortality_n_to_litr_cel_n(c,j) = gap_mortality_n_to_litr_cel_n(c,j) + &
-               !     m_leafn_to_litter(p) * lf_fcel(i_ivt) *  lprof_pj
-               ! gap_mortality_n_to_litr_lig_n(c,j) = gap_mortality_n_to_litr_lig_n(c,j) + &
-               !     m_leafn_to_litter(p) * lf_flig(i_ivt) *  lprof_pj
-
-               ! fine root litter nitrogen fluxes
-
-               ! gap_mortality_n_to_litr_cel_n(c,j) = gap_mortality_n_to_litr_cel_n(c,j) + &
-               !     m_frootn_to_litter(p) * fr_fcel(i_ivt) *  fr_prof_pj
-               ! gap_mortality_n_to_litr_lig_n(c,j) = gap_mortality_n_to_litr_lig_n(c,j) + &
-               !     m_frootn_to_litter(p) * fr_flig(i_ivt) *  fr_prof_pj
-
-               ! ! wood gap mortality nitrogen fluxes
-               ! gap_mortality_n_to_cwdn(c,j)  = gap_mortality_n_to_cwdn(c,j)  + &
-               !     (m_livestemn_to_litter(p) + m_deadstemn_to_litter(p))  *  st_prof_pj
-               ! gap_mortality_n_to_cwdn(c,j) = gap_mortality_n_to_cwdn(c,j) + &
-               !     (m_livecrootn_to_litter(p) + m_deadcrootn_to_litter(p)) *  cr_prof_pj
-
-
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1,sum2,sum3,sum4,c)
-      do j = 1,nlevdecomp
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            sum1 = gap_mortality_p_to_litr_met_p(c,j)
-            sum2 = gap_mortality_p_to_litr_cel_p(c,j)
-            sum3 = gap_mortality_p_to_litr_lig_p(c,j)
-            sum4 = gap_mortality_p_to_cwdp(c,j)
-
-            !$acc loop vector reduction(+:sum1,sum2,sum3,sum4) private(wt_col,i_ivt,lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj)
-            do p = col_pp%pfti(c), col_pp%pftf(c)
-               if ( veg_pp%active(p) ) then
-                  i_ivt = ivt(p)
-                  wt_col = wtcol(p)
-                  lprof_pj   = wt_col * leaf_prof(p,j)
-                  fr_prof_pj = wt_col * froot_prof(p,j)
-                  cr_prof_pj = wt_col * croot_prof(p,j)
-                  st_prof_pj = wt_col * stem_prof(p,j)
-
-                 ! leaf gap mortality phosphorus fluxes
-                 sum1 = sum1 &
-                     + m_leafp_to_litter(p) * lf_flab(i_ivt) * lprof_pj &
-                     + m_frootp_to_litter(p) * fr_flab(i_ivt) * fr_prof_pj &
-                     + m_retransp_to_litter(p) * lprof_pj + m_ppool_to_litter(p) * lprof_pj &
-                     + m_leafp_storage_to_litter(p)  * lprof_pj &
-                     + m_frootp_storage_to_litter(p) * fr_prof_pj &
-                     +(m_livestemp_storage_to_litter(p) + m_deadstemp_storage_to_litter(p))* st_prof_pj &
-                     +(m_livecrootp_storage_to_litter(p) + m_deadcrootp_storage_to_litter(p))* cr_prof_pj &
-                     +m_leafp_xfer_to_litter(p)  *  lprof_pj + m_frootp_xfer_to_litter(p) *  fr_prof_pj &
-                     +(m_livestemp_xfer_to_litter(p) + m_deadstemp_xfer_to_litter(p))  *  st_prof_pj &
-                     +(m_livecrootp_xfer_to_litter(p) + m_deadcrootp_xfer_to_litter(p)) *  cr_prof_pj
-                 !
-                 sum2 = sum2  &
-                     + m_leafp_to_litter(p) * lf_fcel(i_ivt) *  lprof_pj &
-                     + m_frootp_to_litter(p) * fr_fcel(i_ivt) *  fr_prof_pj
-                 !
-                 sum3 = sum3 &
-                     + m_leafp_to_litter(p) * lf_flig(i_ivt) *  lprof_pj &
-                     + m_frootp_to_litter(p) * fr_flig(i_ivt) *  fr_prof_pj
-
-                 ! wood gap mortality phosphorus fluxes
-                 sum4 = sum4  &
-                     +(m_livestemp_to_litter(p) + m_deadstemp_to_litter(p))  *  st_prof_pj &
-                     +(m_livecrootp_to_litter(p) + m_deadcrootp_to_litter(p)) *  cr_prof_pj
-                 !
-             end if
-          end do
-          gap_mortality_p_to_litr_met_p(c,j) = sum1
-          gap_mortality_p_to_litr_cel_p(c,j) = sum2
-          gap_mortality_p_to_litr_lig_p(c,j) = sum3
-          gap_mortality_p_to_cwdp(c,j)  = sum4
-       end do
-    end do
-    !$acc exit data delete(sum1,sum2,sum3,sum4,wt_col,i_ivt,lprof_pj,fr_prof_pj,cr_prof_pj,st_prof_pj)
-
     end associate
 
   end subroutine CNGapPftToColumn
 
-  subroutine mortality_rate_soilorder(num_soilp, filter_soilp, cnstate_vars)
+  subroutine mortality_rate_soilorder(&
+       num_soilp, filter_soilp, &
+       cnstate_vars)
     !
     ! !DESCRIPTION:
     ! !this surroutine is to calculate mortality rate based on soil order
 
     ! USES
+      !$acc routine seq
     use pftvarcon       , only: nbrdlf_evr_trp_tree, nbrdlf_dcd_trp_tree
     use soilorder_varcon, only: r_mort_soilorder
 
     !
     ! !ARGUMENTS:
-    integer, intent(in) :: num_soilp
-    integer, intent(in) :: filter_soilp(:)
+    integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:) ! patch filter for soil points
     type(cnstate_type)       , intent(inout)    :: cnstate_vars
 
-    integer :: fp, p, c
+    ! local variables
+    integer :: p,c,fp
+
+
     associate(                                                      &
        ivt            =>    veg_pp%itype                             , & ! Input:[integer  (:)   ]  patch vegetation type
        isoilorder     =>    cnstate_vars%isoilorder               , &
        r_mort_cal     =>    cnstate_vars%r_mort_cal_patch )
 
-       !$acc parallel loop independent gang vector default(present) private(p,c)
-       do fp = 1, num_soilp
-          p =filter_soilp(fp)
+       ! loop over the patches
+       do fp = 1,num_soilp
+          p = filter_soilp(fp)
           c = veg_pp%column(p)
-          ! loop over the patches
-          if( ivt(p) == nbrdlf_evr_trp_tree .or. ivt(p) == nbrdlf_dcd_trp_tree )then
-             r_mort_cal(p) = r_mort_soilorder( isoilorder(c) )
-          else
-             r_mort_cal(p) = 0.02_r8                 ! Default mortality rate
-          endif
+               if( veg_pp%itype(p) == nbrdlf_evr_trp_tree .or. veg_pp%itype(p) == nbrdlf_dcd_trp_tree )then
+                   r_mort_cal(p) = r_mort_soilorder( isoilorder(c) )
+               else
+                   r_mort_cal(p) = 0.02_r8                 ! Default mortality rate
+               endif
        end do
 
      end associate
diff --git a/components/elm/src/biogeochem/GrowthRespMod.F90 b/components/elm/src/biogeochem/GrowthRespMod.F90
index a25b49e96f..f499dedb2e 100644
--- a/components/elm/src/biogeochem/GrowthRespMod.F90
+++ b/components/elm/src/biogeochem/GrowthRespMod.F90
@@ -11,9 +11,15 @@ module GrowthRespMod
   use VegetationPropertiesType   , only : veg_vp
   use VegetationType        , only : veg_pp
   use VegetationDataType    , only : veg_cf
+
+  !
+
   use shr_log_mod   , only : errMsg => shr_log_errMsg
+  use decompMod       , only : bounds_type
+  use ColumnDataType  , only : column_carbon_flux
   use ColumnType      , only : col_pp
 
+
   implicit none
   save
   private
@@ -33,14 +39,17 @@ contains
     ! !USES:
     !
     ! !ARGUMENTS:
-    integer , intent(in) :: num_soilp
-    integer, intent(in) :: filter_soilp(:)
+      !$acc routine seq
+    integer, intent(in) :: num_soilp       ! number of soil patches in filter
+    integer, intent(in) :: filter_soilp(:) ! filter for soil patches
     !
     ! !LOCAL VARIABLES:
-    integer :: ivt, fp,p    ! Input:  [integer (:)]  pft vegetation type
+    integer :: p                ! indices
+    integer :: fp               ! lake filter pft index
     !-----------------------------------------------------------------------
 
     associate(                                                                      &
+         ivt                           =>    veg_pp%itype                         , & ! Input:  [integer (:)]  pft vegetation type
 
          woody                         =>    veg_vp%woody                         , & ! Input:  [real(r8) (:)]  binary flag for woody lifeform (1=woody, 0=not woody)
 
@@ -89,63 +98,62 @@ contains
          )
 
       ! Loop through patches
-      ! start pft loop
-      !$acc parallel loop independent gang vector default(present)
+      ! start pft loop 
       do fp = 1,num_soilp
+
         p = filter_soilp(fp)
-        ivt = veg_pp%itype(p)
-         if (ivt >= npcropmin) then ! skip 2 generic crops
+         if (ivt(p) >= npcropmin) then ! skip 2 generic crops
 
-            cpool_livestem_gr(p)          = cpool_to_livestemc(p) * grperc(ivt)
+            cpool_livestem_gr(p)          = cpool_to_livestemc(p) * grperc(ivt(p))
 
             cpool_livestem_storage_gr(p)  = cpool_to_livestemc_storage(p) * &
-                 grperc(ivt) * grpnow(ivt)
+                 grperc(ivt(p)) * grpnow(ivt(p))
 
             transfer_livestem_gr(p)       = livestemc_xfer_to_livestemc(p) * &
-                 grperc(ivt) * (1._r8 - grpnow(ivt))
+                 grperc(ivt(p)) * (1._r8 - grpnow(ivt(p)))
 
-            cpool_grain_gr(p)             = cpool_to_grainc(p) * grperc(ivt)
+            cpool_grain_gr(p)             = cpool_to_grainc(p) * grperc(ivt(p))
 
             cpool_grain_storage_gr(p)     = cpool_to_grainc_storage(p) * &
-                 grperc(ivt) * grpnow(ivt)
+                 grperc(ivt(p)) * grpnow(ivt(p))
 
-            transfer_grain_gr(p)          = grainc_xfer_to_grainc(p) * grperc(ivt) &
-                 * (1._r8 - grpnow(ivt))
+            transfer_grain_gr(p)          = grainc_xfer_to_grainc(p) * grperc(ivt(p)) &
+                 * (1._r8 - grpnow(ivt(p)))
          end if
 
          ! leaf and fine root growth respiration
-         cpool_leaf_gr(p)          = cpool_to_leafc(p) * grperc(ivt)
-         cpool_leaf_storage_gr(p)  = cpool_to_leafc_storage(p) * grperc(ivt) * &
-              grpnow(ivt)
-         transfer_leaf_gr(p)       = leafc_xfer_to_leafc(p) * grperc(ivt) * &
-              (1._r8 - grpnow(ivt))
-         cpool_froot_gr(p)         = cpool_to_frootc(p) * grperc(ivt)
-         cpool_froot_storage_gr(p) = cpool_to_frootc_storage(p) * grperc(ivt) * &
-              grpnow(ivt)
-         transfer_froot_gr(p)      = frootc_xfer_to_frootc(p) * grperc(ivt) * &
-              (1._r8 - grpnow(ivt))
-
-         if (woody(ivt) == 1._r8) then
-            cpool_livestem_gr(p)          = cpool_to_livestemc(p) * grperc(ivt)
+         cpool_leaf_gr(p)          = cpool_to_leafc(p) * grperc(ivt(p))
+         cpool_leaf_storage_gr(p)  = cpool_to_leafc_storage(p) * grperc(ivt(p)) * &
+              grpnow(ivt(p))
+         transfer_leaf_gr(p)       = leafc_xfer_to_leafc(p) * grperc(ivt(p)) * &
+              (1._r8 - grpnow(ivt(p)))
+         cpool_froot_gr(p)         = cpool_to_frootc(p) * grperc(ivt(p))
+         cpool_froot_storage_gr(p) = cpool_to_frootc_storage(p) * grperc(ivt(p)) * &
+              grpnow(ivt(p))
+         transfer_froot_gr(p)      = frootc_xfer_to_frootc(p) * grperc(ivt(p)) * &
+              (1._r8 - grpnow(ivt(p)))
+
+         if (woody(ivt(p)) == 1._r8) then
+            cpool_livestem_gr(p)          = cpool_to_livestemc(p) * grperc(ivt(p))
             cpool_livestem_storage_gr(p)  = cpool_to_livestemc_storage(p) * &
-                 grperc(ivt) * grpnow(ivt)
+                 grperc(ivt(p)) * grpnow(ivt(p))
             transfer_livestem_gr(p)       = livestemc_xfer_to_livestemc(p) * &
-                 grperc(ivt) * (1._r8 - grpnow(ivt))
-            cpool_deadstem_gr(p)          = cpool_to_deadstemc(p) * grperc(ivt)
+                 grperc(ivt(p)) * (1._r8 - grpnow(ivt(p)))
+            cpool_deadstem_gr(p)          = cpool_to_deadstemc(p) * grperc(ivt(p))
             cpool_deadstem_storage_gr(p)  = cpool_to_deadstemc_storage(p) * &
-                 grperc(ivt) * grpnow(ivt)
+                 grperc(ivt(p)) * grpnow(ivt(p))
             transfer_deadstem_gr(p)       = deadstemc_xfer_to_deadstemc(p) * &
-                 grperc(ivt) * (1._r8 - grpnow(ivt))
-            cpool_livecroot_gr(p)         = cpool_to_livecrootc(p) * grperc(ivt)
+                 grperc(ivt(p)) * (1._r8 - grpnow(ivt(p)))
+            cpool_livecroot_gr(p)         = cpool_to_livecrootc(p) * grperc(ivt(p))
             cpool_livecroot_storage_gr(p) = cpool_to_livecrootc_storage(p) * &
-                 grperc(ivt) * grpnow(ivt)
+                 grperc(ivt(p)) * grpnow(ivt(p))
             transfer_livecroot_gr(p)      = livecrootc_xfer_to_livecrootc(p) * &
-                 grperc(ivt) * (1._r8 - grpnow(ivt))
-            cpool_deadcroot_gr(p)         = cpool_to_deadcrootc(p) * grperc(ivt)
+                 grperc(ivt(p)) * (1._r8 - grpnow(ivt(p)))
+            cpool_deadcroot_gr(p)         = cpool_to_deadcrootc(p) * grperc(ivt(p))
             cpool_deadcroot_storage_gr(p) = cpool_to_deadcrootc_storage(p) * &
-                 grperc(ivt) * grpnow(ivt)
+                 grperc(ivt(p)) * grpnow(ivt(p))
             transfer_deadcroot_gr(p)      = deadcrootc_xfer_to_deadcrootc(p) * &
-                 grperc(ivt) * (1._r8 - grpnow(ivt))
+                 grperc(ivt(p)) * (1._r8 - grpnow(ivt(p)))
          end if
 
       end do
diff --git a/components/elm/src/biogeochem/MaintenanceRespMod.F90 b/components/elm/src/biogeochem/MaintenanceRespMod.F90
index 7c2b3e1a4c..ef83ca92ff 100644
--- a/components/elm/src/biogeochem/MaintenanceRespMod.F90
+++ b/components/elm/src/biogeochem/MaintenanceRespMod.F90
@@ -17,8 +17,12 @@ module MaintenanceRespMod
   use VegetationPropertiesType      , only : veg_vp
   use SoilStateType       , only : soilstate_type
   use CanopyStateType     , only : canopystate_type
-  use ColumnDataType      , only : col_es
+  use TemperatureType     , only : temperature_type
   use PhotosynthesisType  , only : photosyns_type
+  use CNCarbonFluxType    , only : carbonflux_type
+  use CNCarbonStateType   , only : carbonstate_type
+  use CNNitrogenStateType , only : nitrogenstate_type
+  use ColumnDataType      , only : col_es
   use VegetationType      , only : veg_pp
   use VegetationDataType  , only : veg_es, veg_cs, veg_cf, veg_ns
   !
@@ -42,7 +46,7 @@ module MaintenanceRespMod
 contains
 
   !-----------------------------------------------------------------------
-   subroutine readMaintenanceRespParams (ncid )
+   subroutine readMaintenanceRespParams ( ncid )
      !
      ! !DESCRIPTION:
      ! Read parameters
@@ -66,13 +70,13 @@ contains
      call ncd_io(varname=trim(tString),data=tempr, flag='read', ncid=ncid, readvar=readv)
      if ( .not. readv ) call endrun(msg=trim(errCode)//trim(tString)//errMsg(__FILE__, __LINE__))
      br_mr_Inst = tempr
-
+     
    end subroutine readMaintenanceRespParams
 
   !-----------------------------------------------------------------------
   ! FIX(SPM,032414) this shouldn't even be called with ED on.
   !
-  subroutine MaintenanceResp(&
+  subroutine MaintenanceResp(bounds, &
        num_soilc, filter_soilc, num_soilp, filter_soilp, &
        canopystate_vars, soilstate_vars, photosyns_vars)
     !
@@ -81,6 +85,8 @@ contains
     ! !USES:
     !
     ! !ARGUMENTS:
+      !$acc routine seq
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc       ! number of soil points in column filter
     integer                  , intent(in)    :: filter_soilc(:) ! column filter for soil points
     integer                  , intent(in)    :: num_soilp       ! number of soil points in patch filter
@@ -93,9 +99,10 @@ contains
     integer :: c,p,j ! indices
     integer :: fp    ! soil filter patch index
     integer :: fc    ! soil filter column index
+    real(r8):: br_mr ! base rate (gC/gN/s)
+    real(r8):: q10   ! temperature dependence
     real(r8):: tc    ! temperature correction, 2m air temp (unitless)
-    real(r8):: tcsoi ! temperature correction by soil layer (unitless)
-    real(r8) :: sum1
+    real(r8):: tcsoi(bounds%begc:bounds%endc,nlevgrnd) ! temperature correction by soil layer (unitless)
     !-----------------------------------------------------------------------
 
     associate(                                                        &
@@ -135,36 +142,52 @@ contains
       ! Original expression is br = 0.0106 molC/(molN h)
       ! Conversion by molecular weights of C and N gives 2.525e-6 gC/(gN s)
       ! set constants
-      !br_mr = br_mr_Inst
+      br_mr = br_mr_Inst
+
       ! Peter Thornton: 3/13/09
       ! Q10 was originally set to 2.0, an arbitrary choice, but reduced to 1.5 as part of the tuning
       ! to improve seasonal cycle of atmospheric CO2 concentration in global
       ! simulatoins
 
-      ! patch loop for leaves and live wood
-      !$acc enter data create(sum1)
+      ! Set Q10 from SharedParamsMod
+      Q10 = ParamsShareInst%Q10_mr
+
+      ! column loop to calculate temperature factors in each soil layer
+      do j=1,nlevgrnd
+         do fc = 1, num_soilc
+            c = filter_soilc(fc)
+
+            ! calculate temperature corrections for each soil layer, for use in
+            ! estimating fine root maintenance respiration with depth
+            tcsoi(c,j) = Q10**((t_soisno(c,j)-SHR_CONST_TKFRZ - 20.0_r8)/10.0_r8)
+        
+         end do
+      end do
 
-      !$acc parallel loop independent gang vector private(p,tc) default(present)
+      ! patch loop for leaves and live wood
       do fp = 1, num_soilp
          p = filter_soilp(fp)
 
          ! calculate maintenance respiration fluxes in
          ! gC/m2/s for each of the live plant tissues.
          ! Leaf and live wood MR
-         tc = ParamsShareInst%Q10_mr**((t_ref2m(p)-SHR_CONST_TKFRZ - 20.0_r8)/10.0_r8)
+
+         tc = Q10**((t_ref2m(p)-SHR_CONST_TKFRZ - 20.0_r8)/10.0_r8)
          if (frac_veg_nosno(p) == 1) then
             leaf_mr(p) = lmrsun(p) * laisun(p) * 12.011e-6_r8 + &
                          lmrsha(p) * laisha(p) * 12.011e-6_r8
 
          else !nosno
              leaf_mr(p) = 0._r8
+
          end if
+
          if (woody(ivt(p)) == 1) then
-            livestem_mr(p) = livestemn(p)*br_mr_Inst*tc
-            livecroot_mr(p) = livecrootn(p)*br_mr_Inst*tc
+            livestem_mr(p) = livestemn(p)*br_mr*tc
+            livecroot_mr(p) = livecrootn(p)*br_mr*tc
          else if (ivt(p) >= npcropmin .and. livestemn(p) .gt. 0._r8) then
-            livestem_mr(p) = livestemn(p)*br_mr_Inst*tc
-            grain_mr(p) = grainn(p)*br_mr_Inst*tc
+            livestem_mr(p) = livestemn(p)*br_mr*tc
+            grain_mr(p) = grainn(p)*br_mr*tc
          end if
          if (br_xr(ivt(p)) .gt. 1e-9_r8) then
             xr(p) = cpool(p) * br_xr(ivt(p)) * tc
@@ -180,29 +203,21 @@ contains
 
       ! soil and patch loop for fine root
 
-      !$acc parallel loop independent gang worker private(p,c,sum1) default(present)
-      do fp = 1,num_soilp
-         p = filter_soilp(fp)
-         c = veg_pp%column(p)
-         ! calculate temperature corrections for each soil layer, for use in
-         ! estimating fine root maintenance respiration with depth
-
-         !$acc loop vector reduction(+:sum1) private(tcsoi)
-         do j = 1,nlevgrnd
+      do j = 1,nlevgrnd
+         do fp = 1,num_soilp
+            p = filter_soilp(fp)
+            c = veg_pp%column(p)
 
-            tcsoi = ParamsShareInst%Q10_mr**((t_soisno(c,j)-SHR_CONST_TKFRZ - 20.0_r8)/10.0_r8)
             ! Fine root MR
             ! rootfr(j) sums to 1.0 over all soil layers, and
             ! describes the fraction of root mass that is in each
             ! layer.  This is used with the layer temperature correction
             ! to estimate the total fine root maintenance respiration as a
             ! function of temperature and N content.
-            froot_mr(p) = froot_mr(p) + frootn(p)*br_mr_Inst*tcsoi*rootfr(p,j)
+            froot_mr(p) = froot_mr(p) + frootn(p)*br_mr*tcsoi(c,j)*rootfr(p,j)
          end do
       end do
 
-      !$acc exit data delete(sum1)
-
     end associate
 
   end subroutine MaintenanceResp
diff --git a/components/elm/src/biogeochem/NitrifDenitrifMod.F90 b/components/elm/src/biogeochem/NitrifDenitrifMod.F90
index 9bd47ef061..ef47133fed 100644
--- a/components/elm/src/biogeochem/NitrifDenitrifMod.F90
+++ b/components/elm/src/biogeochem/NitrifDenitrifMod.F90
@@ -109,31 +109,34 @@ contains
   end subroutine readNitrifDenitrifParams
 
   !-----------------------------------------------------------------------
-  subroutine nitrif_denitrif( num_soilc,filter_soilc,soilstate_vars, ch4_vars)
+  subroutine nitrif_denitrif(bounds, num_soilc, filter_soilc, &
+       soilstate_vars, ch4_vars)
     !
     ! !DESCRIPTION:
     !  calculate nitrification and denitrification rates
     !
     ! !USES:
+      !$acc routine seq
     use SharedParamsMod , only : anoxia_wtsat,ParamsShareInst
     !
     ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc         ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:)   ! filter for soil columns
     type(soilstate_type)     , intent(in)    :: soilstate_vars
     type(ch4_type)           , intent(in)    :: ch4_vars
     !
     ! !LOCAL VARIABLES:
-    integer  :: reflev
-    !real(r8) :: soil_hr_vr ! total soil respiration rate (g C / m3 / s)
+    integer  :: c, fc, reflev, j
+    real(r8) :: soil_hr_vr(bounds%begc:bounds%endc,1:nlevdecomp) ! total soil respiration rate (g C / m3 / s)
     real(r8) :: g_per_m3__to__ug_per_gsoil
     real(r8) :: g_per_m3_sec__to__ug_per_gsoil_day
-    real(r8) :: k_nitr_max            ! maximum nitrification rate constant (1/s)
+    real(r8) :: k_nitr_max                          ! maximum nitrification rate constant (1/s)
     real(r8) :: mu, sigma
     real(r8) :: t
-    real(r8) :: pH
+    real(r8) :: pH(bounds%begc:bounds%endc)
     !debug-- put these type structure for outing to hist files
-    real(r8) :: co2diff_con(2)        ! diffusion constants for CO2
+    real(r8) :: co2diff_con(2)                      ! diffusion constants for CO2
     real(r8) :: eps
     real(r8) :: f_a
     real(r8) :: surface_tension_water ! (J/m^2), Arah and Vinten 1995
@@ -142,16 +145,17 @@ contains
     real(r8) :: rij_kro_beta          !  Arah and Vinten 1995
     real(r8) :: rij_kro_gamma         !  Arah and Vinten 1995
     real(r8) :: rij_kro_delta         !  Arah and Vinten 1995
-    real(r8),parameter :: rho_w  = 1.e3_r8                   ! (kg/m3)
+    real(r8) :: rho_w  = 1.e3_r8                   ! (kg/m3)
     real(r8) :: r_max
-    real(r8) :: r_min
-    real(r8) :: ratio_diffusivity_water_gas
+    real(r8) :: r_min(bounds%begc:bounds%endc,1:nlevdecomp)
+    real(r8) :: ratio_diffusivity_water_gas(bounds%begc:bounds%endc,1:nlevdecomp)
     real(r8) :: om_frac
     real(r8) :: anaerobic_frac_sat, r_psi_sat, r_min_sat ! scalar values in sat portion for averaging
-    real(r8) :: organic_max             ! organic matter content (kg/m3) where
-                                        ! soil is assumed to act like peat
-    integer :: fc, j, c 
+    real(r8) :: organic_max              ! organic matter content (kg/m3) where
+                                         ! soil is assumed to act like peat
+    !character(len=32) :: subname='nitrif_denitrif' ! subroutine name
     !-----------------------------------------------------------------------
+
     associate(                                                                                     &
          watsat                        =>    soilstate_vars%watsat_col                           , & ! Input:  [real(r8) (:,:)  ]  volumetric soil water at saturation (porosity) (nlevgrnd)
          bd                            =>    soilstate_vars%bd_col                               , & ! Input:  [real(r8) (:,:)  ]  bulk density of dry soil material [kg/m3]
@@ -199,32 +203,35 @@ contains
          soil_bulkdensity              =>    col_nf%soil_bulkdensity              , & ! Output:  [real(r8) (:,:) ]  (kg soil / m3) bulk density of soil (including water)
          pot_f_nit_vr                  =>    col_nf%pot_f_nit_vr                  , & ! Output:  [real(r8) (:,:) ]  (gN/m3/s) potential soil nitrification flux
          pot_f_denit_vr                =>    col_nf%pot_f_denit_vr                , & ! Output:  [real(r8) (:,:) ]  (gN/m3/s) potential soil denitrification flux
-         n2_n2o_ratio_denit_vr         =>    col_nf%n2_n2o_ratio_denit_vr         ,  & ! Output:  [real(r8) (:,:) ]  ratio of N2 to N2O production by denitrification [gN/gN]
-         surface_tension_water => NitrifDenitrifParamsInst%surface_tension_water  , &
-
-         ! Set parameters from simple-structure model to calculate anoxic fratction (Arah and Vinten 1995)
-         rij_kro_a     => NitrifDenitrifParamsInst%rij_kro_a     ,&
-         rij_kro_alpha => NitrifDenitrifParamsInst%rij_kro_alpha ,&
-         rij_kro_beta  => NitrifDenitrifParamsInst%rij_kro_beta  ,&
-         rij_kro_gamma => NitrifDenitrifParamsInst%rij_kro_gamma ,&
-         rij_kro_delta => NitrifDenitrifParamsInst%rij_kro_delta ,&
-         organic_max => ParamsShareInst%organic_max &
+         n2_n2o_ratio_denit_vr         =>    col_nf%n2_n2o_ratio_denit_vr           & ! Output:  [real(r8) (:,:) ]  ratio of N2 to N2O production by denitrification [gN/gN]
          )
 
       ! Set maximum nitrification rate constant
+      k_nitr_max =  0.1_r8 / secspday   ! [1/sec] 10%/day  Parton et al., 2001
 
       ! Todo:  FIX(SPM,032414) - the explicit divide gives different results than when that
       ! value is placed in the parameters netcdf file.  To get bfb, keep the
       ! divide in source.
       !k_nitr_max = NitrifDenitrifParamsInst%k_nitr_max
 
+      surface_tension_water = NitrifDenitrifParamsInst%surface_tension_water
+
+      ! Set parameters from simple-structure model to calculate anoxic fratction (Arah and Vinten 1995)
+      rij_kro_a     = NitrifDenitrifParamsInst%rij_kro_a
+      rij_kro_alpha = NitrifDenitrifParamsInst%rij_kro_alpha
+      rij_kro_beta  = NitrifDenitrifParamsInst%rij_kro_beta
+      rij_kro_gamma = NitrifDenitrifParamsInst%rij_kro_gamma
+      rij_kro_delta = NitrifDenitrifParamsInst%rij_kro_delta
+
+      organic_max = ParamsShareInst%organic_max
+
+      pH(bounds%begc:bounds%endc) = 6.5  !!! set all soils with the same pH as placeholder here
       co2diff_con(1) =   0.1325_r8
       co2diff_con(2) =   0.0009_r8
-      !$acc parallel loop independent gang vector collapse(2) default(present)
+
       do j = 1, nlevdecomp
          do fc = 1,num_soilc
             c = filter_soilc(fc)
-             k_nitr_max =  0.1_r8 / secspday   ! [1/sec] 10%/day  Parton et al., 2001
 
             !---------------- calculate soil anoxia state
             ! calculate gas diffusivity of soil at field capacity here
@@ -249,17 +256,17 @@ contains
                ! use rijtema and kroess model after Riley et al., 2000
                ! caclulated r_psi as a function of psi
 
-               r_min = 2 * surface_tension_water / (rho_w * grav * abs(soilpsi(c,j)))
+               r_min(c,j) = 2 * surface_tension_water / (rho_w * grav * abs(soilpsi(c,j)))
                r_max = 2 * surface_tension_water / (rho_w * grav * 0.1_r8)
-               r_psi(c,j) = sqrt(r_min * r_max)
-               ratio_diffusivity_water_gas = (d_con_g(2,1) + d_con_g(2,2)*t_soisno(c,j) ) * 1.e-4_r8 / &
+               r_psi(c,j) = sqrt(r_min(c,j) * r_max)
+               ratio_diffusivity_water_gas(c,j) = (d_con_g(2,1) + d_con_g(2,2)*t_soisno(c,j) ) * 1.e-4_r8 / &
                     ((d_con_w(2,1) + d_con_w(2,2)*t_soisno(c,j) + d_con_w(2,3)*t_soisno(c,j)**2) * 1.e-9_r8)
 
                if (o2_decomp_depth_unsat(c,j) /= spval .and. conc_o2_unsat(c,j) /= spval .and.  &
                     o2_decomp_depth_unsat(c,j) > 0._r8) then
                   anaerobic_frac(c,j) = exp(-rij_kro_a * r_psi(c,j)**(-rij_kro_alpha) * &
                        o2_decomp_depth_unsat(c,j)**(-rij_kro_beta) * &
-                       conc_o2_unsat(c,j)**rij_kro_gamma * (h2osoi_vol(c,j) + ratio_diffusivity_water_gas * &
+                       conc_o2_unsat(c,j)**rij_kro_gamma * (h2osoi_vol(c,j) + ratio_diffusivity_water_gas(c,j) * &
                        watsat(c,j))**rij_kro_delta)
                else
                   anaerobic_frac(c,j) = 0._r8
@@ -272,7 +279,7 @@ contains
                        o2_decomp_depth_sat(c,j) > 0._r8) then
                      anaerobic_frac_sat = exp(-rij_kro_a * r_psi_sat**(-rij_kro_alpha) * &
                           o2_decomp_depth_sat(c,j)**(-rij_kro_beta) * &
-                          conc_o2_sat(c,j)**rij_kro_gamma * (watsat(c,j) + ratio_diffusivity_water_gas * &
+                          conc_o2_sat(c,j)**rij_kro_gamma * (watsat(c,j) + ratio_diffusivity_water_gas(c,j) * &
                           watsat(c,j))**rij_kro_delta)
                   else
                      anaerobic_frac_sat = 0._r8
@@ -288,14 +295,15 @@ contains
                !call endrun(msg=' ERROR: NITRIF_DENITRIF requires Methane model to be active'//errMsg(__FILE__, __LINE__) )
             end if
 
+
             !---------------- nitrification
             ! follows CENTURY nitrification scheme (Parton et al., (2001, 1996))
+
             ! assume nitrification temp function equal to the HR scalar
             k_nitr_t_vr(c,j) = min(t_scalar(c,j), 1._r8)
 
             ! ph function from Parton et al., (2001, 1996)
-            pH = 6.5  !!! set all soils with the same pH as placeholder here
-            k_nitr_ph_vr(c,j) = 0.56 + atan(rpi * 0.45 * (-5.+ pH))/rpi
+            k_nitr_ph_vr(c,j) = 0.56 + atan(rpi * 0.45 * (-5.+ pH(c)))/rpi
 
             ! moisture function-- assume the same moisture function as limits heterotrophic respiration
             ! Parton et al. base their nitrification- soil moisture rate constants based on heterotrophic rates-- can we do the same?
@@ -318,7 +326,7 @@ contains
 
             !---------------- denitrification
             ! first some input variables an unit conversions
-            !soil_hr_vr(fc,j) = phr_vr(c,j)
+            soil_hr_vr(c,j) = phr_vr(c,j)
 
             ! CENTURY papers give denitrification in units of per gram soil; need to convert from volumetric to mass-based units here
             soil_bulkdensity(c,j) = bd(c,j) + h2osoi_liq(c,j)/col_pp%dz(c,j)
@@ -329,7 +337,7 @@ contains
 
             smin_no3_massdens_vr(c,j) = max(smin_no3_vr(c,j), 0._r8) * g_per_m3__to__ug_per_gsoil
 
-            soil_co2_prod(c,j) = ( phr_vr(c,j) * (g_per_m3_sec__to__ug_per_gsoil_day))
+            soil_co2_prod(c,j) = (soil_hr_vr(c,j) * (g_per_m3_sec__to__ug_per_gsoil_day))
 
             !! maximum potential denitrification rates based on heterotrophic respiration rates or nitrate concentrations,
             !! from (del Grosso et al., 2000)
@@ -361,7 +369,7 @@ contains
                ! fucntion saturates at large no3/co2 ratios, so set as some nominally large number
                ratio_no3_co2(c,j) = 100._r8
             endif
-            !
+
             ! total water limitation function (Del Grosso et al., 2000, figure 7a)
             wfps_vr(c,j) = max(min(h2osoi_vol(c,j)/watsat(c, j), 1._r8), 0._r8) * 100._r8
             fr_WFPS(c,j) = max(0.1_r8, 0.015_r8 * wfps_vr(c,j) - 0.32_r8)
@@ -373,7 +381,9 @@ contains
 
             ! final ratio expression
             n2_n2o_ratio_denit_vr(c,j) = max(0.16*ratio_k1(c,j), ratio_k1(c,j)*exp(-0.8 * ratio_no3_co2(c,j))) * fr_WFPS(c,j)
+
          end do
+
       end do
 
     end associate
diff --git a/components/elm/src/biogeochem/NitrogenDynamicsMod.F90 b/components/elm/src/biogeochem/NitrogenDynamicsMod.F90
index 997994350f..c85e615cf6 100644
--- a/components/elm/src/biogeochem/NitrogenDynamicsMod.F90
+++ b/components/elm/src/biogeochem/NitrogenDynamicsMod.F90
@@ -12,9 +12,10 @@ module NitrogenDynamicsMod
   use decompMod           , only : bounds_type
   use elm_varcon          , only : dzsoi_decomp, zisoi
   use elm_varctl          , only : use_vertsoilc
-  use subgridAveMod       , only : p2c, p2c_1d_filter_parallel
+  use subgridAveMod       , only : p2c
   use atm2lndType         , only : atm2lnd_type
   use CNStateType         , only : cnstate_type
+  use WaterFluxType       , only : waterflux_type
   use CropType            , only : crop_type
   use ColumnType          , only : col_pp
   use ColumnDataType      , only : col_es, col_ws, col_wf, col_cf, col_ns, col_nf
@@ -110,7 +111,8 @@ contains
   end subroutine readNitrogenDynamicsParams
 
   !-----------------------------------------------------------------------
-  subroutine NitrogenDeposition( bounds, atm2lnd_vars )
+  subroutine NitrogenDeposition( bounds, &
+       atm2lnd_vars, dt )
     !
     ! !DESCRIPTION:
     ! On the radiation time step, update the nitrogen deposition rate
@@ -120,26 +122,22 @@ contains
     ! directly into the canopy and mineral N entering the soil pool.
     !
     ! !ARGUMENTS:
-    type(bounds_type)  , intent(in)  :: bounds 
-    type(atm2lnd_type) , intent(in)  :: atm2lnd_vars
+      !$acc routine seq
+    type(bounds_type)        , intent(in)    :: bounds
+    type(atm2lnd_type)       , intent(in)    :: atm2lnd_vars
+    real(r8),   intent(in) :: dt
     !
     ! !LOCAL VARIABLES:
-    integer :: g,c,fc                  ! indices
-    integer :: begc, endc 
+    integer :: g,c                    ! indices
     !-----------------------------------------------------------------------
 
     associate(&
          forc_ndep     =>  atm2lnd_vars%forc_ndep_grc           , & ! Input:  [real(r8) (:)]  nitrogen deposition rate (gN/m2/s)
          ndep_to_sminn =>  col_nf%ndep_to_sminn   & ! Output: [real(r8) (:)]
          )
-      
-      begc = bounds%begc 
-      endc = bounds%endc
 
       ! Loop through columns
-      ! Note: why loop through all columns? adjusting to filter is nonBFB due to averaging.
-      !$acc parallel loop independent gang vector default(present)
-      do c = begc, endc 
+      do c = bounds%begc, bounds%endc
          g = col_pp%gridcell(c)
          ndep_to_sminn(c) = forc_ndep(g)
       end do
@@ -157,6 +155,7 @@ contains
     ! All N fixation goes to the soil mineral N pool.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon       , only : secspday, spval
     !
     ! !ARGUMENTS:
@@ -169,7 +168,7 @@ contains
     integer  :: c,fc                  ! indices
     real(r8) :: t                     ! temporary
     real(r8) :: secspyr              ! seconds per yr
-   !  logical  :: do_et_bnf = .false.
+    logical  :: do_et_bnf = .false.
     !-----------------------------------------------------------------------
 
     associate(&
@@ -183,7 +182,7 @@ contains
          )
 
 
-      if (use_fates) then
+      if (do_et_bnf .or. use_fates) then
          secspyr = dayspyr * 86400._r8
          do fc = 1, num_soilc
             c =filter_soilc(fc)
@@ -222,147 +221,149 @@ contains
   end subroutine NitrogenFixation
 
   !-----------------------------------------------------------------------
-  subroutine NitrogenLeaching(num_soilc, filter_soilc, dt )
-   !
-   ! !DESCRIPTION:
-   ! On the radiation time step, update the nitrogen leaching rate
-   ! as a function of soluble mineral N and total soil water outflow.
-   !
-   ! !USES:
-   use elm_varpar       , only : nlevdecomp, nlevsoi, nlevgrnd
-   !
-   ! !ARGUMENTS:
-   integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
-   integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
-   real(r8)                 , intent(in)    :: dt          ! radiation time step (seconds)
-
-   !
-   ! !LOCAL VARIABLES:
-   integer  :: j,c,fc                                 ! indices
-   integer  :: nlevbed				       ! number of layers to bedrock
-   real(r8) :: disn_conc                              ! dissolved mineral N concentration (gN/kg water)
-   real(r8) :: surface_water(num_soilc) ! liquid water to shallow surface depth (kg water/m2)
-   real(r8), parameter :: depth_runoff_Nloss = 0.05   ! (m) depth over which runoff mixes with soil water for N loss to runoff
-   real(r8) :: sum2
-   real(r8) :: tot_water(num_soilc)  
-   !-----------------------------------------------------------------------
-
-   associate(&
-       nlev2bed            => col_pp%nlevbed                            , & ! Input:  [integer (:)    ]  number of layers to bedrock
-        h2osoi_liq          => col_ws%h2osoi_liq            , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2) (new) (-nlevsno+1:nlevgrnd)
-        qflx_drain          => col_wf%qflx_drain             , & ! Input:  [real(r8) (:)   ]  sub-surface runoff (mm H2O /s)
-        qflx_surf           => col_wf%qflx_surf              , & ! Input:  [real(r8) (:)   ]  surface runoff (mm H2O /s)
-        smin_no3_vr         => col_ns%smin_no3_vr        , & ! Input:  [real(r8) (:,:) ]
-        sf_no3              =>  CNNDynamicsParamsInst%sf_no3  ,  &  ! Assume that 100% of the soil NO3 is in a soluble form
-        smin_no3_leached_vr => col_nf%smin_no3_leached_vr , & ! Output: [real(r8) (:,:) ]  rate of mineral NO3 leaching (gN/m3/s)
-        smin_no3_runoff_vr  => col_nf%smin_no3_runoff_vr    & ! Output: [real(r8) (:,:) ]  rate of mineral NO3 loss with runoff (gN/m3/s)
-        )
-
-     !$acc enter data create(sum2, surface_water(:num_soilc), tot_water(:num_soilc) )
-     
-     ! for runoff calculation; calculate total water to a given depth
-     !$acc parallel loop independent gang worker default(present) private(sum2,c,nlevbed) present(surface_water(:num_soilc))
-     do fc = 1,num_soilc
-        c = filter_soilc(fc)
-        nlevbed = nlev2bed(c)
-        sum2 = 0._r8 
-        !$acc loop vector reduction(+:sum2)
-        do j = 1,nlevbed
-           if ( zisoi(j) <= depth_runoff_Nloss)  then
-              sum2 = sum2 + h2osoi_liq(c,j)
-           elseif ( zisoi(j-1) < depth_runoff_Nloss)  then
-              sum2 = sum2 + h2osoi_liq(c,j) * ((depth_runoff_Nloss - zisoi(j-1)) / col_pp%dz(c,j))
-           end if
-        end do
-        surface_water(fc) = sum2 
-     end do
+  subroutine NitrogenLeaching(bounds, num_soilc, filter_soilc, dt )
+    !
+    ! !DESCRIPTION:
+    ! On the radiation time step, update the nitrogen leaching rate
+    ! as a function of soluble mineral N and total soil water outflow.
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varpar       , only : nlevdecomp, nlevsoi, nlevgrnd
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
+    integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
+    real(r8)                 , intent(in)    :: dt          ! radiation time step (seconds)
+
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,fc                                 ! indices
+    integer  :: nlevbed				       ! number of layers to bedrock
+    real(r8) :: sf_no3                                 ! soluble fraction of NO3 (unitless)
+    real(r8) :: disn_conc                              ! dissolved mineral N concentration (gN/kg water)
+    real(r8) :: tot_water(bounds%begc:bounds%endc)     ! total column liquid water (kg water/m2)
+    real(r8) :: surface_water(bounds%begc:bounds%endc) ! liquid water to shallow surface depth (kg water/m2)
+    real(r8) :: drain_tot(bounds%begc:bounds%endc)     ! total drainage flux (mm H2O /s)
+    real(r8), parameter :: depth_runoff_Nloss = 0.05   ! (m) depth over which runoff mixes with soil water for N loss to runoff
+    !-----------------------------------------------------------------------
+
+    associate(& 
+    	 nlev2bed            => col_pp%nlevbed                            , & ! Input:  [integer (:)    ]  number of layers to bedrock
+         h2osoi_liq          => col_ws%h2osoi_liq            , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2) (new) (-nlevsno+1:nlevgrnd)
+         qflx_drain          => col_wf%qflx_drain             , & ! Input:  [real(r8) (:)   ]  sub-surface runoff (mm H2O /s)                    
+         qflx_surf           => col_wf%qflx_surf              , & ! Input:  [real(r8) (:)   ]  surface runoff (mm H2O /s)                        
+         smin_no3_vr         => col_ns%smin_no3_vr        , & ! Input:  [real(r8) (:,:) ]                                                  
+         smin_no3_leached_vr => col_nf%smin_no3_leached_vr , & ! Output: [real(r8) (:,:) ]  rate of mineral NO3 leaching (gN/m3/s)          
+         smin_no3_runoff_vr  => col_nf%smin_no3_runoff_vr    & ! Output: [real(r8) (:,:) ]  rate of mineral NO3 loss with runoff (gN/m3/s)  
+         )
+
+
+      ! Assume that 100% of the soil NO3 is in a soluble form
+      sf_no3 =  CNNDynamicsParamsInst%sf_no3 
 
       ! calculate the total soil water
-      !$acc parallel loop independent gang worker default(present) private(sum2,c,nlevbed) present(tot_water(:num_soilc)) 
+      tot_water(bounds%begc:bounds%endc) = 0._r8
       do fc = 1,num_soilc
          c = filter_soilc(fc)
-         nlevbed = col_pp%nlevbed(c)
-         sum2 = 0._r8 
-         !$acc loop vector reduction(+:sum2)
+         nlevbed = nlev2bed(c)
          do j = 1,nlevbed
-            sum2 = sum2 + col_ws%h2osoi_liq(c,j)
+            tot_water(c) = tot_water(c) + h2osoi_liq(c,j)
          end do
-         tot_water(fc) = sum2
       end do
 
+      ! for runoff calculation; calculate total water to a given depth
+      surface_water(bounds%begc:bounds%endc) = 0._r8
+      do fc = 1,num_soilc
+         c = filter_soilc(fc)
+         nlevbed = nlev2bed(c)
+         do j = 1,nlevbed
+            if ( zisoi(j) <= depth_runoff_Nloss)  then
+               surface_water(c) = surface_water(c) + h2osoi_liq(c,j)
+            elseif ( zisoi(j-1) < depth_runoff_Nloss)  then
+               surface_water(c) = surface_water(c) + h2osoi_liq(c,j) * ( (depth_runoff_Nloss - zisoi(j-1)) / col_pp%dz(c,j))
+            end if
+         end do
+      end do
 
-     !$acc parallel loop independent gang vector collapse(2) default(present) present(tot_water(:num_soilc),surface_water(:num_soilc)) 
-     do j = 1,nlevdecomp
-        do fc = 1,num_soilc
-           c = filter_soilc(fc)
+      ! Loop through columns
+      do fc = 1,num_soilc
+         c = filter_soilc(fc)
+         drain_tot(c) = qflx_drain(c)
+      end do
 
-           if (.not. use_vertsoilc) then
-              ! calculate the dissolved mineral N concentration (gN/kg water)
-              ! assumes that 10% of mineral nitrogen is soluble
-              disn_conc = 0._r8
-              if (tot_water(fc) > 0._r8) then
-                 disn_conc = (sf_no3 * smin_no3_vr(c,j) )/tot_water(fc)
-              end if
+      do j = 1,nlevdecomp
+         ! Loop through columns
+         do fc = 1,num_soilc
+            c = filter_soilc(fc)
+
+            if (.not. use_vertsoilc) then
+               ! calculate the dissolved mineral N concentration (gN/kg water)
+               ! assumes that 10% of mineral nitrogen is soluble
+               disn_conc = 0._r8
+               if (tot_water(c) > 0._r8) then
+                  disn_conc = (sf_no3 * smin_no3_vr(c,j) )/tot_water(c)
+               end if
 
-              ! calculate the N leaching flux as a function of the dissolved
-              ! concentration and the sub-surface drainage flux
-              smin_no3_leached_vr(c,j) = disn_conc * qflx_drain(c)
-           else
-              ! calculate the dissolved mineral N concentration (gN/kg water)
-              ! assumes that 10% of mineral nitrogen is soluble
-              disn_conc = 0._r8
-              if (h2osoi_liq(c,j) > 0._r8) then
-                 disn_conc = (sf_no3 * smin_no3_vr(c,j) * col_pp%dz(c,j) )/(h2osoi_liq(c,j) )
-              end if
-              !
-              ! calculate the N leaching flux as a function of the dissolved
-              ! concentration and the sub-surface drainage flux
-              smin_no3_leached_vr(c,j) = disn_conc * qflx_drain(c) * h2osoi_liq(c,j) / ( tot_water(fc) * col_pp%dz(c,j) )
-              !
-              ! ensure that leaching rate isn't larger than soil N pool
-              smin_no3_leached_vr(c,j) = min(smin_no3_leached_vr(c,j), smin_no3_vr(c,j) / dt )
-              !
-              ! limit the leaching flux to a positive value
-              smin_no3_leached_vr(c,j) = max(smin_no3_leached_vr(c,j), 0._r8)
-              !
-              !
-              ! calculate the N loss from surface runoff, assuming a shallow mixing of surface waters into soil and removal based on runoff
-              if ( zisoi(j) <= depth_runoff_Nloss )  then
-                 smin_no3_runoff_vr(c,j) = disn_conc * qflx_surf(c) * &
-                      h2osoi_liq(c,j) / ( surface_water(fc) * col_pp%dz(c,j) )
-              elseif ( zisoi(j-1) < depth_runoff_Nloss )  then
-                 smin_no3_runoff_vr(c,j) = disn_conc * qflx_surf(c) * &
-                      h2osoi_liq(c,j) * ((depth_runoff_Nloss - zisoi(j-1)) / &
-                      col_pp%dz(c,j)) / ( surface_water(fc) * (depth_runoff_Nloss-zisoi(j-1) ))
-              else
-                 smin_no3_runoff_vr(c,j) = 0._r8
-              endif
-              !
-              ! ensure that runoff rate isn't larger than soil N pool
-              smin_no3_runoff_vr(c,j) = min(smin_no3_runoff_vr(c,j), smin_no3_vr(c,j) / dt - smin_no3_leached_vr(c,j))
-              !
-              ! limit the flux to a positive value
-              smin_no3_runoff_vr(c,j) = max(smin_no3_runoff_vr(c,j), 0._r8)
-
-
-           endif
-           ! limit the flux based on current smin_no3 state
-           ! only let at most the assumed soluble fraction
-           ! of smin_no3 be leached on any given timestep
-           smin_no3_leached_vr(c,j) = min(smin_no3_leached_vr(c,j), (sf_no3 * smin_no3_vr(c,j))/dt)
-
-           ! limit the flux to a positive value
-           smin_no3_leached_vr(c,j) = max(smin_no3_leached_vr(c,j), 0._r8)
-
-        end do
-     end do
-     !$acc exit data delete(sum2,surface_water(:num_soilc), tot_water(:num_soilc) )
-
-   end associate
- end subroutine NitrogenLeaching
+               ! calculate the N leaching flux as a function of the dissolved
+               ! concentration and the sub-surface drainage flux
+               smin_no3_leached_vr(c,j) = disn_conc * drain_tot(c)
+            else
+               ! calculate the dissolved mineral N concentration (gN/kg water)
+               ! assumes that 10% of mineral nitrogen is soluble
+               disn_conc = 0._r8
+               if (h2osoi_liq(c,j) > 0._r8) then
+                  disn_conc = (sf_no3 * smin_no3_vr(c,j) * col_pp%dz(c,j) )/(h2osoi_liq(c,j) )
+               end if
+               !
+               ! calculate the N leaching flux as a function of the dissolved
+               ! concentration and the sub-surface drainage flux
+               smin_no3_leached_vr(c,j) = disn_conc * drain_tot(c) * h2osoi_liq(c,j) / ( tot_water(c) * col_pp%dz(c,j) )
+               !
+               ! ensure that leaching rate isn't larger than soil N pool
+               smin_no3_leached_vr(c,j) = min(smin_no3_leached_vr(c,j), smin_no3_vr(c,j) / dt )
+               !
+               ! limit the leaching flux to a positive value
+               smin_no3_leached_vr(c,j) = max(smin_no3_leached_vr(c,j), 0._r8)
+               !
+               !
+               ! calculate the N loss from surface runoff, assuming a shallow mixing of surface waters into soil and removal based on runoff
+               if ( zisoi(j) <= depth_runoff_Nloss )  then
+                  smin_no3_runoff_vr(c,j) = disn_conc * qflx_surf(c) * &
+                       h2osoi_liq(c,j) / ( surface_water(c) * col_pp%dz(c,j) )
+               elseif ( zisoi(j-1) < depth_runoff_Nloss )  then
+                  smin_no3_runoff_vr(c,j) = disn_conc * qflx_surf(c) * &
+                       h2osoi_liq(c,j) * ((depth_runoff_Nloss - zisoi(j-1)) / &
+                       col_pp%dz(c,j)) / ( surface_water(c) * (depth_runoff_Nloss-zisoi(j-1) ))
+               else
+                  smin_no3_runoff_vr(c,j) = 0._r8
+               endif
+               !
+               ! ensure that runoff rate isn't larger than soil N pool
+               smin_no3_runoff_vr(c,j) = min(smin_no3_runoff_vr(c,j), smin_no3_vr(c,j) / dt - smin_no3_leached_vr(c,j))
+               !
+               ! limit the flux to a positive value
+               smin_no3_runoff_vr(c,j) = max(smin_no3_runoff_vr(c,j), 0._r8)
+
+
+            endif
+            ! limit the flux based on current smin_no3 state
+            ! only let at most the assumed soluble fraction
+            ! of smin_no3 be leached on any given timestep
+            smin_no3_leached_vr(c,j) = min(smin_no3_leached_vr(c,j), (sf_no3 * smin_no3_vr(c,j))/dt)
+
+            ! limit the flux to a positive value
+            smin_no3_leached_vr(c,j) = max(smin_no3_leached_vr(c,j), 0._r8)
+
+         end do
+      end do
+
+    end associate
+  end subroutine NitrogenLeaching
 
   !-----------------------------------------------------------------------
-  subroutine NitrogenFert( num_soilc, filter_soilc )
+  subroutine NitrogenFert(bounds, num_soilc, filter_soilc )
     !
     ! !DESCRIPTION:
     ! On the radiation time step, update the nitrogen fertilizer for crops
@@ -371,6 +372,8 @@ contains
     ! !USES:
     !
     ! !ARGUMENTS:
+      !$acc routine seq
+    type(bounds_type)       , intent(in)    :: bounds
     integer                 , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                 , intent(in)    :: filter_soilc(:) ! filter for soil columns
     !
@@ -383,14 +386,16 @@ contains
          fert_to_sminn =>    col_nf%fert_to_sminn   & ! Output: [real(r8) (:)]
          )
 
-      call p2c_1d_filter_parallel( num_soilc, filter_soilc, &
-           fert,  fert_to_sminn )
+      call p2c(bounds, num_soilc, filter_soilc, &
+           fert(bounds%begp:bounds%endp), &
+           fert_to_sminn(bounds%begc:bounds%endc))
 
     end associate
   end subroutine NitrogenFert
 
   !-----------------------------------------------------------------------
-  subroutine CNSoyfix ( num_soilc, filter_soilc, num_soilp, filter_soilp, &
+  subroutine CNSoyfix (bounds, &
+       num_soilc, filter_soilc, num_soilp, filter_soilp, &
        crop_vars, cnstate_vars)
     !
     ! !DESCRIPTION:
@@ -400,9 +405,11 @@ contains
     ! nitrogen in the soil root zone.
     !
     ! !USES:
+      !$acc routine seq
     use pftvarcon  , only : nsoybean
     !
     ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
     integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
@@ -415,9 +422,9 @@ contains
     real(r8):: fxw,fxn,fxg,fxr             ! soil water factor, nitrogen factor, growth stage factor
     real(r8):: soy_ndemand                 ! difference between nitrogen supply and demand
     real(r8):: GDDfrac
-    real(r8), parameter :: sminnthreshold1= 30._r8, sminnthreshold2= 10._r8
-    real(r8),parameter:: GDDfracthreshold1= 0.15_r8, GDDfracthreshold2= 0.30_r8
-    real(r8),parameter:: GDDfracthreshold3= 0.55_r8, GDDfracthreshold4= 0.75_r8
+    real(r8):: sminnthreshold1, sminnthreshold2
+    real(r8):: GDDfracthreshold1, GDDfracthreshold2
+    real(r8):: GDDfracthreshold3, GDDfracthreshold4
     !-----------------------------------------------------------------------
 
     associate(                                                         &
@@ -436,7 +443,13 @@ contains
          soyfixn_to_sminn =>  col_nf%soyfixn_to_sminn   & ! Output: [real(r8) (:) ]
          )
 
-      !$acc parallel loop independent gang vector default(present) private(p,c)
+      sminnthreshold1 = 30._r8
+      sminnthreshold2 = 10._r8
+      GDDfracthreshold1 = 0.15_r8
+      GDDfracthreshold2 = 0.30_r8
+      GDDfracthreshold3 = 0.55_r8
+      GDDfracthreshold4 = 0.75_r8
+
       do fp = 1,num_soilp
          p = filter_soilp(fp)
          c = veg_pp%column(p)
@@ -509,8 +522,9 @@ contains
          end if
       end do
 
-      call p2c_1d_filter_parallel(num_soilc, filter_soilc, &
-           soyfixn(:), soyfixn_to_sminn(:))
+      call p2c(bounds, num_soilc, filter_soilc, &
+           soyfixn(bounds%begp:bounds%endp), &
+           soyfixn_to_sminn(bounds%begc:bounds%endc))
 
     end associate
 
@@ -526,6 +540,7 @@ contains
     ! N2 fixation is based on Fisher 2010 GBC doi:10.1029/2009GB003621; Wang 2007 GBC doi:10.1029/2006GB002797; and Grand 2012 ecosys model
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon       , only : secspday, spval
     use pftvarcon        , only : noveg
 
@@ -542,7 +557,6 @@ contains
     real(r8) :: f_nodule                   ! empirical, fraction of root that is nodulated
     real(r8) :: N2_aq                      ! aqueous N2 bulk concentration gN/m3 soil
     real(r8) :: nfix_tmp
-    real(r8) :: sum1, sum2 
     !-----------------------------------------------------------------------
 
     associate(&
@@ -562,13 +576,10 @@ contains
          t_scalar              => col_cf%t_scalar           &
          )
 
-      !$acc enter data create(sum1,sum2)
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
       do fc=1,num_soilc
           c = filter_soilc(fc)
-          sum1 = 0.0_r8
-          sum2 = 0._r8
-          !$acc loop vector reduction(+:sum1,sum2)
+          nfix_to_sminn(c) = 0.0_r8
+          nfix_to_ecosysn(c) = 0._r8
           do p = col_pp%pfti(c), col_pp%pftf(c)
               if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
                   ! calculate c cost of n2 fixation: fisher 2010 gbc doi:10.1029/2009gb003621
@@ -587,18 +598,16 @@ contains
                   nfix_tmp = vmax_nfix(veg_pp%itype(p)) * frootc(p) * cn_scalar(p) *f_nodule * t_scalar(c,1) * &
                              N2_aq/ (N2_aq + km_nfix(veg_pp%itype(p)))
                   if (NFIX_PTASE_plant) then
-                     sum1 = sum1 + nfix_tmp  * veg_pp%wtcol(p) * (1._r8-veg_vp%alpha_nfix(veg_pp%itype(p)))
+                     nfix_to_sminn(c) = nfix_to_sminn(c) + nfix_tmp  * veg_pp%wtcol(p) * (1._r8-veg_vp%alpha_nfix(veg_pp%itype(p)))
                      nfix_to_plantn(p) = nfix_tmp * veg_vp%alpha_nfix(veg_pp%itype(p))
-                     sum2 = sum2 + nfix_tmp  * veg_pp%wtcol(p)
+                     nfix_to_ecosysn(c) = nfix_to_ecosysn(c) + nfix_tmp  * veg_pp%wtcol(p)
                   else
-                     sum1 = sum1 + nfix_tmp  * veg_pp%wtcol(p)
+                     nfix_to_sminn(c) = nfix_to_sminn(c) + nfix_tmp  * veg_pp%wtcol(p)
                      nfix_to_plantn(p) = 0.0_r8
-                     sum2 = sum2 + nfix_tmp  * veg_pp%wtcol(p)
+                     nfix_to_ecosysn(c) = nfix_to_ecosysn(c) + nfix_tmp  * veg_pp%wtcol(p)
                   end if
               end if
           end do
-          nfix_to_sminn(c) = sum1 
-          nfix_to_ecosysn(c) = sum2
       end do
 
     end associate
diff --git a/components/elm/src/biogeochem/NitrogenStateUpdate1Mod.F90 b/components/elm/src/biogeochem/NitrogenStateUpdate1Mod.F90
index f1d0a033ef..34aaad0557 100644
--- a/components/elm/src/biogeochem/NitrogenStateUpdate1Mod.F90
+++ b/components/elm/src/biogeochem/NitrogenStateUpdate1Mod.F90
@@ -1,79 +1,55 @@
 module NitrogenStateUpdate1Mod
-   !-----------------------------------------------------------------------
-   ! !DESCRIPTION:
-   ! Module for nitrogen state variable updates, non-mortality fluxes.
-   !
-   ! !USES:
-   use shr_kind_mod           , only: r8 => shr_kind_r8
-   use elm_varpar             , only : nlevdecomp, ndecomp_pools, ndecomp_cascade_transitions
-   use elm_varpar             , only : crop_prog, i_met_lit, i_cel_lit, i_lig_lit, i_cwd
-   use elm_varctl             , only : iulog
-   use elm_varcon             , only : nitrif_n2o_loss_frac
-   use pftvarcon              , only : npcropmin, nc3crop
-   use VegetationPropertiesType         , only : veg_vp
-   use CNDecompCascadeConType , only : decomp_cascade_con
-   use CNStateType            , only : cnstate_type
-   use GridcellDataType       , only : grc_ns, grc_nf
-   use ColumnDataType         , only : col_ns, col_nf
-   use VegetationType         , only : veg_pp
-   use VegetationDataType     , only : veg_ns, veg_nf
-   use tracer_varcon          , only : is_active_betr_bgc
-   ! bgc interface & pflotran:
-   use elm_varctl             , only : use_pflotran, pf_cmode
-   ! forest fertilization experiment
-   use CNStateType            , only : fert_type , fert_continue, fert_dose, fert_start, fert_end
-   use elm_varctl             , only : forest_fert_exp
-   use elm_varctl             , only : nu_com
-   use elm_varctl             , only : NFIX_PTASE_plant
-   use decompMod              , only : bounds_type
-   use elm_varcon             , only : dzsoi_decomp
-   use elm_varctl             , only : use_fates
-   use timeInfoMod            , only : year_curr, mon_curr, day_curr, secs_curr 
-
-   !
-   implicit none
-   save
-   private
-   !
-   ! !PUBLIC MEMBER FUNCTIONS:
-   public :: NitrogenStateUpdateDynPatch
-   public :: NitrogenStateUpdate_Phase1_col
-   public :: NitrogenStateUpdate_Phase1_pft 
-   public :: NitrogenStateDynGridUpdate
-
-   !-----------------------------------------------------------------------
-   
-   contains
-   
-   subroutine NitrogenStateDynGridUpdate(bounds, dt)
-      !
-      ! !DESCRIPTION: 
-      ! Update gridcell N states based on fluxes from dyn_cnbal_patch 
-      ! !ARGUMENTS 
-      type(bounds_type), intent(in) :: bounds  
-      real(r8), intent(in) :: dt 
-      ! 
-      integer :: begg, endg 
-      integer :: g 
-      
-      begg = bounds%begg; endg = bounds%endg 
-      
-      !$acc parallel loop independent gang vector default(present)  
-      do g =begg, endg  
-         grc_ns%seedn(g) = grc_ns%seedn(g) &
-                 - grc_nf%dwt_seedn_to_leaf(g)     * dt &
-                 - grc_nf%dwt_seedn_to_deadstem(g) * dt &
-                 - grc_nf%dwt_seedn_to_npool(g)    * dt
-      end do 
-   end subroutine NitrogenStateDynGridUpdate
+  !-----------------------------------------------------------------------
+  ! !DESCRIPTION:
+  ! Module for nitrogen state variable updates, non-mortality fluxes.
+  !
+  ! !USES:
+  use shr_kind_mod           , only: r8 => shr_kind_r8
+  use elm_varpar             , only : nlevdecomp, ndecomp_pools, ndecomp_cascade_transitions
+  use elm_varpar             , only : crop_prog, i_met_lit, i_cel_lit, i_lig_lit, i_cwd
+  use elm_varctl             , only : iulog
+  use elm_varcon             , only : nitrif_n2o_loss_frac
+  use pftvarcon              , only : npcropmin, nc3crop
+  use VegetationPropertiesType         , only : veg_vp
+  use CNDecompCascadeConType , only : decomp_cascade_con
+  use CNStateType            , only : cnstate_type
+  use GridcellDataType       , only : grc_ns, grc_nf
+  use ColumnDataType         , only : col_ns, col_nf
+  use VegetationType         , only : veg_pp
+  use VegetationDataType     , only : veg_ns, veg_nf
+  use tracer_varcon          , only : is_active_betr_bgc
+  ! bgc interface & pflotran:
+  use elm_varctl             , only : use_pflotran, pf_cmode
+  ! forest fertilization experiment
+  use clm_time_manager       , only : get_curr_date
+  use CNStateType            , only : fert_type , fert_continue, fert_dose, fert_start, fert_end
+  use elm_varctl             , only : forest_fert_exp
+  use elm_varctl             , only : nu_com
+  use elm_varctl             , only : NFIX_PTASE_plant
+  use decompMod              , only : bounds_type
+  use elm_varcon             , only : dzsoi_decomp
+  use elm_varctl             , only : use_fates
+  !
+  implicit none
+  save
+  private
+  !
+  ! !PUBLIC MEMBER FUNCTIONS:
+  public :: NitrogenStateUpdateDynPatch
+  public :: NitrogenStateUpdate1
+  !-----------------------------------------------------------------------
+
+contains
 
   !-----------------------------------------------------------------------
-  subroutine NitrogenStateUpdateDynPatch(num_soilc_with_inactive,&
+  subroutine NitrogenStateUpdateDynPatch(bounds, num_soilc_with_inactive,&
      filter_soilc_with_inactive, dt)
     !
     ! !DESCRIPTION:
     ! Update nitrogen states based on fluxes from dyn_cnbal_patch
+    !$acc routine seq
     ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc_with_inactive       ! number of columns in soil filter
     integer                  , intent(in)    :: filter_soilc_with_inactive(:) ! soil column filter that includes inactive points
     real(r8), intent(in)                      :: dt                            ! time step (seconds)
@@ -82,240 +58,235 @@ module NitrogenStateUpdate1Mod
     ! !LOCAL VARIABLES:
     integer                                  :: c                             ! column index
     integer                                  :: fc                            ! column filter index
+    integer                                  :: g                             ! gridcell index
     integer                                  :: j                             ! level index
+
+    !character(len=*)         , parameter     :: subname = 'NitrogenStateUpdateDynPatch'
     !-----------------------------------------------------------------------
-      !$acc parallel loop independent gang vector default(present)
-      do fc = 1, num_soilc_with_inactive
-
-         c = filter_soilc_with_inactive(fc)
-         col_ns%prod10n(c) = col_ns%prod10n(c) + col_nf%dwt_prod10n_gain(c)*dt
-         col_ns%prod100n(c) = col_ns%prod100n(c) + col_nf%dwt_prod100n_gain(c)*dt
-         col_ns%prod1n(c) = col_ns%prod1n(c) + col_nf%dwt_crop_productn_gain(c)*dt
-      end do 
-      
-      !$acc parallel loop independent gang vector collapse(2) default(present) 
-      do j = 1,nlevdecomp
+
+      if (.not.use_fates) then
+
+         do g = bounds%begg, bounds%endg
+            grc_ns%seedn(g) = grc_ns%seedn(g) &
+                 - grc_nf%dwt_seedn_to_leaf(g)     * dt &
+                 - grc_nf%dwt_seedn_to_deadstem(g) * dt &
+                 - grc_nf%dwt_seedn_to_npool(g)    * dt
+         end do
+
          do fc = 1, num_soilc_with_inactive
+
             c = filter_soilc_with_inactive(fc)
-            
-            col_ns%decomp_npools_vr(c,j,i_met_lit) = col_ns%decomp_npools_vr(c,j,i_met_lit) + &
-                  col_nf%dwt_frootn_to_litr_met_n(c,j) * dt
-            col_ns%decomp_npools_vr(c,j,i_cel_lit) = col_ns%decomp_npools_vr(c,j,i_cel_lit) + &
-                  col_nf%dwt_frootn_to_litr_cel_n(c,j) * dt
-            col_ns%decomp_npools_vr(c,j,i_lig_lit) = col_ns%decomp_npools_vr(c,j,i_lig_lit) + &
-                  col_nf%dwt_frootn_to_litr_lig_n(c,j) * dt
-            col_ns%decomp_npools_vr(c,j,i_cwd) = col_ns%decomp_npools_vr(c,j,i_cwd) + &
-                  ( col_nf%dwt_livecrootn_to_cwdn(c,j) + col_nf%dwt_deadcrootn_to_cwdn(c,j) ) * dt
+            col_ns%prod10n(c) = col_ns%prod10n(c) + col_nf%dwt_prod10n_gain(c)*dt
+            col_ns%prod100n(c) = col_ns%prod100n(c) + col_nf%dwt_prod100n_gain(c)*dt
+            col_ns%prod1n(c) = col_ns%prod1n(c) + col_nf%dwt_crop_productn_gain(c)*dt
+
+            do j = 1,nlevdecomp
 
+               col_ns%decomp_npools_vr(c,j,i_met_lit) = col_ns%decomp_npools_vr(c,j,i_met_lit) + &
+                    col_nf%dwt_frootn_to_litr_met_n(c,j) * dt
+               col_ns%decomp_npools_vr(c,j,i_cel_lit) = col_ns%decomp_npools_vr(c,j,i_cel_lit) + &
+                    col_nf%dwt_frootn_to_litr_cel_n(c,j) * dt
+               col_ns%decomp_npools_vr(c,j,i_lig_lit) = col_ns%decomp_npools_vr(c,j,i_lig_lit) + &
+                    col_nf%dwt_frootn_to_litr_lig_n(c,j) * dt
+               col_ns%decomp_npools_vr(c,j,i_cwd) = col_ns%decomp_npools_vr(c,j,i_cwd) + &
+                    ( col_nf%dwt_livecrootn_to_cwdn(c,j) + col_nf%dwt_deadcrootn_to_cwdn(c,j) ) * dt
+
+            end do
          end do
-      end do
+      end if
 
   end subroutine NitrogenStateUpdateDynPatch
-   
-   !-----------------------------------------------------------------------
-   subroutine NitrogenStateUpdate_Phase1_col(num_soilc, filter_soilc, cnstate_vars, dt)
-      !
-      ! !DESCRIPTION:
-      ! On the radiation time step, update all the prognostic nitrogen state
-      ! variables (except for gap-phase mortality and fire fluxes)
-      !
-      use tracer_varcon, only : is_active_betr_bgc
-      ! !ARGUMENTS:
-      integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
-      integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
-      type(cnstate_type)       , intent(in)    :: cnstate_vars
-      real(r8)                  , intent(in)    :: dt        ! radiation time step (seconds)
-      
-      !
-      ! !LOCAL VARIABLES:
-      integer :: c,p,j,l,k ! indices
-      integer :: fp,fc     ! lake filter indices
-      real(r8), parameter :: frootc_nfix_thc = 10._r8  !threshold fine root carbon for nitrogen fixation gC/m2
-      
-      integer:: kyr                     ! current year
-      integer:: kmo                     ! month of year  (1, ..., 12)
-      integer:: kda                     ! day of month   (1, ..., 31)
-      integer:: mcsec                   ! seconds of day (0, ..., seconds/day)
-      !-----------------------------------------------------------------------
-      
-      associate(                                                                &
+
+  !-----------------------------------------------------------------------
+  subroutine NitrogenStateUpdate1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+       cnstate_vars, dt)
+    !
+    ! !DESCRIPTION:
+    ! On the radiation time step, update all the prognostic nitrogen state
+    ! variables (except for gap-phase mortality and fire fluxes)
+    !
+      !$acc routine seq
+    use tracer_varcon, only : is_active_betr_bgc
+    ! !ARGUMENTS:
+    integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
+    integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    type(cnstate_type)       , intent(in)    :: cnstate_vars
+    real(r8)                  , intent(in)    :: dt        ! radiation time step (seconds)
+
+    !
+    ! !LOCAL VARIABLES:
+    integer :: c,p,j,l,k ! indices
+    integer :: fp,fc     ! lake filter indices
+    real(r8), parameter :: frootc_nfix_thc = 10._r8  !threshold fine root carbon for nitrogen fixation gC/m2
+
+    integer:: kyr                     ! current year
+    integer:: kmo                     ! month of year  (1, ..., 12)
+    integer:: kda                     ! day of month   (1, ..., 31)
+    integer:: mcsec                   ! seconds of day (0, ..., seconds/day)
+    !-----------------------------------------------------------------------
+
+    associate(                                                                                           &
          ivt                   => veg_pp%itype                                , & ! Input:  [integer  (:)     ]  pft vegetation type
-         
+
          woody                 => veg_vp%woody                         , & ! Input:  [real(r8) (:)     ]  binary flag for woody lifeform (1=woody, 0=not woody)
-         
+
          cascade_donor_pool    => decomp_cascade_con%cascade_donor_pool    , & ! Input:  [integer  (:)     ]  which pool is C taken from for a given decomposition step
          cascade_receiver_pool => decomp_cascade_con%cascade_receiver_pool , & ! Input:  [integer  (:)     ]  which pool is C added to for a given decomposition step
-         
+
          ndep_prof             => cnstate_vars%ndep_prof_col               , & ! Input:  [real(r8) (:,:)   ]  profile over which N deposition is distributed through column (1/m)
          nfixation_prof        => cnstate_vars%nfixation_prof_col           & ! Input:  [real(r8) (:,:)   ]  profile over which N fixation is distributed through column (1/m)
-         
+
          )
-         
-         ! column-level fluxes
-         
-         if (.not. is_active_betr_bgc .and. .not.(use_pflotran .and. pf_cmode)) then
 
-            !$acc parallel loop independent gang vector collapse(2) default(present) private(c)
+      ! column-level fluxes
+
+      if (.not. is_active_betr_bgc .and. .not.(use_pflotran .and. pf_cmode)) then
+
+         do j = 1, nlevdecomp
+            do fc = 1,num_soilc
+               c = filter_soilc(fc)
+               
+               ! N deposition and fixation (put all into NH4 pool)
+               col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%ndep_to_sminn(c)*dt * ndep_prof(c,j)
+               col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%nfix_to_sminn(c)*dt * nfixation_prof(c,j)
+
+               ! plant to litter fluxes
+               ! phenology and dynamic landcover fluxes
+               if(.not.use_fates) then
+                  col_nf%decomp_npools_sourcesink(c,j,i_met_lit) = &
+                       col_nf%phenology_n_to_litr_met_n(c,j) * dt
+
+                  col_nf%decomp_npools_sourcesink(c,j,i_cel_lit) = &
+                       col_nf%phenology_n_to_litr_cel_n(c,j) * dt
+
+                  col_nf%decomp_npools_sourcesink(c,j,i_lig_lit) = &
+                       col_nf%phenology_n_to_litr_lig_n(c,j) * dt
+               end if
+            end do
+         end do
+
+         ! repeating N dep and fixation for crops
+         if ( crop_prog )then
             do j = 1, nlevdecomp
+
+               ! column loop
                do fc = 1,num_soilc
                   c = filter_soilc(fc)
-                  
                   ! N deposition and fixation (put all into NH4 pool)
-                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%ndep_to_sminn(c)*dt * ndep_prof(c,j)
-                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%nfix_to_sminn(c)*dt * nfixation_prof(c,j)
-                  
-                  ! plant to litter fluxes
-                  ! phenology and dynamic landcover fluxes
-                  if(.not.use_fates) then
-                     col_nf%decomp_npools_sourcesink(c,j,i_met_lit) = &
-                     col_nf%phenology_n_to_litr_met_n(c,j) * dt
-                     
-                     col_nf%decomp_npools_sourcesink(c,j,i_cel_lit) = &
-                     col_nf%phenology_n_to_litr_cel_n(c,j) * dt
-                     
-                     col_nf%decomp_npools_sourcesink(c,j,i_lig_lit) = &
-                     col_nf%phenology_n_to_litr_lig_n(c,j) * dt
-                  end if
+                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%fert_to_sminn(c)*dt * ndep_prof(c,j)
+                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%soyfixn_to_sminn(c)*dt * nfixation_prof(c,j)
                end do
             end do
-            
-            ! repeating N dep and fixation for crops
-            if ( crop_prog )then
-               !$acc parallel loop independent gang vector collapse(2) default(present) private(c)
-               do j = 1, nlevdecomp
-                  ! column loop
-                  do fc = 1,num_soilc
-                     c = filter_soilc(fc)
-                     ! N deposition and fixation (put all into NH4 pool)
-                     col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%fert_to_sminn(c)*dt * ndep_prof(c,j)
-                     col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%soyfixn_to_sminn(c)*dt * nfixation_prof(c,j)
-                  end do
-               end do
-            end if
-            
-            ! decomposition fluxes
-            !$acc parallel loop independent gang worker collapse(2) default(present) private(c) 
+         end if
+
+         ! decomposition fluxes
+         do k = 1, ndecomp_cascade_transitions
             do j = 1, nlevdecomp
                ! column loop
                do fc = 1,num_soilc
                   c = filter_soilc(fc)
-                  !$acc loop vector independent 
-                  do k = 1, ndecomp_cascade_transitions
-                     !$acc atomic update 
-                     col_nf%decomp_npools_sourcesink(c,j,cascade_donor_pool(k)) = &
-                        col_nf%decomp_npools_sourcesink(c,j,cascade_donor_pool(k)) - &
-                        col_nf%decomp_cascade_ntransfer_vr(c,j,k) * dt
-                     !$acc end atomic 
-                  end do
+
+                  col_nf%decomp_npools_sourcesink(c,j,cascade_donor_pool(k)) = &
+                       col_nf%decomp_npools_sourcesink(c,j,cascade_donor_pool(k)) - &
+                       col_nf%decomp_cascade_ntransfer_vr(c,j,k) * dt
                end do
             end do
-            
-            !$acc parallel loop independent gang worker collapse(2) default(present) private(c) 
-            do j = 1, nlevdecomp
-               ! column loop
-               do fc = 1,num_soilc
-                  c = filter_soilc(fc)
+         end do
 
-                  !$acc loop vector independent 
-                  do k = 1, ndecomp_cascade_transitions
-                     if ( cascade_receiver_pool(k) /= 0 ) then  ! skip terminal transitions
-                        !$acc atomic update 
-                        col_nf%decomp_npools_sourcesink(c,j,cascade_receiver_pool(k)) = &
-                           col_nf%decomp_npools_sourcesink(c,j,cascade_receiver_pool(k)) + &
-                           (col_nf%decomp_cascade_ntransfer_vr(c,j,k) + col_nf%decomp_cascade_sminn_flux_vr(c,j,k)) * dt
-                        !$acc end atomic 
-                     else  ! terminal transitions
-                        !$acc atomic update 
-                        col_nf%decomp_npools_sourcesink(c,j,cascade_donor_pool(k)) = &
-                           col_nf%decomp_npools_sourcesink(c,j,cascade_donor_pool(k)) - &
-                           col_nf%decomp_cascade_sminn_flux_vr(c,j,k) * dt
-                        !$acc end atomic 
-                     end if
+         do k = 1, ndecomp_cascade_transitions
+            if ( cascade_receiver_pool(k) /= 0 ) then  ! skip terminal transitions
+               do j = 1, nlevdecomp
+                  ! column loop
+                  do fc = 1,num_soilc
+                     c = filter_soilc(fc)
+
+                     col_nf%decomp_npools_sourcesink(c,j,cascade_receiver_pool(k)) = &
+                          col_nf%decomp_npools_sourcesink(c,j,cascade_receiver_pool(k)) + &
+                          (col_nf%decomp_cascade_ntransfer_vr(c,j,k) + col_nf%decomp_cascade_sminn_flux_vr(c,j,k)) * dt
                   end do
                end do
-            end do
-            
-            !$acc parallel loop independent gang vector collapse(2) default(present) private(c)  
-            do j = 1, nlevdecomp
-               ! column loop
-               do fc = 1,num_soilc
-                  c = filter_soilc(fc)
-                  
-                  ! mineralization fluxes (divert a fraction of this stream to nitrification flux, add the rest to NH4 pool)
-                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%gross_nmin_vr(c,j)*dt
-                  
-                  ! immobilization fluxes
-                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) - col_nf%actual_immob_nh4_vr(c,j)*dt
-                  col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) - col_nf%actual_immob_no3_vr(c,j)*dt
-                  
-                  ! plant uptake fluxes
-                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) - col_nf%smin_nh4_to_plant_vr(c,j)*dt
-                  col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) - col_nf%smin_no3_to_plant_vr(c,j)*dt
-                  
-                  ! Account for nitrification fluxes
-                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) - col_nf%f_nit_vr(c,j) * dt
-                  col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) + col_nf%f_nit_vr(c,j) * dt * (1._r8 - nitrif_n2o_loss_frac)
-                  
-                  ! Account for denitrification fluxes
-                  col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) - col_nf%f_denit_vr(c,j) * dt
-                  
-                  ! flux that prevents N limitation (when Carbon_only is set; put all into NH4)
-                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%supplement_to_sminn_vr(c,j)*dt
-                  
-                  ! update diagnostic total
-                  col_ns%sminn_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_ns%smin_no3_vr(c,j)
-                  
-               end do ! end of column loop
-            end do
-            
-         endif  !end if is_active_betr_bgc 
+            else  ! terminal transitions
+               do j = 1, nlevdecomp
+                  ! column loop
+                  do fc = 1,num_soilc
+                     c = filter_soilc(fc)
+                     col_nf%decomp_npools_sourcesink(c,j,cascade_donor_pool(k)) = &
+                          col_nf%decomp_npools_sourcesink(c,j,cascade_donor_pool(k)) - &
+                          col_nf%decomp_cascade_sminn_flux_vr(c,j,k) * dt
+                  end do
+               end do
+            end if
+         end do
          
-         ! forest fertilization
-         if (forest_fert_exp) then
-            kyr = year_curr; kmo = mon_curr; kda = day_curr; mcsec = secs_curr;
-
+         do j = 1, nlevdecomp
+            ! column loop
             do fc = 1,num_soilc
                c = filter_soilc(fc)
-               if ( ((fert_continue(c) == 1 .and. kyr > fert_start(c) .and. kyr <= fert_end(c)) .or.  kyr == fert_start(c)) &
+
+               ! mineralization fluxes (divert a fraction of this stream to nitrification flux, add the rest to NH4 pool)
+               col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%gross_nmin_vr(c,j)*dt
+
+               ! immobilization fluxes
+               col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) - col_nf%actual_immob_nh4_vr(c,j)*dt
+
+               col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) - col_nf%actual_immob_no3_vr(c,j)*dt
+
+               ! plant uptake fluxes
+               col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) - col_nf%smin_nh4_to_plant_vr(c,j)*dt
+
+               col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) - col_nf%smin_no3_to_plant_vr(c,j)*dt
+
+               ! Account for nitrification fluxes
+               col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) - col_nf%f_nit_vr(c,j) * dt
+
+               col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) + col_nf%f_nit_vr(c,j) * dt * (1._r8 - nitrif_n2o_loss_frac)
+
+               ! Account for denitrification fluxes
+               col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) - col_nf%f_denit_vr(c,j) * dt
+
+               ! flux that prevents N limitation (when Carbon_only is set; put all into NH4)
+               col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%supplement_to_sminn_vr(c,j)*dt
+
+               ! update diagnostic total
+               col_ns%sminn_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_ns%smin_no3_vr(c,j)
+
+            end do ! end of column loop
+         end do
+         
+      endif  !end if is_active_betr_bgc 
+
+      ! forest fertilization
+      call get_curr_date(kyr, kmo, kda, mcsec)
+      if (forest_fert_exp) then
+         do fc = 1,num_soilc
+            c = filter_soilc(fc)
+            if ( ((fert_continue(c) == 1 .and. kyr > fert_start(c) .and. kyr <= fert_end(c)) .or.  kyr == fert_start(c)) &
                .and. fert_type(c) == 1 &
                .and. kda == 1  .and. mcsec == 1800) then ! fertilization assumed to occur at the begnining of each month
-                  do j = 1, nlevdecomp
-                     col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + fert_dose(c,kmo)/2._r8*ndep_prof(c,j)
-                     col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) + fert_dose(c,kmo)/2._r8*ndep_prof(c,j)
-                     col_ns%sminn_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_ns%smin_no3_vr(c,j)
-                  end do
-               end if
-            end do
-         end if
-         
-      end associate
-         
-      end subroutine NitrogenStateUpdate_Phase1_col
-      
-      subroutine NitrogenStateUpdate_Phase1_pft(num_soilp, filter_soilp,dt)
-         implicit none 
-
-         integer , intent(in) :: num_soilp 
-         integer , intent(in) :: filter_soilp(:)
-         real(r8), intent(in) :: dt 
-         !
-         integer :: p, fp 
-         associate(                                   &
-            ivt                   => veg_pp%itype    , & ! Input:  [integer  (:)     ]  pft vegetation type
-            woody                 => veg_vp%woody      & ! Input:  [real(r8) (:)     ]  binary flag for woody lifeform (1=woody, 0=not woody)
-            )
-            
-            !$acc parallel loop independent gang vector default(present) private(p) 
-            do fp = 1,num_soilp
+               do j = 1, nlevdecomp
+                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + fert_dose(c,kmo)/2._r8*ndep_prof(c,j)
+                  col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) + fert_dose(c,kmo)/2._r8*ndep_prof(c,j)
+                  col_ns%sminn_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_ns%smin_no3_vr(c,j)
+               end do
+            end if
+         end do
+      end if
+
+
+      ! patch loop (veg)
+      if(.not.use_fates) then
+          do fp = 1,num_soilp
               p = filter_soilp(fp)
-               
-               ! phenology: transfer growth fluxes
-               veg_ns%leafn(p)       = veg_ns%leafn(p)       + veg_nf%leafn_xfer_to_leafn(p)*dt
-               veg_ns%leafn_xfer(p)  = veg_ns%leafn_xfer(p)  - veg_nf%leafn_xfer_to_leafn(p)*dt
-               veg_ns%frootn(p)      = veg_ns%frootn(p)      + veg_nf%frootn_xfer_to_frootn(p)*dt
-               veg_ns%frootn_xfer(p) = veg_ns%frootn_xfer(p) - veg_nf%frootn_xfer_to_frootn(p)*dt
-               
-               if (woody(ivt(p)) == 1.0_r8) then
+
+              ! phenology: transfer growth fluxes
+              veg_ns%leafn(p)       = veg_ns%leafn(p)       + veg_nf%leafn_xfer_to_leafn(p)*dt
+              veg_ns%leafn_xfer(p)  = veg_ns%leafn_xfer(p)  - veg_nf%leafn_xfer_to_leafn(p)*dt
+              veg_ns%frootn(p)      = veg_ns%frootn(p)      + veg_nf%frootn_xfer_to_frootn(p)*dt
+              veg_ns%frootn_xfer(p) = veg_ns%frootn_xfer(p) - veg_nf%frootn_xfer_to_frootn(p)*dt
+
+              if (woody(ivt(p)) == 1.0_r8) then
                   veg_ns%livestemn(p)       = veg_ns%livestemn(p)       + veg_nf%livestemn_xfer_to_livestemn(p)*dt
                   veg_ns%livestemn_xfer(p)  = veg_ns%livestemn_xfer(p)  - veg_nf%livestemn_xfer_to_livestemn(p)*dt
                   veg_ns%deadstemn(p)       = veg_ns%deadstemn(p)       + veg_nf%deadstemn_xfer_to_deadstemn(p)*dt
@@ -324,24 +295,24 @@ module NitrogenStateUpdate1Mod
                   veg_ns%livecrootn_xfer(p) = veg_ns%livecrootn_xfer(p) - veg_nf%livecrootn_xfer_to_livecrootn(p)*dt
                   veg_ns%deadcrootn(p)      = veg_ns%deadcrootn(p)      + veg_nf%deadcrootn_xfer_to_deadcrootn(p)*dt
                   veg_ns%deadcrootn_xfer(p) = veg_ns%deadcrootn_xfer(p) - veg_nf%deadcrootn_xfer_to_deadcrootn(p)*dt
-               end if
-               
-               if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+              end if
+
+              if (ivt(p) >= npcropmin) then ! skip 2 generic crops
                   ! lines here for consistency; the transfer terms are zero
                   veg_ns%livestemn(p)       = veg_ns%livestemn(p)      + veg_nf%livestemn_xfer_to_livestemn(p)*dt
                   veg_ns%livestemn_xfer(p)  = veg_ns%livestemn_xfer(p) - veg_nf%livestemn_xfer_to_livestemn(p)*dt
                   veg_ns%grainn(p)          = veg_ns%grainn(p)         + veg_nf%grainn_xfer_to_grainn(p)*dt
                   veg_ns%grainn_xfer(p)     = veg_ns%grainn_xfer(p)    - veg_nf%grainn_xfer_to_grainn(p)*dt
-               end if
-               
-               ! phenology: litterfall and retranslocation fluxes
-               veg_ns%leafn(p)    = veg_ns%leafn(p)    - veg_nf%leafn_to_litter(p)*dt
-               veg_ns%frootn(p)   = veg_ns%frootn(p)   - veg_nf%frootn_to_litter(p)*dt
-               veg_ns%leafn(p)    = veg_ns%leafn(p)    - veg_nf%leafn_to_retransn(p)*dt
-               veg_ns%retransn(p) = veg_ns%retransn(p) + veg_nf%leafn_to_retransn(p)*dt
-               
-               ! live wood turnover and retranslocation fluxes
-               if (woody(ivt(p)) == 1._r8) then
+              end if
+
+              ! phenology: litterfall and retranslocation fluxes
+              veg_ns%leafn(p)    = veg_ns%leafn(p)    - veg_nf%leafn_to_litter(p)*dt
+              veg_ns%frootn(p)   = veg_ns%frootn(p)   - veg_nf%frootn_to_litter(p)*dt
+              veg_ns%leafn(p)    = veg_ns%leafn(p)    - veg_nf%leafn_to_retransn(p)*dt
+              veg_ns%retransn(p) = veg_ns%retransn(p) + veg_nf%leafn_to_retransn(p)*dt
+
+              ! live wood turnover and retranslocation fluxes
+              if (woody(ivt(p)) == 1._r8) then
                   veg_ns%livestemn(p)  = veg_ns%livestemn(p)  - veg_nf%livestemn_to_deadstemn(p)*dt
                   veg_ns%deadstemn(p)  = veg_ns%deadstemn(p)  + veg_nf%livestemn_to_deadstemn(p)*dt
                   veg_ns%livestemn(p)  = veg_ns%livestemn(p)  - veg_nf%livestemn_to_retransn(p)*dt
@@ -350,40 +321,40 @@ module NitrogenStateUpdate1Mod
                   veg_ns%deadcrootn(p) = veg_ns%deadcrootn(p) + veg_nf%livecrootn_to_deadcrootn(p)*dt
                   veg_ns%livecrootn(p) = veg_ns%livecrootn(p) - veg_nf%livecrootn_to_retransn(p)*dt
                   veg_ns%retransn(p)   = veg_ns%retransn(p)   + veg_nf%livecrootn_to_retransn(p)*dt
-               end if
-               if (ivt(p) >= npcropmin) then ! Beth adds retrans from froot
+              end if
+              if (ivt(p) >= npcropmin) then ! Beth adds retrans from froot
                   veg_ns%frootn(p)     = veg_ns%frootn(p)     - veg_nf%frootn_to_retransn(p)*dt
                   veg_ns%retransn(p)   = veg_ns%retransn(p)   + veg_nf%frootn_to_retransn(p)*dt
                   veg_ns%livestemn(p)  = veg_ns%livestemn(p)  - veg_nf%livestemn_to_litter(p)*dt
                   veg_ns%livestemn(p)  = veg_ns%livestemn(p)  - veg_nf%livestemn_to_retransn(p)*dt
                   veg_ns%retransn(p)   = veg_ns%retransn(p)   + veg_nf%livestemn_to_retransn(p)*dt
                   veg_ns%grainn(p)     = veg_ns%grainn(p)     - veg_nf%grainn_to_food(p)*dt
-                  
+
                   veg_ns%cropseedn_deficit(p) = veg_ns%cropseedn_deficit(p) &
-                  - veg_nf%crop_seedn_to_leaf(p) * dt
-               end if
-               
-               ! uptake from soil mineral N pool
-               veg_ns%npool(p) = &
-               veg_ns%npool(p) + veg_nf%sminn_to_npool(p)*dt
-               if (nu_com .ne. 'RD') veg_ns%npool(p) = veg_ns%npool(p) + veg_nf%supplement_to_plantn(p)*dt
-               if (NFIX_PTASE_plant) veg_ns%npool(p) = veg_ns%npool(p) + veg_nf%nfix_to_plantn(p)*dt
-               
-               ! deployment from retranslocation pool
-               veg_ns%npool(p)    = veg_ns%npool(p)    + veg_nf%retransn_to_npool(p)*dt
-               veg_ns%retransn(p) = veg_ns%retransn(p) - veg_nf%retransn_to_npool(p)*dt
-               
-               ! allocation fluxes
-               veg_ns%npool(p)           = veg_ns%npool(p)          - veg_nf%npool_to_leafn(p)*dt
-               veg_ns%leafn(p)           = veg_ns%leafn(p)          + veg_nf%npool_to_leafn(p)*dt
-               veg_ns%npool(p)           = veg_ns%npool(p)          - veg_nf%npool_to_leafn_storage(p)*dt
-               veg_ns%leafn_storage(p)   = veg_ns%leafn_storage(p)  + veg_nf%npool_to_leafn_storage(p)*dt
-               veg_ns%npool(p)           = veg_ns%npool(p)          - veg_nf%npool_to_frootn(p)*dt
-               veg_ns%frootn(p)          = veg_ns%frootn(p)         + veg_nf%npool_to_frootn(p)*dt
-               veg_ns%npool(p)           = veg_ns%npool(p)          - veg_nf%npool_to_frootn_storage(p)*dt
-               veg_ns%frootn_storage(p)  = veg_ns%frootn_storage(p) + veg_nf%npool_to_frootn_storage(p)*dt
-               
-               if (woody(ivt(p)) == 1._r8) then
+                        - veg_nf%crop_seedn_to_leaf(p) * dt
+              end if
+
+              ! uptake from soil mineral N pool
+              veg_ns%npool(p) = &
+                    veg_ns%npool(p) + veg_nf%sminn_to_npool(p)*dt
+              if (nu_com .ne. 'RD') veg_ns%npool(p) = veg_ns%npool(p) + veg_nf%supplement_to_plantn(p)*dt
+              if (NFIX_PTASE_plant) veg_ns%npool(p) = veg_ns%npool(p) + veg_nf%nfix_to_plantn(p)*dt
+
+              ! deployment from retranslocation pool
+              veg_ns%npool(p)    = veg_ns%npool(p)    + veg_nf%retransn_to_npool(p)*dt
+              veg_ns%retransn(p) = veg_ns%retransn(p) - veg_nf%retransn_to_npool(p)*dt
+
+              ! allocation fluxes
+              veg_ns%npool(p)           = veg_ns%npool(p)          - veg_nf%npool_to_leafn(p)*dt
+              veg_ns%leafn(p)           = veg_ns%leafn(p)          + veg_nf%npool_to_leafn(p)*dt
+              veg_ns%npool(p)           = veg_ns%npool(p)          - veg_nf%npool_to_leafn_storage(p)*dt
+              veg_ns%leafn_storage(p)   = veg_ns%leafn_storage(p)  + veg_nf%npool_to_leafn_storage(p)*dt
+              veg_ns%npool(p)           = veg_ns%npool(p)          - veg_nf%npool_to_frootn(p)*dt
+              veg_ns%frootn(p)          = veg_ns%frootn(p)         + veg_nf%npool_to_frootn(p)*dt
+              veg_ns%npool(p)           = veg_ns%npool(p)          - veg_nf%npool_to_frootn_storage(p)*dt
+              veg_ns%frootn_storage(p)  = veg_ns%frootn_storage(p) + veg_nf%npool_to_frootn_storage(p)*dt
+
+              if (woody(ivt(p)) == 1._r8) then
                   veg_ns%npool(p)              = veg_ns%npool(p)              - veg_nf%npool_to_livestemn(p)*dt
                   veg_ns%livestemn(p)          = veg_ns%livestemn(p)          + veg_nf%npool_to_livestemn(p)*dt
                   veg_ns%npool(p)              = veg_ns%npool(p)              - veg_nf%npool_to_livestemn_storage(p)*dt
@@ -400,9 +371,9 @@ module NitrogenStateUpdate1Mod
                   veg_ns%deadcrootn(p)         = veg_ns%deadcrootn(p)         + veg_nf%npool_to_deadcrootn(p)*dt
                   veg_ns%npool(p)              = veg_ns%npool(p)              - veg_nf%npool_to_deadcrootn_storage(p)*dt
                   veg_ns%deadcrootn_storage(p) = veg_ns%deadcrootn_storage(p) + veg_nf%npool_to_deadcrootn_storage(p)*dt
-               end if
-               
-               if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+              end if
+
+              if (ivt(p) >= npcropmin) then ! skip 2 generic crops
                   veg_ns%npool(p)              = veg_ns%npool(p)              - veg_nf%npool_to_livestemn(p)*dt
                   veg_ns%livestemn(p)          = veg_ns%livestemn(p)          + veg_nf%npool_to_livestemn(p)*dt
                   veg_ns%npool(p)              = veg_ns%npool(p)              - veg_nf%npool_to_livestemn_storage(p)*dt
@@ -411,15 +382,15 @@ module NitrogenStateUpdate1Mod
                   veg_ns%grainn(p)             = veg_ns%grainn(p)             + veg_nf%npool_to_grainn(p)*dt
                   veg_ns%npool(p)              = veg_ns%npool(p)              - veg_nf%npool_to_grainn_storage(p)*dt
                   veg_ns%grainn_storage(p)     = veg_ns%grainn_storage(p)     + veg_nf%npool_to_grainn_storage(p)*dt
-               end if
-               
-               ! move storage pools into transfer pools
-               veg_ns%leafn_storage(p)  = veg_ns%leafn_storage(p)  - veg_nf%leafn_storage_to_xfer(p)*dt
-               veg_ns%leafn_xfer(p)     = veg_ns%leafn_xfer(p)     + veg_nf%leafn_storage_to_xfer(p)*dt
-               veg_ns%frootn_storage(p) = veg_ns%frootn_storage(p) - veg_nf%frootn_storage_to_xfer(p)*dt
-               veg_ns%frootn_xfer(p)    = veg_ns%frootn_xfer(p)    + veg_nf%frootn_storage_to_xfer(p)*dt
-               
-               if (woody(ivt(p)) == 1._r8) then
+              end if
+
+              ! move storage pools into transfer pools
+              veg_ns%leafn_storage(p)  = veg_ns%leafn_storage(p)  - veg_nf%leafn_storage_to_xfer(p)*dt
+              veg_ns%leafn_xfer(p)     = veg_ns%leafn_xfer(p)     + veg_nf%leafn_storage_to_xfer(p)*dt
+              veg_ns%frootn_storage(p) = veg_ns%frootn_storage(p) - veg_nf%frootn_storage_to_xfer(p)*dt
+              veg_ns%frootn_xfer(p)    = veg_ns%frootn_xfer(p)    + veg_nf%frootn_storage_to_xfer(p)*dt
+
+              if (woody(ivt(p)) == 1._r8) then
                   veg_ns%livestemn_storage(p)  = veg_ns%livestemn_storage(p)  - veg_nf%livestemn_storage_to_xfer(p)*dt
                   veg_ns%livestemn_xfer(p)     = veg_ns%livestemn_xfer(p)     + veg_nf%livestemn_storage_to_xfer(p)*dt
                   veg_ns%deadstemn_storage(p)  = veg_ns%deadstemn_storage(p)  - veg_nf%deadstemn_storage_to_xfer(p)*dt
@@ -428,21 +399,22 @@ module NitrogenStateUpdate1Mod
                   veg_ns%livecrootn_xfer(p)    = veg_ns%livecrootn_xfer(p)    + veg_nf%livecrootn_storage_to_xfer(p)*dt
                   veg_ns%deadcrootn_storage(p) = veg_ns%deadcrootn_storage(p) - veg_nf%deadcrootn_storage_to_xfer(p)*dt
                   veg_ns%deadcrootn_xfer(p)    = veg_ns%deadcrootn_xfer(p)    + veg_nf%deadcrootn_storage_to_xfer(p)*dt
-               end if
-               
-               if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+              end if
+
+              if (ivt(p) >= npcropmin) then ! skip 2 generic crops
                   ! lines here for consistency; the transfer terms are zero
                   veg_ns%livestemn_storage(p)  = veg_ns%livestemn_storage(p) - veg_nf%livestemn_storage_to_xfer(p)*dt
                   veg_ns%livestemn_xfer(p)     = veg_ns%livestemn_xfer(p)    + veg_nf%livestemn_storage_to_xfer(p)*dt
                   veg_ns%grainn_storage(p)     = veg_ns%grainn_storage(p)    - veg_nf%grainn_storage_to_xfer(p)*dt
                   veg_ns%grainn_xfer(p)        = veg_ns%grainn_xfer(p)       + veg_nf%grainn_storage_to_xfer(p)*dt
-               end if
-               
-            end do  ! num_soilp
+              end if
+
+          end do  ! num_soilp
+
+      end if ! if(.not.use_fates)
+
+    end associate
+
+  end subroutine NitrogenStateUpdate1
 
-       end associate 
-            
-      end subroutine NitrogenStateUpdate_Phase1_pft
-         
 end module NitrogenStateUpdate1Mod
-      
diff --git a/components/elm/src/biogeochem/NitrogenStateUpdate2Mod.F90 b/components/elm/src/biogeochem/NitrogenStateUpdate2Mod.F90
index 8047464e51..9121954e63 100644
--- a/components/elm/src/biogeochem/NitrogenStateUpdate2Mod.F90
+++ b/components/elm/src/biogeochem/NitrogenStateUpdate2Mod.F90
@@ -9,13 +9,14 @@ module NitrogenStateUpdate2Mod
   use elm_varpar          , only : nlevsoi, nlevdecomp
   use elm_varpar          , only : i_met_lit, i_cel_lit, i_lig_lit, i_cwd
   use elm_varctl          , only : iulog
+  use CNNitrogenStateType , only : nitrogenstate_type
+  use CNNitrogenFLuxType  , only : nitrogenflux_type
   use ColumnDataType      , only : col_ns, col_nf
   use VegetationType      , only : veg_pp
   use VegetationDataType  , only : veg_ns, veg_nf
   use pftvarcon           , only : npcropmin
   ! bgc interface & pflotran:
   use elm_varctl          , only : use_pflotran, pf_cmode
-  use timeInfoMod, only : dtime_mod 
   !
   implicit none
   save
@@ -29,7 +30,7 @@ module NitrogenStateUpdate2Mod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine NitrogenStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp)
+  subroutine NitrogenStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp,dt)
     !
     ! !DESCRIPTION:
     ! On the radiation time step, update all the prognostic nitrogen state
@@ -37,78 +38,78 @@ contains
     ! NOTE - associate statements have been removed where there are
     ! no science equations. This increases readability and maintainability
     !
+      !$acc routine seq
     use tracer_varcon, only : is_active_betr_bgc
     ! !ARGUMENTS:
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
     integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
     integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    real(r8) , intent(in)   :: dt      ! radiation time step (seconds)
 
     !
     ! !LOCAL VARIABLES:
     integer  :: c,p,j,l ! indices
     integer  :: fp,fc   ! lake filter indices
     !-----------------------------------------------------------------------
-
+      
     ! column-level nitrogen fluxes from gap-phase mortality
       if ( .not. is_active_betr_bgc .and. &
            .not.(use_pflotran .and. pf_cmode)) then
-          !$acc parallel loop independent gang default(present)
          do j = 1, nlevdecomp
-            !$acc loop vector independent private(c)
             do fc = 1,num_soilc
                c = filter_soilc(fc)
 
                col_ns%decomp_npools_vr(c,j,i_met_lit) = &
-                    col_ns%decomp_npools_vr(c,j,i_met_lit) + col_nf%gap_mortality_n_to_litr_met_n(c,j) * dtime_mod
+                    col_ns%decomp_npools_vr(c,j,i_met_lit) + col_nf%gap_mortality_n_to_litr_met_n(c,j) * dt
                col_ns%decomp_npools_vr(c,j,i_cel_lit) = &
-                    col_ns%decomp_npools_vr(c,j,i_cel_lit) + col_nf%gap_mortality_n_to_litr_cel_n(c,j) * dtime_mod
+                    col_ns%decomp_npools_vr(c,j,i_cel_lit) + col_nf%gap_mortality_n_to_litr_cel_n(c,j) * dt
                col_ns%decomp_npools_vr(c,j,i_lig_lit) = &
-                    col_ns%decomp_npools_vr(c,j,i_lig_lit) + col_nf%gap_mortality_n_to_litr_lig_n(c,j) * dtime_mod
+                    col_ns%decomp_npools_vr(c,j,i_lig_lit) + col_nf%gap_mortality_n_to_litr_lig_n(c,j) * dt
                col_ns%decomp_npools_vr(c,j,i_cwd)     = &
-                    col_ns%decomp_npools_vr(c,j,i_cwd)     + col_nf%gap_mortality_n_to_cwdn(c,j)       * dtime_mod
+                    col_ns%decomp_npools_vr(c,j,i_cwd)     + col_nf%gap_mortality_n_to_cwdn(c,j)       * dt
             end do
          end do
 
      endif
 
       ! patch -level nitrogen fluxes from gap-phase mortality
-      !$acc parallel loop independent gang vector default(present) private(p)
+
       do fp = 1,num_soilp
          p = filter_soilp(fp)
 
          ! displayed pools
-         veg_ns%leafn(p)              =  veg_ns%leafn(p)      - veg_nf%m_leafn_to_litter(p)      * dtime_mod
-         veg_ns%frootn(p)             =  veg_ns%frootn(p)     - veg_nf%m_frootn_to_litter(p)     * dtime_mod
-         veg_ns%livestemn(p)          =  veg_ns%livestemn(p)  - veg_nf%m_livestemn_to_litter(p)  * dtime_mod
-         veg_ns%deadstemn(p)          =  veg_ns%deadstemn(p)  - veg_nf%m_deadstemn_to_litter(p)  * dtime_mod
-         veg_ns%livecrootn(p)         =  veg_ns%livecrootn(p) - veg_nf%m_livecrootn_to_litter(p) * dtime_mod
-         veg_ns%deadcrootn(p)         =  veg_ns%deadcrootn(p) - veg_nf%m_deadcrootn_to_litter(p) * dtime_mod
-         veg_ns%retransn(p)           =  veg_ns%retransn(p)   - veg_nf%m_retransn_to_litter(p)   * dtime_mod
-         veg_ns%npool(p)              =  veg_ns%npool(p)      - veg_nf%m_npool_to_litter(p)      * dtime_mod
+         veg_ns%leafn(p)              =  veg_ns%leafn(p)      - veg_nf%m_leafn_to_litter(p)      * dt
+         veg_ns%frootn(p)             =  veg_ns%frootn(p)     - veg_nf%m_frootn_to_litter(p)     * dt
+         veg_ns%livestemn(p)          =  veg_ns%livestemn(p)  - veg_nf%m_livestemn_to_litter(p)  * dt
+         veg_ns%deadstemn(p)          =  veg_ns%deadstemn(p)  - veg_nf%m_deadstemn_to_litter(p)  * dt
+         veg_ns%livecrootn(p)         =  veg_ns%livecrootn(p) - veg_nf%m_livecrootn_to_litter(p) * dt
+         veg_ns%deadcrootn(p)         =  veg_ns%deadcrootn(p) - veg_nf%m_deadcrootn_to_litter(p) * dt
+         veg_ns%retransn(p)           =  veg_ns%retransn(p)   - veg_nf%m_retransn_to_litter(p)   * dt
+         veg_ns%npool(p)              =  veg_ns%npool(p)      - veg_nf%m_npool_to_litter(p)      * dt
 
          ! storage pools
-         veg_ns%leafn_storage(p)      =  veg_ns%leafn_storage(p)      - veg_nf%m_leafn_storage_to_litter(p)      * dtime_mod
-         veg_ns%frootn_storage(p)     =  veg_ns%frootn_storage(p)     - veg_nf%m_frootn_storage_to_litter(p)     * dtime_mod
-         veg_ns%livestemn_storage(p)  =  veg_ns%livestemn_storage(p)  - veg_nf%m_livestemn_storage_to_litter(p)  * dtime_mod
-         veg_ns%deadstemn_storage(p)  =  veg_ns%deadstemn_storage(p)  - veg_nf%m_deadstemn_storage_to_litter(p)  * dtime_mod
-         veg_ns%livecrootn_storage(p) =  veg_ns%livecrootn_storage(p) - veg_nf%m_livecrootn_storage_to_litter(p) * dtime_mod
-         veg_ns%deadcrootn_storage(p) =  veg_ns%deadcrootn_storage(p) - veg_nf%m_deadcrootn_storage_to_litter(p) * dtime_mod
+         veg_ns%leafn_storage(p)      =  veg_ns%leafn_storage(p)      - veg_nf%m_leafn_storage_to_litter(p)      * dt
+         veg_ns%frootn_storage(p)     =  veg_ns%frootn_storage(p)     - veg_nf%m_frootn_storage_to_litter(p)     * dt
+         veg_ns%livestemn_storage(p)  =  veg_ns%livestemn_storage(p)  - veg_nf%m_livestemn_storage_to_litter(p)  * dt
+         veg_ns%deadstemn_storage(p)  =  veg_ns%deadstemn_storage(p)  - veg_nf%m_deadstemn_storage_to_litter(p)  * dt
+         veg_ns%livecrootn_storage(p) =  veg_ns%livecrootn_storage(p) - veg_nf%m_livecrootn_storage_to_litter(p) * dt
+         veg_ns%deadcrootn_storage(p) =  veg_ns%deadcrootn_storage(p) - veg_nf%m_deadcrootn_storage_to_litter(p) * dt
 
          ! transfer pools
-         veg_ns%leafn_xfer(p)         =  veg_ns%leafn_xfer(p)      - veg_nf%m_leafn_xfer_to_litter(p)      * dtime_mod
-         veg_ns%frootn_xfer(p)        =  veg_ns%frootn_xfer(p)     - veg_nf%m_frootn_xfer_to_litter(p)     * dtime_mod
-         veg_ns%livestemn_xfer(p)     =  veg_ns%livestemn_xfer(p)  - veg_nf%m_livestemn_xfer_to_litter(p)  * dtime_mod
-         veg_ns%deadstemn_xfer(p)     =  veg_ns%deadstemn_xfer(p)  - veg_nf%m_deadstemn_xfer_to_litter(p)  * dtime_mod
-         veg_ns%livecrootn_xfer(p)    =  veg_ns%livecrootn_xfer(p) - veg_nf%m_livecrootn_xfer_to_litter(p) * dtime_mod
-         veg_ns%deadcrootn_xfer(p)    =  veg_ns%deadcrootn_xfer(p) - veg_nf%m_deadcrootn_xfer_to_litter(p) * dtime_mod
+         veg_ns%leafn_xfer(p)         =  veg_ns%leafn_xfer(p)      - veg_nf%m_leafn_xfer_to_litter(p)      * dt
+         veg_ns%frootn_xfer(p)        =  veg_ns%frootn_xfer(p)     - veg_nf%m_frootn_xfer_to_litter(p)     * dt
+         veg_ns%livestemn_xfer(p)     =  veg_ns%livestemn_xfer(p)  - veg_nf%m_livestemn_xfer_to_litter(p)  * dt
+         veg_ns%deadstemn_xfer(p)     =  veg_ns%deadstemn_xfer(p)  - veg_nf%m_deadstemn_xfer_to_litter(p)  * dt
+         veg_ns%livecrootn_xfer(p)    =  veg_ns%livecrootn_xfer(p) - veg_nf%m_livecrootn_xfer_to_litter(p) * dt
+         veg_ns%deadcrootn_xfer(p)    =  veg_ns%deadcrootn_xfer(p) - veg_nf%m_deadcrootn_xfer_to_litter(p) * dt
 
       end do
 
   end subroutine NitrogenStateUpdate2
 
   !-----------------------------------------------------------------------
-  subroutine NitrogenStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp )
+  subroutine NitrogenStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, dt)
     !
     ! !DESCRIPTION:
     ! Update all the prognostic nitrogen state
@@ -116,12 +117,14 @@ contains
     ! NOTE - associate statements have been removed where there are
     ! no science equations. This increases readability and maintainability
     !
+      !$acc routine seq
     use tracer_varcon, only : is_active_betr_bgc
     ! !ARGUMENTS:
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
     integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
     integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    real(r8)                 , intent(in)    :: dt      ! radiation time step (seconds)
 
     !
     ! !LOCAL VARIABLES:
@@ -137,61 +140,59 @@ contains
            .not.(use_pflotran .and. pf_cmode)) then
          ! column-level nitrogen fluxes from harvest mortality
 
-         !$acc parallel loop independent gang default(present)
          do j = 1,nlevdecomp
-            !$acc loop vector independent private(c)
             do fc = 1,num_soilc
                c = filter_soilc(fc)
                col_ns%decomp_npools_vr(c,j,i_met_lit) = &
-                    col_ns%decomp_npools_vr(c,j,i_met_lit) + col_nf%harvest_n_to_litr_met_n(c,j) * dtime_mod
+                    col_ns%decomp_npools_vr(c,j,i_met_lit) + col_nf%harvest_n_to_litr_met_n(c,j) * dt
                col_ns%decomp_npools_vr(c,j,i_cel_lit) = &
-                    col_ns%decomp_npools_vr(c,j,i_cel_lit) + col_nf%harvest_n_to_litr_cel_n(c,j) * dtime_mod
+                    col_ns%decomp_npools_vr(c,j,i_cel_lit) + col_nf%harvest_n_to_litr_cel_n(c,j) * dt
                col_ns%decomp_npools_vr(c,j,i_lig_lit) = &
-                    col_ns%decomp_npools_vr(c,j,i_lig_lit) + col_nf%harvest_n_to_litr_lig_n(c,j) * dtime_mod
+                    col_ns%decomp_npools_vr(c,j,i_lig_lit) + col_nf%harvest_n_to_litr_lig_n(c,j) * dt
                col_ns%decomp_npools_vr(c,j,i_cwd)     = &
-                    col_ns%decomp_npools_vr(c,j,i_cwd)     + col_nf%harvest_n_to_cwdn(c,j)       * dtime_mod
+                    col_ns%decomp_npools_vr(c,j,i_cwd)     + col_nf%harvest_n_to_cwdn(c,j)       * dt
             end do
          end do
 
       endif
 
       ! patch-level nitrogen fluxes from harvest mortality
-      !$acc parallel loop independent gang vector default(present) private(p)
+
       do fp = 1,num_soilp
          p = filter_soilp(fp)
 
          ! displayed pools
-         veg_ns%leafn(p)      = veg_ns%leafn(p)      - veg_nf%hrv_leafn_to_litter(p)      * dtime_mod
-         veg_ns%frootn(p)     = veg_ns%frootn(p)     - veg_nf%hrv_frootn_to_litter(p)     * dtime_mod
-         veg_ns%livestemn(p)  = veg_ns%livestemn(p)  - veg_nf%hrv_livestemn_to_litter(p)  * dtime_mod
-         veg_ns%deadstemn(p)  = veg_ns%deadstemn(p)  - veg_nf%hrv_deadstemn_to_prod10n(p) * dtime_mod
-         veg_ns%deadstemn(p)  = veg_ns%deadstemn(p)  - veg_nf%hrv_deadstemn_to_prod100n(p)* dtime_mod
-         veg_ns%livecrootn(p) = veg_ns%livecrootn(p) - veg_nf%hrv_livecrootn_to_litter(p) * dtime_mod
-         veg_ns%deadcrootn(p) = veg_ns%deadcrootn(p) - veg_nf%hrv_deadcrootn_to_litter(p) * dtime_mod
-         veg_ns%retransn(p)   = veg_ns%retransn(p)   - veg_nf%hrv_retransn_to_litter(p)   * dtime_mod
-         veg_ns%npool(p)      = veg_ns%npool(p)      - veg_nf%hrv_npool_to_litter(p)     * dtime_mod
+         veg_ns%leafn(p)      = veg_ns%leafn(p)      - veg_nf%hrv_leafn_to_litter(p)      * dt
+         veg_ns%frootn(p)     = veg_ns%frootn(p)     - veg_nf%hrv_frootn_to_litter(p)     * dt
+         veg_ns%livestemn(p)  = veg_ns%livestemn(p)  - veg_nf%hrv_livestemn_to_litter(p)  * dt
+         veg_ns%deadstemn(p)  = veg_ns%deadstemn(p)  - veg_nf%hrv_deadstemn_to_prod10n(p) * dt
+         veg_ns%deadstemn(p)  = veg_ns%deadstemn(p)  - veg_nf%hrv_deadstemn_to_prod100n(p)* dt
+         veg_ns%livecrootn(p) = veg_ns%livecrootn(p) - veg_nf%hrv_livecrootn_to_litter(p) * dt
+         veg_ns%deadcrootn(p) = veg_ns%deadcrootn(p) - veg_nf%hrv_deadcrootn_to_litter(p) * dt
+         veg_ns%retransn(p)   = veg_ns%retransn(p)   - veg_nf%hrv_retransn_to_litter(p)   * dt
+         veg_ns%npool(p)      = veg_ns%npool(p)      - veg_nf%hrv_npool_to_litter(p)     * dt
 
        if (ivt(p) >= npcropmin) then ! skip 2 generic crops
-           veg_ns%livestemn(p)= veg_ns%livestemn(p)  - veg_nf%hrv_livestemn_to_prod1n(p)  * dtime_mod
-           veg_ns%leafn(p)    = veg_ns%leafn(p)      - veg_nf%hrv_leafn_to_prod1n(p)      * dtime_mod
-           veg_ns%grainn(p)   = veg_ns%grainn(p)     - veg_nf%hrv_grainn_to_prod1n(p)     * dtime_mod
+           veg_ns%livestemn(p)= veg_ns%livestemn(p)  - veg_nf%hrv_livestemn_to_prod1n(p)  * dt
+           veg_ns%leafn(p)    = veg_ns%leafn(p)      - veg_nf%hrv_leafn_to_prod1n(p)      * dt
+           veg_ns%grainn(p)   = veg_ns%grainn(p)     - veg_nf%hrv_grainn_to_prod1n(p)     * dt
        end if
 
          ! storage pools
-         veg_ns%leafn_storage(p)      = veg_ns%leafn_storage(p)      - veg_nf%hrv_leafn_storage_to_litter(p)      * dtime_mod
-         veg_ns%frootn_storage(p)     = veg_ns%frootn_storage(p)     - veg_nf%hrv_frootn_storage_to_litter(p)     * dtime_mod
-         veg_ns%livestemn_storage(p)  = veg_ns%livestemn_storage(p)  - veg_nf%hrv_livestemn_storage_to_litter(p)  * dtime_mod
-         veg_ns%deadstemn_storage(p)  = veg_ns%deadstemn_storage(p)  - veg_nf%hrv_deadstemn_storage_to_litter(p)  * dtime_mod
-         veg_ns%livecrootn_storage(p) = veg_ns%livecrootn_storage(p) - veg_nf%hrv_livecrootn_storage_to_litter(p) * dtime_mod
-         veg_ns%deadcrootn_storage(p) = veg_ns%deadcrootn_storage(p) - veg_nf%hrv_deadcrootn_storage_to_litter(p) * dtime_mod
+         veg_ns%leafn_storage(p)      = veg_ns%leafn_storage(p)      - veg_nf%hrv_leafn_storage_to_litter(p)      * dt
+         veg_ns%frootn_storage(p)     = veg_ns%frootn_storage(p)     - veg_nf%hrv_frootn_storage_to_litter(p)     * dt
+         veg_ns%livestemn_storage(p)  = veg_ns%livestemn_storage(p)  - veg_nf%hrv_livestemn_storage_to_litter(p)  * dt
+         veg_ns%deadstemn_storage(p)  = veg_ns%deadstemn_storage(p)  - veg_nf%hrv_deadstemn_storage_to_litter(p)  * dt
+         veg_ns%livecrootn_storage(p) = veg_ns%livecrootn_storage(p) - veg_nf%hrv_livecrootn_storage_to_litter(p) * dt
+         veg_ns%deadcrootn_storage(p) = veg_ns%deadcrootn_storage(p) - veg_nf%hrv_deadcrootn_storage_to_litter(p) * dt
 
          ! transfer pools
-         veg_ns%leafn_xfer(p)      = veg_ns%leafn_xfer(p)      - veg_nf%hrv_leafn_xfer_to_litter(p)      *dtime_mod
-         veg_ns%frootn_xfer(p)     = veg_ns%frootn_xfer(p)     - veg_nf%hrv_frootn_xfer_to_litter(p)     *dtime_mod
-         veg_ns%livestemn_xfer(p)  = veg_ns%livestemn_xfer(p)  - veg_nf%hrv_livestemn_xfer_to_litter(p)  *dtime_mod
-         veg_ns%deadstemn_xfer(p)  = veg_ns%deadstemn_xfer(p)  - veg_nf%hrv_deadstemn_xfer_to_litter(p)  *dtime_mod
-         veg_ns%livecrootn_xfer(p) = veg_ns%livecrootn_xfer(p) - veg_nf%hrv_livecrootn_xfer_to_litter(p) *dtime_mod
-         veg_ns%deadcrootn_xfer(p) = veg_ns%deadcrootn_xfer(p) - veg_nf%hrv_deadcrootn_xfer_to_litter(p) *dtime_mod
+         veg_ns%leafn_xfer(p)      = veg_ns%leafn_xfer(p)      - veg_nf%hrv_leafn_xfer_to_litter(p)      *dt
+         veg_ns%frootn_xfer(p)     = veg_ns%frootn_xfer(p)     - veg_nf%hrv_frootn_xfer_to_litter(p)     *dt
+         veg_ns%livestemn_xfer(p)  = veg_ns%livestemn_xfer(p)  - veg_nf%hrv_livestemn_xfer_to_litter(p)  *dt
+         veg_ns%deadstemn_xfer(p)  = veg_ns%deadstemn_xfer(p)  - veg_nf%hrv_deadstemn_xfer_to_litter(p)  *dt
+         veg_ns%livecrootn_xfer(p) = veg_ns%livecrootn_xfer(p) - veg_nf%hrv_livecrootn_xfer_to_litter(p) *dt
+         veg_ns%deadcrootn_xfer(p) = veg_ns%deadcrootn_xfer(p) - veg_nf%hrv_deadcrootn_xfer_to_litter(p) *dt
 
       end do
 
diff --git a/components/elm/src/biogeochem/NitrogenStateUpdate3Mod.F90 b/components/elm/src/biogeochem/NitrogenStateUpdate3Mod.F90
index 533e42242d..8aac7bea21 100644
--- a/components/elm/src/biogeochem/NitrogenStateUpdate3Mod.F90
+++ b/components/elm/src/biogeochem/NitrogenStateUpdate3Mod.F90
@@ -37,6 +37,7 @@ contains
     ! NOTE - associate statements have been removed where there are
     ! no science equations. This increases readability and maintainability.
     !
+      !$acc routine seq
     use tracer_varcon, only : is_active_betr_bgc
     ! !ARGUMENTS:
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
@@ -51,8 +52,8 @@ contains
     integer :: fp,fc      ! lake filter indices
     !-----------------------------------------------------------------------
       if (.not. is_active_betr_bgc) then
-         !$acc parallel loop independent gang vector collapse(2) default(present) 
          do j = 1, nlevdecomp
+            ! column loop
             do fc = 1,num_soilc
                c = filter_soilc(fc)
                
@@ -83,10 +84,9 @@ contains
          end do
 
          ! litter and CWD losses to fire
-         !$acc parallel loop independent gang worker collapse(2) default(present) 
          do l = 1, ndecomp_pools
             do j = 1, nlevdecomp
-               !$acc loop independent vector private(c)
+               ! column loop
                do fc = 1,num_soilc
                   c = filter_soilc(fc)
                   col_ns%decomp_npools_vr(c,j,l) = col_ns%decomp_npools_vr(c,j,l) - col_nf%m_decomp_npools_to_fire_vr(c,j,l) * dt
@@ -98,23 +98,21 @@ contains
 
       ! SOM N losses due to erosion
       if ( ero_ccycle ) then
-         !$acc parallel loop independent gang worker collapse(2) default(present)
          do l = 1, ndecomp_pools
-            do j = 1, nlevdecomp
-               !$acc loop independent vector private(c)
-               do fc = 1, num_soilc
-                  c = filter_soilc(fc)
-                  if ( decomp_cascade_con%is_soil(l) ) then
+            if ( decomp_cascade_con%is_soil(l) ) then
+               do j = 1, nlevdecomp
+                  do fc = 1, num_soilc
+                     c = filter_soilc(fc)
                      col_ns%decomp_npools_vr(c,j,l) = col_ns%decomp_npools_vr(c,j,l) - col_nf%decomp_npools_yield_vr(c,j,l) * dt
-                  end if
+                  end do
                end do
-            end do
+            end if
          end do
       end if
 
       ! patch-level nitrogen fluxes
       if(.not.use_fates) then
-         !$acc parallel loop independent gang vector default(present)
+
          do fp = 1,num_soilp
             p = filter_soilp(fp)
 
diff --git a/components/elm/src/biogeochem/PhenologyFluxLimitMod.F90 b/components/elm/src/biogeochem/PhenologyFluxLimitMod.F90
index a5a86a6a94..76ae3a50ef 100644
--- a/components/elm/src/biogeochem/PhenologyFluxLimitMod.F90
+++ b/components/elm/src/biogeochem/PhenologyFluxLimitMod.F90
@@ -13,7 +13,6 @@ module PhenologyFLuxLimitMod
   use pftvarcon                   , only : npcropmin
   use elm_varctl                  , only : iulog
   use abortutils                  , only : endrun
-  use timeInfoMod
 implicit none
   private
 
@@ -173,6 +172,7 @@ contains
   end subroutine ascal
 !------------------------------------------------------------
   subroutine fpmax(a,b)
+  !
   ! DESCRIPTION
   ! b=max(a,0._r8)
   implicit none
@@ -521,6 +521,7 @@ contains
       veg_cf, veg_cs , c13_veg_cf, c13_veg_cs , c14_veg_cf, c14_veg_cs , &
       veg_nf, veg_ns, veg_pf, veg_ps)
 
+    !
     ! DESCRIPTION
     !  apply the phenology flux limiter to avoid potential negative fluxes.
     use decompMod           , only : bounds_type
@@ -587,6 +588,7 @@ contains
   subroutine carbon_flux_limiter(bounds, num_soilc, filter_soilc,&
       num_soilp, filter_soilp, crop_vars,  &
       veg_cf, veg_cs )
+    !
     ! DESCRIPTION
     ! the flux limiter for phenology carbon fluxes
     use decompMod           , only : bounds_type
@@ -615,7 +617,7 @@ contains
          harvdate              =>    crop_vars%harvdate_patch   & ! Input:  [integer  (:)     ]  harvest date
          )
   ! set time steps
-  dt = dtime_mod !real( get_step_size(), r8 )
+  dt = real( get_step_size(), r8 )
 
   do fp = 1,num_soilp
     p = filter_soilp(fp)
@@ -821,6 +823,7 @@ contains
       num_soilp, filter_soilp, cnstate_vars,  &
       veg_nf, veg_ns)
 
+    !
     ! DESCRIPTION
     ! the flux limiter for phenology nitrogen fluxes
     use decompMod           , only : bounds_type
@@ -849,7 +852,7 @@ contains
          ns                    => veg_ns               &
   )
   ! set time steps
-  dt = dtime_mod !real( get_step_size(), r8 )
+  dt = real( get_step_size(), r8 )
   do fp = 1,num_soilp
     p = filter_soilp(fp)
     ystates(:) = 0._r8
@@ -1034,7 +1037,7 @@ contains
   )
 
   ! set time steps
-  dt = dtime_mod !real( get_step_size(), r8 )
+  dt = real( get_step_size(), r8 )
   do fp = 1,num_soilp
     p = filter_soilp(fp)
     ystates(:) = 0._r8
diff --git a/components/elm/src/biogeochem/PhenologyMod.F90 b/components/elm/src/biogeochem/PhenologyMod.F90
index 7e141feaef..bf46863084 100644
--- a/components/elm/src/biogeochem/PhenologyMod.F90
+++ b/components/elm/src/biogeochem/PhenologyMod.F90
@@ -32,6 +32,12 @@ module PhenologyMod
   use VegetationType      , only : veg_pp
   use VegetationDataType  , only : veg_es, veg_ef, veg_cs, veg_cf, veg_ns, veg_nf
   use VegetationDataType  , only : veg_ps, veg_pf
+  use CNCarbonStateType   , only : carbonstate_type
+  use CNCarbonFluxType    , only : carbonflux_type
+  use CNNitrogenStateType , only : nitrogenstate_type
+  use CNNitrogenFluxType  , only : nitrogenflux_type
+  use PhosphorusStateType , only : phosphorusstate_type
+  use PhosphorusFluxType  , only : phosphorusflux_type
   !!!Added for gpu timing info
   use timeinfoMod
 
@@ -78,6 +84,12 @@ module PhenologyMod
   real(r8) :: soilpsi_off                   ! water potential for offset trigger (MPa)
   real(r8) :: lwtop                         ! live wood turnover proportion (annual fraction)
   !$acc declare create(fracday         )
+  !$acc declare create(crit_dayl       )
+  !$acc declare create(crit_dayl_stress)
+  !$acc declare create(cumprec_onset   )
+  !$acc declare create(ndays_on        )
+  !$acc declare create(ndays_off       )
+  !$acc declare create(fstor2tran      )
   !$acc declare create(crit_onset_fdd  )
   !$acc declare create(crit_onset_swi  )
   !$acc declare create(soilpsi_on      )
@@ -150,7 +162,7 @@ contains
      allocate(PhenolParamsInst%lwtop           )
     !
     ! read in parameters
-    !
+    !   
     tString='crit_dayl'
     call ncd_io(varname=trim(tString),data=tempr, flag='read', ncid=ncid, readvar=readv)
     if ( .not. readv ) call endrun( msg=trim(errCode)//trim(tString)//errMsg(__FILE__, __LINE__))
@@ -162,7 +174,7 @@ contains
     else
        tString='crit_dayl_stress'
        call ncd_io(varname=trim(tString),data=tempr, flag='read', ncid=ncid, readvar=readv)
-       if ( .not. readv ) then
+       if ( .not. readv ) then 
           PhenolParamsInst%crit_dayl_stress = secspqtrday
        else
           PhenolParamsInst%crit_dayl_stress = tempr
@@ -225,10 +237,10 @@ contains
     tString='lwtop_ann'
     call ncd_io(varname=trim(tString),data=tempr, flag='read', ncid=ncid, readvar=readv)
     if ( .not. readv ) call endrun( msg=trim(errCode)//trim(tString)//errMsg(__FILE__, __LINE__))
-    PhenolParamsInst%lwtop=tempr
+    PhenolParamsInst%lwtop=tempr   
 
      !!!!========== Update to device ========= !!!
-     !$acc enter data copyin(PhenolParamsInst%crit_dayl, &
+     !$acc update device(PhenolParamsInst%crit_dayl, &
      !$acc PhenolParamsInst%crit_dayl_stress, &
      !$acc PhenolParamsInst%cumprec_onset   , &
      !$acc PhenolParamsInst%ndays_on        , &
@@ -246,7 +258,7 @@ contains
 
   !-----------------------------------------------------------------------
   subroutine Phenology (num_soilc, filter_soilc, num_soilp, filter_soilp, &
-       num_pcropp, filter_pcropp, num_ppercropp, filter_ppercropp, doalb, &
+       num_pcropp, filter_pcropp, num_ppercropp, filter_ppercropp, doalb, atm2lnd_vars, &
        crop_vars, canopystate_vars, soilstate_vars, &
        cnstate_vars)
     !
@@ -255,6 +267,7 @@ contains
     ! 1. grass phenology
     !
     ! !ARGUMENTS:
+      !$acc routine seq
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
     integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
@@ -264,46 +277,34 @@ contains
     integer                  , intent(in)    :: num_ppercropp   ! number of prog perennial crop patches in filter
     integer                  , intent(in)    :: filter_ppercropp(:) ! filter for prognostic perennial crop patches
     logical                  , intent(in)    :: doalb           ! true if time for sfc albedo calc
+    type(atm2lnd_type)       , intent(in)    :: atm2lnd_vars
     type(crop_type)          , intent(inout) :: crop_vars
     type(canopystate_type)   , intent(in)    :: canopystate_vars
     type(soilstate_type)     , intent(in)    :: soilstate_vars
     type(cnstate_type)       , intent(inout) :: cnstate_vars
-    integer :: fcp, fp ,p
     !-----------------------------------------------------------------------
 
     ! each of the following phenology type routines includes a filter
     ! to operate only on the relevant patches
 
-    !NOTE: this loop is take from PhenologyClimate so that it has only num_pcropp loop
-    !$acc parallel loop independent gang vector default(present) private(p)
-    do fp = 1,num_soilp
-      p = filter_soilp(fp)
-      cnstate_vars%tempavg_t2m_patch(p) = cnstate_vars%tempavg_t2m_patch(p) &
-                     + veg_es%t_ref2m(p) * (dtime_mod/(dayspyr_mod*secspday))
-    end do 
-   
-   call CNEvergreenPhenology(num_soilp,filter_soilp, cnstate_vars)
-   call CNSeasonDecidPhenology(num_soilp,filter_soilp, cnstate_vars)
-   call CNStressDecidPhenology(num_soilp,filter_soilp,soilstate_vars, cnstate_vars)
-   call CNOnsetGrowth(num_soilp,filter_soilp, cnstate_vars)
-
-    !NOTE:  Only one loop is for num_soilp, other loop for num_pcropp
-    !$acc parallel loop independent gang vector default(present) 
-    do fcp=1, num_pcropp
-      p = filter_pcropp(fcp)
-      call PhenologyClimate(p, crop_vars)
-    end do
+    call PhenologyClimate(num_soilp, filter_soilp, num_pcropp, filter_pcropp, &
+         cnstate_vars, crop_vars)
+
+    call CNEvergreenPhenology(num_soilp, filter_soilp, &
+         cnstate_vars)
+
+    call CNSeasonDecidPhenology(num_soilp, filter_soilp, cnstate_vars)
+
+    call CNStressDecidPhenology(num_soilp, filter_soilp,   &
+         soilstate_vars, atm2lnd_vars, cnstate_vars &
+         )
 
    if (num_pcropp > 0 ) then
-      !NOTE:  num_pcropp loop
-      print *, "NUM_PCROPP > 0"
-      stop
-       call CropPlantDate( num_pcropp, filter_pcropp,&
+       call CropPlantDate(num_soilp, filter_soilp, num_pcropp, filter_pcropp,&
             cnstate_vars, crop_vars)
    end if
 
     if (doalb .and. num_pcropp > 0 ) then
-      !NOTE: all in a num_pcropp loop
        call CropPhenology(num_pcropp, filter_pcropp, &
             crop_vars, canopystate_vars, cnstate_vars &
             )
@@ -316,25 +317,30 @@ contains
 
     ! the same onset and offset routines are called regardless of
     ! phenology type - they depend only on onset_flag, offset_flag, bglfr, and bgtr
-  
+
+    call CNOnsetGrowth(num_soilp, filter_soilp, &
+         cnstate_vars)
+
    if (num_pcropp > 0 ) then
-      !NOTE: loop over num_pcropp but then calls routine that performs reductions
-      !      of the patch level variables into the column level variables
       call CNCropHarvest(num_pcropp, filter_pcropp, &
            num_soilc, filter_soilc, crop_vars, &
            cnstate_vars)
    end if
 
-    call CNOffsetLitterfall(num_soilp,filter_soilp, cnstate_vars)
-    call CNBackgroundLitterfall(num_soilp,filter_soilp, cnstate_vars)
-    call CNLivewoodTurnover(num_soilp,filter_soilp)
-
    if (num_ppercropp > 0 ) then
       call CNPerennialCropHarvest(num_ppercropp, filter_ppercropp, &
            num_soilc, filter_soilc, crop_vars, cnstate_vars)
    end if
 
-  ! gather all patch-level litterfall fluxes to the column for litter C and N inputs
+    call CNOffsetLitterfall(num_soilp, filter_soilp, &
+         cnstate_vars)
+
+    call CNBackgroundLitterfall(num_soilp, filter_soilp, &
+         cnstate_vars)
+
+    call CNLivewoodTurnover(num_soilp, filter_soilp)
+
+    ! gather all patch-level litterfall fluxes to the column for litter C and N inputs
 
   end subroutine Phenology
 
@@ -394,6 +400,14 @@ contains
 
     !$acc update device(&
     !$acc   fracday         &
+    !$acc  , crit_dayl       &
+    !$acc  , crit_dayl_stress&
+    !$acc  , cumprec_onset   &
+    !$acc  , ndays_on        &
+    !$acc  , ndays_off       &
+    !$acc  , fstor2tran      &
+    !$acc  , crit_onset_fdd  &
+    !$acc  , crit_onset_swi  &
     !$acc  , soilpsi_on      &
     !$acc  , crit_offset_fdd &
     !$acc  , crit_offset_swi &
@@ -402,12 +416,16 @@ contains
     !$acc  , p1d, p1v       &
     !$acc  , hti   &
     !$acc  , tbase &
+    !$acc  , inhemi       &
+    !$acc  , minplantjday &
+    !$acc  , maxplantjday &
     !$acc  , jdayyrstart )
 
   end subroutine PhenologyInit
 
   !-----------------------------------------------------------------------
-  subroutine PhenologyClimate (p,  crop_vars)
+  subroutine PhenologyClimate (num_soilp, filter_soilp, num_pcropp, filter_pcropp, &
+          cnstate_vars, crop_vars)
     !
     ! !DESCRIPTION:
     ! For coupled carbon-nitrogen code (CN).
@@ -416,35 +434,56 @@ contains
     use timeinfoMod
     !
     ! !ARGUMENTS:
-    !$acc routine seq
-    integer, value, intent(in) :: p
-    type(crop_type), intent(inout) :: crop_vars
+      !$acc routine seq
+    integer                , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    integer                , intent(in)    :: num_pcropp      ! number of prognostic crops in filter
+    integer                , intent(in)    :: filter_pcropp(:)! filter for prognostic crop patches
+    type(cnstate_type)     , intent(inout) :: cnstate_vars
+    type(crop_type)        , intent(inout) :: crop_vars
+
     !
     ! !LOCAL VARIABLES:
-    integer ::  kyr                     ! current year
-    integer ::  kmo                     !         month of year  (1, ..., 12)
-    integer ::  kda                     !         day of month   (1, ..., 31)
-    integer ::  mcsec                   !         seconds of day (0, ..., seconds/day)
+    integer :: p                    ! indices
+    integer :: fp                   ! lake filter pft index
+    real(r8):: dayspyr              ! days per year (days)
+    integer kyr                     ! current year
+    integer kmo                     !         month of year  (1, ..., 12)
+    integer kda                     !         day of month   (1, ..., 31)
+    integer mcsec                   !         seconds of day (0, ..., seconds/day)
     real(r8), parameter :: yravg   = 20.0_r8      ! length of years to average for gdd
     real(r8), parameter :: yravgm1 = yravg-1.0_r8 ! minus 1 of above
+    real(r8) :: dt
     !-----------------------------------------------------------------------
 
     associate(                                                  &
+        !NEW TO MASTER
          nyrs_crop_active => crop_vars%nyrs_crop_active_patch,   & ! InOut:  [integer (:)  ]  number of years this crop patch has been active
+         t_ref2m        => veg_es%t_ref2m     , & ! Input:  [real(r8) (:) ]  2m air temperature (K)
          gdd0           => veg_es%gdd0        , & ! Output: [real(r8) (:) ]  growing deg. days base 0 deg C (ddays)
          gdd8           => veg_es%gdd8        , & ! Output: [real(r8) (:) ]     "     "    "    "   8  "  "    "
          gdd10          => veg_es%gdd10       , & ! Output: [real(r8) (:) ]     "     "    "    "  10  "  "    "
          gdd020         => veg_es%gdd020      , & ! Output: [real(r8) (:) ]  20-yr mean of gdd0 (ddays)
          gdd820         => veg_es%gdd820      , & ! Output: [real(r8) (:) ]  20-yr mean of gdd8 (ddays)
-         gdd1020        => veg_es%gdd1020     & ! Output: [real(r8) (:) ]  20-yr mean of gdd10 (ddays)
+         gdd1020        => veg_es%gdd1020     , & ! Output: [real(r8) (:) ]  20-yr mean of gdd10 (ddays)
+
+         tempavg_t2m    => cnstate_vars%tempavg_t2m_patch       & ! Output: [real(r8) (:) ]  temp. avg 2m air temperature (K)
          )
 
       ! set time steps
+      dt = dtime_mod
+      dayspyr = dayspyr_mod
       !time info only used if num_pcropp > 1
       kyr = year_curr
       kda = day_curr
       kmo = mon_curr
       mcsec = secs_curr
+
+      do fp = 1,num_soilp
+         p = filter_soilp(fp)
+         tempavg_t2m(p) = tempavg_t2m(p) + t_ref2m(p) * (fracday/dayspyr)
+      end do
+
       !
       ! The following crop related steps are done here rather than CropPhenology
       ! so that they will be completed each time-step rather than with doalb.
@@ -452,42 +491,50 @@ contains
       ! The following lines come from ibis's climate.f + stats.f
       ! gdd SUMMATIONS ARE RELATIVE TO THE PLANTING DATE (see subr. updateAccFlds)
 
-      if (kmo == 1 .and. kda == 1 .and. nyrs_crop_active(p) == 0) then ! YR 1:
-         gdd020(p)  = 0._r8                             ! set gdd..20 variables to 0
-         gdd820(p)  = 0._r8                             ! and crops will not be planted
-         gdd1020(p) = 0._r8
-      end if
-      if (kmo == 1 .and. kda == 1 .and. mcsec == 0) then        ! <-- END of EVERY YR:
-         if (nyrs_crop_active(p)  == 1) then                    ! <-- END of YR 1
-            gdd020(p)  = gdd0(p)                                ! <-- END of YR 1
-            gdd820(p)  = gdd8(p)                                ! <-- END of YR 1
-            gdd1020(p) = gdd10(p)                               ! <-- END of YR 1
-         end if                                                 ! <-- END of YR 1
-         gdd020(p)  = (yravgm1* gdd020(p)  + gdd0(p))  / yravg  ! gdd..20 must be long term avgs
-         gdd820(p)  = (yravgm1* gdd820(p)  + gdd8(p))  / yravg  ! so ignore results for yrs 1 & 2
-         gdd1020(p) = (yravgm1* gdd1020(p) + gdd10(p)) / yravg
-      end if
+
+      do fp = 1,num_pcropp
+         p = filter_pcropp(fp)
+         if (kmo == 1 .and. kda == 1 .and. nyrs_crop_active(p) == 0) then ! YR 1:
+            gdd020(p)  = 0._r8                             ! set gdd..20 variables to 0
+            gdd820(p)  = 0._r8                             ! and crops will not be planted
+            gdd1020(p) = 0._r8
+         end if
+         if (kmo == 1 .and. kda == 1 .and. mcsec == 0) then        ! <-- END of EVERY YR:
+            if (nyrs_crop_active(p)  == 1) then                    ! <-- END of YR 1
+               gdd020(p)  = gdd0(p)                                ! <-- END of YR 1
+               gdd820(p)  = gdd8(p)                                ! <-- END of YR 1
+               gdd1020(p) = gdd10(p)                               ! <-- END of YR 1
+            end if                                                 ! <-- END of YR 1
+            gdd020(p)  = (yravgm1* gdd020(p)  + gdd0(p))  / yravg  ! gdd..20 must be long term avgs
+            gdd820(p)  = (yravgm1* gdd820(p)  + gdd8(p))  / yravg  ! so ignore results for yrs 1 & 2
+            gdd1020(p) = (yravgm1* gdd1020(p) + gdd10(p)) / yravg
+         end if
+      end do
 
     end associate
 
   end subroutine PhenologyClimate
 
   !-----------------------------------------------------------------------
-  subroutine CNEvergreenPhenology (num_soilp,filter_soilp, cnstate_vars)
+  subroutine CNEvergreenPhenology (num_soilp, filter_soilp , &
+       cnstate_vars)
     !
     ! !DESCRIPTION:
     ! For coupled carbon-nitrogen code (CN).
     !
     ! !USES:
+    !$acc routine seq
     use elm_varcon       , only : secspday
     !
     ! !ARGUMENTS:
-    integer, intent(in) :: num_soilp 
-    integer, intent(in) :: filter_soilp(:)
+    integer           , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer           , intent(in)    :: filter_soilp(:) ! filter for soil patches
     type(cnstate_type), intent(inout) :: cnstate_vars
     !
     ! !LOCAL VARIABLES:
-    integer :: fp, p 
+    real(r8):: dayspyr                ! Days per year
+    integer :: p                      ! indices
+    integer :: fp                     ! lake filter pft index
     !-----------------------------------------------------------------------
 
     associate(                                    &
@@ -501,24 +548,25 @@ contains
          bgtr        => cnstate_vars%bgtr_patch  , & ! Output: [real(r8) (:) ]  background transfer growth rate (1/s)
          lgsf        => cnstate_vars%lgsf_patch    & ! Output: [real(r8) (:) ]  long growing season factor [0-1]
          )
-    
-   !$acc parallel loop independent gang vector default(present) private(p)
-    do fp = 1,num_soilp
-      p = filter_soilp(fp)
-      if (evergreen(ivt(p)) == 1._r8) then
-         bglfr_leaf(p)  = 1._r8/(leaf_long(ivt(p)) * dayspyr_mod * secspday)
-         bglfr_froot(p) = 1._r8/(froot_long(ivt(p)) * dayspyr_mod * secspday)
-         bgtr(p)  = 0._r8
-         lgsf(p)  = 0._r8
-      end if
-    end do 
+
+      dayspyr = dayspyr_mod
+
+      do fp = 1,num_soilp
+         p = filter_soilp(fp)
+         if (evergreen(ivt(p)) == 1._r8) then
+            bglfr_leaf(p)  = 1._r8/(leaf_long(ivt(p)) * dayspyr * secspday)
+            bglfr_froot(p) = 1._r8/(froot_long(ivt(p)) * dayspyr * secspday)
+            bgtr(p)  = 0._r8
+            lgsf(p)  = 0._r8
+         end if
+      end do
 
     end associate
 
   end subroutine CNEvergreenPhenology
 
   !-----------------------------------------------------------------------
-  subroutine CNSeasonDecidPhenology (num_soilp,filter_soilp, cnstate_vars)
+  subroutine CNSeasonDecidPhenology (num_soilp, filter_soilp, cnstate_vars)
     !
     ! !DESCRIPTION:
     ! For coupled carbon-nitrogen code (CN).
@@ -526,20 +574,22 @@ contains
     ! deciduous vegetation that has only one growing season per year).
     !
     ! !USES:
+      !$acc routine seq
     use shr_const_mod   , only: SHR_CONST_TKFRZ, SHR_CONST_PI
     use elm_varcon      , only: secspday
     !
     ! !ARGUMENTS:
-    integer, intent(in) :: num_soilp 
-    integer, intent(in) :: filter_soilp(:)
-    type(cnstate_type), intent(inout) :: cnstate_vars
+    integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    type(cnstate_type)       , intent(inout) :: cnstate_vars
     !
     ! !LOCAL VARIABLES:
-    integer :: fp, p 
-    integer :: g,c            !indices
+    integer :: g,c,p          !indices
+    integer :: fp             !lake filter pft index
     real(r8):: ws_flag        !winter-summer solstice flag (0 or 1)
     real(r8):: crit_onset_gdd !critical onset growing degree-day sum
     real(r8):: soilt
+    real(r8):: dt
     !-----------------------------------------------------------------------
 
     associate(                                                                                             &
@@ -650,8 +700,8 @@ contains
          deadcrootp_storage_to_xfer          =>    veg_pf%deadcrootp_storage_to_xfer      & ! Output:  [real(r8) (:)   ]
 
          )
-         ! start pft loop
-      !$acc parallel loop independent gang vector default(present)
+         dt = dtime_mod
+      ! start pft loop
       do fp = 1,num_soilp
          p = filter_soilp(fp)
          c = veg_pp%column(p)
@@ -679,7 +729,7 @@ contains
             ! update offset_counter and test for the end of the offset period
             if (offset_flag(p) == 1.0_r8) then
                ! decrement counter for offset period
-               offset_counter(p) = offset_counter(p) - dtime_mod
+               offset_counter(p) = offset_counter(p) - dt
 
                ! if this is the end of the offset_period, reset phenology
                ! flags and indices
@@ -701,7 +751,7 @@ contains
             ! update onset_counter and test for the end of the onset period
             if (onset_flag(p) == 1.0_r8) then
                ! decrement counter for onset period
-               onset_counter(p) = onset_counter(p) - dtime_mod
+               onset_counter(p) = onset_counter(p) - dt
 
                ! if this is the end of the onset period, reset phenology
                ! flags and indices
@@ -800,34 +850,34 @@ contains
                   ! inlined during vectorization
 
                   ! set carbon fluxes for shifting storage pools to transfer pools
-                  leafc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafc_storage(p)/dtime_mod
-                  frootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootc_storage(p)/dtime_mod
+                  leafc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafc_storage(p)/dt
+                  frootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootc_storage(p)/dt
                   if (woody(ivt(p)) == 1.0_r8) then
-                     livestemc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemc_storage(p)/dtime_mod
-                     deadstemc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemc_storage(p)/dtime_mod
-                     livecrootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootc_storage(p)/dtime_mod
-                     deadcrootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootc_storage(p)/dtime_mod
-                     gresp_storage_to_xfer(p)      = PhenolParamsInst%fstor2tran * gresp_storage(p)/dtime_mod
+                     livestemc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemc_storage(p)/dt
+                     deadstemc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemc_storage(p)/dt
+                     livecrootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootc_storage(p)/dt
+                     deadcrootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootc_storage(p)/dt
+                     gresp_storage_to_xfer(p)      = PhenolParamsInst%fstor2tran * gresp_storage(p)/dt
                   end if
 
                   ! set nitrogen fluxes for shifting storage pools to transfer pools
-                  leafn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafn_storage(p)/dtime_mod
-                  frootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootn_storage(p)/dtime_mod
+                  leafn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafn_storage(p)/dt
+                  frootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootn_storage(p)/dt
                   if (woody(ivt(p)) == 1.0_r8) then
-                     livestemn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemn_storage(p)/dtime_mod
-                     deadstemn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemn_storage(p)/dtime_mod
-                     livecrootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootn_storage(p)/dtime_mod
-                     deadcrootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootn_storage(p)/dtime_mod
+                     livestemn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemn_storage(p)/dt
+                     deadstemn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemn_storage(p)/dt
+                     livecrootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootn_storage(p)/dt
+                     deadcrootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootn_storage(p)/dt
                   end if
 
                   ! set phosphorus fluxes for shifting storage pools to transfer pools
-                  leafp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafp_storage(p)/dtime_mod
-                  frootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootp_storage(p)/dtime_mod
+                  leafp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafp_storage(p)/dt
+                  frootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootp_storage(p)/dt
                   if (woody(ivt(p)) == 1.0_r8) then
-                     livestemp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemp_storage(p)/dtime_mod
-                     deadstemp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemp_storage(p)/dtime_mod
-                     livecrootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootp_storage(p)/dtime_mod
-                     deadcrootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootp_storage(p)/dtime_mod
+                     livestemp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemp_storage(p)/dt
+                     deadstemp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemp_storage(p)/dt
+                     livecrootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootp_storage(p)/dt
+                     deadcrootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootp_storage(p)/dt
                   end if
                end if
 
@@ -851,7 +901,8 @@ contains
   end subroutine CNSeasonDecidPhenology
 
   !-----------------------------------------------------------------------
-  subroutine CNStressDecidPhenology (num_soilp,filter_soilp, soilstate_vars, cnstate_vars)
+  subroutine CNStressDecidPhenology (num_soilp, filter_soilp , &
+       soilstate_vars, atm2lnd_vars, cnstate_vars)
     !
     ! !DESCRIPTION:
     ! This routine handles phenology for vegetation types, such as grasses and
@@ -865,17 +916,22 @@ contains
     ! per year.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon       , only : secspday
     use shr_const_mod    , only : SHR_CONST_TKFRZ, SHR_CONST_PI
     !
     ! !ARGUMENTS:
-    integer , intent(in) :: num_soilp
-    integer , intent(in) :: filter_soilp(:) 
-    type(soilstate_type), intent(in)    :: soilstate_vars
-    type(cnstate_type)  , intent(inout) :: cnstate_vars
+    integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    type(soilstate_type)     , intent(in)    :: soilstate_vars
+    type(atm2lnd_type)       , intent(in)    :: atm2lnd_vars
+    type(cnstate_type)       , intent(inout) :: cnstate_vars
     !
     ! !LOCAL VARIABLES:
-    integer :: g,t,c,fp,p      ! indices
+    integer :: g,t,c,p           ! indices
+    integer :: fp              ! lake filter pft index
+    real(r8):: dayspyr         ! days per year
+    real(r8) :: dt
     real(r8):: crit_onset_gdd  ! degree days for onset trigger
     real(r8):: soilt           ! temperature of top soil layer
     real(r8):: psi             ! water stress of top soil layer
@@ -999,12 +1055,15 @@ contains
          )
 
       ! set time steps
-    !$acc parallel loop independent gang vector default(present) private(p)
-    do fp = 1,num_soilp
-      p = filter_soilp(fp)
-      c = veg_pp%column(p)
-      t = veg_pp%topounit(p)
-      g = veg_pp%gridcell(p)
+      dt = dtime_mod
+      dayspyr = dayspyr_mod
+
+
+      do fp = 1,num_soilp
+         p = filter_soilp(fp)
+         c = veg_pp%column(p)
+         t = veg_pp%topounit(p)
+         g = veg_pp%gridcell(p)
 
          if (stress_decid(ivt(p)) == 1._r8) then
             soilt = t_soisno(c,3)
@@ -1017,7 +1076,7 @@ contains
             ! update offset_counter and test for the end of the offset period
             if (offset_flag(p) == 1._r8) then
                ! decrement counter for offset period
-               offset_counter(p) = offset_counter(p) - dtime_mod
+               offset_counter(p) = offset_counter(p) - dt
 
                ! if this is the end of the offset_period, reset phenology
                ! flags and indices
@@ -1038,7 +1097,7 @@ contains
             ! update onset_counter and test for the end of the onset period
             if (onset_flag(p) == 1.0_r8) then
                ! decrement counter for onset period
-               onset_counter(p) = onset_counter(p) - dtime_mod
+               onset_counter(p) = onset_counter(p) - dt
 
                ! if this is the end of the onset period, reset phenology
                ! flags and indices
@@ -1165,34 +1224,34 @@ contains
                   ! inlined during vectorization
 
                   ! set carbon fluxes for shifting storage pools to transfer pools
-                  leafc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafc_storage(p)/dtime_mod
-                  frootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootc_storage(p)/dtime_mod
+                  leafc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafc_storage(p)/dt
+                  frootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootc_storage(p)/dt
                   if (woody(ivt(p)) == 1.0_r8) then
-                     livestemc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemc_storage(p)/dtime_mod
-                     deadstemc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemc_storage(p)/dtime_mod
-                     livecrootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootc_storage(p)/dtime_mod
-                     deadcrootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootc_storage(p)/dtime_mod
-                     gresp_storage_to_xfer(p)      = PhenolParamsInst%fstor2tran * gresp_storage(p)/dtime_mod
+                     livestemc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemc_storage(p)/dt
+                     deadstemc_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemc_storage(p)/dt
+                     livecrootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootc_storage(p)/dt
+                     deadcrootc_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootc_storage(p)/dt
+                     gresp_storage_to_xfer(p)      = PhenolParamsInst%fstor2tran * gresp_storage(p)/dt
                   end if
 
                   ! set nitrogen fluxes for shifting storage pools to transfer pools
-                  leafn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafn_storage(p)/dtime_mod
-                  frootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootn_storage(p)/dtime_mod
+                  leafn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafn_storage(p)/dt
+                  frootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootn_storage(p)/dt
                   if (woody(ivt(p)) == 1.0_r8) then
-                     livestemn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemn_storage(p)/dtime_mod
-                     deadstemn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemn_storage(p)/dtime_mod
-                     livecrootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootn_storage(p)/dtime_mod
-                     deadcrootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootn_storage(p)/dtime_mod
+                     livestemn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemn_storage(p)/dt
+                     deadstemn_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemn_storage(p)/dt
+                     livecrootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootn_storage(p)/dt
+                     deadcrootn_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootn_storage(p)/dt
                   end if
 
                   ! set phosphorus fluxes for shifting storage pools to transfer pools
-                  leafp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafp_storage(p)/dtime_mod
-                  frootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootp_storage(p)/dtime_mod
+                  leafp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * leafp_storage(p)/dt
+                  frootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * frootp_storage(p)/dt
                   if (woody(ivt(p)) == 1.0_r8) then
-                     livestemp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemp_storage(p)/dtime_mod
-                     deadstemp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemp_storage(p)/dtime_mod
-                     livecrootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootp_storage(p)/dtime_mod
-                     deadcrootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootp_storage(p)/dtime_mod
+                     livestemp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * livestemp_storage(p)/dt
+                     deadstemp_storage_to_xfer(p)  = PhenolParamsInst%fstor2tran * deadstemp_storage(p)/dt
+                     livecrootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * livecrootp_storage(p)/dt
+                     deadcrootp_storage_to_xfer(p) = PhenolParamsInst%fstor2tran * deadcrootp_storage(p)/dt
                   end if
 
                end if
@@ -1261,7 +1320,7 @@ contains
             ! calculate long growing season factor (lgsf)
             ! only begin to calculate a lgsf greater than 0.0 once the number
             ! of days active exceeds days/year.
-            lgsf(p) = max(min((days_active(p)-dayspyr_mod)/dayspyr_mod, 1._r8),0._r8)
+            lgsf(p) = max(min((days_active(p)-dayspyr)/dayspyr, 1._r8),0._r8)
 
             ! set background litterfall rate, when not in the phenological offset period
             if (offset_flag(p) == 1._r8) then
@@ -1271,8 +1330,8 @@ contains
                ! calculate the background litterfall rate (bglfr)
                ! in units 1/s, based on leaf longevity (yrs) and correction for long growing season
 
-               bglfr_leaf(p)  = (1._r8/(leaf_long(ivt(p))*dayspyr_mod*secspday))*lgsf(p)
-               bglfr_froot(p) = (1._r8/(froot_long(ivt(p))*dayspyr_mod*secspday))*lgsf(p)
+               bglfr_leaf(p)  = (1._r8/(leaf_long(ivt(p))*dayspyr*secspday))*lgsf(p)
+               bglfr_froot(p) = (1._r8/(froot_long(ivt(p))*dayspyr*secspday))*lgsf(p)
 
             end if
 
@@ -1284,7 +1343,7 @@ contains
                ! in complete turnover of the storage pools in one year at steady state,
                ! once lgsf has reached 1.0 (after 730 days active).
 
-               bgtr(p) = (1._r8/(dayspyr_mod*secspday))*lgsf(p)
+               bgtr(p) = (1._r8/(dayspyr*secspday))*lgsf(p)
 
                ! set carbon fluxes for shifting storage pools to transfer pools
 
@@ -1322,7 +1381,8 @@ contains
 
          end if ! end if stress deciduous
 
-      enddo 
+      end do ! end of pft loop
+
     end associate
 
   end subroutine CNStressDecidPhenology
@@ -1336,6 +1396,7 @@ contains
     ! handle CN fluxes during the phenological onset                       & offset periods.
 
     ! !USES:
+      !$acc routine seq
     use pftvarcon        , only : ncorn, nscereal, nwcereal, nsoybean, gddmin, hybgdd
     use pftvarcon        , only : nwcerealirrig, nsoybeanirrig, ncornirrig, nscerealirrig
     use pftvarcon        , only : lfemerg, grnfill, mxmat, minplanttemp, planttemp
@@ -1350,23 +1411,23 @@ contains
     type(cnstate_type)       , intent(inout) :: cnstate_vars
     !
     ! LOCAL VARAIBLES:
-    integer :: kyr       ! current year
-    integer :: kmo       !         month of year  (1, ..., 12)
-    integer :: kda       !         day of month   (1, ..., 31)
-    integer :: mcsec     !         seconds of day (0, ..., seconds/day)
-    integer :: jday      ! julian day of the year
-    integer :: fp,p      ! patch indices
-    integer :: c         ! column indices
-    integer :: g         ! gridcell indices
-    integer :: h         ! hemisphere indices
-    integer :: t         ! topographic indices
-    integer :: idpp      ! number of days past planting
-    real(r8) :: dayspyr  ! days per year
-    real(r8) :: crmcorn  ! comparitive relative maturity for corn
-    real(r8) :: ndays_on ! number of days to fertilize
-    logical :: p_season  ! precipitation seasonal
-    logical :: t_season  ! temperature seasonal
-    logical :: no_season ! neither temperature or precipitation seasonal
+    integer kyr       ! current year
+    integer kmo       !         month of year  (1, ..., 12)
+    integer kda       !         day of month   (1, ..., 31)
+    integer mcsec     !         seconds of day (0, ..., seconds/day)
+    integer jday      ! julian day of the year
+    integer fp,p      ! patch indices
+    integer c         ! column indices
+    integer g         ! gridcell indices
+    integer h         ! hemisphere indices
+    integer t         ! topographic indices
+    integer idpp      ! number of days past planting
+    real(r8) dayspyr  ! days per year
+    real(r8) crmcorn  ! comparitive relative maturity for corn
+    real(r8) ndays_on ! number of days to fertilize
+    logical p_season  ! precipitation seasonal
+    logical t_season  ! temperature seasonal
+    logical no_season ! neither temperature or precipitation seasonal
     real(r8), parameter :: minrain = 0.1_r8    ! minimum rainfall for planting
     real(r8), parameter :: minwet = 0.2_r8     ! minimum fraction of saturation for planting
     real(r8), parameter :: maxwet = 0.8_r8     ! maximum fraction of saturation for planting
@@ -1438,6 +1499,7 @@ contains
          )
 
       ! get time info
+      !NEED TO FIX!
       dt = dtime_mod
       dayspyr = dayspyr_mod
       kyr = year_curr
@@ -1888,14 +1950,14 @@ contains
     type(cnstate_type)   , intent(inout) :: cnstate_vars
     !
     ! LOCAL VARAIBLES:
-    integer :: jday      ! julian day of the year
-    integer :: fp,p      ! patch indices
-    integer :: c         ! column indices
-    integer :: g         ! gridcell indices
-    integer :: h         ! hemisphere indices
-    integer :: t         ! topographic indices
-    real(r8) :: dayspyr  ! days per year
-    real(r8) :: ndays_on ! number of days to fertilize
+    integer jday      ! julian day of the year
+    integer fp,p      ! patch indices
+    integer c         ! column indices
+    integer g         ! gridcell indices
+    integer h         ! hemisphere indices
+    integer t         ! topographic indices
+    real(r8) dayspyr  ! days per year
+    real(r8) ndays_on ! number of days to fertilize
     real(r8):: soilt
     real(r8):: dt
     !------------------------------------------------------------------------
@@ -2095,7 +2157,7 @@ contains
     type(bounds_type), intent(in) :: bounds
     !
     ! LOCAL VARAIBLES:
-    integer  :: p,g,n,i                     ! indices
+    integer           :: p,g,n,i                     ! indices
 
     !------------------------------------------------------------------------
 
@@ -2152,10 +2214,6 @@ contains
 
     hti   = 1._r8
     tbase = 0._r8
-    !$acc update device(& 
-    !$acc    inhemi       &
-    !$acc  , minplantjday &
-    !$acc  , maxplantjday )
 
   end subroutine CropPhenologyInit
 
@@ -2182,10 +2240,10 @@ contains
     type(crop_type)        , intent(inout) :: crop_vars
     !
     ! LOCAL VARAIBLES:
-    real(r8) :: tcrown                     ! ?
-    real(r8) :: vd, vd1, vd2               ! vernalization dependence
-    real(r8) :: tkil                       ! Freeze kill threshold
-    integer  :: c,g                        ! indices
+    real(r8) tcrown                     ! ?
+    real(r8) vd, vd1, vd2               ! vernalization dependence
+    real(r8) tkil                       ! Freeze kill threshold
+    integer  c,g                        ! indices
     !------------------------------------------------------------------------
 
     associate(                                               &
@@ -2284,7 +2342,6 @@ contains
       ! will have to develop some type of relationship that reduces LAI and
       ! biomass pools in response to cold damaged crop
 
-#ifndef _OPENACC 
       if (t_ref2m_min(p) <= tfrz - 6._r8) then
          tkil = (tbase - 6._r8) - 6._r8 * hdidx(p)
          if (tkil >= tcrown) then
@@ -2297,14 +2354,13 @@ contains
             end if
          end if
       end if
-#endif 
 
     end associate
 
   end subroutine vernalization
 
   !-----------------------------------------------------------------------
-  subroutine CropPlantDate (num_pcropp, filter_pcropp, &
+  subroutine CropPlantDate (num_soilp, filter_soilp, num_pcropp, filter_pcropp, &
         cnstate_vars, crop_vars)
     !
     ! !DESCRIPTION:
@@ -2320,6 +2376,8 @@ contains
 
     !
     ! !ARGUMENTS:
+    integer                , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                , intent(in)    :: filter_soilp(:) ! filter for soil patches
     integer                , intent(in)    :: num_pcropp      ! number of prognostic crops in filter
     integer                , intent(in)    :: filter_pcropp(:)! filter for prognostic crop patches
     type(cnstate_type)     , intent(inout) :: cnstate_vars
@@ -2329,10 +2387,10 @@ contains
     ! !LOCAL VARIABLES:
     integer :: p,c,m,t,n,h          ! indices
     integer :: fp                   ! lake filter pft index
-    integer :: kyr                     ! current year
-    integer :: kmo                     ! month of year  (1, ..., 12)
-    integer :: kda                     ! day of month   (1, ..., 31)
-    integer :: mcsec                   ! seconds of day (0, ..., seconds/day)
+    integer kyr                     ! current year
+    integer kmo                     ! month of year  (1, ..., 12)
+    integer kda                     ! day of month   (1, ..., 31)
+    integer mcsec                   ! seconds of day (0, ..., seconds/day)
     integer , parameter :: nmon = 12        ! number months in year
     real(r8), parameter :: alpha = 0.05_r8  ! coefficient representing degree of weighting decrease
     real(r8), parameter :: mon = 12._r8     ! used for some calculations (number of days in month)
@@ -2384,12 +2442,16 @@ contains
 
       dt = dtime_mod
 
+
       fracday = dt/secspday
-      ! get time-related info
-      kyr = year_curr
-      kmo = mon_curr
-      kda = day_curr
-      mcsec = secs_curr
+
+      if (num_pcropp > 0) then
+         ! get time-related info
+         kyr = year_curr
+         kmo = mon_curr
+         kda = day_curr
+         mcsec = secs_curr
+      end if
 
       do fp = 1,num_pcropp
          p = filter_pcropp(fp)
@@ -2490,7 +2552,8 @@ contains
   end subroutine CropPlantDate
 
   !-----------------------------------------------------------------------
-  subroutine CNOnsetGrowth (num_soilp,filter_soilp, cnstate_vars)
+  subroutine CNOnsetGrowth (num_soilp, filter_soilp, &
+       cnstate_vars)
     !
     ! !DESCRIPTION:
     ! Determines the flux of stored C and N from transfer pools to display
@@ -2500,14 +2563,17 @@ contains
     use pftvarcon            , only : percrop
     !
     ! !ARGUMENTS:
-    integer , intent(in) :: num_soilp 
-    integer , intent(in) :: filter_soilp(:)
-    type(cnstate_type), intent(in)    :: cnstate_vars
+      !$acc routine seq
+    integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    type(cnstate_type)       , intent(in)    :: cnstate_vars
 
     !
     ! !LOCAL VARIABLES:
+    integer :: p            ! indices
+    integer :: fp           ! lake filter pft index
     real(r8):: t1           ! temporary variable
-    integer :: fp, p
+    real(r8) :: dt
     !-----------------------------------------------------------------------
 
     associate(                                                                                             &
@@ -2565,17 +2631,18 @@ contains
          )
 
       ! patch loop
-      !$acc parallel loop independent gang vector default(present)
+      dt = dtime_mod
       do fp = 1,num_soilp
          p = filter_soilp(fp)
+
          ! only calculate these fluxes during onset period
          if (onset_flag(p) == 1._r8) then
 
             ! The transfer rate is a linearly decreasing function of time,
             ! going to zero on the last timestep of the onset period
 
-            if (onset_counter(p) == dtime_mod .or. percrop(ivt(p)) == 1.0_r8) then
-               t1 = 1.0_r8 / dtime_mod
+            if (onset_counter(p) == dt .or. percrop(ivt(p)) == 1.0_r8) then
+               t1 = 1.0_r8 / dt
             else
                t1 = 2.0_r8 / (onset_counter(p))
             end if
@@ -2608,28 +2675,29 @@ contains
          ! pools should be moved to displayed growth in each timestep.
 
          if (bgtr(p) > 0._r8) then
-            leafc_xfer_to_leafc(p)   = leafc_xfer(p) / dtime_mod
-            frootc_xfer_to_frootc(p) = frootc_xfer(p) / dtime_mod
-            leafn_xfer_to_leafn(p)   = leafn_xfer(p) / dtime_mod
-            frootn_xfer_to_frootn(p) = frootn_xfer(p) / dtime_mod
-            leafp_xfer_to_leafp(p)   = leafp_xfer(p) / dtime_mod
-            frootp_xfer_to_frootp(p) = frootp_xfer(p) / dtime_mod
+            leafc_xfer_to_leafc(p)   = leafc_xfer(p) / dt
+            frootc_xfer_to_frootc(p) = frootc_xfer(p) / dt
+            leafn_xfer_to_leafn(p)   = leafn_xfer(p) / dt
+            frootn_xfer_to_frootn(p) = frootn_xfer(p) / dt
+            leafp_xfer_to_leafp(p)   = leafp_xfer(p) / dt
+            frootp_xfer_to_frootp(p) = frootp_xfer(p) / dt
             if (woody(ivt(p)) == 1.0_r8) then
-               livestemc_xfer_to_livestemc(p)   = livestemc_xfer(p) / dtime_mod
-               deadstemc_xfer_to_deadstemc(p)   = deadstemc_xfer(p) / dtime_mod
-               livecrootc_xfer_to_livecrootc(p) = livecrootc_xfer(p) / dtime_mod
-               deadcrootc_xfer_to_deadcrootc(p) = deadcrootc_xfer(p) / dtime_mod
-               livestemn_xfer_to_livestemn(p)   = livestemn_xfer(p) / dtime_mod
-               deadstemn_xfer_to_deadstemn(p)   = deadstemn_xfer(p) / dtime_mod
-               livecrootn_xfer_to_livecrootn(p) = livecrootn_xfer(p) / dtime_mod
-               deadcrootn_xfer_to_deadcrootn(p) = deadcrootn_xfer(p) / dtime_mod
-               livestemp_xfer_to_livestemp(p)   = livestemp_xfer(p) / dtime_mod
-               deadstemp_xfer_to_deadstemp(p)   = deadstemp_xfer(p) / dtime_mod
-               livecrootp_xfer_to_livecrootp(p) = livecrootp_xfer(p) / dtime_mod
-               deadcrootp_xfer_to_deadcrootp(p) = deadcrootp_xfer(p) / dtime_mod
+               livestemc_xfer_to_livestemc(p)   = livestemc_xfer(p) / dt
+               deadstemc_xfer_to_deadstemc(p)   = deadstemc_xfer(p) / dt
+               livecrootc_xfer_to_livecrootc(p) = livecrootc_xfer(p) / dt
+               deadcrootc_xfer_to_deadcrootc(p) = deadcrootc_xfer(p) / dt
+               livestemn_xfer_to_livestemn(p)   = livestemn_xfer(p) / dt
+               deadstemn_xfer_to_deadstemn(p)   = deadstemn_xfer(p) / dt
+               livecrootn_xfer_to_livecrootn(p) = livecrootn_xfer(p) / dt
+               deadcrootn_xfer_to_deadcrootn(p) = deadcrootn_xfer(p) / dt
+               livestemp_xfer_to_livestemp(p)   = livestemp_xfer(p) / dt
+               deadstemp_xfer_to_deadstemp(p)   = deadstemp_xfer(p) / dt
+               livecrootp_xfer_to_livecrootp(p) = livecrootp_xfer(p) / dt
+               deadcrootp_xfer_to_deadcrootp(p) = deadcrootp_xfer(p) / dt
             end if
          end if ! end if bgtr
-      end do 
+
+      end do ! end pft loop
 
     end associate
 
@@ -2646,6 +2714,7 @@ contains
    ! determined based on the LPJ model.
    !
    ! !ARGUMENTS:
+      !$acc routine seq
    integer, intent(in) :: num_pcropp       ! number of prog crop pfts in filter
    integer, intent(in) :: filter_pcropp(:) ! filter for prognostic crop pfts
    integer, intent(in) :: num_soilc        ! number of soil columns in filter
@@ -2839,28 +2908,32 @@ contains
 
    call CNCropHarvestPftToColumn(num_soilc, filter_soilc, cnstate_vars)
 
-   end associate
+    end associate
  end subroutine CNPerennialCropHarvest
 
   !-----------------------------------------------------------------------
-  subroutine CNOffsetLitterfall (num_soilp,filter_soilp, cnstate_vars)
+  subroutine CNOffsetLitterfall (num_soilp, filter_soilp, &
+       cnstate_vars)
     !
     ! !DESCRIPTION:
     ! Determines the flux of C and N from displayed pools to litter
     ! pools during the phenological offset period.
     !
     ! !USES:
+      !$acc routine seq
     use pftvarcon , only : npcropmin
     !
     ! !ARGUMENTS:
-    integer , intent(in) :: num_soilp 
-    integer , intent(in) :: filter_soilp(:)
-    type(cnstate_type) , intent(inout) :: cnstate_vars
+    integer                 , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                 , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    type(cnstate_type)      , intent(inout) :: cnstate_vars
 
     !
     ! !LOCAL VARIABLES:
-    integer :: c, fp,p   ! indices
-    real(r8):: t1        ! temporary variable
+    integer :: p, c         ! indices
+    integer :: fp           ! lake filter pft index
+    real(r8):: t1           ! temporary variable
+    real(r8):: dt
     !-----------------------------------------------------------------------
 
     associate(                                                                     &
@@ -2936,14 +3009,15 @@ contains
 
       ! The litterfall transfer rate starts at 0.0 and increases linearly
       ! over time, with displayed growth going to 0.0 on the last day of litterfall
-      !$acc parallel loop independent gang vector default(present)
-      do fp = 1, num_soilp
-          p = filter_soilp(fp)   
+      dt = dtime_mod
+      do fp = 1,num_soilp
+         p = filter_soilp(fp)
+
          ! only calculate fluxes during offset period
          if (offset_flag(p) == 1._r8) then
 
-            if (offset_counter(p) == dtime_mod) then
-               t1 = 1.0_r8 / dtime_mod
+            if (offset_counter(p) == dt) then
+               t1 = 1.0_r8 / dt
                if (ivt(p) >= npcropmin) then
                ! this assumes that offset_counter == dt for crops
                ! if this were ever changed, we'd need to add code to the "else"
@@ -2955,15 +3029,15 @@ contains
                   frootc_to_litter(p) = t1 * frootc(p) + cpool_to_frootc(p)
                end if
             else
-               t1 = dtime_mod * 2.0_r8 / (offset_counter(p) * offset_counter(p))
+               t1 = dt * 2.0_r8 / (offset_counter(p) * offset_counter(p))
                leafc_to_litter(p)  = prev_leafc_to_litter(p)  + t1*(leafc(p)  - prev_leafc_to_litter(p)*offset_counter(p))
                frootc_to_litter(p) = prev_frootc_to_litter(p) + t1*(frootc(p) - prev_frootc_to_litter(p)*offset_counter(p))
             end if
 
             if ( nu_com .eq. 'RD') then
                if (ivt(p) >= npcropmin) then
-                  if (offset_counter(p) == dtime_mod) then
-                      t1 = 1.0_r8 / dtime_mod
+                  if (offset_counter(p) == dt) then
+                      t1 = 1.0_r8 / dt
 
                      ! this assumes that offset_counter == dt for crops
                      ! if this were ever changed, we'd need to add code to the
@@ -2993,8 +3067,8 @@ contains
                   frootp_to_litter(p) = frootc_to_litter(p) / frootcp(ivt(p))
                end if
             else
-               if (offset_counter(p) == dtime_mod) then
-                  t1 = 1.0_r8 / dtime_mod
+               if (offset_counter(p) == dt) then
+                  t1 = 1.0_r8 / dt
                   if (ivt(p) >= npcropmin) then
                      ! this assumes that offset_counter == dt for crops
                      ! if this were ever changed, we'd need to add code to the "else"
@@ -3032,26 +3106,32 @@ contains
             prev_frootc_to_litter(p) = frootc_to_litter(p)
 
          end if ! end if offset period
-      end do 
+
+      end do ! end pft loop
+
     end associate
 
   end subroutine CNOffsetLitterfall
 
   !-----------------------------------------------------------------------
-  subroutine CNBackgroundLitterfall (num_soilp, filter_soilp, cnstate_vars)
+  subroutine CNBackgroundLitterfall (num_soilp, filter_soilp, &
+       cnstate_vars)
     !
     ! !DESCRIPTION:
     ! Determines the flux of C and N from displayed pools to litter
     ! pools as the result of background litter fall.
     !
     ! !ARGUMENTS:
-    integer , intent(in) :: num_soilp
-    integer , intent(in) :: filter_soilp(:) 
+      !$acc routine seq
+    integer                 , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                 , intent(in)    :: filter_soilp(:) ! filter for soil patches
     type(cnstate_type)      , intent(in)    :: cnstate_vars
-    !Local Variables 
-    integer :: fp, p 
+
+    ! !LOCAL VARIABLES:
+    integer :: p            ! indices
+    integer :: fp           ! lake filter pft index
     !-----------------------------------------------------------------------
-    
+
     associate(                                                               &
          ivt               =>    veg_pp%itype                                 , & ! Input:  [integer  (:) ]  pft vegetation type
 
@@ -3085,10 +3165,12 @@ contains
          leafp             =>    veg_ps%leafp            , &
          frootp            =>    veg_ps%frootp             &
          )
+
+
       ! patch loop
-      !$acc parallel loop independent gang vector default(present)
-      do fp = 1, num_soilp
+      do fp = 1,num_soilp
          p = filter_soilp(fp)
+
          ! only calculate these fluxes if the background litterfall rate is non-zero
          if (bglfr_leaf(p) > 0._r8) then
             ! units for bglfr are already 1/s
@@ -3125,14 +3207,14 @@ contains
                frootp_to_litter(p) = bglfr_froot(p) * frootp(p) ! fine root P retranslocation occur (but not N retranslocation), why not include it here
             end if
          end if
-      end do 
+      end do
 
     end associate
 
   end subroutine CNBackgroundLitterfall
 
   !-----------------------------------------------------------------------
-  subroutine CNLivewoodTurnover (num_soilp,filter_soilp)
+  subroutine CNLivewoodTurnover (num_soilp, filter_soilp)
     !
     ! !DESCRIPTION:
     ! Determines the flux of C and N from live wood to
@@ -3140,14 +3222,16 @@ contains
     ! add phosphorus flux - X.YANG
     !
     ! !ARGUMENTS:
-    integer , intent(in) :: num_soilp
-    integer , intent(in) :: filter_soilp(:) 
+      !$acc routine seq
+    integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
     !
     ! !LOCAL VARIABLES:
+    integer :: p            ! indices
+    integer :: fp           ! lake filter pft index
     real(r8):: ctovr        ! temporary variable for carbon turnover
     real(r8):: ntovr        ! temporary variable for nitrogen turnover
     real(r8):: ptovr        ! temporary variable for phosphorus turnover
-    integer :: fp, p 
     !-----------------------------------------------------------------------
 
     associate(                                                                             &
@@ -3183,10 +3267,10 @@ contains
          )
 
       ! patch loop
-      !$acc parallel loop independent gang vector default(present)
-      do fp = 1, num_soilp
-          p = filter_soilp(fp)
-         !  only calculate these fluxes for woody types
+      do fp = 1,num_soilp
+         p = filter_soilp(fp)
+
+         ! only calculate these fluxes for woody types
          if (woody(ivt(p)) > 0._r8) then
             if ( nu_com .eq. 'RD') then
                ! live stem to dead stem turnover
@@ -3241,195 +3325,167 @@ contains
             end if
 
          end if
-      end do 
+
+      end do
+
     end associate
 
   end subroutine CNLivewoodTurnover
 
   !-----------------------------------------------------------------------
-  subroutine CNLitterToColumn (num_soilc, filter_soilc, cnstate_vars)
-   !
-   ! !DESCRIPTION:
-   ! called at the end of cn_phenology to gather all pft-level litterfall fluxes
-   ! to the column level and assign them to the three litter pools
-   !
-   ! !USES:
-   use elm_varpar , only : max_patch_per_col, nlevdecomp
-   use pftvarcon  , only : npcropmin
-   !
-   ! !ARGUMENTS:
-   integer                 , intent(in)    :: num_soilc       ! number of soil columns in filter
-   integer                 , intent(in)    :: filter_soilc(:) ! filter for soil columns
-   type(cnstate_type)      , intent(in)    :: cnstate_vars
-   !
-   ! !LOCAL VARIABLES:
-   integer :: fc,c,p,j, ivt       ! indices
-   real(r8):: wt_col, sum1, sum2, sum3 
-   !-----------------------------------------------------------------------
+  subroutine CNLitterToColumn (num_soilp, filter_soilp, &
+       cnstate_vars)
+    !
+    ! !DESCRIPTION:
+    ! called at the end of cn_phenology to gather all pft-level litterfall fluxes
+    ! to the column level and assign them to the three litter pools
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varpar , only : max_patch_per_col, nlevdecomp
+    use pftvarcon  , only : npcropmin
+    !
+    ! !ARGUMENTS:
+    integer                 , intent(in)    :: num_soilp       ! number of soil columns in filter
+    integer                 , intent(in)    :: filter_soilp(:) ! filter for soil columns
+    type(cnstate_type)      , intent(in)    :: cnstate_vars
 
-   associate(                                                           &
-        wtcol                               =>    veg_pp%wtcol         , & ! Input:  [real(r8) (:)   ]  weight (relative to column) for this pft (0-1)
-        lf_flab                             =>    veg_vp%lf_flab       , & ! Input:  [real(r8) (:)   ]  leaf litter labile fraction
-        lf_fcel                             =>    veg_vp%lf_fcel       , & ! Input:  [real(r8) (:)   ]  leaf litter cellulose fraction
-        lf_flig                             =>    veg_vp%lf_flig       , & ! Input:  [real(r8) (:)   ]  leaf litter lignin fraction
-        fr_flab                             =>    veg_vp%fr_flab       , & ! Input:  [real(r8) (:)   ]  fine root litter labile fraction
-        fr_fcel                             =>    veg_vp%fr_fcel       , & ! Input:  [real(r8) (:)   ]  fine root litter cellulose fraction
-        fr_flig                             =>    veg_vp%fr_flig       , & ! Input:  [real(r8) (:)   ]  fine root litter lignin fraction
-
-        leaf_prof                           =>    cnstate_vars%leaf_prof_patch  , & ! Input:  [real(r8) (:,:) ]  (1/m) profile of leaves
-        froot_prof                          =>    cnstate_vars%froot_prof_patch , & ! Input:  [real(r8) (:,:) ]  (1/m) profile of fine roots
-
-        leafc_to_litter                     =>    veg_cf%leafc_to_litter           , & ! Input:  [real(r8) (:)   ]  leaf C litterfall (gC/m2/s)
-        frootc_to_litter                    =>    veg_cf%frootc_to_litter          , & ! Input:  [real(r8) (:)   ]  fine root N litterfall (gN/m2/s)
-        livestemc_to_litter                 =>    veg_cf%livestemc_to_litter       , & ! Input:  [real(r8) (:)   ]  live stem C litterfall (gC/m2/s)
-        phenology_c_to_litr_met_c           =>    col_cf%phenology_c_to_litr_met_c   , & ! Output: [real(r8) (:,:) ]  C fluxes associated with phenology (litterfall and crop) to litter metabolic pool (gC/m3/s)
-        phenology_c_to_litr_cel_c           =>    col_cf%phenology_c_to_litr_cel_c   , & ! Output: [real(r8) (:,:) ]  C fluxes associated with phenology (litterfall and crop) to litter cellulose pool (gC/m3/s)
-        phenology_c_to_litr_lig_c           =>    col_cf%phenology_c_to_litr_lig_c   , & ! Output: [real(r8) (:,:) ]  C fluxes associated with phenology (litterfall and crop) to litter lignin pool (gC/m3/s)
-
-        livestemn_to_litter                 =>    veg_nf%livestemn_to_litter     , & ! Input:  [real(r8) (:)   ]  livestem N to litter (gN/m2/s)
-        leafn_to_litter                     =>    veg_nf%leafn_to_litter         , & ! Input:  [real(r8) (:)   ]  leaf N litterfall (gN/m2/s)
-        frootn_to_litter                    =>    veg_nf%frootn_to_litter        , & ! Input:  [real(r8) (:)   ]  fine root N litterfall (gN/m2/s)
-        phenology_n_to_litr_met_n           =>    col_nf%phenology_n_to_litr_met_n , & ! Output: [real(r8) (:,:) ]  N fluxes associated with phenology (litterfall and crop) to litter metabolic pool (gN/m3/s)
-        phenology_n_to_litr_cel_n           =>    col_nf%phenology_n_to_litr_cel_n , & ! Output: [real(r8) (:,:) ]  N fluxes associated with phenology (litterfall and crop) to litter cellulose pool (gN/m3/s)
-        phenology_n_to_litr_lig_n           =>    col_nf%phenology_n_to_litr_lig_n , & ! Output: [real(r8) (:,:) ]  N fluxes associated with phenology (litterfall and crop) to litter lignin pool (gN/m3/s)
-
-        livestemp_to_litter                 =>    veg_pf%livestemp_to_litter     , & ! Input:  [real(r8) (:)   ]  livestem P to litter (gP/m2/s)
-        leafp_to_litter                     =>    veg_pf%leafp_to_litter         , & ! Input:  [real(r8) (:)   ]  leaf P litterfall (gP/m2/s)
-        frootp_to_litter                    =>    veg_pf%frootp_to_litter        , & ! Input:  [real(r8) (:)   ]  fine root P litterfall (gP/m2/s)
-        phenology_p_to_litr_met_p           =>    col_pf%phenology_p_to_litr_met_p , & ! Output: [real(r8) (:,:) ]  P fluxes associated with phenology (litterfall and crop) to litter metabolic pool (gP/m3/s)
-        phenology_p_to_litr_cel_p           =>    col_pf%phenology_p_to_litr_cel_p , & ! Output: [real(r8) (:,:) ]  P fluxes associated with phenology (litterfall and crop) to litter cellulose pool (gP/m3/s)
-        phenology_p_to_litr_lig_p           =>    col_pf%phenology_p_to_litr_lig_p   & ! Output: [real(r8) (:,:) ]  P fluxes associated with phenology (litterfall and crop) to litter lignin pool (gP/m3/s)
-        )
-        
-     !$acc enter data create(sum1,sum2,sum3, wt_col)  
-     !$acc parallel loop independent gang worker collapse(2) private(c,sum1,sum2,sum3) default(present) 
-     do j = 1, nlevdecomp
-        do fc = 1,num_soilc
-           c = filter_soilc(fc)
-           sum1 = 0.0_r8 
-           sum2 = 0.0_r8 
-           sum3 = 0.0_r8
-           !$acc loop vector reduction(+:sum1,sum2,sum3) private(wt_col,ivt)
-           do p = col_pp%pfti(c), col_pp%pftf(c)
-             if(veg_pp%active(p)) then 
-                wt_col = wtcol(p)
-               ivt = veg_pp%itype(p)
+    ! !LOCAL VARIABLES:
+    integer :: fp,c,p,j       ! indices
+    real(r8):: wt_col
+    !-----------------------------------------------------------------------
 
+    associate(                                                                                       &
+         ivt                                 =>    veg_pp%itype                                       , & ! Input:  [integer  (:)   ]  pft vegetation type
+         wtcol                               =>    veg_pp%wtcol                                       , & ! Input:  [real(r8) (:)   ]  weight (relative to column) for this pft (0-1)
+
+         lf_flab                             =>    veg_vp%lf_flab                              , & ! Input:  [real(r8) (:)   ]  leaf litter labile fraction
+         lf_fcel                             =>    veg_vp%lf_fcel                              , & ! Input:  [real(r8) (:)   ]  leaf litter cellulose fraction
+         lf_flig                             =>    veg_vp%lf_flig                              , & ! Input:  [real(r8) (:)   ]  leaf litter lignin fraction
+         fr_flab                             =>    veg_vp%fr_flab                              , & ! Input:  [real(r8) (:)   ]  fine root litter labile fraction
+         fr_fcel                             =>    veg_vp%fr_fcel                              , & ! Input:  [real(r8) (:)   ]  fine root litter cellulose fraction
+         fr_flig                             =>    veg_vp%fr_flig                              , & ! Input:  [real(r8) (:)   ]  fine root litter lignin fraction
+
+         leaf_prof                           =>    cnstate_vars%leaf_prof_patch                    , & ! Input:  [real(r8) (:,:) ]  (1/m) profile of leaves
+         froot_prof                          =>    cnstate_vars%froot_prof_patch                   , & ! Input:  [real(r8) (:,:) ]  (1/m) profile of fine roots
+
+         leafc_to_litter                     =>    veg_cf%leafc_to_litter           , & ! Input:  [real(r8) (:)   ]  leaf C litterfall (gC/m2/s)
+         frootc_to_litter                    =>    veg_cf%frootc_to_litter          , & ! Input:  [real(r8) (:)   ]  fine root N litterfall (gN/m2/s)
+         livestemc_to_litter                 =>    veg_cf%livestemc_to_litter       , & ! Input:  [real(r8) (:)   ]  live stem C litterfall (gC/m2/s)
+!         grainc_to_food                      =>    veg_cf%grainc_to_food            , & ! Input:  [real(r8) (:)   ]  grain C to food (gC/m2/s)
+         phenology_c_to_litr_met_c           =>    col_cf%phenology_c_to_litr_met_c   , & ! Output: [real(r8) (:,:) ]  C fluxes associated with phenology (litterfall and crop) to litter metabolic pool (gC/m3/s)
+         phenology_c_to_litr_cel_c           =>    col_cf%phenology_c_to_litr_cel_c   , & ! Output: [real(r8) (:,:) ]  C fluxes associated with phenology (litterfall and crop) to litter cellulose pool (gC/m3/s)
+         phenology_c_to_litr_lig_c           =>    col_cf%phenology_c_to_litr_lig_c   , & ! Output: [real(r8) (:,:) ]  C fluxes associated with phenology (litterfall and crop) to litter lignin pool (gC/m3/s)
+
+         livestemn_to_litter                 =>    veg_nf%livestemn_to_litter     , & ! Input:  [real(r8) (:)   ]  livestem N to litter (gN/m2/s)
+!         grainn_to_food                      =>    veg_nf%grainn_to_food          , & ! Input:  [real(r8) (:)   ]  grain N to food (gN/m2/s)
+         leafn_to_litter                     =>    veg_nf%leafn_to_litter         , & ! Input:  [real(r8) (:)   ]  leaf N litterfall (gN/m2/s)
+         frootn_to_litter                    =>    veg_nf%frootn_to_litter        , & ! Input:  [real(r8) (:)   ]  fine root N litterfall (gN/m2/s)
+         phenology_n_to_litr_met_n           =>    col_nf%phenology_n_to_litr_met_n , & ! Output: [real(r8) (:,:) ]  N fluxes associated with phenology (litterfall and crop) to litter metabolic pool (gN/m3/s)
+         phenology_n_to_litr_cel_n           =>    col_nf%phenology_n_to_litr_cel_n , & ! Output: [real(r8) (:,:) ]  N fluxes associated with phenology (litterfall and crop) to litter cellulose pool (gN/m3/s)
+         phenology_n_to_litr_lig_n           =>    col_nf%phenology_n_to_litr_lig_n , & ! Output: [real(r8) (:,:) ]  N fluxes associated with phenology (litterfall and crop) to litter lignin pool (gN/m3/s)
+
+         livestemp_to_litter                 =>    veg_pf%livestemp_to_litter     , & ! Input:  [real(r8) (:)   ]  livestem P to litter (gP/m2/s)
+!         grainp_to_food                      =>    veg_pf%grainp_to_food          , & ! Input:  [real(r8) (:)   ]  grain P to food (gP/m2/s)
+         leafp_to_litter                     =>    veg_pf%leafp_to_litter         , & ! Input:  [real(r8) (:)   ]  leaf P litterfall (gP/m2/s)
+         frootp_to_litter                    =>    veg_pf%frootp_to_litter        , & ! Input:  [real(r8) (:)   ]  fine root P litterfall (gP/m2/s)
+         phenology_p_to_litr_met_p           =>    col_pf%phenology_p_to_litr_met_p , & ! Output: [real(r8) (:,:) ]  P fluxes associated with phenology (litterfall and crop) to litter metabolic pool (gP/m3/s)
+         phenology_p_to_litr_cel_p           =>    col_pf%phenology_p_to_litr_cel_p , & ! Output: [real(r8) (:,:) ]  P fluxes associated with phenology (litterfall and crop) to litter cellulose pool (gP/m3/s)
+         phenology_p_to_litr_lig_p           =>    col_pf%phenology_p_to_litr_lig_p   & ! Output: [real(r8) (:,:) ]  P fluxes associated with phenology (litterfall and crop) to litter lignin pool (gP/m3/s)
+         )
+
+      do j = 1, nlevdecomp
+            do fp = 1,num_soilp
+               p = filter_soilp(fp)
+               c = veg_pp%column(p)
+               wt_col = wtcol(p)
                ! leaf litter carbon fluxes
-               sum1 = sum1 + leafc_to_litter(p) * lf_flab(ivt) * wt_col * leaf_prof(p,j)
-               sum2 = sum2 + leafc_to_litter(p) * lf_fcel(ivt) * wt_col * leaf_prof(p,j)
-               sum3 = sum3 + leafc_to_litter(p) * lf_flig(ivt) * wt_col * leaf_prof(p,j)
-              
-               ! fine root litter carbon fluxes
-               sum1 = sum1 + frootc_to_litter(p) * lf_flab(ivt) * wt_col * leaf_prof(p,j)
-               sum2 = sum2 + frootc_to_litter(p) * lf_fcel(ivt) * wt_col * leaf_prof(p,j)
-               sum3 = sum3 + frootc_to_litter(p) * lf_flig(ivt) * wt_col * leaf_prof(p,j)
-
-               ! agroibis puts crop stem litter together with leaf litter
-               ! so I've used the leaf lf_f* parameters instead of making
-               ! new ones for now (slevis)
-               ! The food is now directed to the product pools (BDrewniak)
-               if (ivt >= npcropmin) then ! add livestemc to litter
-                  ! stem litter carbon fluxes
-                  sum1 = sum1 + livestemc_to_litter(p) * lf_flab(ivt) * wt_col * leaf_prof(p,j)
-                  sum2 = sum2 + livestemc_to_litter(p) * lf_fcel(ivt) * wt_col * leaf_prof(p,j)
-                  sum3 = sum3 + livestemc_to_litter(p) * lf_flig(ivt) * wt_col * leaf_prof(p,j)
-               end if 
-             end if 
-           end do 
-           phenology_c_to_litr_met_c(c,j) = phenology_c_to_litr_met_c(c,j) + sum1 
-           phenology_c_to_litr_cel_c(c,j) = phenology_c_to_litr_cel_c(c,j) + sum2 
-           phenology_c_to_litr_lig_c(c,j) = phenology_c_to_litr_lig_c(c,j) + sum3
-        end do 
-     end do 
-     !$acc parallel loop independent gang worker collapse(2) private(sum1,sum2,sum3) default(present) 
-     do j = 1, nlevdecomp
-        do fc = 1,num_soilc
-           c = filter_soilc(fc)
-           sum1 = 0.0_r8 
-           sum2 = 0.0_r8 
-           sum3 = 0.0_r8
-           !$acc loop vector reduction(+:sum1,sum2,sum3) private(wt_col,ivt)
-           do p = col_pp%pfti(c), col_pp%pftf(c)
-               
-              if(veg_pp%active(p)) then  
-                  wt_col = wtcol(p)
-                  ivt = veg_pp%itype(p)
-
-                  ! leaf litter nitrogen fluxes
-                  sum1 = sum1 + leafn_to_litter(p) * lf_flab(ivt) * wt_col * leaf_prof(p,j)
-                  sum2 = sum2 + leafn_to_litter(p) * lf_fcel(ivt) * wt_col * leaf_prof(p,j)
-                  sum3 = sum3 + leafn_to_litter(p) * lf_flig(ivt) * wt_col * leaf_prof(p,j)
-                  ! fine root litter nitrogen fluxes
-                  sum1 = sum1 + frootn_to_litter(p) * lf_flab(ivt) * wt_col * leaf_prof(p,j)
-                  sum2 = sum2 + frootn_to_litter(p) * lf_fcel(ivt) * wt_col * leaf_prof(p,j)
-                  sum3 = sum3 + frootn_to_litter(p) * lf_flig(ivt) * wt_col * leaf_prof(p,j)
-
-                  ! agroibis puts crop stem litter together with leaf litter
-                  ! so I've used the leaf lf_f* parameters instead of making
-                  ! new ones for now (slevis)
-                  ! The food is now directed to the product pools (BDrewniak)
-                  if (ivt >= npcropmin) then ! add livestemc to litter
-                     ! stem litter nitrogen fluxes
-                     sum1 = sum1 + livestemn_to_litter(p) * lf_flab(ivt) * wt_col * leaf_prof(p,j)
-                     sum2 = sum2 + livestemn_to_litter(p) * lf_fcel(ivt) * wt_col * leaf_prof(p,j)
-                     sum3 = sum3 + livestemn_to_litter(p) * lf_flig(ivt) * wt_col * leaf_prof(p,j)
-
-                  end if 
-              end if 
-           end do 
-           phenology_n_to_litr_met_n(c,j) = phenology_n_to_litr_met_n(c,j) + sum1 
-           phenology_n_to_litr_cel_n(c,j) = phenology_n_to_litr_cel_n(c,j) + sum2 
-           phenology_n_to_litr_lig_n(c,j) = phenology_n_to_litr_lig_n(c,j) + sum3
-        end do 
-     end do 
-     !$acc parallel loop independent gang worker collapse(2) private(sum1,sum2,sum3) default(present) 
-     do j = 1, nlevdecomp
-        do fc = 1,num_soilc
-           c = filter_soilc(fc)
-           sum1 = 0.0_r8 
-           sum2 = 0.0_r8 
-           sum3 = 0.0_r8
-           !$acc loop vector reduction(+:sum1,sum2,sum3) private(wt_col,ivt)
-           do p = col_pp%pfti(c), col_pp%pftf(c)
-             if(veg_pp%active(p) ) then 
-              wt_col = wtcol(p)
-              ivt = veg_pp%itype(p)
-              ! leaf litter phosphorus fluxes
-              sum1 = sum1 + leafp_to_litter(p) * lf_flab(ivt) * wt_col * leaf_prof(p,j)
-              sum2 = sum2 + leafp_to_litter(p) * lf_fcel(ivt) * wt_col * leaf_prof(p,j)
-              sum3 = sum3 + leafp_to_litter(p) * lf_flig(ivt) * wt_col * leaf_prof(p,j)
-
-              ! fine root litter phosphorus fluxes
-              sum1 = sum1 + frootp_to_litter(p) * lf_flab(ivt) * wt_col * leaf_prof(p,j)
-              sum2 = sum2 + frootp_to_litter(p) * lf_fcel(ivt) * wt_col * leaf_prof(p,j)
-              sum3 = sum3 + frootp_to_litter(p) * lf_flig(ivt) * wt_col * leaf_prof(p,j)
-
-              ! agroibis puts crop stem litter together with leaf litter
-              ! so I've used the leaf lf_f* parameters instead of making
-              ! new ones for now (slevis)
-              ! The food is now directed to the product pools (BDrewniak)
-              if (ivt >= npcropmin) then ! add livestemc to litter
-                 ! stem litter phosphorus fluxes
-                 sum1 = sum1 + livestemp_to_litter(p) * lf_flab(ivt) * wt_col * leaf_prof(p,j)
-                 sum2 = sum2 + livestemp_to_litter(p) * lf_fcel(ivt) * wt_col * leaf_prof(p,j)
-                 sum3 = sum3 + livestemp_to_litter(p) * lf_flig(ivt) * wt_col * leaf_prof(p,j)
-
-              end if 
-            endif 
-           end do
-           phenology_p_to_litr_met_p(c,j) = phenology_p_to_litr_met_p(c,j) + sum1 
-           phenology_p_to_litr_cel_p(c,j) = phenology_p_to_litr_cel_p(c,j) + sum2 
-           phenology_p_to_litr_lig_p(c,j) = phenology_p_to_litr_lig_p(c,j) + sum3
-        end do 
-     end do
-
-    !$acc exit data delete(sum1,sum2,sum3, wt_col)  
-
-   end associate
-
- end subroutine CNLitterToColumn
+               phenology_c_to_litr_met_c(c,j) = phenology_c_to_litr_met_c(c,j) &
+                   + leafc_to_litter(p) * lf_flab(ivt(p)) * wt_col * leaf_prof(p,j)
+               phenology_c_to_litr_cel_c(c,j) = phenology_c_to_litr_cel_c(c,j) &
+                   + leafc_to_litter(p) * lf_fcel(ivt(p)) * wt_col * leaf_prof(p,j)
+               phenology_c_to_litr_lig_c(c,j) = phenology_c_to_litr_lig_c(c,j) &
+                   + leafc_to_litter(p) * lf_flig(ivt(p)) * wt_col * leaf_prof(p,j)
+
+                     ! leaf litter nitrogen fluxes
+                     phenology_n_to_litr_met_n(c,j) = phenology_n_to_litr_met_n(c,j) &
+                          + leafn_to_litter(p) * lf_flab(ivt(p)) * wt_col * leaf_prof(p,j)
+                     phenology_n_to_litr_cel_n(c,j) = phenology_n_to_litr_cel_n(c,j) &
+                          + leafn_to_litter(p) * lf_fcel(ivt(p)) * wt_col * leaf_prof(p,j)
+                     phenology_n_to_litr_lig_n(c,j) = phenology_n_to_litr_lig_n(c,j) &
+                          + leafn_to_litter(p) * lf_flig(ivt(p)) * wt_col * leaf_prof(p,j)
+
+                     ! leaf litter phosphorus fluxes
+                     phenology_p_to_litr_met_p(c,j) = phenology_p_to_litr_met_p(c,j) &
+                          + leafp_to_litter(p) * lf_flab(ivt(p)) * wt_col * leaf_prof(p,j)
+                     phenology_p_to_litr_cel_p(c,j) = phenology_p_to_litr_cel_p(c,j) &
+                          + leafp_to_litter(p) * lf_fcel(ivt(p)) * wt_col * leaf_prof(p,j)
+                     phenology_p_to_litr_lig_p(c,j) = phenology_p_to_litr_lig_p(c,j) &
+                          + leafp_to_litter(p) * lf_flig(ivt(p)) * wt_col * leaf_prof(p,j)
+
+                     ! fine root litter carbon fluxes
+                     phenology_c_to_litr_met_c(c,j) = phenology_c_to_litr_met_c(c,j) &
+                          + frootc_to_litter(p) * fr_flab(ivt(p)) * wt_col * froot_prof(p,j)
+                     phenology_c_to_litr_cel_c(c,j) = phenology_c_to_litr_cel_c(c,j) &
+                          + frootc_to_litter(p) * fr_fcel(ivt(p)) * wt_col * froot_prof(p,j)
+                     phenology_c_to_litr_lig_c(c,j) = phenology_c_to_litr_lig_c(c,j) &
+                          + frootc_to_litter(p) * fr_flig(ivt(p)) * wt_col * froot_prof(p,j)
+
+                     ! fine root litter nitrogen fluxes
+                     phenology_n_to_litr_met_n(c,j) = phenology_n_to_litr_met_n(c,j) &
+                          + frootn_to_litter(p) * fr_flab(ivt(p)) * wt_col * froot_prof(p,j)
+                     phenology_n_to_litr_cel_n(c,j) = phenology_n_to_litr_cel_n(c,j) &
+                          + frootn_to_litter(p) * fr_fcel(ivt(p)) * wt_col * froot_prof(p,j)
+                     phenology_n_to_litr_lig_n(c,j) = phenology_n_to_litr_lig_n(c,j) &
+                          + frootn_to_litter(p) * fr_flig(ivt(p)) * wt_col * froot_prof(p,j)
+
+
+                     ! fine root litter phosphorus fluxes
+                     phenology_p_to_litr_met_p(c,j) = phenology_p_to_litr_met_p(c,j) &
+                          + frootp_to_litter(p) * fr_flab(ivt(p)) * wt_col * froot_prof(p,j)
+                     phenology_p_to_litr_cel_p(c,j) = phenology_p_to_litr_cel_p(c,j) &
+                          + frootp_to_litter(p) * fr_fcel(ivt(p)) * wt_col * froot_prof(p,j)
+                     phenology_p_to_litr_lig_p(c,j) = phenology_p_to_litr_lig_p(c,j) &
+                          + frootp_to_litter(p) * fr_flig(ivt(p)) * wt_col * froot_prof(p,j)
+
+                     ! agroibis puts crop stem litter together with leaf litter
+                     ! so I've used the leaf lf_f* parameters instead of making
+                     ! new ones for now (slevis)
+                     ! The food is now directed to the product pools (BDrewniak)
+
+                     if (ivt(p) >= npcropmin) then ! add livestemc to litter
+                        ! stem litter carbon fluxes
+                        phenology_c_to_litr_met_c(c,j) = phenology_c_to_litr_met_c(c,j) &
+                             + livestemc_to_litter(p) * lf_flab(ivt(p)) * wt_col * leaf_prof(p,j)
+                        phenology_c_to_litr_cel_c(c,j) = phenology_c_to_litr_cel_c(c,j) &
+                             + livestemc_to_litter(p) * lf_fcel(ivt(p)) * wt_col * leaf_prof(p,j)
+                        phenology_c_to_litr_lig_c(c,j) = phenology_c_to_litr_lig_c(c,j) &
+                             + livestemc_to_litter(p) * lf_flig(ivt(p)) * wt_col * leaf_prof(p,j)
+
+                        ! stem litter nitrogen fluxes
+                        phenology_n_to_litr_met_n(c,j) = phenology_n_to_litr_met_n(c,j) &
+                             + livestemn_to_litter(p) * lf_flab(ivt(p)) * wt_col * leaf_prof(p,j)
+                        phenology_n_to_litr_cel_n(c,j) = phenology_n_to_litr_cel_n(c,j) &
+                             + livestemn_to_litter(p) * lf_fcel(ivt(p)) * wt_col * leaf_prof(p,j)
+                        phenology_n_to_litr_lig_n(c,j) = phenology_n_to_litr_lig_n(c,j) &
+                             + livestemn_to_litter(p) * lf_flig(ivt(p)) * wt_col * leaf_prof(p,j)
+
+                        ! stem litter phosphorus fluxes
+                        phenology_p_to_litr_met_p(c,j) = phenology_p_to_litr_met_p(c,j) &
+                             + livestemp_to_litter(p) * lf_flab(ivt(p)) * wt_col * leaf_prof(p,j)
+                        phenology_p_to_litr_cel_p(c,j) = phenology_p_to_litr_cel_p(c,j) &
+                             + livestemp_to_litter(p) * lf_fcel(ivt(p)) * wt_col * leaf_prof(p,j)
+                        phenology_p_to_litr_lig_p(c,j) = phenology_p_to_litr_lig_p(c,j) &
+                             + livestemp_to_litter(p) * lf_flig(ivt(p)) * wt_col * leaf_prof(p,j)
 
+                     end if
+
+         end do
+      end do
+
+    end associate
+
+  end subroutine CNLitterToColumn
 
  !-----------------------------------------------------------------------
  subroutine CNCropHarvestPftToColumn (num_soilc, filter_soilc, &
@@ -3440,6 +3496,7 @@ contains
    ! to the column level and assign them to a product pools
    !
    ! !USES:
+      !$acc routine seq
    use elm_varpar, only : maxpatch_pft
    type(cnstate_type)       , intent(in)    :: cnstate_vars
    !
diff --git a/components/elm/src/biogeochem/PhosphorusDynamicsMod.F90 b/components/elm/src/biogeochem/PhosphorusDynamicsMod.F90
index f55494e928..c8a7c445c0 100644
--- a/components/elm/src/biogeochem/PhosphorusDynamicsMod.F90
+++ b/components/elm/src/biogeochem/PhosphorusDynamicsMod.F90
@@ -13,6 +13,7 @@ module PhosphorusDynamicsMod
   use decompMod           , only : bounds_type
   use elm_varcon          , only : dzsoi_decomp, zisoi
   use atm2lndType         , only : atm2lnd_type
+  use CNCarbonFluxType    , only : carbonflux_type
   use elm_varpar          , only : nlevdecomp
   use elm_varctl          , only : use_vertsoilc
 
@@ -24,7 +25,7 @@ module PhosphorusDynamicsMod
   use VegetationDataType  , only : veg_ns, veg_pf
   use VegetationPropertiesType      , only : veg_vp
   use elm_varctl          , only : NFIX_PTASE_plant
-  use elm_varctl          , only : use_fates, iulog
+  use elm_varctl          , only : use_fates
   use elm_instMod         , only : alm_fates
 
   !
@@ -41,13 +42,13 @@ module PhosphorusDynamicsMod
   public :: PhosphorusBiochemMin
   public :: PhosphorusLeaching
   public :: PhosphorusBiochemMin_balance
-  public :: PhosphorusMinFluxes
 
   !-----------------------------------------------------------------------
 
 contains
   !-----------------------------------------------------------------------
-  subroutine PhosphorusDeposition( bounds, atm2lnd_vars )
+  subroutine PhosphorusDeposition( bounds, &
+       atm2lnd_vars )
     ! BY X. SHI
     ! !DESCRIPTION:
     ! On the radiation time step, update the phosphorus deposition rate
@@ -57,24 +58,21 @@ contains
     ! directly into the canopy and mineral P entering the soil pool.
     !
     ! !ARGUMENTS:
-    type(bounds_type)  , intent(in) :: bounds 
+      !$acc routine seq
+    type(bounds_type)        , intent(in)    :: bounds
     type(atm2lnd_type)       , intent(in)    :: atm2lnd_vars
     !
     ! !LOCAL VARIABLES:
-    integer :: g,c,fc                ! indices
-    integer :: begc ,endc 
+    integer :: g,c                    ! indices
     !-----------------------------------------------------------------------
 
     associate(&
-         forc_pdep     =>  atm2lnd_vars%forc_pdep_grc     , & ! Input:  [real(r8) (:)]  Phosphorus deposition rate (gP/m2/s)
+         forc_pdep     =>  atm2lnd_vars%forc_pdep_grc           , & ! Input:  [real(r8) (:)]  Phosphorus deposition rate (gP/m2/s)
          pdep_to_sminp =>  col_pf%pdep_to_sminp   & ! Output: [real(r8) (:)]
          )
 
-      begc = bounds%begc 
-      endc = bounds%endc 
       ! Loop through columns
-      !$acc parallel loop independent gang vector private(c,g) default(present)
-      do c = begc, endc
+      do c = bounds%begc, bounds%endc
          g = col_pp%gridcell(c)
          pdep_to_sminp(c) = forc_pdep(g)
       end do
@@ -83,41 +81,32 @@ contains
 
   end subroutine PhosphorusDeposition
 
-  subroutine PhosphorusMinFluxes(num_soilc, filter_soilc,cnstate_vars,dt)
-   implicit none 
-   
-   integer                  , intent(in)    :: num_soilc         ! number of soil columns in filter
-   integer                  , intent(in)    :: filter_soilc(:)   ! filter for soil columns
-   type(cnstate_type)       , intent(in)    :: cnstate_vars
-   real(r8)                 , intent(in)    :: dt 
-   
-   call PhosphorusWeathering(num_soilc, filter_soilc,cnstate_vars, dt)
-   call PhosphorusAdsportion(num_soilc, filter_soilc,cnstate_vars, dt)
-   call PhosphorusDesoprtion(num_soilc, filter_soilc,cnstate_vars, dt)
-   call PhosphorusOcclusion (num_soilc, filter_soilc,cnstate_vars, dt)
-
-  end subroutine PhosphorusMinFluxes
-
   !-----------------------------------------------------------------------
-  subroutine PhosphorusWeathering(num_soilc, filter_soilc, cnstate_vars, dt)
+  subroutine PhosphorusWeathering(num_soilc, filter_soilc, &
+       cnstate_vars, dt)
     !
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon       , only : secspday, spval
     use soilorder_varcon, only: r_weather
     !
     ! !ARGUMENTS:
     integer                 , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                 , intent(in)    :: filter_soilc(:) ! filter for soil columns
-    type(cnstate_type)      , intent(in)    :: cnstate_vars
+    type(cnstate_type)       , intent(in)    :: cnstate_vars
     real(r8), intent(in):: dt           !decomp timestep (seconds)
 
     !
     ! !LOCAL VARIABLES:
+    integer  :: c,fc                  ! indices
+    real(r8) :: t                     ! temporary
+
+!   !OTHER LOCAL VARIABLES
     real(r8)     :: r_weather_c
     real(r8)     :: rr
     real(r8):: dtd          !decomp timestep (days)
-    integer :: fc, c ,j 
+    integer :: j
 
     !-----------------------------------------------------------------------
 
@@ -129,28 +118,32 @@ contains
          )
 
       ! set time steps
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
+      dtd = dt/(30._r8*secspday)
+
       do j = 1,nlevdecomp
-        do fc = 1,num_soilc
-           c = filter_soilc(fc)
-           dtd = dt/(30._r8*secspday)
+         do fc = 1,num_soilc
+            c = filter_soilc(fc)
             !! read in monthly rate is converted to that in half hour
             r_weather_c = r_weather( isoilorder(c) )
             rr=-log(1._r8-r_weather_c)
             r_weather_c=1._r8-exp(-rr*dtd)
             primp_to_labilep(c,j) = primp(c,j)*r_weather_c/dt
-        end do
+         end do
       enddo
     end associate
 
   end subroutine PhosphorusWeathering
- 
   !-----------------------------------------------------------------------
- 
-  subroutine PhosphorusAdsportion( num_soilc, filter_soilc, cnstate_vars,dt)
+
+
+
+  !-----------------------------------------------------------------------
+  subroutine PhosphorusAdsportion(num_soilc, filter_soilc, &
+       cnstate_vars ,dt)
     !
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon       , only : secspday, spval
     use soilorder_varcon , only : r_adsorp
     !
@@ -160,11 +153,17 @@ contains
     type(cnstate_type)       , intent(in)    :: cnstate_vars
     real(r8), intent(in)    :: dt           !decomp timestep (seconds)
 
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: c,fc                  ! indices
+    real(r8) :: t                     ! temporary
+
 !   !OTHER LOCAL VARIABLES
     real(r8)     :: r_adsorp_c
     real(r8)     :: rr
     real(r8):: dtd          !decomp timestep (days)
-    integer :: fc, c ,j 
+    integer :: j
+
     !-----------------------------------------------------------------------
 
     associate(&
@@ -176,64 +175,77 @@ contains
 
          )
 
+
       ! set time steps
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
+      dtd = dt/(30._r8*secspday)
+
       do j = 1,nlevdecomp
-        do fc = 1,num_soilc
-           c = filter_soilc(fc)
-           dtd = dt/(30._r8*secspday)
-
-           ! calculate rate at half-hour time step
-           r_adsorp_c = r_adsorp( isoilorder(c) )
-           rr=-log(1._r8-r_adsorp_c)
-           r_adsorp_c = 1._r8-exp(-rr*dtd)
-           if(labilep(c,j) > 0._r8)then
-              labilep_to_secondp(c,j) = ( labilep(c,j) )*r_adsorp_c/dt
-           else
-              labilep_to_secondp(c,j) = 0._r8
-           end if
+         do fc = 1,num_soilc
+            c = filter_soilc(fc)
 
-        end do
-      end do
+            ! calculate rate at half-hour time step
+            r_adsorp_c = r_adsorp( isoilorder(c) )
+            rr=-log(1._r8-r_adsorp_c)
+            r_adsorp_c = 1._r8-exp(-rr*dtd)
+
+            if(labilep(c,j) > 0._r8)then
+               labilep_to_secondp(c,j) = ( labilep(c,j) )*r_adsorp_c/dt
+            else
+               labilep_to_secondp(c,j) = 0._r8
+            end if
+
+         end do
+       end do
     end associate
 
   end subroutine PhosphorusAdsportion
 
 
   !-----------------------------------------------------------------------
-  subroutine PhosphorusDesoprtion(num_soilc, filter_soilc, cnstate_vars, dt)
+  subroutine PhosphorusDesoprtion(num_soilc, filter_soilc, &
+       cnstate_vars, dt)
     !
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon       , only : secspday, spval
     use soilorder_varcon , only : r_desorp
     !
     ! !ARGUMENTS:
     integer                 , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                 , intent(in)    :: filter_soilc(:) ! filter for soil columns
-    type(cnstate_type)       , intent(in)   :: cnstate_vars
+    type(cnstate_type)       , intent(in)    :: cnstate_vars
     real(r8)                 ,  intent(in)   :: dt           !decomp timestep (seconds)
 
-    !OTHER LOCAL VARIABLES
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: c,fc                  ! indices
+    real(r8) :: t                     ! temporary
+
+!   !OTHER LOCAL VARIABLES
     real(r8)     :: r_desorp_c
     real(r8)     :: rr
-    real(r8)     :: dtd          !decomp timestep (days)
-    integer :: fc, c ,j 
+    real(r8):: dtd          !decomp timestep (days)
+    integer :: j
+
     !-----------------------------------------------------------------------
 
     associate(&
+
          isoilorder     => cnstate_vars%isoilorder              ,&
          secondp     => col_ps%secondp_vr     ,&
          secondp_to_labilep => col_pf%secondp_to_labilep_vr &
+
          )
 
 
       ! set time steps
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
+      dtd = dt/(30._r8*secspday)
+
       do j = 1,nlevdecomp
-        do fc = 1,num_soilc
-           c = filter_soilc(fc)
-           dtd = dt/(30._r8*secspday)
+         do fc = 1,num_soilc
+            c = filter_soilc(fc)
+
             ! calculate rate at half-hour time step
             r_desorp_c = r_desorp( isoilorder(c) )
             rr=-log(1._r8-r_desorp_c)
@@ -245,7 +257,7 @@ contains
               secondp_to_labilep(c,j) = 0._r8
             endif
 
-        end do
+         end do
        end do
     end associate
 
@@ -254,70 +266,83 @@ contains
 
 
   !-----------------------------------------------------------------------
-  subroutine PhosphorusOcclusion( num_soilc,filter_soilc, cnstate_vars, dt)
+  subroutine PhosphorusOcclusion(num_soilc, filter_soilc, &
+       cnstate_vars, dt)
     !
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon       , only : secspday, spval
     use soilorder_varcon , only : r_occlude
     !
     ! !ARGUMENTS:
     integer                 , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                 , intent(in)    :: filter_soilc(:) ! filter for soil columns
-    type(cnstate_type)      , intent(in)    :: cnstate_vars
-    real(r8)                , intent(in)    :: dt      !decomp timestep (seconds)
+    type(cnstate_type)       , intent(in)    :: cnstate_vars
+    real(r8)                , intent(in)   :: dt      !decomp timestep (seconds)
 
     !
     ! !LOCAL VARIABLES:
+    integer  :: c,fc                  ! indices
     real(r8) :: t                     ! temporary
 
 !   !OTHER LOCAL VARIABLES
     real(r8)     :: r_occlude_c
     real(r8)     :: rr
     real(r8):: dtd          !decomp timestep (days)
-    integer :: fc, c ,j 
+    integer :: j
 
     !-----------------------------------------------------------------------
 
     associate(&
+
          isoilorder     => cnstate_vars%isoilorder                      ,&
          secondp     => col_ps%secondp_vr             ,&
          secondp_to_occlp => col_pf%secondp_to_occlp_vr &
+
          )
 
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
+      ! set time steps
+      dtd = dt/(30._r8*secspday)
+
       do j = 1,nlevdecomp
          do fc = 1,num_soilc
-            dtd = dt/(30._r8*secspday)
             c = filter_soilc(fc)
+
+
             ! calculate rate at half-hour time step
             r_occlude_c = r_occlude( isoilorder(c) )
             rr=-log(1._r8-r_occlude_c)
             r_occlude_c = 1._r8-exp(-rr*dtd)
+
             if(secondp(c,j) > 0._r8)then
                secondp_to_occlp(c,j) = secondp(c,j)*r_occlude_c/dt
             else
                secondp_to_occlp(c,j) =0._r8
             endif
 
-        end do
-      end do
+         end do
+       end do
     end associate
 
   end subroutine PhosphorusOcclusion
 
+  !-----------------------------------------------------------------------
+
 
   !-----------------------------------------------------------------------
-  subroutine PhosphorusLeaching(num_soilc, filter_soilc, dt)
+  subroutine PhosphorusLeaching(bounds, num_soilc, filter_soilc, dt)
     !
     ! !DESCRIPTION:
     ! On the radiation time step, update the phosphorus leaching rate
     ! as a function of solution P and total soil water outflow.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varpar       , only : nlevsoi, nlevgrnd
     !
     ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
     real(r8) ,intent(in)    :: dt                                     ! radiation time step(seconds)
@@ -327,52 +352,68 @@ contains
     integer  :: j,c,fc                                 ! indices
     integer  :: nlevbed				       ! number of layers to bedrock
     real(r8) :: disp_conc                              ! dissolved mineral N concentration (gP/kg water)
+    real(r8) :: tot_water(bounds%begc:bounds%endc)     ! total column liquid water (kg water/m2)
+    real(r8) :: surface_water(bounds%begc:bounds%endc) ! liquid water to shallow surface depth (kg water/m2)
+    real(r8) :: drain_tot(bounds%begc:bounds%endc)     ! total drainage flux (mmH2O /s)
     real(r8), parameter :: depth_runoff_Ploss = 0.05   ! (m) depth over which runoff mixes with soil water for P loss to runoff
-    real(r8)  :: tot_water(num_soilc)     ! total column liquid water (kg water/m2)
-    real :: sum1 
     !-----------------------------------------------------------------------
 
     associate(&
-    	   nlev2bed            => col_pp%nlevbed            , & ! Input:  [integer (:)    ]  number of layers to bedrock
-         h2osoi_liq          => col_ws%h2osoi_liq         , & !Input:  [real(r8) (:,:) ]  liquid water (kg/m2) (new) (-nlevsno+1:nlevgrnd)
+    	 nlev2bed            => col_pp%nlevbed                            , & ! Input:  [integer (:)    ]  number of layers to bedrock
+         h2osoi_liq          => col_ws%h2osoi_liq            , & !Input:  [real(r8) (:,:) ]  liquid water (kg/m2) (new) (-nlevsno+1:nlevgrnd)
 
-         qflx_drain          => col_wf%qflx_drain         , & !Input:  [real(r8) (:)   ]  sub-surface runoff (mm H2O /s)
-         qflx_surf           => col_wf%qflx_surf          , & !Input:  [real(r8) (:)   ]  surface runoff (mm H2O /s)
+         qflx_drain          => col_wf%qflx_drain             , & !Input:  [real(r8) (:)   ]  sub-surface runoff (mm H2O /s)
+         qflx_surf           => col_wf%qflx_surf              , & !Input:  [real(r8) (:)   ]  surface runoff (mm H2O /s)
 
-         solutionp_vr        => col_ps%solutionp_vr       , & !Input:  [real(r8) (:,:) ]  (gP/m3) soil mineral N
+         solutionp_vr            => col_ps%solutionp_vr           , & !Input:  [real(r8) (:,:) ]  (gP/m3) soil mineral N
          sminp_leached_vr    => col_pf%sminp_leached_vr     & !Output: [real(r8) (:,:) ]  rate of mineral N leaching (gP/m3/s)
          )
-   
-      !$acc data create(tot_water(:), sum1)  
 
-         
+
       ! calculate the total soil water
-      !$acc parallel loop independent gang worker  private(sum1,c,nlevbed) default(present) 
+      tot_water(bounds%begc:bounds%endc) = 0._r8
       do fc = 1,num_soilc
          c = filter_soilc(fc)
-         nlevbed = col_pp%nlevbed(c)
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1)
+         nlevbed = nlev2bed(c)
          do j = 1,nlevbed
-            sum1 = sum1 + col_ws%h2osoi_liq(c,j)
+            tot_water(c) = tot_water(c) + h2osoi_liq(c,j)
+         end do
+      end do
+
+      ! for runoff calculation; calculate total water to a given depth
+      surface_water(bounds%begc:bounds%endc) = 0._r8
+      do fc = 1,num_soilc
+         c = filter_soilc(fc)
+         nlevbed = nlev2bed(c)
+         do j = 1,nlevbed
+            if ( zisoi(j) <= depth_runoff_Ploss)  then
+               surface_water(c) = surface_water(c) + h2osoi_liq(c,j)
+            elseif ( zisoi(j-1) < depth_runoff_Ploss)  then
+               surface_water(c) = surface_water(c) + h2osoi_liq(c,j) * ((depth_runoff_Ploss - zisoi(j-1)) / col_pp%dz(c,j))
+            end if
          end do
-         tot_water(fc) = sum1
       end do
-       
-         !$acc parallel loop independent gang vector collapse(2) default(present) 
+
+      ! Loop through columns
+      do fc = 1,num_soilc
+         c = filter_soilc(fc)
+         drain_tot(c) = qflx_drain(c)
+      end do
+
          do j = 1,nlevdecomp
+            ! Loop through columns
             do fc = 1,num_soilc
                c = filter_soilc(fc)
 
                if (.not. use_vertsoilc) then
                   disp_conc = 0._r8
-                  if (tot_water(fc) > 0._r8) then
-                     disp_conc = ( solutionp_vr(c,j) ) / tot_water(fc)
+                  if (tot_water(c) > 0._r8) then
+                     disp_conc = ( solutionp_vr(c,j) ) / tot_water(c)
                   end if
 
                   ! calculate the P leaching flux as a function of the dissolved
                   ! concentration and the sub-surface drainage flux
-                  sminp_leached_vr(c,j) = disp_conc * qflx_drain(c)
+                  sminp_leached_vr(c,j) = disp_conc * drain_tot(c)
                else
                   disp_conc = 0._r8
                   if (h2osoi_liq(c,j) > 0._r8) then
@@ -381,7 +422,7 @@ contains
 
                   ! calculate the P leaching flux as a function of the dissolved
                   ! concentration and the sub-surface drainage flux
-                  sminp_leached_vr(c,j) = disp_conc * qflx_drain(c) *h2osoi_liq(c,j) / ( tot_water(fc) * col_pp%dz(c,j) )
+                  sminp_leached_vr(c,j) = disp_conc * drain_tot(c) *h2osoi_liq(c,j) / ( tot_water(c) * col_pp%dz(c,j) )
 
                end if
                ! limit the flux based on current sminp state
@@ -393,14 +434,18 @@ contains
                sminp_leached_vr(c,j) = max(sminp_leached_vr(c,j), 0._r8)
             end do
          end do
-     !$acc end data  
 
     end associate
   end subroutine PhosphorusLeaching
 
+
   !-----------------------------------------------------------------------
 
-  subroutine PhosphorusBiochemMin(num_soilc, filter_soilc, &
+
+  !-----------------------------------------------------------------------
+
+
+  subroutine PhosphorusBiochemMin(bounds,num_soilc, filter_soilc, &
        cnstate_vars, dt)
     !
     ! !DESCRIPTION:
@@ -408,28 +453,33 @@ contains
     ! as a function of solution P and total soil water outflow.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varpar       , only : nlevsoi
     use elm_varpar       , only : ndecomp_pools
-    use soilorder_varcon , only : k_s1_biochem,k_s2_biochem,k_s3_biochem,k_s4_biochem
+    use soilorder_varcon , only:k_s1_biochem,k_s2_biochem,k_s3_biochem,k_s4_biochem
     use elm_varcon       , only : secspday, spval
 
     !
     ! !ARGUMENTS:
-    integer                  , intent(in)  :: num_soilc       ! number of soil columns in filter
-    integer                  , intent(in)  :: filter_soilc(:) ! filter for soil columns
-    type(cnstate_type)       , intent(in)  :: cnstate_vars
+    type(bounds_type)        , intent(in)    :: bounds
+    integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
+    type(cnstate_type)         , intent(in)    :: cnstate_vars
     real(r8) , intent(in)  :: dt           !decomp timestep (seconds)
+
     !
     integer  :: c,fc,j,l
     real(r8) :: rr
     real(r8):: dtd          !decomp timestep (days)
     real(r8):: k_s1_biochem_c         !specfic biochemical rate constant SOM 1
-   !  real(r8):: k_s2_biochem_c         !specfic biochemical rate constant SOM 1
-   !  real(r8):: k_s3_biochem_c         !specfic biochemical rate constant SOM 1
-   !  real(r8):: k_s4_biochem_c         !specfic biochemical rate constant SOM 1
-    real(r8), parameter :: r_bc = -5._r8
-    real(r8):: sum 
+    real(r8):: k_s2_biochem_c         !specfic biochemical rate constant SOM 1
+    real(r8):: k_s3_biochem_c         !specfic biochemical rate constant SOM 1
+    real(r8):: k_s4_biochem_c         !specfic biochemical rate constant SOM 1
+    real(r8):: r_bc
+
     !-----------------------------------------------------------------------
+    !!!!  decomp_ppools_vr_col(begc:endc,1:nlevdecomp_full,1:ndecomp_pools)
+
     associate(&
 
          isoilorder     => cnstate_vars%isoilorder                            ,&
@@ -439,34 +489,36 @@ contains
          biochem_pmin_vr_col  => col_pf%biochem_pmin_vr      ,&
          biochem_pmin_col     => col_pf%biochem_pmin         , &
          fpi_vr_col           => cnstate_vars%fpi_vr_col                      ,&
-         fpi_p_vr_col         => cnstate_vars%fpi_p_vr_col                   &
+         fpi_p_vr_col           => cnstate_vars%fpi_p_vr_col                   &
          )
 
-      !$acc enter data create(sum) 
+      dtd = dt/(30._r8*secspday)
+      r_bc = -5._r8
+
       ! set initial values for potential C and N fluxes
-      ! biochem_pmin_ppools_vr_col(bounds%begc : bounds%endc, :, :) = 0._r8
+      biochem_pmin_ppools_vr_col(bounds%begc : bounds%endc, :, :) = 0._r8
 
-      !$acc parallel loop independent gang vector collapse(2) default(present)
       do l = 1, ndecomp_pools
          do j = 1,nlevdecomp
             do fc = 1,num_soilc
                c = filter_soilc(fc)
 
-               dtd = dt/(30._r8*secspday)
                k_s1_biochem_c = k_s1_biochem( isoilorder(c) )
-               ! k_s2_biochem_c = k_s2_biochem( isoilorder(c) )
-               ! k_s3_biochem_c = k_s3_biochem( isoilorder(c) )
-               ! k_s4_biochem_c = k_s4_biochem( isoilorder(c) )
+               k_s2_biochem_c = k_s2_biochem( isoilorder(c) )
+               k_s3_biochem_c = k_s3_biochem( isoilorder(c) )
+               k_s4_biochem_c = k_s4_biochem( isoilorder(c) )
 
                rr=-log(1._r8-k_s1_biochem_c)
                k_s1_biochem_c = 1-exp(-rr*dtd)
 
-               ! rr=-log(1-k_s2_biochem_c)
-               ! k_s2_biochem_c = 1-exp(-rr*dtd)
-               ! rr=-log(1-k_s3_biochem_c)
-               ! k_s3_biochem_c = 1-exp(-rr*dtd)
-               ! rr=-log(1-k_s4_biochem_c)
-               ! k_s4_biochem_c = 1-exp(-rr*dtd)
+               rr=-log(1-k_s2_biochem_c)
+               k_s2_biochem_c = 1-exp(-rr*dtd)
+
+               rr=-log(1-k_s3_biochem_c)
+               k_s3_biochem_c = 1-exp(-rr*dtd)
+
+               rr=-log(1-k_s4_biochem_c)
+               k_s4_biochem_c = 1-exp(-rr*dtd)
 
                if ( decomp_ppools_vr_col(c,j,l) > 0._r8 ) then
 
@@ -474,26 +526,26 @@ contains
                                      k_s1_biochem_c * fpi_vr_col(c,j)*&
                                      (1._r8-exp(r_bc*(1._r8-fpi_p_vr_col(c,j)) ))/dt
 
+
                endif
 
+
             end do
          end do
       end do
 
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum,c)
+
       do j = 1,nlevdecomp
          do fc = 1,num_soilc
             c = filter_soilc(fc)
-            ! biochem_pmin_vr_col(c,j)=0._r8
-            sum = 0._r8 
-            !$acc loop vector reduction(+:sum) 
+            biochem_pmin_vr_col(c,j)=0._r8
             do l = 1, ndecomp_pools
-               sum = sum + biochem_pmin_ppools_vr_col(c,j,l)
+               biochem_pmin_vr_col(c,j) = biochem_pmin_vr_col(c,j)+ &
+                                          biochem_pmin_ppools_vr_col(c,j,l)
             enddo
-            biochem_pmin_vr_col(c,j) = sum
          enddo
       enddo
-      !$acc exit data delete(sum) 
+
 
 
     end associate
@@ -565,7 +617,7 @@ contains
     if(use_fates) then
         ci = bounds%clump_index
 #ifndef _OPENACC
-        !#fates_py max_comps = size(alm_fates%fates(ci)%bc_out(1)%cp_scalar,dim=1)
+        max_comps = size(alm_fates%fates(ci)%bc_out(1)%cp_scalar,dim=1)
         allocate(biochem_pmin_to_plant_vr_patch(max_comps,nlevdecomp))
 #endif
     else
@@ -578,7 +630,7 @@ contains
     do fc = 1,num_soilc
         c = filter_soilc(fc)
 
-        !#fates_py if(use_fates) s = alm_fates%f2hmap(ci)%hsites(c)
+        if(use_fates) s = alm_fates%f2hmap(ci)%hsites(c)
 
         biochem_pmin_vr(c,:) = 0.0_r8
         biochem_pmin_to_ecosysp_vr_col_pot(c,:) = 0._r8
@@ -586,28 +638,28 @@ contains
 
         if(use_fates) then
            do j = 1,nlevdecomp
-              !#fates_py j_f = alm_fates%fates(ci)%bc_pconst%j_uptake(j)
-              !#fates_py do p = 1, alm_fates%fates(ci)%bc_out(s)%num_plant_comps
+              j_f = alm_fates%fates(ci)%bc_pconst%j_uptake(j)
+              do p = 1, alm_fates%fates(ci)%bc_out(s)%num_plant_comps
 
-                 !#fates_py lamda_up = alm_fates%fates(ci)%bc_out(s)%cp_scalar(p)/ &
-                      !#fates_py max(alm_fates%fates(ci)%bc_out(s)%cn_scalar(p),1e-20_r8)
+                 lamda_up = alm_fates%fates(ci)%bc_out(s)%cp_scalar(p)/ &
+                      max(alm_fates%fates(ci)%bc_out(s)%cn_scalar(p),1e-20_r8)
                  lamda_up = min(max(lamda_up,0.0_r8), 150.0_r8)
 
-                 !#fates_py fr_frac = alm_fates%fates(ci)%bc_out(s)%veg_rootc(p,j) / &
-                      !#fates_py sum(alm_fates%fates(ci)%bc_out(s)%veg_rootc(p,:))
+                 fr_frac = alm_fates%fates(ci)%bc_out(s)%veg_rootc(p,j) / &
+                      sum(alm_fates%fates(ci)%bc_out(s)%veg_rootc(p,:))
 
-                 !#fates_py pft = alm_fates%fates(ci)%bc_out(s)%ft_index(p)
-                 !#fates_py ptase_tmp = alm_fates%fates(ci)%bc_pconst%eca_vmax_ptase(pft) *  &
-                      !#fates_py fr_frac * max(lamda_up - lamda_ptase, 0.0_r8) / &
-                      !#fates_py ( alm_fates%fates(ci)%bc_pconst%eca_km_ptase(pft) + &
-                      !#fates_py max(lamda_up - alm_fates%fates(ci)%bc_pconst%eca_lambda_ptase(pft), 0.0_r8))
+                 pft = alm_fates%fates(ci)%bc_out(s)%ft_index(p)
+                 ptase_tmp = alm_fates%fates(ci)%bc_pconst%eca_vmax_ptase(pft) *  &
+                      fr_frac * max(lamda_up - lamda_ptase, 0.0_r8) / &
+                      ( alm_fates%fates(ci)%bc_pconst%eca_km_ptase(pft) + &
+                      max(lamda_up - alm_fates%fates(ci)%bc_pconst%eca_lambda_ptase(pft), 0.0_r8))
 
-                 !#fates_py biochem_pmin_to_plant_vr_patch(p,j) = ptase_tmp * alm_fates%fates(ci)%bc_pconst%eca_alpha_ptase(pft)
-                 !#fates_py biochem_pmin_vr(c,j) = biochem_pmin_vr(c,j) + ptase_tmp*(1._r8 - alm_fates%fates(ci)%bc_pconst%eca_alpha_ptase(pft))
+                 biochem_pmin_to_plant_vr_patch(p,j) = ptase_tmp * alm_fates%fates(ci)%bc_pconst%eca_alpha_ptase(pft)
+                 biochem_pmin_vr(c,j) = biochem_pmin_vr(c,j) + ptase_tmp*(1._r8 - alm_fates%fates(ci)%bc_pconst%eca_alpha_ptase(pft))
                  biochem_pmin_to_ecosysp_vr_col_pot(c,j) = biochem_pmin_to_ecosysp_vr_col_pot(c,j) + ptase_tmp
 
-             !#fates_py end do
-           end do
+              end do
+           end  do
         else
            do j = 1,nlevdecomp
               do p = col_pp%pfti(c), col_pp%pftf(c)
@@ -680,28 +732,28 @@ contains
                     if ( biochem_pmin_to_ecosysp_vr_col_pot(c,j) > 0.0_r8 ) then
                         biochem_pmin_vr(c,j) = biochem_pmin_vr(c,j) * &
                               biochem_pmin_to_ecosysp_vr_col(c,j) / biochem_pmin_to_ecosysp_vr_col_pot(c,j)
-                        !#fates_py do p = 1, alm_fates%fates(ci)%bc_out(s)%num_plant_comps
+                        do p = 1, alm_fates%fates(ci)%bc_out(s)%num_plant_comps
                             biochem_pmin_to_plant_vr_patch(p,j) = biochem_pmin_to_plant_vr_patch(p,j) * &
                                   biochem_pmin_to_ecosysp_vr_col(c,j) / biochem_pmin_to_ecosysp_vr_col_pot(c,j)
-                        !#fates_py end do
+                        end do
                     else
-                        !#fates_py do p = 1, alm_fates%fates(ci)%bc_out(s)%num_plant_comps
+                        do p = 1, alm_fates%fates(ci)%bc_out(s)%num_plant_comps
                             biochem_pmin_to_plant_vr_patch(p,j) = 0.0_r8
-                        !#fates_py end do
+                        end do
                         biochem_pmin_vr(c,j) = 0.0_r8
                     end if
                 end if
 
                 ! units:  [g/m2] = [g/m3/s] * [s] [m]
-                !#fates_py j_f = alm_fates%fates(ci)%bc_pconst%j_uptake(j)
-                !#fates_py do p = 1, alm_fates%fates(ci)%bc_out(s)%num_plant_comps
-                    !#fates_py alm_fates%fates(ci)%bc_in(s)%plant_p_uptake_flux(p,j_f) = &
-                          !#fates_py alm_fates%fates(ci)%bc_in(s)%plant_p_uptake_flux(p,j_f) + &
-                          !#fates_py biochem_pmin_to_plant_vr_patch(p,j)*dt*dzsoi_decomp(j)
+                j_f = alm_fates%fates(ci)%bc_pconst%j_uptake(j)
+                do p = 1, alm_fates%fates(ci)%bc_out(s)%num_plant_comps
+                    alm_fates%fates(ci)%bc_in(s)%plant_p_uptake_flux(p,j_f) = &
+                          alm_fates%fates(ci)%bc_in(s)%plant_p_uptake_flux(p,j_f) + &
+                          biochem_pmin_to_plant_vr_patch(p,j)*dt*dzsoi_decomp(j)
 
                     biochem_pmin_to_plant(c) =  biochem_pmin_to_plant(c) + &
                          biochem_pmin_to_plant_vr_patch(p,j)*dzsoi_decomp(j)
-                !#fates_py end do
+                end do
 
             end do
 #endif
diff --git a/components/elm/src/biogeochem/PhosphorusStateUpdate1Mod.F90 b/components/elm/src/biogeochem/PhosphorusStateUpdate1Mod.F90
index d5694e8f92..a23057b9b5 100644
--- a/components/elm/src/biogeochem/PhosphorusStateUpdate1Mod.F90
+++ b/components/elm/src/biogeochem/PhosphorusStateUpdate1Mod.F90
@@ -1,79 +1,54 @@
 module PhosphorusStateUpdate1Mod
-   !-----------------------------------------------------------------------
-   ! !DESCRIPTION:
-   ! Module for phosphorus state variable updates, non-mortality fluxes.
-   ! X.YANG
-   ! !USES:
-   use shr_kind_mod           , only: r8 => shr_kind_r8
-   use elm_varpar             , only : nlevdecomp, ndecomp_pools, ndecomp_cascade_transitions
-   use elm_varpar             , only : crop_prog, i_met_lit, i_cel_lit, i_lig_lit, i_cwd
-   use elm_varctl             , only : iulog
-   use pftvarcon              , only : npcropmin, nc3crop
-   use soilorder_varcon       , only : smax,ks_sorption
-   use VegetationPropertiesType         , only : veg_vp
-   use CNDecompCascadeConType , only : decomp_cascade_con
-   use CNStateType            , only : cnstate_type
-   use VegetationType              , only : veg_pp
-   use tracer_varcon          , only : is_active_betr_bgc
-   ! bgc interface & pflotran:
-   use elm_varctl             , only : use_pflotran, pf_cmode
-   use elm_varctl             , only : nu_com
-   ! forest fertilization experiment
-   use CNStateType            , only : fert_type , fert_continue, fert_dose, fert_start, fert_end
-   use elm_varctl             , only : forest_fert_exp
-   use elm_varctl             , only : NFIX_PTASE_plant
-   use decompMod              , only : bounds_type
-   use elm_varcon             , only : dzsoi_decomp
-   use elm_varctl             , only : use_fates
-   use GridcellDataType       , only : grc_ps, grc_pf
-   use ColumnDataType         , only : col_ps, col_pf
-   use VegetationDataType     , only : veg_ps, veg_pf
-   use timeInfoMod            , only : year_curr, mon_curr, day_curr, secs_curr 
-
-   
-   !
-   implicit none
-   save
-   private
-   !
-   ! !PUBLIC MEMBER FUNCTIONS:
-   public :: PhosphorusStateUpdateDynPatch
-   public :: PhosphorusStateUpdate_Phase1_col
-   public :: PhosphorusStateUpdate_Phase1_pft
-   public :: PhosphorusStateDynGridUpdate 
-
-   !-----------------------------------------------------------------------
-   
-   contains
-   
-   subroutine PhosphorusStateDynGridUpdate(bounds, dt)
-      !
-      ! !DESCRIPTION: 
-      ! Update gridcell P states based on fluxes from dyn_cnbal_patch 
-      ! !ARGUMENTS 
-      type(bounds_type), intent(in) :: bounds  
-      real(r8), intent(in) :: dt 
-      ! 
-      integer :: begg, endg 
-      integer :: g 
-      ! ! ! ! ! ! ! !
-      begg = bounds%begg; endg = bounds%endg 
-
-      !$acc parallel loop independent gang vector default(present)  
-      do g =begg, endg  
-         grc_ps%seedp(g) = grc_ps%seedp(g) &
-                 - grc_pf%dwt_seedp_to_leaf(g)     * dt &
-                 - grc_pf%dwt_seedp_to_deadstem(g) * dt &
-                 - grc_pf%dwt_seedp_to_ppool(g)    * dt
-      end do 
-   end subroutine PhosphorusStateDynGridUpdate
+  !-----------------------------------------------------------------------
+  ! !DESCRIPTION:
+  ! Module for phosphorus state variable updates, non-mortality fluxes.
+  ! X.YANG
+  ! !USES:
+  use shr_kind_mod           , only: r8 => shr_kind_r8
+  use elm_varpar             , only : nlevdecomp, ndecomp_pools, ndecomp_cascade_transitions
+  use elm_varpar             , only : crop_prog, i_met_lit, i_cel_lit, i_lig_lit, i_cwd
+  use elm_varctl             , only : iulog
+  use pftvarcon              , only : npcropmin, nc3crop
+  use soilorder_varcon       , only : smax,ks_sorption
+  use VegetationPropertiesType         , only : veg_vp
+  use CNDecompCascadeConType , only : decomp_cascade_con
+  use CNStateType            , only : cnstate_type
+  use VegetationType              , only : veg_pp
+  use tracer_varcon          , only : is_active_betr_bgc
+  ! bgc interface & pflotran:
+  use elm_varctl             , only : use_pflotran, pf_cmode
+  use elm_varctl             , only : nu_com
+  ! forest fertilization experiment
+  use clm_time_manager       , only : get_curr_date
+  use CNStateType            , only : fert_type , fert_continue, fert_dose, fert_start, fert_end
+  use elm_varctl             , only : forest_fert_exp
+  use elm_varctl             , only : NFIX_PTASE_plant
+  use decompMod              , only : bounds_type
+  use elm_varcon             , only : dzsoi_decomp
+  use elm_varctl             , only : use_fates
+  use GridcellDataType       , only : grc_ps, grc_pf
+  use ColumnDataType         , only : col_ps, col_pf
+  use VegetationDataType     , only : veg_ps, veg_pf
 
-  subroutine PhosphorusStateUpdateDynPatch(num_soilc_with_inactive,&
+  !
+  implicit none
+  save
+  private
+  !
+  ! !PUBLIC MEMBER FUNCTIONS:
+  public :: PhosphorusStateUpdateDynPatch
+  public :: PhosphorusStateUpdate1
+  !-----------------------------------------------------------------------
+
+contains
+  subroutine PhosphorusStateUpdateDynPatch(bounds, num_soilc_with_inactive,&
      filter_soilc_with_inactive, dt)
     !
     ! !DESCRIPTION:
     ! Update phosphorus states based on fluxes from dyn_cnbal_patch
+    !$acc routine seq
     ! !ARGUMENTS:
+    type(bounds_type)          , intent(in)    :: bounds
     integer                    , intent(in)    :: num_soilc_with_inactive       ! number of columns in soil filter
     integer                    , intent(in)    :: filter_soilc_with_inactive(:) ! soil column filter that includes inactive points
     !
@@ -81,191 +56,182 @@ module PhosphorusStateUpdate1Mod
     ! !LOCAL VARIABLES:
     integer                                    :: c                             ! column index
     integer                                    :: fc                            ! column filter index
+    integer                                    :: g                             ! gridcell index
     integer                                    :: j                             ! level index
 
     !-----------------------------------------------------------------------
-      !$acc parallel loop independent gang vector default(present) 
-      do fc = 1, num_soilc_with_inactive
-
-         c = filter_soilc_with_inactive(fc)
-         col_ps%prod10p(c) = col_ps%prod10p(c) + col_pf%dwt_prod10p_gain(c)*dt
-         col_ps%prod100p(c) = col_ps%prod100p(c) + col_pf%dwt_prod100p_gain(c)*dt
-         col_ps%prod1p(c) = col_ps%prod1p(c) + col_pf%dwt_crop_productp_gain(c)*dt            
-      end do 
-      
-      !$acc parallel loop independent gang vector collapse(2) default(present)
-      do j = 1,nlevdecomp
+
+      if (.not.use_fates) then
+
+         do g = bounds%begg, bounds%endg
+            grc_ps%seedp(g) = grc_ps%seedp(g) &
+                 - grc_pf%dwt_seedp_to_leaf(g)     * dt &
+                 - grc_pf%dwt_seedp_to_deadstem(g) * dt &
+                 - grc_pf%dwt_seedp_to_ppool(g)    * dt
+         end do
+
          do fc = 1, num_soilc_with_inactive
+
             c = filter_soilc_with_inactive(fc)
+            col_ps%prod10p(c) = col_ps%prod10p(c) + col_pf%dwt_prod10p_gain(c)*dt
+            col_ps%prod100p(c) = col_ps%prod100p(c) + col_pf%dwt_prod100p_gain(c)*dt
+            col_ps%prod1p(c) = col_ps%prod1p(c) + col_pf%dwt_crop_productp_gain(c)*dt            
+
+            do j = 1,nlevdecomp
 
-            col_ps%decomp_ppools_vr(c,j,i_met_lit) = col_ps%decomp_ppools_vr(c,j,i_met_lit) + &
-                  col_pf%dwt_frootp_to_litr_met_p(c,j) * dt
-            col_ps%decomp_ppools_vr(c,j,i_cel_lit) = col_ps%decomp_ppools_vr(c,j,i_cel_lit) + &
-                  col_pf%dwt_frootp_to_litr_cel_p(c,j) * dt
-            col_ps%decomp_ppools_vr(c,j,i_lig_lit) = col_ps%decomp_ppools_vr(c,j,i_lig_lit) + &
-                  col_pf%dwt_frootp_to_litr_lig_p(c,j) * dt
-            col_ps%decomp_ppools_vr(c,j,i_cwd) = col_ps%decomp_ppools_vr(c,j,i_cwd) + &
-                  ( col_pf%dwt_livecrootp_to_cwdp(c,j) + col_pf%dwt_deadcrootp_to_cwdp(c,j) ) * dt
+               col_ps%decomp_ppools_vr(c,j,i_met_lit) = col_ps%decomp_ppools_vr(c,j,i_met_lit) + &
+                    col_pf%dwt_frootp_to_litr_met_p(c,j) * dt
+               col_ps%decomp_ppools_vr(c,j,i_cel_lit) = col_ps%decomp_ppools_vr(c,j,i_cel_lit) + &
+                    col_pf%dwt_frootp_to_litr_cel_p(c,j) * dt
+               col_ps%decomp_ppools_vr(c,j,i_lig_lit) = col_ps%decomp_ppools_vr(c,j,i_lig_lit) + &
+                    col_pf%dwt_frootp_to_litr_lig_p(c,j) * dt
+               col_ps%decomp_ppools_vr(c,j,i_cwd) = col_ps%decomp_ppools_vr(c,j,i_cwd) + &
+                    ( col_pf%dwt_livecrootp_to_cwdp(c,j) + col_pf%dwt_deadcrootp_to_cwdp(c,j) ) * dt
 
+            end do
          end do
-      end do
+      end if
+
 
   end subroutine PhosphorusStateUpdateDynPatch
 
-   !-----------------------------------------------------------------------
-   subroutine PhosphorusStateUpdate_Phase1_col(num_soilc, filter_soilc, cnstate_vars, dt)
-      !
-      ! !DESCRIPTION:
-      ! On the radiation time step, update all the prognostic phosphorus state
-      ! variables (except for gap-phase mortality and fire fluxes)
-      !
-      ! !ARGUMENTS:
-      integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
-      integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
-      type(cnstate_type)       , intent(in)    :: cnstate_vars
-      !
-      real(r8)                 , intent(in)    :: dt !radiation time step
-      ! !LOCAL VARIABLES:
-      integer :: c,j,l,k ! indices
-      integer :: fc     ! lake filter indices
-      
-      integer:: kyr                     ! current year
-      integer:: kmo                     ! month of year  (1, ..., 12)
-      integer:: kda                     ! day of month   (1, ..., 31)
-      integer:: mcsec                   ! seconds of day (0, ..., seconds/day)
-      !-----------------------------------------------------------------------
-      
-      associate(                                                                                           &
+  !-----------------------------------------------------------------------
+  subroutine PhosphorusStateUpdate1(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+       cnstate_vars, dt)
+    !
+    ! !DESCRIPTION:
+    ! On the radiation time step, update all the prognostic phosphorus state
+    ! variables (except for gap-phase mortality and fire fluxes)
+    !
+    ! !ARGUMENTS:
+      !$acc routine seq
+    integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
+    integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    type(cnstate_type)       , intent(in)    :: cnstate_vars
+    !
+    real(r8)                 , intent(in)    :: dt !radiation time step
+    ! !LOCAL VARIABLES:
+    integer :: c,p,j,l,k ! indices
+    integer :: fp,fc     ! lake filter indices
+
+    integer:: kyr                     ! current year
+    integer:: kmo                     ! month of year  (1, ..., 12)
+    integer:: kda                     ! day of month   (1, ..., 31)
+    integer:: mcsec                   ! seconds of day (0, ..., seconds/day)
+    !-----------------------------------------------------------------------
+
+    associate(                                                                                           &
          ivt                   => veg_pp%itype                                , & ! Input:  [integer  (:)     ]  pft vegetation type
-         
+
          woody                 => veg_vp%woody                         , & ! Input:  [real(r8) (:)     ]  binary flag for woody lifeform (1=woody, 0=not woody)
-         
+
          cascade_donor_pool    => decomp_cascade_con%cascade_donor_pool    , & ! Input:  [integer  (:)     ]  which pool is C taken from for a given decomposition step
          cascade_receiver_pool => decomp_cascade_con%cascade_receiver_pool , & ! Input:  [integer  (:)     ]  which pool is C added to for a given decomposition step
-         
+
          !!! N deposition profile, will weathering profile be needed?  -X.YANG
          ndep_prof             => cnstate_vars%ndep_prof_col               & ! Input:  [real(r8) (:,:)   ]  profile over which N deposition is distributed through column (1/m)
          )
-         
-         
-         ! column-level fluxes
-         
-         !------------------------------------------------------------------
-         ! if coupled with pflotran, the following updates are NOT needed
-         ! if (.not.(use_pflotran .and. pf_cmode)) then
-         !------------------------------------------------------------------
-         if((.not.is_active_betr_bgc) )then
-            
-            if(.not.use_fates)then
-               !$acc parallel loop independent gang vector collapse(2) default(present) private(c)
-               do j = 1, nlevdecomp
-                  do fc = 1,num_soilc
-                     c = filter_soilc(fc)
-                     
-                     ! plant to litter fluxes
-                     ! phenology and dynamic landcover fluxes
-                     col_pf%decomp_ppools_sourcesink(c,j,i_met_lit) = &
-                     col_pf%phenology_p_to_litr_met_p(c,j) * dt
-                     
-                     col_pf%decomp_ppools_sourcesink(c,j,i_cel_lit) = &
-                     col_pf%phenology_p_to_litr_cel_p(c,j) * dt
-                     
-                     col_pf%decomp_ppools_sourcesink(c,j,i_lig_lit) = &
-                     col_pf%phenology_p_to_litr_lig_p(c,j) * dt
-                     
-                  end do
+
+
+      ! column-level fluxes
+
+      !------------------------------------------------------------------
+      ! if coupled with pflotran, the following updates are NOT needed
+      ! if (.not.(use_pflotran .and. pf_cmode)) then
+      !------------------------------------------------------------------
+      if((.not.is_active_betr_bgc) )then
+
+         if(.not.use_fates)then
+            do j = 1, nlevdecomp
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                  
+                  ! plant to litter fluxes
+                  ! phenology and dynamic landcover fluxes
+                  col_pf%decomp_ppools_sourcesink(c,j,i_met_lit) = &
+                       col_pf%phenology_p_to_litr_met_p(c,j) * dt
+                  
+                  col_pf%decomp_ppools_sourcesink(c,j,i_cel_lit) = &
+                       col_pf%phenology_p_to_litr_cel_p(c,j) * dt
+                  
+                  col_pf%decomp_ppools_sourcesink(c,j,i_lig_lit) = &
+                       col_pf%phenology_p_to_litr_lig_p(c,j) * dt
+                  
                end do
-            end if
-            
-            !$acc parallel loop independent gang worker default(present) collapse(2) private(c) 
-            ! decomposition fluxes
+            end do
+         end if
+
+      ! decomposition fluxes
+      do k = 1, ndecomp_cascade_transitions
+         do j = 1, nlevdecomp
+            ! column loop
+            do fc = 1,num_soilc
+               c = filter_soilc(fc)
+
+               col_pf%decomp_ppools_sourcesink(c,j,cascade_donor_pool(k)) = &
+                    col_pf%decomp_ppools_sourcesink(c,j,cascade_donor_pool(k)) - &
+                    col_pf%decomp_cascade_ptransfer_vr(c,j,k) * dt
+            end do
+         end do
+      end do
+      do k = 1, ndecomp_cascade_transitions
+         if ( cascade_receiver_pool(k) /= 0 ) then  ! skip terminal transitions
             do j = 1, nlevdecomp
                ! column loop
                do fc = 1,num_soilc
                   c = filter_soilc(fc)
-                  !$acc loop vector independent 
-                  do k = 1, ndecomp_cascade_transitions
-                     !$acc atomic update 
-                     col_pf%decomp_ppools_sourcesink(c,j,cascade_donor_pool(k)) = &
-                        col_pf%decomp_ppools_sourcesink(c,j,cascade_donor_pool(k)) - &
-                        col_pf%decomp_cascade_ptransfer_vr(c,j,k) * dt
-                     !$acc end atomic 
-                  end do
 
+                  col_pf%decomp_ppools_sourcesink(c,j,cascade_receiver_pool(k)) = &
+                       col_pf%decomp_ppools_sourcesink(c,j,cascade_receiver_pool(k)) + &
+                       (col_pf%decomp_cascade_ptransfer_vr(c,j,k) + col_pf%decomp_cascade_sminp_flux_vr(c,j,k)) * dt
                end do
             end do
-            
-            !$acc parallel loop independent gang worker collapse(2) default(present) 
+         else  ! terminal transitions
             do j = 1, nlevdecomp
                ! column loop
                do fc = 1,num_soilc
                   c = filter_soilc(fc)
-                  !$acc loop vector independent 
-                  do k = 1, ndecomp_cascade_transitions
-                     if ( cascade_receiver_pool(k) /= 0 ) then  ! skip terminal transitions
-                        !$acc atomic update                   
-                        col_pf%decomp_ppools_sourcesink(c,j,cascade_receiver_pool(k)) = &
-                           col_pf%decomp_ppools_sourcesink(c,j,cascade_receiver_pool(k)) + &
-                           (col_pf%decomp_cascade_ptransfer_vr(c,j,k) + col_pf%decomp_cascade_sminp_flux_vr(c,j,k)) * dt
-                        !$acc end atomic 
-                     else  ! terminal transitions
-                        !$acc atomic update 
-                        col_pf%decomp_ppools_sourcesink(c,j,cascade_donor_pool(k)) = &
-                           col_pf%decomp_ppools_sourcesink(c,j,cascade_donor_pool(k)) - &
-                           col_pf%decomp_cascade_sminp_flux_vr(c,j,k) * dt
-                        !$acc end atomic 
-                     end if
-                  end do
+                  col_pf%decomp_ppools_sourcesink(c,j,cascade_donor_pool(k)) = &
+                       col_pf%decomp_ppools_sourcesink(c,j,cascade_donor_pool(k)) - &
+                       col_pf%decomp_cascade_sminp_flux_vr(c,j,k) * dt
                end do
             end do
-
-         endif ! if (.not. is_active_betr_bgc))
-         !------------------------------------------------------------------
-         
-         ! forest fertilization
-         if (forest_fert_exp) then
-            kyr = year_curr; kmo = mon_curr; kda = day_curr; mcsec = secs_curr;
-            
-            do fc = 1,num_soilc
-               c = filter_soilc(fc)
-               ! fertilization assumed to occur at the begnining of each month
-               if ( ((fert_continue(c) == 1 .and. kyr > fert_start(c) .and. kyr <= fert_end(c)) .or.  kyr == fert_start(c)) &
-               .and. fert_type(c) == 2 .and. kda == 1  .and. mcsec == 1800) then
-                  do j = 1, nlevdecomp
-                     col_ps%solutionp_vr(c,j) = col_ps%solutionp_vr(c,j) + fert_dose(c,kmo)*ndep_prof(c,j)
-                  end do
-               end if
-            end do
          end if
-         
-         
-      end associate
-         
-   end subroutine PhosphorusStateUpdate_Phase1_col
-      
-      subroutine PhosphorusStateUpdate_Phase1_pft(num_soilp, filter_soilp, dt)
-         implicit none 
-         integer  , intent(in)    :: num_soilp       ! number of soil patches in filter
-         integer  , intent(in)    :: filter_soilp(:) ! filter for soil patches
-         real(r8) , intent(in)    :: dt 
-         !
-         integer :: fp ,p 
-         associate(    &
-            ivt                   => veg_pp%itype        , & ! Input:  [integer  (:)     ]  pft vegetation type
-            woody                 => veg_vp%woody          & ! Input:  [real(r8) (:)     ]  binary flag for woody lifeform (1=woody, 0=not woody)
-            )
-            ! patch loop (veg)
-            !$acc parallel loop independent gang vector default(present) private(p) 
-            do fp = 1,num_soilp
-               p = filter_soilp(fp)
-               
-               ! phenology: transfer growth fluxes
-               veg_ps%leafp(p)       = veg_ps%leafp(p)       + veg_pf%leafp_xfer_to_leafp(p)*dt
-               veg_ps%leafp_xfer(p)  = veg_ps%leafp_xfer(p)  - veg_pf%leafp_xfer_to_leafp(p)*dt
-               veg_ps%frootp(p)      = veg_ps%frootp(p)      + veg_pf%frootp_xfer_to_frootp(p)*dt
-               veg_ps%frootp_xfer(p) = veg_ps%frootp_xfer(p) - veg_pf%frootp_xfer_to_frootp(p)*dt
-               
-               if (woody(ivt(p)) == 1.0_r8) then
+      end do
+      endif ! if (.not. is_active_betr_bgc))
+      !------------------------------------------------------------------
+
+      ! forest fertilization
+      call get_curr_date(kyr, kmo, kda, mcsec)
+      if (forest_fert_exp) then
+         do fc = 1,num_soilc
+            c = filter_soilc(fc)
+            if ( ((fert_continue(c) == 1 .and. kyr > fert_start(c) .and. kyr <= fert_end(c)) .or.  kyr == fert_start(c)) &
+               .and. fert_type(c) == 2 &
+               .and. kda == 1  .and. mcsec == 1800) then ! fertilization assumed to occur at the begnining of each month
+               do j = 1, nlevdecomp
+                  col_ps%solutionp_vr(c,j) = col_ps%solutionp_vr(c,j) + fert_dose(c,kmo)*ndep_prof(c,j)
+               end do
+            end if
+         end do
+      end if
+
+      if(.not.use_fates)then
+
+          ! patch loop (veg)
+
+          do fp = 1,num_soilp
+              p = filter_soilp(fp)
+
+              ! phenology: transfer growth fluxes
+              veg_ps%leafp(p)       = veg_ps%leafp(p)       + veg_pf%leafp_xfer_to_leafp(p)*dt
+              veg_ps%leafp_xfer(p)  = veg_ps%leafp_xfer(p)  - veg_pf%leafp_xfer_to_leafp(p)*dt
+              veg_ps%frootp(p)      = veg_ps%frootp(p)      + veg_pf%frootp_xfer_to_frootp(p)*dt
+              veg_ps%frootp_xfer(p) = veg_ps%frootp_xfer(p) - veg_pf%frootp_xfer_to_frootp(p)*dt
+
+              if (woody(ivt(p)) == 1.0_r8) then
                   veg_ps%livestemp(p)       = veg_ps%livestemp(p)       + veg_pf%livestemp_xfer_to_livestemp(p)*dt
                   veg_ps%livestemp_xfer(p)  = veg_ps%livestemp_xfer(p)  - veg_pf%livestemp_xfer_to_livestemp(p)*dt
                   veg_ps%deadstemp(p)       = veg_ps%deadstemp(p)       + veg_pf%deadstemp_xfer_to_deadstemp(p)*dt
@@ -274,24 +240,24 @@ module PhosphorusStateUpdate1Mod
                   veg_ps%livecrootp_xfer(p) = veg_ps%livecrootp_xfer(p) - veg_pf%livecrootp_xfer_to_livecrootp(p)*dt
                   veg_ps%deadcrootp(p)      = veg_ps%deadcrootp(p)      + veg_pf%deadcrootp_xfer_to_deadcrootp(p)*dt
                   veg_ps%deadcrootp_xfer(p) = veg_ps%deadcrootp_xfer(p) - veg_pf%deadcrootp_xfer_to_deadcrootp(p)*dt
-               end if
-               
-               if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+              end if
+
+              if (ivt(p) >= npcropmin) then ! skip 2 generic crops
                   ! lines here for consistency; the transfer terms are zero
                   veg_ps%livestemp(p)       = veg_ps%livestemp(p)      + veg_pf%livestemp_xfer_to_livestemp(p)*dt
                   veg_ps%livestemp_xfer(p)  = veg_ps%livestemp_xfer(p) - veg_pf%livestemp_xfer_to_livestemp(p)*dt
                   veg_ps%grainp(p)          = veg_ps%grainp(p)         + veg_pf%grainp_xfer_to_grainp(p)*dt
                   veg_ps%grainp_xfer(p)     = veg_ps%grainp_xfer(p)    - veg_pf%grainp_xfer_to_grainp(p)*dt
-               end if
-               
-               ! phenology: litterfall and retranslocation fluxes
-               veg_ps%leafp(p)    = veg_ps%leafp(p)    - veg_pf%leafp_to_litter(p)*dt
-               veg_ps%frootp(p)   = veg_ps%frootp(p)   - veg_pf%frootp_to_litter(p)*dt
-               veg_ps%leafp(p)    = veg_ps%leafp(p)    - veg_pf%leafp_to_retransp(p)*dt
-               veg_ps%retransp(p) = veg_ps%retransp(p) + veg_pf%leafp_to_retransp(p)*dt
-               
-               ! live wood turnover and retranslocation fluxes
-               if (woody(ivt(p)) == 1._r8) then
+              end if
+
+              ! phenology: litterfall and retranslocation fluxes
+              veg_ps%leafp(p)    = veg_ps%leafp(p)    - veg_pf%leafp_to_litter(p)*dt
+              veg_ps%frootp(p)   = veg_ps%frootp(p)   - veg_pf%frootp_to_litter(p)*dt
+              veg_ps%leafp(p)    = veg_ps%leafp(p)    - veg_pf%leafp_to_retransp(p)*dt
+              veg_ps%retransp(p) = veg_ps%retransp(p) + veg_pf%leafp_to_retransp(p)*dt
+
+              ! live wood turnover and retranslocation fluxes
+              if (woody(ivt(p)) == 1._r8) then
                   veg_ps%livestemp(p)  = veg_ps%livestemp(p)  - veg_pf%livestemp_to_deadstemp(p)*dt
                   veg_ps%deadstemp(p)  = veg_ps%deadstemp(p)  + veg_pf%livestemp_to_deadstemp(p)*dt
                   veg_ps%livestemp(p)  = veg_ps%livestemp(p)  - veg_pf%livestemp_to_retransp(p)*dt
@@ -300,39 +266,40 @@ module PhosphorusStateUpdate1Mod
                   veg_ps%deadcrootp(p) = veg_ps%deadcrootp(p) + veg_pf%livecrootp_to_deadcrootp(p)*dt
                   veg_ps%livecrootp(p) = veg_ps%livecrootp(p) - veg_pf%livecrootp_to_retransp(p)*dt
                   veg_ps%retransp(p)   = veg_ps%retransp(p)   + veg_pf%livecrootp_to_retransp(p)*dt
-               end if
-               if (ivt(p) >= npcropmin) then ! Beth adds retrans from froot
+              end if
+              if (ivt(p) >= npcropmin) then ! Beth adds retrans from froot
                   veg_ps%frootp(p)     = veg_ps%frootp(p)     - veg_pf%frootp_to_retransp(p)*dt
                   veg_ps%retransp(p)   = veg_ps%retransp(p)   + veg_pf%frootp_to_retransp(p)*dt
                   veg_ps%livestemp(p)  = veg_ps%livestemp(p)  - veg_pf%livestemp_to_litter(p)*dt
                   veg_ps%livestemp(p)  = veg_ps%livestemp(p)  - veg_pf%livestemp_to_retransp(p)*dt
                   veg_ps%retransp(p)   = veg_ps%retransp(p)   + veg_pf%livestemp_to_retransp(p)*dt
                   veg_ps%grainp(p)     = veg_ps%grainp(p)     - veg_pf%grainp_to_food(p)*dt
-                  
+
                   veg_ps%cropseedp_deficit(p) = veg_ps%cropseedp_deficit(p) &
-                     - veg_pf%crop_seedp_to_leaf(p) * dt
-               end if
-               
-               ! uptake from soil mineral N pool
-               veg_ps%ppool(p) = veg_ps%ppool(p) + veg_pf%sminp_to_ppool(p)*dt
-               if (nu_com .ne. 'RD') veg_ps%ppool(p) = veg_ps%ppool(p) + veg_pf%supplement_to_plantp(p)*dt
-               if (NFIX_PTASE_plant) veg_ps%ppool(p) = veg_ps%ppool(p) + veg_pf%biochem_pmin_to_plant(p)*dt
-               
-               ! deployment from retranslocation pool
-               veg_ps%ppool(p)    = veg_ps%ppool(p)    + veg_pf%retransp_to_ppool(p)*dt
-               veg_ps%retransp(p) = veg_ps%retransp(p) - veg_pf%retransp_to_ppool(p)*dt
-               
-               ! allocation fluxes
-               veg_ps%ppool(p)           = veg_ps%ppool(p)          - veg_pf%ppool_to_leafp(p)*dt
-               veg_ps%leafp(p)           = veg_ps%leafp(p)          + veg_pf%ppool_to_leafp(p)*dt
-               veg_ps%ppool(p)           = veg_ps%ppool(p)          - veg_pf%ppool_to_leafp_storage(p)*dt
-               veg_ps%leafp_storage(p)   = veg_ps%leafp_storage(p)  + veg_pf%ppool_to_leafp_storage(p)*dt
-               veg_ps%ppool(p)           = veg_ps%ppool(p)          - veg_pf%ppool_to_frootp(p)*dt
-               veg_ps%frootp(p)          = veg_ps%frootp(p)         + veg_pf%ppool_to_frootp(p)*dt
-               veg_ps%ppool(p)           = veg_ps%ppool(p)          - veg_pf%ppool_to_frootp_storage(p)*dt
-               veg_ps%frootp_storage(p)  = veg_ps%frootp_storage(p) + veg_pf%ppool_to_frootp_storage(p)*dt
-               
-               if (woody(ivt(p)) == 1._r8) then
+                        - veg_pf%crop_seedp_to_leaf(p) * dt
+              end if
+
+              ! uptake from soil mineral N pool
+              veg_ps%ppool(p) = &
+                    veg_ps%ppool(p) + veg_pf%sminp_to_ppool(p)*dt
+              if (nu_com .ne. 'RD') veg_ps%ppool(p) = veg_ps%ppool(p) + veg_pf%supplement_to_plantp(p)*dt
+              if (NFIX_PTASE_plant) veg_ps%ppool(p) = veg_ps%ppool(p) + veg_pf%biochem_pmin_to_plant(p)*dt
+
+              ! deployment from retranslocation pool
+              veg_ps%ppool(p)    = veg_ps%ppool(p)    + veg_pf%retransp_to_ppool(p)*dt
+              veg_ps%retransp(p) = veg_ps%retransp(p) - veg_pf%retransp_to_ppool(p)*dt
+
+              ! allocation fluxes
+              veg_ps%ppool(p)           = veg_ps%ppool(p)          - veg_pf%ppool_to_leafp(p)*dt
+              veg_ps%leafp(p)           = veg_ps%leafp(p)          + veg_pf%ppool_to_leafp(p)*dt
+              veg_ps%ppool(p)           = veg_ps%ppool(p)          - veg_pf%ppool_to_leafp_storage(p)*dt
+              veg_ps%leafp_storage(p)   = veg_ps%leafp_storage(p)  + veg_pf%ppool_to_leafp_storage(p)*dt
+              veg_ps%ppool(p)           = veg_ps%ppool(p)          - veg_pf%ppool_to_frootp(p)*dt
+              veg_ps%frootp(p)          = veg_ps%frootp(p)         + veg_pf%ppool_to_frootp(p)*dt
+              veg_ps%ppool(p)           = veg_ps%ppool(p)          - veg_pf%ppool_to_frootp_storage(p)*dt
+              veg_ps%frootp_storage(p)  = veg_ps%frootp_storage(p) + veg_pf%ppool_to_frootp_storage(p)*dt
+
+              if (woody(ivt(p)) == 1._r8) then
                   veg_ps%ppool(p)              = veg_ps%ppool(p)              - veg_pf%ppool_to_livestemp(p)*dt
                   veg_ps%livestemp(p)          = veg_ps%livestemp(p)          + veg_pf%ppool_to_livestemp(p)*dt
                   veg_ps%ppool(p)              = veg_ps%ppool(p)              - veg_pf%ppool_to_livestemp_storage(p)*dt
@@ -349,9 +316,9 @@ module PhosphorusStateUpdate1Mod
                   veg_ps%deadcrootp(p)         = veg_ps%deadcrootp(p)         + veg_pf%ppool_to_deadcrootp(p)*dt
                   veg_ps%ppool(p)              = veg_ps%ppool(p)              - veg_pf%ppool_to_deadcrootp_storage(p)*dt
                   veg_ps%deadcrootp_storage(p) = veg_ps%deadcrootp_storage(p) + veg_pf%ppool_to_deadcrootp_storage(p)*dt
-               end if
-               
-               if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+              end if
+
+              if (ivt(p) >= npcropmin) then ! skip 2 generic crops
                   veg_ps%ppool(p)              = veg_ps%ppool(p)              - veg_pf%ppool_to_livestemp(p)*dt
                   veg_ps%livestemp(p)          = veg_ps%livestemp(p)          + veg_pf%ppool_to_livestemp(p)*dt
                   veg_ps%ppool(p)              = veg_ps%ppool(p)              - veg_pf%ppool_to_livestemp_storage(p)*dt
@@ -360,15 +327,15 @@ module PhosphorusStateUpdate1Mod
                   veg_ps%grainp(p)             = veg_ps%grainp(p)             + veg_pf%ppool_to_grainp(p)*dt
                   veg_ps%ppool(p)              = veg_ps%ppool(p)              - veg_pf%ppool_to_grainp_storage(p)*dt
                   veg_ps%grainp_storage(p)     = veg_ps%grainp_storage(p)     + veg_pf%ppool_to_grainp_storage(p)*dt
-               end if
-               
-               ! move storage pools into transfer pools
-               veg_ps%leafp_storage(p)  = veg_ps%leafp_storage(p)  - veg_pf%leafp_storage_to_xfer(p)*dt
-               veg_ps%leafp_xfer(p)     = veg_ps%leafp_xfer(p)     + veg_pf%leafp_storage_to_xfer(p)*dt
-               veg_ps%frootp_storage(p) = veg_ps%frootp_storage(p) - veg_pf%frootp_storage_to_xfer(p)*dt
-               veg_ps%frootp_xfer(p)    = veg_ps%frootp_xfer(p)    + veg_pf%frootp_storage_to_xfer(p)*dt
-               
-               if (woody(ivt(p)) == 1._r8) then
+              end if
+
+              ! move storage pools into transfer pools
+              veg_ps%leafp_storage(p)  = veg_ps%leafp_storage(p)  - veg_pf%leafp_storage_to_xfer(p)*dt
+              veg_ps%leafp_xfer(p)     = veg_ps%leafp_xfer(p)     + veg_pf%leafp_storage_to_xfer(p)*dt
+              veg_ps%frootp_storage(p) = veg_ps%frootp_storage(p) - veg_pf%frootp_storage_to_xfer(p)*dt
+              veg_ps%frootp_xfer(p)    = veg_ps%frootp_xfer(p)    + veg_pf%frootp_storage_to_xfer(p)*dt
+
+              if (woody(ivt(p)) == 1._r8) then
                   veg_ps%livestemp_storage(p)  = veg_ps%livestemp_storage(p)  - veg_pf%livestemp_storage_to_xfer(p)*dt
                   veg_ps%livestemp_xfer(p)     = veg_ps%livestemp_xfer(p)     + veg_pf%livestemp_storage_to_xfer(p)*dt
                   veg_ps%deadstemp_storage(p)  = veg_ps%deadstemp_storage(p)  - veg_pf%deadstemp_storage_to_xfer(p)*dt
@@ -377,22 +344,21 @@ module PhosphorusStateUpdate1Mod
                   veg_ps%livecrootp_xfer(p)    = veg_ps%livecrootp_xfer(p)    + veg_pf%livecrootp_storage_to_xfer(p)*dt
                   veg_ps%deadcrootp_storage(p) = veg_ps%deadcrootp_storage(p) - veg_pf%deadcrootp_storage_to_xfer(p)*dt
                   veg_ps%deadcrootp_xfer(p)    = veg_ps%deadcrootp_xfer(p)    + veg_pf%deadcrootp_storage_to_xfer(p)*dt
-               end if
-               
-               if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+              end if
+
+              if (ivt(p) >= npcropmin) then ! skip 2 generic crops
                   ! lines here for consistency; the transfer terms are zero
                   veg_ps%livestemp_storage(p)  = veg_ps%livestemp_storage(p) - veg_pf%livestemp_storage_to_xfer(p)*dt
                   veg_ps%livestemp_xfer(p)     = veg_ps%livestemp_xfer(p)    + veg_pf%livestemp_storage_to_xfer(p)*dt
                   veg_ps%grainp_storage(p)     = veg_ps%grainp_storage(p)    - veg_pf%grainp_storage_to_xfer(p)*dt
                   veg_ps%grainp_xfer(p)        = veg_ps%grainp_xfer(p)       + veg_pf%grainp_storage_to_xfer(p)*dt
-               end if
-               
-            end do ! num_soilp
+              end if
+
+          end do ! num_soilp
+      end if  !if(.not.use_fates)
+
+    end associate
 
-         end associate
+  end subroutine PhosphorusStateUpdate1
 
-      end subroutine PhosphorusStateUpdate_Phase1_pft
-      
-      
-   end module PhosphorusStateUpdate1Mod
-   
+end module PhosphorusStateUpdate1Mod
diff --git a/components/elm/src/biogeochem/PhosphorusStateUpdate2Mod.F90 b/components/elm/src/biogeochem/PhosphorusStateUpdate2Mod.F90
index e1f01df6d7..2385083451 100644
--- a/components/elm/src/biogeochem/PhosphorusStateUpdate2Mod.F90
+++ b/components/elm/src/biogeochem/PhosphorusStateUpdate2Mod.F90
@@ -9,6 +9,8 @@ module PhosphorusStateUpdate2Mod
   use elm_varpar          , only : nlevsoi, nlevdecomp
   use elm_varpar          , only : i_met_lit, i_cel_lit, i_lig_lit, i_cwd
   use elm_varctl          , only : iulog
+  !use PhosphorusStateType , only : phosphorusstate_type
+  !use PhosphorusFLuxType  , only : phosphorusflux_type
   use VegetationType           , only : veg_pp
   use pftvarcon           , only : npcropmin
   use tracer_varcon       , only : is_active_betr_bgc
@@ -17,7 +19,6 @@ module PhosphorusStateUpdate2Mod
   use ColumnDataType      , only : col_ps, col_pf
   use VegetationDataType  , only : veg_ps, veg_pf
   !
-  use timeInfoMod , only : dtime_mod
   implicit none
   save
   private
@@ -30,7 +31,7 @@ module PhosphorusStateUpdate2Mod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine PhosphorusStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp )
+  subroutine PhosphorusStateUpdate2(num_soilc, filter_soilc, num_soilp, filter_soilp, dt)
     !
     ! !DESCRIPTION:
     ! On the radiation time step, update all the prognostic phosporus state
@@ -39,36 +40,39 @@ contains
     ! no science equations. This increases readability and maintainability
     !
     ! !ARGUMENTS:
+      !$acc routine seq
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
     integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
     integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    real(r8), intent(in) :: dt      ! radiation time step (seconds)
+
     !
     ! !LOCAL VARIABLES:
     integer  :: c,p,j,l ! indices
     integer  :: fp,fc   ! lake filter indices
     !-----------------------------------------------------------------------
-    !------------------------------------------------------------------
-    ! if coupled with pflotran, the following updates are NOT needed
-    ! if (.not.(use_pflotran .and. pf_cmode)) then
-    !------------------------------------------------------------------
+
+
+      !------------------------------------------------------------------
+      ! if coupled with pflotran, the following updates are NOT needed
+!      if (.not.(use_pflotran .and. pf_cmode)) then
+      !------------------------------------------------------------------
 
       ! column-level phosporus fluxes from gap-phase mortality
       if (.not. is_active_betr_bgc) then
-      !$acc parallel loop independent gang default(present)
       do j = 1, nlevdecomp
-         !$acc loop vector independent
          do fc = 1,num_soilc
             c = filter_soilc(fc)
 
             col_ps%decomp_ppools_vr(c,j,i_met_lit) = &
-                 col_ps%decomp_ppools_vr(c,j,i_met_lit) + col_pf%gap_mortality_p_to_litr_met_p(c,j) * dtime_mod
+                 col_ps%decomp_ppools_vr(c,j,i_met_lit) + col_pf%gap_mortality_p_to_litr_met_p(c,j) * dt
             col_ps%decomp_ppools_vr(c,j,i_cel_lit) = &
-                 col_ps%decomp_ppools_vr(c,j,i_cel_lit) + col_pf%gap_mortality_p_to_litr_cel_p(c,j) * dtime_mod
+                 col_ps%decomp_ppools_vr(c,j,i_cel_lit) + col_pf%gap_mortality_p_to_litr_cel_p(c,j) * dt
             col_ps%decomp_ppools_vr(c,j,i_lig_lit) = &
-                 col_ps%decomp_ppools_vr(c,j,i_lig_lit) + col_pf%gap_mortality_p_to_litr_lig_p(c,j) * dtime_mod
+                 col_ps%decomp_ppools_vr(c,j,i_lig_lit) + col_pf%gap_mortality_p_to_litr_lig_p(c,j) * dt
             col_ps%decomp_ppools_vr(c,j,i_cwd)     = &
-                 col_ps%decomp_ppools_vr(c,j,i_cwd)     + col_pf%gap_mortality_p_to_cwdp(c,j)       * dtime_mod
+                 col_ps%decomp_ppools_vr(c,j,i_cwd)     + col_pf%gap_mortality_p_to_cwdp(c,j)       * dt
          end do
       end do
       endif ! if (.not.is_active_betr_bgc))
@@ -76,42 +80,41 @@ contains
 
       ! patch -level phosporus fluxes from gap-phase mortality
 
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_soilp
          p = filter_soilp(fp)
 
          ! displayed pools
-         veg_ps%leafp(p)              =  veg_ps%leafp(p)      - veg_pf%m_leafp_to_litter(p)      * dtime_mod
-         veg_ps%frootp(p)             =  veg_ps%frootp(p)     - veg_pf%m_frootp_to_litter(p)     * dtime_mod
-         veg_ps%livestemp(p)          =  veg_ps%livestemp(p)  - veg_pf%m_livestemp_to_litter(p)  * dtime_mod
-         veg_ps%deadstemp(p)          =  veg_ps%deadstemp(p)  - veg_pf%m_deadstemp_to_litter(p)  * dtime_mod
-         veg_ps%livecrootp(p)         =  veg_ps%livecrootp(p) - veg_pf%m_livecrootp_to_litter(p) * dtime_mod
-         veg_ps%deadcrootp(p)         =  veg_ps%deadcrootp(p) - veg_pf%m_deadcrootp_to_litter(p) * dtime_mod
-         veg_ps%retransp(p)           =  veg_ps%retransp(p)   - veg_pf%m_retransp_to_litter(p)   * dtime_mod
-         veg_ps%ppool(p)              =  veg_ps%ppool(p)      - veg_pf%m_ppool_to_litter(p)   * dtime_mod
+         veg_ps%leafp(p)              =  veg_ps%leafp(p)      - veg_pf%m_leafp_to_litter(p)      * dt
+         veg_ps%frootp(p)             =  veg_ps%frootp(p)     - veg_pf%m_frootp_to_litter(p)     * dt
+         veg_ps%livestemp(p)          =  veg_ps%livestemp(p)  - veg_pf%m_livestemp_to_litter(p)  * dt
+         veg_ps%deadstemp(p)          =  veg_ps%deadstemp(p)  - veg_pf%m_deadstemp_to_litter(p)  * dt
+         veg_ps%livecrootp(p)         =  veg_ps%livecrootp(p) - veg_pf%m_livecrootp_to_litter(p) * dt
+         veg_ps%deadcrootp(p)         =  veg_ps%deadcrootp(p) - veg_pf%m_deadcrootp_to_litter(p) * dt
+         veg_ps%retransp(p)           =  veg_ps%retransp(p)   - veg_pf%m_retransp_to_litter(p)   * dt
+         veg_ps%ppool(p)              =  veg_ps%ppool(p)      - veg_pf%m_ppool_to_litter(p)   * dt
 
          ! storage pools
-         veg_ps%leafp_storage(p)      =  veg_ps%leafp_storage(p)      - veg_pf%m_leafp_storage_to_litter(p)      * dtime_mod
-         veg_ps%frootp_storage(p)     =  veg_ps%frootp_storage(p)     - veg_pf%m_frootp_storage_to_litter(p)     * dtime_mod
-         veg_ps%livestemp_storage(p)  =  veg_ps%livestemp_storage(p)  - veg_pf%m_livestemp_storage_to_litter(p)  * dtime_mod
-         veg_ps%deadstemp_storage(p)  =  veg_ps%deadstemp_storage(p)  - veg_pf%m_deadstemp_storage_to_litter(p)  * dtime_mod
-         veg_ps%livecrootp_storage(p) =  veg_ps%livecrootp_storage(p) - veg_pf%m_livecrootp_storage_to_litter(p) * dtime_mod
-         veg_ps%deadcrootp_storage(p) =  veg_ps%deadcrootp_storage(p) - veg_pf%m_deadcrootp_storage_to_litter(p) * dtime_mod
+         veg_ps%leafp_storage(p)      =  veg_ps%leafp_storage(p)      - veg_pf%m_leafp_storage_to_litter(p)      * dt
+         veg_ps%frootp_storage(p)     =  veg_ps%frootp_storage(p)     - veg_pf%m_frootp_storage_to_litter(p)     * dt
+         veg_ps%livestemp_storage(p)  =  veg_ps%livestemp_storage(p)  - veg_pf%m_livestemp_storage_to_litter(p)  * dt
+         veg_ps%deadstemp_storage(p)  =  veg_ps%deadstemp_storage(p)  - veg_pf%m_deadstemp_storage_to_litter(p)  * dt
+         veg_ps%livecrootp_storage(p) =  veg_ps%livecrootp_storage(p) - veg_pf%m_livecrootp_storage_to_litter(p) * dt
+         veg_ps%deadcrootp_storage(p) =  veg_ps%deadcrootp_storage(p) - veg_pf%m_deadcrootp_storage_to_litter(p) * dt
 
          ! transfer pools
-         veg_ps%leafp_xfer(p)         =  veg_ps%leafp_xfer(p)      - veg_pf%m_leafp_xfer_to_litter(p)      * dtime_mod
-         veg_ps%frootp_xfer(p)        =  veg_ps%frootp_xfer(p)     - veg_pf%m_frootp_xfer_to_litter(p)     * dtime_mod
-         veg_ps%livestemp_xfer(p)     =  veg_ps%livestemp_xfer(p)  - veg_pf%m_livestemp_xfer_to_litter(p)  * dtime_mod
-         veg_ps%deadstemp_xfer(p)     =  veg_ps%deadstemp_xfer(p)  - veg_pf%m_deadstemp_xfer_to_litter(p)  * dtime_mod
-         veg_ps%livecrootp_xfer(p)    =  veg_ps%livecrootp_xfer(p) - veg_pf%m_livecrootp_xfer_to_litter(p) * dtime_mod
-         veg_ps%deadcrootp_xfer(p)    =  veg_ps%deadcrootp_xfer(p) - veg_pf%m_deadcrootp_xfer_to_litter(p) * dtime_mod
+         veg_ps%leafp_xfer(p)         =  veg_ps%leafp_xfer(p)      - veg_pf%m_leafp_xfer_to_litter(p)      * dt
+         veg_ps%frootp_xfer(p)        =  veg_ps%frootp_xfer(p)     - veg_pf%m_frootp_xfer_to_litter(p)     * dt
+         veg_ps%livestemp_xfer(p)     =  veg_ps%livestemp_xfer(p)  - veg_pf%m_livestemp_xfer_to_litter(p)  * dt
+         veg_ps%deadstemp_xfer(p)     =  veg_ps%deadstemp_xfer(p)  - veg_pf%m_deadstemp_xfer_to_litter(p)  * dt
+         veg_ps%livecrootp_xfer(p)    =  veg_ps%livecrootp_xfer(p) - veg_pf%m_livecrootp_xfer_to_litter(p) * dt
+         veg_ps%deadcrootp_xfer(p)    =  veg_ps%deadcrootp_xfer(p) - veg_pf%m_deadcrootp_xfer_to_litter(p) * dt
 
       end do
 
   end subroutine PhosphorusStateUpdate2
 
   !-----------------------------------------------------------------------
-  subroutine PhosphorusStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp )
+  subroutine PhosphorusStateUpdate2h(num_soilc, filter_soilc, num_soilp, filter_soilp, dt)
     !
     ! !DESCRIPTION:
     ! Update all the prognostic phosphorus state
@@ -120,10 +123,15 @@ contains
     ! no science equations. This increases readability and maintainability
     !
     ! !ARGUMENTS:
+      !$acc routine seq
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
     integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
     integer                  , intent(in)    :: filter_soilp(:) ! filter for soil patches
+    !type(phosphorusflux_type)  , intent(in)    :: phosphorusflux_vars
+    !type(phosphorusstate_type) , intent(inout) :: phosphorusstate_vars
+    real(r8),     intent(in)     :: dt      ! radiation time step (seconds)
+
     !
     ! !LOCAL VARIABLES:
     integer :: c,p,j,l ! indices
@@ -132,6 +140,7 @@ contains
 
     associate(                      &
          ivt => veg_pp%itype            & ! Input:  [integer  (:) ]  pft vegetation type
+
          )
 
       !------------------------------------------------------------------
@@ -141,19 +150,17 @@ contains
 
       ! column-level phosporus fluxes from harvest mortality
 
-      !$acc parallel loop independent gang default(present)
       do j = 1,nlevdecomp
-         !$acc loop independent vector
          do fc = 1,num_soilc
             c = filter_soilc(fc)
             col_ps%decomp_ppools_vr(c,j,i_met_lit) = &
-                 col_ps%decomp_ppools_vr(c,j,i_met_lit) + col_pf%harvest_p_to_litr_met_p(c,j) * dtime_mod
+                 col_ps%decomp_ppools_vr(c,j,i_met_lit) + col_pf%harvest_p_to_litr_met_p(c,j) * dt
             col_ps%decomp_ppools_vr(c,j,i_cel_lit) = &
-                 col_ps%decomp_ppools_vr(c,j,i_cel_lit) + col_pf%harvest_p_to_litr_cel_p(c,j) * dtime_mod
+                 col_ps%decomp_ppools_vr(c,j,i_cel_lit) + col_pf%harvest_p_to_litr_cel_p(c,j) * dt
             col_ps%decomp_ppools_vr(c,j,i_lig_lit) = &
-                 col_ps%decomp_ppools_vr(c,j,i_lig_lit) + col_pf%harvest_p_to_litr_lig_p(c,j) * dtime_mod
+                 col_ps%decomp_ppools_vr(c,j,i_lig_lit) + col_pf%harvest_p_to_litr_lig_p(c,j) * dt
             col_ps%decomp_ppools_vr(c,j,i_cwd)     = &
-                 col_ps%decomp_ppools_vr(c,j,i_cwd)     + col_pf%harvest_p_to_cwdp(c,j)       * dtime_mod
+                 col_ps%decomp_ppools_vr(c,j,i_cwd)     + col_pf%harvest_p_to_cwdp(c,j)       * dt
          end do
       end do
       endif ! if (.not.(use_pflotran .and. pf_cmode))
@@ -161,42 +168,41 @@ contains
 
       ! patch-level phosporus fluxes from harvest mortality
 
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_soilp
          p = filter_soilp(fp)
 
          ! displayed pools
-         veg_ps%leafp(p)      = veg_ps%leafp(p)      - veg_pf%hrv_leafp_to_litter(p)      * dtime_mod
-         veg_ps%frootp(p)     = veg_ps%frootp(p)     - veg_pf%hrv_frootp_to_litter(p)     * dtime_mod
-         veg_ps%livestemp(p)  = veg_ps%livestemp(p)  - veg_pf%hrv_livestemp_to_litter(p)  * dtime_mod
-         veg_ps%deadstemp(p)  = veg_ps%deadstemp(p)  - veg_pf%hrv_deadstemp_to_prod10p(p) * dtime_mod
-         veg_ps%deadstemp(p)  = veg_ps%deadstemp(p)  - veg_pf%hrv_deadstemp_to_prod100p(p)* dtime_mod
-         veg_ps%livecrootp(p) = veg_ps%livecrootp(p) - veg_pf%hrv_livecrootp_to_litter(p) * dtime_mod
-         veg_ps%deadcrootp(p) = veg_ps%deadcrootp(p) - veg_pf%hrv_deadcrootp_to_litter(p) * dtime_mod
-         veg_ps%retransp(p)   = veg_ps%retransp(p)   - veg_pf%hrv_retransp_to_litter(p)   * dtime_mod
-         veg_ps%ppool(p)      = veg_ps%ppool(p)      - veg_pf%hrv_ppool_to_litter(p)      * dtime_mod
+         veg_ps%leafp(p)      = veg_ps%leafp(p)      - veg_pf%hrv_leafp_to_litter(p)      * dt
+         veg_ps%frootp(p)     = veg_ps%frootp(p)     - veg_pf%hrv_frootp_to_litter(p)     * dt
+         veg_ps%livestemp(p)  = veg_ps%livestemp(p)  - veg_pf%hrv_livestemp_to_litter(p)  * dt
+         veg_ps%deadstemp(p)  = veg_ps%deadstemp(p)  - veg_pf%hrv_deadstemp_to_prod10p(p) * dt
+         veg_ps%deadstemp(p)  = veg_ps%deadstemp(p)  - veg_pf%hrv_deadstemp_to_prod100p(p)* dt
+         veg_ps%livecrootp(p) = veg_ps%livecrootp(p) - veg_pf%hrv_livecrootp_to_litter(p) * dt
+         veg_ps%deadcrootp(p) = veg_ps%deadcrootp(p) - veg_pf%hrv_deadcrootp_to_litter(p) * dt
+         veg_ps%retransp(p)   = veg_ps%retransp(p)   - veg_pf%hrv_retransp_to_litter(p)   * dt
+         veg_ps%ppool(p)      = veg_ps%ppool(p)      - veg_pf%hrv_ppool_to_litter(p)      * dt
 
        if (ivt(p) >= npcropmin) then ! skip 2 generic crops
-           veg_ps%livestemp(p)= veg_ps%livestemp(p)  - veg_pf%hrv_livestemp_to_prod1p(p)  * dtime_mod
-           veg_ps%leafp(p)    = veg_ps%leafp(p)      - veg_pf%hrv_leafp_to_prod1p(p)      * dtime_mod
-           veg_ps%grainp(p)   = veg_ps%grainp(p)     - veg_pf%hrv_grainp_to_prod1p(p)     * dtime_mod
+           veg_ps%livestemp(p)= veg_ps%livestemp(p)  - veg_pf%hrv_livestemp_to_prod1p(p)  * dt
+           veg_ps%leafp(p)    = veg_ps%leafp(p)      - veg_pf%hrv_leafp_to_prod1p(p)      * dt
+           veg_ps%grainp(p)   = veg_ps%grainp(p)     - veg_pf%hrv_grainp_to_prod1p(p)     * dt
        end if
 
          ! storage pools
-         veg_ps%leafp_storage(p)      = veg_ps%leafp_storage(p)      - veg_pf%hrv_leafp_storage_to_litter(p)      * dtime_mod
-         veg_ps%frootp_storage(p)     = veg_ps%frootp_storage(p)     - veg_pf%hrv_frootp_storage_to_litter(p)     * dtime_mod
-         veg_ps%livestemp_storage(p)  = veg_ps%livestemp_storage(p)  - veg_pf%hrv_livestemp_storage_to_litter(p)  * dtime_mod
-         veg_ps%deadstemp_storage(p)  = veg_ps%deadstemp_storage(p)  - veg_pf%hrv_deadstemp_storage_to_litter(p)  * dtime_mod
-         veg_ps%livecrootp_storage(p) = veg_ps%livecrootp_storage(p) - veg_pf%hrv_livecrootp_storage_to_litter(p) * dtime_mod
-         veg_ps%deadcrootp_storage(p) = veg_ps%deadcrootp_storage(p) - veg_pf%hrv_deadcrootp_storage_to_litter(p) * dtime_mod
+         veg_ps%leafp_storage(p)      = veg_ps%leafp_storage(p)      - veg_pf%hrv_leafp_storage_to_litter(p)      * dt
+         veg_ps%frootp_storage(p)     = veg_ps%frootp_storage(p)     - veg_pf%hrv_frootp_storage_to_litter(p)     * dt
+         veg_ps%livestemp_storage(p)  = veg_ps%livestemp_storage(p)  - veg_pf%hrv_livestemp_storage_to_litter(p)  * dt
+         veg_ps%deadstemp_storage(p)  = veg_ps%deadstemp_storage(p)  - veg_pf%hrv_deadstemp_storage_to_litter(p)  * dt
+         veg_ps%livecrootp_storage(p) = veg_ps%livecrootp_storage(p) - veg_pf%hrv_livecrootp_storage_to_litter(p) * dt
+         veg_ps%deadcrootp_storage(p) = veg_ps%deadcrootp_storage(p) - veg_pf%hrv_deadcrootp_storage_to_litter(p) * dt
 
          ! transfer pools
-         veg_ps%leafp_xfer(p)      = veg_ps%leafp_xfer(p)      - veg_pf%hrv_leafp_xfer_to_litter(p)      *dtime_mod
-         veg_ps%frootp_xfer(p)     = veg_ps%frootp_xfer(p)     - veg_pf%hrv_frootp_xfer_to_litter(p)     *dtime_mod
-         veg_ps%livestemp_xfer(p)  = veg_ps%livestemp_xfer(p)  - veg_pf%hrv_livestemp_xfer_to_litter(p)  *dtime_mod
-         veg_ps%deadstemp_xfer(p)  = veg_ps%deadstemp_xfer(p)  - veg_pf%hrv_deadstemp_xfer_to_litter(p)  *dtime_mod
-         veg_ps%livecrootp_xfer(p) = veg_ps%livecrootp_xfer(p) - veg_pf%hrv_livecrootp_xfer_to_litter(p) *dtime_mod
-         veg_ps%deadcrootp_xfer(p) = veg_ps%deadcrootp_xfer(p) - veg_pf%hrv_deadcrootp_xfer_to_litter(p) *dtime_mod
+         veg_ps%leafp_xfer(p)      = veg_ps%leafp_xfer(p)      - veg_pf%hrv_leafp_xfer_to_litter(p)      *dt
+         veg_ps%frootp_xfer(p)     = veg_ps%frootp_xfer(p)     - veg_pf%hrv_frootp_xfer_to_litter(p)     *dt
+         veg_ps%livestemp_xfer(p)  = veg_ps%livestemp_xfer(p)  - veg_pf%hrv_livestemp_xfer_to_litter(p)  *dt
+         veg_ps%deadstemp_xfer(p)  = veg_ps%deadstemp_xfer(p)  - veg_pf%hrv_deadstemp_xfer_to_litter(p)  *dt
+         veg_ps%livecrootp_xfer(p) = veg_ps%livecrootp_xfer(p) - veg_pf%hrv_livecrootp_xfer_to_litter(p) *dt
+         veg_ps%deadcrootp_xfer(p) = veg_ps%deadcrootp_xfer(p) - veg_pf%hrv_deadcrootp_xfer_to_litter(p) *dt
 
       end do
 
diff --git a/components/elm/src/biogeochem/PhosphorusStateUpdate3Mod.F90 b/components/elm/src/biogeochem/PhosphorusStateUpdate3Mod.F90
index aa05cab50b..44f826c242 100644
--- a/components/elm/src/biogeochem/PhosphorusStateUpdate3Mod.F90
+++ b/components/elm/src/biogeochem/PhosphorusStateUpdate3Mod.F90
@@ -14,6 +14,8 @@ module PhosphorusStateUpdate3Mod
   use elm_varctl          , only : use_erosion, ero_ccycle, use_fates
   use CNDecompCascadeConType , only : decomp_cascade_con
   use CNStateType         , only : cnstate_type
+  use PhosphorusStateType , only : phosphorusstate_type
+  use PhosphorusFLuxType  , only : phosphorusflux_type
   use soilorder_varcon    , only : smax,ks_sorption
   use tracer_varcon       , only : is_active_betr_bgc
   ! bgc interface & pflotran:
@@ -35,7 +37,7 @@ module PhosphorusStateUpdate3Mod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine PhosphorusStateUpdate3(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+  subroutine PhosphorusStateUpdate3(bounds,num_soilc, filter_soilc, num_soilp, filter_soilp, &
        cnstate_vars, dt )
     !
     ! !DESCRIPTION:
@@ -46,6 +48,8 @@ contains
     ! no science equatiops. This increases readability and maintainability.
     !
     ! !ARGUMENTS:
+      !$acc routine seq
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc       ! number of soil columps in filter
     integer                  , intent(in)    :: filter_soilc(:) ! filter for soil columps
     integer                  , intent(in)    :: num_soilp       ! number of soil patches in filter
@@ -60,10 +64,10 @@ contains
 
    real(r8):: smax_c       ! parameter(gP/m2), maximum amount of sorbed P in equilibrium with solution P
    real(r8):: ks_sorption_c ! parameter(gP/m2), empirical constant for sorbed P in equilibrium with solution P
-   real(r8):: flux_mineralization(1:num_soilc,1:nlevdecomp)   !! local temperary variable
-   real(r8):: temp_solutionp
+   real(r8):: flux_mineralization(bounds%begc:bounds%endc,1:nlevdecomp)   !! local temperary variable
+   real(r8):: temp_solutionp(bounds%begc:bounds%endc,1:nlevdecomp)
    real(r8):: aa,bb,cc ! solve quadratic function
-   real(r8) :: sum1 
+
     !-----------------------------------------------------------------------
 
     associate(&
@@ -74,12 +78,17 @@ contains
          km_minsurf_p_vr   => veg_vp%km_minsurf_p_vr     &
          )
 
-      !$acc enter data create(flux_mineralization(1:num_soilc,1:nlevdecomp),sum1)
       ! set time steps
       !! immobilization/mineralization in litter-to-SOM and SOM-to-SOM fluxes
       !! - X.YANG
+      do j = 1, nlevdecomp
+         ! column loop
+         do fc = 1,num_soilc
+            c = filter_soilc(fc)
+            flux_mineralization(c,j) = 0._r8
+         enddo
+      enddo
       if(is_active_betr_bgc)then
-        !$acc parallel loop independent gang vector collapse(2) default(present)
         do j = 1, nlevdecomp
           do fc = 1,num_soilc
             c = filter_soilc(fc)
@@ -88,43 +97,48 @@ contains
           end do
         enddo
       else
-         !$acc parallel loop independent gang worker collapse(2) default(present) private(c,sum1)
-         do j = 1, nlevdecomp
-            do fc = 1,num_soilc
-               c = filter_soilc(fc)
-               sum1 = 0._r8
-               !$acc loop vector reduction(+:sum1)
-               do k = 1, ndecomp_cascade_transitions
-                  if ( cascade_receiver_pool(k) /= 0 ) then  ! skip terminal transitions
-                     
-                    sum1 = sum1 - col_pf%decomp_cascade_sminp_flux_vr(c,j,k)*dt
-                 else
-                    sum1 = sum1 + col_pf%decomp_cascade_sminp_flux_vr(c,j,k)*dt
-                  endif
+        do k = 1, ndecomp_cascade_transitions
+          if ( cascade_receiver_pool(k) /= 0 ) then  ! skip terminal transitions
+            do j = 1, nlevdecomp
+               ! column loop
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                    flux_mineralization(c,j) = flux_mineralization(c,j) - &
+                                               col_pf%decomp_cascade_sminp_flux_vr(c,j,k)*dt
                end do
-               flux_mineralization(fc,j) = sum1 
-            end do
+             end do
+           else
+             do j = 1, nlevdecomp
+               ! column loop
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                    flux_mineralization(c,j) = flux_mineralization(c,j) + &
+                                               col_pf%decomp_cascade_sminp_flux_vr(c,j,k)*dt
+               end do
+             end do
+           endif
         end do
 
-        !$acc parallel loop independent gang vector collapse(2) default(present)
+
         do j = 1, nlevdecomp
+              ! column loop
            do fc = 1,num_soilc
              c = filter_soilc(fc)
-             flux_mineralization(fc,j) = flux_mineralization(fc,j) + col_pf%biochem_pmin_vr(c,j)*dt
+             flux_mineralization(c,j) = flux_mineralization(c,j) + &
+                                       col_pf%biochem_pmin_vr(c,j)*dt
            end do
         end do
-      if (nu_com .eq. 'RD') then
 
-        !$acc parallel loop independent gang vector collapse(2) default(present)
+      if (nu_com .eq. 'RD') then
         do j = 1, nlevdecomp
           do fc = 1,num_soilc
             c = filter_soilc(fc)
                ! assign read in parameter values
                smax_c = smax( isoilorder(c) )
                ks_sorption_c = ks_sorption( isoilorder(c) )
-               temp_solutionp = col_ps%solutionp_vr(c,j)
+               temp_solutionp(c,j) = col_ps%solutionp_vr(c,j)
 
-               col_ps%solutionp_vr(c,j)      = col_ps%solutionp_vr(c,j)  + ( flux_mineralization(fc,j) &
+               col_ps%solutionp_vr(c,j)      = col_ps%solutionp_vr(c,j)  + ( flux_mineralization(c,j) &
                     + col_pf%primp_to_labilep_vr(c,j)*dt &
                     + col_pf%secondp_to_labilep_vr(c,j)*dt &
                     + col_pf%supplement_to_sminp_vr(c,j)*dt - col_pf%sminp_to_plant_vr(c,j)*dt&
@@ -133,23 +147,23 @@ contains
 
 
                  col_ps%labilep_vr(c,j) = col_ps%labilep_vr(c,j) + ((smax_c*ks_sorption_c)&
-                    /(ks_sorption_c+temp_solutionp)**2._r8 ) * &
-                    ( flux_mineralization(fc,j) + col_pf%primp_to_labilep_vr(c,j)*dt + col_pf%secondp_to_labilep_vr(c,j)*dt &
+                    /(ks_sorption_c+temp_solutionp(c,j))**2._r8 ) * &
+                    ( flux_mineralization(c,j) + col_pf%primp_to_labilep_vr(c,j)*dt + col_pf%secondp_to_labilep_vr(c,j)*dt &
                     + col_pf%supplement_to_sminp_vr(c,j)*dt - col_pf%sminp_to_plant_vr(c,j)*dt &
                     - col_pf%labilep_to_secondp_vr(c,j)*dt - col_pf%sminp_leached_vr(c,j)*dt ) / &
-                    ( 1._r8+(smax_c*ks_sorption_c)/(ks_sorption_c+temp_solutionp)**2._r8 )
+                    ( 1._r8+(smax_c*ks_sorption_c)/(ks_sorption_c+temp_solutionp(c,j))**2._r8 )
 
-               col_pf%desorb_to_solutionp_vr(c,j) = ( flux_mineralization(fc,j)/dt + col_pf%primp_to_labilep_vr(c,j) &
+               col_pf%desorb_to_solutionp_vr(c,j) = ( flux_mineralization(c,j)/dt + col_pf%primp_to_labilep_vr(c,j) &
                                 + col_pf%secondp_to_labilep_vr(c,j) &
                                 + col_pf%supplement_to_sminp_vr(c,j) - col_pf%sminp_to_plant_vr(c,j) &
                                 - col_pf%labilep_to_secondp_vr(c,j) - col_pf%sminp_leached_vr(c,j) ) / &
                                 (1._r8+(smax_c*ks_sorption_c)/(ks_sorption_c+col_ps%solutionp_vr(c,j))**2._r8)
 
-               col_pf%adsorb_to_labilep_vr(c,j) = ((smax_c*ks_sorption_c)/(ks_sorption_c+temp_solutionp)**2._r8 ) * &
-                             ( flux_mineralization(fc,j)/dt + col_pf%primp_to_labilep_vr(c,j) + col_pf%secondp_to_labilep_vr(c,j) &
+               col_pf%adsorb_to_labilep_vr(c,j) = ((smax_c*ks_sorption_c)/(ks_sorption_c+temp_solutionp(c,j))**2._r8 ) * &
+                             ( flux_mineralization(c,j)/dt + col_pf%primp_to_labilep_vr(c,j) + col_pf%secondp_to_labilep_vr(c,j) &
                              + col_pf%supplement_to_sminp_vr(c,j) - col_pf%sminp_to_plant_vr(c,j) &
                              - col_pf%labilep_to_secondp_vr(c,j) - col_pf%sminp_leached_vr(c,j) ) / &
-                             ( 1._r8+(smax_c*ks_sorption_c)/(ks_sorption_c+temp_solutionp)**2._r8 )
+                             ( 1._r8+(smax_c*ks_sorption_c)/(ks_sorption_c+temp_solutionp(c,j))**2._r8 )
              end do
            end do
         else ! ECA
@@ -161,22 +175,22 @@ contains
 
                 smax_c = vmax_minsurf_p_vr(isoilorder(c),j)
                 ks_sorption_c = km_minsurf_p_vr(isoilorder(c),j)
-                temp_solutionp = ( col_ps%solutionp_vr(c,j) + col_ps%labilep_vr(c,j) + &
-                            (flux_mineralization(fc,j) + col_pf%primp_to_labilep_vr(c,j)*dt + &
+                temp_solutionp(c,j) = ( col_ps%solutionp_vr(c,j) + col_ps%labilep_vr(c,j) + &
+                            (flux_mineralization(c,j) + col_pf%primp_to_labilep_vr(c,j)*dt + &
                             col_pf%secondp_to_labilep_vr(c,j)*dt + col_pf%supplement_to_sminp_vr(c,j)*dt - &
                             col_pf%sminp_to_plant_vr(c,j)*dt - col_pf%labilep_to_secondp_vr(c,j)*dt - &
                             col_pf%sminp_leached_vr(c,j)*dt ))
 
-                 if (temp_solutionp < 0.0_r8) then
+                 if (temp_solutionp(c,j) < 0.0_r8) then
                     col_pf%labilep_to_secondp_vr(c,j) = col_pf%labilep_to_secondp_vr(c,j)/ &
                             (col_pf%labilep_to_secondp_vr(c,j)+col_pf%sminp_leached_vr(c,j))* &
-                            (temp_solutionp + col_pf%labilep_to_secondp_vr(c,j)*dt + &
+                            (temp_solutionp(c,j) + col_pf%labilep_to_secondp_vr(c,j)*dt + &
                             col_pf%sminp_leached_vr(c,j)*dt) /dt
                     col_pf%sminp_leached_vr(c,j) = col_pf%sminp_leached_vr(c,j)/ &
                             (col_pf%labilep_to_secondp_vr(c,j)+col_pf%sminp_leached_vr(c,j))* &
-                            (temp_solutionp + col_pf%labilep_to_secondp_vr(c,j)*dt + &
+                            (temp_solutionp(c,j) + col_pf%labilep_to_secondp_vr(c,j)*dt + &
                             col_pf%sminp_leached_vr(c,j)*dt) /dt
-                       temp_solutionp = 0.0_r8
+                       temp_solutionp(c,j) = 0.0_r8
                        col_ps%solutionp_vr(c,j) = 0.0_r8
                        col_ps%labilep_vr(c,j) = 0.0_r8
                  else
@@ -184,34 +198,31 @@ contains
                        ! sorbp + solutionp = smax*solutionp/(ks+solutionp) + solutionp = total p pool after competition
                        ! solve quadratic function to get equilibrium solutionp and adsorbp pools
                        aa = 1;
-                       bb = smax_c + ks_sorption_c - temp_solutionp
-                       cc = -1.0_r8 * ks_sorption_c *  temp_solutionp
+                       bb = smax_c + ks_sorption_c - temp_solutionp(c,j)
+                       cc = -1.0_r8 * ks_sorption_c *  temp_solutionp(c,j)
                        col_ps%solutionp_vr(c,j)  = (-bb+(bb*bb-4.0_r8*aa*cc)**0.5_r8)/(2.0_r8*aa)
-                       col_ps%labilep_vr(c,j) = temp_solutionp - col_ps%solutionp_vr(c,j)
+                       col_ps%labilep_vr(c,j) = temp_solutionp(c,j) - col_ps%solutionp_vr(c,j)
                  end if
 
                  col_ps%solutionp_vr_cur(c,j) = col_ps%solutionp_vr(c,j)
                  col_ps%labilep_vr_cur(c,j) = col_ps%labilep_vr(c,j)
               enddo
            enddo
-        end if
+         end if
 
          if (nu_com .eq. 'RD') then
-            !$acc parallel loop independent gang worker collapse(2) default(present) 
-            do l = 1, ndecomp_pools
-               do j = 1, nlevdecomp
-                  !$acc loop vector independent private(c)
-                  do fc = 1,num_soilc
-                     c = filter_soilc(fc)
+          do j = 1, nlevdecomp
+             do fc = 1,num_soilc
+                c = filter_soilc(fc)
+                do l = 1, ndecomp_pools
 
-                     col_ps%decomp_ppools_vr(c,j,l) = col_ps%decomp_ppools_vr(c,j,l)- col_pf%biochem_pmin_ppools_vr(c,j,l)*dt
+                   col_ps%decomp_ppools_vr(c,j,l) = col_ps%decomp_ppools_vr(c,j,l)- col_pf%biochem_pmin_ppools_vr(c,j,l)*dt
 
-                  end do
-               end do
-            end do
+                end do
+             end do
+          end do
          end if
 
-         !$acc parallel loop independent gang vector collapse(2) default(present)
          do j = 1, nlevdecomp
             do fc = 1,num_soilc
                c = filter_soilc(fc)
@@ -221,8 +232,8 @@ contains
                col_ps%primp_vr_prev(c,j)   = col_ps%primp_vr(c,j)
 
                col_ps%secondp_vr(c,j) = col_ps%secondp_vr(c,j) + ( col_pf%labilep_to_secondp_vr(c,j) &
-                    - col_pf%secondp_to_labilep_vr(c,j) - col_pf%secondp_to_occlp_vr(c,j) )*dt
-               
+                    - col_pf%secondp_to_labilep_vr(c,j) &
+                                     - col_pf%secondp_to_occlp_vr(c,j) )*dt
                col_ps%occlp_vr(c,j)   = col_ps%occlp_vr(c,j) + ( col_pf%secondp_to_occlp_vr(c,j) ) * dt
                col_ps%primp_vr(c,j)   = col_ps%primp_vr(c,j) - ( col_pf%primp_to_labilep_vr(c,j) )*dt + col_pf%pdep_to_sminp(c)*dt &
                     * pdep_prof(c,j)
@@ -249,9 +260,9 @@ contains
                end do
             end do
          end if
-      
-      !$acc parallel loop independent gang vector collapse(2) default(present) private(c)
+
       do j = 1, nlevdecomp
+         ! column loop
          do fc = 1,num_soilc
             c = filter_soilc(fc)
 
@@ -267,10 +278,9 @@ contains
       end do
 
       ! litter and CWD losses to fire
-      !$acc parallel loop independent gang worker collapse(2) default(present)
       do l = 1, ndecomp_pools
          do j = 1, nlevdecomp
-            !$acc loop vector independent private(c)
+            ! column loop
             do fc = 1,num_soilc
                c = filter_soilc(fc)
                col_ps%decomp_ppools_vr(c,j,l) = col_ps%decomp_ppools_vr(c,j,l) - col_pf%m_decomp_ppools_to_fire_vr(c,j,l) * dt
@@ -303,7 +313,6 @@ contains
     ! patch-level phosphorus fluxes
 
     if(.not.use_fates) then
-      !$acc parallel loop independent gang vector default(present) private(p)
        do fp = 1,num_soilp
           p = filter_soilp(fp)
 
@@ -360,7 +369,6 @@ contains
           veg_ps%ppool(p)              =  veg_ps%ppool(p) - veg_pf%m_ppool_to_litter_fire(p)       * dt
        end do
     end if
-      !$acc exit data delete(flux_mineralization(:,:),sum1)
 
     end associate
 
diff --git a/components/elm/src/biogeochem/PrecisionControlMod.F90 b/components/elm/src/biogeochem/PrecisionControlMod.F90
index 30bc838904..89e30c83fd 100644
--- a/components/elm/src/biogeochem/PrecisionControlMod.F90
+++ b/components/elm/src/biogeochem/PrecisionControlMod.F90
@@ -16,7 +16,7 @@ module PrecisionControlMod
   use VegetationType      , only : veg_pp
   use VegetationDataType  , only : veg_cs, c13_veg_cs, c14_veg_cs
   use VegetationDataType  , only : veg_ns, veg_ps
-  #define is_active_betr_bgc .false.
+
   !
   implicit none
   save
@@ -36,9 +36,11 @@ contains
     ! they get too small.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varctl , only : iulog, use_c13, use_c14, use_fates
     use elm_varpar , only : nlevdecomp_full, crop_prog
     use pftvarcon  , only : nc3crop
+    use tracer_varcon          , only : is_active_betr_bgc
     use CNDecompCascadeConType , only : decomp_cascade_con
     !
     ! !ARGUMENTS:
@@ -49,16 +51,16 @@ contains
     !
     ! !LOCAL VARIABLES:
     integer :: c,p,j,k,l  ! indices
-    integer :: fp,fc    ! filter indices
+    integer :: fp,fc    ! lake filter indices
     real(r8):: pc,pn,pp    ! truncation terms for patch-level corrections
     real(r8):: cc,cn,cp    ! truncation terms for column-level corrections
     real(r8):: pc13     ! truncation terms for patch-level corrections
     real(r8):: cc13     ! truncation terms for column-level corrections
     real(r8):: pc14     ! truncation terms for patch-level corrections
     real(r8):: cc14     ! truncation terms for column-level corrections
-    real(r8), parameter :: ccrit = 1.e-8_r8   ! critical carbon state value for truncation (gC/m2)
-    real(r8), parameter :: ncrit = 1.e-8_r8   ! critical nitrogen state value for truncation
-    real(r8), parameter :: pcrit = 1.e-8_r8   ! critical phosphorus state value for truncation
+    real(r8):: ccrit    ! critical carbon state value for truncation
+    real(r8):: ncrit    ! critical nitrogen state value for truncation
+    real(r8):: pcrit    ! critical phosphorus state value for truncation
     real(r8):: cc_eca
     real(r8):: cn_eca
     real(r8):: cp_eca
@@ -70,10 +72,17 @@ contains
          initial_cn_ratio                 =>    decomp_cascade_con%initial_cn_ratio                 &
          )
 
+      ! set the critical carbon state value for truncation (gC/m2)
+      ccrit = 1.e-8_r8
+
+      ! set the critical nitrogen state value for truncation (gN/m2)
+      ncrit = 1.e-8_r8
+
+      ! set the critical phosphorus state value for truncation (gN/m2)
+      pcrit = 1.e-8_r8
+
       ! patch loop
       if (.not.use_fates) then
-         
-         !$acc parallel loop independent gang vector default(present) private(p,pc,pn,pp,pc13,pc14)
          do fp = 1,num_soilp
             p = filter_soilp(fp)
 
@@ -548,75 +557,73 @@ contains
             endif
 
          end do ! end of pft loop
-
       end if ! end of if(.not.use_fates)
 
       if (.not. is_active_betr_bgc) then
-         
+
          ! column loop
-         !TODO: split c13c14 into separate loops 
-         !$acc enter data create(cc, cn) 
-         !$acc parallel loop independent gang worker collapse(2) private(cc,cn,c)
          do fc = 1,num_soilc
+            c = filter_soilc(fc)
+
             do j = 1,nlevdecomp_full
-               c = filter_soilc(fc)
                ! initialize the column-level C and N truncation terms
                cc = 0._r8
+               if ( use_c13 ) cc13 = 0._r8
+               if ( use_c14 ) cc14 = 0._r8
                cn = 0._r8
-               !if ( use_c13 ) cc13 = 0._r8
-               !if ( use_c14 ) cc14 = 0._r8
 
                ! do tests on state variables for precision control
                ! for linked C-N state variables, perform precision test on
                ! the C component, but truncate both C and N components
 
+
                ! all decomposing pools C and N
-               !$acc loop vector reduction(+:cc,cn)
                do k = 1, ndecomp_pools
+
                   if (abs(col_cs%decomp_cpools_vr(c,j,k)) < ccrit) then
                      cc = cc + col_cs%decomp_cpools_vr(c,j,k)
-                     cn = cn + col_ns%decomp_npools_vr(c,j,k)
-
                      col_cs%decomp_cpools_vr(c,j,k) = 0._r8
+                     cn = cn + col_ns%decomp_npools_vr(c,j,k)
                      col_ns%decomp_npools_vr(c,j,k) = 0._r8
-                     !if ( use_c13 ) then
-                     !   cc13 = cc13 + c13_col_cs%decomp_cpools_vr(c,j,k)
-                     !   c13_col_cs%decomp_cpools_vr(c,j,k) = 0._r8
-                     !endif
-                     !if ( use_c14 ) then
-                     !   cc14 = cc14 + c14_col_cs%decomp_cpools_vr(c,j,k)
-                     !   c14_col_cs%decomp_cpools_vr(c,j,k) = 0._r8
-                     !endif
+                     if ( use_c13 ) then
+                        cc13 = cc13 + c13_col_cs%decomp_cpools_vr(c,j,k)
+                        c13_col_cs%decomp_cpools_vr(c,j,k) = 0._r8
+                     endif
+                     if ( use_c14 ) then
+                        cc14 = cc14 + c14_col_cs%decomp_cpools_vr(c,j,k)
+                        c14_col_cs%decomp_cpools_vr(c,j,k) = 0._r8
+                     endif
                   end if
+
                end do
+
                ! not doing precision control on soil mineral N, since it will
                ! be getting the N truncation flux anyway.
+
                col_cs%ctrunc_vr(c,j) = col_cs%ctrunc_vr(c,j) + cc
                col_ns%ntrunc_vr(c,j) = col_ns%ntrunc_vr(c,j) + cn
-               !if ( use_c13 ) then
-               !   c13_col_cs%ctrunc_vr(c,j) = c13_col_cs%ctrunc_vr(c,j) + cc13
-               !endif
-               !if ( use_c14 ) then
-               !   c14_col_cs%ctrunc_vr(c,j) = c14_col_cs%ctrunc_vr(c,j) + cc14
-               !endif
+               if ( use_c13 ) then
+                  c13_col_cs%ctrunc_vr(c,j) = c13_col_cs%ctrunc_vr(c,j) + cc13
+               endif
+               if ( use_c14 ) then
+                  c14_col_cs%ctrunc_vr(c,j) = c14_col_cs%ctrunc_vr(c,j) + cc14
+               endif
             end do
 
          end do   ! end of column loop
-         !$acc exit data delete(cc,cn)
 
-         !
          ! remove small negative perturbations for stability purposes, if any should arise.
-         !$acc parallel loop independent gang vector default(present)
-         do j = 1,nlevdecomp_full
-            do fc = 1,num_soilc
-               c = filter_soilc(fc)
+         
+         do fc = 1,num_soilc
+            c = filter_soilc(fc)
+            do j = 1,nlevdecomp_full
                if (abs(col_ns%smin_no3_vr(c,j)) < ncrit/1e4_r8) then
                   if ( col_ns%smin_no3_vr(c,j)  < 0._r8 ) then
 #ifndef _OPENACC
                      write(iulog, *) '-10^-12 < smin_no3 < 0. resetting to zero.'
                      write(iulog, *) 'smin_no3_vr_col(c,j), c, j: ', col_ns%smin_no3_vr(c,j), c, j
-#endif
                      col_ns%smin_no3_vr(c,j) = 0._r8
+#endif
                   endif
                end if
                if (abs(col_ns%smin_nh4_vr(c,j)) < ncrit/1e4_r8) then
@@ -624,8 +631,8 @@ contains
 #ifndef _OPENACC
                      write(iulog, *) '-10^-12 < smin_nh4 < 0. resetting to zero.'
                      write(iulog, *) 'smin_nh4_vr_col(c,j), c, j: ', col_ns%smin_nh4_vr(c,j), c, j
-#endif
                      col_ns%smin_nh4_vr(c,j) = 0._r8
+#endif
                   endif
                end if
             end do
diff --git a/components/elm/src/biogeochem/SoilLittDecompMod.F90 b/components/elm/src/biogeochem/SoilLittDecompMod.F90
index 0c46b7ddf8..0586868c82 100644
--- a/components/elm/src/biogeochem/SoilLittDecompMod.F90
+++ b/components/elm/src/biogeochem/SoilLittDecompMod.F90
@@ -9,13 +9,14 @@ module SoilLittDecompMod
   use shr_kind_mod           , only : r8 => shr_kind_r8
   use shr_const_mod          , only : SHR_CONST_TKFRZ
   use decompMod              , only : bounds_type
+  use perf_mod               , only : t_startf, t_stopf
   use perfMod_GPU
   use elm_varctl             , only : iulog, use_lch4, use_century_decomp
   use elm_varcon             , only : dzsoi_decomp
   use elm_varpar             , only : nlevdecomp, ndecomp_cascade_transitions, ndecomp_pools
   use DecompCascadeCNMod     , only : decomp_rate_constants_cn
   use DecompCascadeBGCMod    , only : decomp_rate_constants_bgc
-  use NitrifDenitrifMod      , only : nitrif_denitrif
+  use NitrifDenitrifMod    , only : nitrif_denitrif
   use VerticalProfileMod     , only : decomp_vertprofiles
   use CNDecompCascadeConType , only : decomp_cascade_con
   use CNStateType            , only : cnstate_type
@@ -31,9 +32,11 @@ module SoilLittDecompMod
   use ColumnDataType         , only : col_ns, col_nf
   use ColumnDataType         , only : col_ps, col_pf
   use VegetationDataType     , only : veg_ps, veg_pf
+  use ELMFatesInterfaceMod   , only : hlm_fates_interface_type
   ! clm interface & pflotran:
   use elm_varctl             , only : use_elm_interface, use_pflotran, pf_cmode
   use elm_varctl             , only : use_cn, use_fates
+  use elm_instMod            , only : alm_fates
   !
   implicit none
   save
@@ -41,7 +44,7 @@ module SoilLittDecompMod
   !
   ! !PUBLIC MEMBER FUNCTIONS:
 
-  public :: readSoilLittDecompParams
+   public :: readSoilLittDecompParams
   public :: SoilLittDecompAlloc
   ! pflotran
   public :: SoilLittDecompAlloc2
@@ -55,37 +58,38 @@ module SoilLittDecompMod
   !-----------------------------------------------------------------------
 
 contains
-   !-----------------------------------------------------------------------
-    subroutine readSoilLittDecompParams ( ncid)
-      !
-      ! !DESCRIPTION:
-      ! Read parameters
-      !
-      ! !USES:
-      use ncdio_pio    , only: file_desc_t,ncd_io
-      use abortutils   , only: endrun
-      use shr_log_mod  , only: errMsg => shr_log_errMsg
-
-      ! !ARGUMENTS:
-      implicit none
-      type(file_desc_t),intent(inout) :: ncid   ! pio netCDF file id
-      !
-      ! !LOCAL VARIABLES:
-      character(len=32)  :: subname = 'CNDecompParamsType'
-      character(len=100) :: errCode = '-Error reading in parameters file:'
-      logical            :: readv ! has variable been read in or not
-      real(r8)           :: tempr ! temporary to read in constant
-      character(len=100) :: tString ! temp. var for reading
-      !-----------------------------------------------------------------------
-      allocate(CNDecompParamsInst%dnp)
-      tString='dnp'
-      call ncd_io(trim(tString),tempr, 'read', ncid, readvar=readv)
-      if ( .not. readv ) call endrun(msg=trim(errCode)//trim(tString)//errMsg(__FILE__, __LINE__))
-      CNDecompParamsInst%dnp=tempr
-
-    end subroutine readSoilLittDecompParams
-
-!-----------------------------------------------
+
+  !-----------------------------------------------------------------------
+   subroutine readSoilLittDecompParams ( ncid )
+     !
+     ! !DESCRIPTION:
+     ! Read parameters
+     !
+     ! !USES:
+     use ncdio_pio    , only: file_desc_t,ncd_io
+     use abortutils   , only: endrun
+     use shr_log_mod  , only: errMsg => shr_log_errMsg
+
+     ! !ARGUMENTS:
+     implicit none
+     type(file_desc_t),intent(inout) :: ncid   ! pio netCDF file id
+     !
+     ! !LOCAL VARIABLES:
+     character(len=32)  :: subname = 'CNDecompParamsType'
+     character(len=100) :: errCode = '-Error reading in parameters file:'
+     logical            :: readv ! has variable been read in or not
+     real(r8)           :: tempr ! temporary to read in constant
+     character(len=100) :: tString ! temp. var for reading
+     !-----------------------------------------------------------------------
+     allocate(CNDecompParamsInst%dnp)
+     tString='dnp'
+     call ncd_io(trim(tString),tempr, 'read', ncid, readvar=readv)
+     if ( .not. readv ) call endrun(msg=trim(errCode)//trim(tString)//errMsg(__FILE__, __LINE__))
+     CNDecompParamsInst%dnp=tempr
+
+   end subroutine readSoilLittDecompParams
+
+!-------------------------------------------------------------------------------------------------
   subroutine SoilLittDecompAlloc (bounds, num_soilc, filter_soilc,    &
                 num_soilp, filter_soilp,                        &
                 canopystate_vars, soilstate_vars,               &
@@ -103,9 +107,12 @@ contains
     !-----------------------------------------------------------------------------
 
     ! !USES:
+!    use AllocationMod , only: CNAllocation
+      !$acc routine seq
     use AllocationMod , only: Allocation2_ResolveNPLimit ! Phase-2 of CNAllocation
+    !
     ! !ARGUMENT:
-    type(bounds_type)        , intent(in)    :: bounds 
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc          ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:)    ! filter for soil columns
     integer                  , intent(in)    :: num_soilp          ! number of soil patches in filter
@@ -114,27 +121,28 @@ contains
     type(soilstate_type)     , intent(in)    :: soilstate_vars
     type(cnstate_type)       , intent(inout) :: cnstate_vars
     type(ch4_type)           , intent(in)    :: ch4_vars
+
+    ! add phosphorus --
+!    type(crop_type)          , intent(in)    :: crop_vars
     real(r8),   intent(in)    :: dtime
     !
     ! !LOCAL VARIABLES:
-    integer :: c,j,k,l,m                                                                 !indices
-    integer :: fc                                                                        !lake filter column index
-    real(r8):: p_decomp_cpool_loss(num_soilc,1:nlevdecomp,1:ndecomp_cascade_transitions) !potential C loss from one pool to another
-    real(r8):: immob(num_soilc,1:nlevdecomp)                                             !potential N immobilization
-    real(r8):: immob_p(num_soilc,1:nlevdecomp)                                           !potential P immobilization
-    real(r8):: ratio                                                                     !temporary variable
-    real(r8):: dnp                                                                       !denitrification proportion
-    real(r8):: cn_decomp_pools(num_soilc,1:nlevdecomp,1:ndecomp_pools)
-    real(r8):: cp_decomp_pools(num_soilc,1:nlevdecomp,1:ndecomp_pools)
-    real(r8):: cp_decomp_pools_new(num_soilc,1:nlevdecomp,1:ndecomp_pools)              !C:P ratio of new SOM
+    integer :: c,j,k,l,m                                                                               !indices
+    integer :: fc                                                                                      !lake filter column index
+    real(r8):: p_decomp_cpool_loss(bounds%begc:bounds%endc,1:nlevdecomp,1:ndecomp_cascade_transitions) !potential C loss from one pool to another
+    real(r8):: immob(bounds%begc:bounds%endc,1:nlevdecomp)                                             !potential N immobilization
+    real(r8):: immob_p(bounds%begc:bounds%endc,1:nlevdecomp)                                             !potential P immobilization
+    real(r8):: ratio                                                                                   !temporary variable
+    real(r8):: dnp                                                                        !denitrification proportion
+    real(r8):: cn_decomp_pools(bounds%begc:bounds%endc,1:nlevdecomp,1:ndecomp_pools)
+    real(r8):: cp_decomp_pools(bounds%begc:bounds%endc,1:nlevdecomp,1:ndecomp_pools)
+    real(r8):: cp_decomp_pools_new(bounds%begc:bounds%endc,1:nlevdecomp,1:ndecomp_pools)               !C:P ratio of new SOM
     integer, parameter :: i_atm = 0
-    integer :: k_donor_pool
     ! For methane code
-    !real(r8):: hrsum(num_soilc,1:nlevdecomp)          !sum of HR (gC/m2/s)
-    real :: startt, stopt
-    real(r8) :: sum_1, sum_2, sum_3, sum_4
+    real(r8):: phr_vr(bounds%begc:bounds%endc,1:nlevdecomp)                                            !potential HR (gC/m3/s)
+    real(r8):: hrsum(bounds%begc:bounds%endc,1:nlevdecomp)                                             !sum of HR (gC/m2/s)
 
-    character(len=64) :: event
+    character(len=256) :: event
     !-----------------------------------------------------------------------
 
     associate(                                                                                           &
@@ -145,11 +153,12 @@ contains
          initial_cn_ratio                 =>    decomp_cascade_con%initial_cn_ratio                    , & ! Input:  [real(r8) (:)     ]  c:n ratio for initialization of pools
          initial_cp_ratio                 =>    decomp_cascade_con%initial_cp_ratio                    , & ! Input:  [real(r8) (:)     ]  c:p ratio for initialization of pools
 
-         is_cwd                           =>    decomp_cascade_con%is_cwd                 , &
-         fpi_vr                           =>    cnstate_vars%fpi_vr_col                   , & ! Input:  [real(r8) (:,:)   ]  fraction of potential immobilization for N(no units)
-         fpi_p_vr                         =>    cnstate_vars%fpi_p_vr_col                 , & ! Input:  [real(r8) (:,:)   ]  fraction of potential immobilization for P (no units)
-         rf_decomp_cascade                =>    cnstate_vars%rf_decomp_cascade_col        , & ! Input:  [real(r8) (:,:,:) ]  respired fraction in decomposition step (frac)
-         pathfrac_decomp_cascade          =>    cnstate_vars%pathfrac_decomp_cascade_col  , & ! Input:  [real(r8) (:,:,:) ]  what fraction of C leaving a given pool passes through a given transition (frac)
+         is_cwd                           =>    decomp_cascade_con%is_cwd                              , &
+!
+         fpi_vr                           =>    cnstate_vars%fpi_vr_col                                , & ! Input:  [real(r8) (:,:)   ]  fraction of potential immobilization for N(no units)
+         fpi_p_vr                         =>    cnstate_vars%fpi_p_vr_col                              , & ! Input:  [real(r8) (:,:)   ]  fraction of potential immobilization for P (no units)
+         rf_decomp_cascade                =>    cnstate_vars%rf_decomp_cascade_col                     , & ! Input:  [real(r8) (:,:,:) ]  respired fraction in decomposition step (frac)
+         pathfrac_decomp_cascade          =>    cnstate_vars%pathfrac_decomp_cascade_col               , & ! Input:  [real(r8) (:,:,:) ]  what fraction of C leaving a given pool passes through a given transition (frac)
 
          decomp_npools_vr                 =>    col_ns%decomp_npools_vr                , & ! Input:  [real(r8) (:,:,:) ]  (gC/m3)  vertically-resolved decomposing (litter, cwd, soil) N pools
          decomp_ppools_vr                 =>    col_ps%decomp_ppools_vr              , & ! Input:  [real(r8) (:,:,:) ]  (gC/m3)  vertically-resolved decomposing (litter, cwd, soil) P pools
@@ -175,61 +184,78 @@ contains
          gross_pmin                       =>    col_pf%gross_pmin                     , & ! Output: [real(r8) (:)     ]  gross rate of P mineralization (gP/m2/s)
          net_pmin                         =>    col_pf%net_pmin                       , & ! Output: [real(r8) (:)     ]  net rate of P mineralization (gP/m2/s)
 
-         decomp_cascade_hr_vr             =>    col_cf%decomp_cascade_hr_vr           , & ! Output: [real(r8) (:,:,:) ]  vertically-resolved het. resp. from decomposing C pools (gC/m3/s)
-         decomp_cascade_ctransfer_vr      =>    col_cf%decomp_cascade_ctransfer_vr    , & ! Output: [real(r8) (:,:,:) ]  vertically-resolved het. resp. from decomposing C pools (gC/m3/s)
-         decomp_k                         =>    col_cf%decomp_k                       , & ! Output: [real(r8) (:,:,:) ]  rate constant for decomposition (1./sec)
-         phr_vr                           =>    col_cf%phr_vr                         , & ! Output: [real(r8) (:,:)   ]  potential HR (gC/m3/s)
-         fphr                             =>    col_cf%fphr                           , & ! Output: [real(r8) (:,:)   ]  fraction of potential SOM + LITTER heterotrophic
-         pmnf_decomp_cascade              =>    col_nf%pmnf_decomp_cascade            , &
-         pmpf_decomp_cascade              =>    col_pf%pmpf_decomp_cascade            , &
-         soil_n_immob_flux                =>    col_nf%soil_n_immob_flux              , &
-         soil_n_immob_flux_vr             =>    col_nf%soil_n_immob_flux_vr           , &
-         soil_n_grossmin_flux             =>    col_nf%soil_n_grossmin_flux           , &
-         soil_p_immob_flux                =>    col_pf%soil_p_immob_flux              , &
-         soil_p_immob_flux_vr             =>    col_pf%soil_p_immob_flux_vr           , &
-         soil_p_grossmin_flux             =>    col_pf%soil_p_grossmin_flux           , &
-         actual_immob_vr                  =>    col_nf%actual_immob_vr                , &
+         decomp_cascade_hr_vr             =>    col_cf%decomp_cascade_hr_vr               , & ! Output: [real(r8) (:,:,:) ]  vertically-resolved het. resp. from decomposing C pools (gC/m3/s)
+         decomp_cascade_ctransfer_vr      =>    col_cf%decomp_cascade_ctransfer_vr        , & ! Output: [real(r8) (:,:,:) ]  vertically-resolved het. resp. from decomposing C pools (gC/m3/s)
+         decomp_k                         =>    col_cf%decomp_k                           , & ! Output: [real(r8) (:,:,:) ]  rate constant for decomposition (1./sec)
+         phr_vr                           =>    col_cf%phr_vr                             , & ! Output: [real(r8) (:,:)   ]  potential HR (gC/m3/s)
+         fphr                             =>    col_cf%fphr                               , & ! Output: [real(r8) (:,:)   ]  fraction of potential SOM + LITTER heterotrophic
+         pmnf_decomp_cascade              =>    col_nf%pmnf_decomp_cascade                  , &
+         pmpf_decomp_cascade              =>    col_pf%pmpf_decomp_cascade                , &
+         soil_n_immob_flux                =>    col_nf%soil_n_immob_flux                    , &
+         soil_n_immob_flux_vr             =>    col_nf%soil_n_immob_flux_vr                 , &
+         soil_n_grossmin_flux             =>    col_nf%soil_n_grossmin_flux                 , &
+         soil_p_immob_flux                =>    col_pf%soil_p_immob_flux                  , &
+         soil_p_immob_flux_vr             =>    col_pf%soil_p_immob_flux_vr               , &
+         soil_p_grossmin_flux             =>    col_pf%soil_p_grossmin_flux               , &
+         actual_immob_vr                  =>    col_nf%actual_immob_vr                  , &
          actual_immob_p_vr                =>    col_pf%actual_immob_p_vr                &
          )
 
       !-------------------------------------------------------------------------------------------------
       ! call decomp_rate_constants_bgc() or decomp_rate_constants_cn(): now called in EcosystemDynNoLeaching1
       !-------------------------------------------------------------------------------------------------
+      ! set initial values for potential C and N fluxes
+      p_decomp_cpool_loss(bounds%begc : bounds%endc, :, :) = 0._r8
+      pmnf_decomp_cascade(bounds%begc : bounds%endc, :, :) = 0._r8
+      pmpf_decomp_cascade(bounds%begc : bounds%endc, :, :) = 0._r8    !! initial values for potential P fluxes
 
       ! column loop to calculate potential decomp rates and total immobilization
       ! demand.
-      call cpu_time(startt) 
-      !$acc enter data create(cn_decomp_pools(:num_soilc,1:nlevdecomp,1:ndecomp_pools), &
-      !$acc                                     p_decomp_cpool_loss(:num_soilc,1:nlevdecomp,1:ndecomp_cascade_transitions))
-      !$acc enter data create(cp_decomp_pools(:num_soilc,1:nlevdecomp,1:ndecomp_pools),&
-      !$acc                   immob(:num_soilc,1:nlevdecomp) ,immob_p(:num_soilc,1:nlevdecomp)  ) 
-      !$acc enter data create(cp_decomp_pools_new(:num_soilc,1:nlevdecomp,1:ndecomp_pools)) 
-      call cpu_time(stopt) 
-      write(iulog,*) "SoilLittDecompAlloc1 :: create",(stopt-startt)*1.E+3,"ms" 
+
       !! calculate c:n ratios of applicable pools
+      do l = 1, ndecomp_pools
+         if ( floating_cn_ratio_decomp_pools(l) ) then
+            do j = 1,nlevdecomp
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                  if ( decomp_npools_vr(c,j,l) > 0._r8 ) then
+                     cn_decomp_pools(c,j,l) = decomp_cpools_vr(c,j,l) / decomp_npools_vr(c,j,l)
+                  end if
+               end do
+            end do
+         else
+            do j = 1,nlevdecomp
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                  cn_decomp_pools(c,j,l) = initial_cn_ratio(l)
+               end do
+            end do
+         end if
+      end do
 
-      !$acc parallel loop gang independent collapse(2) default(present)
+      !! calculate c:p ratios of applicable pools
       do l = 1, ndecomp_pools
+         if ( floating_cp_ratio_decomp_pools(l) ) then
+            do j = 1,nlevdecomp
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                  if ( decomp_ppools_vr(c,j,l) > 0._r8 ) then
+                     cp_decomp_pools(c,j,l) = decomp_cpools_vr(c,j,l) / decomp_ppools_vr(c,j,l)
+                  end if
+               end do
+            end do
+         else
+            do j = 1,nlevdecomp
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                  cp_decomp_pools(c,j,l) = initial_cp_ratio(l)
+               end do
+            end do
+         end if
          do j = 1,nlevdecomp
-            !$acc loop vector independent private(c)
             do fc = 1,num_soilc
                c = filter_soilc(fc)
-               if ( floating_cn_ratio_decomp_pools(l) ) then
-                  if ( decomp_npools_vr(c,j,l) > 0._r8 ) then
-                      cn_decomp_pools(fc,j,l) = decomp_cpools_vr(c,j,l) / decomp_npools_vr(c,j,l)
-                  end if
-               else
-                  cn_decomp_pools(fc,j,l) = initial_cn_ratio(l)
-               end if
-               !! calculate c:p ratios of applicable pools
-               if ( floating_cp_ratio_decomp_pools(l) ) then
-                   if ( decomp_ppools_vr(c,j,l) > 0._r8 ) then
-                      cp_decomp_pools(fc,j,l) = decomp_cpools_vr(c,j,l) / decomp_ppools_vr(c,j,l)
-                   end if
-                else
-                   cp_decomp_pools(fc,j,l) = initial_cp_ratio(l)
-                end if
-              cp_decomp_pools_new(fc,j,l) = initial_cp_ratio(l)
+               cp_decomp_pools_new(c,j,l) = initial_cp_ratio(l)
             end do
          end do
       end do
@@ -238,167 +264,181 @@ contains
       ! these fluxes include the  "/ dt" term to put them on a
       ! per second basis, since the rate constants have been
       ! calculated on a per timestep basis.
-       !$acc parallel loop  gang independent collapse(2) default(present)
-       do k = 1, ndecomp_cascade_transitions
-          do j = 1,nlevdecomp
-             !$acc loop vector private(c,k_donor_pool,ratio)
-             do fc = 1,num_soilc
-                k_donor_pool = cascade_donor_pool(k)
-                c = filter_soilc(fc)
-                ! set initial values for potential C and N fluxes
-                p_decomp_cpool_loss(fc,j,k) = 0._r8
-                pmnf_decomp_cascade(c ,j,k) = 0._r8
-                pmpf_decomp_cascade(c ,j,k) = 0._r8    !! initial values for potential P fluxes
-
-                if (decomp_cpools_vr(c,j,k_donor_pool) > 0._r8 .and. &
-                     decomp_k(c,j,k_donor_pool) > 0._r8 ) then
-
-                   p_decomp_cpool_loss(fc,j,k) = decomp_cpools_vr(c,j,k_donor_pool) &
-                            * decomp_k(c,j,k_donor_pool)  * pathfrac_decomp_cascade(c,j,k)
-                   if ( .not. floating_cn_ratio_decomp_pools(cascade_receiver_pool(k)) ) then  !! not transition of cwd to litter
-
-                      if (cascade_receiver_pool(k) /= i_atm ) then  ! not 100% respiration
-                         ratio = 0._r8
-                         if (decomp_npools_vr(c,j,k_donor_pool) > 0._r8) then
-                            ratio = cn_decomp_pools(fc,j,cascade_receiver_pool(k))/cn_decomp_pools(fc,j,k_donor_pool)
-                         endif
-                         pmnf_decomp_cascade(c,j,k) = (p_decomp_cpool_loss(fc,j,k) * (1.0_r8 - rf_decomp_cascade(c,j,k) - ratio) &
-                              / cn_decomp_pools(fc,j,cascade_receiver_pool(k)) )
-
-                      else   ! 100% respiration
-                         pmnf_decomp_cascade(c,j,k) = - p_decomp_cpool_loss(fc,j,k) / cn_decomp_pools(fc,j,k_donor_pool)
-                      endif
-
-                   else   ! CWD -> litter
-                      pmnf_decomp_cascade(c,j,k) = 0._r8
-                   end if
-                   !!! add phosphorus fluxes
-                   if ( .not. is_cwd( (cascade_receiver_pool(k)) ) ) then  !! not transition of cwd to litter
-                      if (cascade_receiver_pool(k) /= i_atm ) then  ! not 100% respiration
-                         ratio = 0._r8
-                         if (decomp_ppools_vr(c,j,k_donor_pool) > 0._r8) then
-                            ratio = cp_decomp_pools_new(fc,j,cascade_receiver_pool(k))/cp_decomp_pools(fc,j,k_donor_pool)
-                         endif
-                         pmpf_decomp_cascade(c,j,k) = (p_decomp_cpool_loss(fc,j,k) * (1.0_r8 - rf_decomp_cascade(c,j,k) - ratio) &
-                              / cp_decomp_pools_new(fc,j,cascade_receiver_pool(k)) )
-                      else   ! 100% respiration
-                         pmpf_decomp_cascade(c,j,k) = - p_decomp_cpool_loss(fc,j,k) / cp_decomp_pools(fc,j,k_donor_pool)
-                      endif
-                   else   ! CWD -> litter
-                      pmpf_decomp_cascade(c,j,k) = 0._r8
-                   end if
-                end if
-             end do
-          end do
-       end do
-       
-      !$acc enter data create(sum_1,sum_2,sum_3,sum_4)
-      !$acc  parallel loop independent gang collapse(2) default(present) private(c,sum_1,sum_2,sum_3,sum_4)
+
+      do k = 1, ndecomp_cascade_transitions
+         do j = 1,nlevdecomp
+            do fc = 1,num_soilc
+               c = filter_soilc(fc)
+
+               if (decomp_cpools_vr(c,j,cascade_donor_pool(k)) > 0._r8 .and. &
+                    decomp_k(c,j,cascade_donor_pool(k)) > 0._r8 ) then
+
+                 p_decomp_cpool_loss(c,j,k) = decomp_cpools_vr(c,j,cascade_donor_pool(k)) &
+                       * decomp_k(c,j,cascade_donor_pool(k))  * pathfrac_decomp_cascade(c,j,k)
+                  if ( .not. floating_cn_ratio_decomp_pools(cascade_receiver_pool(k)) ) then  !! not transition of cwd to litter
+
+                     if (cascade_receiver_pool(k) /= i_atm ) then  ! not 100% respiration
+                        ratio = 0._r8
+
+                        if (decomp_npools_vr(c,j,cascade_donor_pool(k)) > 0._r8) then
+                           ratio = cn_decomp_pools(c,j,cascade_receiver_pool(k))/cn_decomp_pools(c,j,cascade_donor_pool(k))
+                        endif
+                        pmnf_decomp_cascade(c,j,k) = (p_decomp_cpool_loss(c,j,k) * (1.0_r8 - rf_decomp_cascade(c,j,k) - ratio) &
+                             / cn_decomp_pools(c,j,cascade_receiver_pool(k)) )
+
+                     else   ! 100% respiration
+                        pmnf_decomp_cascade(c,j,k) = - p_decomp_cpool_loss(c,j,k) / cn_decomp_pools(c,j,cascade_donor_pool(k))
+                     endif
+
+                  else   ! CWD -> litter
+                     pmnf_decomp_cascade(c,j,k) = 0._r8
+                  end if
+                  !!! add phosphorus fluxes
+                  if ( .not. is_cwd( (cascade_receiver_pool(k)) ) ) then  !! not transition of cwd to litter
+
+                     if (cascade_receiver_pool(k) /= i_atm ) then  ! not 100% respiration
+                        ratio = 0._r8
+
+                        if (decomp_ppools_vr(c,j,cascade_donor_pool(k)) > 0._r8) then
+!                           ratio = cp_decomp_pools(c,j,cascade_receiver_pool(k))/cp_decomp_pools(c,j,cascade_donor_pool(k))
+                           ratio = cp_decomp_pools_new(c,j,cascade_receiver_pool(k))/cp_decomp_pools(c,j,cascade_donor_pool(k))
+                        endif
+
+                        pmpf_decomp_cascade(c,j,k) = (p_decomp_cpool_loss(c,j,k) * (1.0_r8 - rf_decomp_cascade(c,j,k) - ratio) &
+                             / cp_decomp_pools_new(c,j,cascade_receiver_pool(k)) )
+
+                     else   ! 100% respiration
+                        pmpf_decomp_cascade(c,j,k) = - p_decomp_cpool_loss(c,j,k) / cp_decomp_pools(c,j,cascade_donor_pool(k))
+                     endif
+
+                  else   ! CWD -> litter
+                     pmpf_decomp_cascade(c,j,k) = 0._r8
+                  end if
+
+               end if
+            end do
+         end do
+      end do
+
+      ! Sum up all the potential immobilization fluxes (positive pmnf flux)
+      ! and all the mineralization fluxes (negative pmnf flux)
       do j = 1,nlevdecomp
          do fc = 1,num_soilc
             c = filter_soilc(fc)
-            sum_1 = 0._r8
-            sum_2 = 0._r8
-            sum_3 = 0._r8
-            sum_4 = 0._r8
-            !$acc loop vector reduction(+:sum_1,sum_2,sum_3,sum_4)
-            do k = 1, ndecomp_cascade_transitions
+            immob(c,j) = 0._r8
+            immob_p(c,j) = 0._r8
+            gross_nmin_vr(c,j) = 0._r8
+            gross_pmin_vr(c,j) = 0._r8
+         end do
+      end do
+      do k = 1, ndecomp_cascade_transitions
+         do j = 1,nlevdecomp
+            do fc = 1,num_soilc
+               c = filter_soilc(fc)
                if (pmnf_decomp_cascade(c,j,k) > 0._r8) then
-                  sum_1 = sum_1 + pmnf_decomp_cascade(c,j,k)
+                  immob(c,j) = immob(c,j) + pmnf_decomp_cascade(c,j,k)
                else
-                  sum_2 = sum_2 - pmnf_decomp_cascade(c,j,k)
+                  gross_nmin_vr(c,j) = gross_nmin_vr(c,j) - pmnf_decomp_cascade(c,j,k)
                end if
                if (pmpf_decomp_cascade(c,j,k) > 0._r8) then
-                  sum_3 = sum_3 + pmpf_decomp_cascade(c,j,k)
+                  immob_p(c,j) = immob_p(c,j) + pmpf_decomp_cascade(c,j,k)
                else
-                  sum_4 = sum_4 - pmpf_decomp_cascade(c,j,k)
+                  gross_pmin_vr(c,j) = gross_pmin_vr(c,j) - pmpf_decomp_cascade(c,j,k)
                end if
             end do
-            immob(fc,j) = sum_1
-            gross_nmin_vr(c,j) = sum_2
-            immob_p(fc,j) = sum_3
-            gross_pmin_vr(c,j) = sum_4
          end do
       end do
 
-      !$acc parallel loop independent gang worker collapse(2) private(c,sum_1) default(present)
       do j = 1,nlevdecomp
          do fc = 1,num_soilc
             c = filter_soilc(fc)
-            sum_1 = 0._r8
-            !$acc loop vector reduction(+:sum_1)
-            do k = 1, ndecomp_cascade_transitions
-               sum_1 = sum_1 + rf_decomp_cascade(c,j,k) * p_decomp_cpool_loss(fc,j,k)
-            end do
-            phr_vr(c,j) = sum_1
+            potential_immob_vr(c,j) = immob(c,j)
+            potential_immob_p_vr(c,j) = immob_p(c,j)
          end do
       end do
-      
-      !$acc parallel loop independent gang  vector collapse(2) default(present) 
+
+      ! Add up potential hr for methane calculations
       do j = 1,nlevdecomp
          do fc = 1,num_soilc
             c = filter_soilc(fc)
-            potential_immob_vr(c,j) = immob(fc,j)
-            potential_immob_p_vr(c,j) = immob_p(fc,j)
+            phr_vr(c,j) = 0._r8
+         end do
+      end do
+      do k = 1, ndecomp_cascade_transitions
+         do j = 1,nlevdecomp
+            do fc = 1,num_soilc
+               c = filter_soilc(fc)
+               phr_vr(c,j) = phr_vr(c,j) + rf_decomp_cascade(c,j,k) * p_decomp_cpool_loss(c,j,k)
+            end do
          end do
       end do
 
-      !-------------------------------------------------------------------------------------------------
-      ! 'call decomp_vertprofiles()' (calc nfixation_prof) is moved to EcosystemDynNoLeaching1
-      ! 'nfixation_prof' is used in 'calc_nuptake_prof' & 'calc_puptake_prof', which are called in Allocation1,2,3
-      !-------------------------------------------------------------------------------------------------
-      call nitrif_denitrif( num_soilc,filter_soilc, &
-                     soilstate_vars,  ch4_vars )
+
+!-------------------------------------------------------------------------------------------------
+! 'call decomp_vertprofiles()' (calc nfixation_prof) is moved to EcosystemDynNoLeaching1
+! 'nfixation_prof' is used in 'calc_nuptake_prof' & 'calc_puptake_prof', which are called in Allocation1,2,3
+!-------------------------------------------------------------------------------------------------
+      call nitrif_denitrif(bounds, &
+           num_soilc, filter_soilc, &
+           soilstate_vars,  ch4_vars )
 
       ! now that potential N immobilization is known, call allocation
       ! to resolve the competition between plants and soil heterotrophs
       ! for available soil mineral N resource.
       ! in addition, calculate fpi_vr, fpi_p_vr, & fgp
-      call Allocation2_ResolveNPLimit(bounds,num_soilc, filter_soilc, &
-               cnstate_vars, soilstate_vars, dtime)
+      event = 'CNAllocation - phase-2'
+      call t_start_lnd(event)
+      call Allocation2_ResolveNPLimit(bounds,                       &
+               num_soilc, filter_soilc, num_soilp, filter_soilp,    &
+               cnstate_vars,                                        &
+               soilstate_vars, dtime,                               &
+               alm_fates)
+      call t_stop_lnd(event)
+
+
       ! column loop to calculate actual immobilization and decomp rates, following
       ! resolution of plant/heterotroph  competition for mineral N
-      !-------------------------------------------------------------------------------------------------
-      ! delete c:n,c:p ratios calculation, they have been calculated at the beginning of this subroutine
-      !-------------------------------------------------------------------------------------------------
-      ! upon return from CNAllocation, the fraction of potential immobilization
+
+
+          !-------------------------------------------------------------------------------------------------
+          ! delete c:n,c:p ratios calculation, they have been calculated at the beginning of this subroutine
+          !-------------------------------------------------------------------------------------------------
+
+          ! upon return from CNAllocation, the fraction of potential immobilization
       ! has been set (cnstate_vars%fpi_vr_col). now finish the decomp calculations.
       ! Only the immobilization steps are limited by fpi_vr (pmnf > 0)
       ! Also calculate denitrification losses as a simple proportion
       ! of mineralization flux.
 
-      !$acc parallel loop independent gang worker collapse(2) default(present)
       do k = 1, ndecomp_cascade_transitions
          do j = 1,nlevdecomp
-            !$acc loop vector private(c,k_donor_pool)
             do fc = 1,num_soilc
-               k_donor_pool = cascade_donor_pool(k)
                c = filter_soilc(fc)
 
-               if (decomp_cpools_vr(c,j,k_donor_pool) > 0._r8) then
+               if (decomp_cpools_vr(c,j,cascade_donor_pool(k)) > 0._r8) then
                   if ( pmnf_decomp_cascade(c,j,k) > 0._r8 .and. pmpf_decomp_cascade(c,j,k) > 0._r8 ) then    ! N and P co-limitation
-                     p_decomp_cpool_loss(fc,j,k) = p_decomp_cpool_loss(fc,j,k) * min( fpi_vr(c,j),fpi_p_vr(c,j) )
+                     p_decomp_cpool_loss(c,j,k) = p_decomp_cpool_loss(c,j,k) * min( fpi_vr(c,j),fpi_p_vr(c,j) )
                      pmnf_decomp_cascade(c,j,k) = pmnf_decomp_cascade(c,j,k) * min( fpi_vr(c,j),fpi_p_vr(c,j) )
                      pmpf_decomp_cascade(c,j,k) = pmpf_decomp_cascade(c,j,k) * min( fpi_vr(c,j),fpi_p_vr(c,j) )   !!! immobilization step
-                  elseif ( pmnf_decomp_cascade(c,j,k) > 0._r8 .and. pmpf_decomp_cascade(c,j,k) <= 0._r8 ) then  ! N limitation
-                     p_decomp_cpool_loss(fc,j,k) = p_decomp_cpool_loss(fc,j,k) * fpi_vr(c,j)
+                  elseif ( pmnf_decomp_cascade(c,j,k) > 0._r8 .and. pmpf_decomp_cascade(c,j,k) <= 0._r8 ) then  ! N limitation 
+                     p_decomp_cpool_loss(c,j,k) = p_decomp_cpool_loss(c,j,k) * fpi_vr(c,j)
                      pmnf_decomp_cascade(c,j,k) = pmnf_decomp_cascade(c,j,k) * fpi_vr(c,j)
                      pmpf_decomp_cascade(c,j,k) = pmpf_decomp_cascade(c,j,k) * fpi_vr(c,j) !!! immobilization step
-                  elseif ( pmnf_decomp_cascade(c,j,k) <= 0._r8 .and. pmpf_decomp_cascade(c,j,k) >  0._r8 ) then  ! P limitation
-                     p_decomp_cpool_loss(fc,j,k) = p_decomp_cpool_loss(fc,j,k) * fpi_p_vr(c,j)
+                  elseif ( pmnf_decomp_cascade(c,j,k) <= 0._r8 .and. pmpf_decomp_cascade(c,j,k) >  0._r8 ) then  ! P limitation 
+                     p_decomp_cpool_loss(c,j,k) = p_decomp_cpool_loss(c,j,k) * fpi_p_vr(c,j)
                      pmnf_decomp_cascade(c,j,k) = pmnf_decomp_cascade(c,j,k) * fpi_p_vr(c,j)
                      pmpf_decomp_cascade(c,j,k) = pmpf_decomp_cascade(c,j,k) * fpi_p_vr(c,j) !!! immobilization step
                   end if
-                  decomp_cascade_hr_vr(c,j,k) = rf_decomp_cascade(c,j,k) * p_decomp_cpool_loss(fc,j,k)
-                  decomp_cascade_ctransfer_vr(c,j,k) = (1._r8 - rf_decomp_cascade(c,j,k)) * p_decomp_cpool_loss(fc,j,k)
-                  if (decomp_npools_vr(c,j,k_donor_pool) > 0._r8 .and. cascade_receiver_pool(k) /= i_atm) then
-                     decomp_cascade_ntransfer_vr(c,j,k) = p_decomp_cpool_loss(fc,j,k) / cn_decomp_pools(fc,j,k_donor_pool)
+                  decomp_cascade_hr_vr(c,j,k) = rf_decomp_cascade(c,j,k) * p_decomp_cpool_loss(c,j,k)
+                  decomp_cascade_ctransfer_vr(c,j,k) = (1._r8 - rf_decomp_cascade(c,j,k)) * p_decomp_cpool_loss(c,j,k)
+                  if (decomp_npools_vr(c,j,cascade_donor_pool(k)) > 0._r8 .and. cascade_receiver_pool(k) /= i_atm) then
+                     decomp_cascade_ntransfer_vr(c,j,k) = p_decomp_cpool_loss(c,j,k) / cn_decomp_pools(c,j,cascade_donor_pool(k))
                   else
                      decomp_cascade_ntransfer_vr(c,j,k) = 0._r8
                   endif
                   !!! phosphorus fluxes
-                  if (decomp_ppools_vr(c,j,k_donor_pool) > 0._r8 .and. cascade_receiver_pool(k) /= i_atm) then
-                     decomp_cascade_ptransfer_vr(c,j,k) = p_decomp_cpool_loss(fc,j,k) / cp_decomp_pools(fc,j,k_donor_pool)
+                  if (decomp_ppools_vr(c,j,cascade_donor_pool(k)) > 0._r8 .and. cascade_receiver_pool(k) /= i_atm) then
+                     decomp_cascade_ptransfer_vr(c,j,k) = p_decomp_cpool_loss(c,j,k) / cp_decomp_pools(c,j,cascade_donor_pool(k))
                   else
                      decomp_cascade_ptransfer_vr(c,j,k) = 0._r8
                   endif
@@ -409,7 +449,8 @@ contains
                      decomp_cascade_sminn_flux_vr(c,j,k) = - pmnf_decomp_cascade(c,j,k)
                      decomp_cascade_sminp_flux_vr(c,j,k) = - pmpf_decomp_cascade(c,j,k)
                   endif
-
+                  net_nmin_vr(c,j) = net_nmin_vr(c,j) - pmnf_decomp_cascade(c,j,k)
+                  net_pmin_vr(c,j) = net_pmin_vr(c,j) - pmpf_decomp_cascade(c,j,k)
                else
                   decomp_cascade_ntransfer_vr(c,j,k) = 0._r8
                   decomp_cascade_ptransfer_vr(c,j,k) = 0._r8
@@ -421,46 +462,30 @@ contains
          end do
       end do
 
-
-      !$acc parallel loop independent gang worker collapse(2) private(c,sum_1,sum_2) default(present)
-      do j = 1,nlevdecomp
+      if (nu_com .eq. 'RD') then
          do fc = 1,num_soilc
             c = filter_soilc(fc)
-            sum_1 = 0._r8
-            sum_2 = 0._r8
-            !$acc loop vector reduction(+:sum_1,sum_2)
-            do k = 1, ndecomp_cascade_transitions
-               sum_1 = sum_1 - pmnf_decomp_cascade(c,j,k)
-               sum_2 = sum_2 - pmpf_decomp_cascade(c,j,k)
+            do j = 1,nlevdecomp
+                gross_nmin_vr(c,j) = 0.0_r8
+                gross_pmin_vr(c,j) = 0.0_r8
             end do
-            net_nmin_vr(c,j) = sum_1
-            net_pmin_vr(c,j) = sum_2
          end do
-      end do
-
-      if (nu_com .eq. 'RD') then
-         !$acc parallel loop independent gang worker collapse(2) private(c,sum_1,sum_2)
-         do j = 1,nlevdecomp
-            do fc = 1,num_soilc
-               c = filter_soilc(fc)
-               sum_1 = 0.0_r8
-               sum_2 = 0.0_r8
-               !$acc loop vector reduction(+:sum_1,sum_2)
-               do k = 1, ndecomp_cascade_transitions
+         do k = 1, ndecomp_cascade_transitions
+            do j = 1,nlevdecomp
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
                   if (pmnf_decomp_cascade(c,j,k) <= 0._r8) then
-                      sum_1 = sum_1 - 1.0_r8*pmnf_decomp_cascade(c,j,k)
+                      gross_nmin_vr(c,j) = gross_nmin_vr(c,j) - 1.0_r8*pmnf_decomp_cascade(c,j,k)
                   end if
                   if (pmpf_decomp_cascade(c,j,k) <= 0._r8) then
-                      sum_2 = sum_2 - 1.0_r8*pmpf_decomp_cascade(c,j,k)
+                      gross_pmin_vr(c,j) = gross_pmin_vr(c,j) - 1.0_r8*pmpf_decomp_cascade(c,j,k)
                   end if
-               end do
-               gross_nmin_vr(c,j) = sum_1
-               gross_pmin_vr(c,j) = sum_2
+                end do
              end do
           end do
       end if
 
-   if (nu_com .ne. 'RD') then
+      if (nu_com .ne. 'RD') then
       do fc = 1,num_soilc
           c = filter_soilc(fc)
           soil_n_immob_flux(c) =0.0_r8
@@ -494,36 +519,51 @@ contains
                end if
              end do
           end do
-      end do
-   end if
+       end do
+       end if
 
       if (use_lch4) then
-         !$acc parallel loop independent gang worker collapse(2) private(c,sum_1) default(present)
+         ! Calculate total fraction of potential HR, for methane code
          do j = 1,nlevdecomp
             do fc = 1,num_soilc
-               ! Calculate total fraction of potential HR, for methane code
                c = filter_soilc(fc)
-               sum_1 = 0.0_r8
-               if(phr_vr(c,j) > 0._r8) then
-                  !$acc loop vector reduction(+:sum_1)
-                  do k = 1, ndecomp_cascade_transitions
-                     sum_1 = sum_1 + rf_decomp_cascade(c,j,k) * p_decomp_cpool_loss(fc,j,k)
-                  end do
-                  ! Nitrogen limitation / (low)-moisture limitation
-                  fphr(c,j) = sum_1/phr_vr(c,j)* w_scalar(c,j)
-                  fphr(c,j) = max(fphr(c,j),0.01_r8) ! Prevent overflow errors for 0 respiration
+               hrsum(c,j) = 0._r8
+            end do
+         end do
+         do k = 1, ndecomp_cascade_transitions
+            do j = 1,nlevdecomp
+               do fc = 1,num_soilc
+                  c = filter_soilc(fc)
+                  hrsum(c,j) = hrsum(c,j) + rf_decomp_cascade(c,j,k) * p_decomp_cpool_loss(c,j,k)
+               end do
+            end do
+         end do
+
+         ! Nitrogen limitation / (low)-moisture limitation
+         do j = 1,nlevdecomp
+            do fc = 1,num_soilc
+               c = filter_soilc(fc)
+               if (phr_vr(c,j) > 0._r8) then
+                  fphr(c,j) = hrsum(c,j) / phr_vr(c,j) * w_scalar(c,j)
+                  fphr(c,j) = max(fphr(c,j), 0.01_r8) ! Prevent overflow errors for 0 respiration
                else
                   fphr(c,j) = 1._r8
                end if
             end do
          end do
-
       end if
 
-      !$acc exit data delete(sum_1,sum_2,sum_3,sum_4)
-      !$acc exit data delete(cn_decomp_pools(:,:,:), p_decomp_cpool_loss(:,:,:), &
-      !$acc   cp_decomp_pools(:,:,:),immob(:,:) ,immob_p(:,:) , &
-      !$acc   cp_decomp_pools_new(:,:,:) )
+      ! vertically integrate net and gross mineralization fluxes for diagnostic output
+      ! moved to SoilLittDecompAlloc2
+!      do j = 1,nlevdecomp
+!         do fc = 1,num_soilc
+!            c = filter_soilc(fc)
+!            net_nmin(c) = net_nmin(c) + net_nmin_vr(c,j) * dzsoi_decomp(j)
+!            gross_nmin(c) = gross_nmin(c) + gross_nmin_vr(c,j) * dzsoi_decomp(j)
+!            net_pmin(c) = net_pmin(c) + net_pmin_vr(c,j) * dzsoi_decomp(j)
+!            gross_pmin(c) = gross_pmin(c) + gross_pmin_vr(c,j) * dzsoi_decomp(j)
+!         end do
+!      end do
 
     end associate
 
@@ -531,9 +571,9 @@ contains
 
 !-------------------------------------------------------------------------------------------------
 
-  subroutine SoilLittDecompAlloc2 ( num_soilc, filter_soilc, num_soilp, filter_soilp,   &
-        canopystate_vars, soilstate_vars,          &
-       cnstate_vars, crop_vars,  dt)
+  subroutine SoilLittDecompAlloc2 (bounds, num_soilc, filter_soilc, num_soilp, filter_soilp,   &
+       photosyns_vars, canopystate_vars, soilstate_vars,          &
+       cnstate_vars, ch4_vars, crop_vars, atm2lnd_vars, dt)
     !-----------------------------------------------------------------------------
     ! DESCRIPTION:
     ! bgc interface & pflotran:
@@ -543,31 +583,37 @@ contains
     !-----------------------------------------------------------------------------
 
     ! !USES:
+      !$acc routine seq
     use AllocationMod , only: Allocation3_PlantCNPAlloc ! Phase-3 of CNAllocation
+    use atm2lndType     , only: atm2lnd_type
+
     !
     ! !ARGUMENT:
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc          ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:)    ! filter for soil columns
     integer                  , intent(in)    :: num_soilp          ! number of soil patches in filter
     integer                  , intent(in)    :: filter_soilp(:)    ! filter for soil patches
+    type(photosyns_type)     , intent(in)    :: photosyns_vars
     type(canopystate_type)   , intent(in)    :: canopystate_vars
     type(soilstate_type)     , intent(in)    :: soilstate_vars
     type(cnstate_type)       , intent(inout) :: cnstate_vars
+    type(ch4_type)           , intent(in)    :: ch4_vars
     type(crop_type)          , intent(inout) :: crop_vars
+    type(atm2lnd_type)       , intent(in)    :: atm2lnd_vars
     real(r8), intent(in) :: dt                                           ! time step (seconds)
 
     !
     ! !LOCAL VARIABLES:
     integer :: fc, c, j                                     ! indices
-    !real(r8):: col_plant_ndemand(bounds%begc:bounds%endc)   ! column-level vertically-integrated plant N demand (gN/m2/s)
-    real(r8) :: smin_nh4_to_plant_vr_loc(1:num_soilc,1:nlevdecomp)
-    real(r8) :: smin_no3_to_plant_vr_loc(1:num_soilc,1:nlevdecomp)
+!    real(r8):: col_plant_ndemand(bounds%begc:bounds%endc)   ! column-level vertically-integrated plant N demand (gN/m2/s)
+    real(r8) :: smin_nh4_to_plant_vr_loc(bounds%begc:bounds%endc,1:nlevdecomp)
+    real(r8) :: smin_no3_to_plant_vr_loc(bounds%begc:bounds%endc,1:nlevdecomp)
 
     ! For methane code
-    real(r8):: hrsum(1:num_soilc,1:nlevdecomp) !sum of HR (gC/m2/s)
-    real(r8):: sum1,sum2,sum3,sum4
+    real(r8):: hrsum(bounds%begc:bounds%endc,1:nlevdecomp)                                             !sum of HR (gC/m2/s)
 
-    character(len=64) :: event
+    character(len=256) :: event
     !-----------------------------------------------------------------------
 
     associate(                                                                                      &
@@ -581,6 +627,7 @@ contains
          gross_pmin                       =>    col_pf%gross_pmin                     , & ! Output: [real(r8) (:)     ]  gross rate of P mineralization (gP/m2/s)
          net_pmin                         =>    col_pf%net_pmin                       , & ! Output: [real(r8) (:)     ]  net rate of P mineralization (gP/m2/s)
 
+
          fpi_vr                           =>    cnstate_vars%fpi_vr_col                                , & ! Output:  [real(r8) (:,:)   ]  fraction of potential immobilization (no units)
          fpi                              =>    cnstate_vars%fpi_col                                   , & ! Output: [real(r8) (:)   ]  fraction of potential immobilization (no units)
          potential_immob_vr               =>    col_nf%potential_immob_vr               , & ! Input:
@@ -612,15 +659,15 @@ contains
          )
 
       ! set time steps
-      !------------------------------------------------------------------
-      ! 'call decomp_vertprofiles()' moved to EcosystemDynNoLeaching1
-      !------------------------------------------------------------------
+            !------------------------------------------------------------------
+            ! 'call decomp_vertprofiles()' moved to EcosystemDynNoLeaching1
+            !------------------------------------------------------------------
+            smin_nh4_to_plant_vr_loc(:,:) = 0._r8
+            smin_no3_to_plant_vr_loc(:,:) = 0._r8
+
 
       ! MUST have already updated needed bgc variables from PFLOTRAN by this point
       if(use_elm_interface.and.use_pflotran.and.pf_cmode) then
-         smin_nh4_to_plant_vr_loc(1:num_soilc,:) = 0._r8
-         smin_no3_to_plant_vr_loc(1:num_soilc,:) = 0._r8
-
          ! fpg calculation
          do fc=1,num_soilc
             c = filter_soilc(fc)
@@ -683,7 +730,7 @@ contains
             do j = 1,nlevdecomp
                do fc = 1,num_soilc
                   c = filter_soilc(fc)
-                  hrsum(fc,j) = hr_vr(c,j)
+                  hrsum(c,j) = hr_vr(c,j)
                end do
             end do
 
@@ -692,7 +739,7 @@ contains
                do fc = 1,num_soilc
                   c = filter_soilc(fc)
                   if (phr_vr(c,j) > 0._r8) then
-                     fphr(c,j) = hrsum(fc,j) / phr_vr(c,j) * w_scalar(c,j)
+                     fphr(c,j) = hrsum(c,j) / phr_vr(c,j) * w_scalar(c,j)
                      fphr(c,j) = max(fphr(c,j), 0.01_r8) ! Prevent overflow errors for 0 respiration
                   else
                      fphr(c,j) = 1._r8
@@ -701,41 +748,43 @@ contains
             end do
          end if
 
-         ! ! needs to zero CLM-CNP variables NOT available from pflotran bgc coupling
-         ! call CNvariables_nan4pf(num_soilc, filter_soilc, &
-         !                num_soilp, filter_soilp)
+         ! needs to zero CLM-CNP variables NOT available from pflotran bgc coupling
+         call CNvariables_nan4pf(bounds, num_soilc, filter_soilc, &
+                        num_soilp, filter_soilp)
 
          ! save variables before updating
          do fc = 1,num_soilc
             c = filter_soilc(fc)
             do j = 1,nlevdecomp
-                smin_no3_to_plant_vr_loc(fc,j) = smin_no3_to_plant_vr(c,j)
-                smin_nh4_to_plant_vr_loc(fc,j) = smin_nh4_to_plant_vr(c,j)
+                smin_no3_to_plant_vr_loc(c,j) = smin_no3_to_plant_vr(c,j)
+                smin_nh4_to_plant_vr_loc(c,j) = smin_nh4_to_plant_vr(c,j)
             end do
          end do
 
       end if !if(use_elm_interface.and.use_pflotran.and.pf_cmode)
+
       !------------------------------------------------------------------
       ! phase-3 Allocation for plants
       if(.not.use_fates)then
-        ! event = 'CNAllocation - phase-3'
-        !call t_start_lnd(event)
-        call Allocation3_PlantCNPAlloc( &
+        event = 'CNAllocation - phase-3'
+        call t_start_lnd(event)
+        call Allocation3_PlantCNPAlloc (bounds                      , &
                   num_soilc, filter_soilc, num_soilp, filter_soilp    , &
                   canopystate_vars                                    , &
                   cnstate_vars, crop_vars, dt)
-        !call t_stop_lnd(event)
+        call t_stop_lnd(event)
       end if
       !------------------------------------------------------------------
+
     if(use_pflotran.and.pf_cmode) then
-      ! in Allocation3_PlantCNPAlloc():
-      ! smin_nh4_to_plant_vr(c,j), smin_no3_to_plant_vr(c,j), sminn_to_plant_vr(c,j) may be adjusted
-      ! therefore, we need to update smin_no3_vr(c,j) & smin_nh4_vr(c,j)
+    ! in Allocation3_PlantCNPAlloc():
+    ! smin_nh4_to_plant_vr(c,j), smin_no3_to_plant_vr(c,j), sminn_to_plant_vr(c,j) may be adjusted
+    ! therefore, we need to update smin_no3_vr(c,j) & smin_nh4_vr(c,j)
       do fc = 1,num_soilc
            c = filter_soilc(fc)
            do j = 1,nlevdecomp
-               smin_no3_vr(c,j) = smin_no3_vr(c,j) - (smin_no3_to_plant_vr(c,j) - smin_no3_to_plant_vr_loc(fc,j))*dt
-               smin_nh4_vr(c,j) = smin_nh4_vr(c,j) - (smin_nh4_to_plant_vr(c,j) - smin_nh4_to_plant_vr_loc(fc,j))*dt
+               smin_no3_vr(c,j) = smin_no3_vr(c,j) - (smin_no3_to_plant_vr(c,j) - smin_no3_to_plant_vr_loc(c,j))*dt
+               smin_nh4_vr(c,j) = smin_nh4_vr(c,j) - (smin_nh4_to_plant_vr(c,j) - smin_nh4_to_plant_vr_loc(c,j))*dt
                smin_no3_vr(c,j) = max(0._r8, smin_no3_vr(c,j))
                smin_nh4_vr(c,j) = max(0._r8, smin_nh4_vr(c,j))
             end do
@@ -743,29 +792,24 @@ contains
     end if !(use_pflotran.and.pf_cmode)
     !------------------------------------------------------------------
       ! vertically integrate net and gross mineralization fluxes for diagnostic output
-      !$acc enter data create(sum1,sum2,sum3,sum4)
-
-      !$acc parallel loop independent gang worker private(c,sum1,sum2,sum3,sum4)
-      do fc = 1,num_soilc
+      do fc=1,num_soilc
          c = filter_soilc(fc)
-         sum1 = 0.0_r8; sum2 =0.0_r8;
-         sum3 = 0.0_r8; sum4 = 0.0_r8;
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4)
-         do j = 1,nlevdecomp
-            sum1 = sum1 + net_nmin_vr(c,j) * dzsoi_decomp(j)
-            sum2 = sum2 + gross_nmin_vr(c,j) * dzsoi_decomp(j)
+         net_nmin(c)    = 0._r8
+         gross_nmin(c)  = 0._r8
+         net_pmin(c)    = 0._r8
+         gross_pmin(c)  = 0._r8
+      end do
+      do j = 1,nlevdecomp
+         do fc = 1,num_soilc
+            c = filter_soilc(fc)
+            net_nmin(c) = net_nmin(c) + net_nmin_vr(c,j) * dzsoi_decomp(j)
+            gross_nmin(c) = gross_nmin(c) + gross_nmin_vr(c,j) * dzsoi_decomp(j)
             !phosphorus
-            sum3 = sum3 + net_pmin_vr(c,j) * dzsoi_decomp(j)
-            sum4 = sum4 + gross_pmin_vr(c,j) * dzsoi_decomp(j)
+            net_pmin(c) = net_pmin(c) + net_pmin_vr(c,j) * dzsoi_decomp(j)
+            gross_pmin(c) = gross_pmin(c) + gross_pmin_vr(c,j) * dzsoi_decomp(j)
          end do
-         net_nmin(c)   = sum1
-         gross_nmin(c) = sum2
-         net_pmin(c)   = sum3
-         gross_pmin(c) = sum4
       end do
-      !$acc exit data delete(sum1,sum2,sum3,sum4) 
     end associate
-
   end subroutine SoilLittDecompAlloc2
 
   !-------------------------------------------------------------------------------------------------
@@ -777,10 +821,9 @@ contains
   !  if not properly set.
   !
   !USES:
+    !$acc routine seq
     use elm_varctl   , only: carbon_only, carbonnitrogen_only
     use elm_varpar   , only: nlevdecomp, ndecomp_cascade_transitions
-    use ColumnDataType     , only : col_ps_setvalues, col_pf_setvalues
-    use VegetationDataType , only : veg_ps_setvalues, veg_pf_setvalues
    !
    !ARGUMENTS:
     type(bounds_type)        , intent(in)    :: bounds
@@ -817,15 +860,16 @@ contains
 
    ! pflotran not yet support phosphous cycle
    if ( carbon_only .or.  carbonnitrogen_only  ) then
-      call veg_ps_SetValues(veg_ps,num_patch=num_soilp,  filter_patch=filter_soilp,  value_patch=0._r8)
-      call col_ps_SetValues(col_ps,num_column=num_soilc, filter_column=filter_soilc, value_column=0._r8)
+      call veg_ps%SetValues(num_patch=num_soilp,  filter_patch=filter_soilp,  value_patch=0._r8)
+      call col_ps%SetValues(num_column=num_soilc, filter_column=filter_soilc, value_column=0._r8)
 
-      call veg_pf_setvalues(veg_pf,num_patch=num_soilp,  filter_patch=filter_soilp,  value_patch=0._r8)
-      call col_pf_setvalues(col_pf,num_column=num_soilc, filter_column=filter_soilc, value_column=0._r8)
+      call veg_pf%setvalues( num_patch=num_soilp,  filter_patch=filter_soilp,  value_patch=0._r8)
+      call col_pf%setvalues( num_column=num_soilc, filter_column=filter_soilc, value_column=0._r8)
    end if
 
-
   end associate
   end subroutine CNvariables_nan4pf
 
+  !-------------------------------------------------------------------------------------------------
+
 end module SoilLittDecompMod
diff --git a/components/elm/src/biogeochem/SoilLittVertTranspMod.F90 b/components/elm/src/biogeochem/SoilLittVertTranspMod.F90
index a68b5f70f6..90c2d57f9f 100644
--- a/components/elm/src/biogeochem/SoilLittVertTranspMod.F90
+++ b/components/elm/src/biogeochem/SoilLittVertTranspMod.F90
@@ -22,10 +22,9 @@ module SoilLittVertTranspMod
   save
   !
   public :: SoilLittVertTransp
-  public :: createLitterTransportList
   public :: readSoilLittVertTranspParams
 
-  type, public :: SoilLittVertTranspParamsType
+  type, private :: SoilLittVertTranspParamsType
      real(r8),pointer  :: som_diffus                => null() ! Soil organic matter diffusion
      real(r8),pointer  :: cryoturb_diffusion_k      => null() ! The cryoturbation diffusive constant cryoturbation to the active layer thickness
      real(r8),pointer  :: max_altdepth_cryoturbation => null() ! (m) maximum active layer thickness for cryoturbation to occur
@@ -34,16 +33,7 @@ module SoilLittVertTranspMod
   type(SoilLittVertTranspParamsType), public ::  SoilLittVertTranspParamsInst
   !$acc declare create(SoilLittVertTranspParamsInst)
 
-  type, public :: ConcTransportType
-
-     real(r8), pointer :: conc_ptr(:,:,:) => null()
-     real(r8), pointer :: src_ptr(:,:,:)  => null()
-     real(r8), pointer :: trcr_tend_ptr(:,:,:) => null()
-
-  end type ConcTransportType
-  type(ConcTransportType), public, allocatable :: transport_ptr_list(:)
-  !$acc declare create(transport_ptr_list(:))
-
+  !
   real(r8), public :: som_adv_flux =  0._r8
   !$acc declare copyin(som_adv_flux)
   real(r8), public :: max_depth_cryoturb = 3._r8   ! (m) this is the maximum depth of cryoturbation
@@ -51,66 +41,13 @@ module SoilLittVertTranspMod
   real(r8) :: som_diffus                   ! [m^2/sec] = 1 cm^2 / yr
   real(r8) :: cryoturb_diffusion_k         ! [m^2/sec] = 5 cm^2 / yr = 1m^2 / 200 yr
   real(r8) :: max_altdepth_cryoturbation   ! (m) maximum active layer thickness for cryoturbation to occur
+  !$acc declare create(som_diffus                )
+  !$acc declare create(cryoturb_diffusion_k      )
+  !$acc declare create(max_altdepth_cryoturbation)
   !-----------------------------------------------------------------------
 
 contains
 
-   subroutine createLitterTransportList()
-      ! This subroutine creates a list that will point to the
-      ! litter/som fields needed for the vertical transport
-      ! calculations.
-
-      implicit none
-
-      integer :: ntype
-
-      ntype = 3
-      if ( use_c13 ) then
-         ntype = ntype+1
-      endif
-      if ( use_c14 ) then
-         ntype = ntype+1
-      endif
-
-      allocate(transport_ptr_list(ntype))
-      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-      ! C
-      transport_ptr_list(1)%conc_ptr        => col_cs%decomp_cpools_vr
-      transport_ptr_list(1)%src_ptr         => col_cf%decomp_cpools_sourcesink
-      transport_ptr_list(1)%trcr_tend_ptr   => col_cf%decomp_cpools_transport_tendency
-      ! N
-      transport_ptr_list(2)%conc_ptr        => col_ns%decomp_npools_vr
-      transport_ptr_list(2)%src_ptr         => col_nf%decomp_npools_sourcesink
-      transport_ptr_list(2)%trcr_tend_ptr   => col_nf%decomp_npools_transport_tendency
-      ! P
-      transport_ptr_list(3)%conc_ptr        => col_ps%decomp_ppools_vr
-      transport_ptr_list(3)%src_ptr         => col_pf%decomp_ppools_sourcesink
-      transport_ptr_list(3)%trcr_tend_ptr   => col_pf%decomp_ppools_transport_tendency
-      ! c13 and c14 if there
-      if(use_c14 .and. use_c13) then
-         !
-         transport_ptr_list(4)%conc_ptr       => c13_col_cs%decomp_cpools_vr
-         transport_ptr_list(4)%src_ptr        => c13_col_cf%decomp_cpools_sourcesink
-         transport_ptr_list(4)%trcr_tend_ptr  => c13_col_cf%decomp_cpools_transport_tendency
-         !
-         transport_ptr_list(5)%conc_ptr       => c14_col_cs%decomp_cpools_vr
-         transport_ptr_list(5)%src_ptr        => c14_col_cf%decomp_cpools_sourcesink
-         transport_ptr_list(5)%trcr_tend_ptr  => c14_col_cf%decomp_cpools_transport_tendency
-      else
-         if(use_c13) then
-            transport_ptr_list(4)%conc_ptr       => c13_col_cs%decomp_cpools_vr
-            transport_ptr_list(4)%src_ptr        => c13_col_cf%decomp_cpools_sourcesink
-            transport_ptr_list(4)%trcr_tend_ptr  => c13_col_cf%decomp_cpools_transport_tendency
-         end if
-         if (use_c14) then
-            transport_ptr_list(4)%conc_ptr       => c14_col_cs%decomp_cpools_vr
-            transport_ptr_list(4)%src_ptr        => c14_col_cf%decomp_cpools_sourcesink
-            transport_ptr_list(4)%trcr_tend_ptr  => c14_col_cf%decomp_cpools_transport_tendency
-         end if
-      end if
-
-   end subroutine createLitterTransportList
-
   !-----------------------------------------------------------------------
   subroutine readSoilLittVertTranspParams ( ncid )
     !
@@ -155,16 +92,8 @@ contains
     !$acc enter data copyin(SoilLittVertTranspParamsInst)
   end subroutine readSoilLittVertTranspParams
 
-  function aaa(pe) result(res)
-     !$acc routine seq
-     implicit none
-     real(r8) :: res
-     real(r8) :: pe
-     res =  max (0._r8, (1._r8 - 0.1_r8 * abs(pe))**5)
-  end function
-
   !-----------------------------------------------------------------------
-  subroutine SoilLittVertTransp(num_soilc, filter_soilc,   &
+  subroutine SoilLittVertTransp(bounds, num_soilc, filter_soilc,   &
        canopystate_vars, cnstate_vars )
     !
     ! !DESCRIPTION:
@@ -174,45 +103,59 @@ contains
     ! Initial code by C. Koven and W. Riley
     !
     ! !USES:
+      !$acc routine seq
     use elm_varpar       , only : nlevdecomp, ndecomp_pools, nlevdecomp_full
     use elm_varcon       , only : zsoi, dzsoi_decomp, zisoi
+    use TridiagonalMod   , only : Tridiagonal
     !
     ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc        ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:)  ! filter for soil columns
     type(canopystate_type)   , intent(in)    :: canopystate_vars
     type(cnstate_type)       , intent(inout) :: cnstate_vars
+    real(r8) :: dtime  ! land model time step (sec)
+    integer  :: year, mon, day, secs
+
     !
     ! !LOCAL VARIABLES:
-    real(r8) :: pe          ! Pe for "A" function in Patankar
-    real(r8) :: w_m1, w_p1  ! Weights for calculating harmonic mean of diffusivity
-    real(r8) :: d_m1, d_p1  ! Harmonic mean of diffusivity
-    real(r8) :: d_p1_zp1    ! diffusivity/delta_z for next j  (set to zero for no diffusion)
-    real(r8) :: d_m1_zm1    ! diffusivity/delta_z for previous j (set to zero for no diffusion)
-    real(r8) :: pe_p1       ! Peclet # for next j
-    real(r8) :: pe_m1       ! Peclet # for previous j
-    real(r8) :: dz_node,dz_nodep1          ! difference between nodes
+    real(r8) :: diffus (bounds%begc:bounds%endc,1:nlevdecomp+1)    ! diffusivity (m2/s)  (includes spinup correction, if any)
+    real(r8) :: adv_flux(bounds%begc:bounds%endc,1:nlevdecomp+1)   ! advective flux (m/s)  (includes spinup correction, if any)
+    real(r8) :: aaa                                                ! "A" function in Patankar
+    real(r8) :: pe                                                 ! Pe for "A" function in Patankar
+    real(r8) :: w_m1, w_p1                                         ! Weights for calculating harmonic mean of diffusivity
+    real(r8) :: d_m1, d_p1                                         ! Harmonic mean of diffusivity
+    real(r8) :: a_tri(bounds%begc:bounds%endc,0:nlevdecomp+1)      ! "a" vector for tridiagonal matrix
+    real(r8) :: b_tri(bounds%begc:bounds%endc,0:nlevdecomp+1)      ! "b" vector for tridiagonal matrix
+    real(r8) :: c_tri(bounds%begc:bounds%endc,0:nlevdecomp+1)      ! "c" vector for tridiagonal matrix
+    real(r8) :: r_tri(bounds%begc:bounds%endc,0:nlevdecomp+1)      ! "r" vector for tridiagonal solution
+    real(r8) :: d_p1_zp1(bounds%begc:bounds%endc,1:nlevdecomp+1)   ! diffusivity/delta_z for next j  (set to zero for no diffusion)
+    real(r8) :: d_m1_zm1(bounds%begc:bounds%endc,1:nlevdecomp+1)   ! diffusivity/delta_z for previous j (set to zero for no diffusion)
+    real(r8) :: f_p1(bounds%begc:bounds%endc,1:nlevdecomp+1)       ! water flux for next j
+    real(r8) :: f_m1(bounds%begc:bounds%endc,1:nlevdecomp+1)       ! water flux for previous j
+    real(r8) :: pe_p1(bounds%begc:bounds%endc,1:nlevdecomp+1)      ! Peclet # for next j
+    real(r8) :: pe_m1(bounds%begc:bounds%endc,1:nlevdecomp+1)      ! Peclet # for previous j
+    real(r8) :: dz_node(1:nlevdecomp+1)                            ! difference between nodes
+    real(r8) :: epsilon_t (bounds%begc:bounds%endc,1:nlevdecomp+1,1:ndecomp_pools) !
+    real(r8) :: conc_trcr(bounds%begc:bounds%endc,0:nlevdecomp+1)                  !
+    real(r8), pointer :: conc_ptr(:,:,:)                           ! pointer, concentration state variable being transported
+    real(r8), pointer :: source(:,:,:)                             ! pointer, source term
+    real(r8), pointer :: trcr_tendency_ptr(:,:,:)                  ! poiner, store the vertical tendency (gain/loss due to vertical transport)
     real(r8) :: a_p_0
+    real(r8) :: deficit
     integer  :: ntype
-    integer  :: i_type,s,fc,c,j,l  ! indices
-    integer  :: jtop(num_soilc)    ! top level at each column
-    real(r8) :: spinup_term                  ! spinup accelerated decomposition factor, used to accelerate transport as well
-    real(r8), parameter :: epsilon=1.e-30     ! small number
-    !!added to remove arrays:
-    real(r8) :: diffus_j, diffus_jm1, diffus_jp1 ! diffusivity (m2/s)  (includes spinup correction, if any)
-    real(r8) :: adv_flux_j,adv_flux_jm1, adv_flux_jp1        ! advective flux (m/s)  (includes spinup correction, if any)
-    real(r8) :: a_tri(num_soilc,0:nlevdecomp+1,ndecomp_pools)      ! "a" vector for tridiagonal matrix
-    real(r8) :: b_tri(num_soilc,0:nlevdecomp+1,ndecomp_pools)      ! "b" vector for tridiagonal matrix
-    real(r8) :: c_tri(num_soilc,0:nlevdecomp+1,ndecomp_pools)      ! "c" vector for tridiagonal matrix
-    real(r8) :: r_tri(num_soilc,0:nlevdecomp+1,ndecomp_pools)      ! "r" vector for tridiagonal solution
-    real(r8) :: conc_trcr(num_soilc,0:nlevdecomp+1,ndecomp_pools)                  !
-    real(r8) :: bet
-    real(r8) :: gam(0:nlevdecomp+1)
-    real :: startt, stopt
-    !-----------------------------------------------------------------------
+    integer  :: i_type,s,fc,c,j,l             ! indices
+    integer  :: jtop(bounds%begc:bounds%endc) ! top level at each column
+    integer  :: zerolev_diffus
+    real(r8) :: spinup_term                   ! spinup accelerated decomposition factor, used to accelerate transport as well
+    real(r8) :: epsilon                       ! small number
+
 
+    !-----------------------------------------------------------------------
 
     ! Set statement functions
+    aaa (pe) = max (0._r8, (1._r8 - 0.1_r8 * abs(pe))**5)  ! A function from Patankar, Table 5.2, pg 95
+
     associate(                                                      &
          is_cwd           => decomp_cascade_con%is_cwd            , & ! Input:  [logical (:)    ]  TRUE => pool is a cwd pool
          spinup_factor    => decomp_cascade_con%spinup_factor     , & ! Input:  [real(r8) (:)   ]  spinup accelerated decomposition factor, used to accelerate transport as well
@@ -220,20 +163,21 @@ contains
          altmax           => canopystate_vars%altmax_col          , & ! Input:  [real(r8) (:)   ]  maximum annual depth of thaw
          altmax_lastyear  => canopystate_vars%altmax_lastyear_col , & ! Input:  [real(r8) (:)   ]  prior year maximum annual depth of thaw
 
-         som_adv_coef     => cnstate_vars%som_adv_coef_col       , & ! Output: [real(r8) (:,:) ]  SOM advective flux (m/s)
-         som_diffus_coef  => cnstate_vars%som_diffus_coef_col    ,  & ! Output: [real(r8) (:,:) ]  SOM diffusivity due to bio/cryo-turbation (m2/s)
-         ! !Set parameters of vertical mixing of SOM
-          som_diffus                 => SoilLittVertTranspParamsInst%som_diffus   , &
-          cryoturb_diffusion_k       => SoilLittVertTranspParamsInst%cryoturb_diffusion_k  , &
-          max_altdepth_cryoturbation => SoilLittVertTranspParamsInst%max_altdepth_cryoturbation &
+         som_adv_coef     => cnstate_vars%som_adv_coef_col        , & ! Output: [real(r8) (:,:) ]  SOM advective flux (m/s)
+         som_diffus_coef  => cnstate_vars%som_diffus_coef_col       & ! Output: [real(r8) (:,:) ]  SOM diffusivity due to bio/cryo-turbation (m2/s)
          )
-      
-      call cpu_time(startt)
-      !$acc enter data create(a_tri(:,:,:),b_tri(:,:,:),&
-      !$acc     c_tri(:,:,:),r_tri(:,:,:), &
-      !$acc     conc_trcr(:,:,:), gam(:) )
-      call cpu_time(stopt) 
-      write(iulog,*) "TIMING SoilLittVertTransp::data",(stopt-startt)*1.E+3,"ms" 
+
+      !Set parameters of vertical mixing of SOM
+      som_diffus                 = SoilLittVertTranspParamsInst%som_diffus
+      cryoturb_diffusion_k       = SoilLittVertTranspParamsInst%cryoturb_diffusion_k
+      max_altdepth_cryoturbation = SoilLittVertTranspParamsInst%max_altdepth_cryoturbation
+
+      dtime = dtime_mod
+      year = year_curr
+      mon = mon_curr
+      day = day_curr
+
+
       ntype = 3
       if ( use_c13 ) then
          ntype = ntype+1
@@ -241,22 +185,19 @@ contains
       if ( use_c14 ) then
          ntype = ntype+1
       endif
-   
-      !$acc enter data create(spinup_term, i_type) 
+
       spinup_term = 1._r8
-      !$acc update device(spinup_term)
+      epsilon = 1.e-30
 
       if (use_vertsoilc) then
          !------ first get diffusivity / advection terms -------!
          ! use different mixing rates for bioturbation and cryoturbation, with fixed bioturbation and cryoturbation set to a maximum depth
-         !$acc parallel loop independent gang default(present)
-         do j = 1,nlevdecomp+1
-            !$acc loop vector independent private(c)
-            do fc = 1, num_soilc
-               c = filter_soilc (fc)
-               if  ( ( max(altmax(c), altmax_lastyear(c)) <= max_altdepth_cryoturbation ) .and. &
-                  ( max(altmax(c), altmax_lastyear(c)) > 0._r8) ) then
-                  ! use mixing profile modified slightly from Koven et al. (2009): constant through active layer, linear decrease from base of active layer to zero at a fixed depth
+         do fc = 1, num_soilc
+            c = filter_soilc (fc)
+            if  ( ( max(altmax(c), altmax_lastyear(c)) <= max_altdepth_cryoturbation ) .and. &
+                 ( max(altmax(c), altmax_lastyear(c)) > 0._r8) ) then
+               ! use mixing profile modified slightly from Koven et al. (2009): constant through active layer, linear decrease from base of active layer to zero at a fixed depth
+               do j = 1,nlevdecomp+1
                   if ( zisoi(j) < max(altmax(c), altmax_lastyear(c)) ) then
                      som_diffus_coef(c,j) = cryoturb_diffusion_k
                      som_adv_coef(c,j) = 0._r8
@@ -266,228 +207,281 @@ contains
                           ( max_depth_cryoturb - max(altmax(c), altmax_lastyear(c)) ) ), 0._r8)  ! go linearly to zero between ALT and max_depth_cryoturb
                      som_adv_coef(c,j) = 0._r8
                   endif
-               elseif (  max(altmax(c), altmax_lastyear(c)) > 0._r8 ) then
-                  ! constant advection, constant diffusion
+               end do
+            elseif (  max(altmax(c), altmax_lastyear(c)) > 0._r8 ) then
+               ! constant advection, constant diffusion
+               do j = 1,nlevdecomp+1
                   som_adv_coef(c,j) = som_adv_flux
                   som_diffus_coef(c,j) = som_diffus
-               else
-                  ! completely frozen soils--no mixing
+               end do
+            else
+               ! completely frozen soils--no mixing
+               do j = 1,nlevdecomp+1
                   som_adv_coef(c,j) = 0._r8
                   som_diffus_coef(c,j) = 0._r8
-               endif
-            end do
+               end do
+            endif
          end do
+
+         ! Set the distance between the node and the one ABOVE it
+         dz_node(1) = zsoi(1)
+         do j = 2,nlevdecomp+1
+            dz_node(j)= zsoi(j) - zsoi(j-1)
+         enddo
+
       endif
-   
+
       !------ loop over litter/som types
       do i_type = 1, ntype
 
-         !$acc update device(i_type)
+         select case (i_type)
+         case (1)  ! C
+            conc_ptr          => col_cs%decomp_cpools_vr
+            source            => col_cf%decomp_cpools_sourcesink
+            trcr_tendency_ptr => col_cf%decomp_cpools_transport_tendency
+         case (2)  ! N
+            conc_ptr          => col_ns%decomp_npools_vr
+            source            => col_nf%decomp_npools_sourcesink
+            trcr_tendency_ptr => col_nf%decomp_npools_transport_tendency
+         case (3)  ! P
+            conc_ptr          => col_ps%decomp_ppools_vr
+            source            => col_pf%decomp_ppools_sourcesink
+            trcr_tendency_ptr => col_pf%decomp_ppools_transport_tendency
+         case (4)
+            if ( use_c13 ) then
+               ! C13
+               conc_ptr          => c13_col_cs%decomp_cpools_vr
+               source            => c13_col_cf%decomp_cpools_sourcesink
+               trcr_tendency_ptr => c13_col_cf%decomp_cpools_transport_tendency
+            else
+               ! C14
+               conc_ptr          => c14_col_cs%decomp_cpools_vr
+               source            => c14_col_cf%decomp_cpools_sourcesink
+               trcr_tendency_ptr => c14_col_cf%decomp_cpools_transport_tendency
+            endif
+         case (5)
+            if ( use_c14 .and. use_c13 ) then
+               ! C14
+               conc_ptr          => c14_col_cs%decomp_cpools_vr
+               source            => c14_col_cf%decomp_cpools_sourcesink
+               trcr_tendency_ptr => c14_col_cf%decomp_cpools_transport_tendency
+            else
+#ifndef _OPENACC
+               write(iulog,*) 'error.  ncase = 5, but c13 and c14 not both enabled.'
+               call endrun(msg=errMsg(__FILE__, __LINE__))
+#endif
+            endif
+         end select
 
          if (use_vertsoilc) then
-            ! Set Pe (Peclet #) and D/dz throughout column
 
-            !$acc parallel loop independent gang default(present)
             do s = 1, ndecomp_pools
+
+               if ( spinup_state .eq. 1 ) then
+                  ! increase transport (both advection and diffusion) by the same factor as accelerated decomposition for a given pool
+                  spinup_term = spinup_factor(s)
+               else
+                  spinup_term = 1.
+               endif
+
                if ( .not. is_cwd(s) ) then
-                  !$acc loop independent worker vector private(c)
+
+                  do j = 1,nlevdecomp+1
+                     do fc = 1, num_soilc
+                        c = filter_soilc (fc)
+                        !
+                        if ( abs(som_adv_coef(c,j)) * spinup_term < epsilon ) then
+                           adv_flux(c,j) = epsilon
+                        else
+			   if (spinup_term > 1 .and. year >= 40 .and. spinup_state .eq. 1) then
+                             adv_flux(c,j) = som_adv_coef(c,j) * spinup_term / cnstate_vars%scalaravg_col(c,j)
+ 			   else
+                             adv_flux(c,j) = som_adv_coef(c,j) * spinup_term
+			   end if
+                        endif
+                        !
+                        if ( abs(som_diffus_coef(c,j)) * spinup_term < epsilon ) then
+                           diffus(c,j) = epsilon
+                        else
+			   if (spinup_term > 1 .and. year >= 40 .and. spinup_state .eq. 1) then
+                             diffus(c,j) = som_diffus_coef(c,j) * spinup_term / cnstate_vars%scalaravg_col(c,j)
+                           else
+                             diffus(c,j) = som_diffus_coef(c,j) * spinup_term
+			   end if
+                        endif
+                        !
+                     end do
+                  end do
+
+                  ! Set Pe (Peclet #) and D/dz throughout column
+
                   do fc = 1, num_soilc ! dummy terms here
                      c = filter_soilc (fc)
-                     conc_trcr(fc,0,s) = 0._r8
-                     conc_trcr(fc,nlevdecomp+1,s) = 0._r8
-
-                     a_tri(fc,0,s) = 0._r8
-                     b_tri(fc,0,s) = 1._r8
-                     c_tri(fc,0,s) = -1._r8
-                     r_tri(fc,0,s) = 0._r8
-
-                     conc_trcr(fc,nlevdecomp+1,s) = transport_ptr_list(i_type)%conc_ptr(c,nlevdecomp+1,s)
-                     a_tri(fc,nlevdecomp+1,s) = -1._r8
-                     b_tri(fc,nlevdecomp+1,s) = 1._r8
-                     c_tri(fc,nlevdecomp+1,s) = 0._r8
-                     r_tri(fc,nlevdecomp+1,s) = 0._r8
+                     conc_trcr(c,0) = 0._r8
+                     conc_trcr(c,nlevdecomp+1) = 0._r8
                   end do
-               end if
-            end do
 
-            !$acc parallel loop independent gang worker vector collapse(3) default(present) 
-            do s = 1, ndecomp_pools
-               do j = 1,nlevdecomp
-                  do fc = 1, num_soilc
-                     c = filter_soilc (fc)
-                     if(.not. is_cwd(s)) then
 
-                        if ( spinup_state .eq. 1 ) then
-                           ! increase transport (both advection and diffusion) by the same factor as accelerated decomposition for a given pool
-                           spinup_term = spinup_factor(s)
-                        else
-                           spinup_term = 1.
-                        endif
-                        conc_trcr(fc,j,s) = transport_ptr_list(i_type)%conc_ptr(c,j,s)
+                  do j = 1,nlevdecomp+1
+                     do fc = 1, num_soilc
+                        c = filter_soilc (fc)
+
+                        conc_trcr(c,j) = conc_ptr(c,j,s)
                         ! dz_tracer below is the difference between gridcell edges  (dzsoi_decomp)
                         ! dz_node_tracer is difference between cell centers
-                        call calc_diffus_advflux(spinup_term,year_curr, som_diffus_coef(c,j), som_adv_coef(c,j), &
-                                                 cnstate_vars%scalaravg_col(c,j),adv_flux_j, diffus_j)
 
                         ! Calculate the D and F terms in the Patankar algorithm
                         if (j == 1) then
-                          call calc_diffus_advflux(spinup_term,year_curr, som_diffus_coef(c,j+1), som_adv_coef(c,j+1), &
-                                                   cnstate_vars%scalaravg_col(c,j+1),adv_flux_jp1, diffus_jp1)
-
-                           dz_nodep1 =  zsoi(j+1) - zsoi(j)
-                           d_m1_zm1 = 0._r8
-                           w_p1 = (zsoi(j+1) - zisoi(j)) / dz_nodep1
-                           if (diffus_jp1 > 0._r8 .and. diffus_j > 0._r8) then
-                             d_p1 = 1._r8 / ((1._r8 - w_p1) / diffus_j + w_p1 / diffus_jp1) ! Harmonic mean of diffus
+                           d_m1_zm1(c,j) = 0._r8
+                           w_p1 = (zsoi(j+1) - zisoi(j)) / dz_node(j+1)
+                           if ( diffus(c,j+1) > 0._r8 .and. diffus(c,j) > 0._r8) then
+                              d_p1 = 1._r8 / ((1._r8 - w_p1) / diffus(c,j) + w_p1 / diffus(c,j+1)) ! Harmonic mean of diffus
                            else
                               d_p1 = 0._r8
                            endif
-
-                           d_p1_zp1 = d_p1 / dz_nodep1
-                           pe_m1 = 0._r8
-                           pe_p1 = adv_flux_jp1 / d_p1_zp1 ! Peclet #
-
-                           a_p_0 =  dzsoi_decomp(j) / dtime_mod
-                           a_tri(fc,j,s) = -(d_m1_zm1 * aaa(pe_m1) + max( adv_flux_j, 0._r8)) ! Eqn 5.47 Patankar
-                           c_tri(fc,j,s) = -(d_p1_zp1 * aaa(pe_p1) + max(-adv_flux_jp1, 0._r8))
-                           b_tri(fc,j,s) = -a_tri(fc,j,s) - c_tri(fc,j,s) + a_p_0
-                           r_tri(fc,j,s) = transport_ptr_list(i_type)%src_ptr(c,j,s) * dzsoi_decomp(j) /dtime_mod + (a_p_0 - adv_flux_j) * conc_trcr(fc,j,s)
+                           d_p1_zp1(c,j) = d_p1 / dz_node(j+1)
+                           f_m1(c,j) = adv_flux(c,j)  ! Include infiltration here
+                           f_p1(c,j) = adv_flux(c,j+1)
+                           pe_m1(c,j) = 0._r8
+                           pe_p1(c,j) = f_p1(c,j) / d_p1_zp1(c,j) ! Peclet #
+                        elseif (j == nlevdecomp+1) then
+                           ! At the bottom, assume no gradient in d_z (i.e., they're the same)
+                           w_m1 = (zisoi(j-1) - zsoi(j-1)) / dz_node(j)
+                           if ( diffus(c,j) > 0._r8 .and. diffus(c,j-1) > 0._r8) then
+                              d_m1 = 1._r8 / ((1._r8 - w_m1) / diffus(c,j) + w_m1 / diffus(c,j-1)) ! Harmonic mean of diffus
+                           else
+                              d_m1 = 0._r8
+                           endif
+                           d_m1_zm1(c,j) = d_m1 / dz_node(j)
+                           d_p1_zp1(c,j) = d_m1_zm1(c,j) ! Set to be the same
+                           f_m1(c,j) = adv_flux(c,j)
+                           !f_p1(c,j) = adv_flux(c,j+1)
+                           f_p1(c,j) = 0._r8
+                           pe_m1(c,j) = f_m1(c,j) / d_m1_zm1(c,j) ! Peclet #
+                           pe_p1(c,j) = f_p1(c,j) / d_p1_zp1(c,j) ! Peclet #
                         else
-                          ! Use distance from j-1 node to interface with j divided by distance between nodes
-                          call calc_diffus_advflux(spinup_term,year_curr, som_diffus_coef(c,j-1), som_adv_coef(c,j-1), &
-                                                   cnstate_vars%scalaravg_col(c,j-1),adv_flux_jm1, diffus_jm1)
-
-                          call calc_diffus_advflux(spinup_term,year_curr, som_diffus_coef(c,j+1), som_adv_coef(c,j+1), &
-                                                   cnstate_vars%scalaravg_col(c,j+1),adv_flux_jp1, diffus_jp1)
                            ! Use distance from j-1 node to interface with j divided by distance between nodes
-                           dz_node = zsoi(j) - zsoi(j-1)
-                           w_m1 = (zisoi(j-1) - zsoi(j-1)) / dz_node
-
-                           if ( diffus_jm1 > 0._r8 .and. diffus_j > 0._r8) then
-                             d_m1 = 1._r8 / ((1._r8 - w_m1) / diffus_j + w_m1 / diffus_jm1) ! Harmonic mean of diffus
+                           w_m1 = (zisoi(j-1) - zsoi(j-1)) / dz_node(j)
+                           if ( diffus(c,j-1) > 0._r8 .and. diffus(c,j) > 0._r8) then
+                              d_m1 = 1._r8 / ((1._r8 - w_m1) / diffus(c,j) + w_m1 / diffus(c,j-1)) ! Harmonic mean of diffus
                            else
-                             d_m1 = 0._r8
+                              d_m1 = 0._r8
                            endif
-                           dz_nodep1 = zsoi(j+1) - zsoi(j)
-                           w_p1 = (zsoi(j+1) - zisoi(j)) / dz_nodep1
-                           if ( diffus_jp1 > 0._r8 .and. diffus_j > 0._r8) then
-                             d_p1 = 1._r8 / ((1._r8 - w_p1) / diffus_j + w_p1 / diffus_jp1) ! Harmonic mean of diffus
+                           w_p1 = (zsoi(j+1) - zisoi(j)) / dz_node(j+1)
+                           if ( diffus(c,j+1) > 0._r8 .and. diffus(c,j) > 0._r8) then
+                              d_p1 = 1._r8 / ((1._r8 - w_p1) / diffus(c,j) + w_p1 / diffus(c,j+1)) ! Harmonic mean of diffus
                            else
-                             d_p1 = (1._r8 - w_m1) * diffus_j + w_p1 * diffus_jp1 ! Arithmetic mean of diffus
+                              d_p1 = (1._r8 - w_m1) * diffus(c,j) + w_p1 * diffus(c,j+1) ! Arithmetic mean of diffus
                            endif
-                           d_m1_zm1 = d_m1 / dz_node
-                           d_p1_zp1 = d_p1 / dz_nodep1
-                           pe_m1 = adv_flux_j / d_m1_zm1 ! Peclet #
-                           pe_p1 = adv_flux_jp1 / d_p1_zp1 ! Peclet #
-
-                           a_p_0 =  dzsoi_decomp(j) / dtime_mod
-                           a_tri(fc,j,s) = -(d_m1_zm1 * aaa(pe_m1) + max( adv_flux_j, 0._r8)) ! Eqn 5.47 Patankar
-                           c_tri(fc,j,s) = -(d_p1_zp1 * aaa(pe_p1) + max(-adv_flux_jp1, 0._r8))
-                           b_tri(fc,j,s) = -a_tri(fc,j,s) - c_tri(fc,j,s) + a_p_0
-                           r_tri(fc,j,s) = transport_ptr_list(i_type)%src_ptr(c,j,s) * dzsoi_decomp(j) /dtime_mod + a_p_0 * conc_trcr(fc,j,s)
+                           d_m1_zm1(c,j) = d_m1 / dz_node(j)
+                           d_p1_zp1(c,j) = d_p1 / dz_node(j+1)
+                           f_m1(c,j) = adv_flux(c,j)
+                           f_p1(c,j) = adv_flux(c,j+1)
+                           pe_m1(c,j) = f_m1(c,j) / d_m1_zm1(c,j) ! Peclet #
+                           pe_p1(c,j) = f_p1(c,j) / d_p1_zp1(c,j) ! Peclet #
                         end if
-                     end if
-                  enddo ! fc
-               enddo ! j; nlevdecomp
-            end do ! s: ndecomp_pools
+                     enddo ! fc
+                  enddo ! j; nlevdecomp
 
-            ! subtract initial concentration and source terms for tendency calculation
-            !$acc parallel loop independent collapse(3) gang vector default(present)
-            do s = 1, ndecomp_pools
-               do j = 1, nlevdecomp
-                  do fc = 1, num_soilc
-                     c = filter_soilc (fc)
-                     if(.not. is_cwd(s)) then
-                        transport_ptr_list(i_type)%trcr_tend_ptr(c,j,s) = 0._r8 - (conc_trcr(fc,j,s) + transport_ptr_list(i_type)%src_ptr(c,j,s))
-                     end if
-                  end do
-               end do
-            end do
 
-            ! Solve for the concentration profile for this time step
+                  ! Calculate the tridiagonal coefficients
+                  do j = 0,nlevdecomp +1
+                     do fc = 1, num_soilc
+                        c = filter_soilc (fc)
+                        ! g = cgridcell(c)
 
-            !$acc parallel loop independent gang worker vector collapse(2) default(present) private(bet, gam(0:nlevdecomp+1))
-            do s = 1, ndecomp_pools
-               do fc = 1,num_soilc
-                  if(.not. is_cwd(s)) then
-                     bet = b_tri(fc,0,s)
-
-                     !$acc loop seq
-                     do j = 0, nlevdecomp+1
-                        if (j >= 0) then !!!should be able to remove this?
-                           if (j == 0) then
-                              conc_trcr(fc,j,s) = r_tri(fc,j,s) / bet
-                           else
-                              gam(j) = c_tri(fc,j-1,s) / bet
-                              bet = b_tri(fc,j,s) - a_tri(fc,j,s) * gam(j)
-                              conc_trcr(fc,j,s) = (r_tri(fc,j,s) - a_tri(fc,j,s)*conc_trcr(fc,j-1,s)) / bet
-                           end if
-                        end if
-                     end do
+                        if (j > 0 .and. j < nlevdecomp+1) then
+                           a_p_0 =  dzsoi_decomp(j) / dtime
+                        endif
+
+                        if (j == 0) then ! top layer (atmosphere)
+                           a_tri(c,j) = 0._r8
+                           b_tri(c,j) = 1._r8
+                           c_tri(c,j) = -1._r8
+                           r_tri(c,j) = 0._r8
+                        elseif (j == 1) then
+                           a_tri(c,j) = -(d_m1_zm1(c,j) * aaa(pe_m1(c,j)) + max( f_m1(c,j), 0._r8)) ! Eqn 5.47 Patankar
+                           c_tri(c,j) = -(d_p1_zp1(c,j) * aaa(pe_p1(c,j)) + max(-f_p1(c,j), 0._r8))
+                           b_tri(c,j) = -a_tri(c,j) - c_tri(c,j) + a_p_0
+                           r_tri(c,j) = source(c,j,s) * dzsoi_decomp(j) /dtime + (a_p_0 - adv_flux(c,j)) * conc_trcr(c,j)
+                        elseif (j < nlevdecomp+1) then
+                           a_tri(c,j) = -(d_m1_zm1(c,j) * aaa(pe_m1(c,j)) + max( f_m1(c,j), 0._r8)) ! Eqn 5.47 Patankar
+                           c_tri(c,j) = -(d_p1_zp1(c,j) * aaa(pe_p1(c,j)) + max(-f_p1(c,j), 0._r8))
+                           b_tri(c,j) = -a_tri(c,j) - c_tri(c,j) + a_p_0
+                           r_tri(c,j) = source(c,j,s) * dzsoi_decomp(j) /dtime + a_p_0 * conc_trcr(c,j)
+                        else ! j==nlevdecomp+1; 0 concentration gradient at bottom
+                           a_tri(c,j) = -1._r8
+                           b_tri(c,j) = 1._r8
+                           c_tri(c,j) = 0._r8
+                           r_tri(c,j) = 0._r8
+                        endif
+                     enddo ! fc; column
+                  enddo ! j; nlevdecomp
+
+                  do fc = 1, num_soilc
+                     c = filter_soilc (fc)
+                     jtop(c) = 0
+                  enddo
 
-                     !$acc loop seq
-                     do j = nlevdecomp,0,-1
-                       if (j >= 0) then
-                          conc_trcr(fc,j,s) = conc_trcr(fc,j,s) - gam(j+1) * conc_trcr(fc,j+1,s)
-                       end if
+                  ! subtract initial concentration and source terms for tendency calculation
+                  do fc = 1, num_soilc
+                     c = filter_soilc (fc)
+                     do j = 1, nlevdecomp
+                        trcr_tendency_ptr(c,j,s) = 0.-(conc_trcr(c,j) + source(c,j,s))
                      end do
-                  end if
-               end do
-            end do
+                  end do
 
-            ! add post-transport concentration to calculate tendency term
-            !$acc parallel loop independent gang collapse(2) default(present)
-            do s = 1, ndecomp_pools
-               do j = 1, nlevdecomp
-                  if(.not. is_cwd(s)) then
-                     !$acc loop vector independent private(c)
-                     do fc = 1, num_soilc
-                        c = filter_soilc (fc)
-                        transport_ptr_list(i_type)%trcr_tend_ptr(c,j,s) = (transport_ptr_list(i_type)%trcr_tend_ptr(c,j,s) + conc_trcr(fc,j,s))/dtime_mod
+                  ! Solve for the concentration profile for this time step
+                  call Tridiagonal(bounds, 0, nlevdecomp+1, &
+                       jtop(bounds%begc:bounds%endc), &
+                       num_soilc, filter_soilc, &
+                       a_tri(bounds%begc:bounds%endc, :), &
+                       b_tri(bounds%begc:bounds%endc, :), &
+                       c_tri(bounds%begc:bounds%endc, :), &
+                       r_tri(bounds%begc:bounds%endc, :), &
+                       conc_trcr(bounds%begc:bounds%endc,0:nlevdecomp+1))
+
+                  ! add post-transport concentration to calculate tendency term
+                  do fc = 1, num_soilc
+                     c = filter_soilc (fc)
+                     do j = 1, nlevdecomp
+                        trcr_tendency_ptr(c,j,s) = trcr_tendency_ptr(c,j,s) + conc_trcr(c,j)
+                        trcr_tendency_ptr(c,j,s) = trcr_tendency_ptr(c,j,s) / dtime
                      end do
-                  end if
-                  !
-               end do
-            end do
+                  end do
 
-            ! for CWD pools, just add
-            !$acc parallel loop independent gang default(present)
-            do s = 1, ndecomp_pools
-               if(is_cwd(s)) then
-                  !$acc loop worker vector collapse(2) independent private(c)
+               else
+                  ! for CWD pools, just add
                   do j = 1,nlevdecomp
                      do fc = 1, num_soilc
                         c = filter_soilc (fc)
-                        conc_trcr(fc,j,s) = transport_ptr_list(i_type)%conc_ptr(c,j,s) + transport_ptr_list(i_type)%src_ptr(c,j,s)
+                        conc_trcr(c,j) = conc_ptr(c,j,s) + source(c,j,s)
                      end do
                   end do
-               end if
-            end do
 
+               end if ! not CWD
 
-            !$acc parallel loop independent gang collapse(2) default(present)
-            do s = 1, ndecomp_pools
                do j = 1,nlevdecomp
-                  !$acc loop vector independent private(c)
                   do fc = 1, num_soilc
                      c = filter_soilc (fc)
-                     transport_ptr_list(i_type)%conc_ptr(c,j,s) = conc_trcr(fc,j,s)
+                     conc_ptr(c,j,s) = conc_trcr(c,j)
                   end do
                end do
 
             end do ! s (pool loop)
 
-         else !use_vertsoilc?
+         else
 
             !! for single level case, no transport; just update the fluxes calculated in the StateUpdate1 subroutines
-            !$acc parallel loop independent collapse(2) default(present)
             do l = 1, ndecomp_pools
                do j = 1,nlevdecomp
-                  !$acc loop vector independent private(c)
                   do fc = 1, num_soilc
                      c = filter_soilc (fc)
-                     transport_ptr_list(i_type)%conc_ptr(c,j,l) = transport_ptr_list(i_type)%conc_ptr(c,j,l) + transport_ptr_list(i_type)%src_ptr(c,j,l)
-                     transport_ptr_list(i_type)%trcr_tend_ptr(c,j,l) = 0._r8
+
+                     conc_ptr(c,j,l) = conc_ptr(c,j,l) + source(c,j,l)
+
+                     trcr_tendency_ptr(c,j,l) = 0._r8
+
                   end do
                end do
             end do
@@ -495,43 +489,9 @@ contains
          endif
 
       end do  ! i_type
-   
-      !$acc exit data delete(a_tri(:,:,:),b_tri(:,:,:),&
-      !$acc     c_tri(:,:,:),r_tri(:,:,:), gam(:), &
-      !$acc     conc_trcr(:,:,:), spinup_term, i_type)
+
     end associate
 
   end subroutine SoilLittVertTransp
 
-  subroutine calc_diffus_advflux(spinup_term,year, som_diffus_coef, som_adv_coef, cnscalaravg_col, &
-                          adv_fluxj, diffusj)
-    !$acc routine seq
-    real(r8), intent(in)  ::  spinup_term
-    integer , value, intent(in) :: year
-    real(r8), intent(in)  ::  som_diffus_coef, som_adv_coef, cnscalaravg_col
-    real(r8), intent(out) ::  adv_fluxj, diffusj
-
-    real(r8) , parameter :: eps = 1d-30
-
-    if ( abs(som_adv_coef) * spinup_term < eps ) then
-       adv_fluxj = eps
-    else
-         if (spinup_term > 1 .and. year >= 40 .and. spinup_state .eq. 1) then
-           adv_fluxj = som_adv_coef * spinup_term / cnscalaravg_col
-         else
-           adv_fluxj = som_adv_coef * spinup_term
-         end if
-    endif
-    !
-    if ( abs(som_diffus_coef) * spinup_term < eps ) then
-       diffusj = eps
-    else
-         if (spinup_term > 1 .and. year >= 40 .and. spinup_state .eq. 1) then
-           diffusj = som_diffus_coef * spinup_term / cnscalaravg_col
-         else
-           diffusj = som_diffus_coef * spinup_term
-         end if
-    endif
-  end subroutine calc_diffus_advflux
-
 end module SoilLittVertTranspMod
diff --git a/components/elm/src/biogeochem/VegStructUpdateMod.F90 b/components/elm/src/biogeochem/VegStructUpdateMod.F90
index 4b35b0036d..706e89daab 100644
--- a/components/elm/src/biogeochem/VegStructUpdateMod.F90
+++ b/components/elm/src/biogeochem/VegStructUpdateMod.F90
@@ -11,8 +11,8 @@ module VegStructUpdateMod
   use VegetationPropertiesType     , only : veg_vp
   use FrictionVelocityType , only : frictionvel_type
   use CNStateType          , only : cnstate_type
-  use CanopyStateType      , only : canopystate_type
   use CropType             , only : crop_type
+  use CanopyStateType      , only : canopystate_type
   use ColumnDataType       , only : col_ws
   use VegetationType       , only : veg_pp
   use VegetationDataType   , only : veg_cs
@@ -28,36 +28,35 @@ module VegStructUpdateMod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine VegStructUpdate(num_soilp,filter_soilp, &
+  subroutine VegStructUpdate(num_soilp, filter_soilp, &
        frictionvel_vars, cnstate_vars, &
-       canopystate_vars, crop_vars, dt)
+       canopystate_vars, crop_vars)
     !
     ! !DESCRIPTION:
     ! On the radiation time step, use C state variables and epc to diagnose
     ! vegetation structure (LAI, SAI, height)
-       
+    !
     ! !USES:
     use pftvarcon        , only : noveg, nc3crop, nc3irrig, nbrdlf_evr_shrub, nbrdlf_dcd_brl_shrub
     use pftvarcon        , only : ncorn, ncornirrig, npcropmin, ztopmx, laimx
     use pftvarcon        , only : nmiscanthus, nmiscanthusirrig, nswitchgrass, nswitchgrassirrig
+    use clm_time_manager , only : get_rad_step_size
     use elm_varctl       , only : spinup_state, spinup_mortality_factor
     !
-   !  ! !ARGUMENTS:
+    ! !ARGUMENTS:
     integer                , intent(in)    :: num_soilp       ! number of column soil points in pft filter
     integer                , intent(in)    :: filter_soilp(:) ! patch filter for soil points
     type(frictionvel_type) , intent(in)    :: frictionvel_vars
     type(cnstate_type)     , intent(inout) :: cnstate_vars
     type(canopystate_type) , intent(inout) :: canopystate_vars
     type(crop_type)        , intent(inout) :: crop_vars
-    real(r8), intent(in)     :: dt         ! radiation time step (sec)
-
     !
     ! !REVISION HISTORY:
     ! 10/28/03: Created by Peter Thornton
     ! 2/29/08, David Lawrence: revised snow burial fraction for short vegetation
     !
     ! !LOCAL VARIABLES:
-    integer  :: c,g,p      ! indices
+    integer  :: p,c,g      ! indices
     integer  :: fp         ! lake filter indices
     real(r8) :: taper      ! ratio of height:radius_breast_height (tree allometry)
     real(r8) :: stocking   ! #stems / ha (stocking density)
@@ -67,6 +66,7 @@ contains
     real(r8) :: tsai_old   ! for use in Zeng tsai formula
     real(r8) :: tsai_min   ! PATCH derived minimum tsai
     real(r8) :: tsai_alpha ! monthly decay rate of tsai
+    real(r8) :: dt         ! radiation time step (sec)
 
     real(r8), parameter :: dtsmonth = 2592000._r8 ! number of seconds in a 30 day month (60x60x24x30)
     !-----------------------------------------------------------------------
@@ -112,18 +112,20 @@ contains
          frac_veg_nosno_alb =>  canopystate_vars%frac_veg_nosno_alb_patch & ! Output: [integer  (:) ] frac of vegetation not covered by snow [-]
          )
 
+      dt = real( get_rad_step_size(), r8 )
+
+      ! constant allometric parameters
+      taper = 200._r8
+      stocking = 1000._r8
+
+      ! convert from stems/ha -> stems/m^2
+      stocking = stocking / 10000._r8
+
       ! patch loop
-      !$acc parallel loop independent gang vector default(present) 
       do fp = 1,num_soilp
          p = filter_soilp(fp)
          c = veg_pp%column(p)
          g = veg_pp%gridcell(p)
-         ! constant allometric parameters
-         taper = 200._r8
-         stocking = 1000._r8
-
-         ! convert from stems/ha -> stems/m^2
-         stocking = stocking / 10000._r8
 
          if (ivt(p) /= noveg) then
 
@@ -264,7 +266,7 @@ contains
             frac_veg_nosno_alb(p) = 0
          end if
 
-       end do
+      end do
 
     end associate
 
diff --git a/components/elm/src/biogeochem/VerticalProfileMod.F90 b/components/elm/src/biogeochem/VerticalProfileMod.F90
index c4db7070a0..9edc0d7602 100644
--- a/components/elm/src/biogeochem/VerticalProfileMod.F90
+++ b/components/elm/src/biogeochem/VerticalProfileMod.F90
@@ -25,10 +25,11 @@ module VerticalProfileMod
   logical , public :: exponential_rooting_profile = .true.
   logical , public :: pftspecific_rootingprofile = .true.
   ! how steep profile is for root C inputs (1/ e-folding depth) (1/m)
-  real(r8), public :: rootprof_exp  = 3._R8
+  real(r8), public :: rootprof_exp  = 3.       
   ! how steep profile is for surface components (1/ e_folding depth) (1/m)
-  real(r8), public :: surfprof_exp  = 10._r8
+  real(r8), public :: surfprof_exp  = 10.      
   !-----------------------------------------------------------------------
+
 contains
 
   !-----------------------------------------------------------------------
@@ -68,9 +69,9 @@ contains
     ! !LOCAL VARIABLES:
     real(r8) :: surface_prof(1:nlevdecomp)
     real(r8) :: surface_prof_tot
-    real(r8) :: rootfr_tot, sum_rootfr
+    real(r8) :: rootfr_tot
     real(r8) :: cinput_rootfr(bounds%begp:bounds%endp, 1:nlevdecomp_full)      ! pft-native root fraction used for calculating inputs
-    real(r8) :: col_cinput_rootfr(1:num_soilc, 1:nlevdecomp_full)  ! col-native root fraction used for calculating inputs
+    real(r8) :: col_cinput_rootfr(bounds%begc:bounds%endc, 1:nlevdecomp_full)  ! col-native root fraction used for calculating inputs
     integer  :: c, j, fc, p, fp, pi
     integer  :: alt_ind
     integer  :: nlevbed
@@ -82,9 +83,7 @@ contains
     real(r8) :: ndep_prof_sum
     real(r8) :: nfixation_prof_sum
     real(r8) :: pdep_prof_sum
-    real(r8),parameter :: delta = 1.e-10
-    integer  :: erridx
-    integer  :: begc, endc, begp, endp 
+    real(r8) :: delta = 1.e-10
     character(len=32) :: subname = 'decomp_vertprofiles'
     !-----------------------------------------------------------------------
 
@@ -101,68 +100,37 @@ contains
          leaf_prof            => cnstate_vars%leaf_prof_patch              , & ! Output:  [real(r8) (:,:) ]  (1/m) profile of leaves                         
          froot_prof           => cnstate_vars%froot_prof_patch             , & ! Output:  [real(r8) (:,:) ]  (1/m) profile of fine roots                     
          croot_prof           => cnstate_vars%croot_prof_patch             , & ! Output:  [real(r8) (:,:) ]  (1/m) profile of coarse roots                   
-         stem_prof            => cnstate_vars%stem_prof_patch               & ! Output:  [real(r8) (:,:) ]  (1/m) profile of stems                          
+         stem_prof            => cnstate_vars%stem_prof_patch              , & ! Output:  [real(r8) (:,:) ]  (1/m) profile of stems                          
          
+         begp                 => bounds%begp                               , &
+         endp                 => bounds%endp                               , &
+         begc                 => bounds%begc                               , &
+         endc                 => bounds%endc                                 &
          )
 
-      begp = bounds%begp  
-      endp = bounds%endp  
-      begc = bounds%begc  
-      endc = bounds%endc
-      !$acc enter data copyin(surfprof_exp,rootprof_exp)  
-      !$acc enter data create(&
-      !$acc surface_prof(:), &
-      !$acc cinput_rootfr(:,:) , &
-      !$acc col_cinput_rootfr(:,:), &
-      !$acc froot_prof_sum, &
-      !$acc croot_prof_sum, &
-      !$acc leaf_prof_sum , &
-      !$acc stem_prof_sum , &
-      !$acc ndep_prof_sum , &
-      !$acc nfixation_prof_sum , & 
-      !$acc pdep_prof_sum , &
-      !$acc rootfr_tot, sum_rootfr) 
       if (use_vertsoilc) then
 
          ! define a single shallow surface profile for surface additions (leaves, stems, and N deposition)
-        !$ acc parallel loop independent default(present) vector        
+         surface_prof(:) = 0._r8
          do j = 1, nlevdecomp
             surface_prof(j) = exp(-surfprof_exp * zsoi(j)) / dzsoi_decomp(j)
          end do
-         
+
          ! initialize profiles to zero
-         !$acc parallel loop independent gang vector collapse(2) default(present) 
-         do j = 1,nlevdecomp_full
-            do p =begp, endp  ! NOTE: could be over filter only 
-               !p = filter_soilp(fp) 
-               cinput_rootfr(p, j)     = 0._r8
-               leaf_prof (p, j)  = 0._r8
-               froot_prof(p, j)  = 0._r8
-               croot_prof(p, j)  = 0._r8
-               stem_prof (p, j)  = 0._r8
-            end do 
-         end do 
-         !$acc parallel loop independent gang vector collapse(2) default(present) 
-         do j =1, nlevdecomp_full
-            do c = begc, endc 
-               !c = filter_soilc(fc) 
-               nfixation_prof(c, j) = 0._r8
-               ndep_prof(c, j)      = 0._r8
-               pdep_prof(c, j)      = 0._r8
-            end do 
-         end do 
+         leaf_prof(begp:endp, :)      = 0._r8
+         froot_prof(begp:endp, :)     = 0._r8
+         croot_prof(begp:endp, :)     = 0._r8
+         stem_prof(begp:endp, :)      = 0._r8
+         nfixation_prof(begc:endc, :) = 0._r8
+         ndep_prof(begc:endc, :)      = 0._r8
+         pdep_prof(begc:endc, :)      = 0._r8
 
-         !$acc parallel loop independent gang vector collapse(2) default(present) 
-         do j =1, nlevdecomp_full
-            do fc = 1, num_soilc 
-               col_cinput_rootfr(fc, j) = 0._r8
-            end do 
-         end do 
+         cinput_rootfr(begp:endp, :)     = 0._r8
+         col_cinput_rootfr(begc:endc, :) = 0._r8
 
          if ( exponential_rooting_profile ) then
             if ( .not. pftspecific_rootingprofile ) then
                ! define rooting profile from exponential parameters
-            !$acc parallel loop independent gang vector collapse(2) default(present) 
                do j = 1, nlevdecomp
                   do fp = 1,num_soilp
                      p = filter_soilp(fp)
@@ -171,14 +139,12 @@ contains
                end do
             else
                ! use beta distribution parameter from Jackson et al., 1996
-               !$acc parallel loop independent gang worker default(present) private(rootfr_tot)  
                do fp = 1,num_soilp
                   p = filter_soilp(fp)
                   c = veg_pp%column(p)
                   nlevbed = nlev2bed(c)
                   rootfr_tot = 0._r8
                   if (veg_pp%itype(p) /= noveg) then
-                     !$acc loop vector reduction(+:rootfr_tot)
                      do j = 1, nlevdecomp
                         if (j <= nlevbed) then
                            cinput_rootfr(p,j) = ( rootprof_beta(veg_pp%itype(p)) ** (zisoi(j-1)*100._r8) - &
@@ -190,7 +156,6 @@ contains
                         end if
                      end do
                      if (nlevbed < nlevdecomp) then
-                        !$acc loop vector independent 
                         do j = 1, nlevbed
                            cinput_rootfr(p,j) = cinput_rootfr(p,j) / rootfr_tot
                         end do
@@ -201,10 +166,8 @@ contains
                end do
             endif
          else
-
-            ! use standard CLM root fraction profiles
-            !$acc parallel loop independent gang vector default(present) collapse(2)
             do j = 1, nlevdecomp
+               ! use standard CLM root fraction profiles
                do fp = 1,num_soilp
                   p = filter_soilp(fp)
                   cinput_rootfr(p,j) = rootfr(p,j) / dzsoi_decomp(j)
@@ -212,7 +175,6 @@ contains
             end do
          endif
 
-         !$acc parallel loop independent gang worker default(present) private(nlevbed,surface_prof_tot,rootfr_tot) 
          do fp = 1,num_soilp
             p = filter_soilp(fp)
             c = veg_pp%column(p)
@@ -220,20 +182,18 @@ contains
             ! integrate rootfr over active layer of soil column
             rootfr_tot = 0._r8
             surface_prof_tot = 0._r8
-            !$acc loop vector reduction(+:surface_prof_tot,rootfr_tot)
             do j = 1, min(max(altmax_lastyear_indx(c), 1), nlevdecomp)
                rootfr_tot = rootfr_tot + cinput_rootfr(p,j) * dzsoi_decomp(j)
                if (nlevbed < nlevdecomp) then
-                  surface_prof_tot = surface_prof_tot + exp(log(surface_prof(j)) * zisoi(nlevdecomp)/zisoi(nlevbed)) * dzsoi_decomp(j)
+                  surface_prof_tot = surface_prof_tot + exp(log(surface_prof(j)) * zisoi(nlevdecomp) / &
+                  	zisoi(nlevbed)) * dzsoi_decomp(j)
                else
                   surface_prof_tot = surface_prof_tot + surface_prof(j) * dzsoi_decomp(j)
                end if
             end do
-
             if ( (altmax_lastyear_indx(c) > 0) .and. (rootfr_tot > 0._r8) .and. (surface_prof_tot > 0._r8) ) then
                ! where there is not permafrost extending to the surface, integrate the profiles over the active layer
                ! this is equivalnet to integrating over all soil layers outside of permafrost regions
-               !$acc loop vector independent 
                do j = 1, min(max(altmax_lastyear_indx(c), 1), nlevdecomp)
                   froot_prof(p,j) = cinput_rootfr(p,j) / rootfr_tot
                   croot_prof(p,j) = cinput_rootfr(p,j) / rootfr_tot
@@ -260,23 +220,24 @@ contains
 
          end do
 
-         !$acc parallel loop independent gang worker collapse(2) default(present) private(sum_rootfr)
-         do j = 1,nlevdecomp
+         !! aggregate root profile to column
+         ! call p2c (decomp, nlevdecomp_full, &
+         !      cinput_rootfr(bounds%begp:bounds%endp, :), &
+         !      col_cinput_rootfr(bounds%begc:bounds%endc, :), &
+         !      'unity')
+         do pi = 1,maxpatch_pft
             do fc = 1,num_soilc
                c = filter_soilc(fc)
-               sum_rootfr = 0._r8 
-               !$acc loop vector reduction(+:sum_rootfr)
-               do p = col_pp%pfti(c), col_pp%pftf(c)
-                  if (veg_pp%wtcol(p) > 0._r8) then
-                     sum_rootfr = sum_rootfr+ cinput_rootfr(p,j) * veg_pp%wtcol(p)
-                  end if
-               end do
-               col_cinput_rootfr(fc,j) = col_cinput_rootfr(fc,j) + sum_rootfr
+               if (pi <=  col_pp%npfts(c)) then
+                  p = col_pp%pfti(c) + pi - 1
+                  do j = 1,nlevdecomp
+                     col_cinput_rootfr(c,j) = col_cinput_rootfr(c,j) + cinput_rootfr(p,j) * veg_pp%wtcol(p)
+                  end do
+               end if
             end do
          end do
 
          ! repeat for column-native profiles: Ndep and Nfix
-         !$acc parallel loop independent gang worker default(present) private(surface_prof_tot,rootfr_tot,alt_ind,nlevbed) 
          do fc = 1,num_soilc
             c = filter_soilc(fc)
             nlevbed = nlev2bed(c)
@@ -284,132 +245,89 @@ contains
             surface_prof_tot = 0._r8
             ! redo column ntegration over active layer for column-native profiles
             alt_ind = min(max(altmax_lastyear_indx(c), 1), nlevdecomp)
-            !$acc loop vector reduction(+:rootfr_tot, surface_prof_tot)
             do j = 1, min(alt_ind, nlevbed)
-               rootfr_tot = rootfr_tot + col_cinput_rootfr(fc,j) * dzsoi_decomp(j)
+               rootfr_tot = rootfr_tot + col_cinput_rootfr(c,j) * dzsoi_decomp(j)
                surface_prof_tot = surface_prof_tot + surface_prof(j) * dzsoi_decomp(j)
             end do
             if ( (altmax_lastyear_indx(c) > 0) .and. (rootfr_tot > 0._r8) .and. (surface_prof_tot > 0._r8) ) then
-               !$acc loop vector independent 
                do j = 1,  min(max(altmax_lastyear_indx(c), 1), nlevdecomp)
-                  nfixation_prof(c,j) = col_cinput_rootfr(fc,j) / rootfr_tot
+                  nfixation_prof(c,j) = col_cinput_rootfr(c,j) / rootfr_tot
                   if (j <= nlevbed) then
                      ndep_prof(c,j) = surface_prof(j)/ surface_prof_tot
                      pdep_prof(c,j) = surface_prof(j)/ surface_prof_tot
                   end if
                end do
             else
-               nfixation_prof(c,1) = 1._r8/dzsoi_decomp(1)
-               ndep_prof(c,1) = 1._r8/dzsoi_decomp(1)
-               pdep_prof(c,1) = 1._r8/dzsoi_decomp(1) 
+               nfixation_prof(c,1) = 1./dzsoi_decomp(1)
+               ndep_prof(c,1) = 1./dzsoi_decomp(1)
+               pdep_prof(c,1) = 1./dzsoi_decomp(1) 
             endif
          end do
 
       else
 
          ! for one layer decomposition model, set profiles to unity
-         !$acc parallel loop independent gang vector collapse(2) default(present)
-         do j = 1, nlevdecomp_full
-            do fp = 1,num_soilp
-               p = filter_soilp(fp) 
-               leaf_prof(p, j) = 1._r8
-               froot_prof(p, j) = 1._r8
-               croot_prof(p, j) = 1._r8
-               stem_prof(p, j) = 1._r8
-            end do 
-         end do 
-
-         !$acc parallel loop independent gang vector collapse(2) default(present)
-         do j = 1, nlevdecomp_full
-            do fc = 1, num_soilc 
-               c = filter_soilc(fc) 
-               nfixation_prof(c, j) = 1._r8
-               ndep_prof(c, j) = 1._r8
-               pdep_prof(c, j) = 1._r8
-            end do 
-         end do 
+         leaf_prof(begp:endp, :) = 1._r8
+         froot_prof(begp:endp, :) = 1._r8
+         croot_prof(begp:endp, :) = 1._r8
+         stem_prof(begp:endp, :) = 1._r8
+         nfixation_prof(begc:endc, :) = 1._r8
+         ndep_prof(begc:endc, :) = 1._r8
+         pdep_prof(begc:endc, :) = 1._r8
 
       end if
 
+
       ! check to make sure integral of all profiles = 1.
-      erridx = 0 
-     !! !$acc parallel loop independent gang worker default(present) private(ndep_prof_sum, nfixation_prof_sum, pdep_prof_sum)&
-     !! !$acc       copy(erridx) 
-     !! do fc = 1,num_soilc
-     !!    c = filter_soilc(fc)
-     !!    ndep_prof_sum = 0._r8
-     !!    nfixation_prof_sum = 0._r8
-     !!    pdep_prof_sum = 0._r8
-     !!   !$acc loop vector reduction(+:ndep_prof_sum, nfixation_prof_sum, pdep_prof_sum)  
-     !!    do j = 1, nlevdecomp
-     !!       ndep_prof_sum = ndep_prof_sum + ndep_prof(c,j) *  dzsoi_decomp(j)
-     !!       nfixation_prof_sum = nfixation_prof_sum + nfixation_prof(c,j) *  dzsoi_decomp(j)
-     !!       pdep_prof_sum = pdep_prof_sum + pdep_prof(c,j) *  dzsoi_decomp(j)
-     !!    end do
-     !!    if ( ( abs(ndep_prof_sum - 1._r8) > delta ) .or.  ( abs(nfixation_prof_sum - 1._r8) > delta ) .or. &
-     !!         ( abs(pdep_prof_sum - 1._r8) > delta )  ) then
-     !!         erridx = c
-     !!     end if 
-     !! end do
-     !! if(erridx .ne. 0 ) then 
-     !!       !NOTE: Have to incorporate proper copyout data directives here 
-     !!       write(iulog, *) 'profile sums: ', ndep_prof_sum, nfixation_prof_sum, pdep_prof_sum
-     !!       write(iulog, *) 'c: ', erridx
-     !!       !write(iulog, *) 'altmax_lastyear_indx: ', altmax_lastyear_indx(c)
-     !!       !write(iulog, *) 'nfixation_prof: ', nfixation_prof(c,:)
-     !!       !write(iulog, *) 'ndep_prof: ', ndep_prof(c,:)
-     !!       !write(iulog, *) 'pdep_prof: ', pdep_prof(c,:)
-     !!       !write(iulog, *) 'cinput_rootfr: ', col_cinput_rootfr(fc,:)
-     !!       !write(iulog, *) 'dzsoi_decomp: ', dzsoi_decomp(:)
-     !!       !write(iulog, *) 'surface_prof: ', surface_prof(:)
-     !!       !write(iulog, *) 'npfts(c): ', col_pp%npfts(c)
-     !!       !do p = col_pp%pfti(c), col_pp%pftf(c)
-     !!       !   write(iulog, *) 'p, itype(p), wtcol(p): ', p, veg_pp%itype(p), veg_pp%wtcol(p)
-     !!       !   write(iulog, *) 'cinput_rootfr(p,:): ', cinput_rootfr(p,:)
-     !!       !end do
-     !!       call endrun(msg=" ERROR: _prof_sum-1>delta"//errMsg(__FILE__, __LINE__))
-     !!endif
-   
-     !!erridx = 0 
-     !! !$acc parallel loop independent gang worker default(present) &
-     !! !$acc  private(froot_prof_sum,croot_prof_sum,leaf_prof_sum,stem_prof_sum) copy(erridx)  
-     !! do fp = 1,num_soilp
-     !!    p = filter_soilp(fp)
-     !!    froot_prof_sum = 0._r8
-     !!    croot_prof_sum = 0._r8 
-     !!    leaf_prof_sum = 0._r8 
-     !!    stem_prof_sum = 0._r8
-     !!    !$acc loop vector reduction(+:froot_prof_sum,croot_prof_sum,leaf_prof_sum,stem_prof_sum)
-     !!    do j = 1, nlevdecomp
-     !!       froot_prof_sum = froot_prof_sum + froot_prof(p,j) *  dzsoi_decomp(j)
-     !!       croot_prof_sum = croot_prof_sum + croot_prof(p,j) *  dzsoi_decomp(j)
-     !!       leaf_prof_sum = leaf_prof_sum + leaf_prof(p,j) *  dzsoi_decomp(j)
-     !!       stem_prof_sum = stem_prof_sum + stem_prof(p,j) *  dzsoi_decomp(j)
-     !!    end do
-     !!    if ( ( abs(froot_prof_sum - 1._r8) > delta ) .or.  ( abs(croot_prof_sum - 1._r8) > delta ) .or. &
-     !!         ( abs(stem_prof_sum - 1._r8) > delta ) .or.  ( abs(leaf_prof_sum - 1._r8) > delta ) ) then
-     !!         print *, "froot_prof_sum:",froot_prof_sum
-     !!         erridx = p 
-     !!    endif
-     !! end do
-     !! if(erridx .ne. 0) then 
-     !!       write(iulog, *) 'p: ', p
-     !!       call endrun(msg=' ERROR: sum-1 > delta'//errMsg(__FILE__, __LINE__))
-     !!  end if
+      do fc = 1,num_soilc
+         c = filter_soilc(fc)
+         ndep_prof_sum = 0.
+         nfixation_prof_sum = 0.
+         pdep_prof_sum = 0.
+         do j = 1, nlevdecomp
+            ndep_prof_sum = ndep_prof_sum + ndep_prof(c,j) *  dzsoi_decomp(j)
+            nfixation_prof_sum = nfixation_prof_sum + nfixation_prof(c,j) *  dzsoi_decomp(j)
+            pdep_prof_sum = pdep_prof_sum + pdep_prof(c,j) *  dzsoi_decomp(j)
+         end do
+         if ( ( abs(ndep_prof_sum - 1._r8) > delta ) .or.  ( abs(nfixation_prof_sum - 1._r8) > delta ) .or. &
+              ( abs(pdep_prof_sum - 1._r8) > delta )  ) then
+            write(iulog, *) 'profile sums: ', ndep_prof_sum, nfixation_prof_sum, pdep_prof_sum
+            write(iulog, *) 'c: ', c
+            write(iulog, *) 'altmax_lastyear_indx: ', altmax_lastyear_indx(c)
+            write(iulog, *) 'nfixation_prof: ', nfixation_prof(c,:)
+            write(iulog, *) 'ndep_prof: ', ndep_prof(c,:)
+            write(iulog, *) 'pdep_prof: ', pdep_prof(c,:)
+            write(iulog, *) 'cinput_rootfr: ', col_cinput_rootfr(c,:)
+            write(iulog, *) 'dzsoi_decomp: ', dzsoi_decomp(:)
+            write(iulog, *) 'surface_prof: ', surface_prof(:)
+            write(iulog, *) 'npfts(c): ', col_pp%npfts(c)
+            do p = col_pp%pfti(c), col_pp%pfti(c) + col_pp%npfts(c) -1
+               write(iulog, *) 'p, itype(p), wtcol(p): ', p, veg_pp%itype(p), veg_pp%wtcol(p)
+               write(iulog, *) 'cinput_rootfr(p,:): ', cinput_rootfr(p,:)
+            end do
+            call endrun(msg=" ERROR: _prof_sum-1>delta"//errMsg(__FILE__, __LINE__))
+         endif
+      end do
+
+      do fp = 1,num_soilp
+         p = filter_soilp(fp)
+         froot_prof_sum = 0.
+         croot_prof_sum = 0.
+         leaf_prof_sum = 0.
+         stem_prof_sum = 0.
+         do j = 1, nlevdecomp
+            froot_prof_sum = froot_prof_sum + froot_prof(p,j) *  dzsoi_decomp(j)
+            croot_prof_sum = croot_prof_sum + croot_prof(p,j) *  dzsoi_decomp(j)
+            leaf_prof_sum = leaf_prof_sum + leaf_prof(p,j) *  dzsoi_decomp(j)
+            stem_prof_sum = stem_prof_sum + stem_prof(p,j) *  dzsoi_decomp(j)
+         end do
+         if ( ( abs(froot_prof_sum - 1._r8) > delta ) .or.  ( abs(croot_prof_sum - 1._r8) > delta ) .or. &
+              ( abs(stem_prof_sum - 1._r8) > delta ) .or.  ( abs(leaf_prof_sum - 1._r8) > delta ) ) then
+            write(iulog, *) 'profile sums: ', froot_prof_sum, croot_prof_sum, leaf_prof_sum, stem_prof_sum
+            call endrun(msg=' ERROR: sum-1 > delta'//errMsg(__FILE__, __LINE__))
+         endif
+      end do
 
-      !$acc exit data delete(&
-      !$acc surface_prof(:), &
-      !$acc cinput_rootfr(:,:) , &
-      !$acc col_cinput_rootfr(:,:), &
-      !$acc froot_prof_sum, &
-      !$acc croot_prof_sum, &
-      !$acc leaf_prof_sum , &
-      !$acc stem_prof_sum , &
-      !$acc ndep_prof_sum , &
-      !$acc nfixation_prof_sum , & 
-      !$acc pdep_prof_sum , &
-      !$acc rootfr_tot, sum_rootfr,&
-      !$acc rootprof_exp, surfprof_exp) 
     end associate 
 
   end subroutine decomp_vertprofiles
diff --git a/components/elm/src/biogeochem/WoodProductsMod.F90 b/components/elm/src/biogeochem/WoodProductsMod.F90
index 46d40c9a57..e3d848fff0 100644
--- a/components/elm/src/biogeochem/WoodProductsMod.F90
+++ b/components/elm/src/biogeochem/WoodProductsMod.F90
@@ -35,25 +35,26 @@ contains
     ! with changes in landcover, and in CNHarvest(), for gains associated with wood harvest.
     !
     ! !ARGUMENTS:
-    !! !$acc routine seq
+      !$acc routine seq
     integer                    , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                    , intent(in)    :: filter_soilc(:) ! filter for soil columns
     real(r8)   :: dt       ! time step (seconds)
+
+
     !
     ! !LOCAL VARIABLES:
     integer  :: fc       ! lake filter indices
     integer  :: c        ! indices
-    real(r8),parameter :: kprod10=7.2e-9_r8   ! decay constant for 10-year product pool
-    real(r8),parameter :: kprod100=7.2e-10_r8 ! decay constant for 100-year product pool
+    real(r8) :: kprod10  ! decay constant for 10-year product pool
+    real(r8) :: kprod100 ! decay constant for 100-year product pool
     !-----------------------------------------------------------------------
     dt = dtime_mod
     ! calculate column-level losses from product pools
     ! the following (1/s) rate constants result in ~90% loss of initial state over 10 and 100 years,
     ! respectively, using a discrete-time fractional decay algorithm.
-    ! kprod10 = 7.2e-9
-    ! kprod100 = 7.2e-10
+    kprod10 = 7.2e-9
+    kprod100 = 7.2e-10
 
-    !$acc parallel loop independent gang vector default(present) private(c)
     do fc = 1,num_soilc
        c = filter_soilc(fc)
 
@@ -80,7 +81,6 @@ contains
 
 
     ! update wood product state variables
-    !$acc parallel loop independent gang vector default(present) private(c) 
     do fc = 1,num_soilc
        c = filter_soilc(fc)
 
diff --git a/components/elm/src/biogeophys/ActiveLayerMod.F90 b/components/elm/src/biogeophys/ActiveLayerMod.F90
index e04b4e8256..e2b3a88c28 100644
--- a/components/elm/src/biogeophys/ActiveLayerMod.F90
+++ b/components/elm/src/biogeophys/ActiveLayerMod.F90
@@ -8,11 +8,11 @@ module ActiveLayerMod
   use shr_kind_mod    , only : r8 => shr_kind_r8
   use shr_const_mod   , only : SHR_CONST_TKFRZ
   use elm_varctl      , only : iulog
+  use TemperatureType , only : temperature_type
   use CanopyStateType , only : canopystate_type
   use GridcellType    , only : grc_pp       
   use ColumnType      , only : col_pp
-  use ColumnDataType  , only : col_es
-  use timeinfoMod 
+  use ColumnDataType  , only : col_es  
   !
   implicit none
   save
@@ -25,7 +25,8 @@ module ActiveLayerMod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine alt_calc(num_soilc, filter_soilc, canopystate_vars) 
+  subroutine alt_calc(num_soilc, filter_soilc, &
+       temperature_vars, canopystate_vars) 
     !
     ! !DESCRIPTION:
     !  define active layer thickness similarly to frost_table, except set as deepest thawed layer and define on nlevgrnd
@@ -42,14 +43,16 @@ contains
     !  initialized to valid values, so I think this is okay.
     !
     ! !USES:
-    !$acc routine seq 
     use shr_const_mod    , only : SHR_CONST_TKFRZ
     use elm_varpar       , only : nlevgrnd
+    use clm_time_manager , only : get_curr_date, get_step_size
+    use elm_varctl       , only : iulog
     use elm_varcon       , only : zsoi
     !
     ! !ARGUMENTS:
     integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
+    type(temperature_type) , intent(in)    :: temperature_vars
     type(canopystate_type) , intent(inout) :: canopystate_vars
     !
     ! !LOCAL VARIABLES:
@@ -78,13 +81,9 @@ contains
 
       ! on a set annual timestep, update annual maxima
       ! make this 1 January for NH columns, 1 July for SH columns
-      ! call get_curr_date(year, mon, day, sec)
-      dtime =  int(dtime_mod)
-      year = year_curr 
-      mon = mon_curr
-      day = day_curr 
-      sec = secs_curr
-      if ( (mon .eq. 1) .and. (day .eq. 1) .and. ( sec / int(dtime) .eq. 1) ) then
+      call get_curr_date(year, mon, day, sec)
+      dtime =  get_step_size()
+      if ( (mon .eq. 1) .and. (day .eq. 1) .and. ( sec / dtime .eq. 1) ) then
          do fc = 1,num_soilc
             c = filter_soilc(fc)
             g = col_pp%gridcell(c)
@@ -145,6 +144,7 @@ contains
             endif
          endif
 
+
          ! if appropriate, update maximum annual active layer thickness
          if (alt(c) > altmax(c)) then
             altmax(c) = alt(c)
diff --git a/components/elm/src/biogeophys/AerosolMod.F90 b/components/elm/src/biogeophys/AerosolMod.F90
index e5095b38da..698124d5d2 100644
--- a/components/elm/src/biogeophys/AerosolMod.F90
+++ b/components/elm/src/biogeophys/AerosolMod.F90
@@ -12,7 +12,7 @@ module AerosolMod
   use ColumnType       , only : col_pp
   use ColumnDataType   , only : col_ws, col_wf
 
-  use timeinfoMod, only : dtime_mod 
+  use timeinfoMod
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -38,6 +38,7 @@ contains
     ! (based on new snow level state, after SnowFilter is rebuilt.
     ! NEEDS TO BE AFTER SnowFiler is rebuilt in Hydrology2, otherwise there
     ! can be zero snow layers but an active column in filter)
+    !$acc routine seq
     ! !ARGUMENTS:
     type(bounds_type)     , intent(in )   :: bounds
     integer               , intent(in)    :: num_on         ! number of column filter-ON points
@@ -47,10 +48,10 @@ contains
     type(aerosol_type)    , intent(inout) :: aerosol_vars
     !
     ! !LOCAL VARIABLES:
-    integer  :: g,l,c,j,fc,snl_idx      ! indices
+    real(r8) :: dtime           ! land model time step (sec)
+    integer  :: g,l,c,j,fc      ! indices
     real(r8) :: snowmass        ! liquid+ice snow mass in a layer [kg/m2]
     real(r8) :: snowcap_scl_fct ! temporary factor used to correct for snow capping
-    real(r8) :: sum1,sum2,sum3 
     !-----------------------------------------------------------------------
 
     associate(                                                &
@@ -91,14 +92,22 @@ contains
          mss_cnc_dst4  => aerosol_vars%mss_cnc_dst4_col       & ! Output: [real(r8) (:,:) ]  mass concentration of dust species 4 (col,lyr) [kg/kg]
          )
 
-      !$acc enter data create(sum1,sum2,sum3)
-      if(.not. use_extrasnowlayers) then 
-         !$acc parallel loop independent gang vector collapse(2) default(present) 
+      dtime = dtime_mod
+
+      do fc = 1, num_on
+         c = filter_on(fc)
+
+         ! Zero column-integrated aerosol mass before summation
+         mss_bc_col(c)  = 0._r8
+         mss_oc_col(c)  = 0._r8
+         mss_dst_col(c) = 0._r8
+
          do j = -nlevsno+1, 0
-            do fc = 1, num_on 
-               c = filter_on(fc)
-               ! layer mass of snow:
-               snowmass = h2osoi_ice(c,j) + h2osoi_liq(c,j)
+
+            ! layer mass of snow:
+            snowmass = h2osoi_ice(c,j) + h2osoi_liq(c,j)
+
+            if (.not. use_extrasnowlayers) then
                ! Correct the top layer aerosol mass to account for snow capping. 
                ! This approach conserves the aerosol mass concentration
                ! (but not the aerosol amss) when snow-capping is invoked
@@ -106,7 +115,7 @@ contains
                if (j == snl(c)+1) then
                   if (do_capsnow(c)) then 
 
-                     snowcap_scl_fct = snowmass / (snowmass + (qflx_snwcp_ice(c)*dtime_mod))
+                     snowcap_scl_fct = snowmass / (snowmass + (qflx_snwcp_ice(c)*dtime))
 
                      mss_bcpho(c,j) = mss_bcpho(c,j)*snowcap_scl_fct
                      mss_bcphi(c,j) = mss_bcphi(c,j)*snowcap_scl_fct
@@ -119,30 +128,22 @@ contains
                      mss_dst4(c,j)  = mss_dst4(c,j)*snowcap_scl_fct
                   endif
                endif
-
-            end do 
-         end do 
-      end if 
-      
-      !$acc parallel loop independent gang vector collapse(2) default(present) 
-      do j = -nlevsno+1, 0
-         do fc = 1, num_on
-            c = filter_on(fc)
-
-            ! layer mass of snow:
-            snowmass = h2osoi_ice(c,j) + h2osoi_liq(c,j)
+            endif
 
             if (j >= snl(c)+1) then
 
                mss_bctot(c,j)     = mss_bcpho(c,j) + mss_bcphi(c,j)
+               mss_bc_col(c)      = mss_bc_col(c)  + mss_bctot(c,j)
                mss_cnc_bcphi(c,j) = mss_bcphi(c,j) / snowmass
                mss_cnc_bcpho(c,j) = mss_bcpho(c,j) / snowmass
 
                mss_octot(c,j)     = mss_ocpho(c,j) + mss_ocphi(c,j)
+               mss_oc_col(c)      = mss_oc_col(c)  + mss_octot(c,j)
                mss_cnc_ocphi(c,j) = mss_ocphi(c,j) / snowmass
                mss_cnc_ocpho(c,j) = mss_ocpho(c,j) / snowmass
 
                mss_dsttot(c,j)    = mss_dst1(c,j)  + mss_dst2(c,j) + mss_dst3(c,j) + mss_dst4(c,j)
+               mss_dst_col(c)     = mss_dst_col(c) + mss_dsttot(c,j)
                mss_cnc_dst1(c,j)  = mss_dst1(c,j)  / snowmass
                mss_cnc_dst2(c,j)  = mss_dst2(c,j)  / snowmass
                mss_cnc_dst3(c,j)  = mss_dst3(c,j)  / snowmass
@@ -176,80 +177,48 @@ contains
             endif
          enddo
 
-         
-      enddo
-      !$acc parallel loop independent gang vector default(present)
-      do fc = 1, num_on
-         c = filter_on(fc)
-         snl_idx = snl(c)+1
          ! top-layer diagnostics
-         h2osno_top(c)  = h2osoi_ice(c,snl_idx) + h2osoi_liq(c,snl_idx) !TODO MV - is this correct to be placed here???
-         mss_bc_top(c)  = mss_bctot(c,snl_idx)
-         mss_oc_top(c)  = mss_octot(c,snl_idx)
-         mss_dst_top(c) = mss_dsttot(c,snl_idx)
-      end do
-      
-      !$acc parallel loop gang worker independent default(present) private(sum1,sum2,sum3)
-      do fc = 1, num_on
-         c = filter_on(fc)
-         sum1 = 0._r8
-         sum2 = 0._r8 
-         sum3 = 0._r8
-         !$acc loop vector reduction(+:sum1,sum2,sum3) 
-         do j = snl(c)+1,0
-            if (j >= snl(c)+1) then
-               sum1 = sum1 + mss_bctot(c,j)
-               sum2 = sum2 + mss_octot(c,j)
-               sum3 = sum3 + mss_dsttot(c,j)
-            end if
-         end do 
-         mss_bc_col(c) = sum1 
-         mss_bc_col(c) = sum2 
-         mss_dst_col(c) = sum3 
-      end do 
+         h2osno_top(c)  = h2osoi_ice(c,snl(c)+1) + h2osoi_liq(c,snl(c)+1) !TODO MV - is this correct to be placed here???
+         mss_bc_top(c)  = mss_bctot(c,snl(c)+1)
+         mss_oc_top(c)  = mss_octot(c,snl(c)+1)
+         mss_dst_top(c) = mss_dsttot(c,snl(c)+1)
+      enddo
 
       ! Zero mass variables in columns without snow
-      !$acc parallel loop independent gang vector default(present) 
+
       do fc = 1, num_off
          c = filter_off(fc)
+
          mss_bc_top(c)      = 0._r8
          mss_bc_col(c)      = 0._r8
-         
+         mss_bcpho(c,:)     = 0._r8
+         mss_bcphi(c,:)     = 0._r8
+         mss_bctot(c,:)     = 0._r8
+         mss_cnc_bcphi(c,:) = 0._r8
+         mss_cnc_bcpho(c,:) = 0._r8
+
          mss_oc_top(c)      = 0._r8
          mss_oc_col(c)      = 0._r8
-         
+         mss_ocpho(c,:)     = 0._r8
+         mss_ocphi(c,:)     = 0._r8
+         mss_octot(c,:)     = 0._r8
+         mss_cnc_ocphi(c,:) = 0._r8
+         mss_cnc_ocpho(c,:) = 0._r8
+
          mss_dst_top(c)     = 0._r8
          mss_dst_col(c)     = 0._r8
-      enddo
+         mss_dst1(c,:)      = 0._r8
+         mss_dst2(c,:)      = 0._r8
+         mss_dst3(c,:)      = 0._r8
+         mss_dst4(c,:)      = 0._r8
+         mss_dsttot(c,:)    = 0._r8
 
-      !$acc parallel loop independent gang vector collapse(2) default(present)
-      do j=-nlevsno+1,0
-         do fc = 1, num_off
-            c = filter_off(fc)
-            mss_dst1(c,j)      = 0._r8
-            mss_dst2(c,j)      = 0._r8
-            mss_dst3(c,j)      = 0._r8
-            mss_dst4(c,j)      = 0._r8
-            mss_dsttot(c,j)    = 0._r8
-   
-            mss_cnc_dst1(c,j)  = 0._r8
-            mss_cnc_dst2(c,j)  = 0._r8
-            mss_cnc_dst3(c,j)  = 0._r8
-            mss_cnc_dst4(c,j)  = 0._r8
-            mss_ocpho(c,j)     = 0._r8
-            mss_ocphi(c,j)     = 0._r8
-            mss_octot(c,j)     = 0._r8
-            mss_cnc_ocphi(c,j) = 0._r8
-            mss_cnc_ocpho(c,j) = 0._r8
-
-            mss_bcpho(c,j)     = 0._r8
-            mss_bcphi(c,j)     = 0._r8
-            mss_bctot(c,j)     = 0._r8
-            mss_cnc_bcphi(c,j) = 0._r8
-            mss_cnc_bcpho(c,j) = 0._r8
-         end do 
-      end do 
-      !$acc exit data delete(sum1,sum2,sum3)
+         mss_cnc_dst1(c,:)  = 0._r8
+         mss_cnc_dst2(c,:)  = 0._r8
+         mss_cnc_dst3(c,:)  = 0._r8
+         mss_cnc_dst4(c,:)  = 0._r8
+
+      enddo
 
     end associate
 
@@ -261,6 +230,7 @@ contains
     !
     ! !DESCRIPTION:
     ! Compute aerosol fluxes through snowpack and aerosol deposition fluxes into top layere
+    !$acc routine seq
     ! !ARGUMENTS:
     type(bounds_type)  , intent(in)    :: bounds
     integer            , intent(in)    :: num_snowc       ! number of snow points in column filter
@@ -269,6 +239,7 @@ contains
     type(aerosol_type) , intent(inout) :: aerosol_vars
     !
     ! !LOCAL VARIABLES:
+    real(r8) :: dtime      ! land model time step (sec)
     integer  :: c,g,j,fc
     !-----------------------------------------------------------------------
 
@@ -318,8 +289,6 @@ contains
     ! (cloud-borne) aerosol, and "pho" flavors are interstitial
     ! aerosol. "wet" and "dry" fluxes of BC and OC specified here are
     ! purely diagnostic
-
-    !$acc parallel loop independent gang vector default(present)
     do c = bounds%begc,bounds%endc
        g = col_pp%gridcell(c)
 
@@ -355,7 +324,6 @@ contains
     ! species are distinguished in model, other fluxes (e.g., dry and
     ! wet BC/OC) are purely diagnostic.
 
-      !$acc parallel loop independent gang vector default(present)
       do c = bounds%begc,bounds%endc
          g = col_pp%gridcell(c)
 
@@ -391,20 +359,19 @@ contains
       ! is in the top layer after deposition, and is not immediately
       ! washed out before radiative calculations are done
 
-      !$acc parallel loop independent gang vector default(present) &
-      !$acc present(mss_bcphi(:,:),mss_bcpho(:,:),mss_ocphi(:,:),mss_ocpho(:,:), &
-      !$acc  mss_dst1(:,:),mss_dst2(:,:),mss_dst3(:,:),mss_dst4(:,:))
+      dtime = dtime_mod
+
       do fc = 1, num_snowc
          c = filter_snowc(fc)
-         mss_bcphi(c,snl(c)+1) = mss_bcphi(c,snl(c)+1) + (flx_bc_dep_phi(c)*dtime_mod)
-         mss_bcpho(c,snl(c)+1) = mss_bcpho(c,snl(c)+1) + (flx_bc_dep_pho(c)*dtime_mod)
-         mss_ocphi(c,snl(c)+1) = mss_ocphi(c,snl(c)+1) + (flx_oc_dep_phi(c)*dtime_mod)
-         mss_ocpho(c,snl(c)+1) = mss_ocpho(c,snl(c)+1) + (flx_oc_dep_pho(c)*dtime_mod)
-
-         mss_dst1(c,snl(c)+1) = mss_dst1(c,snl(c)+1) + (flx_dst_dep_dry1(c) + flx_dst_dep_wet1(c))*dtime_mod
-         mss_dst2(c,snl(c)+1) = mss_dst2(c,snl(c)+1) + (flx_dst_dep_dry2(c) + flx_dst_dep_wet2(c))*dtime_mod
-         mss_dst3(c,snl(c)+1) = mss_dst3(c,snl(c)+1) + (flx_dst_dep_dry3(c) + flx_dst_dep_wet3(c))*dtime_mod
-         mss_dst4(c,snl(c)+1) = mss_dst4(c,snl(c)+1) + (flx_dst_dep_dry4(c) + flx_dst_dep_wet4(c))*dtime_mod
+         mss_bcphi(c,snl(c)+1) = mss_bcphi(c,snl(c)+1) + (flx_bc_dep_phi(c)*dtime)
+         mss_bcpho(c,snl(c)+1) = mss_bcpho(c,snl(c)+1) + (flx_bc_dep_pho(c)*dtime)
+         mss_ocphi(c,snl(c)+1) = mss_ocphi(c,snl(c)+1) + (flx_oc_dep_phi(c)*dtime)
+         mss_ocpho(c,snl(c)+1) = mss_ocpho(c,snl(c)+1) + (flx_oc_dep_pho(c)*dtime)
+
+         mss_dst1(c,snl(c)+1) = mss_dst1(c,snl(c)+1) + (flx_dst_dep_dry1(c) + flx_dst_dep_wet1(c))*dtime
+         mss_dst2(c,snl(c)+1) = mss_dst2(c,snl(c)+1) + (flx_dst_dep_dry2(c) + flx_dst_dep_wet2(c))*dtime
+         mss_dst3(c,snl(c)+1) = mss_dst3(c,snl(c)+1) + (flx_dst_dep_dry3(c) + flx_dst_dep_wet3(c))*dtime
+         mss_dst4(c,snl(c)+1) = mss_dst4(c,snl(c)+1) + (flx_dst_dep_dry4(c) + flx_dst_dep_wet4(c))*dtime
       end do
 
     end associate
diff --git a/components/elm/src/biogeophys/BalanceCheckMod.F90 b/components/elm/src/biogeophys/BalanceCheckMod.F90
index 6ee6173059..723e9a72ff 100644
--- a/components/elm/src/biogeophys/BalanceCheckMod.F90
+++ b/components/elm/src/biogeophys/BalanceCheckMod.F90
@@ -26,6 +26,7 @@ module BalanceCheckMod
   use ColumnDataType     , only : col_ef, col_ws, col_wf
   use VegetationType     , only : veg_pp
   use VegetationDataType , only : veg_ef, veg_ws
+
   use timeinfoMod
   !
   ! !PUBLIC TYPES:
@@ -161,7 +162,7 @@ contains
      ! The error for water balance:
      !
      ! error = abs(precipitation - change of water storage - evaporation - runoff)
-     !$acc routine seq 
+     !
      ! !USES:
      use elm_varcon        , only : spval
      use column_varcon     , only : icol_roof, icol_sunwall, icol_shadewall
@@ -169,7 +170,7 @@ contains
      use landunit_varcon   , only : istice_mec, istdlak, istsoil,istcrop,istwet
      use elm_varctl        , only : create_glacier_mec_landunit
      use elm_initializeMod , only : surfalb_vars
-     use domainMod         , only : ldomain_gpu
+     use domainMod         , only : ldomain
      use CanopyStateType   , only : canopystate_type
      use subgridAveMod
      !
@@ -343,6 +344,7 @@ contains
        do fc = 1,num_do_smb_c
           c = filter_do_smb_c(fc)
           g = col_pp%gridcell(c)
+!          write(iulog,*)'WARNING:  glc_dyn_runoff_routing = ', glc_dyn_runoff_routing(g)  ! TKT
           if (glc_dyn_runoff_routing(g)) then
              errh2o(c) = errh2o(c) + qflx_glcice_frz(c)*dtime
              errh2o(c) = errh2o(c) - qflx_glcice_melt(c)*dtime
@@ -369,7 +371,7 @@ contains
           if ((col_pp%itype(indexc) == icol_roof .or. &
                col_pp%itype(indexc) == icol_road_imperv .or. &
                col_pp%itype(indexc) == icol_road_perv) .and. &
-               abs(errh2o(indexc)) > 1.e-4_r8 ) then
+               abs(errh2o(indexc)) > 1.e-4_r8 .and. (nstep > 2) ) then
 
              write(iulog,*)'clm urban model is stopping - error is greater than 1e-4 (mm)'
              write(iulog,*)'nstep                      = ',nstep
@@ -381,7 +383,7 @@ contains
              write(iulog,*)'qflx_evap_tot              = ',qflx_evap_tot(indexc)
              write(iulog,*)'qflx_irrig                 = ',qflx_irrig(indexc)
              write(iulog,*)'qflx_supply                = ',atm2lnd_vars%supply_grc(g)
-             write(iulog,*)'f_grd                      = ',ldomain_gpu%f_grd(g)
+             write(iulog,*)'f_grd                      = ',ldomain%f_grd(g)
              write(iulog,*)'qflx_surf                  = ',qflx_surf(indexc)
              write(iulog,*)'qflx_qrgwl                 = ',qflx_qrgwl(indexc)
              write(iulog,*)'qflx_drain                 = ',qflx_drain(indexc)
@@ -391,7 +393,7 @@ contains
              write(iulog,*)'elm model is stopping'
              call endrun(decomp_index=indexc, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
 
-          else if (abs(errh2o(indexc)) > 1.e-4_r8 ) then
+          else if (abs(errh2o(indexc)) > 1.e-4_r8 .and. (nstep > 2) ) then
 
              write(iulog,*)'elm model is stopping - error is greater than 1e-4 (mm)'
              write(iulog,*)'colum number               = ',col_pp%gridcell(indexc)
@@ -406,7 +408,7 @@ contains
              write(iulog,*)'qflx_surf_irrig_col        = ',qflx_surf_irrig_col(indexc)
              write(iulog,*)'qflx_over_supply_col       = ',qflx_over_supply_col(indexc)
              write(iulog,*)'qflx_supply                = ',atm2lnd_vars%supply_grc(g)
-             write(iulog,*)'f_grd                      = ',ldomain_gpu%f_grd(g)
+             write(iulog,*)'f_grd                      = ',ldomain%f_grd(g)
              write(iulog,*)'qflx_surf                  = ',qflx_surf(indexc)
              write(iulog,*)'qflx_h2osfc_surf           = ',qflx_h2osfc_surf(indexc)
              write(iulog,*)'qflx_qrgwl                 = ',qflx_qrgwl(indexc)
@@ -659,9 +661,6 @@ contains
           write(iulog,*)'WARNING: BalanceCheck: longwave energy balance error (W/m2)'
           write(iulog,*)'nstep        = ',nstep
           write(iulog,*)'errlon       = ',errlon(indexp)
-          write(iulog,*) "lwrad_out:",eflx_lwrad_out(indexp)
-          write(iulog,*) "lwrad_net: ",eflx_lwrad_net(indexp)
-          write(iulog,*) "forc_lwrad:", forc_lwrad(veg_pp%topounit(indexp))
           if (abs(errlon(indexp)) > 1.e-5_r8 ) then
              write(iulog,*)'elm model is stopping - error is greater than 1e-5 (W/m2)'
              call endrun(decomp_index=indexp, elmlevel=namep, msg=errmsg(__FILE__, __LINE__))
@@ -724,17 +723,14 @@ contains
           end if
        end do
        if ( found ) then
-#ifndef _OPENACC
           write(iulog,*)'WARNING: BalanceCheck: soil balance error (W/m2)'
           write(iulog,*)'nstep         = ',nstep
           write(iulog,*)'errsoi_col    = ',errsoi_col(indexc)
-          write(iulog,*)'gridcell number  = ',col_pp%gridcell(indexc)
-          write(iulog,*)'itype         = ',col_pp%itype(indexc)
-          if (abs(errsoi_col(indexc)) > 1.e-4_r8  .and. (nstep > 2) ) then
+          write(iulog,*)'colum number  = ',col_pp%gridcell(indexc)
+          if (abs(errsoi_col(indexc)) > 1.e-4_r8 .and. (nstep > 2) ) then
              write(iulog,*)'elm model is stopping'
              call endrun(decomp_index=indexc, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
           end if
-#endif 
        end if
 
      end associate
@@ -751,7 +747,7 @@ contains
     ! Initialize column-level water balance at beginning of time step
     !
     ! !USES:
-    use subgridAveMod , only : p2c_1d_filter_parallel,c2g_1d_parallel, urbanf, unity
+    use subgridAveMod , only : p2c,c2g, urbanf, unity
     use elm_varpar    , only : nlevgrnd, nlevsoi, nlevurb
     use column_varcon , only : icol_roof, icol_sunwall, icol_shadewall
     use column_varcon , only : icol_road_perv, icol_road_imperv
@@ -774,7 +770,6 @@ contains
     real(r8) :: h2osoi_liq_depth_intg(bounds%begc:bounds%endc)
     real(r8) :: h2osoi_ice_depth_intg(bounds%begc:bounds%endc)
     real(r8) :: wa_local_col(bounds%begc:bounds%endc)
-    real(r8) :: sum1,sum2,sum3
 
     associate(                                                                        &
          zi                        =>    col_pp%zi                                  , & ! Input:  [real(r8) (:,:) ]  interface level below a "z" level (m)
@@ -798,29 +793,22 @@ contains
          )
 
       ! Set to zero
-      !$acc enter data create( &
-      !$acc begwb_col (:), & 
-      !$acc h2ocan_col(:), &
-      !$acc h2osoi_liq_depth_intg(:), &
-      !$acc h2osoi_ice_depth_intg(:), &
-      !$acc wa_local_col(:), sum1,sum2,sum3 &
-      !$acc )
-      
-      !$acc parallel loop independent gang vector default(present) 
-      do c = bounds%begc, bounds%endc 
-         h2osoi_liq_depth_intg_col(c) = 0._r8
-         h2osoi_ice_depth_intg_col(c) = 0._r8
-         wa_local_col(c) = wa(c)
-      end do 
+      begwb_col (bounds%begc:bounds%endc) = 0._r8
+      h2ocan_col(bounds%begc:bounds%endc) = 0._r8
+      h2osoi_liq_depth_intg(bounds%begc:bounds%endc) = 0._r8
+      h2osoi_ice_depth_intg(bounds%begc:bounds%endc) = 0._r8
+      h2osoi_liq_depth_intg_col(bounds%begc:bounds%endc) = 0._r8
+      h2osoi_ice_depth_intg_col(bounds%begc:bounds%endc) = 0._r8
 
       ! Determine beginning water balance for time step
       ! pft-level canopy water averaged to column
 
-      call p2c_1d_filter_parallel(num_nolakec, filter_nolakec, &
+      call p2c(bounds, num_nolakec, filter_nolakec, &
             h2ocan_patch(bounds%begp:bounds%endp), &
             h2ocan_col(bounds%begc:bounds%endc))
 
-      !$acc parallel loop independent gang vector default(present)
+      wa_local_col(bounds%begc:bounds%endc) = wa(bounds%begc:bounds%endc)
+
       do f = 1, num_nolakec
          c = filter_nolakec(f)
          g = col_pp%gridcell(c)
@@ -834,102 +822,87 @@ contains
          begwb_col(c) = begwb_col(c) + total_plant_stored_h2o(c)
       end do
 
-      !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2)
-      do f = 1, num_nolakec
-         sum1 = 0._r8
-         sum2 = 0._r8 
-         c = filter_nolakec(f)
-         !$acc loop reduction(+:sum1,sum2)
-         do j = 1, nlevgrnd
+      do j = 1, nlevgrnd
+         do f = 1, num_nolakec
+            c = filter_nolakec(f)
             if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
                  .or. col_pp%itype(c) == icol_roof) .and. j > nlevurb) then
             else
-               sum1 = sum1 + h2osoi_liq(c,j)
-               sum2 = sum2 + h2osoi_ice(c,j)
+               begwb_col(c) = begwb_col(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)
+               h2osoi_liq_depth_intg(c) = h2osoi_liq_depth_intg(c) + h2osoi_liq(c,j)
+               h2osoi_ice_depth_intg(c) = h2osoi_ice_depth_intg(c) + h2osoi_ice(c,j)
             end if
          end do
-         begwb_col(c) = begwb_col(c) + sum1 + sum2 
-         h2osoi_liq_depth_intg(c) = sum1 
-         h2osoi_ice_depth_intg(c) = sum2 
       end do
-      
-      !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2)
+
       do f = 1, num_lakec
          c = filter_lakec(f)
-         sum1 = 0._r8 ; sum2 = 0._r8
          begwb_col(c) = h2osno(c)
-         !$acc loop reduction(+:sum1,sum2,sum3)
          do j = 1, nlevgrnd
-            sum1 = sum1 + h2osoi_liq(c,j)
-            sum2 = sum2 + h2osoi_ice(c,j)
+            begwb_col(c) = begwb_col(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)
+            h2osoi_liq_depth_intg(c) = h2osoi_liq_depth_intg(c) + h2osoi_liq(c,j)
+            h2osoi_ice_depth_intg(c) = h2osoi_ice_depth_intg(c) + h2osoi_ice(c,j)
          enddo
-         begwb_col(c) = begwb_col(c) + sum1 +sum2 
-         h2osoi_liq_depth_intg(c) = h2osoi_liq_depth_intg(c) + sum1
-         h2osoi_ice_depth_intg(c) = h2osoi_ice_depth_intg(c) + sum2
-
       end do
 
-      call c2g_1d_parallel(bounds, begwb_col(bounds%begc:bounds%endc), &
+      call c2g(bounds, begwb_col(bounds%begc:bounds%endc), &
            begwb_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type= urbanf, l2g_scale_type=unity,para=.true.)
+           c2l_scale_type= urbanf, l2g_scale_type=unity )
 
-      call c2g_1d_parallel(bounds, wa_local_col(bounds%begc:bounds%endc), &
+      call c2g(bounds, wa_local_col(bounds%begc:bounds%endc), &
            beg_wa_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type= urbanf, l2g_scale_type=unity,para=.true. )
+           c2l_scale_type= urbanf, l2g_scale_type=unity )
 
-      call c2g_1d_parallel(bounds, h2ocan_col(bounds%begc:bounds%endc), &
+      call c2g(bounds, h2ocan_col(bounds%begc:bounds%endc), &
            beg_h2ocan_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type= urbanf, l2g_scale_type=unity,para=.true. )
+           c2l_scale_type= urbanf, l2g_scale_type=unity )
 
-      call c2g_1d_parallel(bounds, h2osno(bounds%begc:bounds%endc), &
+      call c2g(bounds, h2osno(bounds%begc:bounds%endc), &
            beg_h2osno_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type= urbanf, l2g_scale_type=unity,para=.true. )
+           c2l_scale_type= urbanf, l2g_scale_type=unity )
 
-      call c2g_1d_parallel(bounds, h2osfc(bounds%begc:bounds%endc), &
+      call c2g(bounds, h2osfc(bounds%begc:bounds%endc), &
            beg_h2osfc_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type= urbanf, l2g_scale_type=unity,para=.true. )
+           c2l_scale_type= urbanf, l2g_scale_type=unity )
 
-      call c2g_1d_parallel(bounds, h2osoi_liq_depth_intg(bounds%begc:bounds%endc), &
+      call c2g(bounds, h2osoi_liq_depth_intg(bounds%begc:bounds%endc), &
            beg_h2osoi_liq_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type= urbanf, l2g_scale_type=unity,para=.true. )
+           c2l_scale_type= urbanf, l2g_scale_type=unity )
 
-      call c2g_1d_parallel(bounds, h2osoi_ice_depth_intg(bounds%begc:bounds%endc), &
+      call c2g(bounds, h2osoi_ice_depth_intg(bounds%begc:bounds%endc), &
            beg_h2osoi_ice_grc(bounds%begg:bounds%endg), &
-           c2l_scale_type= urbanf, l2g_scale_type=unity,para=.true. )
-
-      !$acc exit data delete( &
-      !$acc begwb_col (:), & 
-      !$acc h2ocan_col(:), &
-      !$acc h2osoi_liq_depth_intg(:), &
-      !$acc h2osoi_ice_depth_intg(:), &
-      !$acc wa_local_col(:),sum1,sum2,sum3 &
-      !$acc )
-           
+           c2l_scale_type= urbanf, l2g_scale_type=unity )
+
     end associate
 
   end subroutine BeginGridWaterBalance
 
    !-----------------------------------------------------------------------
-   subroutine GridBalanceCheck( bounds, &
-        atm2lnd_vars, glc2lnd_vars,  &
-       energyflux_vars, soilhydrology_vars)
+   subroutine GridBalanceCheck( bounds, num_do_smb_c, filter_do_smb_c, &
+        atm2lnd_vars, glc2lnd_vars, solarabs_vars,  &
+       energyflux_vars, canopystate_vars, soilhydrology_vars)
      !
      ! !DESCRIPTION:
-     !$acc routine seq 
+     !
      ! !USES:
      use elm_varcon        , only : spval
      use column_varcon     , only : icol_roof, icol_sunwall, icol_shadewall
      use column_varcon     , only : icol_road_perv, icol_road_imperv
      use landunit_varcon   , only : istice_mec, istdlak, istsoil,istcrop,istwet
      use elm_varctl        , only : create_glacier_mec_landunit
+     use elm_initializeMod , only : surfalb_vars
      use CanopyStateType   , only : canopystate_type
      use subgridAveMod     , only : c2g, urbanf, unity
      !
      ! !ARGUMENTS:
      type(bounds_type)     , intent(in)    :: bounds
+     integer               , intent(in)    :: num_do_smb_c        ! number of columns in filter_do_smb_c
+     integer               , intent(in)    :: filter_do_smb_c (:) ! column filter for points where SMB calculations are done
      type(atm2lnd_type)    , intent(in)    :: atm2lnd_vars
      type(glc2lnd_type)    , intent(in)    :: glc2lnd_vars
+     type(solarabs_type)   , intent(in)    :: solarabs_vars
      type(energyflux_type) , intent(inout) :: energyflux_vars
+     type(canopystate_type), intent(inout) :: canopystate_vars
      type(soilhydrology_type), intent(inout) :: soilhydrology_vars
      !
      ! !LOCAL VARIABLES:
@@ -949,6 +922,7 @@ contains
           forc_lwrad                 =>    atm2lnd_vars%forc_lwrad_downscaled_col     , & ! Input:  [real(r8) (:)   ]  downward infrared (longwave) radiation (W/m**2)
           glc_dyn_runoff_routing     =>    glc2lnd_vars%glc_dyn_runoff_routing_grc    , & ! Input:  [real(r8) (:)   ]  whether we're doing runoff routing appropriate for having a dynamic icesheet
 
+          do_capsnow                 =>    col_ws%do_capsnow             , & ! Input:  [logical (:)    ]  true => do snow capping
           h2osno_col                 =>    col_ws%h2osno                 , & ! Input:  [real(r8) (:)   ]  snow water (mm H2O)
           h2osno_old                 =>    col_ws%h2osno_old             , & ! Input:  [real(r8) (:)   ]  snow water (mm H2O) at previous time step
           frac_sno_eff               =>    col_ws%frac_sno_eff           , & ! Input:  [real(r8) (:)   ]  effective snow fraction
@@ -961,6 +935,7 @@ contains
           endwb_col                  =>    col_ws%endwb                  , & ! Output: [real(r8) (:)   ]  water mass end of the time step
           endwb_grc                  =>    grc_ws%endwb                  , & ! Output: [real(r8) (:)   ]  water mass end of the time step
           total_plant_stored_h2o_col =>    col_ws%total_plant_stored_h2o , & ! Input: [real(r8) (:)   ]  water mass in plant tissues (kg m-2)
+          dwb                        =>    col_wf%dwb                     , & ! Output: [real(r8) (:)   ]  change of water mass within the time step [kg/m2/s]
           qflx_rain_grnd_col         =>    col_wf%qflx_rain_grnd          , & ! Input:  [real(r8) (:)   ]  rain on ground after interception (mm H2O/s) [+]
           qflx_snow_grnd_col         =>    col_wf%qflx_snow_grnd          , & ! Input:  [real(r8) (:)   ]  snow on ground after interception (mm H2O/s) [+]
           qflx_evap_soi              =>    col_wf%qflx_evap_soi           , & ! Input:  [real(r8) (:)   ]  soil evaporation (mm H2O/s) (+ = to atm)
@@ -986,8 +961,50 @@ contains
           qflx_glcice                =>    col_wf%qflx_glcice             , & ! Input:  [real(r8) (:)   ]  flux of new glacier ice (mm H2O /s) [+ if ice grows]
           qflx_glcice_melt           =>    col_wf%qflx_glcice_melt        , & ! Input:  [real(r8) (:)   ]  ice melt (mm H2O/s)
           qflx_glcice_frz            =>    col_wf%qflx_glcice_frz         , & ! Input:  [real(r8) (:)   ]  ice growth (mm H2O/s) [+]
+          qflx_top_soil              =>    col_wf%qflx_top_soil           , & ! Input:  [real(r8) (:)   ]  net water input into soil from top (mm/s)
+          qflx_sl_top_soil           =>    col_wf%qflx_sl_top_soil        , & ! Input:  [real(r8) (:)   ]  liquid water + ice from layer above soil to top soil layer or sent to qflx_qrgwl (mm H2O/s)
+          qflx_liq_dynbal            =>    grc_wf%qflx_liq_dynbal         , & ! Input:  [real(r8) (:)   ]  liq runoff due to dynamic land cover change (mm H2O /s)
+          qflx_ice_dynbal            =>    grc_wf%qflx_ice_dynbal         , & ! Input:  [real(r8) (:)   ]  ice runoff due to dynamic land cover change (mm H2O /s)
+          snow_sources               =>    col_wf%snow_sources            , & ! Output: [real(r8) (:)   ]  snow sources (mm H2O /s)
+          snow_sinks                 =>    col_wf%snow_sinks              , & ! Output: [real(r8) (:)   ]  snow sinks (mm H2O /s)
           qflx_lateral               =>    col_wf%qflx_lateral            , & ! Input:  [real(r8) (:)   ]  lateral flux of water to neighboring column (mm H2O /s)
+
+          eflx_lwrad_out             =>    veg_ef%eflx_lwrad_out       , & ! Input:  [real(r8) (:)   ]  emitted infrared (longwave) radiation (W/m**2)
+          eflx_lwrad_net             =>    veg_ef%eflx_lwrad_net       , & ! Input:  [real(r8) (:)   ]  net infrared (longwave) rad (W/m**2) [+ = to atm]
+          eflx_sh_tot                =>    veg_ef%eflx_sh_tot          , & ! Input:  [real(r8) (:)   ]  total sensible heat flux (W/m**2) [+ to atm]
+          eflx_lh_tot                =>    veg_ef%eflx_lh_tot          , & ! Input:  [real(r8) (:)   ]  total latent heat flux (W/m8*2)  [+ to atm]
+          eflx_soil_grnd             =>    veg_ef%eflx_soil_grnd       , & ! Input:  [real(r8) (:)   ]  soil heat flux (W/m**2) [+ = into soil]
+          eflx_wasteheat_patch       =>    veg_ef%eflx_wasteheat       , & ! Input:  [real(r8) (:)   ]  sensible heat flux from urban heating/cooling sources of waste heat (W/m**2)
+          eflx_heat_from_ac_patch    =>    veg_ef%eflx_heat_from_ac    , & ! Input:  [real(r8) (:)   ]  sensible heat flux put back into canyon due to removal by AC (W/m**2)
+          eflx_traffic_patch         =>    veg_ef%eflx_traffic         , & ! Input:  [real(r8) (:)   ]  traffic sensible heat flux (W/m**2)
+          eflx_dynbal                =>    grc_ef%eflx_dynbal          , & ! Input:  [real(r8) (:)   ]  energy conversion flux due to dynamic land cover change(W/m**2) [+ to atm]
+
+          sabg_soil                  =>    solarabs_vars%sabg_soil_patch              , & ! Input:  [real(r8) (:)   ]  solar radiation absorbed by soil (W/m**2)
+          sabg_snow                  =>    solarabs_vars%sabg_snow_patch              , & ! Input:  [real(r8) (:)   ]  solar radiation absorbed by snow (W/m**2)
+          sabg_chk                   =>    solarabs_vars%sabg_chk_patch               , & ! Input:  [real(r8) (:)   ]  sum of soil/snow using current fsno, for balance check
+          fsa                        =>    solarabs_vars%fsa_patch                    , & ! Input:  [real(r8) (:)   ]  solar radiation absorbed (total) (W/m**2)
+          fsr                        =>    solarabs_vars%fsr_patch                    , & ! Input:  [real(r8) (:)   ]  solar radiation reflected (W/m**2)
+          sabv                       =>    solarabs_vars%sabv_patch                   , & ! Input:  [real(r8) (:)   ]  solar radiation absorbed by vegetation (W/m**2)
+          sabg                       =>    solarabs_vars%sabg_patch                   , & ! Input:  [real(r8) (:)   ]  solar radiation absorbed by ground (W/m**2)
+
           errsoi_col                 =>    col_ef%errsoi                 , & ! Output: [real(r8) (:)   ]  column-level soil/lake energy conservation error (W/m**2)
+          errsol                     =>    veg_ef%errsol               , & ! Output: [real(r8) (:)   ]  solar radiation conservation error (W/m**2)
+          errseb                     =>    veg_ef%errseb               , & ! Output: [real(r8) (:)   ]  surface energy conservation error (W/m**2)
+          errlon                     =>    veg_ef%errlon               , & ! Output: [real(r8) (:)   ]  longwave radiation conservation error (W/m**2)
+
+          fabd                       =>    surfalb_vars%fabd_patch                    , & ! Input:  [real(r8) (:,:)]  flux absorbed by canopy per unit direct flux
+          fabi                       =>    surfalb_vars%fabi_patch                    , & ! Input:  [real(r8) (:,:)]  flux absorbed by canopy per unit indirect flux
+          elai                       =>    canopystate_vars%elai_patch                , & ! Input:  [real(r8) (:,:)]
+          esai                       =>    canopystate_vars%esai_patch                , & ! Input:  [real(r8) (:,:)]
+
+          albd                       =>    surfalb_vars%albd_patch                    , & ! Output: [real(r8) (:,:)]  surface albedo (direct)
+          albi                       =>    surfalb_vars%albi_patch                    , & ! Output: [real(r8) (:,:)]  surface albedo (diffuse)
+          ftdd                       =>    surfalb_vars%ftdd_patch                    , & ! Input:  [real(r8) (:,:)]  down direct flux below canopy per unit direct flux
+          ftid                       =>    surfalb_vars%ftid_patch                    , & ! Input:  [real(r8) (:,:)]  down diffuse flux below canopy per unit direct flux
+          ftii                       =>    surfalb_vars%ftii_patch                    , & ! Input:  [real(r8) (:,:)]  down diffuse flux below canopy per unit diffuse flux
+
+          netrad                     =>    veg_ef%netrad               , & ! Output: [real(r8) (:)   ]  net radiation (positive downward) (W/m**2)
+          h2ocan_patch               =>    veg_ws%h2ocan               , & ! Input:  [real(r8) (:)   ]  canopy water (mm H2O) (pft-level)
           wa                         =>    soilhydrology_vars%wa_col                  , & ! Output: [real(r8) (:)   ]  water in the unconfined aquifer (mm)
           h2ocan_col                 =>    col_ws%h2ocan                 , & ! Input:  [real(r8) (:)   ]  canopy water (mm H2O)
           h2osfc_col                 =>    col_ws%h2osfc                 , & ! Input:  [real(r8) (:)   ]  surface water (mm)
@@ -1010,8 +1027,8 @@ contains
           l = col_pp%landunit(c)
 
           if (col_pp%itype(c) == icol_sunwall .or.  col_pp%itype(c) == icol_shadewall) then
-             forc_rain_col(c) = 0._r8
-             forc_snow_col(c) = 0._r8
+             forc_rain_col(c) = 0.
+             forc_snow_col(c) = 0.
           else
              forc_rain_col(c) = forc_rain(c)
              forc_snow_col(c) = forc_snow(c)
diff --git a/components/elm/src/biogeophys/BandDiagonalMod.F90 b/components/elm/src/biogeophys/BandDiagonalMod.F90
index 24e60bd62f..b3283b6fde 100644
--- a/components/elm/src/biogeophys/BandDiagonalMod.F90
+++ b/components/elm/src/biogeophys/BandDiagonalMod.F90
@@ -24,32 +24,41 @@ module BandDiagonalMod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine BandDiagonal(bounds, lbj, ubj, jtop, jbot, numf, filter, b, r, u)
+  subroutine BandDiagonal(bounds, lbj, ubj, jtop, jbot, numf, filter, nband, b, r, u)
     !
     ! !DESCRIPTION:
     ! Tridiagonal matrix solution
-    use lapack_acc_seq
+    !
+    ! !ARGUMENTS:
     implicit none
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds                    
     integer , intent(in)    :: lbj, ubj                        ! lbinning and ubing level indices
-    integer , intent(in)    :: jtop(bounds%begc:)  
+    integer , intent(in)    :: jtop( bounds%begc: )            ! top level for each column [col]
     integer , intent(in)    :: jbot( bounds%begc: )            ! bottom level for each column [col]
     integer , intent(in)    :: numf                            ! filter dimension
+    integer , intent(in)    :: nband                           ! band width
     integer , intent(in)    :: filter(:)                       ! filter
     real(r8), intent(in)    :: b( bounds%begc: , 1:   , lbj: ) ! compact band matrix [col, nband, j]
     real(r8), intent(in)    :: r( bounds%begc: , lbj: )        ! "r" rhs of linear system [col, j]
     real(r8), intent(inout) :: u( bounds%begc: , lbj: )        ! solution [col, j]
     !
     ! ! LOCAL VARIABLES:
-    integer , parameter    :: nband = 5       ! band width
-    integer  :: j,ci,fc,info,n,nmax, k,jstart,jstop        !indices
-    integer, parameter  :: kl=(nband-1)/2,ku=kl              !number of sub/super diagonals
-    integer, parameter  :: m=2*kl+ku+1
-    !integer, allocatable :: ipiv(:,:)             !temporary
-    real(r8),allocatable :: ab(:,:,:),temp(:,:,:) !compact storage array
-    real(r8),allocatable :: result(:,:)
+    integer  :: j,ci,fc,info,m,n              !indices
+    integer  :: kl,ku                         !number of sub/super diagonals
+    integer, allocatable :: ipiv(:)           !temporary
+    real(r8),allocatable :: ab(:,:),temp(:,:) !compact storage array
+    real(r8),allocatable :: result(:)
 
     !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(jtop) == (/bounds%endc/)),             errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(jbot) == (/bounds%endc/)),             errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(b)    == (/bounds%endc, nband, ubj/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(r)    == (/bounds%endc, ubj/)),        errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(u)    == (/bounds%endc, ubj/)),        errMsg(__FILE__, __LINE__))
+
+
 !!$     SUBROUTINE SGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )
 !!$*
 !!$*  -- LAPACK driver routine (version 3.1) --
@@ -146,118 +155,67 @@ contains
 !!$*  + need not be set on entry, but are required by the routine to store
 !!$*  elements of U because of fill-in resulting from the row interchanges.
 
+
 !Set up input matrix AB
-!An m-by-n band matrix with kl subdiagonals and ku superdiagonals
-!may be stored compactly in a two-dimensional array with
+!An m-by-n band matrix with kl subdiagonals and ku superdiagonals 
+!may be stored compactly in a two-dimensional array with 
 !kl+ku+1 rows and n columns
 !AB(KL+KU+1+i-j,j) = A(i,j)
 
-   ! calculate the maximum N-dimension needed (jbot-jtop +1)
-   nmax = -100
-   !$acc parallel loop gang vector default(present) reduction(max:nmax) copy(nmax)
-   do fc = 1, numf
-     ci = filter(fc) 
-     n = jbot(ci)-jtop(ci)+1
-     nmax = max(nmax,n)
-   end do 
-
-   ! m is the number of rows required for storage space by dgbsv
-   ! n is the number of levels (snow/soil)
-   !scs: replace ubj with jbot
-   
-   allocate(ab(1:m,1:nmax,1:numf), temp(1:m,1:nmax,1:numf), result(1:nmax,1:numf) ) 
-   !$acc enter data create(ab(:,:,:) ,temp(:,:,:), result(:,:) )
-    
-   !!! ipiv(1:nmax,1:numf), 
-    ! initialize the matrices
-   !$acc parallel loop independent gang vector default(present) collapse(3)
-   do fc = 1, numf  
-      do j = 1, nmax 
-         do k = 1, m
-            ab(k,j,fc) = 0._r8 
-            temp(k,j,fc) = 0._r8
-         end do 
-      end do 
-   end do 
-
-   !$acc parallel loop independent gang vector default(present)
-   do fc = 1, numf
-      ci = filter(fc)
-      n = jbot(ci)-jtop(ci)+1
-      result(1:n,fc) = r(ci, jtop(ci):jbot(ci))
-   end do
-
-   !$acc parallel loop independent gang vector default(present)  
-   do fc = 1, numf
-      ci = filter(fc) 
-      n = jbot(ci)-jtop(ci)+1
-      !band 1 :
-      !$acc loop seq 
-      do j = 0, n-3
-         ! ab(kl+ku-1,3:n)=b(ci,1,jtop(ci):jbot(ci)-2)   ! 2nd superdiagonal
-         ab(kl+ku-1,3+j,fc) = b(ci,1,jtop(ci)+j)   ! 2nd superdiagonal
-      end do 
-      !$acc loop seq 
-      do j = 0, n-2
-         !ab(kl+ku+0,2:n,fc) = b(ci,2,jtop(ci):jbot(ci)-1)   ! 1st superdiagonal
-         ab(kl+ku+0,2+j,fc) = b(ci,2,jtop(ci)+j) 
-      end do 
-      !$acc loop seq 
-      do j = 0, n-1 
-         !ab(kl+ku+1,1:n,fc) = b(ci,3,jtop(ci):jbot(ci)  )   ! diagonal
-         ab(kl+ku+1,1+j,fc) = b(ci,3,jtop(ci)+j)   ! diagonal
-      end do 
-      !$acc loop seq 
-      do j = 0 , n-2
-         !ab(kl+ku+2,1:n-1,fc) = b(ci,4,jtop(ci)+1:jbot(ci)) ! 1st subdiagonal
-         ab(kl+ku+2,1+j,fc) = b(ci,4,jtop(ci)+1+j ) ! 1st subdiagonal
-      end do
-      !$acc loop seq 
-      do j = 0, n-3 
-         !ab(kl+ku+3,1:n-2,fc) = b(ci,5,jtop(ci)+2:jbot(ci)) ! 2nd subdiagonal 
-         ab(kl+ku+3,1+j,fc) = b(ci,5,jtop(ci)+2+j) ! 2nd subdiagonal 
-      end do 
-   end do
-
-   !$acc parallel loop independent gang vector default(present) collapse(3)
-   do fc = 1, numf  
-      do j = 1, nmax 
-         do k = 1, m
-            temp(k,j,fc) = ab(k,j,fc)
-
-         end do 
-      end do 
-   end do 
- 
-   !$acc parallel loop independent gang vector default(present)  
-   do fc = 1,numf
-      ci = filter(fc)
-      n = jbot(ci)-jtop(ci)+1
-        
-      call dgbsv_oacc(n, kl, ku, 1, ab(1:m,1:n,fc), m , result(1:n,fc),n,info)
-      ! ! DGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )
-      !  call dgbsv( n, kl, ku, 1, ab, m, ipiv, result, n, info )
-
-       u(ci,jtop(ci):jbot(ci))=result(1:n,fc)
-      
-       if(info /= 0) then
-          print *, 'index: ', ci
-         write(iulog,*)'n,kl,ku,m ',n,kl,ku,m
-         write(iulog,*)'dgbsv info: ',ci,info
-
-         write(iulog,*) ''
-         write(iulog,*) 'ab matrix'
-         write(iulog,*) ''
+    do fc = 1,numf
+       ci = filter(fc)
+
+       kl=(nband-1)/2
+       ku=kl
+! m is the number of rows required for storage space by dgbsv
+       m=2*kl+ku+1
+! n is the number of levels (snow/soil)
+!scs: replace ubj with jbot
+       n=jbot(ci)-jtop(ci)+1
+
+       allocate(ab(m,n))
+       ab=0.0
+
+       ab(kl+ku-1,3:n)=b(ci,1,jtop(ci):jbot(ci)-2)   ! 2nd superdiagonal
+       ab(kl+ku+0,2:n)=b(ci,2,jtop(ci):jbot(ci)-1)   ! 1st superdiagonal
+       ab(kl+ku+1,1:n)=b(ci,3,jtop(ci):jbot(ci))     ! diagonal
+       ab(kl+ku+2,1:n-1)=b(ci,4,jtop(ci)+1:jbot(ci)) ! 1st subdiagonal
+       ab(kl+ku+3,1:n-2)=b(ci,5,jtop(ci)+2:jbot(ci)) ! 2nd subdiagonal
+
+       allocate(temp(m,n))
+       temp=ab
+
+       allocate(ipiv(n))
+       allocate(result(n))
+
+! on input result is rhs, on output result is solution vector
+       result(:)=r(ci,jtop(ci):jbot(ci))
+
+!       DGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )
+       call dgbsv( n, kl, ku, 1, ab, m, ipiv, result, n, info )
+       u(ci,jtop(ci):jbot(ci))=result(:)
+
+       if(info /= 0) then 
+          write(iulog,*)'index: ', ci
+          write(iulog,*)'n,kl,ku,m ',n,kl,ku,m
+          write(iulog,*)'dgbsv info: ',ci,info
+          
+          write(iulog,*) ''
+          write(iulog,*) 'ab matrix'
+          do j=1,n
+             !             write(iulog,'(i2,7f18.7)') j,temp(:,j)
+             write(iulog,'(i2,5f18.7)') j,temp(3:7,j)
+          enddo
+          write(iulog,*) ''
           stop
        endif
+       deallocate(temp)
 
+       deallocate(ab)
+       deallocate(ipiv)
+       deallocate(result)
     end do
 
-    !$acc exit data delete(ab(:,:,:) ,temp(:,:,:), result(:,:) )  !!!!!!ipiv(:nmax,:numf)
-    deallocate(temp)
-    deallocate(ab)
-    !deallocate(ipiv)
-    deallocate(result)
   end subroutine BandDiagonal
 
 end module BandDiagonalMod
diff --git a/components/elm/src/biogeophys/BareGroundFluxesMod.F90 b/components/elm/src/biogeophys/BareGroundFluxesMod.F90
index 69dba67193..60ff7a96e7 100644
--- a/components/elm/src/biogeophys/BareGroundFluxesMod.F90
+++ b/components/elm/src/biogeophys/BareGroundFluxesMod.F90
@@ -32,70 +32,91 @@ module BareGroundFluxesMod
 contains
 
   !------------------------------------------------------------------------------
-  subroutine BareGroundFluxes( num_nolu_barep, filter_nolu_barep, &
-       canopystate_vars, soilstate_vars, &
+  subroutine BareGroundFluxes(bounds, num_nolakeurbanp, filter_nolakeurbanp, &
+       atm2lnd_vars, canopystate_vars, soilstate_vars, &
        frictionvel_vars, ch4_vars)
     !
     ! !DESCRIPTION:
     ! Compute sensible and latent fluxes and their derivatives with respect
     ! to ground temperature using ground temperatures from previous time step.
+    !
     ! !USES:
+      !$acc routine seq
     use shr_const_mod        , only : SHR_CONST_RGAS
+    use shr_flux_mod         , only : shr_flux_update_stress
     use elm_varpar           , only : nlevgrnd
     use elm_varcon           , only : cpair, vkc, grav, denice, denh2o
-    use elm_varctl           , only : use_lch4
+    use elm_varctl           , only : iulog, use_lch4
     use landunit_varcon      , only : istsoil, istcrop
-    use FrictionVelocityMod  , only : FrictionVelocity_noloop, MoninObukIni
+    use FrictionVelocityMod  , only : FrictionVelocity, MoninObukIni, implicit_stress
     use QSatMod              , only : QSat
     use SurfaceResistanceMod , only : do_soilevap_beta
+    use clm_time_manager     , only : get_nstep
     !
     ! !ARGUMENTS:
-    integer                , intent(in)    :: num_nolu_barep        ! number of pft non-lake, non-urban points in pft filter
-    integer                , intent(in)    :: filter_nolu_barep(:)   ! patch filter for non-lake, non-urban bare pfts
+    type(bounds_type)      , intent(in)    :: bounds
+    integer                , intent(in)    :: num_nolakeurbanp          ! number of pft non-lake, non-urban points in pft filter
+    integer                , intent(in)    :: filter_nolakeurbanp(:)    ! patch filter for non-lake, non-urban points
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(canopystate_type) , intent(in)    :: canopystate_vars
     type(soilstate_type)   , intent(in)    :: soilstate_vars
     type(frictionvel_type) , intent(inout) :: frictionvel_vars
     type(ch4_type)         , intent(inout) :: ch4_vars
     !
     ! !LOCAL VARIABLES:
-    integer, parameter  :: niters = 3            ! maximum number of iterations for surface temperature
-    integer  :: p,c,t,g,j,l                      ! indices
-    integer  :: f                                ! filter pft index
+    real(r8), parameter :: dtaumin = 0.01_r8     ! max limit for stress convergence [Pa]
+    integer, parameter  :: itmin = 3             ! minimum number of iterations
+    integer, parameter  :: itmax = 30            ! maximum number of iterations
+    integer  :: p,c,t,g,f,j,l                    ! indices
+    integer  :: filterp(bounds%endp-bounds%begp+1) ! patch filter for vegetated patches
+    integer  :: fn                               ! number of values in local pft filter
+    integer  :: filterp0(bounds%endp-bounds%begp+1) ! pre-iteration filterp
+    integer  :: fn0                              ! pre-iteration fn
+    integer  :: fnold                            ! previous iteration fn
+    integer  :: fp                               ! lake filter pft index
     integer  :: iter                             ! iteration index
-    real(r8) :: zldis  ! reference height "minus" zero displacement height [m]
-    real(r8) :: displa ! displacement height [m]
-    real(r8) :: zeta   ! dimensionless height used in Monin-Obukhov theory
-    real(r8) :: beta   ! coefficient of convective velocity [-]
-    real(r8) :: wc     ! convective velocity [m/s]
-    real(r8) :: dth    ! diff of virtual temp. between ref. height and surface
-    real(r8) :: dthv   ! diff of vir. poten. temp. between ref. height and surface
-    real(r8) :: dqh    ! diff of humidity between ref. height and surface
-    real(r8) :: obu     ! Monin-Obukhov length (m)
-    real(r8) :: ur      ! wind speed at reference height [m/s]
-    real(r8) :: um      ! wind speed including the stablity effect [m/s]
-    real(r8) :: temp1   ! relation for potential temperature profile
-    real(r8) :: temp12m ! relation for potential temperature profile applied at 2-m
-    real(r8) :: temp2   ! relation for specific humidity profile
-    real(r8) :: temp22m ! relation for specific humidity profile applied at 2-m
-    real(r8) :: ustar   ! friction velocity [m/s]
-    real(r8) :: tstar   ! temperature scaling parameter
-    real(r8) :: qstar   ! moisture scaling parameter
-    real(r8) :: thvstar ! virtual potential temperature scaling parameter
-    real(r8) :: cf      ! heat transfer coefficient from leaves [-]
-    real(r8) :: ram     ! aerodynamical resistance [s/m]
-    real(r8) :: rah     ! thermal resistance [s/m]
-    real(r8) :: raw     ! moisture resistance [s/m]
-    real(r8) :: raih    ! temporary variable [kg/m2/s]
-    real(r8) :: raiw    ! temporary variable [kg/m2/s]
-    real(r8) :: fm      ! needed for BGC only to diagnose 10m wind speed
-    real(r8) :: z0mg_patch!(num_nolakeurbanp)
-    real(r8) :: z0hg_patch!(num_nolakeurbanp)
-    real(r8) :: z0qg_patch!(num_nolakeurbanp)
+    integer  :: iter_final                       ! number of iterations used
+    integer  :: loopmax                          ! maximum number of iterations for this configuration
+    real(r8) :: zldis(bounds%begp:bounds%endp)   ! reference height "minus" zero displacement height [m]
+    real(r8) :: displa(bounds%begp:bounds%endp)  ! displacement height [m]
+    real(r8) :: zeta                             ! dimensionless height used in Monin-Obukhov theory
+    real(r8) :: beta                             ! coefficient of convective velocity [-]
+    real(r8) :: wc                               ! convective velocity [m/s]
+    real(r8) :: dth(bounds%begp:bounds%endp)     ! diff of virtual temp. between ref. height and surface
+    real(r8) :: dthv                             ! diff of vir. poten. temp. between ref. height and surface
+    real(r8) :: dqh(bounds%begp:bounds%endp)     ! diff of humidity between ref. height and surface
+    real(r8) :: obu(bounds%begp:bounds%endp)     ! Monin-Obukhov length (m)
+    real(r8) :: ur(bounds%begp:bounds%endp)      ! wind speed at reference height [m/s]
+    real(r8) :: um(bounds%begp:bounds%endp)      ! wind speed including the stablity effect [m/s]
+    real(r8) :: temp1(bounds%begp:bounds%endp)   ! relation for potential temperature profile
+    real(r8) :: temp12m(bounds%begp:bounds%endp) ! relation for potential temperature profile applied at 2-m
+    real(r8) :: temp2(bounds%begp:bounds%endp)   ! relation for specific humidity profile
+    real(r8) :: temp22m(bounds%begp:bounds%endp) ! relation for specific humidity profile applied at 2-m
+    real(r8) :: ustar(bounds%begp:bounds%endp)   ! friction velocity [m/s]
+    real(r8) :: tstar                            ! temperature scaling parameter
+    real(r8) :: qstar                            ! moisture scaling parameter
+    real(r8) :: thvstar                          ! virtual potential temperature scaling parameter
+    real(r8) :: cf                               ! heat transfer coefficient from leaves [-]
+    real(r8) :: ram                              ! aerodynamical resistance [s/m]
+    real(r8) :: rah                              ! thermal resistance [s/m]
+    real(r8) :: raw                              ! moisture resistance [s/m]
+    real(r8) :: raih                             ! temporary variable [kg/m2/s]
+    real(r8) :: raiw                             ! temporary variable [kg/m2/s]
+    real(r8) :: fm(bounds%begp:bounds%endp)      ! needed for BGC only to diagnose 10m wind speed
+    real(r8) :: z0mg_patch(bounds%begp:bounds%endp)
+    real(r8) :: z0hg_patch(bounds%begp:bounds%endp)
+    real(r8) :: z0qg_patch(bounds%begp:bounds%endp)
     real(r8) :: e_ref2m                ! 2 m height surface saturated vapor pressure [Pa]
     real(r8) :: de2mdT                 ! derivative of 2 m height surface saturated vapor pressure on t_ref2m
     real(r8) :: qsat_ref2m             ! 2 m height surface saturated specific humidity [kg/kg]
     real(r8) :: dqsat2mdT              ! derivative of 2 m height surface saturated specific humidity on t_ref2m
     real(r8) :: www                    ! surface soil wetness [-]
+    real(r8) :: wind_speed0(bounds%begp:bounds%endp) ! Wind speed from atmosphere at start of iteration
+    real(r8) :: wind_speed_adj(bounds%begp:bounds%endp) ! Adjusted wind speed for iteration
+    real(r8) :: tau(bounds%begp:bounds%endp)      ! Stress used in iteration
+    real(r8) :: tau_diff(bounds%begp:bounds%endp) ! Difference from previous iteration tau
+    real(r8) :: prev_tau(bounds%begp:bounds%endp) ! Previous iteration tau
+    real(r8) :: prev_tau_diff(bounds%begp:bounds%endp) ! Previous difference in iteration tau
     !------------------------------------------------------------------------------
 
     associate(                                                          &
@@ -104,19 +125,15 @@ contains
          zii              =>    col_pp%zii                            , & ! Input:  [real(r8) (:)   ]  convective boundary height [m]
          forc_u           =>    top_as%ubot                           , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in east direction (m/s)
          forc_v           =>    top_as%vbot                           , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in north direction (m/s)
+         wsresp           =>    top_as%wsresp                         , & ! Input:  [real(r8) (:)   ]  response of wind to surface stress (m/s/Pa)
+         tau_est          =>    top_as%tau_est                        , & ! Input:  [real(r8) (:)   ]  approximate atmosphere change to zonal wind (m/s)
+         ugust            =>    top_as%ugust                          , & ! Input:  [real(r8) (:)   ]  gustiness from atmosphere (m/s)
          forc_th          =>    top_as%thbot                          , & ! Input:  [real(r8) (:)   ]  atmospheric potential temperature (Kelvin)
          forc_pbot        =>    top_as%pbot                           , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)
          forc_rho         =>    top_as%rhobot                         , & ! Input:  [real(r8) (:)   ]  density (kg/m**3)
          forc_q           =>    top_as%qbot                           , & ! Input:  [real(r8) (:)   ]  atmospheric specific humidity (kg/kg)
 
-         forc_hgt_u_patch => frictionvel_vars%forc_hgt_u_patch , & ! Input:
-         forc_hgt_t_patch => frictionvel_vars%forc_hgt_t_patch , & ! Input:  [real(r8) (:) ] observational height of temperature at pft level [m]
-         forc_hgt_q_patch => frictionvel_vars%forc_hgt_q_patch , & ! Input:  [real(r8) (:) ] observational height of specific humidity at pft level [m]
-         vds              => frictionvel_vars%vds_patch        , & ! Output: [real(r8) (:) ] dry deposition velocity term (m/s) (for SO4 NH4NO3)
-         u10              => frictionvel_vars%u10_patch        , & ! Output: [real(r8) (:) ] 10-m wind (m/s) (for dust model)
-         u10_elm          => frictionvel_vars%u10_elm_patch    , & ! Output: [real(r8) (:) ] 10-m wind (m/s)
-         va               => frictionvel_vars%va_patch         , & ! Output: [real(r8) (:) ] atmospheric wind speed plus convective velocity (m/s)
-         fv               => frictionvel_vars%fv_patch         ,  & ! Output: [real(r8) (:) ] friction velocity (m/s) (for dust model)
+         forc_hgt_u_patch =>    frictionvel_vars%forc_hgt_u_patch     , & ! Input:
 
          frac_veg_nosno   =>    canopystate_vars%frac_veg_nosno_patch , & ! Input:  [logical  (:)   ]  true=> pft is bare ground (elai+esai = zero)
 
@@ -125,22 +142,22 @@ contains
          watsat           =>    soilstate_vars%watsat_col             , & ! Input:  [real(r8) (:,:) ]  volumetric soil water at saturation (porosity)
          soilbeta         =>    soilstate_vars%soilbeta_col           , & ! Input:  [real(r8) (:)   ]  soil wetness relative to field capacity
 
-         t_soisno         =>    col_es%t_soisno   , & ! Input:  [real(r8) (:,:) ]  soil temperature (Kelvin)
-         t_grnd           =>    col_es%t_grnd     , & ! Input:  [real(r8) (:)   ]  ground surface temperature [K]
-         thv              =>    col_es%thv        , & ! Input:  [real(r8) (:)   ]  virtual potential temperature (kelvin)
-         thm              =>    veg_es%thm        , & ! Input:  [real(r8) (:)   ]  intermediate variable (forc_t+0.0098*forc_hgt_t_patch)
-         t_h2osfc         =>    col_es%t_h2osfc   , & ! Input:  [real(r8) (:)   ]  surface water temperature
+         t_soisno         =>    col_es%t_soisno         , & ! Input:  [real(r8) (:,:) ]  soil temperature (Kelvin)
+         t_grnd           =>    col_es%t_grnd           , & ! Input:  [real(r8) (:)   ]  ground surface temperature [K]
+         thv              =>    col_es%thv              , & ! Input:  [real(r8) (:)   ]  virtual potential temperature (kelvin)
+         thm              =>    veg_es%thm              , & ! Input:  [real(r8) (:)   ]  intermediate variable (forc_t+0.0098*forc_hgt_t_patch)
+         t_h2osfc         =>    col_es%t_h2osfc         , & ! Input:  [real(r8) (:)   ]  surface water temperature
 
-         frac_sno         =>    col_ws%frac_sno   , & ! Input:  [real(r8) (:)   ]  fraction of ground covered by snow (0 to 1)
-         qg_snow          =>    col_ws%qg_snow    , & ! Input:  [real(r8) (:)   ]  specific humidity at snow surface [kg/kg]
-         qg_soil          =>    col_ws%qg_soil    , & ! Input:  [real(r8) (:)   ]  specific humidity at soil surface [kg/kg]
-         qg_h2osfc        =>    col_ws%qg_h2osfc  , & ! Input:  [real(r8) (:)   ]  specific humidity at h2osfc surface [kg/kg]
-         qg               =>    col_ws%qg         , & ! Input:  [real(r8) (:)   ]  specific humidity at ground surface [kg/kg]
-         dqgdT            =>    col_ws%dqgdT      , & ! Input:  [real(r8) (:)   ]  temperature derivative of "qg"
-         h2osoi_ice       =>    col_ws%h2osoi_ice , & ! Input:  [real(r8) (:,:) ]  ice lens (kg/m2)
-         h2osoi_liq       =>    col_ws%h2osoi_liq , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2)
+         frac_sno         =>    col_ws%frac_sno          , & ! Input:  [real(r8) (:)   ]  fraction of ground covered by snow (0 to 1)
+         qg_snow          =>    col_ws%qg_snow           , & ! Input:  [real(r8) (:)   ]  specific humidity at snow surface [kg/kg]
+         qg_soil          =>    col_ws%qg_soil           , & ! Input:  [real(r8) (:)   ]  specific humidity at soil surface [kg/kg]
+         qg_h2osfc        =>    col_ws%qg_h2osfc         , & ! Input:  [real(r8) (:)   ]  specific humidity at h2osfc surface [kg/kg]
+         qg               =>    col_ws%qg                , & ! Input:  [real(r8) (:)   ]  specific humidity at ground surface [kg/kg]
+         dqgdT            =>    col_ws%dqgdT             , & ! Input:  [real(r8) (:)   ]  temperature derivative of "qg"
+         h2osoi_ice       =>    col_ws%h2osoi_ice        , & ! Input:  [real(r8) (:,:) ]  ice lens (kg/m2)
+         h2osoi_liq       =>    col_ws%h2osoi_liq        , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2)
 
-         grnd_ch4_cond    =>    ch4_vars%grnd_ch4_cond_patch , & ! Output: [real(r8) (:)   ]  tracer conductance for boundary layer [m/s]
+         grnd_ch4_cond    =>    ch4_vars%grnd_ch4_cond_patch          , & ! Output: [real(r8) (:)   ]  tracer conductance for boundary layer [m/s]
 
          eflx_sh_snow     =>    veg_ef%eflx_sh_snow    , & ! Output: [real(r8) (:)   ]  sensible heat flux from snow (W/m**2) [+ to atm]
          eflx_sh_soil     =>    veg_ef%eflx_sh_soil    , & ! Output: [real(r8) (:)   ]  sensible heat flux from soil (W/m**2) [+ to atm]
@@ -158,103 +175,172 @@ contains
          t_ref2m          =>    veg_es%t_ref2m        , & ! Output: [real(r8) (:)   ]  2 m height surface air temperature (Kelvin)
          t_ref2m_r        =>    veg_es%t_ref2m_r      , & ! Output: [real(r8) (:)   ]  Rural 2 m height surface air temperature (Kelvin)
 
-         q_ref2m          =>    veg_ws%q_ref2m        , & ! Output: [real(r8) (:)   ]  2 m height surface specific humidity (kg/kg)
-         rh_ref2m_r       =>    veg_ws%rh_ref2m_r     , & ! Output: [real(r8) (:)   ]  Rural 2 m height surface relative humidity (%)
-         rh_ref2m         =>    veg_ws%rh_ref2m       , & ! Output: [real(r8) (:)   ]  2 m height surface relative humidity (%)
-
-         z0mg_col         =>    frictionvel_vars%z0mg_col   , & ! Output: [real(r8) (:)   ]  roughness length, momentum [m]
-         z0hg_col         =>    frictionvel_vars%z0hg_col   , & ! Output: [real(r8) (:)   ]  roughness length, sensible heat [m]
-         z0qg_col         =>    frictionvel_vars%z0qg_col   , & ! Output: [real(r8) (:)   ]  roughness length, latent heat [m]
-         ram1             =>    frictionvel_vars%ram1_patch , & ! Output: [real(r8) (:)   ]  aerodynamical resistance (s/m)
-
-         qflx_ev_snow     =>    veg_wf%qflx_ev_snow  , & ! Output: [real(r8) (:)   ]  evaporation flux from snow (W/m**2) [+ to atm]
-         qflx_ev_soil     =>    veg_wf%qflx_ev_soil  , & ! Output: [real(r8) (:)   ]  evaporation flux from soil (W/m**2) [+ to atm]
-         qflx_ev_h2osfc   =>    veg_wf%qflx_ev_h2osfc, & ! Output: [real(r8) (:)   ]  evaporation flux from h2osfc (W/m**2) [+ to atm]
-         qflx_evap_soi    =>    veg_wf%qflx_evap_soi , & ! Output: [real(r8) (:)   ]  soil evaporation (mm H2O/s) (+ = to atm)
-         qflx_evap_tot    =>    veg_wf%qflx_evap_tot   & ! Output: [real(r8) (:)   ]  qflx_evap_soi + qflx_evap_can + qflx_tran_veg
+         q_ref2m          =>    veg_ws%q_ref2m         , & ! Output: [real(r8) (:)   ]  2 m height surface specific humidity (kg/kg)
+         rh_ref2m_r       =>    veg_ws%rh_ref2m_r      , & ! Output: [real(r8) (:)   ]  Rural 2 m height surface relative humidity (%)
+         rh_ref2m         =>    veg_ws%rh_ref2m        , & ! Output: [real(r8) (:)   ]  2 m height surface relative humidity (%)
+
+         z0mg_col         =>    frictionvel_vars%z0mg_col             , & ! Output: [real(r8) (:)   ]  roughness length, momentum [m]
+         z0hg_col         =>    frictionvel_vars%z0hg_col             , & ! Output: [real(r8) (:)   ]  roughness length, sensible heat [m]
+         z0qg_col         =>    frictionvel_vars%z0qg_col             , & ! Output: [real(r8) (:)   ]  roughness length, latent heat [m]
+         ram1             =>    frictionvel_vars%ram1_patch           , & ! Output: [real(r8) (:)   ]  aerodynamical resistance (s/m)
+
+         qflx_ev_snow     =>    veg_wf%qflx_ev_snow     , & ! Output: [real(r8) (:)   ]  evaporation flux from snow (W/m**2) [+ to atm]
+         qflx_ev_soil     =>    veg_wf%qflx_ev_soil     , & ! Output: [real(r8) (:)   ]  evaporation flux from soil (W/m**2) [+ to atm]
+         qflx_ev_h2osfc   =>    veg_wf%qflx_ev_h2osfc   , & ! Output: [real(r8) (:)   ]  evaporation flux from h2osfc (W/m**2) [+ to atm]
+         qflx_evap_soi    =>    veg_wf%qflx_evap_soi    , & ! Output: [real(r8) (:)   ]  soil evaporation (mm H2O/s) (+ = to atm)
+         qflx_evap_tot    =>    veg_wf%qflx_evap_tot    , & ! Output: [real(r8) (:)   ]  qflx_evap_soi + qflx_evap_can + qflx_tran_veg
+         begp             =>    bounds%begp                           , &
+         endp             =>    bounds%endp                             &
          )
 
       !---------------------------------------------------
       ! Filter patches where frac_veg_nosno IS ZERO
       !---------------------------------------------------
+      
+      beta = 1._r8 ! previously set as a constant for all columns in CanopyTemperature()
+
+      fn = 0
+      do fp = 1,num_nolakeurbanp
+         p = filter_nolakeurbanp(fp)
+         if (frac_veg_nosno(p) == 0) then
+            fn = fn + 1
+            filterp(fn) = p
+         end if
+      end do
 
       ! Compute sensible and latent fluxes and their derivatives with respect
       ! to ground temperature using ground temperatures from previous time step
-      !$acc parallel loop independent gang vector default(present) 
-      do f = 1, num_nolu_barep
-         p = filter_nolu_barep(f)
+
+      do f = 1, fn
+         p = filterp(f)
          c = veg_pp%column(p)
-         g = veg_pp%gridcell(p)
          t = veg_pp%topounit(p)
-         l = veg_pp%landunit(p)
-
-         beta = 1._r8 ! previously set as a constant for all columns in CanopyTemperature()
-         iter = 0
+         g = veg_pp%gridcell(p)
 
          ! Initialization variables
 
-         displa = 0._r8
+         displa(p) = 0._r8
          dlrad(p)  = 0._r8
          ulrad(p)  = 0._r8
 
-         ur    = max(1.0_r8,sqrt(forc_u(t)*forc_u(t)+forc_v(t)*forc_v(t)))
-         dth   = thm(p)-t_grnd(c)
-         dqh   = forc_q(t) - qg(c)
-         dthv  = dth*(1._r8+0.61_r8*forc_q(t))+0.61_r8*forc_th(t)*dqh
-         zldis = forc_hgt_u_patch(p)
+         ! Initialize winds for iteration.
+         if (implicit_stress) then
+            wind_speed0(p) = max(0.01_r8, hypot(forc_u(t), forc_v(t)))
+            wind_speed_adj(p) = wind_speed0(p)
+            ur(p) = max(1.0_r8, wind_speed_adj(p) + ugust(t))
+
+            prev_tau(p) = tau_est(t)
+         else
+            ur(p)    = max(1.0_r8,sqrt(forc_u(t)*forc_u(t)+forc_v(t)*forc_v(t)) + ugust(t))
+         end if
+         tau_diff(p) = 1.e100_r8
+
+         dth(p)   = thm(p)-t_grnd(c)
+         dqh(p)   = forc_q(t) - qg(c)
+         dthv     = dth(p)*(1._r8+0.61_r8*forc_q(t))+0.61_r8*forc_th(t)*dqh(p)
+         zldis(p) = forc_hgt_u_patch(p)
 
          ! Copy column roughness to local pft-level arrays
 
-         z0mg_patch = z0mg_col(c)
-         z0hg_patch = z0hg_col(c)
-         z0qg_patch = z0qg_col(c)
+         z0mg_patch(p) = z0mg_col(c)
+         z0hg_patch(p) = z0hg_col(c)
+         z0qg_patch(p) = z0qg_col(c)
 
          ! Initialize Monin-Obukhov length and wind speed
 
-         call MoninObukIni(ur, thv(c), dthv, zldis, z0mg_patch, um, obu )
+         call MoninObukIni(ur(p), thv(c), dthv, zldis(p), z0mg_patch(p), um(p), obu(p))
 
+      end do
 
-         ! Perform stability iteration
-         ! Determine friction velocity, and potential temperature and humidity
-         ! profiles of the surface boundary layer
-         ITERATION : do while( iter < niters)
-
-           call FrictionVelocity_noloop( &
-                displa, z0mg_patch, z0hg_patch, z0qg_patch, &
-                obu, iter+1, ur, um, ustar, &
-                temp1, temp2, temp12m, temp22m, fm, &
-                forc_hgt_u_patch(p), forc_hgt_t_patch(p), forc_hgt_q_patch(p), &
-                vds(p), u10(p), u10_elm(p), va(p), fv(p))
-                
+      ! Perform stability iteration
+      ! Determine friction velocity, and potential temperature and humidity
+      ! profiles of the surface boundary layer
+
+      fn0 = fn
+      filterp0(1:fn) = filterp(1:fn)
+
+      if (implicit_stress) then
+         loopmax = itmax
+      else
+         loopmax = itmin
+      end if
+
+      ITERATION: do iter = 1, loopmax
+
+         call FrictionVelocity(begp, endp, fn, filterp, &
+              displa(begp:endp), z0mg_patch(begp:endp), z0hg_patch(begp:endp), z0qg_patch(begp:endp), &
+              obu(begp:endp), iter, ur(begp:endp), um(begp:endp), ustar(begp:endp), &
+              temp1(begp:endp), temp2(begp:endp), temp12m(begp:endp), temp22m(begp:endp), fm(begp:endp), &
+              frictionvel_vars)
+
+         do f = 1, fn
+            p = filterp(f)
+            c = veg_pp%column(p)
+            t = veg_pp%topounit(p)
+            g = veg_pp%gridcell(p)
+
+            ! Calculate magnitude of stress and update wind speed.
+            if (implicit_stress) then
+               ram = 1._r8/(ustar(p)*ustar(p)/um(p))
+               tau(p) = forc_rho(t)*wind_speed_adj(p)/ram
+               call shr_flux_update_stress(wind_speed0(p), wsresp(t), tau_est(t), &
+                    tau(p), prev_tau(p), tau_diff(p), prev_tau_diff(p), &
+                    wind_speed_adj(p))
+               ur(p) = max(1.0_r8, wind_speed_adj(p) + ugust(t))
+            end if
 
-            tstar = temp1*dth
-            qstar = temp2*dqh
-            z0hg_patch = z0mg_patch/exp(0.13_r8 * (ustar*z0mg_patch/1.5e-5_r8)**0.45_r8)
-            z0qg_patch = z0hg_patch
+            tstar = temp1(p)*dth(p)
+            qstar = temp2(p)*dqh(p)
+            z0hg_patch(p) = z0mg_patch(p)/exp(0.13_r8 * (ustar(p)*z0mg_patch(p)/1.5e-5_r8)**0.45_r8)
+            z0qg_patch(p) = z0hg_patch(p)
             thvstar = tstar*(1._r8+0.61_r8*forc_q(t)) + 0.61_r8*forc_th(t)*qstar
-            zeta = zldis*vkc*grav*thvstar/(ustar**2*thv(c))
+            zeta = zldis(p)*vkc*grav*thvstar/(ustar(p)**2*thv(c))
 
             if (zeta >= 0._r8) then                   !stable
                zeta = min(2._r8,max(zeta,0.01_r8))
-               um = max(ur,0.1_r8)
+               um(p) = max(ur(p),0.1_r8)
             else                                      !unstable
                zeta = max(-100._r8,min(zeta,-0.01_r8))
-               wc = beta*(-grav*ustar*thvstar*zii(c)/thv(c))**0.333_r8
-               um = sqrt(ur*ur + wc*wc)
+               wc = beta*(-grav*ustar(p)*thvstar*zii(c)/thv(c))**0.333_r8
+               um(p) = sqrt(ur(p)*ur(p) + wc*wc)
+            end if
+            obu(p) = zldis(p)/zeta
+         end do
+
+         ! Test for convergence
+         iter_final = iter
+         if (iter >= itmin) then
+            fnold = fn
+            fn = 0
+            do f = 1, fnold
+               p = filterp(f)
+               if (.not. (abs(tau_diff(p)) < dtaumin)) then
+                  fn = fn + 1
+                  filterp(fn) = p
+               end if
+            end do
+            if (fn == 0) then
+               exit ITERATION
             end if
-            obu = zldis/zeta
+         end if
 
-           !end do
-           iter = iter + 1
-         end do ITERATION! end stability iteration
+      end do ITERATION ! end stability iteration
 
+      fn = fn0
+      filterp(1:fn) = filterp0(1:fn)
 
+      do f = 1, fn
+         p = filterp(f)
+         c = veg_pp%column(p)
+         g = veg_pp%gridcell(p)
+         t = veg_pp%topounit(p)
+         l = veg_pp%landunit(p)
 
          ! Determine aerodynamic resistances
 
-         ram  = 1._r8/(ustar*ustar/um)
-         rah  = 1._r8/(temp1*ustar)
-         raw  = 1._r8/(temp2*ustar)
+         ram  = 1._r8/(ustar(p)*ustar(p)/um(p))
+         rah  = 1._r8/(temp1(p)*ustar(p))
+         raw  = 1._r8/(temp2(p)*ustar(p))
          raih = forc_rho(t)*cpair/rah
          if (use_lch4) then
             grnd_ch4_cond(p) = 1._r8/raw
@@ -265,7 +351,7 @@ contains
          www = min(max(www,0.0_r8),1._r8)
 
          !changed by K.Sakaguchi. Soilbeta is used for evaporation
-         if (dqh > 0._r8) then  !dew  (beta is not applied, just like rsoil used to be)
+         if (dqh(p) > 0._r8) then  !dew  (beta is not applied, just like rsoil used to be)
             raiw = forc_rho(t)/(raw)
          else
             if(do_soilevap_beta())then
@@ -286,7 +372,11 @@ contains
          ! using ground temperatures from previous time step
          taux(p)          = -forc_rho(t)*forc_u(t)/ram
          tauy(p)          = -forc_rho(t)*forc_v(t)/ram
-         eflx_sh_grnd(p)  = -raih*dth
+         if (implicit_stress) then
+            taux(p)          = taux(p) * (wind_speed_adj(p) / wind_speed0(p))
+            tauy(p)          = tauy(p) * (wind_speed_adj(p) / wind_speed0(p))
+         end if
+         eflx_sh_grnd(p)  = -raih*dth(p)
          eflx_sh_tot(p)   = eflx_sh_grnd(p)
 
          ! compute sensible heat fluxes individually
@@ -295,7 +385,7 @@ contains
          eflx_sh_h2osfc(p) = -raih*(thm(p)-t_h2osfc(c))
 
          ! water fluxes from soil
-         qflx_evap_soi(p)  = -raiw*dqh
+         qflx_evap_soi(p)  = -raiw*dqh(p)
          qflx_evap_tot(p)  = qflx_evap_soi(p)
 
          ! compute latent heat fluxes individually
@@ -304,10 +394,10 @@ contains
          qflx_ev_h2osfc(p) = -raiw*(forc_q(t) - qg_h2osfc(c))
 
          ! 2 m height air temperature
-         t_ref2m(p) = thm(p) + temp1*dth*(1._r8/temp12m - 1._r8/temp1)
+         t_ref2m(p) = thm(p) + temp1(p)*dth(p)*(1._r8/temp12m(p) - 1._r8/temp1(p))
 
          ! 2 m height specific humidity
-         q_ref2m(p) = forc_q(t) + temp2*dqh*(1._r8/temp22m - 1._r8/temp2)
+         q_ref2m(p) = forc_q(t) + temp2(p)*dqh(p)*(1._r8/temp22m(p) - 1._r8/temp2(p))
 
          ! 2 m height relative humidity
          call QSat(t_ref2m(p), forc_pbot(t), e_ref2m, de2mdT, qsat_ref2m, dqsat2mdT)
@@ -319,6 +409,16 @@ contains
             t_ref2m_r(p) = t_ref2m(p)
          end if
 
+         ! Check for convergence of stress.
+         if (implicit_stress .and. abs(tau_diff(p)) > dtaumin) then
+            if (get_nstep() > 0) then ! Suppress common warnings on the first time step.
+               write(iulog,*)'WARNING: Stress did not converge for bare ground ',&
+                    ' nstep = ',get_nstep(),' p= ',p,' prev_tau_diff= ',prev_tau_diff(p),&
+                    ' tau_diff= ',tau_diff(p),' tau= ',tau(p),&
+                    ' wind_speed_adj= ',wind_speed_adj(p),' iter_final= ',iter_final
+            end if
+         end if
+
       end do
 
     end associate
diff --git a/components/elm/src/biogeophys/CanopyFluxesMod.F90 b/components/elm/src/biogeophys/CanopyFluxesMod.F90
index 804ccc3b3f..59f14dc948 100644
--- a/components/elm/src/biogeophys/CanopyFluxesMod.F90
+++ b/components/elm/src/biogeophys/CanopyFluxesMod.F90
@@ -1,7 +1,7 @@
 module CanopyFluxesMod
 
 #include "shr_assert.h"
-  
+
   !------------------------------------------------------------------------------
   ! !DESCRIPTION:
   ! Performs calculation of leaf temperature and surface fluxes.
@@ -40,8 +40,11 @@ module CanopyFluxesMod
   use ColumnDataType        , only : col_es, col_ef, col_ws
   use VegetationType        , only : veg_pp
   use VegetationDataType    , only : veg_es, veg_ef, veg_ws, veg_wf
-  ! using elm_instMod messes with the compilation order
-  !#fates_py use elm_instMod           , only : alm_fates, soil_water_retention_curve
+
+  !!! using elm_instMod messes with the compilation order
+  use elm_instMod           , only : alm_fates, soil_water_retention_curve
+  use TemperatureType , only : temperature_vars
+  use perfMod_GPU
   use timeinfoMod
   use spmdmod          , only: masterproc
   !
@@ -55,12 +58,10 @@ module CanopyFluxesMod
 contains
 
   !------------------------------------------------------------------------------
-  subroutine CanopyFluxes(bounds,  num_nolu_barep, filter_nolu_barep, &
-       num_nolu_vegp, filter_nolu_vegp , &
-       canopystate_vars, cnstate_vars, energyflux_vars, &
+  subroutine CanopyFluxes(bounds,  num_nolakeurbanp, filter_nolakeurbanp, &
+       atm2lnd_vars, canopystate_vars, cnstate_vars, energyflux_vars, &
        frictionvel_vars, soilstate_vars, solarabs_vars, surfalb_vars, &
        ch4_vars, photosyns_vars)
-
     ! !DESCRIPTION:
     ! 1. Calculates the leaf temperature:
     ! 2. Calculates the leaf fluxes, transpiration, photosynthesis and
@@ -89,7 +90,9 @@ contains
     !     less than 0.1 W/m2; or the iterative steps over 40.
     !
     ! !USES:
+      !$acc routine seq
     use shr_const_mod      , only : SHR_CONST_TKFRZ, SHR_CONST_RGAS
+    use shr_flux_mod       , only : shr_flux_update_stress
     use elm_varcon         , only : sb, cpair, hvap, vkc, grav, denice
     use elm_varcon         , only : denh2o, tfrz, csoilc, tlsai_crit, alpha_aero
     use elm_varcon         , only : isecspday, degpsec
@@ -97,20 +100,20 @@ contains
     use elm_varcon         , only : c14ratio
 
     !NEW
-    use domainMod          , only : ldomain_gpu
+    use domainMod          , only : ldomain
     use QSatMod            , only : QSat
-    use FrictionVelocityMod, only : FrictionVelocity_noloop, MoninObukIni
+    use FrictionVelocityMod, only : FrictionVelocity, MoninObukIni, implicit_stress
+    use SoilWaterRetentionCurveMod, only : soil_water_retention_curve_type
     use SurfaceResistanceMod, only : getlblcef
     use PhotosynthesisType, only : photosyns_vars_TimeStepInit
     !
     ! !ARGUMENTS:
     type(bounds_type)         , intent(in)    :: bounds
-    integer                   , intent(in)    :: num_nolu_barep
-    integer                   , intent(in)    :: filter_nolu_barep(:)
-    integer                   , intent(in)    :: num_nolu_vegp
-    integer                   , intent(in)    :: filter_nolu_vegp(:)
+    integer                   , intent(in)    :: num_nolakeurbanp       ! number of column non-lake, non-urban points in pft filter
+    integer                   , intent(in)    :: filter_nolakeurbanp(:) ! patch filter for non-lake, non-urban points
+    type(atm2lnd_type)        , intent(inout) :: atm2lnd_vars
     type(canopystate_type)    , intent(inout) :: canopystate_vars
-    type(cnstate_type)        , intent(inout) :: cnstate_vars  
+    type(cnstate_type)        , intent(inout) :: cnstate_vars
     type(energyflux_type)     , intent(inout) :: energyflux_vars
     type(frictionvel_type)    , intent(inout) :: frictionvel_vars
     type(solarabs_type)       , intent(inout) :: solarabs_vars
@@ -118,6 +121,7 @@ contains
     type(soilstate_type)      , intent(inout) :: soilstate_vars
     type(ch4_type)            , intent(inout) :: ch4_vars
     type(photosyns_type)      , intent(inout) :: photosyns_vars
+    real(r8) :: dtime
     integer  ::  time
     !
     ! !LOCAL VARIABLES:
@@ -125,12 +129,13 @@ contains
     real(r8), pointer   :: bsha(:)          ! shaded canopy transpiration wetness factor (0 to 1)
     real(r8), parameter :: btran0 = 0.0_r8  ! initial value
     real(r8), parameter :: zii = 1000.0_r8  ! convective boundary layer height [m]
-    real(r8), parameter :: beta = 1.0_r8    ! coefficient of conective velocity [-]
+    real(r8), parameter :: beta = 1.0_r8    ! coefficient of convective velocity [-]
     real(r8), parameter :: delmax = 1.0_r8  ! maxchange in  leaf temperature [K]
     real(r8), parameter :: dlemin = 0.1_r8  ! max limit for energy flux convergence [w/m2]
     real(r8), parameter :: dtmin = 0.01_r8  ! max limit for temperature convergence [K]
-    integer , parameter :: itmax = 40       ! maximum number of iteration [-]
-    integer , parameter :: itmin = 2        ! minimum number of iteration [-]
+    real(r8), parameter :: dtaumin = 0.01_r8! max limit for stress convergence [Pa]
+    integer , parameter :: itmax = 41       ! maximum number of iteration [-]
+    integer , parameter :: itmin = 3        ! minimum number of iteration [-]
     real(r8), parameter :: irrig_min_lai = 0.0_r8           ! Minimum LAI for irrigation
     real(r8), parameter :: irrig_btran_thresh = 0.999999_r8 ! Irrigate when btran falls below 0.999999 rather than 1 to allow for round-off error
     integer , parameter :: irrig_start_time = isecspday/4   ! (6AM) Time of day to check whether we need irrigation, seconds (0 = midnight).
@@ -160,118 +165,124 @@ contains
     !added by K.Sakaguchi for stability formulation
     real(r8), parameter :: ria  = 0.5_r8             ! free parameter for stable formulation (currently = 0.5, "gamma" in Sakaguchi&Zeng,2008)
 
-    real(r8) :: zldis(num_nolu_vegp)   ! reference height "minus" zero displacement height [m]
-    real(r8) :: zeta                   ! dimensionless height used in Monin-Obukhov theory
-    real(r8) :: wc                     ! convective velocity [m/s]
-    real(r8) :: dth(num_nolu_vegp)     ! diff of virtual temp. between ref. height and surface
-    real(r8) :: dthv(num_nolu_vegp)    ! diff of vir. poten. temp. between ref. height and surface
-    real(r8) :: dqh(num_nolu_vegp)     ! diff of humidity between ref. height and surface
-    real(r8) :: obu(num_nolu_vegp)     ! Monin-Obukhov length (m)
-    real(r8) :: um (num_nolu_vegp)     ! wind speed including the stablity effect [m/s]
-    real(r8) :: ur (num_nolu_vegp)     ! wind speed at reference height [m/s]
-    real(r8) :: uaf(num_nolu_vegp)     ! velocity of air within foliage [m/s]
-    real(r8) :: temp1(num_nolu_vegp)   ! relation for potential temperature profile
-    real(r8) :: temp12m(num_nolu_vegp) ! relation for potential temperature profile applied at 2-m
-    real(r8) :: temp2  (num_nolu_vegp) ! relation for specific humidity profile
-    real(r8) :: temp22m(num_nolu_vegp) ! relation for specific humidity profile applied at 2-m
-    real(r8) :: ustar  (num_nolu_vegp) ! friction velocity [m/s]
-    real(r8) :: tstar                  ! temperature scaling parameter
-    real(r8) :: qstar                  ! moisture scaling parameter
-    real(r8) :: thvstar                ! virtual potential temperature scaling parameter
-    real(r8) :: taf(num_nolu_vegp)     ! air temperature within canopy space [K]
-    real(r8) :: qaf(num_nolu_vegp)     ! humidity of canopy air [kg/kg]
-    real(r8) :: rpp                    ! fraction of potential evaporation from leaf [-]
-    real(r8) :: rppdry                 ! fraction of potential evaporation through transp [-]
-    real(r8) :: cf                     ! heat transfer coefficient from leaves [-]
-    real(r8) :: cf_bare                ! heat transfer coefficient from bare ground [-]
-    real(r8) :: rb(num_nolu_vegp)      ! leaf boundary layer resistance [s/m]
-    real(r8) :: rah(num_nolu_vegp,2)   ! thermal resistance [s/m]
-    real(r8) :: raw(num_nolu_vegp,2)   ! moisture resistance [s/m]
-    real(r8) :: wta                    ! heat conductance for air [m/s]
-    real(r8) :: wtg(num_nolu_vegp)     ! heat conductance for ground [m/s]
-    real(r8) :: wtl                    ! heat conductance for leaf [m/s]
-    real(r8) :: wta0(num_nolu_vegp)    ! normalized heat conductance for air [-]
-    real(r8) :: wtl0(num_nolu_vegp)    ! normalized heat conductance for leaf [-]
-    real(r8) :: wtg0                   ! normalized heat conductance for ground [-]
-    real(r8) :: wtal(num_nolu_vegp)    ! normalized heat conductance for air and leaf [-]
-    real(r8) :: wtga                   ! normalized heat cond. for air and ground  [-]
-    real(r8) :: wtaq                   ! latent heat conductance for air [m/s]
-    real(r8) :: wtlq                   ! latent heat conductance for leaf [m/s]
-    real(r8) :: wtgq(num_nolu_vegp)    ! latent heat conductance for ground [m/s]
-    real(r8) :: wtaq0(num_nolu_vegp)   ! normalized latent heat conductance for air [-]
-    real(r8) :: wtlq0(num_nolu_vegp)   ! normalized latent heat conductance for leaf [-]
-    real(r8) :: wtgq0                  ! normalized heat conductance for ground [-]
-    real(r8) :: wtalq(num_nolu_vegp)   ! normalized latent heat cond. for air and leaf [-]
-    real(r8) :: wtgaq                  ! normalized latent heat cond. for air and ground [-]
-    real(r8) :: el(num_nolu_vegp)      ! vapor pressure on leaf surface [pa]
-    real(r8) :: deldT                  ! derivative of "el" on "t_veg" [pa/K]
-    real(r8) :: qsatl(num_nolu_vegp)   ! leaf specific humidity [kg/kg]
-    real(r8) :: qsatldT(num_nolu_vegp) ! derivative of "qsatl" on "t_veg"
-    real(r8) :: e_ref2m                ! 2 m height surface saturated vapor pressure [Pa]
-    real(r8) :: de2mdT                 ! derivative of 2 m height surface saturated vapor pressure on t_ref2m
-    real(r8) :: qsat_ref2m             ! 2 m height surface saturated specific humidity [kg/kg]
-    real(r8) :: dqsat2mdT              ! derivative of 2 m height surface saturated specific humidity on t_ref2m
-    real(r8) :: air(num_nolu_vegp)     ! atmos. radiation temporay set
-    real(r8) :: bir(num_nolu_vegp)     ! atmos. radiation temporay set
-    real(r8) :: cir(num_nolu_vegp)     ! atmos. radiation temporay set
-    real(r8) :: dc1,dc2                ! derivative of energy flux [W/m2/K]
-    real(r8) :: delt                   ! temporary
-    real(r8) :: delq(num_nolu_vegp)    ! temporary
-    real(r8) :: del(num_nolu_vegp)     ! absolute change in leaf temp in current iteration [K]
-    real(r8) :: del2(num_nolu_vegp)    ! change in leaf temperature in previous iteration [K]
-    real(r8) :: dele(num_nolu_vegp)    ! change in latent heat flux from leaf [K]
-    real(r8) :: dels                   ! change in leaf temperature in current iteration [K]
-    real(r8) :: det(num_nolu_vegp)     ! maximum leaf temp. change in two consecutive iter [K]
-    real(r8) :: efeb(num_nolu_vegp)    ! latent heat flux from leaf (previous iter) [mm/s]
-    real(r8) :: efeold                 ! latent heat flux from leaf (previous iter) [mm/s]
-    real(r8) :: efpot                  ! potential latent energy flux [kg/m2/s]
-    real(r8) :: efe(num_nolu_vegp)     ! water flux from leaf [mm/s]
-    real(r8) :: efsh                   ! sensible heat from leaf [mm/s]
-    real(r8) :: obuold(num_nolu_vegp)  ! monin-obukhov length from previous iteration
-    real(r8) :: tlbef(num_nolu_vegp)   ! leaf temperature from previous iteration [K]
-    real(r8) :: ecidif                 ! excess energies [W/m2]
-    real(r8) :: err(num_nolu_vegp)     ! balance error
-    real(r8) :: erre                   ! balance error
-    real(r8) :: co2(num_nolu_vegp)     ! atmospheric co2 partial pressure (pa)
-    real(r8) :: o2(num_nolu_vegp)      ! atmospheric o2 partial pressure (pa)
-    real(r8) :: svpts(num_nolu_vegp)   ! saturation vapor pressure at t_veg (pa)
-    real(r8) :: eah(num_nolu_vegp)     ! canopy air vapor pressure (pa)
-    real(r8) :: s_node                 ! vol_liq/eff_porosity
-    real(r8) :: smp_node               ! matrix potential
-    real(r8) :: smp_node_lf            ! F. Li and S. Levis
-    real(r8) :: vol_liq                ! partial volume of liquid water in layer
-    integer  :: itlef                  ! counter for leaf temperature iteration [-]
-    integer  :: nmozsgn(num_nolu_vegp) ! number of times stability changes sign
-    real(r8) :: w                      ! exp(-LSAI)
-    real(r8) :: csoilcn                ! interpolated csoilc for less than dense canopies
-    real(r8) :: fm(num_nolu_vegp)    ! needed for BGC only to diagnose 10m wind speed
-    real(r8) :: wtshi                  ! sensible heat resistance for air, grnd and leaf [-]
-    real(r8) :: wtsqi                  ! latent heat resistance for air, grnd and leaf [-]
-    integer  :: j                      ! soil/snow level index
-    integer  :: p                      ! patch index
-    integer  :: c                      ! column index
-    integer  :: l                      ! landunit index
-    integer  :: t                      ! topounit index
-    integer  :: g                      ! gridcell index
-    integer  :: fp                     ! lake filter pft index
-    integer  :: fn                     ! number of values in vegetated pft filter
-    integer  :: fnorig                 ! number of values in pft filter copy
-    integer  :: fporig(num_nolu_vegp)  ! temporary filter
-    integer  :: fnold                       ! temporary copy of pft count
-    integer  :: f                           ! filter index
-    logical  :: found                       ! error flag for canopy above forcing hgt
-    integer  :: index                       ! patch index for error
-    real(r8) :: egvf                        ! effective green vegetation fraction
-    real(r8) :: lt                          ! elai+esai
-    real(r8) :: ri                          ! stability parameter for under canopy air (unitless)
-    real(r8) :: csoilb                      ! turbulent transfer coefficient over bare soil (unitless)
-    real(r8) :: ricsoilc                    ! modified transfer coefficient under dense canopy (unitless)
-    real(r8) :: snow_depth_c                ! critical snow depth to cover plant litter (m)
-    real(r8) :: rdl                         ! dry litter layer resistance for water vapor  (s/m)
-    real(r8) :: elai_dl                     ! exposed (dry) plant litter area index
-    real(r8) :: fsno_dl                     ! effective snow cover over plant litter
-    real(r8) :: dayl_factor(num_nolu_vegp) ! scalar (0-1) for daylength effect on Vcmax
+    real(r8) :: zldis(bounds%begp:bounds%endp)       ! reference height "minus" zero displacement height [m]
+    real(r8) :: zeta                                 ! dimensionless height used in Monin-Obukhov theory
+    real(r8) :: wc                                   ! convective velocity [m/s]
+    real(r8) :: dth(bounds%begp:bounds%endp)         ! diff of virtual temp. between ref. height and surface
+    real(r8) :: dthv(bounds%begp:bounds%endp)        ! diff of vir. poten. temp. between ref. height and surface
+    real(r8) :: dqh(bounds%begp:bounds%endp)         ! diff of humidity between ref. height and surface
+    real(r8) :: obu(bounds%begp:bounds%endp)         ! Monin-Obukhov length (m)
+    real(r8) :: um(bounds%begp:bounds%endp)          ! wind speed including the stablity effect [m/s]
+    real(r8) :: ur(bounds%begp:bounds%endp)          ! wind speed at reference height [m/s]
+    real(r8) :: uaf(bounds%begp:bounds%endp)         ! velocity of air within foliage [m/s]
+    real(r8) :: temp1(bounds%begp:bounds%endp)       ! relation for potential temperature profile
+    real(r8) :: temp12m(bounds%begp:bounds%endp)     ! relation for potential temperature profile applied at 2-m
+    real(r8) :: temp2(bounds%begp:bounds%endp)       ! relation for specific humidity profile
+    real(r8) :: temp22m(bounds%begp:bounds%endp)     ! relation for specific humidity profile applied at 2-m
+    real(r8) :: ustar(bounds%begp:bounds%endp)       ! friction velocity [m/s]
+    real(r8) :: tstar                                ! temperature scaling parameter
+    real(r8) :: qstar                                ! moisture scaling parameter
+    real(r8) :: thvstar                              ! virtual potential temperature scaling parameter
+    real(r8) :: taf(bounds%begp:bounds%endp)         ! air temperature within canopy space [K]
+    real(r8) :: qaf(bounds%begp:bounds%endp)         ! humidity of canopy air [kg/kg]
+    real(r8) :: rpp                                  ! fraction of potential evaporation from leaf [-]
+    real(r8) :: rppdry                               ! fraction of potential evaporation through transp [-]
+    real(r8) :: cf                                   ! heat transfer coefficient from leaves [-]
+    real(r8) :: cf_bare                              ! heat transfer coefficient from bare ground [-]
+    real(r8) :: rb(bounds%begp:bounds%endp)          ! leaf boundary layer resistance [s/m]
+    real(r8) :: rah(bounds%begp:bounds%endp,2)       ! thermal resistance [s/m]
+    real(r8) :: raw(bounds%begp:bounds%endp,2)       ! moisture resistance [s/m]
+    real(r8) :: wta                                  ! heat conductance for air [m/s]
+    real(r8) :: wtg(bounds%begp:bounds%endp)         ! heat conductance for ground [m/s]
+    real(r8) :: wtl                                  ! heat conductance for leaf [m/s]
+    real(r8) :: wta0(bounds%begp:bounds%endp)        ! normalized heat conductance for air [-]
+    real(r8) :: wtl0(bounds%begp:bounds%endp)        ! normalized heat conductance for leaf [-]
+    real(r8) :: wtg0                                 ! normalized heat conductance for ground [-]
+    real(r8) :: wtal(bounds%begp:bounds%endp)        ! normalized heat conductance for air and leaf [-]
+    real(r8) :: wtga                                 ! normalized heat cond. for air and ground  [-]
+    real(r8) :: wtaq                                 ! latent heat conductance for air [m/s]
+    real(r8) :: wtlq                                 ! latent heat conductance for leaf [m/s]
+    real(r8) :: wtgq(bounds%begp:bounds%endp)        ! latent heat conductance for ground [m/s]
+    real(r8) :: wtaq0(bounds%begp:bounds%endp)       ! normalized latent heat conductance for air [-]
+    real(r8) :: wtlq0(bounds%begp:bounds%endp)       ! normalized latent heat conductance for leaf [-]
+    real(r8) :: wtgq0                                ! normalized heat conductance for ground [-]
+    real(r8) :: wtalq(bounds%begp:bounds%endp)       ! normalized latent heat cond. for air and leaf [-]
+    real(r8) :: wtgaq                                ! normalized latent heat cond. for air and ground [-]
+    real(r8) :: el(bounds%begp:bounds%endp)          ! vapor pressure on leaf surface [pa]
+    real(r8) :: deldT                                ! derivative of "el" on "t_veg" [pa/K]
+    real(r8) :: qsatl(bounds%begp:bounds%endp)       ! leaf specific humidity [kg/kg]
+    real(r8) :: qsatldT(bounds%begp:bounds%endp)     ! derivative of "qsatl" on "t_veg"
+    real(r8) :: e_ref2m                              ! 2 m height surface saturated vapor pressure [Pa]
+    real(r8) :: de2mdT                               ! derivative of 2 m height surface saturated vapor pressure on t_ref2m
+    real(r8) :: qsat_ref2m                           ! 2 m height surface saturated specific humidity [kg/kg]
+    real(r8) :: dqsat2mdT                            ! derivative of 2 m height surface saturated specific humidity on t_ref2m
+    real(r8) :: air(bounds%begp:bounds%endp)         ! atmos. radiation temporay set
+    real(r8) :: bir(bounds%begp:bounds%endp)         ! atmos. radiation temporay set
+    real(r8) :: cir(bounds%begp:bounds%endp)         ! atmos. radiation temporay set
+    real(r8) :: dc1,dc2                              ! derivative of energy flux [W/m2/K]
+    real(r8) :: delt                                 ! temporary
+    real(r8) :: delq(bounds%begp:bounds%endp)        ! temporary
+    real(r8) :: del(bounds%begp:bounds%endp)         ! absolute change in leaf temp in current iteration [K]
+    real(r8) :: del2(bounds%begp:bounds%endp)        ! change in leaf temperature in previous iteration [K]
+    real(r8) :: dele(bounds%begp:bounds%endp)        ! change in latent heat flux from leaf [K]
+    real(r8) :: dels                                 ! change in leaf temperature in current iteration [K]
+    real(r8) :: det(bounds%begp:bounds%endp)         ! maximum leaf temp. change in two consecutive iter [K]
+    real(r8) :: efeb(bounds%begp:bounds%endp)        ! latent heat flux from leaf (previous iter) [mm/s]
+    real(r8) :: efeold                               ! latent heat flux from leaf (previous iter) [mm/s]
+    real(r8) :: efpot                                ! potential latent energy flux [kg/m2/s]
+    real(r8) :: efe(bounds%begp:bounds%endp)         ! water flux from leaf [mm/s]
+    real(r8) :: efsh                                 ! sensible heat from leaf [mm/s]
+    real(r8) :: obuold(bounds%begp:bounds%endp)      ! monin-obukhov length from previous iteration
+    real(r8) :: tlbef(bounds%begp:bounds%endp)       ! leaf temperature from previous iteration [K]
+    real(r8) :: ecidif                               ! excess energies [W/m2]
+    real(r8) :: err(bounds%begp:bounds%endp)         ! balance error
+    real(r8) :: erre                                 ! balance error
+    real(r8) :: co2(bounds%begp:bounds%endp)         ! atmospheric co2 partial pressure (pa)
+    real(r8) :: c13o2(bounds%begp:bounds%endp)       ! atmospheric c13o2 partial pressure (pa)
+    real(r8) :: o2(bounds%begp:bounds%endp)          ! atmospheric o2 partial pressure (pa)
+    real(r8) :: svpts(bounds%begp:bounds%endp)       ! saturation vapor pressure at t_veg (pa)
+    real(r8) :: eah(bounds%begp:bounds%endp)         ! canopy air vapor pressure (pa)
+    real(r8) :: s_node                               ! vol_liq/eff_porosity
+    real(r8) :: smp_node                             ! matrix potential
+    real(r8) :: smp_node_lf                          ! F. Li and S. Levis
+    real(r8) :: vol_liq                              ! partial volume of liquid water in layer
+    integer  :: itlef                                ! counter for leaf temperature iteration [-]
+    integer  :: iter_final                           ! number of iterations used
+    integer  :: nmozsgn(bounds%begp:bounds%endp)     ! number of times stability changes sign
+    real(r8) :: w                                    ! exp(-LSAI)
+    real(r8) :: csoilcn                              ! interpolated csoilc for less than dense canopies
+    real(r8) :: fm(bounds%begp:bounds%endp)          ! needed for BGC only to diagnose 10m wind speed
+    real(r8) :: wtshi                                ! sensible heat resistance for air, grnd and leaf [-]
+    real(r8) :: wtsqi                                ! latent heat resistance for air, grnd and leaf [-]
+    integer  :: j                                    ! soil/snow level index
+    integer  :: p                                    ! patch index
+    integer  :: c                                    ! column index
+    integer  :: l                                    ! landunit index
+    integer  :: t                                    ! topounit index
+    integer  :: g                                    ! gridcell index
+    integer  :: fp                                   ! lake filter pft index
+    integer  :: fn_noveg                             ! number of values in bare ground pft filter
+    integer  :: filterp_noveg(bounds%endp-bounds%begp+1) ! bare ground pft filter
+    integer  :: fn                                   ! number of values in vegetated pft filter
+    integer  :: filterp(bounds%endp-bounds%begp+1)   ! vegetated pft filter
+    integer  :: fnorig                               ! number of values in pft filter copy
+    integer  :: fporig(bounds%endp-bounds%begp+1)    ! temporary filter
+    integer  :: fnold                                ! temporary copy of pft count
+    integer  :: f                                    ! filter index
+    logical  :: found                                ! error flag for canopy above forcing hgt
+    integer  :: index                                ! patch index for error
+    real(r8) :: egvf                                 ! effective green vegetation fraction
+    real(r8) :: lt                                   ! elai+esai
+    real(r8) :: ri                                   ! stability parameter for under canopy air (unitless)
+    real(r8) :: csoilb                               ! turbulent transfer coefficient over bare soil (unitless)
+    real(r8) :: ricsoilc                             ! modified transfer coefficient under dense canopy (unitless)
+    real(r8) :: snow_depth_c                         ! critical snow depth to cover plant litter (m)
+    real(r8) :: rdl                                  ! dry litter layer resistance for water vapor  (s/m)
+    real(r8) :: elai_dl                              ! exposed (dry) plant litter area index
+    real(r8) :: fsno_dl                              ! effective snow cover over plant litter
+    real(r8) :: dayl_factor(bounds%begp:bounds%endp) ! scalar (0-1) for daylength effect on Vcmax
     ! If no unfrozen layers, put all in the top layer.
+    real(r8) :: rootsum(bounds%begp:bounds%endp)
     real(r8) :: delt_snow
     real(r8) :: delt_soil
     real(r8) :: delt_h2osfc
@@ -279,23 +290,30 @@ contains
     real(r8) :: delq_snow
     real(r8) :: delq_soil
     real(r8) :: delq_h2osfc
-    integer  :: local_time                     ! local time at start of time step (seconds after solar midnight)
+    integer  :: local_time                               ! local time at start of time step (seconds after solar midnight)
     integer  :: seconds_since_irrig_start_time
-    integer  :: irrig_nsteps_per_day           ! number of time steps per day in which we irrigate
-    logical  :: check_for_irrig(num_nolu_vegp) ! where do we need to check soil moisture to see if we need to irrigate?
-    logical  :: frozen_soil(num_nolu_vegp)     ! set to true if we have encountered a frozen soil layer
-    real(r8) :: vol_liq_so                     ! partial volume of liquid water in layer for which smp_node = smpso
-    real(r8) :: h2osoi_liq_so                  ! liquid water corresponding to vol_liq_so for this layer [kg/m2]
-    real(r8) :: h2osoi_liq_sat                 ! liquid water corresponding to eff_porosity for this layer [kg/m2]
-    real(r8) :: deficit                        ! difference between desired soil moisture level for this layer and
-                                               ! current soil moisture level [kg/m2]
-    real(r8) :: dt_veg(num_nolu_vegp)          ! change in t_veg, last iteration (Kelvin)
-    integer  :: ft                             ! plant functional type index
-    real(r8) :: temprootr,sum1
+    integer  :: irrig_nsteps_per_day                     ! number of time steps per day in which we irrigate
+    logical  :: check_for_irrig(bounds%begp:bounds%endp) ! where do we need to check soil moisture to see if we need to irrigate?
+    logical  :: frozen_soil(bounds%begp:bounds%endp)     ! set to true if we have encountered a frozen soil layer
+    real(r8) :: vol_liq_so                               ! partial volume of liquid water in layer for which smp_node = smpso
+    real(r8) :: h2osoi_liq_so                            ! liquid water corresponding to vol_liq_so for this layer [kg/m2]
+    real(r8) :: h2osoi_liq_sat                           ! liquid water corresponding to eff_porosity for this layer [kg/m2]
+    real(r8) :: deficit                                  ! difference between desired soil moisture level for this layer and
+                                                         ! current soil moisture level [kg/m2]
+    real(r8) :: dt_veg(bounds%begp:bounds%endp)          ! change in t_veg, last iteration (Kelvin)
+    integer  :: jtop(bounds%begc:bounds%endc)            ! lbning
+    integer  :: filterc_tmp(bounds%endp-bounds%begp+1)   ! temporary variable
+    integer  :: ft                                       ! plant functional type index
+    real(r8) :: temprootr
+    real(r8) :: dt_veg_temp(bounds%begp:bounds%endp)
     integer  :: iv
-    real :: startt, stopt,iterT1,iterT2
-    integer :: filterp(num_nolu_vegp)  ! filter for iteration loop
-    integer :: converged(num_nolu_vegp), num_unconverged 
+    real(r8) :: wind_speed0(bounds%begp:bounds%endp) ! Wind speed from atmosphere at start of iteration
+    real(r8) :: wind_speed_adj(bounds%begp:bounds%endp) ! Adjusted wind speed for iteration
+    real(r8) :: tau(bounds%begp:bounds%endp)      ! Stress used in iteration
+    real(r8) :: tau_diff(bounds%begp:bounds%endp) ! Difference from previous iteration tau
+    real(r8) :: prev_tau(bounds%begp:bounds%endp) ! Previous iteration tau
+    real(r8) :: prev_tau_diff(bounds%begp:bounds%endp) ! Previous difference in iteration tau
+
     character(len=64) :: event !! timing event
     !------------------------------------------------------------------------------
 
@@ -304,17 +322,20 @@ contains
          dayl                 => grc_pp%dayl                                  , & ! Input:  [real(r8) (:)   ]  daylength (s)
          max_dayl             => grc_pp%max_dayl                              , & ! Input:  [real(r8) (:)   ]  maximum daylength for this grid cell (s)
 
-         forc_lwrad           => top_af%lwrad                              , & ! Input:  [real(r8) (:)   ]  downward infrared (longwave) radiation (W/m**2)
-         forc_q               => top_as%qbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric specific humidity (kg/kg)
-         forc_pbot            => top_as%pbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)
-         forc_th              => top_as%thbot                              , & ! Input:  [real(r8) (:)   ]  atmospheric potential temperature (Kelvin)
-         forc_rho             => top_as%rhobot                             , & ! Input:  [real(r8) (:)   ]  air density (kg/m**3)
-         forc_t               => top_as%tbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric temperature (Kelvin)
-         forc_u               => top_as%ubot                               , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in east direction (m/s)
-         forc_v               => top_as%vbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in north direction (m/s)
-         forc_pco2            => top_as%pco2bot                            , & ! Input:  [real(r8) (:)   ]  partial pressure co2 (Pa)
-         forc_pc13o2          => top_as%pc13o2bot                          , & ! Input:  [real(r8) (:)   ]  partial pressure c13o2 (Pa)
-         forc_po2             => top_as%po2bot                             , & ! Input:  [real(r8) (:)   ]  partial pressure o2 (Pa)
+         forc_lwrad           => top_af%lwrad                              , & ! Input:  [real(r8) (:)   ]  downward infrared (longwave) radiation (W/m**2)                       
+         forc_q               => top_as%qbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric specific humidity (kg/kg)                                 
+         forc_pbot            => top_as%pbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)                                             
+         forc_th              => top_as%thbot                              , & ! Input:  [real(r8) (:)   ]  atmospheric potential temperature (Kelvin)                            
+         forc_rho             => top_as%rhobot                             , & ! Input:  [real(r8) (:)   ]  air density (kg/m**3)                                                     
+         forc_t               => top_as%tbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric temperature (Kelvin)                                      
+         forc_u               => top_as%ubot                               , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in east direction (m/s)                        
+         forc_v               => top_as%vbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in north direction (m/s)                       
+         wsresp               => top_as%wsresp                             , & ! Input:  [real(r8) (:)   ]  response of wind to surface stress (m/s/Pa)
+         tau_est              => top_as%tau_est                            , & ! Input:  [real(r8) (:)   ]  approximate atmosphere change to zonal wind (m/s)
+         ugust                => top_as%ugust                              , & ! Input:  [real(r8) (:)   ]  gustiness from atmosphere (m/s)
+         forc_pco2            => top_as%pco2bot                            , & ! Input:  [real(r8) (:)   ]  partial pressure co2 (Pa)                                             
+         forc_pc13o2          => top_as%pc13o2bot                          , & ! Input:  [real(r8) (:)   ]  partial pressure c13o2 (Pa)                                           
+         forc_po2             => top_as%po2bot                             , & ! Input:  [real(r8) (:)   ]  partial pressure o2 (Pa)                                              
 
          dleaf                => veg_vp%dleaf                          , & ! Input:  [real(r8) (:)   ]  characteristic leaf dimension (m)
          smpso                => veg_vp%smpso                          , & ! Input:  [real(r8) (:)   ]  soil water potential at full stomatal opening (mm)
@@ -354,13 +375,6 @@ contains
          z0hv                 => frictionvel_vars%z0hv_patch               , & ! Output: [real(r8) (:)   ]  roughness length over vegetation, sensible heat [m]
          z0qv                 => frictionvel_vars%z0qv_patch               , & ! Output: [real(r8) (:)   ]  roughness length over vegetation, latent heat [m]
          rb1                  => frictionvel_vars%rb1_patch                , & ! Output: [real(r8) (:)   ]  boundary layer resistance (s/m)
-         forc_hgt_t_patch => frictionvel_vars%forc_hgt_t_patch , & ! Input:  [real(r8) (:) ] observational height of temperature at pft level [m]
-         forc_hgt_q_patch => frictionvel_vars%forc_hgt_q_patch , & ! Input:  [real(r8) (:) ] observational height of specific humidity at pft level [m]
-         vds              => frictionvel_vars%vds_patch        , & ! Output: [real(r8) (:) ] dry deposition velocity term (m/s) (for SO4 NH4NO3)
-         u10              => frictionvel_vars%u10_patch        , & ! Output: [real(r8) (:) ] 10-m wind (m/s) (for dust model)
-         u10_elm          => frictionvel_vars%u10_elm_patch    , & ! Output: [real(r8) (:) ] 10-m wind (m/s)
-         va               => frictionvel_vars%va_patch         , & ! Output: [real(r8) (:) ] atmospheric wind speed plus convective velocity (m/s)
-         fv               => frictionvel_vars%fv_patch         ,  & ! Output: [real(r8) (:) ] friction velocity (m/s) (for dust model)
 
          t_h2osfc             => col_es%t_h2osfc             , & ! Input:  [real(r8) (:)   ]  surface water temperature
          t_soisno             => col_es%t_soisno             , & ! Input:  [real(r8) (:,:) ]  soil temperature (Kelvin)
@@ -432,117 +446,111 @@ contains
         bsun                    => energyflux_vars%bsun_patch ! Output:[real(r8) (:)   ]  sunlit canopy transpiration wetness factor (0 to 1)
         bsha                    => energyflux_vars%bsha_patch ! Output:[real(r8) (:)   ]  sunlit canopy transpiration wetness factor (0 to 1)
       end if
+      ! Determine step size
+      dtime = dtime_mod
+      !yr = year_curr; mon = mon_curr; day = day_curr;
+      time = secs_curr;
 
-     
-      fn = num_nolu_vegp
+      irrig_nsteps_per_day = ((irrig_length + (dtime - 1))/dtime)  ! round up
       ! First - set the following values over points where frac vegetation covered by snow is zero
       ! (e.g. btran, t_veg, rootr, rresis)
-      if(num_nolu_barep > 0) then
-         !$acc parallel loop independent gang vector private(p,c,t) default(present) &
-         !$acc   present(t_veg(:), btran(:), rssun(:), rssha(:), lbl_rsc_h2o(:), thm(:) ) 
-         do fp = 1,num_nolu_barep
-            p = filter_nolu_barep(fp)
-            c = veg_pp%column(p)
-            t = veg_pp%topounit(p)
+      do fp = 1,num_nolakeurbanp
+         p = filter_nolakeurbanp(fp)
+         c = veg_pp%column(p)
+         t = veg_pp%topounit(p)
+         if (frac_veg_nosno(p) == 0) then
             btran(p) = 0._r8
             t_veg(p) = forc_t(t)
             cf_bare  = forc_pbot(t)/(SHR_CONST_RGAS*0.001_r8*thm(p))*1.e06_r8
             rssun(p) = 1._r8/1.e15_r8 * cf_bare
             rssha(p) = 1._r8/1.e15_r8 * cf_bare
             lbl_rsc_h2o(p)=0._r8
-         end do
-         !$acc parallel loop independent gang default(present)
-         do j = 1, nlevgrnd
-            !$acc loop vector private(p)
-            do fp = 1,num_nolu_barep
-               p = filter_nolu_barep(fp)
+            do j = 1, nlevgrnd
                rootr(p,j)  = 0._r8
                rresis(p,j) = 0._r8
             end do
-         end do
-         
-            
+         end if
+      end do
+      ! -----------------------------------------------------------------
+      ! Time step initialization of photosynthesis variables
+      ! -----------------------------------------------------------------
+
+      call photosyns_vars_TimeStepInit(photosyns_vars,bounds)
+
+      ! -----------------------------------------------------------------
+      ! Filter patches where frac_veg_nosno IS NON-ZERO
+      ! -----------------------------------------------------------------
+      fn = 0
+      do fp = 1,num_nolakeurbanp
+         p = filter_nolakeurbanp(fp)
+         if (frac_veg_nosno(p) /= 0) then
+            fn = fn + 1
+            filterp(fn) = p
+         end if
+      end do
+
+#ifndef _OPENACC
+      if (use_fates) then
+         call alm_fates%prep_canopyfluxes( bounds )
       end if
-      if(num_nolu_vegp == 0) return
-      !!NOTE:  Ensure dtime_mod and secs_curr replaces dtime and time !!!!
-      ! Determine step size
-      time = secs_curr;
-      irrig_nsteps_per_day = ((irrig_length + (dtime_mod - 1))/dtime_mod)  ! round up
-      !$acc enter data copyin(time,irrig_nsteps_per_day) 
+#endif
 
-      !$acc enter data create(del(:), efeb(:), wtlq0(:),wtalq(:), &
-      !$acc    wtgq(:), wtaq0(:), obuold(:),dayl_factor(:),check_for_irrig(:),zldis(:) ) 
-      !$acc enter data create(filterp(:))
-      ! Initialize
 
-      !$acc parallel loop independent gang vector private(p) default(present) present(btran(:), btran2(:))
+      ! Initialize
       do f = 1, fn
-         filterp(f) = filter_nolu_vegp(f) 
          p = filterp(f)
-         del(f)    = 0._r8  ! change in leaf temperature from previous iteration
-         efeb(f)   = 0._r8  ! latent head flux from leaf for previous iteration
-         wtlq0(f)  = 0._r8
-         wtalq(f)  = 0._r8
-         wtgq(f)   = 0._r8
-         wtaq0(f)  = 0._r8
-         obuold(f) = 0._r8
+         del(p)    = 0._r8  ! change in leaf temperature from previous iteration
+         efeb(p)   = 0._r8  ! latent head flux from leaf for previous iteration
+         wtlq0(p)  = 0._r8
+         wtalq(p)  = 0._r8
+         wtgq(p)   = 0._r8
+         wtaq0(p)  = 0._r8
+         obuold(p) = 0._r8
          btran(p)  = btran0
          btran2(p)  = btran0
       end do
 
       ! calculate daylength control for Vcmax
-      !$acc parallel loop independent gang vector private(p,g) default(present)
       do f = 1, fn
-         p=filter_nolu_vegp(f)
+         p=filterp(f)
          g=veg_pp%gridcell(p)
          ! calculate dayl_factor as the ratio of (current:max dayl)^2
          ! set a minimum of 0.01 (1%) for the dayl_factor
-         dayl_factor(f)=min(1._r8,max(0.01_r8,(dayl(g)*dayl(g))/(max_dayl(g)*max_dayl(g))))
+         dayl_factor(p)=min(1._r8,max(0.01_r8,(dayl(g)*dayl(g))/(max_dayl(g)*max_dayl(g))))
       end do
-      ! -----------------------------------------------------------------
-      ! Time step initialization of photosynthesis variables
-      ! -----------------------------------------------------------------
-      !NOTE: This likely shouldn't init based on bounds but on a filter !!
-      call photosyns_vars_TimeStepInit(photosyns_vars,bounds)
 
-#ifndef _OPENACC
-      if (use_fates) then
-         !#fates_py call alm_fates%prep_canopyfluxes( bounds )
-      end if
-#endif
-      
       rb1(begp:endp) = 0._r8
-
-
-      !NOTE: this filter set up means doing the same calculations for a column
-      !      redundantly (eg. computing the same column variable 4 times)
-      !      It would be best to make nolu_vegc filter.
       !assign the temporary filter
-      
-      ! compute effective soil porosity
+      do f = 1, fn
+         p = filterp(f)
+         filterc_tmp(f)=veg_pp%column(p)
+      enddo
+
+      !compute effective soil porosity
       call calc_effective_soilporosity(bounds,                          &
            ubj = nlevgrnd,                                              &
            numf = fn,                                                   &
-           filter = filter_nolu_vegp(1:fn),                             &
+           filter = filterc_tmp(1:fn),                                  &
            watsat = watsat(bounds%begc:bounds%endc, 1:nlevgrnd),        &
            h2osoi_ice = h2osoi_ice(bounds%begc:bounds%endc,1:nlevgrnd), &
            denice = denice,                                             &
            eff_por=eff_porosity(bounds%begc:bounds%endc, 1:nlevgrnd) )
 
       !compute volumetric liquid water content
+      jtop(bounds%begc:bounds%endc) = 1
 
       call calc_volumetric_h2oliq(bounds,                                    &
+           jtop = jtop(bounds%begc:bounds%endc),                             &
            lbj = 1,                                                          &
            ubj = nlevgrnd,                                                   &
            numf = fn,                                                        &
-           filter = filter_nolu_vegp(1:fn),                                       &
+           filter = filterc_tmp(1:fn),                                       &
            eff_porosity = eff_porosity(bounds%begc:bounds%endc, 1:nlevgrnd), &
            h2osoi_liq = h2osoi_liq(bounds%begc:bounds%endc, 1:nlevgrnd),     &
            denh2o = denh2o,                                                  &
            vol_liq = h2osoi_liqvol(bounds%begc:bounds%endc, 1:nlevgrnd) )
 
-      ! set up perchroot options
-      ! Better way to do this???
+      !set up perchroot options
       call set_perchroot_opt(perchroot, perchroot_alt)
       ! --------------------------------------------------------------------------
       ! if this is a FATES simulation
@@ -555,72 +563,77 @@ contains
       ! wetness factor btran and the root weighting factors for FATES.  These
       ! values require knowledge of the belowground root structure.
       ! --------------------------------------------------------------------------
+
       if(use_fates)then
 #ifndef _OPENACC
-         !#fates_py call alm_fates%wrap_btran(bounds, fn, filterc_tmp(1:fn), soilstate_vars, &
-               !#fates_py temperature_vars, energyflux_vars, soil_water_retention_curve)
+         call alm_fates%wrap_btran(bounds, fn, filterc_tmp(1:fn), soilstate_vars, &
+               temperature_vars, energyflux_vars, soil_water_retention_curve)
 #endif
       else
          !calculate root moisture stress
          call calc_root_moist_stress(bounds,     &
               nlevgrnd = nlevgrnd,               &
               fn = fn,                           &
-              filterp = filter_nolu_vegp,                 &
+              filterp = filterp,                 &
               canopystate_vars=canopystate_vars, &
               energyflux_vars=energyflux_vars,   &
               soilstate_vars=soilstate_vars      &
               )
-      end if !use_fates
 
+      end if !use_fates
       ! Determine if irrigation is needed (over irrigated soil columns)
+
       ! First, determine in what grid cells we need to bother 'measuring' soil water, to see if we need irrigation
       ! Also set n_irrig_steps_left for these grid cells
       ! n_irrig_steps_left(p) > 0 is ok even if irrig_rate(p) ends up = 0
       ! in this case, we'll irrigate by 0 for the given number of time steps
-      !$acc parallel loop independent gang vector default(present) present(btran(:),elai(:),n_irrig_steps_left(:), irrig_rate(:)) private(p,g,local_time,seconds_since_irrig_start_time)
+
       do f = 1, fn
-         p = filter_nolu_vegp(f)
+         p = filterp(f)
+         c = veg_pp%column(p)
          g = veg_pp%gridcell(p)
          if ( .not.veg_pp%is_fates(p)             .and. &
               irrigated(veg_pp%itype(p)) == 1._r8 .and. &
-              elai(p) > irrig_min_lai  .and. btran(p) < irrig_btran_thresh ) then
+              elai(p) > irrig_min_lai          .and. &
+              btran(p) < irrig_btran_thresh ) then
 
             ! see if it's the right time of day to start irrigating:
-            local_time = modulo(secs_curr + nint(grc_pp%londeg(g)/degpsec), isecspday)
+            local_time = modulo(time + nint(grc_pp%londeg(g)/degpsec), isecspday)
             seconds_since_irrig_start_time = modulo(local_time - irrig_start_time, isecspday)
-            if (seconds_since_irrig_start_time < dtime_mod) then
+            if (seconds_since_irrig_start_time < dtime) then
                ! it's time to start irrigating
-               check_for_irrig(f)    = .true.
+               check_for_irrig(p)    = .true.
                n_irrig_steps_left(p) = irrig_nsteps_per_day
                irrig_rate(p)         = 0._r8  ! reset; we'll add to this later
             else
-               check_for_irrig(f)    = .false.
+               check_for_irrig(p)    = .false.
             end if
          else  ! non-irrig pft or elai<=irrig_min_lai or btran>irrig_btran_thresh
-            check_for_irrig(f)       = .false.
+            check_for_irrig(p)       = .false.
          end if
 
       end do
 
+
       ! Now 'measure' soil water for the grid cells identified above and see if the
       ! soil is dry enough to warrant irrigation
       ! (Note: frozen_soil could probably be a column-level variable, but that would be
       ! slightly less robust to potential future modifications)
       ! This should not be operating on FATES patches (see is_fates filter above, pushes
       ! check_for_irrig = false
-      ! frozen_soil(1:fn) = .false.
-      !$acc parallel loop independent gang worker default(present) private(p,c,g)
-      do f = 1, fn
-         p = filter_nolu_vegp(f)
-         c = veg_pp%column(p)
-         g = veg_pp%gridcell(p)
-         if (check_for_irrig(f)) then
-            !$acc loop vector reduction(+:sum1) private(vol_liq_so,h2osoi_liq_so,h2osoi_liq_sat,deficit)
-            do j = 1,nlevgrnd
+      frozen_soil(bounds%begp : bounds%endp) = .false.
+      do j = 1,nlevgrnd
+         do f = 1, fn
+            p = filterp(f)
+            c = veg_pp%column(p)
+            g = veg_pp%gridcell(p)
+            if (check_for_irrig(p) .and. .not. frozen_soil(p)) then
                ! if level L was frozen, then we don't look at any levels below L
-               ! if (t_soisno(c,j) <= SHR_CONST_TKFRZ) then
-               if (t_soisno(c,j) > SHR_CONST_TKFRZ .and. rootfr(p,j) > 0._r8) then
+               if (t_soisno(c,j) <= SHR_CONST_TKFRZ) then
+                  frozen_soil(p) = .true.
+               else if (rootfr(p,j) > 0._r8) then
                   ! determine soil water deficit in this layer:
+
                   ! Calculate vol_liq_so - i.e., vol_liq at which smp_node = smpso - by inverting the above equations
                   ! for the root resistance factors
                   vol_liq_so   = eff_porosity(c,j) * (-smpso(veg_pp%itype(p))/sucsat(c,j))**(-1/bsw(c,j))
@@ -628,24 +641,19 @@ contains
                   ! Translate vol_liq_so and eff_porosity into h2osoi_liq_so and h2osoi_liq_sat and calculate deficit
                   h2osoi_liq_so  = vol_liq_so * denh2o * col_pp%dz(c,j)
                   h2osoi_liq_sat = eff_porosity(c,j) * denh2o * col_pp%dz(c,j)
-                  deficit        = max((h2osoi_liq_so + ldomain_gpu%firrig(g)*(h2osoi_liq_sat - h2osoi_liq_so)) - h2osoi_liq(c,j), 0._r8)
+                  deficit        = max((h2osoi_liq_so + ldomain%firrig(g)*(h2osoi_liq_sat - h2osoi_liq_so)) - h2osoi_liq(c,j), 0._r8)
 
                   ! Add deficit to irrig_rate, converting units from mm to mm/sec
-                  sum1  = sum1 + deficit/(dtime_mod*irrig_nsteps_per_day)
+                  irrig_rate(p)  = irrig_rate(p) + deficit/(dtime*irrig_nsteps_per_day)
 
                end if  ! else if (rootfr(p,j) > 0)
-            end do     ! do j
-            irrig_rate(p) = sum1
-         end if        ! if (check_for_irrig(f) .and. .not. frozen_soil(f))
-      end do           ! do f
-
-      found = .false.
+            end if     ! if (check_for_irrig(p) .and. .not. frozen_soil(p))
+         end do        ! do f
+      end do           ! do j
 
       ! Modify aerodynamic parameters for sparse/dense canopy (X. Zeng)
-      !$acc parallel loop independent gang vector default(present) private(p,c,egvf,lt) &
-      !$acc present(z0qv(:),forc_hgt_u_patch(:),elai(:),displa(:),esai(:),z0hv(:),z0mg(:),z0mv(:))
       do f = 1, fn
-         p = filter_nolu_vegp(f)
+         p = filterp(f)
          c = veg_pp%column(p)
 
          lt = min(elai(p)+esai(p), tlsai_crit)
@@ -654,116 +662,136 @@ contains
          z0mv(p)   = exp(egvf * log(z0mv(p)) + (1._r8 - egvf) * log(z0mg(c)))
          z0hv(p)   = z0mv(p)
          z0qv(p)   = z0mv(p)
-
-         !!Moved this here to allow async compute/data create w/ loop below
-         zldis(f) = forc_hgt_u_patch(p) - displa(p)
-
       end do
 
-      !$acc enter data create(air(:),bir(:), cir(:), co2(:),o2(:),&
-      !$acc nmozsgn(:), taf(:),qaf(:), ur(:),dth(:),dqh(:),delq(:), &
-      !$acc  dthv(:), obu(:),el(:),qsatl(:),qsatldT(:), um(:), &
-      !$acc  wta0(:), err(:), det(:))
-
-      !$acc parallel loop independent gang vector default(present) private(p,c,t,g,deldT) present(thm(:),emv(:))
+      found = .false.
       do f = 1, fn
-         p = filter_nolu_vegp(f)
+         p = filterp(f)
          c = veg_pp%column(p)
          t = veg_pp%topounit(p)
          g = veg_pp%gridcell(p)
 
          ! Net absorbed longwave radiation by canopy and ground
          ! =air+bir*t_veg**4+cir*t_grnd(c)**4
-         air(f) =   emv(p) * (1._r8+(1._r8-emv(p))*(1._r8-emg(c))) * forc_lwrad(t)
-         bir(f) = - (2._r8-emv(p)*(1._r8-emg(c))) * emv(p) * sb
-         cir(f) =   emv(p)*emg(c)*sb
+
+         air(p) =   emv(p) * (1._r8+(1._r8-emv(p))*(1._r8-emg(c))) * forc_lwrad(t)
+         bir(p) = - (2._r8-emv(p)*(1._r8-emg(c))) * emv(p) * sb
+         cir(p) =   emv(p)*emg(c)*sb
 
          ! Saturated vapor pressure, specific humidity, and their derivatives
          ! at the leaf surface
 
-         call QSat (t_veg(p), forc_pbot(t), el(f), deldT, qsatl(f), qsatldT(f))
+         call QSat (t_veg(p), forc_pbot(t), el(p), deldT, qsatl(p), qsatldT(p))
 
          ! Determine atmospheric co2 and o2
 
-         co2(f) = forc_pco2(t)
-         o2(f)  = forc_po2(t)
+         co2(p) = forc_pco2(t)
+         o2(p)  = forc_po2(t)
+
+         if ( use_c13 ) then
+            c13o2(p) = forc_pc13o2(t)
+         end if
 
          ! Initialize flux profile
-         nmozsgn(f) = 0
 
-         taf(f) = (t_grnd(c) + thm(p))/2._r8
-         qaf(f) = (forc_q(t)+qg(c))/2._r8
+         nmozsgn(p) = 0
+
+         taf(p) = (t_grnd(c) + thm(p))/2._r8
+         qaf(p) = (forc_q(t)+qg(c))/2._r8
 
-         ur(f)    = max(1.0_r8,sqrt(forc_u(t)*forc_u(t)+forc_v(t)*forc_v(t)))
-         dth(f)   = thm(p)-taf(f)
-         dqh(f)   = forc_q(t)-qaf(f)
-         delq(f)  = qg(c) - qaf(f)
-         dthv(f)  = dth(f)*(1._r8+0.61_r8*forc_q(t))+0.61_r8*forc_th(t)*dqh(f)
+         ! Initialize winds for iteration.
+         if (implicit_stress) then
+            wind_speed0(p) = max(0.01_r8, hypot(forc_u(t), forc_v(t)))
+            wind_speed_adj(p) = wind_speed0(p)
+            ur(p) = max(1.0_r8, wind_speed_adj(p) + ugust(t))
+
+            prev_tau(p) = tau_est(t)
+         else
+            ur(p) = max(1.0_r8,sqrt(forc_u(t)*forc_u(t)+forc_v(t)*forc_v(t)) + ugust(t))
+         end if
+         tau_diff(p) = 1.e100_r8
+
+         dth(p) = thm(p)-taf(p)
+         dqh(p) = forc_q(t)-qaf(p)
+         delq(p) = qg(c) - qaf(p)
+         dthv(p) = dth(p)*(1._r8+0.61_r8*forc_q(t))+0.61_r8*forc_th(t)*dqh(p)
+         zldis(p) = forc_hgt_u_patch(p) - displa(p)
+
+
+         ! Check to see if the forcing height is below the canopy height
+         if (zldis(p) < 0._r8) then
+            found = .true.
+            index = p
+         end if
 
       end do
 
       if (found) then
          if ( .not. use_fates ) then
-            write(*,*)'Error: Forcing height is below canopy height for pft index '
+#ifndef _OPENACC
+            write(iulog,*)'Error: Forcing height is below canopy height for pft index '
             call endrun(decomp_index=index, elmlevel=namep, msg=errmsg(__FILE__, __LINE__))
+#endif
          end if
       end if
-      
-      !$acc enter data create(converged(:) ) 
-      !$acc parallel loop independent gang vector default(present) private(p,c)
+
       do f = 1, fn
-         p = filter_nolu_vegp(f)
+         p = filterp(f)
          c = veg_pp%column(p)
-         converged(f) = 0 
+
          ! Initialize Monin-Obukhov length and wind speed
 
-         call MoninObukIni(ur(f), thv(c), dthv(f), zldis(f), z0mv(p), um(f), obu(f))
+         call MoninObukIni(ur(p), thv(c), dthv(p), zldis(p), z0mv(p), um(p), obu(p))
 
       end do
+
       ! Set counter for leaf temperature iteration (itlef)
-      
-      num_unconverged = num_nolu_vegp  
-      itlef = 0
-      !$acc enter data copyin(itlef) create(temp1(:), temp2(:),temp12m(:),&
-      !$acc    temp22m(:),ustar(:),rah(:,:),raw(:,:), uaf(:),rb(:), &
-      !$acc     tlbef(:), del(:),del2(:),svpts(:),eah(:), dt_veg(:),wtg(:), &
-      !$acc     wtl0(:), wtal(:), efe(:), dele(:),fm(:))
-      
+
+      itlef = 1
+      fnorig = fn
+      fporig(1:fn) = filterp(1:fn)
+
       ! Begin stability iteration
       event = 'can_iter'
-      ITERATION : do while (itlef <= itmax .and. num_unconverged > 0)
-        !$acc update device(itlef)  
-        !$acc parallel loop independent gang vector  default(present)
-        do f = 1, fn
-            if(converged(f)) cycle
+      call t_start_lnd(event)
+      ITERATION : do while (itlef <= itmax .and. fn > 0)
+
+         ! Determine friction velocity, and potential temperature and humidity
+         ! profiles of the surface boundary layer
+         call FrictionVelocity (begp, endp, fn, filterp, &
+              displa(begp:endp), z0mv(begp:endp), z0hv(begp:endp), z0qv(begp:endp), &
+              obu(begp:endp), itlef, ur(begp:endp), um(begp:endp), ustar(begp:endp), &
+              temp1(begp:endp), temp2(begp:endp), temp12m(begp:endp), temp22m(begp:endp), fm(begp:endp), &
+              frictionvel_vars)
+
+         do f = 1, fn
             p = filterp(f)
-            call FrictionVelocity_noloop ( &
-                        displa(p), z0mv(p), z0hv(p), z0qv(p), &
-                        obu(f), itlef+1, ur(f), um(f), ustar(f), &
-                        temp1(f), temp2(f), temp12m(f), temp22m(f), fm(f), &
-                        forc_hgt_u_patch(p), forc_hgt_t_patch(p), forc_hgt_q_patch(p), &
-                        vds(p), u10(p), u10_elm(p), va(p), fv(p))
-        end do
-        !$acc parallel loop independent gang vector default(present) private(p,c,t,g,&
-        !$acc  cf, w,csoilb,ri, ricsoilc, csoilcn) present(ram1(:), rb1(:), rhaf(:),grnd_ch4_cond(:),t_veg(:),elai(:),btran(:),&
-        !$acc  esai(:), temp2(:), htop(:), dleaf_patch(:), rah(:,:))
-        do f = 1, fn
-           if(converged(f)) cycle
-           p = filterp(f)
-           c = veg_pp%column(p)
-           t = veg_pp%topounit(p)
-           g = veg_pp%gridcell(p)
+            c = veg_pp%column(p)
+            t = veg_pp%topounit(p)
+            g = veg_pp%gridcell(p)
 
-            tlbef(f) = t_veg(p) !not used right now?
-            del2(f) = del(f)   ! also not used in this loop
+            tlbef(p) = t_veg(p)
+            del2(p) = del(p)
 
             ! Determine aerodynamic resistances
-            ram1(p)  = 1._r8/(ustar(f)*ustar(f)/um(f))
-            rah(f,1) = 1._r8/(temp1(f)*ustar(f))
-            raw(f,1) = 1._r8/(temp2(f)*ustar(f))
+            ram1(p)  = 1._r8/(ustar(p)*ustar(p)/um(p))
+            rah(p,1) = 1._r8/(temp1(p)*ustar(p))
+            raw(p,1) = 1._r8/(temp2(p)*ustar(p))
+
+            ! Forbid removing more than 99% of wind speed in a time step.
+            ! This is mainly to avoid convergence issues since this is such a
+            ! basic form of iteration in this loop...
+            if (implicit_stress) then
+               tau(p) = forc_rho(t)*wind_speed_adj(p)/ram1(p)
+               call shr_flux_update_stress(wind_speed0(p), wsresp(t), tau_est(t), &
+                    tau(p), prev_tau(p), tau_diff(p), prev_tau_diff(p), &
+                    wind_speed_adj(p))
+               ur(p) = max(1.0_r8, wind_speed_adj(p) + ugust(t))
+            end if
 
             ! Bulk boundary layer resistance of leaves
-            uaf(f) = um(f)*sqrt( 1._r8/(ram1(p)*um(f)) )
+
+            uaf(p) = um(p)*sqrt( 1._r8/(ram1(p)*um(p)) )
 
             ! Use pft parameter for leaf characteristic width
             ! dleaf_patch if this is not an ed patch.
@@ -774,9 +802,9 @@ contains
             end if
 
 
-            cf  = 0.01_r8/(sqrt(uaf(f))*sqrt( dleaf_patch(p) ))
-            rb(f)  = 1._r8/(cf*uaf(f))
-            rb1(p) = rb(f) !NOTE: this doesn't need to be updated every iteration
+            cf  = 0.01_r8/(sqrt(uaf(p))*sqrt( dleaf_patch(p) ))
+            rb(p)  = 1._r8/(cf*uaf(p))
+            rb1(p) = rb(p)
 
             ! Parameterization for variation of csoilc with canopy density from
             ! X. Zeng, University of Arizona
@@ -786,15 +814,15 @@ contains
             ! changed by K.Sakaguchi from here
             ! transfer coefficient over bare soil is changed to a local variable
             ! just for readability of the code (from line 680)
-            csoilb = (vkc/(0.13_r8*(z0mg(c)*uaf(f)/1.5e-5_r8)**0.45_r8))
+            csoilb = (vkc/(0.13_r8*(z0mg(c)*uaf(p)/1.5e-5_r8)**0.45_r8))
 
             !compute the stability parameter for ricsoilc  ("S" in Sakaguchi&Zeng,2008)
 
-            ri = ( grav*htop(p) * (taf(f) - t_grnd(c)) ) / (taf(f) * uaf(f) **2.00_r8)
+            ri = ( grav*htop(p) * (taf(p) - t_grnd(c)) ) / (taf(p) * uaf(p) **2.00_r8)
 
             !! modify csoilc value (0.004) if the under-canopy is in stable condition
 
-            if ( (taf(f) - t_grnd(c) ) > 0._r8) then
+            if ( (taf(p) - t_grnd(c) ) > 0._r8) then
                ! decrease the value of csoilc by dividing it with (1+gamma*min(S, 10.0))
                ! ria ("gmanna" in Sakaguchi&Zeng, 2008) is a constant (=0.5)
                ricsoilc = csoilc / (1.00_r8 + ria*min( ri, 10.0_r8) )
@@ -805,18 +833,19 @@ contains
 
             !! Sakaguchi changes for stability formulation ends here
 
-            rah(f,2) = 1._r8/(csoilcn*uaf(f))
-            raw(f,2) = rah(f,2)
+            rah(p,2) = 1._r8/(csoilcn*uaf(p))
+            raw(p,2) = rah(p,2)
             if (use_lch4) then
-               grnd_ch4_cond(p) = 1._r8/(raw(f,1)+raw(f,2))
+               grnd_ch4_cond(p) = 1._r8/(raw(p,1)+raw(p,2))
             end if
 
             ! Stomatal resistances for sunlit and shaded fractions of canopy.
             ! Done each iteration to account for differences in eah, tv.
 
-            svpts(f) = el(f)                         ! pa
-            eah(f) = forc_pbot(t) * qaf(f) / 0.622_r8   ! pa
-            rhaf(p) = eah(f)/svpts(f)
+            svpts(p) = el(p)                         ! pa
+            eah(p) = forc_pbot(t) * qaf(p) / 0.622_r8   ! pa
+            rhaf(p) = eah(p)/svpts(p)
+         end do
 
          ! Modification for shrubs proposed by X.D.Z
          ! Equivalent modification for soy following AgroIBIS
@@ -827,52 +856,47 @@ contains
          ! BUG MV 4/7/2014 - is this the correct place to have it in the iteration?
          ! THIS SHOULD BE MOVED OUT OF THE ITERATION but will change answers -
 
+         do f = 1, fn
+            p = filterp(f)
+            c = veg_pp%column(p)
             if(.not.veg_pp%is_fates(p)) then
                if (veg_pp%itype(p) == nsoybean .or. veg_pp%itype(p) == nsoybeanirrig) then
+
                   btran(p) = min(1._r8, btran(p) * 1.25_r8)
                end if
             end if
-
-        end do
+         end do
 
 
          if ( use_fates ) then
-               ! #ifndef _OPENACC
-               !             call alm_fates%wrap_photosynthesis(bounds, fn, filterp(1:fn), &
-               !                   svpts(begp:endp), eah(begp:endp), o2(begp:endp), &
-               !                   co2(begp:endp), rb(begp:endp), dayl_factor(begp:endp), &
-               !                   atm2lnd_vars, temperature_vars, canopystate_vars, photosyns_vars)
-               ! #endif
+#ifndef _OPENACC
+            call alm_fates%wrap_photosynthesis(bounds, fn, filterp(1:fn), &
+                  svpts(begp:endp), eah(begp:endp), o2(begp:endp), &
+                  co2(begp:endp), rb(begp:endp), dayl_factor(begp:endp), &
+                  atm2lnd_vars, temperature_vars, canopystate_vars, photosyns_vars)
+#endif
          else ! not use_fates
 
             if ( use_hydrstress ) then
-               ! call PhotosynthesisHydraulicStress (bounds, fn, filterp, &
-               !      svpts(begp:endp), eah(begp:endp), o2(begp:endp), co2(begp:endp), rb(begp:endp), bsun(begp:endp), &
-               !      bsha(begp:endp), btran(begp:endp), dayl_factor(begp:endp), &
-               !      qsatl(begp:endp), qaf(begp:endp),     &
-               !      atm2lnd_vars, soilstate_vars, surfalb_vars, solarabs_vars,    &
-               !      canopystate_vars, photosyns_vars)
+               call PhotosynthesisHydraulicStress (bounds, fn, filterp, &
+                    svpts(begp:endp), eah(begp:endp), o2(begp:endp), co2(begp:endp), rb(begp:endp), bsun(begp:endp), &
+                    bsha(begp:endp), btran(begp:endp), dayl_factor(begp:endp), &
+                    qsatl(begp:endp), qaf(begp:endp),     &
+                    atm2lnd_vars, soilstate_vars, surfalb_vars, solarabs_vars,    &
+                    canopystate_vars, photosyns_vars)
             else
-              call Photosynthesis(bounds,num_nolu_vegp,filterp,converged(1:num_nolu_vegp),&
-                        svpts(1:num_nolu_vegp), eah(1:num_nolu_vegp),o2(1:num_nolu_vegp),&
-                        co2(1:num_nolu_vegp), rb(1:num_nolu_vegp), btran(begp:endp), dayl_factor(1:num_nolu_vegp),&
-                        surfalb_vars, solarabs_vars, canopystate_vars, photosyns_vars, 'sun', &
-                        solarabs_vars%parsun_z_patch(begp:endp,:),  canopystate_vars%laisun_z_patch(begp:endp,:), &
-                        surfalb_vars%vcmaxcintsun_patch(begp:endp),  photosyns_vars%alphapsnsun_patch(begp:endp), &
-                        photosyns_vars%cisun_z_patch(begp:endp,:), photosyns_vars%rssun_patch(begp:endp), &
-                        photosyns_vars%rssun_z_patch(begp:endp,:), photosyns_vars%lmrsun_patch(begp:endp), &
-                        photosyns_vars%lmrsun_z_patch(begp:endp,:), photosyns_vars%psnsun_patch(begp:endp), &
-                        photosyns_vars%psnsun_z_patch(begp:endp,:),photosyns_vars%psnsun_wc_patch(begp:endp), &
-                        photosyns_vars%psnsun_wj_patch(begp:endp),photosyns_vars%psnsun_wp_patch(begp:endp)   )
-
+               call Photosynthesis (bounds, fn, filterp, &
+                        svpts(begp:endp), eah(begp:endp), o2(begp:endp), co2(begp:endp), rb(begp:endp), btran(begp:endp), &
+                        dayl_factor(begp:endp), atm2lnd_vars,  surfalb_vars, solarabs_vars, &
+                        canopystate_vars, photosyns_vars, 'sun')
             end if
 
             if ( use_c13 ) then
                call Fractionation (bounds, fn, filterp, &
-                     cnstate_vars, solarabs_vars, surfalb_vars, photosyns_vars, 1)
+                     cnstate_vars, solarabs_vars, surfalb_vars, photosyns_vars, &
+                    1)
             endif
 
-            !$acc parallel loop independent gang vector default(present) private(p,c)
             do f = 1, fn
                p = filterp(f)
                c = veg_pp%column(p)
@@ -882,32 +906,22 @@ contains
             end do
 
             if ( .not. use_hydrstress ) then
-               call Photosynthesis(bounds,fn,filterp,converged, &
-                        svpts(1:num_nolu_vegp), eah(1:num_nolu_vegp),o2(1:num_nolu_vegp),&
-                        co2(1:num_nolu_vegp),rb(1:num_nolu_vegp), btran(begp:endp), dayl_factor(1:num_nolu_vegp),&
-                        surfalb_vars, solarabs_vars, canopystate_vars, photosyns_vars, 'sha', &
-                        solarabs_vars%parsha_z_patch(begp:endp,:), canopystate_vars%laisha_z_patch(begp:endp,:), &
-                        surfalb_vars%vcmaxcintsha_patch(begp:endp), photosyns_vars%alphapsnsha_patch(begp:endp), &
-                        photosyns_vars%cisha_z_patch(begp:endp,:),photosyns_vars%rssha_patch(begp:endp), &
-                        photosyns_vars%rssha_z_patch(begp:endp,:),photosyns_vars%lmrsha_patch(begp:endp), &
-                        photosyns_vars%lmrsha_z_patch(begp:endp,:),photosyns_vars%psnsha_patch(begp:endp),&
-                        photosyns_vars%psnsha_z_patch(begp:endp,:),photosyns_vars%psnsha_wc_patch(begp:endp),&
-                        photosyns_vars%psnsha_wj_patch(begp:endp),photosyns_vars%psnsha_wp_patch(begp:endp)   )
-
+              call Photosynthesis (bounds, fn, filterp, &
+                   svpts(begp:endp), eah(begp:endp), o2(begp:endp), co2(begp:endp), rb(begp:endp), btran(begp:endp), &
+                   dayl_factor(begp:endp), atm2lnd_vars,surfalb_vars, solarabs_vars, &
+                   canopystate_vars, photosyns_vars, 'sha')
             end if
 
+
             if ( use_c13 ) then
                call Fractionation (bounds, fn, filterp,  &
-                     cnstate_vars, solarabs_vars, surfalb_vars, photosyns_vars, 0)
+                     cnstate_vars, solarabs_vars, surfalb_vars, photosyns_vars, &
+                    0)
             end if
 
          end if ! end of if use_fates
 
-         !$acc parallel loop independent gang vector default(present) present(laisun(:),&
-         !$acc  thm(:), canopy_cond(:),temp2(:), frac_veg_nosno(:), esai(:), fdry(:), wta0(:), h2ocan(:), &
-         !$acc  laisha(:),rssha(:),btran(:), fwet(:), qflx_evap_veg(:), qflx_tran_veg(:),sabv(:), eflx_sh_veg(:) )
          do f = 1, fn
-            if(converged(f)) cycle 
             p = filterp(f)
             c = veg_pp%column(p)
             t = veg_pp%topounit(p)
@@ -916,32 +930,32 @@ contains
             ! Sensible heat conductance for air, leaf and ground
             ! Moved the original subroutine in-line...
 
-            wta    = 1._r8/rah(f,1)             ! air
-            wtl    = (elai(p)+esai(p))/rb(f)    ! leaf
-            wtg(f) = 1._r8/rah(f,2)             ! ground
-            wtshi  = 1._r8/(wta+wtl+wtg(f))
-            wtl0(f) = wtl*wtshi         ! leaf
-            wtg0    = wtg(f)*wtshi      ! ground
-            wta0(f) = wta*wtshi         ! air
+            wta    = 1._r8/rah(p,1)             ! air
+            wtl    = (elai(p)+esai(p))/rb(p)    ! leaf
+            wtg(p) = 1._r8/rah(p,2)             ! ground
+            wtshi  = 1._r8/(wta+wtl+wtg(p))
+            wtl0(p) = wtl*wtshi         ! leaf
+            wtg0    = wtg(p)*wtshi      ! ground
+            wta0(p) = wta*wtshi         ! air
 
-            wtga    = wta0(f)+wtg0      ! ground + air
-            wtal(f) = wta0(f)+wtl0(f)   ! air + leaf
+            wtga    = wta0(p)+wtg0      ! ground + air
+            wtal(p) = wta0(p)+wtl0(p)   ! air + leaf
 
             ! Fraction of potential evaporation from leaf
 
             if (fdry(p) > 0._r8) then
-               rppdry  = fdry(p)*rb(f)*(laisun(p)/(rb(f)+rssun(p)) + &
-                    laisha(p)/(rb(f)+rssha(p)))/elai(p)
+               rppdry  = fdry(p)*rb(p)*(laisun(p)/(rb(p)+rssun(p)) + &
+                    laisha(p)/(rb(p)+rssha(p)))/elai(p)
             else
                rppdry = 0._r8
             end if
 
             ! Calculate canopy conductance for methane / oxygen (e.g. stomatal conductance & leaf bdy cond)
             if (use_lch4) then
-               canopy_cond(p) = (laisun(p)/(rb(f)+rssun(p)) + laisha(p)/(rb(f)+rssha(p)))/max(elai(p), 0.01_r8)
+               canopy_cond(p) = (laisun(p)/(rb(p)+rssun(p)) + laisha(p)/(rb(p)+rssha(p)))/max(elai(p), 0.01_r8)
             end if
 
-            efpot = forc_rho(t)*wtl*(qsatl(f)-qaf(f))
+            efpot = forc_rho(t)*wtl*(qsatl(p)-qaf(p))
             ! When the hydraulic stress parameterization is active calculate rpp
             ! but not transpiration
             if ( use_hydrstress ) then
@@ -952,7 +966,7 @@ contains
                    rpp = fwet(p)
                  end if
                  !Check total evapotranspiration from leaves
-                 rpp = min(rpp, (qflx_tran_veg(p)+h2ocan(p)/dtime_mod)/efpot)
+                 rpp = min(rpp, (qflx_tran_veg(p)+h2ocan(p)/dtime)/efpot)
               else
                  rpp = 1._r8
               end if
@@ -968,7 +982,7 @@ contains
                   qflx_tran_veg(p) = 0._r8
                end if
                !Check total evapotranspiration from leaves
-               rpp = min(rpp, (qflx_tran_veg(p)+h2ocan(p)/dtime_mod)/efpot)
+               rpp = min(rpp, (qflx_tran_veg(p)+h2ocan(p)/dtime)/efpot)
               else
                !No transpiration if potential evaporation less than zero
                rpp = 1._r8
@@ -980,66 +994,66 @@ contains
             ! Air has same conductance for both sensible and latent heat.
             ! Moved the original subroutine in-line...
 
-            wtaq    = frac_veg_nosno(p)/raw(f,1)                        ! air
-            wtlq    = frac_veg_nosno(p)*(elai(p)+esai(p))/rb(f) * rpp   ! leaf
+            wtaq    = frac_veg_nosno(p)/raw(p,1)                        ! air
+            wtlq    = frac_veg_nosno(p)*(elai(p)+esai(p))/rb(p) * rpp   ! leaf
 
             !Litter layer resistance. Added by K.Sakaguchi
             snow_depth_c = z_dl ! critical depth for 100% litter burial by snow (=litter thickness)
             fsno_dl = snow_depth(c)/snow_depth_c    ! effective snow cover for (dry)plant litter
             elai_dl = lai_dl*(1._r8 - min(fsno_dl,1._r8)) ! exposed (dry)litter area index
-            rdl = ( 1._r8 - exp(-elai_dl) ) / ( 0.004_r8*uaf(f)) ! dry litter layer resistance
+            rdl = ( 1._r8 - exp(-elai_dl) ) / ( 0.004_r8*uaf(p)) ! dry litter layer resistance
 
             ! add litter resistance and Lee and Pielke 1992 beta
-            if (delq(f) < 0._r8) then  !dew. Do not apply beta for negative flux (follow old rsoil)
-               wtgq(f) = frac_veg_nosno(p)/(raw(f,2)+rdl)
+            if (delq(p) < 0._r8) then  !dew. Do not apply beta for negative flux (follow old rsoil)
+               wtgq(p) = frac_veg_nosno(p)/(raw(p,2)+rdl)
             else
                if (do_soilevap_beta()) then
-                  wtgq(f) = soilbeta(c)*frac_veg_nosno(p)/(raw(f,2)+rdl)
+                  wtgq(p) = soilbeta(c)*frac_veg_nosno(p)/(raw(p,2)+rdl)
                endif
             end if
 
-            wtsqi   = 1._r8/(wtaq+wtlq+wtgq(f))
+            wtsqi   = 1._r8/(wtaq+wtlq+wtgq(p))
 
-            wtgq0    = wtgq(f)*wtsqi      ! ground
-            wtlq0(f) = wtlq*wtsqi         ! leaf
-            wtaq0(f) = wtaq*wtsqi         ! air
+            wtgq0    = wtgq(p)*wtsqi      ! ground
+            wtlq0(p) = wtlq*wtsqi         ! leaf
+            wtaq0(p) = wtaq*wtsqi         ! air
 
-            wtgaq    = wtaq0(f)+wtgq0     ! air + ground
-            wtalq(f) = wtaq0(f)+wtlq0(f)  ! air + leaf
+            wtgaq    = wtaq0(p)+wtgq0     ! air + ground
+            wtalq(p) = wtaq0(p)+wtlq0(p)  ! air + leaf
 
             dc1 = forc_rho(t)*cpair*wtl
             dc2 = hvap*forc_rho(t)*wtlq
 
-            efsh   = dc1*(wtga*t_veg(p)-wtg0*t_grnd(c)-wta0(f)*thm(p))
-            efe(f) = dc2*(wtgaq*qsatl(f)-wtgq0*qg(c)-wtaq0(f)*forc_q(t))
+            efsh   = dc1*(wtga*t_veg(p)-wtg0*t_grnd(c)-wta0(p)*thm(p))
+            efe(p) = dc2*(wtgaq*qsatl(p)-wtgq0*qg(c)-wtaq0(p)*forc_q(t))
 
             ! Evaporation flux from foliage
 
             erre = 0._r8
-            if (efe(f)*efeb(f) < 0._r8) then
-               efeold = efe(f)
-               efe(f)  = 0.1_r8*efeold
-               erre = efe(f) - efeold
+            if (efe(p)*efeb(p) < 0._r8) then
+               efeold = efe(p)
+               efe(p)  = 0.1_r8*efeold
+               erre = efe(p) - efeold
             end if
             ! fractionate ground emitted longwave
             lw_grnd=(frac_sno(c)*t_soisno(c,snl(c)+1)**4 &
                  +(1._r8-frac_sno(c)-frac_h2osfc(c))*t_soisno(c,1)**4 &
                  +frac_h2osfc(c)*t_h2osfc(c)**4)
 
-            dt_veg(f) = (sabv(p) + air(f) + bir(f)*t_veg(p)**4 + &
-                 cir(f)*lw_grnd - efsh - efe(f)) / &
-                 (- 4._r8*bir(f)*t_veg(p)**3 +dc1*wtga +dc2*wtgaq*qsatldT(f))
-            t_veg(p) = tlbef(f) + dt_veg(f)
-            dels = dt_veg(f)
-            del(f)  = abs(dels)
-            err(f) = 0._r8
-            if (del(f) > delmax) then
-               dt_veg(f) = delmax*dels/del(f)
-               t_veg(p) = tlbef(f) + dt_veg(f)
-               err(f) = sabv(p) + air(f) + bir(f)*tlbef(f)**3*(tlbef(f) + &
-                    4._r8*dt_veg(f)) + cir(f)*lw_grnd - &
-                    (efsh + dc1*wtga*dt_veg(f)) - (efe(f) + &
-                    dc2*wtgaq*qsatldT(f)*dt_veg(f))
+            dt_veg(p) = (sabv(p) + air(p) + bir(p)*t_veg(p)**4 + &
+                 cir(p)*lw_grnd - efsh - efe(p)) / &
+                 (- 4._r8*bir(p)*t_veg(p)**3 +dc1*wtga +dc2*wtgaq*qsatldT(p))
+            t_veg(p) = tlbef(p) + dt_veg(p)
+            dels = dt_veg(p)
+            del(p)  = abs(dels)
+            err(p) = 0._r8
+            if (del(p) > delmax) then
+               dt_veg(p) = delmax*dels/del(p)
+               t_veg(p) = tlbef(p) + dt_veg(p)
+               err(p) = sabv(p) + air(p) + bir(p)*tlbef(p)**3*(tlbef(p) + &
+                    4._r8*dt_veg(p)) + cir(p)*lw_grnd - &
+                    (efsh + dc1*wtga*dt_veg(p)) - (efe(p) + &
+                    dc2*wtgaq*qsatldT(p)*dt_veg(p))
             end if
 
             ! Fluxes from leaves to canopy space
@@ -1047,8 +1061,8 @@ contains
             ! result in an imbalance in "hvap*qflx_evap_veg" and
             ! "efe + dc2*wtgaq*qsatdt_veg"
 
-            efpot = forc_rho(t)*wtl*(wtgaq*(qsatl(f)+qsatldT(f)*dt_veg(f)) &
-                 -wtgq0*qg(c)-wtaq0(f)*forc_q(t))
+            efpot = forc_rho(t)*wtl*(wtgaq*(qsatl(p)+qsatldT(p)*dt_veg(p)) &
+                 -wtgq0*qg(c)-wtaq0(p)*forc_q(t))
             qflx_evap_veg(p) = rpp*efpot
 
             ! Calculation of evaporative potentials (efpot) and
@@ -1057,8 +1071,8 @@ contains
             ! during the timestep.  This energy is later added to the
             ! sensible heat flux.
             if ( use_hydrstress ) then
-               ecidif = max(0._r8,qflx_evap_veg(p)-qflx_tran_veg(p)-h2ocan(p)/dtime_mod)
-               qflx_evap_veg(p) = min(qflx_evap_veg(p),qflx_tran_veg(p)+h2ocan(p)/dtime_mod)
+               ecidif = max(0._r8,qflx_evap_veg(p)-qflx_tran_veg(p)-h2ocan(p)/dtime)
+               qflx_evap_veg(p) = min(qflx_evap_veg(p),qflx_tran_veg(p)+h2ocan(p)/dtime)
             else
 
               ecidif = 0._r8
@@ -1067,89 +1081,91 @@ contains
               else
                qflx_tran_veg(p) = 0._r8
               end if
-              ecidif = max(0._r8, qflx_evap_veg(p)-qflx_tran_veg(p)-h2ocan(p)/dtime_mod)
-              qflx_evap_veg(p) = min(qflx_evap_veg(p),qflx_tran_veg(p)+h2ocan(p)/dtime_mod)
+              ecidif = max(0._r8, qflx_evap_veg(p)-qflx_tran_veg(p)-h2ocan(p)/dtime)
+              qflx_evap_veg(p) = min(qflx_evap_veg(p),qflx_tran_veg(p)+h2ocan(p)/dtime)
             end if
 
             ! The energy loss due to above two limits is added to
             ! the sensible heat flux.
-            eflx_sh_veg(p) = efsh + dc1*wtga*dt_veg(f) + err(f) + erre + hvap*ecidif
+            eflx_sh_veg(p) = efsh + dc1*wtga*dt_veg(p) + err(p) + erre + hvap*ecidif
 
             ! Re-calculate saturated vapor pressure, specific humidity, and their
             ! derivatives at the leaf surface
 
-            call QSat(t_veg(p), forc_pbot(t), el(f), deldT, qsatl(f), qsatldT(f))
+            call QSat(t_veg(p), forc_pbot(t), el(p), deldT, qsatl(p), qsatldT(p))
 
             ! Update vegetation/ground surface temperature, canopy air
             ! temperature, canopy vapor pressure, aerodynamic temperature, and
             ! Monin-Obukhov stability parameter for next iteration.
 
-            taf(f) = wtg0*t_grnd(c) + wta0(f)*thm(p) + wtl0(f)*t_veg(p)
-            qaf(f) = wtlq0(f)*qsatl(f) + wtgq0*qg(c) + forc_q(t)*wtaq0(f)
+            taf(p) = wtg0*t_grnd(c) + wta0(p)*thm(p) + wtl0(p)*t_veg(p)
+            qaf(p) = wtlq0(p)*qsatl(p) + wtgq0*qg(c) + forc_q(t)*wtaq0(p)
 
             ! Update Monin-Obukhov length and wind speed including the
             ! stability effect
 
-            dth(f) = thm(p)-taf(f)
-            dqh(f) = forc_q(t)-qaf(f)
-            delq(f) = wtalq(f)*qg(c)-wtlq0(f)*qsatl(f)-wtaq0(f)*forc_q(t)
+            dth(p) = thm(p)-taf(p)
+            dqh(p) = forc_q(t)-qaf(p)
+            delq(p) = wtalq(p)*qg(c)-wtlq0(p)*qsatl(p)-wtaq0(p)*forc_q(t)
 
-            tstar = temp1(f)*dth(f)
-            qstar = temp2(f)*dqh(f)
+            tstar = temp1(p)*dth(p)
+            qstar = temp2(p)*dqh(p)
 
             thvstar = tstar*(1._r8+0.61_r8*forc_q(t)) + 0.61_r8*forc_th(t)*qstar
-            zeta = zldis(f)*vkc*grav*thvstar/(ustar(f)**2*thv(c))
+            zeta = zldis(p)*vkc*grav*thvstar/(ustar(p)**2*thv(c))
 
             if (zeta >= 0._r8) then     !stable
                zeta = min(2._r8,max(zeta,0.01_r8))
-               um(f) = max(ur(f),0.1_r8)
+               um(p) = max(ur(p),0.1_r8)
             else                     !unstable
                zeta = max(-100._r8,min(zeta,-0.01_r8))
-               wc = beta*(-grav*ustar(f)*thvstar*zii/thv(c))**0.333_r8
-               um(f) = sqrt(ur(f)*ur(f)+wc*wc)
+               wc = beta*(-grav*ustar(p)*thvstar*zii/thv(c))**0.333_r8
+               um(p) = sqrt(ur(p)*ur(p)+wc*wc)
             end if
-            obu(f) = zldis(f)/zeta
+            obu(p) = zldis(p)/zeta
 
-            if (obuold(f)*obu(f) < 0._r8) nmozsgn(f) = nmozsgn(f)+1
-            if (nmozsgn(f) >= 4) obu(f) = zldis(f)/(-0.01_r8)
-            obuold(f) = obu(f)
+            if (obuold(p)*obu(p) < 0._r8) nmozsgn(p) = nmozsgn(p)+1
+            if (nmozsgn(p) >= 4) obu(p) = zldis(p)/(-0.01_r8)
+            obuold(p) = obu(p)
 
          end do   ! end of filtered pft loop
 
-         !$acc parallel loop independent gang vector default(present) private(p,t)
          do f = 1, fn
-           if(converged(f)) cycle 
            p = filterp(f)
            t = veg_pp%topounit(p)
-           !laminar boundary resistance for h2o over leaf, should I make this consistent for latent heat calculation?
-           lbl_rsc_h2o(p) = getlblcef(forc_rho(t),t_veg(p))*uaf(f)/(uaf(f)**2._r8+1.e-10_r8)   
+           lbl_rsc_h2o(p) = getlblcef(forc_rho(t),t_veg(p))*uaf(p)/(uaf(p)**2._r8+1.e-10_r8)   !laminar boundary resistance for h2o over leaf, should I make this consistent for latent heat calculation?
          enddo
 
          ! Test for convergence
+         iter_final = itlef
          itlef = itlef+1
          if (itlef > itmin) then
-            fnold = 0 
-            num_unconverged = 0 
-            !$acc parallel loop independent gang vector default(present) private(p) present(det(1:fn), dele(1:fn)) &
-            !$acc   copy(num_unconverged) reduction(+:num_unconverged) 
             do f = 1, fn
-               if(converged(f)) cycle   
                p = filterp(f)
-               dele(f) = abs(efe(f) - efeb(f))
-               efeb(f) = efe(f)
-               det(f)  = max(del(f),del2(f))
-               if((det(f) < dtmin .and. dele(f) < dlemin)) then 
-                  converged(f) = 1
-               else
-                 num_unconverged = num_unconverged + 1  
-               end if 
+               dele(p) = abs(efe(p)-efeb(p))
+               efeb(p) = efe(p)
+               det(p)  = max(del(p),del2(p))
+            end do
+            fnold = fn
+            fn = 0
+            do f = 1, fnold
+               p = filterp(f)
+               if (.not. (det(p) < dtmin .and. dele(p) < dlemin) .or. &
+                    (implicit_stress .and. abs(tau_diff(p)) >= dtaumin)) then
+                  fn = fn + 1
+                  filterp(fn) = p
+               end if
             end do
          end if
+
       end do ITERATION     ! End stability iteration
-      
-      !$acc parallel loop independent gang vector default(present)
-      do f = 1, num_nolu_vegp
-         p = filter_nolu_vegp(f)
+      call t_stop_lnd(event)
+
+      fn = fnorig
+      filterp(1:fn) = fporig(1:fn)
+
+      do f = 1, fn
+         p = filterp(f)
          c = veg_pp%column(p)
          t = veg_pp%topounit(p)
          g = veg_pp%gridcell(p)
@@ -1160,45 +1176,50 @@ contains
               +(1._r8-frac_sno(c)-frac_h2osfc(c))*t_soisno(c,1)**4 &
               +frac_h2osfc(c)*t_h2osfc(c)**4)
 
-         err(f) = sabv(p) + air(f) + bir(f)*tlbef(f)**3*(tlbef(f) + 4._r8*dt_veg(f)) &
-              + cir(f)*lw_grnd - eflx_sh_veg(p) - hvap*qflx_evap_veg(p)
+         err(p) = sabv(p) + air(p) + bir(p)*tlbef(p)**3*(tlbef(p) + 4._r8*dt_veg(p)) &
+                                !+ cir(p)*t_grnd(c)**4 - eflx_sh_veg(p) - hvap*qflx_evap_veg(p)
+              + cir(p)*lw_grnd - eflx_sh_veg(p) - hvap*qflx_evap_veg(p)
 
          ! Fluxes from ground to canopy space
 
-         delt    = wtal(f)*t_grnd(c)-wtl0(f)*t_veg(p)-wta0(f)*thm(p)
+         delt    = wtal(p)*t_grnd(c)-wtl0(p)*t_veg(p)-wta0(p)*thm(p)
          taux(p) = -forc_rho(t)*forc_u(t)/ram1(p)
          tauy(p) = -forc_rho(t)*forc_v(t)/ram1(p)
-         eflx_sh_grnd(p) = cpair*forc_rho(t)*wtg(f)*delt
+         if (implicit_stress) then
+            taux(p) = taux(p) * (wind_speed_adj(p) / wind_speed0(p))
+            tauy(p) = tauy(p) * (wind_speed_adj(p) / wind_speed0(p))
+         end if
+         eflx_sh_grnd(p) = cpair*forc_rho(t)*wtg(p)*delt
 
          ! compute individual sensible heat fluxes
-         delt_snow = wtal(f)*t_soisno(c,snl(c)+1)-wtl0(f)*t_veg(p)-wta0(f)*thm(p)
-         eflx_sh_snow(p) = cpair*forc_rho(t)*wtg(f)*delt_snow
+         delt_snow = wtal(p)*t_soisno(c,snl(c)+1)-wtl0(p)*t_veg(p)-wta0(p)*thm(p)
+         eflx_sh_snow(p) = cpair*forc_rho(t)*wtg(p)*delt_snow
 
-         delt_soil  = wtal(f)*t_soisno(c,1)-wtl0(f)*t_veg(p)-wta0(f)*thm(p)
-         eflx_sh_soil(p) = cpair*forc_rho(t)*wtg(f)*delt_soil
+         delt_soil  = wtal(p)*t_soisno(c,1)-wtl0(p)*t_veg(p)-wta0(p)*thm(p)
+         eflx_sh_soil(p) = cpair*forc_rho(t)*wtg(p)*delt_soil
 
-         delt_h2osfc  = wtal(f)*t_h2osfc(c)-wtl0(f)*t_veg(p)-wta0(f)*thm(p)
-         eflx_sh_h2osfc(p) = cpair*forc_rho(t)*wtg(f)*delt_h2osfc
-         qflx_evap_soi(p) = forc_rho(t)*wtgq(f)*delq(f)
+         delt_h2osfc  = wtal(p)*t_h2osfc(c)-wtl0(p)*t_veg(p)-wta0(p)*thm(p)
+         eflx_sh_h2osfc(p) = cpair*forc_rho(t)*wtg(p)*delt_h2osfc
+         qflx_evap_soi(p) = forc_rho(t)*wtgq(p)*delq(p)
 
          ! compute individual latent heat fluxes
-         delq_snow = wtalq(f)*qg_snow(c)-wtlq0(f)*qsatl(f)-wtaq0(f)*forc_q(t)
-         qflx_ev_snow(p) = forc_rho(t)*wtgq(f)*delq_snow
+         delq_snow = wtalq(p)*qg_snow(c)-wtlq0(p)*qsatl(p)-wtaq0(p)*forc_q(t)
+         qflx_ev_snow(p) = forc_rho(t)*wtgq(p)*delq_snow
 
-         delq_soil = wtalq(f)*qg_soil(c)-wtlq0(f)*qsatl(f)-wtaq0(f)*forc_q(t)
-         qflx_ev_soil(p) = forc_rho(t)*wtgq(f)*delq_soil
+         delq_soil = wtalq(p)*qg_soil(c)-wtlq0(p)*qsatl(p)-wtaq0(p)*forc_q(t)
+         qflx_ev_soil(p) = forc_rho(t)*wtgq(p)*delq_soil
 
-         delq_h2osfc = wtalq(f)*qg_h2osfc(c)-wtlq0(f)*qsatl(f)-wtaq0(f)*forc_q(t)
-         qflx_ev_h2osfc(p) = forc_rho(t)*wtgq(f)*delq_h2osfc
+         delq_h2osfc = wtalq(p)*qg_h2osfc(c)-wtlq0(p)*qsatl(p)-wtaq0(p)*forc_q(t)
+         qflx_ev_h2osfc(p) = forc_rho(t)*wtgq(p)*delq_h2osfc
 
          ! 2 m height air temperature
 
-         t_ref2m(p) = thm(p) + temp1(f)*dth(f)*(1._r8/temp12m(f) - 1._r8/temp1(f))
+         t_ref2m(p) = thm(p) + temp1(p)*dth(p)*(1._r8/temp12m(p) - 1._r8/temp1(p))
          t_ref2m_r(p) = t_ref2m(p)
 
          ! 2 m height specific humidity
 
-         q_ref2m(p) = forc_q(t) + temp2(f)*dqh(f)*(1._r8/temp22m(f) - 1._r8/temp2(f))
+         q_ref2m(p) = forc_q(t) + temp2(p)*dqh(p)*(1._r8/temp22m(p) - 1._r8/temp2(p))
 
          ! 2 m height relative humidity
 
@@ -1209,72 +1230,71 @@ contains
          ! Downward longwave radiation below the canopy
 
          dlrad(p) = (1._r8-emv(p))*emg(c)*forc_lwrad(t) + &
-              emv(p)*emg(c)*sb*tlbef(f)**3*(tlbef(f) + 4._r8*dt_veg(f))
+              emv(p)*emg(c)*sb*tlbef(p)**3*(tlbef(p) + 4._r8*dt_veg(p))
 
          ! Upward longwave radiation above the canopy
 
          ulrad(p) = ((1._r8-emg(c))*(1._r8-emv(p))*(1._r8-emv(p))*forc_lwrad(t) &
-              + emv(p)*(1._r8+(1._r8-emg(c))*(1._r8-emv(p)))*sb*tlbef(f)**3*(tlbef(f) + &
-              4._r8*dt_veg(f)) + emg(c)*(1._r8-emv(p))*sb*lw_grnd)
+              + emv(p)*(1._r8+(1._r8-emg(c))*(1._r8-emv(p)))*sb*tlbef(p)**3*(tlbef(p) + &
+              4._r8*dt_veg(p)) + emg(c)*(1._r8-emv(p))*sb*lw_grnd)
 
          ! Derivative of soil energy flux with respect to soil temperature
 
-         cgrnds(p) = cgrnds(p) + cpair*forc_rho(t)*wtg(f)*wtal(f)
-         cgrndl(p) = cgrndl(p) + forc_rho(t)*wtgq(f)*wtalq(f)*dqgdT(c)
+         cgrnds(p) = cgrnds(p) + cpair*forc_rho(t)*wtg(p)*wtal(p)
+         cgrndl(p) = cgrndl(p) + forc_rho(t)*wtgq(p)*wtalq(p)*dqgdT(c)
          cgrnd(p)  = cgrnds(p) + cgrndl(p)*htvp(c)
 
          ! Update dew accumulation (kg/m2)
 
-         h2ocan(p) = max(0._r8,h2ocan(p)+(qflx_tran_veg(p)-qflx_evap_veg(p))*dtime_mod)
+         h2ocan(p) = max(0._r8,h2ocan(p)+(qflx_tran_veg(p)-qflx_evap_veg(p))*dtime)
+
+         ! Check for convergence of stress.
+         if (implicit_stress .and. abs(tau_diff(p)) > dtaumin) then
+            if (nstep_mod > 0) then ! Suppress common warnings on the first time step.
+               write(iulog,*)'WARNING: Stress did not converge for canopy ',&
+                    ' nstep = ',nstep_mod,' p= ',p,' prev_tau_diff= ',prev_tau_diff(p),&
+                    ' tau_diff= ',tau_diff(p),' tau= ',tau(p),&
+                    ' wind_speed_adj= ',wind_speed_adj(p),' iter_final= ',iter_final
+            end if
+         end if
 
       end do
 
       if ( use_fates ) then
 
-        !#py call alm_fates%wrap_accumulatefluxes(bounds,fn,filterp(1:fn))
-        !#py call alm_fates%wrap_hydraulics_drive(bounds,fn,filterp(1:fn),soilstate_vars, &
-        !#py                                     solarabs_vars,energyflux_vars)
+#ifndef _OPENACC
+        call alm_fates%wrap_accumulatefluxes(bounds,fn,filterp(1:fn))
+        call alm_fates%wrap_hydraulics_drive(bounds,fn,filterp(1:fn),soilstate_vars, &
+             solarabs_vars,energyflux_vars)
+#endif
       else
 
          ! Determine total photosynthesis
-         call PhotosynthesisTotal(num_nolu_vegp, filter_nolu_vegp, &
-               cnstate_vars, canopystate_vars, photosyns_vars)
+         call PhotosynthesisTotal(fn, filterp, &
+              atm2lnd_vars, cnstate_vars, canopystate_vars, photosyns_vars)
+
          ! Filter out patches which have small energy balance errors; report others
-         ! NOTE: filter out patches for what? This is the end of the subroutine.
-         fnold = num_nolu_vegp
+
+         fnold = fn
          fn = 0
-         !$acc parallel loop independent gang vector default(present) 
          do f = 1, fnold
             p = filterp(f)
-            if (abs(err(f)) > 0.1_r8) then
+            if (abs(err(p)) > 0.1_r8) then
                fn = fn + 1
                filterp(fn) = p
-               print *, 'energy balance in canopy ',p,', err=',err(f)
-               write(iulog,*) "sabv  :", sabv(p) 
-               write(iulog,*) "air   :",air(p)
-               write(iulog,*) "bir   :" ,bir(p)
-               write(iulog,*) "cir   :" ,cir(p)
-               write(iulog,*) "tlbef :",tlbef(p)
-               write(iulog,*) "dt_veg:",dt_veg(p) 
-               write(iulog,*) "eflx_sh_veg:",eflx_sh_veg(p) 
-               write(iulog,*) "qflx_evap_veg:",qflx_evap_veg(p)
             end if
          end do
 
+         do f = 1, fn
+            p = filterp(f)
+            write(iulog,*) 'energy balance in canopy ',p,', err=',err(p)
+         end do
+
       end if
-      !$acc exit data delete(del(:), efeb(:), wtlq0(:),wtalq(:), &
-      !$acc  wtgq(:), wtaq0(:), obuold(:),dayl_factor(:) , &
-      !$acc  check_for_irrig(:), filterp(:),zldis(:), &
-      !$acc  air(:),bir(:), cir(:), co2(:),o2(:),&
-      !$acc  nmozsgn(:), taf(:),qaf(:), ur(:),dth(:),dqh(:),delq(:), &
-      !$acc  dthv(:), obu(:),el(:),qsatl(:),qsatldT(:), &
-      !$acc  temp1(:), temp2(:),temp12m(:),&
-      !$acc  temp22m(:),ustar(:), um(:),rah(:,:),raw(:,:), uaf(:),rb(:), &
-      !$acc  tlbef(:), del(:),del2(:),svpts(:),eah(:),wta0(:), err(:), dt_veg(:) ,wtg(:), &
-      !$acc  wtal(:), wtl0(:), efe(:), det(:), dele(:), fm(:), converged(:)  )
-      !$acc exit data delete(time,irrig_nsteps_per_day, itlef) 
+
     end associate
 
+
   end subroutine CanopyFluxes
 
 end module CanopyFluxesMod
diff --git a/components/elm/src/biogeophys/CanopyHydrologyMod.F90 b/components/elm/src/biogeophys/CanopyHydrologyMod.F90
index b3af289d03..f3774e4822 100644
--- a/components/elm/src/biogeophys/CanopyHydrologyMod.F90
+++ b/components/elm/src/biogeophys/CanopyHydrologyMod.F90
@@ -12,7 +12,7 @@ module CanopyHydrologyMod
   ! !USES:
   use shr_kind_mod      , only : r8 => shr_kind_r8
   use shr_log_mod       , only : errMsg => shr_log_errMsg
-  use shr_infnan_mod    , only : isnan => shr_infnan_isnan
+  use shr_infnan_mod    , only : isnan => shr_infnan_isnan                                                        
   use shr_sys_mod       , only : shr_sys_flush
   use decompMod         , only : bounds_type
   use abortutils        , only : endrun
@@ -22,15 +22,14 @@ module CanopyHydrologyMod
   use AerosolType       , only : aerosol_type
   use CanopyStateType   , only : canopystate_type
   use TopounitDataType  , only : top_as, top_af ! Atmospheric state and flux variables
-  use ColumnType        , only : col_pp
-  use ColumnDataType    , only : col_es, col_ws, col_wf
+  use ColumnType        , only : col_pp 
+  use ColumnDataType    , only : col_es, col_ws, col_wf  
   use VegetationType    , only : veg_pp
-  use VegetationDataType, only : veg_ws, veg_wf
+  use VegetationDataType, only : veg_ws, veg_wf  
   use elm_varcon        , only : snw_rds_min
   use pftvarcon         , only : irrigated
   use GridcellType      , only : grc_pp
   use timeinfoMod, only : dtime_mod
-  use domainMod ,only : ldomain_gpu
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -42,12 +41,12 @@ module CanopyHydrologyMod
   !
   ! !PRIVATE MEMBER FUNCTIONS:
   private :: FracWet    ! Determine fraction of vegetated surface that is wet
-  private :: FracH2oSfc ! Determine fraction of land surfaces which are submerged
+  private :: FracH2oSfc ! Determine fraction of land surfaces which are submerged  
   !
   ! !PRIVATE DATA MEMBERS:
-  integer :: oldfflag=0  ! use old fsno parameterization (N&Y07)
+  integer :: oldfflag=0  ! use old fsno parameterization (N&Y07) 
   !-----------------------------------------------------------------------
-  !$acc declare copyin(oldfflag)
+
 contains
 
   !-----------------------------------------------------------------------
@@ -74,7 +73,7 @@ contains
     namelist / elm_canopyhydrology_inparm / oldfflag
 
     ! ----------------------------------------------------------------------
-    ! Read namelist from standard input.
+    ! Read namelist from standard input. 
     ! ----------------------------------------------------------------------
 
     if ( masterproc )then
@@ -112,7 +111,7 @@ contains
      ! (4) snow layer initialization if the snow accumulation exceeds 10 mm.
      ! Note:  The evaporation loss is taken off after the calculation of leaf
      ! temperature in the subroutine clm\_leaftem.f90, not in this subroutine.
-     !$acc routine seq
+     !
      ! !USES:
      use elm_varcon         , only : hfus, denice, zlnd, rpi, spval, tfrz
      use column_varcon      , only : icol_roof, icol_sunwall, icol_shadewall
@@ -121,12 +120,15 @@ contains
      use elm_varpar         , only : nlevsoi,nlevsno
      use elm_varsur         , only : wt_lunit
      use atm2lndType        , only : atm2lnd_type
+     use domainMod          , only : ldomain
      use TopounitType       , only : top_pp
+     use clm_time_manager   , only : get_step_size
      use subgridAveMod      , only : p2c,p2g
-     !use SnowHydrologyMod   , only : NewSnowBulkDensity
+     use clm_time_manager   , only : get_step_size, get_prev_date, get_nstep
+     use SnowHydrologyMod   , only : NewSnowBulkDensity
      !
      ! !ARGUMENTS:
-     type(bounds_type)      , intent(in)    :: bounds
+     type(bounds_type)      , intent(in)    :: bounds     
      integer                , intent(in)    :: num_nolakec          ! number of column non-lake points in column filter
      integer                , intent(in)    :: filter_nolakec(:)    ! column filter for non-lake points
      integer                , intent(in)    :: num_nolakep          ! number of pft non-lake points in pft filter
@@ -151,13 +153,13 @@ contains
      real(r8) :: xrun                                         ! excess water that exceeds the leaf capacity [mm/s]
      real(r8) :: dz_snowf                                     ! layer thickness rate change due to precipitation [mm/s]
      real(r8) :: bifall(bounds%begc:bounds%endc)              ! bulk density of newly fallen dry snow [kg/m3]
-     real(r8) :: fracsnow            ! frac of precipitation that is snow
-     real(r8) :: fracrain            ! frac of precipitation that is rain
-     real(r8) :: qflx_candrip        ! rate of canopy runoff and snow falling off canopy [mm/s]
-     real(r8) :: qflx_through_rain   ! direct rain throughfall [mm/s]
-     real(r8) :: qflx_through_snow   ! direct snow throughfall [mm/s]
-     real(r8) :: qflx_prec_grnd_snow ! snow precipitation incident on ground [mm/s]
-     real(r8) :: qflx_prec_grnd_rain ! rain precipitation incident on ground [mm/s]
+     real(r8) :: fracsnow(bounds%begp:bounds%endp)            ! frac of precipitation that is snow
+     real(r8) :: fracrain(bounds%begp:bounds%endp)            ! frac of precipitation that is rain
+     real(r8) :: qflx_candrip(bounds%begp:bounds%endp)        ! rate of canopy runoff and snow falling off canopy [mm/s]
+     real(r8) :: qflx_through_rain(bounds%begp:bounds%endp)   ! direct rain throughfall [mm/s]
+     real(r8) :: qflx_through_snow(bounds%begp:bounds%endp)   ! direct snow throughfall [mm/s]
+     real(r8) :: qflx_prec_grnd_snow(bounds%begp:bounds%endp) ! snow precipitation incident on ground [mm/s]
+     real(r8) :: qflx_prec_grnd_rain(bounds%begp:bounds%endp) ! rain precipitation incident on ground [mm/s]
      real(r8) :: z_avg                                        ! grid cell average snow depth
      real(r8) :: rho_avg                                      ! avg density of snow column
      real(r8) :: temp_snow_depth,temp_intsnow                 ! temporary variables
@@ -166,96 +168,96 @@ contains
      real(r8) :: delf_melt
      real(r8) :: fsno_new
      real(r8) :: accum_factor
-     real(r8) :: newsnow
-     real(r8) :: snowmelt
+     real(r8) :: newsnow(bounds%begc:bounds%endc)
+     real(r8) :: snowmelt(bounds%begc:bounds%endc)
      integer  :: j
-
+	 
      !--------------------------------------------------- ! initializing variables used to adjust irrigation on local processer
-     !real(r8) :: qflx_irrig_grid(bounds%begg:bounds%endg)      ! irrigation at grid level [mm/s]
-     real(r8) :: irrigated_ppg(bounds%begg:bounds%endg)        ! irrigated pft per grid
+     real(r8) :: qflx_irrig_grid(bounds%begg:bounds%endg)      ! irrigation at grid level [mm/s] 
+     integer :: irrigated_ppg(bounds%begg:bounds%endg)        ! irrigated pft per grid
      integer :: gg
      !-----------------------------------------------------------------------
 
-     associate(                                                     &
+     associate(                                                     & 
           pgridcell            => veg_pp%gridcell                             , & ! Input:  [integer  (:)   ]  pft's gridcell
           ptopounit            => veg_pp%topounit                             , & ! Input:  [integer  (:)   ]  pft's topounit
-          plandunit            => veg_pp%landunit                             , & ! Input:  [integer  (:)   ]  pft's landunit
-          pcolumn              => veg_pp%column                               , & ! Input:  [integer  (:)   ]  pft's column
+          plandunit            => veg_pp%landunit                             , & ! Input:  [integer  (:)   ]  pft's landunit                           
+          pcolumn              => veg_pp%column                               , & ! Input:  [integer  (:)   ]  pft's column                             
           pgwgt                => veg_pp%wtgcell                              , & ! Input:  [integer  (:)   ]  pft's weight in gridcell
-          ltype                => lun_pp%itype                                , & ! Input:  [integer  (:)   ]  landunit type
-          urbpoi               => lun_pp%urbpoi                               , & ! Input:  [logical  (:)   ]  true => landunit is an urban point
-          cgridcell            => col_pp%gridcell                             , & ! Input:  [integer  (:)   ]  columns's gridcell
-          clandunit            => col_pp%landunit                             , & ! Input:  [integer  (:)   ]  columns's landunit
-          ctype                => col_pp%itype                                , & ! Input:  [integer  (:)   ]  column type
-          pfti                 => col_pp%pfti                                 , & ! Input:  [integer  (:)   ]  column's beginning pft index
-          npfts                => col_pp%npfts                                , & ! Input:  [integer  (:)   ]  number of patches in column
-          snl                  => col_pp%snl                                  , & ! Input:  [integer  (:)   ]  number of snow layers
-          n_melt               => col_pp%n_melt                               , & ! Input:  [real(r8) (:)   ]  SCA shape parameter
-          zi                   => col_pp%zi                                   , & ! Output: [real(r8) (:,:) ]  interface level below a "z" level (m)
-          dz                   => col_pp%dz                                   , & ! Output: [real(r8) (:,:) ]  layer depth (m)
-          z                    => col_pp%z                                    , & ! Output: [real(r8) (:,:) ]  layer thickness (m)
-
-          forc_rain            => top_af%rain                              , & ! Input:  [real(r8) (:)   ]  rain rate (kg H2O/m**2/s, or mm liquid H2O/s)
-          forc_snow            => top_af%snow                              , & ! Input:  [real(r8) (:)   ]  snow rate (kg H2O/m**2/s, or mm liquid H2O/s)
-          forc_t               => top_as%tbot                              , & ! Input:  [real(r8) (:)   ]  atmospheric temperature (Kelvin)
+          ltype                => lun_pp%itype                                , & ! Input:  [integer  (:)   ]  landunit type                            
+          urbpoi               => lun_pp%urbpoi                               , & ! Input:  [logical  (:)   ]  true => landunit is an urban point       
+          cgridcell            => col_pp%gridcell                             , & ! Input:  [integer  (:)   ]  columns's gridcell                       
+          clandunit            => col_pp%landunit                             , & ! Input:  [integer  (:)   ]  columns's landunit                       
+          ctype                => col_pp%itype                                , & ! Input:  [integer  (:)   ]  column type                              
+          pfti                 => col_pp%pfti                                 , & ! Input:  [integer  (:)   ]  column's beginning pft index             
+          npfts                => col_pp%npfts                                , & ! Input:  [integer  (:)   ]  number of patches in column                 
+          snl                  => col_pp%snl                                  , & ! Input:  [integer  (:)   ]  number of snow layers                    
+          n_melt               => col_pp%n_melt                               , & ! Input:  [real(r8) (:)   ]  SCA shape parameter                     
+          zi                   => col_pp%zi                                   , & ! Output: [real(r8) (:,:) ]  interface level below a "z" level (m) 
+          dz                   => col_pp%dz                                   , & ! Output: [real(r8) (:,:) ]  layer depth (m)                       
+          z                    => col_pp%z                                    , & ! Output: [real(r8) (:,:) ]  layer thickness (m)                   
+
+          forc_rain            => top_af%rain                              , & ! Input:  [real(r8) (:)   ]  rain rate (kg H2O/m**2/s, or mm liquid H2O/s)                        
+          forc_snow            => top_af%snow                              , & ! Input:  [real(r8) (:)   ]  snow rate (kg H2O/m**2/s, or mm liquid H2O/s)                        
+          forc_t               => top_as%tbot                              , & ! Input:  [real(r8) (:)   ]  atmospheric temperature (Kelvin)        
           forc_wind            => top_as%windbot                           , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed (m/s)
-          qflx_floodg          => atm2lnd_vars%forc_flood_grc              , & ! Input:  [real(r8) (:)   ]  gridcell flux of flood water from RTM
+          qflx_floodg          => atm2lnd_vars%forc_flood_grc              , & ! Input:  [real(r8) (:)   ]  gridcell flux of flood water from RTM   
 
-          dewmx                => canopystate_vars%dewmx_patch             , & ! Input:  [real(r8) (:)   ]  Maximum allowed dew [mm]
+          dewmx                => canopystate_vars%dewmx_patch             , & ! Input:  [real(r8) (:)   ]  Maximum allowed dew [mm]                
           frac_veg_nosno       => canopystate_vars%frac_veg_nosno_patch    , & ! Input:  [integer  (:)   ]  fraction of vegetation not covered by snow (0 OR 1) [-]
           elai                 => canopystate_vars%elai_patch              , & ! Input:  [real(r8) (:)   ]  one-sided leaf area index with burying by snow
           esai                 => canopystate_vars%esai_patch              , & ! Input:  [real(r8) (:)   ]  one-sided stem area index with burying by snow
 
-          t_grnd               => col_es%t_grnd              , & ! Input:  [real(r8) (:)   ]  ground temperature (Kelvin)
-          t_soisno             => col_es%t_soisno            , & ! Output: [real(r8) (:,:) ]  soil temperature (Kelvin)
+          t_grnd               => col_es%t_grnd              , & ! Input:  [real(r8) (:)   ]  ground temperature (Kelvin)             
+          t_soisno             => col_es%t_soisno            , & ! Output: [real(r8) (:,:) ]  soil temperature (Kelvin)  
 
-          do_capsnow           => col_ws%do_capsnow           , & ! Output: [logical  (:)   ]  true => do snow capping
-          h2ocan               => veg_ws%h2ocan             , & ! Output: [real(r8) (:)   ]  total canopy water (mm H2O)
-          h2osfc               => col_ws%h2osfc               , & ! Output: [real(r8) (:)   ]  surface water (mm)
-          h2osno               => col_ws%h2osno               , & ! Output: [real(r8) (:)   ]  snow water (mm H2O)
-          snow_depth           => col_ws%snow_depth           , & ! Output: [real(r8) (:)   ]  snow height (m)
-          int_snow             => col_ws%int_snow             , & ! Output: [real(r8) (:)   ]  integrated snowfall [mm]
+          do_capsnow           => col_ws%do_capsnow           , & ! Output: [logical  (:)   ]  true => do snow capping                  
+          h2ocan               => veg_ws%h2ocan             , & ! Output: [real(r8) (:)   ]  total canopy water (mm H2O)             
+          h2osfc               => col_ws%h2osfc               , & ! Output: [real(r8) (:)   ]  surface water (mm)                      
+          h2osno               => col_ws%h2osno               , & ! Output: [real(r8) (:)   ]  snow water (mm H2O)                     
+          snow_depth           => col_ws%snow_depth           , & ! Output: [real(r8) (:)   ]  snow height (m)                         
+          int_snow             => col_ws%int_snow             , & ! Output: [real(r8) (:)   ]  integrated snowfall [mm]                
           frac_sno_eff         => col_ws%frac_sno_eff         , & ! Output: [real(r8) (:)   ]  eff. fraction of ground covered by snow (0 to 1)
           frac_sno             => col_ws%frac_sno             , & ! Output: [real(r8) (:)   ]  fraction of ground covered by snow (0 to 1)
           frac_h2osfc          => col_ws%frac_h2osfc          , & ! Output: [real(r8) (:)   ]  fraction of ground covered by surface water (0 to 1)
           frac_iceold          => col_ws%frac_iceold          , & ! Output: [real(r8) (:,:) ]  fraction of ice relative to the tot water
-          h2osoi_ice           => col_ws%h2osoi_ice           , & ! Output: [real(r8) (:,:) ]  ice lens (kg/m2)
-          h2osoi_liq           => col_ws%h2osoi_liq           , & ! Output: [real(r8) (:,:) ]  liquid water (kg/m2)
-          swe_old              => col_ws%swe_old              , & ! Output: [real(r8) (:,:) ]  snow water before update
+          h2osoi_ice           => col_ws%h2osoi_ice           , & ! Output: [real(r8) (:,:) ]  ice lens (kg/m2)                      
+          h2osoi_liq           => col_ws%h2osoi_liq           , & ! Output: [real(r8) (:,:) ]  liquid water (kg/m2)                  
+          swe_old              => col_ws%swe_old              , & ! Output: [real(r8) (:,:) ]  snow water before update              
 
           irrig_rate           => veg_wf%irrig_rate          , & ! Input:  [real(r8) (:)   ]  current irrigation rate (applied if n_irrig_steps_left > 0) [mm/s]
           n_irrig_steps_left   => veg_wf%n_irrig_steps_left  , & ! Output: [integer  (:)   ]  number of time steps for which we still need to irrigate today
-          qflx_floodc          => col_wf%qflx_floodc           , & ! Output: [real(r8) (:)   ]  column flux of flood water from RTM
-          qflx_snow_melt       => col_wf%qflx_snow_melt        , & ! Output: [real(r8) (:)   ]  snow melt from previous time step
-          qflx_snow_h2osfc     => col_wf%qflx_snow_h2osfc      , & ! Output: [real(r8) (:)   ]  snow falling on surface water (mm/s)
+          qflx_floodc          => col_wf%qflx_floodc           , & ! Output: [real(r8) (:)   ]  column flux of flood water from RTM     
+          qflx_snow_melt       => col_wf%qflx_snow_melt        , & ! Output: [real(r8) (:)   ]  snow melt from previous time step       
+          qflx_snow_h2osfc     => col_wf%qflx_snow_h2osfc      , & ! Output: [real(r8) (:)   ]  snow falling on surface water (mm/s)     
           qflx_snwcp_liq       => veg_wf%qflx_snwcp_liq      , & ! Output: [real(r8) (:)   ]  excess rainfall due to snow capping (mm H2O /s) [+]
           qflx_snwcp_ice       => veg_wf%qflx_snwcp_ice      , & ! Output: [real(r8) (:)   ]  excess snowfall due to snow capping (mm H2O /s) [+]
           qflx_snow_grnd_col   => col_wf%qflx_snow_grnd        , & ! Output: [real(r8) (:)   ]  snow on ground after interception (mm H2O/s) [+]
           qflx_snow_grnd_patch => veg_wf%qflx_snow_grnd      , & ! Output: [real(r8) (:)   ]  snow on ground after interception (mm H2O/s) [+]
-          qflx_prec_intr       => veg_wf%qflx_prec_intr      , & ! Output: [real(r8) (:)   ]  interception of precipitation [mm/s]
+          qflx_prec_intr       => veg_wf%qflx_prec_intr      , & ! Output: [real(r8) (:)   ]  interception of precipitation [mm/s]    
           qflx_prec_grnd       => veg_wf%qflx_prec_grnd      , & ! Output: [real(r8) (:)   ]  water onto ground including canopy runoff [kg/(m2 s)]
           qflx_rain_grnd       => veg_wf%qflx_rain_grnd      , & ! Output: [real(r8) (:)   ]  rain on ground after interception (mm H2O/s) [+]
-          qflx_dirct_rain      => veg_wf%qflx_dirct_rain     , & ! Output: [real(r8) (:)   ]  direct rain throughfall on ground (mm H2O/s)
+          qflx_dirct_rain      => veg_wf%qflx_dirct_rain     , & ! Output: [real(r8) (:)   ]  direct rain throughfall on ground (mm H2O/s) 
           qflx_leafdrip        => veg_wf%qflx_leafdrip       , & ! Output: [real(r8) (:)   ]  leap rain drip on ground (mm H2O/s)
-          qflx_irrig           => veg_wf%qflx_irrig_patch          , & ! Output: [real(r8) (:)   ]  total water demand or irrigation amount if one-way (mm/s)
-          qflx_real_irrig      => veg_wf%qflx_real_irrig_patch     , & ! Output: [real(r8) (:)   ]  actual irrigation amount (mm/s)
-          qflx_surf_irrig_col  => col_wf%qflx_surf_irrig       , & ! Output: [real(r8) (:)   ]  col real surface water irrigation flux (mm H2O /s)
-          qflx_grnd_irrig_col  => col_wf%qflx_grnd_irrig       , & ! Output: [real(r8) (:)   ]  col real groundwater irrigation flux (mm H2O /s)
-          qflx_over_supply_col => col_wf%qflx_over_supply      , & ! Output: [real(r8) (:)   ]  over supply irrigation flux (mm H2O /s)
-          qflx_supply          => veg_wf%qflx_supply_patch         , & ! Output: [real(r8) (:)   ]  irrigation supply (mm/s)
-          qflx_surf_irrig      => veg_wf%qflx_surf_irrig_patch     , & ! Output: [real(r8) (:)   ]  actual surface water irrigation (mm/s)
-          qflx_grnd_irrig      => veg_wf%qflx_grnd_irrig_patch     , & ! Output: [real(r8) (:)   ]  actual groundwater irrigation (mm/s)
-          qflx_over_supply     => veg_wf%qflx_over_supply_patch      & ! Output: [real(r8) (:)   ]  the portion of supply that exceed total demand (mm/s)
+          qflx_irrig           => veg_wf%qflx_irrig_patch          , & ! Output: [real(r8) (:)   ]  total water demand or irrigation amount if one-way (mm/s)      
+          qflx_real_irrig      => veg_wf%qflx_real_irrig_patch     , & ! Output: [real(r8) (:)   ]  actual irrigation amount (mm/s)      
+          qflx_surf_irrig_col  => col_wf%qflx_surf_irrig       , & ! Output: [real(r8) (:)   ]  col real surface water irrigation flux (mm H2O /s)  
+          qflx_grnd_irrig_col  => col_wf%qflx_grnd_irrig       , & ! Output: [real(r8) (:)   ]  col real groundwater irrigation flux (mm H2O /s)          
+          qflx_over_supply_col => col_wf%qflx_over_supply      , & ! Output: [real(r8) (:)   ]  over supply irrigation flux (mm H2O /s)          
+          qflx_supply          => veg_wf%qflx_supply_patch         , & ! Output: [real(r8) (:)   ]  irrigation supply (mm/s)      
+          qflx_surf_irrig      => veg_wf%qflx_surf_irrig_patch     , & ! Output: [real(r8) (:)   ]  actual surface water irrigation (mm/s)      
+          qflx_grnd_irrig      => veg_wf%qflx_grnd_irrig_patch     , & ! Output: [real(r8) (:)   ]  actual groundwater irrigation (mm/s)     
+          qflx_over_supply     => veg_wf%qflx_over_supply_patch      & ! Output: [real(r8) (:)   ]  the portion of supply that exceed total demand (mm/s)                 
           )
 
        ! Compute time step
-
-       dtime = dtime_mod
+       
+       dtime = get_step_size()
 
        do gg = bounds%begg,bounds%endg
           irrigated_ppg(gg) = 0
        end do
-
+         
        do f = 1, num_nolakep
           p = filter_nolakep(f)
           g = pgridcell(p)
@@ -279,12 +281,12 @@ contains
           if (ltype(l)==istsoil .or. ltype(l)==istwet .or. urbpoi(l) .or. &
                ltype(l)==istcrop) then
 
-             qflx_candrip = 0._r8      ! rate of canopy runoff
-             qflx_through_snow = 0._r8 ! rain precipitation direct through canopy
-             qflx_through_rain = 0._r8 ! snow precipitation direct through canopy
+             qflx_candrip(p) = 0._r8      ! rate of canopy runoff
+             qflx_through_snow(p) = 0._r8 ! rain precipitation direct through canopy
+             qflx_through_rain(p) = 0._r8 ! snow precipitation direct through canopy
              qflx_prec_intr(p) = 0._r8    ! total intercepted precipitation
-             fracsnow = 0._r8          ! fraction of input precip that is snow
-             fracrain = 0._r8          ! fraction of input precip that is rain
+             fracsnow(p) = 0._r8          ! fraction of input precip that is snow
+             fracrain(p) = 0._r8          ! fraction of input precip that is rain
 
 
              if (ctype(c) /= icol_sunwall .and. ctype(c) /= icol_shadewall) then
@@ -292,8 +294,8 @@ contains
                 if (frac_veg_nosno(p) == 1 .and. (forc_rain(t) + forc_snow(t)) > 0._r8) then
 
                    ! determine fraction of input precipitation that is snow and rain
-                   fracsnow = forc_snow(t)/(forc_snow(t) + forc_rain(t))
-                   fracrain = forc_rain(t)/(forc_snow(t) + forc_rain(t))
+                   fracsnow(p) = forc_snow(t)/(forc_snow(t) + forc_rain(t))
+                   fracrain(p) = forc_rain(t)/(forc_snow(t) + forc_rain(t))
 
                    ! The leaf water capacities for solid and liquid are different,
                    ! generally double for snow, but these are of somewhat less
@@ -307,8 +309,8 @@ contains
                    fpi = 0.25_r8*(1._r8 - exp(-0.5_r8*(elai(p) + esai(p))))
 
                    ! Direct throughfall
-                   qflx_through_snow = forc_snow(t) * (1._r8-fpi)
-                   qflx_through_rain = forc_rain(t) * (1._r8-fpi)
+                   qflx_through_snow(p) = forc_snow(t) * (1._r8-fpi)
+                   qflx_through_rain(p) = forc_rain(t) * (1._r8-fpi)
 
                    ! Intercepted precipitation [mm/s]
                    qflx_prec_intr(p) = (forc_snow(t) + forc_rain(t)) * fpi
@@ -317,7 +319,7 @@ contains
                    h2ocan(p) = max(0._r8, h2ocan(p) + dtime*qflx_prec_intr(p))
 
                    ! Initialize rate of canopy runoff and snow falling off canopy
-                   qflx_candrip = 0._r8
+                   qflx_candrip(p) = 0._r8
 
                    ! Excess water that exceeds the leaf capacity
                    xrun = (h2ocan(p) - h2ocanmx)/dtime
@@ -325,7 +327,7 @@ contains
                    ! Test on maximum dew on leaf
                    ! Note if xrun > 0 then h2ocan must be at least h2ocanmx
                    if (xrun > 0._r8) then
-                      qflx_candrip = xrun
+                      qflx_candrip(p) = xrun
                       h2ocan(p) = h2ocanmx
                    end if
 
@@ -335,12 +337,12 @@ contains
           else if (ltype(l)==istice .or. ltype(l)==istice_mec) then
 
              h2ocan(p)            = 0._r8
-             qflx_candrip      = 0._r8
-             qflx_through_snow = 0._r8
-             qflx_through_rain = 0._r8
+             qflx_candrip(p)      = 0._r8
+             qflx_through_snow(p) = 0._r8
+             qflx_through_rain(p) = 0._r8
              qflx_prec_intr(p)    = 0._r8
-             fracsnow          = 0._r8
-             fracrain          = 0._r8
+             fracsnow(p)          = 0._r8
+             fracrain(p)          = 0._r8
 
           end if
 
@@ -348,20 +350,20 @@ contains
 
           if (ctype(c) /= icol_sunwall .and. ctype(c) /= icol_shadewall) then
              if (frac_veg_nosno(p) == 0) then
-                qflx_prec_grnd_snow = forc_snow(t)
-                qflx_prec_grnd_rain = forc_rain(t)
+                qflx_prec_grnd_snow(p) = forc_snow(t)
+                qflx_prec_grnd_rain(p) = forc_rain(t)
                 qflx_dirct_rain(p) = forc_rain(t)
                 qflx_leafdrip(p) = 0._r8
              else
-                qflx_prec_grnd_snow = qflx_through_snow + (qflx_candrip * fracsnow)
-                qflx_prec_grnd_rain = qflx_through_rain + (qflx_candrip * fracrain)
-                qflx_dirct_rain(p) = qflx_through_rain
-                qflx_leafdrip(p) = qflx_candrip * fracrain
+                qflx_prec_grnd_snow(p) = qflx_through_snow(p) + (qflx_candrip(p) * fracsnow(p))
+                qflx_prec_grnd_rain(p) = qflx_through_rain(p) + (qflx_candrip(p) * fracrain(p))
+                qflx_dirct_rain(p) = qflx_through_rain(p)
+                qflx_leafdrip(p) = qflx_candrip(p) * fracrain(p)
              end if
              ! Urban sunwall and shadewall have no intercepted precipitation
           else
-             qflx_prec_grnd_snow = 0._r8
-             qflx_prec_grnd_rain = 0._r8
+             qflx_prec_grnd_snow(p) = 0.
+             qflx_prec_grnd_rain(p) = 0.
              qflx_dirct_rain(p) = 0._r8
              qflx_leafdrip(p) = 0._r8
           end if
@@ -373,7 +375,7 @@ contains
              n_irrig_steps_left(p) = n_irrig_steps_left(p) - 1
           else
              qflx_irrig(p) = 0._r8
-             !qflx_irrig_grid(g) = 0._r8
+             qflx_irrig_grid(g) = 0._r8
           end if
 
           ! Add irrigation water directly onto ground (bypassing canopy interception)
@@ -393,29 +395,29 @@ contains
                if (qflx_irrig(p) > 0._r8 .or. qflx_supply(p) > 0._r8) then	!this pft needs water or have supply             
                   if  (irrigated(veg_pp%itype(p)) == 1._r8) then ! this pft is irrigated
                      qflx_surf_irrig(p) = qflx_supply(p)/irrigated_ppg(g)  ! surface water irrgation from MOSART, with time step shift                   
-                     qflx_grnd_irrig(p) = ldomain_gpu%f_grd(g)*qflx_irrig(p) ! groundwater irrigation based on demand in ELM, same time step
+                     qflx_grnd_irrig(p) = ldomain%f_grd(g)*qflx_irrig(p) ! groundwater irrigation based on demand in ELM, same time step
                      
                      if (extra_gw_irr) then ! if always met by additional extra gw pumping
                         if (qflx_supply(p) > 0._r8) then				
                            if (pgwgt(p) > 0._r8) then	 
-                              qflx_grnd_irrig(p) = atm2lnd_vars%deficit_grc(g)/pgwgt(p)/irrigated_ppg(g) + ldomain_gpu%f_grd(g)*qflx_irrig(p)
+                              qflx_grnd_irrig(p) = atm2lnd_vars%deficit_grc(g)/pgwgt(p)/irrigated_ppg(g) + ldomain%f_grd(g)*qflx_irrig(p)
                               !groundwater irrigation based on deficit from MOSART (with time step shift), not demand from ELM
                            end if
                         else if (qflx_irrig(p) > 0._r8) then
-                           qflx_grnd_irrig(p) = ldomain_gpu%f_grd(g)*qflx_irrig(p)
+                           qflx_grnd_irrig(p) = ldomain%f_grd(g)*qflx_irrig(p)
                         else
                            qflx_grnd_irrig(p) = 0._r8
                         endif	
                      endif			   
                      qflx_real_irrig(p) = qflx_surf_irrig(p) + qflx_grnd_irrig(p) ! actual irrigation, including groundwater irrigation
-                     qflx_prec_grnd_rain = qflx_prec_grnd_rain + qflx_real_irrig(p)   
+                     qflx_prec_grnd_rain(p) = qflx_prec_grnd_rain(p) + qflx_real_irrig(p)   
                   end if		
                end if       
             else  ! one way coupling
-               qflx_surf_irrig(p) = ldomain_gpu%f_surf(g)*qflx_irrig(p)
-               qflx_grnd_irrig(p) = ldomain_gpu%f_grd(g)*qflx_irrig(p)
+               qflx_surf_irrig(p) = ldomain%f_surf(g)*qflx_irrig(p)
+               qflx_grnd_irrig(p) = ldomain%f_grd(g)*qflx_irrig(p)
                qflx_real_irrig(p) = qflx_surf_irrig(p) + qflx_grnd_irrig(p)
-               qflx_prec_grnd_rain = qflx_prec_grnd_rain + qflx_real_irrig(p) 
+               qflx_prec_grnd_rain(p) = qflx_prec_grnd_rain(p) + qflx_real_irrig(p) 
                qflx_over_supply(p) = 0._r8
                qflx_supply(p) = 0._r8 !no water supplied by MOSART 
             end if
@@ -429,24 +431,24 @@ contains
 
           ! Done irrigation
 
-          qflx_prec_grnd(p) = qflx_prec_grnd_snow + qflx_prec_grnd_rain
+          qflx_prec_grnd(p) = qflx_prec_grnd_snow(p) + qflx_prec_grnd_rain(p)
 
           if (.not. use_extrasnowlayers) then
              if (do_capsnow(c)) then
-                qflx_snwcp_liq(p) = qflx_prec_grnd_rain
-                qflx_snwcp_ice(p) = qflx_prec_grnd_snow
+                qflx_snwcp_liq(p) = qflx_prec_grnd_rain(p)
+                qflx_snwcp_ice(p) = qflx_prec_grnd_snow(p)
 
                 qflx_snow_grnd_patch(p) = 0._r8
                 qflx_rain_grnd(p) = 0._r8
              else
                 qflx_snwcp_liq(p) = 0._r8
                 qflx_snwcp_ice(p) = 0._r8
-                qflx_snow_grnd_patch(p) = qflx_prec_grnd_snow           ! ice onto ground (mm/s)
-                qflx_rain_grnd(p)     = qflx_prec_grnd_rain           ! liquid water onto ground (mm/s)
+                qflx_snow_grnd_patch(p) = qflx_prec_grnd_snow(p)           ! ice onto ground (mm/s)
+                qflx_rain_grnd(p)     = qflx_prec_grnd_rain(p)           ! liquid water onto ground (mm/s)
              end if
           else
-             qflx_snow_grnd_patch(p) = qflx_prec_grnd_snow           ! ice onto ground (mm/s)
-             qflx_rain_grnd(p)     = qflx_prec_grnd_rain           ! liquid water onto ground (mm/s)
+             qflx_snow_grnd_patch(p) = qflx_prec_grnd_snow(p)           ! ice onto ground (mm/s)
+             qflx_rain_grnd(p)     = qflx_prec_grnd_rain(p)           ! liquid water onto ground (mm/s)       
           endif
 
        end do ! (end pft loop)
@@ -462,17 +464,17 @@ contains
        call p2c(bounds, num_nolakec, filter_nolakec, &
             qflx_snow_grnd_patch(bounds%begp:bounds%endp), &
             qflx_snow_grnd_col(bounds%begc:bounds%endc))
-
-      ! Update column level irrigation supple for balance check
-       call p2c(bounds, num_nolakec, filter_nolakec, &
+			
+		! Update column level irrigation supple for balance check	
+       call p2c(bounds, num_nolakec, filter_nolakec, &      
             qflx_over_supply(bounds%begp:bounds%endp), &
             qflx_over_supply_col(bounds%begc:bounds%endc))
 
-       call p2c(bounds, num_nolakec, filter_nolakec, &
+       call p2c(bounds, num_nolakec, filter_nolakec, &      
             qflx_surf_irrig(bounds%begp:bounds%endp), &
             qflx_surf_irrig_col(bounds%begc:bounds%endc))
-
-       call p2c(bounds, num_nolakec, filter_nolakec, &
+            
+       call p2c(bounds, num_nolakec, filter_nolakec, &      
             qflx_grnd_irrig(bounds%begp:bounds%endp), &
             qflx_grnd_irrig_col(bounds%begc:bounds%endc))
 
@@ -480,7 +482,7 @@ contains
        do f = 1, num_nolakec
           c = filter_nolakec(f)
           g = cgridcell(c)
-          if (ctype(c) /= icol_sunwall .and. ctype(c) /= icol_shadewall) then
+          if (ctype(c) /= icol_sunwall .and. ctype(c) /= icol_shadewall) then      
              qflx_floodc(c) = qflx_floodg(g)
           else
              qflx_floodc(c) = 0._r8
@@ -488,11 +490,11 @@ contains
        enddo
 
        ! Determine snow height and snow water
-
-       ! if (use_extrasnowlayers) then
-       !    call NewSnowBulkDensity(bounds, num_nolakec, filter_nolakec, &
-       !                            top_as, bifall(bounds%begc:bounds%endc))
-       ! end if
+       
+       if (use_extrasnowlayers) then
+          call NewSnowBulkDensity(bounds, num_nolakec, filter_nolakec, &
+                                  top_as, bifall(bounds%begc:bounds%endc))
+       end if
 
        do f = 1, num_nolakec
           c = filter_nolakec(f)
@@ -517,7 +519,7 @@ contains
 
           if (do_capsnow(c) .and. .not. use_extrasnowlayers) then
              dz_snowf = 0._r8
-             newsnow = qflx_snow_grnd_col(c) * dtime
+             newsnow(c) = qflx_snow_grnd_col(c) * dtime
              frac_sno(c)=1._r8
              int_snow(c) = 5.e2_r8
           else
@@ -532,13 +534,13 @@ contains
              end if
 
              ! all snow falls on ground, no snow on h2osfc
-             newsnow = qflx_snow_grnd_col(c) * dtime
+             newsnow(c) = qflx_snow_grnd_col(c) * dtime
 
              ! update int_snow
              int_snow(c) = max(int_snow(c),h2osno(c)) !h2osno could be larger due to frost
 
              ! snowmelt from previous time step * dtime
-             snowmelt = qflx_snow_melt(c) * dtime
+             snowmelt(c) = qflx_snow_melt(c) * dtime
 
              ! set shape factor for accumulation of snow
              accum_factor=0.1
@@ -548,7 +550,7 @@ contains
                 !======================  FSCA PARAMETERIZATIONS  ======================
                 ! fsca parameterization based on *changes* in swe
                 ! first compute change from melt during previous time step
-                if(snowmelt > 0._r8) then
+                if(snowmelt(c) > 0._r8) then
 
                    smr=min(1._r8,(h2osno(c))/(int_snow(c)))
 
@@ -557,12 +559,12 @@ contains
                 endif
 
                 ! update fsca by new snow event, add to previous fsca
-                if (newsnow > 0._r8) then
-                   fsno_new = 1._r8 - (1._r8 - tanh(accum_factor*newsnow))*(1._r8 - frac_sno(c))
+                if (newsnow(c) > 0._r8) then
+                   fsno_new = 1._r8 - (1._r8 - tanh(accum_factor*newsnow(c)))*(1._r8 - frac_sno(c))
                    frac_sno(c) = fsno_new
 
                    ! reset int_snow after accumulation events
-                   temp_intsnow= (h2osno(c) + newsnow) &
+                   temp_intsnow= (h2osno(c) + newsnow(c)) &
                         / (0.5*(cos(rpi*(1._r8-max(frac_sno(c),1e-6_r8))**(1./n_melt(c)))+1._r8))
                    int_snow(c) = min(1.e8_r8,temp_intsnow)
                 endif
@@ -572,21 +574,21 @@ contains
                 ! for subgrid fluxes
                 if (subgridflag ==1 .and. .not. urbpoi(l)) then
                    if (frac_sno(c) > 0._r8)then
-                      snow_depth(c)=snow_depth(c) + newsnow/(bifall(c) * frac_sno(c))
+                      snow_depth(c)=snow_depth(c) + newsnow(c)/(bifall(c) * frac_sno(c))
                    else
                       snow_depth(c)=0._r8
                    end if
                 else
                    ! for uniform snow cover
-                   snow_depth(c)=snow_depth(c)+newsnow/bifall(c)
+                   snow_depth(c)=snow_depth(c)+newsnow(c)/bifall(c)
                 endif
 
                 ! use original fsca formulation (n&y 07)
-                if (oldfflag == 1) then
+                if (oldfflag == 1) then 
                    ! snow cover fraction in Niu et al. 2007
                    if(snow_depth(c) > 0.0_r8)  then
                       frac_sno(c) = tanh(snow_depth(c)/(2.5_r8*zlnd* &
-                           (min(800._r8,(h2osno(c)+ newsnow)/snow_depth(c))/100._r8)**1._r8) )
+                           (min(800._r8,(h2osno(c)+ newsnow(c))/snow_depth(c))/100._r8)**1._r8) )
                    endif
                    if(h2osno(c) < 1.0_r8)  then
                       frac_sno(c)=min(frac_sno(c),h2osno(c))
@@ -595,29 +597,29 @@ contains
 
              else !h2osno == 0
                 ! initialize frac_sno and snow_depth when no snow present initially
-                if (newsnow > 0._r8) then
-                   z_avg = newsnow/bifall(c)
-                   fmelt=newsnow
-                   frac_sno(c) = tanh(accum_factor*newsnow)
+                if (newsnow(c) > 0._r8) then 
+                   z_avg = newsnow(c)/bifall(c)
+                   fmelt=newsnow(c)
+                   frac_sno(c) = tanh(accum_factor*newsnow(c))
 
                    ! make int_snow consistent w/ new fsno, h2osno
                    int_snow(c) = 0. !reset prior to adding newsnow below
-                   temp_intsnow= (h2osno(c) + newsnow) &
+                   temp_intsnow= (h2osno(c) + newsnow(c)) &
                         / (0.5*(cos(rpi*(1._r8-max(frac_sno(c),1e-6_r8))**(1./n_melt(c)))+1._r8))
                    int_snow(c) = min(1.e8_r8,temp_intsnow)
 
                    ! update snow_depth and h2osno to be consistent with frac_sno, z_avg
-                   if (subgridflag == 1 .and. .not. urbpoi(l)) then
+                   if (subgridflag ==1 .and. .not. urbpoi(l)) then
                       snow_depth(c)=z_avg/frac_sno(c)
                    else
-                      snow_depth(c)=newsnow/bifall(c)
+                      snow_depth(c)=newsnow(c)/bifall(c)
                    endif
                    ! use n&y07 formulation
-                   if (oldfflag == 1) then
+                   if (oldfflag == 1) then 
                       ! snow cover fraction in Niu et al. 2007
                       if(snow_depth(c) > 0.0_r8)  then
                          frac_sno(c) = tanh(snow_depth(c)/(2.5_r8*zlnd* &
-                              (min(800._r8,newsnow/snow_depth(c))/100._r8)**1._r8) )
+                              (min(800._r8,newsnow(c)/snow_depth(c))/100._r8)**1._r8) )
                       endif
                    endif
                 else
@@ -631,8 +633,8 @@ contains
              qflx_snow_h2osfc(c) = 0._r8
 
              ! update h2osno for new snow
-             h2osno(c) = h2osno(c) + newsnow
-             int_snow(c) = int_snow(c) + newsnow
+             h2osno(c) = h2osno(c) + newsnow(c) 
+             int_snow(c) = int_snow(c) + newsnow(c)
 
              ! update change in snow depth
              dz_snowf = (snow_depth(c) - temp_snow_depth) / dtime
@@ -641,7 +643,7 @@ contains
 
           ! set frac_sno_eff variable
           if (ltype(l) == istsoil .or. ltype(l) == istcrop) then
-             if (subgridflag ==1) then
+             if (subgridflag ==1) then 
                 frac_sno_eff(c) = frac_sno(c)
              else
                 frac_sno_eff(c) = 1._r8
@@ -673,26 +675,7 @@ contains
                 frac_iceold(c,0) = 1._r8
 
                 ! intitialize SNICAR variables for fresh snow:
-                !call aerosol_vars%Reset(column=c)
-                aerosol_vars%mss_bcpho_col(c,:)  = 0._r8
-                aerosol_vars%mss_bcphi_col(c,:)  = 0._r8
-                aerosol_vars%mss_bctot_col(c,:)  = 0._r8
-                aerosol_vars%mss_bc_col_col(c)   = 0._r8
-                aerosol_vars%mss_bc_top_col(c)   = 0._r8
-
-                aerosol_vars%mss_ocpho_col(c,:)  = 0._r8
-                aerosol_vars%mss_ocphi_col(c,:)  = 0._r8
-                aerosol_vars%mss_octot_col(c,:)  = 0._r8
-                aerosol_vars%mss_oc_col_col(c)   = 0._r8
-                aerosol_vars%mss_oc_top_col(c)   = 0._r8
-
-                aerosol_vars%mss_dst1_col(c,:)   = 0._r8
-                aerosol_vars%mss_dst2_col(c,:)   = 0._r8
-                aerosol_vars%mss_dst3_col(c,:)   = 0._r8
-                aerosol_vars%mss_dst4_col(c,:)   = 0._r8
-                aerosol_vars%mss_dsttot_col(c,:) = 0._r8
-                aerosol_vars%mss_dst_col_col(c)  = 0._r8
-                aerosol_vars%mss_dst_top_col(c)  = 0._r8
+                call aerosol_vars%Reset(column=c)
                 ! call waterstate_vars%Reset(column=c)
                 col_ws%snw_rds(c,0) = snw_rds_min
              end if
@@ -709,28 +692,10 @@ contains
                 frac_iceold(c,0) = 1._r8
 
                 ! intitialize SNICAR variables for fresh snow:
-                !call aerosol_vars%Reset(column=c)
-                aerosol_vars%mss_bcpho_col(c,:)  = 0._r8
-                aerosol_vars%mss_bcphi_col(c,:)  = 0._r8
-                aerosol_vars%mss_bctot_col(c,:)  = 0._r8
-                aerosol_vars%mss_bc_col_col(c)   = 0._r8
-                aerosol_vars%mss_bc_top_col(c)   = 0._r8
-
-                aerosol_vars%mss_ocpho_col(c,:)  = 0._r8
-                aerosol_vars%mss_ocphi_col(c,:)  = 0._r8
-                aerosol_vars%mss_octot_col(c,:)  = 0._r8
-                aerosol_vars%mss_oc_col_col(c)   = 0._r8
-                aerosol_vars%mss_oc_top_col(c)   = 0._r8
-
-                aerosol_vars%mss_dst1_col(c,:)   = 0._r8
-                aerosol_vars%mss_dst2_col(c,:)   = 0._r8
-                aerosol_vars%mss_dst3_col(c,:)   = 0._r8
-                aerosol_vars%mss_dst4_col(c,:)   = 0._r8
-                aerosol_vars%mss_dsttot_col(c,:) = 0._r8
-                aerosol_vars%mss_dst_col_col(c)  = 0._r8
-                aerosol_vars%mss_dst_top_col(c)  = 0._r8
+                call aerosol_vars%Reset(column=c)
+                ! call waterstate_vars%Reset(column=c)
                 col_ws%snw_rds(c,0) = snw_rds_min
-             end if
+             end if             
           end if
 
           ! The change of ice partial density of surface node due to precipitation.
@@ -738,7 +703,7 @@ contains
           ! later.
 
           if (snl(c) < 0 .and. newnode == 0) then
-             h2osoi_ice(c,snl(c)+1) = h2osoi_ice(c,snl(c)+1)+newsnow
+             h2osoi_ice(c,snl(c)+1) = h2osoi_ice(c,snl(c)+1)+newsnow(c)
              dz(c,snl(c)+1) = dz(c,snl(c)+1)+dz_snowf*dtime
           end if
 
@@ -748,7 +713,7 @@ contains
        call FracH2oSfc(bounds, num_nolakec, filter_nolakec, &
              col_wf%qflx_h2osfc2topsoi, dtime)
 
-     end associate
+     end associate 
 
    end subroutine CanopyHydrology
 
@@ -762,7 +727,7 @@ contains
      ! stem area which contribute to evaporation. The variable ``fdry''
      ! is the fraction of elai which is dry because only leaves
      ! can transpire.  Adjusted for stem area which does not transpire.
-     !$acc routine seq 
+     !
      ! !ARGUMENTS:
      integer                , intent(in)    :: numf                  ! number of filter non-lake points
      integer                , intent(in)    :: filter(numf)          ! patch filter for non-lake points
@@ -774,13 +739,15 @@ contains
      real(r8) :: dewmxi           ! inverse of maximum allowed dew [1/mm]
      !-----------------------------------------------------------------------
 
-     associate(                                              &
+     associate(                                              & 
           frac_veg_nosno => canopystate_vars%frac_veg_nosno_patch , & ! Input:  [integer (:)]  fraction of veg not covered by snow (0/1 now) [-]
-          dewmx          => canopystate_vars%dewmx_patch          , & ! Input:  [real(r8) (:) ]  Maximum allowed dew [mm]
+          dewmx          => canopystate_vars%dewmx_patch          , & ! Input:  [real(r8) (:) ]  Maximum allowed dew [mm]                
           elai           => canopystate_vars%elai_patch           , & ! Input:  [real(r8) (:) ]  one-sided leaf area index with burying by snow
           esai           => canopystate_vars%esai_patch           , & ! Input:  [real(r8) (:) ]  one-sided stem area index with burying by snow
-          h2ocan         => veg_ws%h2ocan          , & ! Input:  [real(r8) (:) ]  total canopy water (mm H2O)
-          fwet           => veg_ws%fwet            , & ! Output: [real(r8) (:) ]  fraction of canopy that is wet (0 to 1)
+
+          h2ocan         => veg_ws%h2ocan          , & ! Input:  [real(r8) (:) ]  total canopy water (mm H2O)             
+          
+          fwet           => veg_ws%fwet            , & ! Output: [real(r8) (:) ]  fraction of canopy that is wet (0 to 1) 
           fdry           => veg_ws%fdry              & ! Output: [real(r8) (:) ]  fraction of foliage that is green and dry [-] (new)
           )
 
@@ -810,20 +777,20 @@ contains
          qflx_h2osfc2topsoi,dtime, no_update)
      !
      ! !DESCRIPTION:
-     ! Determine fraction of land surfaces which are submerged
+     ! Determine fraction of land surfaces which are submerged  
      ! based on surface microtopography and surface water storage.
-     !$acc routine seq
+     !
      ! !USES:
      use shr_const_mod   , only : shr_const_pi
-     !use shr_spfn_mod    , only : erf => shr_spfn_erf
+     use shr_spfn_mod    , only : erf => shr_spfn_erf
      use landunit_varcon , only : istsoil, istcrop
      !
      ! !ARGUMENTS:
-     type(bounds_type)     , intent(in)           :: bounds
+     type(bounds_type)     , intent(in)           :: bounds           
      integer               , intent(in)           :: num_h2osfc       ! number of column points in column filter
-     integer               , intent(in)           :: filter_h2osfc(:) ! column filter
-     real(r8)              , intent(inout)        :: qflx_h2osfc2topsoi(bounds%begc:bounds%endc)
-     real(r8)              , intent(in)           :: dtime
+     integer               , intent(in)           :: filter_h2osfc(:) ! column filter 
+     real(r8)              , intent(inout)        :: qflx_h2osfc2topsoi(bounds%begc:bounds%endc)     
+     real(r8)              , intent(in)           :: dtime     
      integer               , intent(in), optional :: no_update        ! flag to make calculation w/o updating variables
      !
      ! !LOCAL VARIABLES:
@@ -833,16 +800,16 @@ contains
      real(r8):: min_h2osfc
      !-----------------------------------------------------------------------
 
-     associate(                                              &
-          micro_sigma  => col_pp%micro_sigma                  , & ! Input:  [real(r8) (:)   ] microtopography pdf sigma (m)
-
-          h2osno       => col_ws%h2osno       , & ! Input:  [real(r8) (:)   ] snow water (mm H2O)
+     associate(                                              & 
+          micro_sigma  => col_pp%micro_sigma                  , & ! Input:  [real(r8) (:)   ] microtopography pdf sigma (m)                     
 
-          h2osoi_liq   => col_ws%h2osoi_liq   , & ! Output: [real(r8) (:,:) ] liquid water (col,lyr) [kg/m2]
-          h2osfc       => col_ws%h2osfc       , & ! Output: [real(r8) (:)   ] surface water (mm)
-          frac_sno     => col_ws%frac_sno     , & ! Output: [real(r8) (:)   ] fraction of ground covered by snow (0 to 1)
-          frac_sno_eff => col_ws%frac_sno_eff , & ! Output: [real(r8) (:)   ] eff. fraction of ground covered by snow (0 to 1)
-          frac_h2osfc  => col_ws%frac_h2osfc    & ! Output: [real(r8) (:)   ] col fractional area with surface water greater than zero
+          h2osno       => col_ws%h2osno       , & ! Input:  [real(r8) (:)   ] snow water (mm H2O)                               
+          
+          h2osoi_liq   => col_ws%h2osoi_liq   , & ! Output: [real(r8) (:,:) ] liquid water (col,lyr) [kg/m2]                  
+          h2osfc       => col_ws%h2osfc       , & ! Output: [real(r8) (:)   ] surface water (mm)                                
+          frac_sno     => col_ws%frac_sno     , & ! Output: [real(r8) (:)   ] fraction of ground covered by snow (0 to 1)       
+          frac_sno_eff => col_ws%frac_sno_eff , & ! Output: [real(r8) (:)   ] eff. fraction of ground covered by snow (0 to 1)  
+          frac_h2osfc  => col_ws%frac_h2osfc    & ! Output: [real(r8) (:)   ] col fractional area with surface water greater than zero 
           )
 
        ! arbitrary lower limit on h2osfc for safer numerics...
@@ -856,7 +823,7 @@ contains
           if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
 
              !  Use newton-raphson method to iteratively determine frac_h20sfc
-             !  based on amount of surface water storage (h2osfc) and
+             !  based on amount of surface water storage (h2osfc) and 
              !  microtopography variability (micro_sigma)
 
              if (h2osfc(c) > min_h2osfc) then
@@ -878,7 +845,7 @@ contains
              else
                 frac_h2osfc(c) = 0._r8
                 h2osoi_liq(c,1) = h2osoi_liq(c,1) + h2osfc(c)
-                qflx_h2osfc2topsoi(c) = h2osfc(c)/dtime
+                qflx_h2osfc2topsoi(c) = h2osfc(c)/dtime                
                 h2osfc(c)=0._r8
              endif
 
@@ -887,7 +854,7 @@ contains
                 ! adjust fh2o, fsno when sum is greater than zero
                 if (frac_sno(c) > (1._r8 - frac_h2osfc(c)) .and. h2osno(c) > 0) then
 
-                   if (frac_h2osfc(c) > 0.01_r8) then
+                   if (frac_h2osfc(c) > 0.01_r8) then             
                       frac_h2osfc(c) = max(1.0_r8 - frac_sno(c),0.01_r8)
                       frac_sno(c) = 1.0_r8 - frac_h2osfc(c)
                    else
diff --git a/components/elm/src/biogeophys/CanopyTemperatureMod.F90 b/components/elm/src/biogeophys/CanopyTemperatureMod.F90
index b2bdd18009..017c3770a9 100644
--- a/components/elm/src/biogeophys/CanopyTemperatureMod.F90
+++ b/components/elm/src/biogeophys/CanopyTemperatureMod.F90
@@ -67,6 +67,7 @@ contains
     !                Ha = Hf + Hg and Ea = Ef + Eg
     !
     ! !USES:
+      !$acc routine seq
     use QSatMod            , only : QSat
     use elm_varcon         , only : denh2o, denice, roverg, hvap, hsub, zlnd, zsno, tfrz, spval
     use column_varcon      , only : icol_roof, icol_sunwall, icol_shadewall
@@ -92,7 +93,6 @@ contains
     integer  :: j            ! soil/snow level index
     integer  :: fp           ! lake filter pft index
     integer  :: fc           ! lake filter column index
-    integer  :: begp, endp   ! patch bounds
     real(r8) :: qred         ! soil surface relative humidity
     real(r8) :: avmuir       ! ir inverse optical depth per unit leaf area
     real(r8) :: eg           ! water vapor pressure at temperature T [pa]
@@ -108,6 +108,7 @@ contains
     real(r8) :: eff_porosity ! effective porosity in layer
     real(r8) :: vol_ice      ! partial volume of ice lens in layer
     real(r8) :: vol_liq      ! partial volume of liquid water in layer
+    real(r8) :: fh2o_eff(bounds%begc:bounds%endc) ! effective surface water fraction (i.e. seen by atm)
     !------------------------------------------------------------------------------
 
     associate(                                                          &
@@ -199,9 +200,6 @@ contains
          tssbef           =>    col_es%t_ssbef                          & ! Output: [real(r8) (:,:) ] soil/snow temperature before update (K)
          )
 
-      begp = bounds%begp 
-      endp = bounds%endp 
-      !$acc parallel loop independent gang vector collapse(2) default(present) 
       do j = -nlevsno+1, nlevgrnd
          do fc = 1,num_nolakec
             c = filter_nolakec(fc)
@@ -218,8 +216,7 @@ contains
 
       ! calculate moisture stress/resistance for soil evaporation
       call calc_soilevap_stress(bounds, num_nolakec, filter_nolakec, soilstate_vars)
-      
-      !$acc parallel loop independent gang vector default(present)
+
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          l = col_pp%landunit(c)
@@ -262,7 +259,6 @@ contains
             else if (col_pp%itype(c) == icol_road_perv) then
                ! Pervious road depends on water in total soil column
                nlevbed = nlev2bed(c)
-               !$acc loop seq 
                do j = 1, nlevbed
                   if (t_soisno(c,j) >= tfrz) then
                      vol_ice = min(watsat(c,j), h2osoi_ice(c,j)/(dz(c,j)*denice))
@@ -395,10 +391,12 @@ contains
       ! of its dynamics call.  If and when crops are
       ! enabled simultaneously with FATES, we will
       ! have to apply a filter here.
+#ifndef _OPENACC
       if(use_fates) then
          call alm_fates%TransferZ0mDisp(bounds,frictionvel_vars,canopystate_vars)
       end if
-      !$acc parallel loop independent gang vector default(present) 
+#endif
+
       do fp = 1,num_nolakep
          p = filter_nolakep(fp)
          if( .not.(veg_pp%is_fates(p))) then
@@ -409,7 +407,6 @@ contains
 
       ! Initialization
 
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_nolakep
          p = filter_nolakep(fp)
 
@@ -451,8 +448,7 @@ contains
 
       ! Make forcing height a pft-level quantity that is the atmospheric forcing
       ! height plus each pft's z0m+displa
-      !$acc parallel loop independent gang vector default(present) 
-      do p = begp,endp
+      do p = bounds%begp,bounds%endp
          if (veg_pp%active(p)) then
             g = veg_pp%gridcell(p)
             t = veg_pp%topounit(p)
@@ -486,7 +482,6 @@ contains
          end if
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fp = 1,num_nolakep
          p = filter_nolakep(fp)
          c = veg_pp%column(p)
diff --git a/components/elm/src/biogeophys/DaylengthMod.F90 b/components/elm/src/biogeophys/DaylengthMod.F90
index 3c8d6f3ead..ba6d88ae2f 100644
--- a/components/elm/src/biogeophys/DaylengthMod.F90
+++ b/components/elm/src/biogeophys/DaylengthMod.F90
@@ -6,22 +6,19 @@ module DaylengthMod
   !
   use shr_kind_mod , only : r8 => shr_kind_r8
   use decompMod    , only : bounds_type
-  use GridcellType , only : grc_pp
+  use GridcellType , only : grc_pp                
   !
   implicit none
   save
-  PRIVATE
+  private
   !
   ! !PUBLIC MEMBER FUNCTIONS:
-  public :: daylength, daylength_test       ! function to compute daylength
+  public :: daylength         ! function to compute daylength
   public :: InitDaylength     ! initialize daylength for all grid cells
   public :: UpdateDaylength   ! update daylength for all grid cells
   !
   ! !PRIVATE DATA MEMBERS:
-  logical, public :: first_step = .true.        ! is this the first step since initialization?
-
-  !$acc declare copyin(first_step)
-
+  logical :: first_step       ! is this the first step since initialization?
   !
   !-----------------------------------------------------------------------
 
@@ -37,6 +34,8 @@ contains
     ! be strictly less than pi/2; lat must be less than pi/2 within a small tolerance.
     !
     ! !USES:
+    use shr_infnan_mod, only : nan => shr_infnan_nan, &
+                               assignment(=)
     use shr_const_mod , only : SHR_CONST_PI
     !
     ! !ARGUMENTS:
@@ -63,77 +62,24 @@ contains
 
     ! lat must be less than pi/2 within a small tolerance
     if (abs(lat) >= (pole + lat_epsilon)) then
-       daylength = -666.6666
+       daylength = nan
 
     ! decl must be strictly less than pi/2
     else if (abs(decl) >= pole) then
-       daylength = -666.6666
+       daylength = nan
 
     ! normal case
-    else
+    else    
        ! Ensure that latitude isn't too close to pole, to avoid problems with cos(lat) being negative
        my_lat = min(offset_pole, max(-1._r8 * offset_pole, lat))
 
        temp = -(sin(my_lat)*sin(decl))/(cos(my_lat) * cos(decl))
        temp = min(1._r8,max(-1._r8,temp))
-       daylength = 2.0_r8 * secs_per_radian * acos(temp)
+       daylength = 2.0_r8 * secs_per_radian * acos(temp) 
     end if
 
   end function daylength
-!===================================================================!
-!===================================================================!
-real(r8) function daylength_test(lat, decl)
-    !$acc routine seq
-    ! !DESCRIPTION:
-    ! Computes daylength (in seconds)
-    !
-    ! Latitude and solar declination angle should both be specified in radians. decl must
-    ! be strictly less than pi/2; lat must be less than pi/2 within a small tolerance.
-    !
-    ! !USES:
-    use shr_const_mod , only : SHR_CONST_PI
-    !
-    ! !ARGUMENTS:
-    real(r8), intent(in) :: lat    ! latitude (radians)
-    real(r8), intent(in) :: decl   ! solar declination angle (radians)
-    !
-    ! !LOCAL VARIABLES:
-    real(r8) :: my_lat             ! local version of lat, possibly adjusted slightly
-    real(r8) :: temp               ! temporary variable
-
-    ! number of seconds per radian of hour-angle
-    real(r8), parameter :: secs_per_radian = 13750.9871_r8
 
-    ! epsilon for defining latitudes "near" the pole
-    real(r8), parameter :: lat_epsilon = 10._r8 * epsilon(1._r8)
-
-    ! Define an offset pole as slightly less than pi/2 to avoid problems with cos(lat) being negative
-    real(r8), parameter :: pole = SHR_CONST_PI/2.0_r8
-    real(r8), parameter :: offset_pole = pole - lat_epsilon
-    !-----------------------------------------------------------------------
-
-    ! Can't SHR_ASSERT in an elemental function; instead, return a bad value if any
-    ! preconditions are violated
-
-    ! lat must be less than pi/2 within a small tolerance
-    if (abs(lat) >= (pole + lat_epsilon)) then
-       daylength_test = huge(1.0_r8)
-
-    ! decl must be strictly less than pi/2
-    else if (abs(decl) >= pole) then
-       daylength_test = huge(1._r8)
-
-    ! normal case
-    else
-       ! Ensure that latitude isn't too close to pole, to avoid problems with cos(lat) being negative
-       my_lat = min(offset_pole, max(-1._r8 * offset_pole, lat))
-
-       temp = -(sin(my_lat)*sin(decl))/(cos(my_lat) * cos(decl))
-       temp = min(1._r8,max(-1._r8,temp))
-       daylength_test = 2.0_r8 * secs_per_radian * acos(temp)
-    end if
-
-  end function daylength_test
 
   !-----------------------------------------------------------------------
   subroutine InitDaylength(bounds, declin, declinm1)
@@ -172,7 +118,7 @@ real(r8) function daylength_test(lat, decl)
 
   !-----------------------------------------------------------------------
   subroutine UpdateDaylength(bounds, declin)
-    !$acc routine seq
+    !
     ! !DESCRIPTION:
     ! Update daylength for all grid cells, and set previous daylength. This should be
     ! called exactly once per time step.
@@ -184,30 +130,29 @@ real(r8) function daylength_test(lat, decl)
     type(bounds_type), intent(in) :: bounds
     real(r8), intent(in) :: declin            ! solar declination angle (radians)
     !
-    integer :: cell
     !-----------------------------------------------------------------------
 
+    associate(&
+    lat       => grc_pp%lat,       & ! Input:  [real(r8) (:)] latitude (radians)
+    dayl      => grc_pp%dayl,      & ! InOut:  [real(r8) (:)] day length (s)
+    prev_dayl => grc_pp%prev_dayl, & ! Output: [real(r8) (:)] day length from previous time step (s)
+
+    begg      => bounds%begg  , & ! beginning grid cell index
+    endg      => bounds%endg    & ! ending grid cell index
+    )
+
     ! In the first time step, we simply use dayl & prev_dayl that were set in
     ! initialization. (We do NOT want to run the normal code in that case, because that
     ! would incorrectly set prev_dayl to be the same as the current dayl in the first
     ! time step, because of the way prev_dayl is initialized.)
-
-    !if (first_step) then
-    !   first_step = .false.
-    !else
-    !   grc_pp%prev_dayl(bounds%begg:bounds%endg) = grc_pp%dayl(bounds%begg:bounds%endg)
-    !   grc_pp%dayl(bounds%begg:bounds%endg) = daylength(grc_pp%lat(bounds%begg:bounds%endg), declin)
-    !end if
-
-    if ( first_step) then
-      first_step = .false.
-    else
-      do cell = bounds%begg, bounds%endg
-        grc_pp%prev_dayl(cell) = grc_pp%dayl(cell)
-        grc_pp%dayl(cell) = daylength_test(grc_pp%lat(cell), declin)
-      end do
+    if (first_step) then
+       first_step = .false.
+    else 
+       prev_dayl(begg:endg) = dayl(begg:endg)
+       dayl(begg:endg) = daylength(lat(begg:endg), declin)
     end if
 
+    end associate
 
   end subroutine UpdateDaylength
 
diff --git a/components/elm/src/biogeophys/EnergyFluxType.F90 b/components/elm/src/biogeophys/EnergyFluxType.F90
index f5b2b5604a..2443242fee 100644
--- a/components/elm/src/biogeophys/EnergyFluxType.F90
+++ b/components/elm/src/biogeophys/EnergyFluxType.F90
@@ -248,7 +248,7 @@ contains
 
     allocate(this%rresis_patch             (begp:endp,1:nlevgrnd))  ; this%rresis_patch            (:,:) = nan
     allocate(this%btran_patch              (begp:endp))             ; this%btran_patch             (:)   = nan
-    allocate(this%btran2_patch             (begp:endp))             ; this%btran2_patch            (:)   = spval
+    allocate(this%btran2_patch             (begp:endp))             ; this%btran2_patch            (:)   = nan
     allocate( this%bsun_patch              (begp:endp))             ; this%bsun_patch              (:)   = nan
     allocate( this%bsha_patch              (begp:endp))             ; this%bsha_patch              (:)   = nan
 
diff --git a/components/elm/src/biogeophys/FrictionVelocityMod.F90 b/components/elm/src/biogeophys/FrictionVelocityMod.F90
index 04d4563009..c857eae54c 100644
--- a/components/elm/src/biogeophys/FrictionVelocityMod.F90
+++ b/components/elm/src/biogeophys/FrictionVelocityMod.F90
@@ -30,970 +30,9 @@ module FrictionVelocityMod
   private :: StabilityFunc2        ! Stability function for rib < 0.
   !------------------------------------------------------------------------------
 
-  public :: FrictionVelocity_test
-  public :: FrictionVelocity_loops
-  public :: FrictionVelocity_noloop 
-contains
-
-  !------------------------------------------------------------------------------
-  subroutine FrictionVelocity_noloop( &
-       displa, z0m, z0h, z0q, &
-       obu, iter, ur, um, ustar, &
-       temp1, temp2, temp12m, temp22m, fm, &
-       forc_hgt_u_patch , forc_hgt_t_patch, forc_hgt_q_patch, &
-       vds, u10, u10_elm, va, fv)
-    !$acc routine seq
-    ! !DESCRIPTION:
-    ! Calculation of the friction velocity, relation for potential
-    ! temperature and humidity profiles of surface boundary layer.
-    ! The scheme is based on the work of Zeng et al. (1998):
-    ! Intercomparison of bulk aerodynamic algorithms for the computation
-    ! of sea surface fluxes using TOGA CORE and TAO data. J. Climate,
-    ! Vol. 11, 2628-2644.
-    !
-    ! !USES:
-    use elm_varcon, only : vkc
-    implicit none
-    !
-    ! !ARGUMENTS:
-    real(r8) , intent(in)    :: displa      ! displacement height (m) [lbn:ubn]
-    real(r8) , intent(in)    :: z0m         ! roughness length over vegetation, momentum [m] [lbn:ubn]
-    real(r8) , intent(in)    :: z0h         ! roughness length over vegetation, sensible heat [m] [lbn:ubn]
-    real(r8) , intent(in)    :: z0q         ! roughness length over vegetation, latent heat [m] [lbn:ubn]
-    real(r8) , intent(in)    :: obu         ! monin-obukhov length (m) [lbn:ubn]
-    integer  , intent(in)    :: iter        ! iteration number
-    real(r8) , intent(in)    :: ur          ! wind speed at reference height [m/s] [lbn:ubn]
-    real(r8) , intent(in)    :: um          ! wind speed including the stablity effect [m/s] [lbn:ubn]
-    real(r8) , intent(out)   :: ustar       ! friction velocity [m/s] [lbn:ubn]
-    real(r8) , intent(out)   :: temp1       ! relation for potential temperature profile [lbn:ubn]
-    real(r8) , intent(out)   :: temp12m     ! relation for potential temperature profile applied at 2-m [lbn:ubn]
-    real(r8) , intent(out)   :: temp2       ! relation for specific humidity profile [lbn:ubn]
-    real(r8) , intent(out)   :: temp22m     ! relation for specific humidity profile applied at 2-m [lbn:ubn]
-    real(r8) , intent(inout) :: fm          ! diagnose 10m wind (DUST only) [lbn:ubn]
-    real(r8) , intent(in)    :: forc_hgt_u_patch ! observational height of wind at pft level [m]
-    real(r8) , intent(in)    :: forc_hgt_t_patch ! observational height of temperature at pft level [m]
-    real(r8) , intent(in)    :: forc_hgt_q_patch ! observational height of specific humidity at pft level [m]
-    real(r8) , intent(inout) :: vds              ! dry deposition velocity term (m/s) (for SO4 NH4NO3)
-    real(r8) , intent(inout) :: u10              ! 10-m wind (m/s) (for dust model)
-    real(r8) , intent(inout) :: u10_elm          ! 10-m wind (m/s)
-    real(r8) , intent(inout) :: va               ! atmospheric wind speed plus convective velocity (m/s)
-    real(r8) , intent(inout) :: fv               ! friction velocity (m/s) (for dust model)
-
-    !
-    ! !LOCAL VARIABLES:
-    real(r8), parameter :: zetam = 1.574_r8 ! transition point of flux-gradient relation (wind profile)
-    real(r8), parameter :: zetat = 0.465_r8 ! transition point of flux-gradient relation (temp. profile)
-    real(r8) :: zldis              ! reference height "minus" zero displacement heght [m]
-    real(r8) :: zeta               ! dimensionless height used in Monin-Obukhov theory
-    real(r8) :: tmp1,tmp2,tmp3,tmp4         ! Used to diagnose the 10 meter wind
-    real(r8) :: fmnew                       ! Used to diagnose the 10 meter wind
-    real(r8) :: fm10                        ! Used to diagnose the 10 meter wind
-    real(r8) :: zeta10                      ! Used to diagnose the 10 meter wind
-    real(r8) :: vds_tmp                     ! Temporary for dry deposition velocity
-    !------------------------------------------------------------------------------
-    ! Adjustment factors for unstable (moz < 0) or stable (moz > 0) conditions.
-
-    ! Wind profile
-    zldis = forc_hgt_u_patch-displa
-
-    zeta = zldis/obu
-    if (zeta < -zetam) then
-       ustar = vkc*um/(log(-zetam*obu/z0m)&
-            - StabilityFunc1(-zetam) &
-            + StabilityFunc1(z0m/obu) &
-            + 1.14_r8*((-zeta)**0.333_r8-(zetam)**0.333_r8))
-    else if (zeta < 0._r8) then
-       ustar = vkc*um/(log(zldis/z0m)&
-            - StabilityFunc1(zeta)&
-            + StabilityFunc1(z0m/obu))
-    else if (zeta <=  1._r8) then
-       ustar = vkc*um/(log(zldis/z0m) + 5._r8*zeta -5._r8*z0m/obu)
-    else
-       ustar = vkc*um/(log(obu/z0m)+5._r8-5._r8*z0m/obu &
-            +(5._r8*log(zeta)+zeta-1._r8))
-    end if
-
-    if (zeta < 0._r8) then
-       vds_tmp = 2.e-3_r8*ustar * ( 1._r8 + (300._r8/(-obu))**0.666_r8)
-    else
-       vds_tmp = 2.e-3_r8*ustar
-    endif
 
-    vds = vds_tmp
-
-    ! Calculate a 10-m wind (10m + z0m + d)
-    ! For now, this will not be the same as the 10-m wind calculated for the dust
-    ! model because the ELM stability functions are used here, not the LSM stability
-    ! functions used in the dust model. We will eventually change the dust model to be
-    ! consistent with the following formulation.
-    ! Note that the 10-m wind calculated this way could actually be larger than the
-    ! atmospheric forcing wind because 1) this includes the convective velocity, 2)
-    ! this includes the 1 m/s minimum wind threshold
-
-    ! If forcing height is less than or equal to 10m, then set 10-m wind to um
-    if (zldis-z0m <= 10._r8) then
-       u10_elm = um
-    else
-       if (zeta < -zetam) then
-          u10_elm = um - ( ustar/vkc*(log(-zetam*obu/(10._r8+z0m))         &
-               - StabilityFunc1(-zetam)                                 &
-               + StabilityFunc1((10._r8+z0m)/obu)                 &
-               + 1.14_r8*((-zeta)**0.333_r8-(zetam)**0.333_r8)) )
-       else if (zeta < 0._r8) then
-          u10_elm = um - ( ustar/vkc*(log(zldis/(10._r8+z0m))              &
-               - StabilityFunc1(zeta)                                &
-               + StabilityFunc1((10._r8+z0m)/obu)) )
-       else if (zeta <=  1._r8) then
-          u10_elm = um - ( ustar/vkc*(log(zldis/(10._r8+z0m))              &
-               + 5._r8*zeta - 5._r8*(10._r8+z0m)/obu) )
-       else
-          u10_elm = um - ( ustar/vkc*(log(obu/(10._r8+z0m))    &
-               + 5._r8 - 5._r8*(10._r8+z0m)/obu                   &
-               + (5._r8*log(zeta)+zeta-1._r8)) )
-       end if
-    end if
-    va = um
-
-    !===================!
-    !Temperature Profile!
-    !===================!
-    zldis = forc_hgt_t_patch - displa
-    zeta = zldis/obu
-    if (zeta < -zetat) then
-       temp1 = vkc/(log(-zetat*obu/z0h)&
-            - StabilityFunc2(-zetat) &
-            + StabilityFunc2(z0h/obu) &
-            + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-    else if (zeta < 0._r8) then
-       temp1 = vkc/(log(zldis/z0h) &
-            - StabilityFunc2(zeta) &
-            + StabilityFunc2(z0h/obu))
-    else if (zeta <=  1._r8) then
-       temp1 = vkc/(log(zldis/z0h) + 5._r8*zeta - 5._r8*z0h/obu)
-    else
-       temp1 = vkc/(log(obu/z0h) + 5._r8 - 5._r8*z0h/obu &
-            + (5._r8*log(zeta)+zeta-1._r8))
-    end if
-    !=================!
-    !Humidity Profile !
-    !=================!
-    if (forc_hgt_q_patch == forc_hgt_t_patch .and. z0q == z0h) then
-       temp2 = temp1
-    else
-       zldis = forc_hgt_q_patch-displa
-       zeta = zldis/obu
-       if (zeta < -zetat) then
-          temp2 = vkc/(log(-zetat*obu/z0q) &
-               - StabilityFunc2(-zetat) &
-               + StabilityFunc2(z0q/obu) &
-               + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-       else if (zeta < 0._r8) then
-          temp2 = vkc/(log(zldis/z0q) &
-               - StabilityFunc2(zeta) &
-               + StabilityFunc2(z0q/obu))
-       else if (zeta <=  1._r8) then
-          temp2 = vkc/(log(zldis/z0q) + 5._r8*zeta-5._r8*z0q/obu)
-       else
-          temp2 = vkc/(log(obu/z0q) + 5._r8 - 5._r8*z0q/obu &
-               + (5._r8*log(zeta)+zeta-1._r8))
-       end if
-    endif
-
-    ! Temperature profile applied at 2-m
-
-    zldis = 2.0_r8 + z0h
-    zeta = zldis/obu
-    if (zeta < -zetat) then
-       temp12m = vkc/(log(-zetat*obu/z0h)&
-            - StabilityFunc2(-zetat) &
-            + StabilityFunc2(z0h/obu) &
-            + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-    else if (zeta < 0._r8) then
-       temp12m = vkc/(log(zldis/z0h) &
-            - StabilityFunc2(zeta)  &
-            + StabilityFunc2(z0h/obu))
-    else if (zeta <=  1._r8) then
-       temp12m = vkc/(log(zldis/z0h) + 5._r8*zeta - 5._r8*z0h/obu)
-    else
-       temp12m = vkc/(log(obu/z0h) + 5._r8 - 5._r8*z0h/obu &
-            + (5._r8*log(zeta)+zeta-1._r8))
-    end if
-
-    ! Humidity profile applied at 2-m
-
-    if (z0q == z0h) then
-       temp22m = temp12m
-    else
-       zldis = 2.0_r8 + z0q
-       zeta = zldis/obu
-       if (zeta < -zetat) then
-          temp22m = vkc/(log(-zetat*obu/z0q) - &
-               StabilityFunc2(-zetat) + StabilityFunc2(z0q/obu) &
-               + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-       else if (zeta < 0._r8) then
-          temp22m = vkc/(log(zldis/z0q) - &
-               StabilityFunc2(zeta)+StabilityFunc2(z0q/obu))
-       else if (zeta <=  1._r8) then
-          temp22m = vkc/(log(zldis/z0q) + 5._r8*zeta-5._r8*z0q/obu)
-       else
-          temp22m = vkc/(log(obu/z0q) + 5._r8 - 5._r8*z0q/obu &
-               + (5._r8*log(zeta)+zeta-1._r8))
-       end if
-    end if
-
-    ! diagnose 10-m wind for dust model (dstmbl.F)
-    ! Notes from C. Zender's dst.F:
-    ! According to Bon96 p. 62, the displacement height d (here displa) is
-    ! 0.0 <= d <= 0.34 m in dust source regions (i.e., regions w/o trees).
-    ! Therefore d <= 0.034*z1 and may safely be neglected.
-    ! Code from LSM routine SurfaceTemperature was used to obtain u10
-    
-    zldis = forc_hgt_u_patch - displa
-    zeta = zldis/obu
-    if (min(zeta, 1._r8) < 0._r8) then
-       tmp1 = (1._r8 - 16._r8*min(zeta,1._r8))**0.25_r8
-       tmp2 = log((1._r8+tmp1*tmp1)/2._r8)
-       tmp3 = log((1._r8+tmp1)/2._r8)
-       fmnew = 2._r8*tmp3 + tmp2 - 2._r8*atan(tmp1) + 1.5707963_r8
-    else
-       fmnew = -5._r8*min(zeta,1._r8)
-    endif
-    if (iter == 1) then
-        fm = fmnew
-    else
-        fm = 0.5_r8 * (fm+fmnew)
-    end if
-    zeta10 = min(10._r8/obu, 1._r8)
-    if (zeta == 0._r8) zeta10 = 0._r8
-    if (zeta10 < 0._r8) then
-       tmp1 = (1.0_r8 - 16.0_r8 * zeta10)**0.25_r8
-       tmp2 = log((1.0_r8 + tmp1*tmp1)/2.0_r8)
-       tmp3 = log((1.0_r8 + tmp1)/2.0_r8)
-       fm10 = 2.0_r8*tmp3 + tmp2 - 2.0_r8*atan(tmp1) + 1.5707963_r8
-    else                ! not stable
-       fm10 = -5.0_r8 * zeta10
-    end if
-
-    tmp4 = log( max( 1.0_8, forc_hgt_u_patch / 10._r8) )
-    u10 = ur - ustar/vkc * (tmp4 - fm + fm10)
-    fv  = ustar
-  end subroutine FrictionVelocity_noloop
-    !------------------------------------------------------------------------------
-  subroutine FrictionVelocity_loops(lbn, ubn, fn, filtern, &
-   displa, z0m, z0h, z0q, &
-   obu, iter, ur, um, ustar, &
-   temp1, temp2, temp12m, temp22m, fm,frictionvel_vars,converged, landunit_index)
-! !DESCRIPTION:
-! Calculation of the friction velocity, relation for potential
-! temperature and humidity profiles of surface boundary layer.
-! The scheme is based on the work of Zeng et al. (1998):
-! Intercomparison of bulk aerodynamic algorithms for the computation
-! of sea surface fluxes using TOGA CORE and TAO data. J. Climate,
-! Vol. 11, 2628-2644.
-!
-! !USES:
-use elm_varcon, only : vkc
-
-implicit none
-!
-! !ARGUMENTS:
-integer  , intent(in)    :: lbn, ubn            ! pft/landunit array bounds
-integer  , intent(in)    :: fn                  ! number of filtered pft/landunit elements
-integer  , intent(in)    :: filtern(fn)         ! pft/landunit filter
-real(r8) , intent(in)    :: displa  ( lbn: )    ! displacement height (m) [lbn:ubn]
-real(r8) , intent(in)    :: z0m     ( lbn: )    ! roughness length over vegetation, momentum [m] [lbn:ubn]
-real(r8) , intent(in)    :: z0h     ( lbn: )    ! roughness length over vegetation, sensible heat [m] [lbn:ubn]
-real(r8) , intent(in)    :: z0q     ( lbn: )    ! roughness length over vegetation, latent heat [m] [lbn:ubn]
-real(r8) , intent(in)    :: obu     ( 1: )      ! monin-obukhov length (m) [lbn:ubn]
-integer  , intent(in)    :: iter                ! iteration number
-real(r8) , intent(in)    :: ur      (1: )    ! wind speed at reference height [m/s] [lbn:ubn]
-real(r8) , intent(in)    :: um      (1: )    ! wind speed including the stablity effect [m/s] [lbn:ubn]
-real(r8) , intent(out)   :: ustar   (1: )    ! friction velocity [m/s] [lbn:ubn]
-real(r8) , intent(out)   :: temp1   (1: )    ! relation for potential temperature profile [lbn:ubn]
-real(r8) , intent(out)   :: temp2   (1: )    ! relation for specific humidity profile [lbn:ubn]
-real(r8) , intent(out)   :: temp12m (1: )    ! relation for potential temperature profile applied at 2-m [lbn:ubn]
-real(r8) , intent(out)   :: temp22m (1: )    ! relation for specific humidity profile applied at 2-m [lbn:ubn]
-real(r8) , intent(inout) :: fm      (1: )    ! diagnose 10m wind (DUST only) [lbn:ubn]
-type(frictionvel_type) , intent(inout) :: frictionvel_vars
-logical, intent(in)  :: converged(lbn:)
-logical  , intent(in), optional :: landunit_index   ! optional argument that defines landunit or pft level
-!
-! !LOCAL VARIABLES:
-real(r8), parameter :: zetam = 1.574_r8 ! transition point of flux-gradient relation (wind profile)
-real(r8), parameter :: zetat = 0.465_r8 ! transition point of flux-gradient relation (temp. profile)
-integer  :: f                           ! pft/landunit filter index
-integer  :: n                           ! pft/landunit index
-integer  :: g                           ! gridcell index
-integer  :: pp                          ! pfti,pftf index
-integer  :: pfti, pftf
-real(r8) :: zldis               ! reference height "minus" zero displacement heght [m]
-real(r8) :: zeta                ! dimensionless height used in Monin-Obukhov theory
-real(r8) :: tmp1,tmp2,tmp3,tmp4 ! Used to diagnose the 10 meter wind
-real(r8) :: fmnew               ! Used to diagnose the 10 meter wind
-real(r8) :: fm10                ! Used to diagnose the 10 meter wind
-real(r8) :: zeta10              ! Used to diagnose the 10 meter wind
-real(r8) :: vds_tmp             ! Temporary for dry deposition velocity
-logical  :: is_landunit_index 
-!------------------------------------------------------------------------------
-associate(                                                   &
-     forc_hgt_u_patch => frictionvel_vars%forc_hgt_u_patch , & ! Input:  [real(r8) (:) ] observational height of wind at pft level [m]
-     forc_hgt_t_patch => frictionvel_vars%forc_hgt_t_patch , & ! Input:  [real(r8) (:) ] observational height of temperature at pft level [m]
-     forc_hgt_q_patch => frictionvel_vars%forc_hgt_q_patch , & ! Input:  [real(r8) (:) ] observational height of specific humidity at pft level [m]
-     vds              => frictionvel_vars%vds_patch        , & ! Output: [real(r8) (:) ] dry deposition velocity term (m/s) (for SO4 NH4NO3)
-     u10              => frictionvel_vars%u10_patch        , & ! Output: [real(r8) (:) ] 10-m wind (m/s) (for dust model)
-     u10_elm          => frictionvel_vars%u10_elm_patch    , & ! Output: [real(r8) (:) ] 10-m wind (m/s)
-     va               => frictionvel_vars%va_patch         , & ! Output: [real(r8) (:) ] atmospheric wind speed plus convective velocity (m/s)
-     fv               => frictionvel_vars%fv_patch           & ! Output: [real(r8) (:) ] friction velocity (m/s) (for dust model)
-     )
-
-  ! Adjustment factors for unstable (moz < 0) or stable (moz > 0) conditions.
-  is_landunit_index = present(landunit_index)
-  !$acc enter data copyin(is_landunit_index)
-
-  !$acc parallel loop independent gang vector default(present) 
-   do f = 1, fn
-      n = filtern(f)
-      if(converged(n)) cycle
-
-      if (is_landunit_index) then
-        g = lun_pp%gridcell(n)
-        pfti = lun_pp%pfti(n)
-        pftf = lun_pp%pftf(n)
-      else
-        g = veg_pp%gridcell(n)
-      end if
-
-      ! Wind profile
-
-      if (is_landunit_index) then
-        zldis = forc_hgt_u_patch(pfti)-displa(n)
-      else
-        zldis = forc_hgt_u_patch(n)-displa(n)
-      end if
-
-      zeta = zldis/obu(f)
-      if (zeta < -zetam) then
-        ustar(f) = vkc*um(f)/(log(-zetam*obu(f)/z0m(n))&
-              - StabilityFunc1(-zetam) &
-              + StabilityFunc1(z0m(n)/obu(f)) &
-              + 1.14_r8*((-zeta)**0.333_r8-(zetam)**0.333_r8))
-      else if (zeta < 0._r8) then
-        ustar(f) = vkc*um(f)/(log(zldis/z0m(n))&
-              - StabilityFunc1(zeta)&
-              + StabilityFunc1(z0m(n)/obu(f)))
-      else if (zeta <=  1._r8) then
-        ustar(f) = vkc*um(f)/(log(zldis/z0m(n)) + 5._r8*zeta -5._r8*z0m(n)/obu(f))
-      else
-        ustar(f) = vkc*um(f)/(log(obu(f)/z0m(n))+5._r8-5._r8*z0m(n)/obu(f) &
-              +(5._r8*log(zeta)+zeta-1._r8))
-      end if
-
-      if (zeta < 0._r8) then
-        vds_tmp = 2.e-3_r8*ustar(f) * ( 1._r8 + (300._r8/(-obu(f)))**0.666_r8)
-      else
-        vds_tmp = 2.e-3_r8*ustar(f)
-      endif
-
-      if (is_landunit_index) then
-        !$acc loop seq 
-        do pp = pfti,pftf
-            vds(pp) = vds_tmp
-        end do
-      else
-        vds(n) = vds_tmp
-      end if
-
-      ! Calculate a 10-m wind (10m + z0m + d)
-      ! For now, this will not be the same as the 10-m wind calculated for the dust
-      ! model because the CLM stability functions are used here, not the LSM stability
-      ! functions used in the dust model. We will eventually change the dust model to be
-      ! consistent with the following formulation.
-      ! Note that the 10-m wind calculated this way could actually be larger than the
-      ! atmospheric forcing wind because 1) this includes the convective velocity, 2)
-      ! this includes the 1 m/s minimum wind threshold
-
-      ! If forcing height is less than or equal to 10m, then set 10-m wind to um
-      if (is_landunit_index) then
-        !$acc loop seq 
-        do pp = pfti,pftf
-            if (zldis-z0m(n) <= 10._r8) then
-               u10_elm(pp) = um(f)
-            else
-               if (zeta < -zetam) then
-                  u10_elm(pp) = um(f) - ( ustar(f)/vkc*(log(-zetam*obu(f)/(10._r8+z0m(n)))      &
-                       - StabilityFunc1(-zetam)                              &
-                       + StabilityFunc1((10._r8+z0m(n))/obu(f))              &
-                       + 1.14_r8*((-zeta)**0.333_r8-(zetam)**0.333_r8)) )
-               else if (zeta < 0._r8) then
-                  u10_elm(pp) = um(f) - ( ustar(f)/vkc*(log(zldis/(10._r8+z0m(n)))           &
-                       - StabilityFunc1(zeta)                             &
-                       + StabilityFunc1((10._r8+z0m(n))/obu(f))) )
-               else if (zeta <=  1._r8) then
-                  u10_elm(pp) = um(f) - ( ustar(f)/vkc*(log(zldis/(10._r8+z0m(n)))           &
-                       + 5._r8*zeta - 5._r8*(10._r8+z0m(n))/obu(f)) )
-               else
-                  u10_elm(pp) = um(f) - ( ustar(f)/vkc*(log(obu(f)/(10._r8+z0m(n)))             &
-                       + 5._r8 - 5._r8*(10._r8+z0m(n))/obu(f)                &
-                       + (5._r8*log(zeta)+zeta-1._r8)) )
-
-               end if
-            end if
-            va(pp) = um(f)
-        end do
-      else
-        if (zldis-z0m(n) <= 10._r8) then
-            u10_elm(n) = um(f)
-        else
-            if (zeta < -zetam) then
-               u10_elm(n) = um(f) - ( ustar(f)/vkc*(log(-zetam*obu(f)/(10._r8+z0m(n)))         &
-                    - StabilityFunc1(-zetam)                                 &
-                    + StabilityFunc1((10._r8+z0m(n))/obu(f))                 &
-                    + 1.14_r8*((-zeta)**0.333_r8-(zetam)**0.333_r8)) )
-            else if (zeta < 0._r8) then
-               u10_elm(n) = um(f) - ( ustar(f)/vkc*(log(zldis/(10._r8+z0m(n)))              &
-                    - StabilityFunc1(zeta)                                &
-                    + StabilityFunc1((10._r8+z0m(n))/obu(f))) )
-            else if (zeta <=  1._r8) then
-               u10_elm(n) = um(f) - ( ustar(f)/vkc*(log(zldis/(10._r8+z0m(n)))              &
-                    + 5._r8*zeta - 5._r8*(10._r8+z0m(n))/obu(f)) )
-            else
-               u10_elm(n) = um(f) - ( ustar(f)/vkc*(log(obu(f)/(10._r8+z0m(n)))    &
-                    + 5._r8 - 5._r8*(10._r8+z0m(n))/obu(f)                   &
-                    + (5._r8*log(zeta)+zeta-1._r8)) )
-            end if
-        end if
-        va(n) = um(f)
-      end if
-
-      !===================!
-      !Temperature Profile!
-      !===================!
-      if (is_landunit_index) then
-        zldis = forc_hgt_t_patch(pfti)-displa(n)
-      else
-        zldis = forc_hgt_t_patch(n)-displa(n)
-      end if
-      zeta = zldis/obu(f)
-      if (zeta < -zetat) then
-        temp1(f) = vkc/(log(-zetat*obu(f)/z0h(n))&
-              - StabilityFunc2(-zetat) &
-              + StabilityFunc2(z0h(n)/obu(f)) &
-              + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-      else if (zeta < 0._r8) then
-        temp1(f) = vkc/(log(zldis/z0h(n)) &
-              - StabilityFunc2(zeta) &
-              + StabilityFunc2(z0h(n)/obu(f)))
-      else if (zeta <=  1._r8) then
-        temp1(f) = vkc/(log(zldis/z0h(n)) + 5._r8*zeta - 5._r8*z0h(n)/obu(f))
-      else
-        temp1(f) = vkc/(log(obu(f)/z0h(n)) + 5._r8 - 5._r8*z0h(n)/obu(f) &
-              + (5._r8*log(zeta)+zeta-1._r8))
-      end if
-      !=================!
-      !Humidity Profile !
-      !=================!
-      if (is_landunit_index) then
-        if (forc_hgt_q_patch(pfti) == forc_hgt_t_patch(pfti) .and. z0q(n) == z0h(n)) then
-            temp2(f) = temp1(f)
-        else
-            zldis = forc_hgt_q_patch(pfti)-displa(n)
-            zeta = zldis/obu(f)
-            if (zeta < -zetat) then
-               temp2(f) = vkc/(log(-zetat*obu(f)/z0q(n)) &
-                    - StabilityFunc2(-zetat) &
-                    + StabilityFunc2(z0q(n)/obu(f)) &
-                    + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-            else if (zeta < 0._r8) then
-               temp2(f) = vkc/(log(zldis/z0q(n)) &
-                    - StabilityFunc2(zeta) &
-                    + StabilityFunc2(z0q(n)/obu(f)))
-            else if (zeta <=  1._r8) then
-               temp2(f) = vkc/(log(zldis/z0q(n)) + 5._r8*zeta-5._r8*z0q(n)/obu(f))
-            else
-               temp2(f) = vkc/(log(obu(f)/z0q(n)) + 5._r8 - 5._r8*z0q(n)/obu(f) &
-                    + (5._r8*log(zeta)+zeta-1._r8))
-            end if
-        end if
-      else
-        if (forc_hgt_q_patch(n) == forc_hgt_t_patch(n) .and. z0q(n) == z0h(n)) then
-            temp2(f) = temp1(f)
-        else
-            zldis = forc_hgt_q_patch(n)-displa(n)
-            zeta = zldis/obu(f)
-            if (zeta < -zetat) then
-               temp2(f) = vkc/(log(-zetat*obu(f)/z0q(n)) &
-                    - StabilityFunc2(-zetat) &
-                    + StabilityFunc2(z0q(n)/obu(f)) &
-                    + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-            else if (zeta < 0._r8) then
-               temp2(f) = vkc/(log(zldis/z0q(n)) &
-                    - StabilityFunc2(zeta) &
-                    + StabilityFunc2(z0q(n)/obu(f)))
-            else if (zeta <=  1._r8) then
-               temp2(f) = vkc/(log(zldis/z0q(n)) + 5._r8*zeta-5._r8*z0q(n)/obu(f))
-            else
-               temp2(f) = vkc/(log(obu(f)/z0q(n)) + 5._r8 - 5._r8*z0q(n)/obu(f) &
-                    + (5._r8*log(zeta)+zeta-1._r8))
-            end if
-        endif
-      endif
-
-      ! Temperature profile applied at 2-m
-
-      zldis = 2.0_r8 + z0h(n)
-      zeta = zldis/obu(f)
-      if (zeta < -zetat) then
-        temp12m(f) = vkc/(log(-zetat*obu(f)/z0h(n))&
-              - StabilityFunc2(-zetat) &
-              + StabilityFunc2(z0h(n)/obu(f)) &
-              + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-      else if (zeta < 0._r8) then
-        temp12m(f) = vkc/(log(zldis/z0h(n)) &
-              - StabilityFunc2(zeta)  &
-              + StabilityFunc2(z0h(n)/obu(f)))
-      else if (zeta <=  1._r8) then
-        temp12m(f) = vkc/(log(zldis/z0h(n)) + 5._r8*zeta - 5._r8*z0h(n)/obu(f))
-      else
-        temp12m(f) = vkc/(log(obu(f)/z0h(n)) + 5._r8 - 5._r8*z0h(n)/obu(f) &
-              + (5._r8*log(zeta)+zeta-1._r8))
-      end if
-
-      ! Humidity profile applied at 2-m
-
-      if (z0q(n) == z0h(n)) then
-        temp22m(f) = temp12m(f)
-      else
-        zldis = 2.0_r8 + z0q(n)
-        zeta = zldis/obu(f)
-        if (zeta < -zetat) then
-            temp22m(f) = vkc/(log(-zetat*obu(f)/z0q(n)) - &
-                 StabilityFunc2(-zetat) + StabilityFunc2(z0q(n)/obu(f)) &
-                 + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-        else if (zeta < 0._r8) then
-            temp22m(f) = vkc/(log(zldis/z0q(n)) - &
-                 StabilityFunc2(zeta)+StabilityFunc2(z0q(n)/obu(f)))
-        else if (zeta <=  1._r8) then
-            temp22m(f) = vkc/(log(zldis/z0q(n)) + 5._r8*zeta-5._r8*z0q(n)/obu(f))
-        else
-            temp22m(f)= vkc/(log(obu(f)/z0q(n)) + 5._r8 - 5._r8*z0q(n)/obu(f) &
-                 + (5._r8*log(zeta)+zeta-1._r8))
-        end if
-      end if
-
-      ! diagnose 10-m wind for dust model (dstmbl.F)
-      ! Notes from C. Zender's dst.F:
-      ! According to Bon96 p. 62, the displacement height d (here displa) is
-      ! 0.0 <= d <= 0.34 m in dust source regions (i.e., regions w/o trees).
-      ! Therefore d <= 0.034*z1 and may safely be neglected.
-      ! Code from LSM routine SurfaceTemperature was used to obtain u10
-      if (is_landunit_index) then
-        zldis = forc_hgt_u_patch(pfti)-displa(n)
-      else
-        zldis = forc_hgt_u_patch(n)-displa(n)
-      end if
-
-      zeta = zldis/obu(f)
-      if (min(zeta, 1._r8) < 0._r8) then
-        tmp1 = (1._r8 - 16._r8*min(zeta,1._r8))**0.25_r8
-        tmp2 = log((1._r8+tmp1*tmp1)/2._r8)
-        tmp3 = log((1._r8+tmp1)/2._r8)
-        fmnew = 2._r8*tmp3 + tmp2 - 2._r8*atan(tmp1) + 1.5707963_r8
-      else
-        fmnew = -5._r8*min(zeta,1._r8)
-      endif
-      if (iter == 1) then
-          fm(f) = fmnew
-      else
-          fm(f) = 0.5_r8 * (fm(f)+fmnew)
-      end if
-      zeta10 = min(10._r8/obu(f), 1._r8)
-      if (zeta == 0._r8) zeta10 = 0._r8
-      if (zeta10 < 0._r8) then
-        tmp1 = (1.0_r8 - 16.0_r8 * zeta10)**0.25_r8
-        tmp2 = log((1.0_r8 + tmp1*tmp1)/2.0_r8)
-        tmp3 = log((1.0_r8 + tmp1)/2.0_r8)
-        fm10 = 2.0_r8*tmp3 + tmp2 - 2.0_r8*atan(tmp1) + 1.5707963_r8
-      else                ! not stable
-        fm10 = -5.0_r8 * zeta10
-      end if
-
-      if (is_landunit_index) then
-        tmp4 = log( max( 1.0_8, forc_hgt_u_patch(pfti) / 10._r8) )
-      else
-        tmp4 = log( max( 1.0_8, forc_hgt_u_patch(n) / 10._r8) )
-      end if
-      if (is_landunit_index) then
-        !$acc loop seq 
-        do pp = pfti,pftf
-            u10(pp) = ur(f) - ustar(f)/vkc * (tmp4 - fm(f) + fm10)
-            fv(pp)  = ustar(f)
-        end do
-      else
-        u10(n) = ur(f) - ustar(f)/vkc * (tmp4 - fm(f) + fm10)
-        fv(n)  = ustar(f)
-      end if
-   end do !! do loop of fn
-
-   !$acc exit data delete(is_landunit_index)
- end associate
-
-end subroutine FrictionVelocity_loops
-
-
-  !------------------------------------------------------------------------------
-subroutine FrictionVelocity_test(lbn, ubn, fn, filtern, &
-   displa, z0m, z0h, z0q, &
-   obu, iter, ur, um, ustar, &
-   temp1, temp2, temp12m, temp22m, fm,frictionvel_vars,converged,landunit_index)
-! !DESCRIPTION:
-! Calculation of the friction velocity, relation for potential
-! temperature and humidity profiles of surface boundary layer.
-! The scheme is based on the work of Zeng et al. (1998):
-! Intercomparison of bulk aerodynamic algorithms for the computation
-! of sea surface fluxes using TOGA CORE and TAO data. J. Climate,
-! Vol. 11, 2628-2644.
-!
-! !USES:
-use elm_varcon, only : vkc
-
-
-implicit none
-!
-! !ARGUMENTS:
-integer  , intent(in)    :: lbn, ubn                 ! pft/landunit array bounds
-integer  , intent(in)    :: fn                       ! number of filtered pft/landunit elements
-integer  , intent(in)    :: filtern(fn)              ! pft/landunit filter
-real(r8) , intent(in)    :: displa  ( lbn: )         ! displacement height (m) [lbn:ubn]
-real(r8) , intent(in)    :: z0m     ( lbn: )         ! roughness length over vegetation, momentum [m] [lbn:ubn]
-real(r8) , intent(in)    :: z0h     ( lbn: )         ! roughness length over vegetation, sensible heat [m] [lbn:ubn]
-real(r8) , intent(in)    :: z0q     ( lbn: )         ! roughness length over vegetation, latent heat [m] [lbn:ubn]
-real(r8) , intent(in)    :: obu     ( lbn: )         ! monin-obukhov length (m) [lbn:ubn]
-integer  , intent(in)    :: iter                     ! iteration number
-real(r8) , intent(in)    :: ur      ( lbn: )         ! wind speed at reference height [m/s] [lbn:ubn]
-real(r8) , intent(in)    :: um      ( lbn: )         ! wind speed including the stablity effect [m/s] [lbn:ubn]
-real(r8) , intent(out)   :: ustar   ( lbn: )         ! friction velocity [m/s] [lbn:ubn]
-real(r8) , intent(out)   :: temp1   ( lbn: )         ! relation for potential temperature profile [lbn:ubn]
-real(r8) , intent(out)   :: temp12m ( lbn: )         ! relation for potential temperature profile applied at 2-m [lbn:ubn]
-real(r8) , intent(out)   :: temp2   ( lbn: )         ! relation for specific humidity profile [lbn:ubn]
-real(r8) , intent(out)   :: temp22m ( lbn: )         ! relation for specific humidity profile applied at 2-m [lbn:ubn]
-real(r8) , intent(inout) :: fm      ( lbn: )         ! diagnose 10m wind (DUST only) [lbn:ubn]
-type(frictionvel_type) , intent(inout) :: frictionvel_vars
-logical, intent(in)      :: converged(lbn:)
-logical  , intent(in), optional :: landunit_index   ! optional argument that defines landunit or pft level
-!
-! !LOCAL VARIABLES:
-real(r8), parameter :: zetam = 1.574_r8 ! transition point of flux-gradient relation (wind profile)
-real(r8), parameter :: zetat = 0.465_r8 ! transition point of flux-gradient relation (temp. profile)
-integer  :: f                           ! pft/landunit filter index
-integer  :: n                           ! pft/landunit index
-integer  :: g                           ! gridcell index
-integer  :: pp                          ! pfti,pftf index
-integer :: pfti, pftf
-real(r8) :: zldis              ! reference height "minus" zero displacement heght [m]
-real(r8) :: zeta               ! dimensionless height used in Monin-Obukhov theory
-real(r8) :: tmp1,tmp2,tmp3,tmp4         ! Used to diagnose the 10 meter wind
-real(r8) :: fmnew                       ! Used to diagnose the 10 meter wind
-real(r8) :: fm10                        ! Used to diagnose the 10 meter wind
-real(r8) :: zeta10                      ! Used to diagnose the 10 meter wind
-real(r8) :: vds_tmp                     ! Temporary for dry deposition velocity
-!------------------------------------------------------------------------------
-associate(                                                   &
-     forc_hgt_u_patch => frictionvel_vars%forc_hgt_u_patch , & ! Input:  [real(r8) (:) ] observational height of wind at pft level [m]
-     forc_hgt_t_patch => frictionvel_vars%forc_hgt_t_patch , & ! Input:  [real(r8) (:) ] observational height of temperature at pft level [m]
-     forc_hgt_q_patch => frictionvel_vars%forc_hgt_q_patch , & ! Input:  [real(r8) (:) ] observational height of specific humidity at pft level [m]
-     vds              => frictionvel_vars%vds_patch        , & ! Output: [real(r8) (:) ] dry deposition velocity term (m/s) (for SO4 NH4NO3)
-     u10              => frictionvel_vars%u10_patch        , & ! Output: [real(r8) (:) ] 10-m wind (m/s) (for dust model)
-     u10_elm          => frictionvel_vars%u10_elm_patch    , & ! Output: [real(r8) (:) ] 10-m wind (m/s)
-     va               => frictionvel_vars%va_patch         , & ! Output: [real(r8) (:) ] atmospheric wind speed plus convective velocity (m/s)
-     fv               => frictionvel_vars%fv_patch           & ! Output: [real(r8) (:) ] friction velocity (m/s) (for dust model)
-     )
-
-  ! Adjustment factors for unstable (moz < 0) or stable (moz > 0) conditions.
-
-    do f = 1, fn
-      n = filtern(f)
-      if(converged(n)) cycle
-      if (present(landunit_index)) then
-         g = lun_pp%gridcell(n)
-         pfti = lun_pp%pfti(n)
-         pftf = lun_pp%pftf(n)
-      else
-         g = veg_pp%gridcell(n)
-      end if
-
-      ! Wind profile
-
-      if (present(landunit_index)) then
-         zldis = forc_hgt_u_patch(pfti)-displa(n)
-      else
-         zldis = forc_hgt_u_patch(n)-displa(n)
-      end if
-
-      zeta = zldis/obu(n)
-      if (zeta < -zetam) then
-         ustar(n) = vkc*um(n)/(log(-zetam*obu(n)/z0m(n))&
-              - StabilityFunc1(-zetam) &
-              + StabilityFunc1(z0m(n)/obu(n)) &
-              + 1.14_r8*((-zeta)**0.333_r8-(zetam)**0.333_r8))
-      else if (zeta < 0._r8) then
-         ustar(n) = vkc*um(n)/(log(zldis/z0m(n))&
-              - StabilityFunc1(zeta)&
-              + StabilityFunc1(z0m(n)/obu(n)))
-      else if (zeta <=  1._r8) then
-         ustar(n) = vkc*um(n)/(log(zldis/z0m(n)) + 5._r8*zeta -5._r8*z0m(n)/obu(n))
-      else
-         ustar(n) = vkc*um(n)/(log(obu(n)/z0m(n))+5._r8-5._r8*z0m(n)/obu(n) &
-              +(5._r8*log(zeta)+zeta-1._r8))
-      end if
-
-      if (zeta < 0._r8) then
-         vds_tmp = 2.e-3_r8*ustar(n) * ( 1._r8 + (300._r8/(-obu(n)))**0.666_r8)
-      else
-         vds_tmp = 2.e-3_r8*ustar(n)
-      endif
-
-      if (present(landunit_index)) then
-         do pp = pfti,pftf
-            vds(pp) = vds_tmp
-         end do
-      else
-         vds(n) = vds_tmp
-      end if
-
-      ! Calculate a 10-m wind (10m + z0m + d)
-      ! For now, this will not be the same as the 10-m wind calculated for the dust
-      ! model because the CLM stability functions are used here, not the LSM stability
-      ! functions used in the dust model. We will eventually change the dust model to be
-      ! consistent with the following formulation.
-      ! Note that the 10-m wind calculated this way could actually be larger than the
-      ! atmospheric forcing wind because 1) this includes the convective velocity, 2)
-      ! this includes the 1 m/s minimum wind threshold
-
-      ! If forcing height is less than or equal to 10m, then set 10-m wind to um
-      if (present(landunit_index)) then
-         do pp = pfti,pftf
-            if (zldis-z0m(n) <= 10._r8) then
-               u10_elm(pp) = um(n)
-            else
-               if (zeta < -zetam) then
-                  u10_elm(pp) = um(n) - ( ustar(n)/vkc*(log(-zetam*obu(n)/(10._r8+z0m(n)))      &
-                       - StabilityFunc1(-zetam)                              &
-                       + StabilityFunc1((10._r8+z0m(n))/obu(n))              &
-                       + 1.14_r8*((-zeta)**0.333_r8-(zetam)**0.333_r8)) )
-               else if (zeta < 0._r8) then
-                  u10_elm(pp) = um(n) - ( ustar(n)/vkc*(log(zldis/(10._r8+z0m(n)))           &
-                       - StabilityFunc1(zeta)                             &
-                       + StabilityFunc1((10._r8+z0m(n))/obu(n))) )
-               else if (zeta <=  1._r8) then
-                  u10_elm(pp) = um(n) - ( ustar(n)/vkc*(log(zldis/(10._r8+z0m(n)))           &
-                       + 5._r8*zeta - 5._r8*(10._r8+z0m(n))/obu(n)) )
-               else
-                  u10_elm(pp) = um(n) - ( ustar(n)/vkc*(log(obu(n)/(10._r8+z0m(n)))             &
-                       + 5._r8 - 5._r8*(10._r8+z0m(n))/obu(n)                &
-                       + (5._r8*log(zeta)+zeta-1._r8)) )
-
-               end if
-            end if
-            va(pp) = um(n)
-         end do
-      else
-         if (zldis-z0m(n) <= 10._r8) then
-            u10_elm(n) = um(n)
-         else
-            if (zeta < -zetam) then
-               u10_elm(n) = um(n) - ( ustar(n)/vkc*(log(-zetam*obu(n)/(10._r8+z0m(n)))         &
-                    - StabilityFunc1(-zetam)                                 &
-                    + StabilityFunc1((10._r8+z0m(n))/obu(n))                 &
-                    + 1.14_r8*((-zeta)**0.333_r8-(zetam)**0.333_r8)) )
-            else if (zeta < 0._r8) then
-               u10_elm(n) = um(n) - ( ustar(n)/vkc*(log(zldis/(10._r8+z0m(n)))              &
-                    - StabilityFunc1(zeta)                                &
-                    + StabilityFunc1((10._r8+z0m(n))/obu(n))) )
-            else if (zeta <=  1._r8) then
-               u10_elm(n) = um(n) - ( ustar(n)/vkc*(log(zldis/(10._r8+z0m(n)))              &
-                    + 5._r8*zeta - 5._r8*(10._r8+z0m(n))/obu(n)) )
-            else
-               u10_elm(n) = um(n) - ( ustar(n)/vkc*(log(obu(n)/(10._r8+z0m(n)))    &
-                    + 5._r8 - 5._r8*(10._r8+z0m(n))/obu(n)                   &
-                    + (5._r8*log(zeta)+zeta-1._r8)) )
-            end if
-         end if
-         va(n) = um(n)
-      end if
-
-      !===================!
-      !Temperature Profile!
-      !===================!
-      if (present(landunit_index)) then
-         zldis = forc_hgt_t_patch(pfti)-displa(n)
-      else
-         zldis = forc_hgt_t_patch(n)-displa(n)
-      end if
-      zeta = zldis/obu(n)
-      if (zeta < -zetat) then
-         temp1(n) = vkc/(log(-zetat*obu(n)/z0h(n))&
-              - StabilityFunc2(-zetat) &
-              + StabilityFunc2(z0h(n)/obu(n)) &
-              + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-      else if (zeta < 0._r8) then
-         temp1(n) = vkc/(log(zldis/z0h(n)) &
-              - StabilityFunc2(zeta) &
-              + StabilityFunc2(z0h(n)/obu(n)))
-      else if (zeta <=  1._r8) then
-         temp1(n) = vkc/(log(zldis/z0h(n)) + 5._r8*zeta - 5._r8*z0h(n)/obu(n))
-      else
-         temp1(n) = vkc/(log(obu(n)/z0h(n)) + 5._r8 - 5._r8*z0h(n)/obu(n) &
-              + (5._r8*log(zeta)+zeta-1._r8))
-      end if
-      !=================!
-      !Humidity Profile !
-      !=================!
-      if (present(landunit_index)) then
-         if (forc_hgt_q_patch(pfti) == forc_hgt_t_patch(pfti) .and. z0q(n) == z0h(n)) then
-            temp2(n) = temp1(n)
-         else
-            zldis = forc_hgt_q_patch(pfti)-displa(n)
-            zeta = zldis/obu(n)
-            if (zeta < -zetat) then
-               temp2(n) = vkc/(log(-zetat*obu(n)/z0q(n)) &
-                    - StabilityFunc2(-zetat) &
-                    + StabilityFunc2(z0q(n)/obu(n)) &
-                    + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-            else if (zeta < 0._r8) then
-               temp2(n) = vkc/(log(zldis/z0q(n)) &
-                    - StabilityFunc2(zeta) &
-                    + StabilityFunc2(z0q(n)/obu(n)))
-            else if (zeta <=  1._r8) then
-               temp2(n) = vkc/(log(zldis/z0q(n)) + 5._r8*zeta-5._r8*z0q(n)/obu(n))
-            else
-               temp2(n) = vkc/(log(obu(n)/z0q(n)) + 5._r8 - 5._r8*z0q(n)/obu(n) &
-                    + (5._r8*log(zeta)+zeta-1._r8))
-            end if
-         end if
-      else
-         if (forc_hgt_q_patch(n) == forc_hgt_t_patch(n) .and. z0q(n) == z0h(n)) then
-            temp2(n) = temp1(n)
-         else
-            zldis = forc_hgt_q_patch(n)-displa(n)
-            zeta = zldis/obu(n)
-            if (zeta < -zetat) then
-               temp2(n) = vkc/(log(-zetat*obu(n)/z0q(n)) &
-                    - StabilityFunc2(-zetat) &
-                    + StabilityFunc2(z0q(n)/obu(n)) &
-                    + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-            else if (zeta < 0._r8) then
-               temp2(n) = vkc/(log(zldis/z0q(n)) &
-                    - StabilityFunc2(zeta) &
-                    + StabilityFunc2(z0q(n)/obu(n)))
-            else if (zeta <=  1._r8) then
-               temp2(n) = vkc/(log(zldis/z0q(n)) + 5._r8*zeta-5._r8*z0q(n)/obu(n))
-            else
-               temp2(n) = vkc/(log(obu(n)/z0q(n)) + 5._r8 - 5._r8*z0q(n)/obu(n) &
-                    + (5._r8*log(zeta)+zeta-1._r8))
-            end if
-         endif
-      endif
-
-      ! Temperature profile applied at 2-m
-
-      zldis = 2.0_r8 + z0h(n)
-      zeta = zldis/obu(n)
-      if (zeta < -zetat) then
-         temp12m(n) = vkc/(log(-zetat*obu(n)/z0h(n))&
-              - StabilityFunc2(-zetat) &
-              + StabilityFunc2(z0h(n)/obu(n)) &
-              + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-      else if (zeta < 0._r8) then
-         temp12m(n) = vkc/(log(zldis/z0h(n)) &
-              - StabilityFunc2(zeta)  &
-              + StabilityFunc2(z0h(n)/obu(n)))
-      else if (zeta <=  1._r8) then
-         temp12m(n) = vkc/(log(zldis/z0h(n)) + 5._r8*zeta - 5._r8*z0h(n)/obu(n))
-      else
-         temp12m(n) = vkc/(log(obu(n)/z0h(n)) + 5._r8 - 5._r8*z0h(n)/obu(n) &
-              + (5._r8*log(zeta)+zeta-1._r8))
-      end if
-
-      ! Humidity profile applied at 2-m
-
-      if (z0q(n) == z0h(n)) then
-         temp22m(n) = temp12m(n)
-      else
-         zldis = 2.0_r8 + z0q(n)
-         zeta = zldis/obu(n)
-         if (zeta < -zetat) then
-            temp22m(n) = vkc/(log(-zetat*obu(n)/z0q(n)) - &
-                 StabilityFunc2(-zetat) + StabilityFunc2(z0q(n)/obu(n)) &
-                 + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta)**(-0.333_r8)))
-         else if (zeta < 0._r8) then
-            temp22m(n) = vkc/(log(zldis/z0q(n)) - &
-                 StabilityFunc2(zeta)+StabilityFunc2(z0q(n)/obu(n)))
-         else if (zeta <=  1._r8) then
-            temp22m(n) = vkc/(log(zldis/z0q(n)) + 5._r8*zeta-5._r8*z0q(n)/obu(n))
-         else
-            temp22m(n) = vkc/(log(obu(n)/z0q(n)) + 5._r8 - 5._r8*z0q(n)/obu(n) &
-                 + (5._r8*log(zeta)+zeta-1._r8))
-         end if
-      end if
-
-      ! diagnose 10-m wind for dust model (dstmbl.F)
-      ! Notes from C. Zender's dst.F:
-      ! According to Bon96 p. 62, the displacement height d (here displa) is
-      ! 0.0 <= d <= 0.34 m in dust source regions (i.e., regions w/o trees).
-      ! Therefore d <= 0.034*z1 and may safely be neglected.
-      ! Code from LSM routine SurfaceTemperature was used to obtain u10
-
-
-      if (present(landunit_index)) then
-         zldis = forc_hgt_u_patch(pfti)-displa(n)
-      else
-         zldis = forc_hgt_u_patch(n)-displa(n)
-      end if
-
-      zeta = zldis/obu(n)
-      if (min(zeta, 1._r8) < 0._r8) then
-         tmp1 = (1._r8 - 16._r8*min(zeta,1._r8))**0.25_r8
-         tmp2 = log((1._r8+tmp1*tmp1)/2._r8)
-         tmp3 = log((1._r8+tmp1)/2._r8)
-         fmnew = 2._r8*tmp3 + tmp2 - 2._r8*atan(tmp1) + 1.5707963_r8
-      else
-         fmnew = -5._r8*min(zeta,1._r8)
-      endif
-      if (iter == 1) then
-          fm(n) = fmnew
-      else
-          fm(n) = 0.5_r8 * (fm(n)+fmnew)
-      end if
-      zeta10 = min(10._r8/obu(n), 1._r8)
-      if (zeta == 0._r8) zeta10 = 0._r8
-      if (zeta10 < 0._r8) then
-         tmp1 = (1.0_r8 - 16.0_r8 * zeta10)**0.25_r8
-         tmp2 = log((1.0_r8 + tmp1*tmp1)/2.0_r8)
-         tmp3 = log((1.0_r8 + tmp1)/2.0_r8)
-         fm10 = 2.0_r8*tmp3 + tmp2 - 2.0_r8*atan(tmp1) + 1.5707963_r8
-      else                ! not stable
-         fm10 = -5.0_r8 * zeta10
-      end if
-
-      if (present(landunit_index)) then
-         tmp4 = log( max( 1.0_8, forc_hgt_u_patch(pfti) / 10._r8) )
-      else
-         tmp4 = log( max( 1.0_8, forc_hgt_u_patch(n) / 10._r8) )
-      end if
-      if (present(landunit_index)) then
-         do pp = pfti,pftf
-            u10(pp) = ur(n) - ustar(n)/vkc * (tmp4 - fm(n) + fm10)
-            fv(pp)  = ustar(n)
-         end do
-      else
-         u10(n) = ur(n) - ustar(n)/vkc * (tmp4 - fm(n) + fm10)
-         fv(n)  = ustar(n)
-      end if
-    end do !! do loop of fn
-
- end associate
+contains
 
-end subroutine FrictionVelocity_test
   !------------------------------------------------------------------------------
   subroutine FrictionVelocity(lbn, ubn, fn, filtern, &
        displa, z0m, z0h, z0q, &
@@ -1410,23 +449,25 @@ end subroutine FrictionVelocity_test
     !
     ! !ARGUMENTS:
     implicit none
-    real(r8), intent(in),value  :: ur    ! wind speed at reference height [m/s]
-    real(r8), intent(in),value  :: thv   ! virtual potential temperature (kelvin)
-    real(r8), intent(in),value  :: dthv  ! diff of vir. poten. temp. between ref. height and surface
-    real(r8), intent(in),value  :: zldis ! reference height "minus" zero displacement heght [m]
-    real(r8), intent(in),value  :: z0m   ! roughness length, momentum [m]
+    real(r8), intent(in)  :: ur    ! wind speed at reference height [m/s]
+    real(r8), intent(in)  :: thv   ! virtual potential temperature (kelvin)
+    real(r8), intent(in)  :: dthv  ! diff of vir. poten. temp. between ref. height and surface
+    real(r8), intent(in)  :: zldis ! reference height "minus" zero displacement heght [m]
+    real(r8), intent(in)  :: z0m   ! roughness length, momentum [m]
     real(r8), intent(out) :: um    ! wind speed including the stability effect [m/s]
     real(r8), intent(out) :: obu   ! monin-obukhov length (m)
     !
     ! !LOCAL VARIABLES:
-    real(r8),parameter :: wc=0.5_r8    ! convective velocity [m/s]
-    real(r8),parameter :: ustar=0.06_r8 ! friction velocity [m/s]
+    real(r8) :: wc    ! convective velocity [m/s]
     real(r8) :: rib   ! bulk Richardson number
     real(r8) :: zeta  ! dimensionless height used in Monin-Obukhov theory
+    real(r8) :: ustar ! friction velocity [m/s]
     !-----------------------------------------------------------------------
 
     ! Initial values of u* and convective velocity
 
+    ustar=0.06_r8
+    wc=0.5_r8
     if (dthv >= 0._r8) then
        um=max(ur,0.1_r8)
     else
@@ -1434,6 +475,7 @@ end subroutine FrictionVelocity_test
     endif
 
     rib=grav*zldis*dthv/(thv*um*um)
+
     if (rib >= 0._r8) then      ! neutral or stable
        zeta = rib*log(zldis/z0m)/(1._r8-5._r8*min(rib,0.19_r8))
        zeta = min(2._r8,max(zeta,0.01_r8 ))
diff --git a/components/elm/src/biogeophys/HydrologyDrainageMod.F90 b/components/elm/src/biogeophys/HydrologyDrainageMod.F90
index 9ff13c2898..4be115394d 100644
--- a/components/elm/src/biogeophys/HydrologyDrainageMod.F90
+++ b/components/elm/src/biogeophys/HydrologyDrainageMod.F90
@@ -20,11 +20,11 @@ module HydrologyDrainageMod
   use ColumnDataType    , only : col_ws, col_wf
   use VegetationType    , only : veg_pp
 
+  use elm_instMod   , only : ep_betr
   use WaterStateType, only : waterstate_vars
   use WaterFluxType , only : waterflux_vars
 
   use timeinfoMod
-  use elm_instMod , only : ep_betr 
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -46,12 +46,14 @@ contains
        soilhydrology_vars, soilstate_vars )
     ! !DESCRIPTION:
     ! Calculates soil/snow hydrology with drainage (subsurface runoff)
+    !
     ! !USES:
+      !$acc routine seq
     use landunit_varcon  , only : istice, istwet, istsoil, istice_mec, istcrop
     use column_varcon    , only : icol_roof, icol_road_imperv, icol_road_perv, icol_sunwall, icol_shadewall
     use elm_varcon       , only : denh2o, denice, secspday
     use elm_varctl       , only : glc_snow_persistence_max_days, use_vichydro, use_betr
-    use domainMod        , only : ldomain_gpu
+    use domainMod        , only : ldomain
     use atm2lndType      , only : atm2lnd_type
     use elm_varpar       , only : nlevgrnd, nlevurb, nlevsoi
     use SoilHydrologyMod , only : ELMVICMap, Drainage
@@ -74,8 +76,8 @@ contains
 
     !
     ! !LOCAL VARIABLES:
+    real(r8) :: dtime
     integer  :: g,t,l,c,j,fc               ! indices
-    real(r8) :: sumtot, sumice, sumliq 
     !-----------------------------------------------------------------------
 
     associate(                                                                  &
@@ -121,22 +123,26 @@ contains
          qflx_glcice_frz        => col_wf%qflx_glcice_frz           & ! Output: [real(r8) (:)   ]  ice growth (positive definite) (mm H2O/s)
          )
 
-      !$acc enter data create(sumtot,sumice,sumliq)
-   #ifndef _OPENACC
+      ! Determine time step and step size
+
+      dtime = dtime_mod
+
       if (use_vichydro) then
          call ELMVICMap(bounds, num_hydrologyc, filter_hydrologyc, &
               soilhydrology_vars)
       endif
 
+#ifndef _OPENACC
       if (use_betr) then
         call ep_betr%BeTRSetBiophysForcing(bounds, col_pp, veg_pp, 1, nlevsoi, waterstate_vars=waterstate_vars)
         call ep_betr%PreDiagSoilColWaterFlux(num_hydrologyc, filter_hydrologyc)
       endif
-   #endif
+#endif
+
       if (.not. use_vsfm) then
          call Drainage(bounds, num_hydrologyc, filter_hydrologyc, &
               num_urbanc, filter_urbanc,&
-              soilhydrology_vars, soilstate_vars, dtime_mod)
+              soilhydrology_vars, soilstate_vars, dtime)
       endif
 
 #ifndef _OPENACC
@@ -148,7 +154,6 @@ contains
       endif
 #endif
 
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = 1, nlevgrnd
          do fc = 1, num_nolakec
             c = filter_nolakec(fc)
@@ -160,7 +165,6 @@ contains
          end do
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_nolakec
          c = filter_nolakec(fc)
          l = col_pp%landunit(c)
@@ -175,23 +179,18 @@ contains
          end if
       end do
 
-      !$acc parallel loop independent gang worker default(present) private(sumtot,sumliq,sumice)
-      do fc = 1, num_nolakec
-         c = filter_nolakec(fc)
-         sumtot = 0._r8; sumliq = 0._r8; sumice = 0._r8;
-         !$acc loop vector reduction(+:sumtot,sumliq,sumice)
-         do j = 1, nlevgrnd
+      do j = 1, nlevgrnd
+         do fc = 1, num_nolakec
+            c = filter_nolakec(fc)
             if ((ctype(c) == icol_sunwall .or. ctype(c) == icol_shadewall &
-               .or. ctype(c) == icol_roof) .and. j > nlevurb ) then
+                 .or. ctype(c) == icol_roof) .and. j > nlevurb) then
+
             else
-              sumtot = sumtot + h2osoi_ice(c,j) + h2osoi_liq(c,j)
-              sumliq = sumliq + h2osoi_liq(c,j)
-              sumice = sumice + h2osoi_ice(c,j)
+               endwb(c) = endwb(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)
+               h2osoi_liq_depth_intg(c) = h2osoi_liq_depth_intg(c) + h2osoi_liq(c,j)
+               h2osoi_ice_depth_intg(c) = h2osoi_ice_depth_intg(c) + h2osoi_ice(c,j)
             end if
-          end do
-          endwb(c) = endwb(c) + sumtot
-          h2osoi_liq_depth_intg(c) = h2osoi_liq_depth_intg(c) + sumliq
-          h2osoi_ice_depth_intg(c) = h2osoi_ice_depth_intg(c) + sumice
+         end do
       end do
 
       ! ---------------------------------------------------------------------------------
@@ -200,7 +199,6 @@ contains
       ! Other orthogonal modules should not need to worry about this term,
       ! and it should be zero in all other cases and all other columns.
       ! ---------------------------------------------------------------------------------
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_nolakec
          c = filter_nolakec(fc)
          endwb(c) = endwb(c) + total_plant_stored_h2o(c)
@@ -214,12 +212,10 @@ contains
       ! 2) If using glc_dyn_runoff_routing=T, zero qflx_snwcp_ice: qflx_snwcp_ice is the flux
       !    sent to ice runoff, but for glc_dyn_runoff_routing=T, we do NOT want this to be
       !    sent to ice runoff (instead it is sent to CISM).
-      !$acc parallel loop independent gang vector default(present) 
+
       do c = bounds%begc,bounds%endc
          qflx_glcice_frz(c) = 0._r8
       end do
-
-      !$acc parallel loop independent gang vector default(present) 
       do fc = 1,num_do_smb_c
          c = filter_do_smb_c(fc)
          l = col_pp%landunit(c)
@@ -235,11 +231,10 @@ contains
 
       ! Determine wetland and land ice hydrology (must be placed here
       ! since need snow updated from CombineSnowLayers)
-      !$acc parallel loop independent gang vector default(present)
       do c = bounds%begc,bounds%endc
          qflx_irr_demand(c) = 0._r8
       end do
-      !$acc parallel loop independent gang vector default(present)
+
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          l = col_pp%landunit(c)
@@ -255,7 +250,7 @@ contains
             qflx_surf(c)          = 0._r8
             qflx_infl(c)          = 0._r8
             qflx_qrgwl(c) = forc_rain(t) + forc_snow(t) + qflx_floodg(g) - qflx_evap_tot(c) - qflx_snwcp_ice(c) - &
-                 (endwb(c)-begwb(c))/dtime_mod
+                 (endwb(c)-begwb(c))/dtime
 
             ! With glc_dyn_runoff_routing = false (the less realistic way, typically used
             ! when NOT coupling to CISM), excess snow immediately runs off, whereas melting
@@ -288,7 +283,7 @@ contains
          qflx_runoff(c) = qflx_drain(c) + qflx_surf(c)  + qflx_h2osfc_surf(c) + qflx_qrgwl(c) + qflx_drain_perched(c)
 
          if ((lun_pp%itype(l)==istsoil .or. lun_pp%itype(l)==istcrop) .and. col_pp%active(c)) then
-            qflx_irr_demand(c) = -1.0_r8 * ldomain_gpu%f_surf(g)*qflx_irrig(c) !surface water demand send to MOSART
+            qflx_irr_demand(c) = -1.0_r8 * ldomain%f_surf(g)*qflx_irrig(c) !surface water demand send to MOSART
          end if
          if (lun_pp%urbpoi(l)) then
             qflx_runoff_u(c) = qflx_runoff(c)
@@ -298,7 +293,6 @@ contains
 
       end do
 
-      !$acc exit data delete(sumtot,sumice,sumliq)
     end associate
 
   end subroutine HydrologyDrainage
diff --git a/components/elm/src/biogeophys/HydrologyNoDrainageMod.F90 b/components/elm/src/biogeophys/HydrologyNoDrainageMod.F90
index 604e4eb9ec..e05b2f5eee 100644
--- a/components/elm/src/biogeophys/HydrologyNoDrainageMod.F90
+++ b/components/elm/src/biogeophys/HydrologyNoDrainageMod.F90
@@ -21,8 +21,10 @@ Module HydrologyNoDrainageMod
   use VegetationType    , only : veg_pp
   use TopounitDataType  , only : top_as, top_af ! Atmospheric state and flux variables
   use elm_instMod       , only : alm_fates , ep_betr
+
   use WaterFluxType  ,only  : waterflux_vars
   use WaterStateType ,only  : waterstate_vars
+
   use timeinfoMod
   !
   ! !PUBLIC TYPES:
@@ -43,9 +45,8 @@ contains
        num_urbanc, filter_urbanc, &
        num_snowc, filter_snowc, &
        num_nosnowc, filter_nosnowc, canopystate_vars, &
-       atm2lnd_vars, soilstate_vars, &
+       atm2lnd_vars, soilstate_vars, energyflux_vars, &
        soilhydrology_vars, aerosol_vars)
-   
     ! !DESCRIPTION:
     ! This is the main subroutine to execute the calculation of soil/snow
     ! hydrology
@@ -62,6 +63,7 @@ contains
     !    -> DivideExtraSnowLayers: subdivide up to 16 snow layers that are thicker than maximum
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon           , only : denh2o, denice, hfus, grav, tfrz
     use landunit_varcon      , only : istice, istwet, istsoil, istice_mec, istcrop, istdlak
     use column_varcon        , only : icol_roof, icol_road_imperv, icol_road_perv, icol_sunwall
@@ -72,7 +74,7 @@ contains
     use SnowHydrologyMod     , only : SnowWater, BuildSnowFilter 
     use SoilHydrologyMod     , only : ELMVICMap, SurfaceRunoff, Infiltration, WaterTable
     use SoilWaterMovementMod , only : SoilWater
-   !  use SoilWaterRetentionCurveMod, only : soil_water_retention_curve_type
+    use SoilWaterRetentionCurveMod, only : soil_water_retention_curve_type
     use elm_varctl           , only : use_vsfm
     use SoilHydrologyMod     , only : DrainageVSFM
     use SoilWaterMovementMod , only : Compute_EffecRootFrac_And_VertTranSink
@@ -93,9 +95,11 @@ contains
     integer                  , intent(inout) :: filter_nosnowc(:)    ! column filter for non-snow points
     type(atm2lnd_type)       , intent(in)    :: atm2lnd_vars
     type(soilstate_type)     , intent(inout) :: soilstate_vars
-    type(canopystate_type)   , intent(in)    :: canopystate_vars
+    type(energyflux_type)    , intent(in)    :: energyflux_vars
+    type(canopystate_type)   , intent(in)  :: canopystate_vars
     type(aerosol_type)       , intent(inout) :: aerosol_vars
     type(soilhydrology_type) , intent(inout) :: soilhydrology_vars
+    real(r8) :: dtime                         ! land model time step (sec)
 
     !
     ! !LOCAL VARIABLES:
@@ -103,36 +107,35 @@ contains
     integer  :: nlevbed                       ! # layers to bedrock
     real(r8) :: psi,vwc,fsattmp,psifrz        ! temporary variables for soilpsi calculation
     real(r8) :: watdry                        ! temporary
-    real(r8) :: rwat(1:num_hydrologyc) ! soil water wgted by depth to maximum depth of 0.5 m
-    real(r8) :: swat(1:num_hydrologyc) ! same as rwat but at saturation
-    real(r8) :: rz  (1:num_hydrologyc)   ! thickness of soil layers contributing to rwat (m)
+    real(r8) :: rwat(bounds%begc:bounds%endc) ! soil water wgted by depth to maximum depth of 0.5 m
+    real(r8) :: swat(bounds%begc:bounds%endc) ! same as rwat but at saturation
+    real(r8) :: rz(bounds%begc:bounds%endc)   ! thickness of soil layers contributing to rwat (m)
     real(r8) :: tsw                           ! volumetric soil water to 0.5 m
     real(r8) :: stsw                          ! volumetric soil water to 0.5 m at saturation
     real(r8) :: fracl                         ! fraction of soil layer contributing to 10cm total soil water
     real(r8) :: s_node                        ! soil wetness (-)
-    real(r8) :: sum1, sum2, sum3,sum4
-    real     :: startt, stopt  
+    real(r8) :: icefrac(bounds%begc:bounds%endc,1:nlevgrnd)
     !-----------------------------------------------------------------------
     
-    associate(                                       & 
-         z                  => col_pp%z               , & ! Input:  [real(r8) (:,:) ]  layer depth  (m)                      
-         dz                 => col_pp%dz              , & ! Input:  [real(r8) (:,:) ]  layer thickness depth (m)             
-         zi                 => col_pp%zi              , & ! Input:  [real(r8) (:,:) ]  interface depth (m)                   
-         snl                => col_pp%snl             , & ! Input:  [integer  (:)   ]  number of snow layers                    
-         nlev2bed           => col_pp%nlevbed         , & ! Input:  [integer  (:)   ]  number of layers to bedrock                     
-         ctype              => col_pp%itype           , & ! Input:  [integer  (:)   ]  column type                              
+    associate(                                                          & 
+         z                  => col_pp%z                                  , & ! Input:  [real(r8) (:,:) ]  layer depth  (m)                      
+         dz                 => col_pp%dz                                 , & ! Input:  [real(r8) (:,:) ]  layer thickness depth (m)             
+         zi                 => col_pp%zi                                 , & ! Input:  [real(r8) (:,:) ]  interface depth (m)                   
+         snl                => col_pp%snl                                , & ! Input:  [integer  (:)   ]  number of snow layers                    
+         nlev2bed           => col_pp%nlevbed                           , & ! Input:  [integer  (:)   ]  number of layers to bedrock                     
+         ctype              => col_pp%itype                              , & ! Input:  [integer  (:)   ]  column type                              
 
          forc_wind          => top_as%windbot         , & ! Input:  [real(r8) (:) ]  atmospheric wind speed (m/s)
 
-         t_h2osfc           => col_es%t_h2osfc        , & ! Input:  [real(r8) (:)   ]  surface water temperature               
-         dTdz_top           => col_es%dTdz_top        , & ! Output: [real(r8) (:)   ]  temperature gradient in top layer (col) [K m-1] !
-         snot_top           => col_es%snot_top        , & ! Output: [real(r8) (:)   ]  snow temperature in top layer (col) [K]
-         t_soisno           => col_es%t_soisno        , & ! Output: [real(r8) (:,:) ]  soil temperature (Kelvin)
-         t_grnd             => col_es%t_grnd          , & ! Output: [real(r8) (:)   ]  ground temperature (Kelvin)
-         t_grnd_u           => col_es%t_grnd_u        , & ! Output: [real(r8) (:)   ]  Urban ground temperature (Kelvin)
-         t_grnd_r           => col_es%t_grnd_r        , & ! Output: [real(r8) (:)   ]  Rural ground temperature (Kelvin)
-         t_soi_10cm         => col_es%t_soi10cm       , & ! Output: [real(r8) (:)   ]  soil temperature in top 10cm of soil (Kelvin)
-         tsoi17             => col_es%t_soi17cm       , & ! Output: [real(r8) (:)   ]  soil temperature in top 17cm of soil (Kelvin)
+         t_h2osfc           => col_es%t_h2osfc          , & ! Input:  [real(r8) (:)   ]  surface water temperature               
+         dTdz_top           => col_es%dTdz_top          , & ! Output: [real(r8) (:)   ]  temperature gradient in top layer (col) [K m-1] !
+         snot_top           => col_es%snot_top          , & ! Output: [real(r8) (:)   ]  snow temperature in top layer (col) [K]
+         t_soisno           => col_es%t_soisno          , & ! Output: [real(r8) (:,:) ]  soil temperature (Kelvin)
+         t_grnd             => col_es%t_grnd            , & ! Output: [real(r8) (:)   ]  ground temperature (Kelvin)
+         t_grnd_u           => col_es%t_grnd_u          , & ! Output: [real(r8) (:)   ]  Urban ground temperature (Kelvin)
+         t_grnd_r           => col_es%t_grnd_r          , & ! Output: [real(r8) (:)   ]  Rural ground temperature (Kelvin)
+         t_soi_10cm         => col_es%t_soi10cm         , & ! Output: [real(r8) (:)   ]  soil temperature in top 10cm of soil (Kelvin)
+         tsoi17             => col_es%t_soi17cm         , & ! Output: [real(r8) (:)   ]  soil temperature in top 17cm of soil (Kelvin)
 
          snow_depth         => col_ws%snow_depth         , & ! Input:  [real(r8) (:)   ]  snow height of snow covered area (m)
          snowdp             => col_ws%snowdp             , & ! Input:  [real(r8) (:)   ]  gridcell averaged snow height (m)
@@ -164,23 +167,20 @@ contains
          smpmin             => soilstate_vars%smpmin_col              , & ! Input:  [real(r8) (:)   ]  restriction for min of soil potential (mm)
          soilpsi            => soilstate_vars%soilpsi_col               & ! Output: [real(r8) (:,:) ]  soil water potential in each soil layer (MPa)
          )
-    !$acc enter data create(&
-    !$acc rwat(:), &
-    !$acc swat(:), &
-    !$acc rz(:), &
-    !$acc psi, &
-    !$acc sum1, &
-    !$acc sum2, &
-    !$acc sum3)
 
+         dtime = dtime_mod
       ! Determine initial snow/no-snow filters (will be modified possibly by
       ! routines CombineSnowLayers and DivideSnowLayers below
-      call BuildSnowFilter(num_nolakec, filter_nolakec, &
+
+      call BuildSnowFilter(bounds, num_nolakec, filter_nolakec, &
            num_snowc, filter_snowc, num_nosnowc, filter_nosnowc)
-      
+
+
       ! Determine the change of snow mass and the snow water onto soil
+
       call SnowWater(bounds, num_snowc, filter_snowc, num_nosnowc, filter_nosnowc, &
            atm2lnd_vars, aerosol_vars)
+
       ! mapping soilmoist from CLM to VIC layers for runoff calculations
       if (use_vichydro) then
          call ELMVICMap(bounds, num_hydrologyc, filter_hydrologyc, &
@@ -188,54 +188,65 @@ contains
       end if
 
       call SurfaceRunoff(bounds, num_hydrologyc, filter_hydrologyc, num_urbanc, filter_urbanc, &
-           soilhydrology_vars, soilstate_vars, dtime_mod)
+           soilhydrology_vars, soilstate_vars, dtime)
 
       !------------------------------------------------------------------------------------
       if (use_pflotran .and. pf_hmode) then
 
-         call Infiltration(bounds, num_hydrononsoic, filter_hydrononsoic, &
-              num_urbanc, filter_urbanc, &
-              soilhydrology_vars, soilstate_vars, dtime_mod)
+        call Infiltration(bounds, num_hydrononsoic, filter_hydrononsoic, &
+             num_urbanc, filter_urbanc, &
+             energyflux_vars, soilhydrology_vars, soilstate_vars, dtime)
 
       else
       !------------------------------------------------------------------------------------
+
         call Infiltration(bounds, num_hydrologyc, filter_hydrologyc, num_urbanc, filter_urbanc, &
-             soilhydrology_vars, soilstate_vars, dtime_mod)
-         
+             energyflux_vars, soilhydrology_vars, soilstate_vars, dtime)
+
+      !------------------------------------------------------------------------------------
       end if
       !------------------------------------------------------------------------------------
 
       !!TODO:  need to fix the waterstate_vars dependence here.
+#ifndef _OPENACC
       if (use_betr) then
         call ep_betr%BeTRSetBiophysForcing(bounds, col_pp, veg_pp, 1, nlevsoi, waterstate_vars=waterstate_vars)
         call ep_betr%PreDiagSoilColWaterFlux(num_hydrologyc, filter_hydrologyc)
       endif
+#endif
 
       if (use_vsfm) then
          call DrainageVSFM(bounds, num_hydrologyc, filter_hydrologyc, &
               num_urbanc, filter_urbanc,&
-              soilhydrology_vars, soilstate_vars, dtime_mod)
+              soilhydrology_vars, soilstate_vars, dtime)
       endif
+
       call Compute_EffecRootFrac_And_VertTranSink(bounds, num_hydrologyc, &
-           filter_hydrologyc, soilstate_vars, canopystate_vars)
-      
+           filter_hydrologyc, soilstate_vars, canopystate_vars, energyflux_vars)
 
+#ifndef _OPENACC
       ! If FATES plant hydraulics is turned on, over-ride default transpiration sink calculation
       if( use_fates ) call alm_fates%ComputeRootSoilFlux(bounds, num_hydrologyc, filter_hydrologyc, &
                                                       soilstate_vars)
+#endif
       !------------------------------------------------------------------------------------
       if (use_pflotran .and. pf_hmode) then
-      
+
         call SoilWater(bounds, num_hydrononsoic, filter_hydrononsoic, &
             num_urbanc, filter_urbanc, &
-            soilhydrology_vars, soilstate_vars, dtime_mod)
+            soilhydrology_vars, soilstate_vars, dtime)
 
       else
+      !------------------------------------------------------------------------------------
+
         call SoilWater(bounds, num_hydrologyc, filter_hydrologyc, num_urbanc, filter_urbanc, &
-            soilhydrology_vars, soilstate_vars, dtime_mod)
+            soilhydrology_vars, soilstate_vars, dtime)
+
+      !------------------------------------------------------------------------------------
       end if
       !------------------------------------------------------------------------------------
 
+#ifndef _OPENACC
        if (use_betr) then
           call ep_betr%BeTRSetBiophysForcing(bounds, col_pp, veg_pp, 1, nlevsoi, waterstate_vars=waterstate_vars, &
              waterflux_vars=waterflux_vars, soilhydrology_vars = soilhydrology_vars)
@@ -244,6 +255,7 @@ contains
 
           call ep_betr%RetrieveBiogeoFlux(bounds, 1, nlevsoi, waterflux_vars=waterflux_vars)
        endif
+#endif
 
       if (use_vichydro) then
          ! mapping soilmoist from CLM to VIC layers for runoff calculations
@@ -254,22 +266,28 @@ contains
       !------------------------------------------------------------------------------------
       if (use_pflotran .and. pf_hmode) then
 
-      call WaterTable(bounds, num_hydrononsoic, filter_hydrononsoic, &
-         num_urbanc, filter_urbanc, &
-         soilhydrology_vars, soilstate_vars, dtime_mod)
+        call WaterTable(bounds, num_hydrononsoic, filter_hydrononsoic, &
+           num_urbanc, filter_urbanc, &
+           soilhydrology_vars, soilstate_vars, dtime)
 
       else
-        !------------------------------------------------------------------------------------
+      !------------------------------------------------------------------------------------
+
         call WaterTable(bounds, num_hydrologyc, filter_hydrologyc, num_urbanc, filter_urbanc, &
-           soilhydrology_vars, soilstate_vars, dtime_mod)
-        !------------------------------------------------------------------------------------
+           soilhydrology_vars, soilstate_vars, dtime)
+
+      !------------------------------------------------------------------------------------
       end if
+      !------------------------------------------------------------------------------------
 
+
+#ifndef _OPENACC
       if (use_betr) then
          !apply dew and sublimation fluxes, this is a temporary work aroud for tracking water isotope
          !Jinyun Tang, Feb 4, 2015
          call ep_betr%CalcDewSubFlux(bounds, col_pp, num_hydrologyc, filter_hydrologyc)
       endif           
+#endif
       
       if (use_extrasnowlayers) then
          call SnowCapping(bounds, num_nolakec, filter_nolakec, num_snowc, filter_snowc, &
@@ -277,24 +295,22 @@ contains
       end if
       
       ! Natural compaction and metamorphosis.
-      call SnowCompaction(bounds, num_snowc, filter_snowc, top_as, dtime_mod)
+      call SnowCompaction(bounds, num_snowc, filter_snowc, top_as, dtime)
 
       ! Combine thin snow elements
       call CombineSnowLayers(bounds, num_snowc, filter_snowc, &
-           aerosol_vars, dtime_mod)
+           aerosol_vars, dtime)
 
       ! Divide thick snow elements
       if (.not. use_extrasnowlayers) then
          call DivideSnowLayers(bounds, num_snowc, filter_snowc, &
-           aerosol_vars,  is_lake=.false.)
-      
+              aerosol_vars,  is_lake=.false.)
       else
          call DivideExtraSnowLayers(bounds, num_snowc, filter_snowc, &
               aerosol_vars,  is_lake=.false.)
       endif
       
       ! Set empty snow layers to zero
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = -nlevsno+1,0
          do fc = 1, num_snowc
             c = filter_snowc(fc)
@@ -311,18 +327,16 @@ contains
 
       ! Build new snow filter
 
-      call BuildSnowFilter(num_nolakec, filter_nolakec, &
+      call BuildSnowFilter(bounds, num_nolakec, filter_nolakec, &
            num_snowc, filter_snowc, num_nosnowc, filter_nosnowc)
 
       ! For columns where snow exists, accumulate 'time-covered-by-snow' counters.
       ! Otherwise, re-zero counter, since it is bareland
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_snowc
          c = filter_snowc(fc)
-         snow_persistence(c) = snow_persistence(c) + dtime_mod
+         snow_persistence(c) = snow_persistence(c) + dtime
       end do
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_nosnowc
          c = filter_nosnowc(fc)
          snow_persistence(c) = 0._r8
@@ -330,28 +344,24 @@ contains
 
       ! Vertically average t_soisno and sum of h2osoi_liq and h2osoi_ice
       ! over all snow layers for history output
+
       do fc = 1, num_nolakec
          c = filter_nolakec(fc)
          snowice(c) = 0._r8
          snowliq(c) = 0._r8
       end do
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-      do fc = 1, num_snowc
-         c = filter_snowc(fc)
-         sum1 = 0._r8; sum2 = 0._r8;
-         !$acc loop vector reduction(+:sum1,sum2)
-         do j = -nlevsno+1, 0
+
+      do j = -nlevsno+1, 0
+         do fc = 1, num_snowc
+            c = filter_snowc(fc)
             if (j >= snl(c)+1) then
-               sum1 = sum1 + h2osoi_ice(c,j)
-               sum2 = sum2 + h2osoi_liq(c,j)
+               snowice(c) = snowice(c) + h2osoi_ice(c,j)
+               snowliq(c) = snowliq(c) + h2osoi_liq(c,j)
             end if
          end do
-         snowice(c) = sum1
-         snowliq(c) = sum2 
       end do
 
       ! Calculate column average snow depth
-      !$acc parallel loop independent gang vector default(present)
       do c = bounds%begc,bounds%endc
          snowdp(c) = snow_depth(c) * frac_sno_eff(c)
       end do
@@ -359,51 +369,54 @@ contains
       ! Determine ground temperature, ending water balance and volumetric soil water
       ! Calculate soil temperature and total water (liq+ice) in top 10cm of soil
       ! Calculate soil temperature and total water (liq+ice) in top 17cm of soil
-   
-      !NOTE: Reductions in this Loop!!!
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3) 
       do fc = 1, num_nolakec
          c = filter_nolakec(fc)
          l = col_pp%landunit(c)
          if (.not. lun_pp%urbpoi(l)) then
-            sum1 = 0._r8; sum2 = 0._r8; sum3 = 0._r8
-	         nlevbed = nlev2bed(c)
-            !$acc loop vector reduction(+:sum1,sum2,sum3)
-            do j = 1, nlevbed
+            t_soi_10cm(c) = 0._r8
+            tsoi17(c) = 0._r8
+            h2osoi_liqice_10cm(c) = 0._r8
+         end if
+      end do
+      do fc = 1, num_nolakec
+         c = filter_nolakec(fc)
+	       nlevbed = nlev2bed(c)
+         do j = 1, nlevbed
+            l = col_pp%landunit(c)
+            if (.not. lun_pp%urbpoi(l)) then
                ! soil T at top 17 cm added by F. Li and S. Levis
                if (zi(c,j) <= 0.17_r8) then
                   fracl = 1._r8
-                  sum1 = sum1 + t_soisno(c,j)*dz(c,j)*fracl
+                  tsoi17(c) = tsoi17(c) + t_soisno(c,j)*dz(c,j)*fracl
                else
                   if (zi(c,j) > 0.17_r8 .and. zi(c,j-1) < 0.17_r8) then
                      fracl = (0.17_r8 - zi(c,j-1))/dz(c,j)
-                     sum1 = sum1 + t_soisno(c,j)*dz(c,j)*fracl
+                     tsoi17(c) = tsoi17(c) + t_soisno(c,j)*dz(c,j)*fracl
                   end if
                end if
 
                if (zi(c,j) <= 0.1_r8) then
                   fracl = 1._r8
-                  sum2 = sum2 + t_soisno(c,j)*dz(c,j)*fracl
-                  sum3 = sum3 + (h2osoi_liq(c,j)+h2osoi_ice(c,j))* fracl
+                  t_soi_10cm(c) = t_soi_10cm(c) + t_soisno(c,j)*dz(c,j)*fracl
+                  h2osoi_liqice_10cm(c) = h2osoi_liqice_10cm(c) + &
+                       (h2osoi_liq(c,j)+h2osoi_ice(c,j))* &
+                       fracl
                else
                   if (zi(c,j) > 0.1_r8 .and. zi(c,j-1) < 0.1_r8) then
                      fracl = (0.1_r8 - zi(c,j-1))/dz(c,j)
-                     sum2 = sum2 + t_soisno(c,j)*dz(c,j)*fracl
-                     sum3 = sum3 + (h2osoi_liq(c,j)+h2osoi_ice(c,j))* fracl
+                     t_soi_10cm(c) = t_soi_10cm(c) + t_soisno(c,j)*dz(c,j)*fracl
+                     h2osoi_liqice_10cm(c) = h2osoi_liqice_10cm(c) + &
+                          (h2osoi_liq(c,j)+h2osoi_ice(c,j))* &
+                          fracl
                   end if
                end if
-               
-            end do
-            tsoi17(c) =  sum1 
-            t_soi_10cm(c) =  sum2
-            h2osoi_liqice_10cm(c) = sum3 
-         end if
+            end if
+         end do
       end do
-      
+
       ! TODO - if this block of code is moved out of here - the SoilHydrology
       ! will NOT effect t_grnd, t_grnd_u or t_grnd_r
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_nolakec
 
          c = filter_nolakec(fc)
@@ -430,7 +443,6 @@ contains
 
       end do
 
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = 1, nlevgrnd
          do fc = 1, num_nolakec
             c = filter_nolakec(fc)
@@ -446,12 +458,11 @@ contains
             end if
          end do
       end do
-      
+
       if ( (use_cn .or. use_fates) .and. &
          .not.(use_pflotran .and. pf_hmode) ) then
          ! Update soilpsi.
          ! ZMS: Note this could be merged with the following loop updating smp_l in the future.
-         !$acc parallel loop independent gang vector default(present) collapse(2) 
          do j = 1, nlevgrnd
             do fc = 1, num_hydrologyc
                c = filter_hydrologyc(fc)
@@ -479,34 +490,32 @@ contains
          ! Available soil water up to a depth of 0.05 m.
          ! Potentially available soil water (=whc) up to a depth of 0.05 m.
          ! Water content as fraction of whc up to a depth of 0.05 m.
-         
-         !$acc parallel loop independent gang worker default(present) private(sum1, sum2, sum3,c)
+
          do fc = 1, num_hydrologyc
             c = filter_hydrologyc(fc)
-            sum1 = 0._r8; sum2 = 0.0_r8;
-            sum3 = 0.0_r8 
+            rwat(c) = 0._r8
+            swat(c) = 0._r8
+            rz(c)   = 0._r8
+         end do
 
-            !$acc loop vector reduction(+:sum1,sum2,sum3)
-            do j = 1, nlevgrnd
+         do j = 1, nlevgrnd
+            do fc = 1, num_hydrologyc
+               c = filter_hydrologyc(fc)
+               !if (z(c,j)+0.5_r8*dz(c,j) <= 0.5_r8) then
                if (z(c,j)+0.5_r8*dz(c,j) <= 0.05_r8) then
                   watdry = watsat(c,j) * (316230._r8/sucsat(c,j)) ** (-1._r8/bsw(c,j))
-                  sum1 = sum1 + (h2osoi_vol(c,j)-watdry) * dz(c,j)
-                  sum2 = sum2 + (watsat(c,j)    -watdry) * dz(c,j)
-                  sum3 = sum3 + dz(c,j)
+                  rwat(c) = rwat(c) + (h2osoi_vol(c,j)-watdry) * dz(c,j)
+                  swat(c) = swat(c) + (watsat(c,j)    -watdry) * dz(c,j)
+                  rz(c) = rz(c) + dz(c,j)
                end if
             end do
-            rwat(fc) = sum1
-            swat(fc) = sum2 
-            rz(fc) = sum3  
-
          end do
 
-         !$acc parallel loop independent gang vector default(present)
          do fc = 1, num_hydrologyc
             c = filter_hydrologyc(fc)
-            if (rz(fc) /= 0._r8) then
-               tsw  = rwat(fc)/rz(fc)
-               stsw = swat(fc)/rz(fc)
+            if (rz(c) /= 0._r8) then
+               tsw  = rwat(c)/rz(c)
+               stsw = swat(c)/rz(c)
             else
                watdry = watsat(c,1) * (316230._r8/sucsat(c,1)) ** (-1._r8/bsw(c,1))
                tsw = h2osoi_vol(c,1) - watdry
@@ -515,30 +524,23 @@ contains
             wf(c) = tsw/stsw
          end do
 
-         !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3)
-         do fc = 1, num_hydrologyc
-            c = filter_hydrologyc(fc)
-            sum1 = 0._r8; sum2 = 0._r8; sum3=0._r8
-            !$acc loop vector reduction(+:sum1,sum2,sum3)
-            do j = 1, nlevgrnd
+         do j = 1, nlevgrnd
+            do fc = 1, num_hydrologyc
+               c = filter_hydrologyc(fc)
                if (z(c,j)+0.5_r8*dz(c,j) <= 0.17_r8) then
                   watdry = watsat(c,j) * (316230._r8/sucsat(c,j)) ** (-1._r8/bsw(c,j))
-                  sum1 = sum1 + (h2osoi_vol(c,j)-watdry) * dz(c,j)
-                  sum2 = sum2 + (watsat(c,j)    -watdry) * dz(c,j)
-                  sum3 = sum3 + dz(c,j)
+                  rwat(c) = rwat(c) + (h2osoi_vol(c,j)-watdry) * dz(c,j)
+                  swat(c) = swat(c) + (watsat(c,j)    -watdry) * dz(c,j)
+                  rz(c) = rz(c) + dz(c,j)
                end if
             end do
-            rwat(fc) = rwat(fc) + sum1
-            swat(fc) = swat(fc) + sum2
-            rz(fc)   = rz(fc)   + sum3
          end do
 
-         !$acc parallel loop independent gang vector default(present)
          do fc = 1, num_hydrologyc
             c = filter_hydrologyc(fc)
-            if (rz(fc) /= 0._r8) then
-               tsw  = rwat(fc)/rz(fc)
-               stsw = swat(fc)/rz(fc)
+            if (rz(c) /= 0._r8) then
+               tsw  = rwat(c)/rz(c)
+               stsw = swat(c)/rz(c)
             else
                watdry = watsat(c,1) * (316230._r8/sucsat(c,1)) ** (-1._r8/bsw(c,1))
                tsw = h2osoi_vol(c,1) - watdry
@@ -549,14 +551,12 @@ contains
       end if
 
       ! top-layer diagnostics
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_snowc
          c = filter_snowc(fc)
          h2osno_top(c)  = h2osoi_ice(c,snl(c)+1) + h2osoi_liq(c,snl(c)+1)
       enddo
 
       ! Zero variables in columns without snow
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_nosnowc
          c = filter_nosnowc(fc)
 
@@ -569,15 +569,6 @@ contains
          sno_liq_top(c)     = spval
       end do
 
-    !$acc exit data delete(&
-    !$acc rwat(:), &
-    !$acc swat(:), &
-    !$acc rz(:), &
-    !$acc psi, &
-    !$acc sum1, &
-    !$acc sum2, &
-    !$acc sum3)
-
     end associate
 
   end subroutine HydrologyNoDrainage
diff --git a/components/elm/src/biogeophys/LakeCon.F90 b/components/elm/src/biogeophys/LakeCon.F90
index 383abeced7..5ca5dc576e 100644
--- a/components/elm/src/biogeophys/LakeCon.F90
+++ b/components/elm/src/biogeophys/LakeCon.F90
@@ -2,7 +2,7 @@ module LakeCon
 
   !-----------------------------------------------------------------------
   ! !DESCRIPTION:
-  ! Module containing constants and parameters for the Lake code
+  ! Module containing constants and parameters for the Lake code 
   ! (CLM4-LISSS, documented in Subin et al. 2011, JAMES)
   ! Also contains time constant variables for Lake code
   ! Created by Zack Subin, 2011
@@ -22,18 +22,18 @@ module LakeCon
   !-----------------------------------------------------------------------
 
   !------------------------------------------------------------------
-  ! Lake Model non-tuneable constants
+  ! Lake Model non-tuneable constants 
   !------------------------------------------------------------------
 
   ! temperature of maximum water density (K)
   ! This is from Hostetler and Bartlein (1990); more updated sources suggest 277.13 K.
-  real(r8), parameter :: tdmax = 277._r8
+  real(r8), parameter :: tdmax = 277._r8   
 
   !------------------------------------------------------------------
-  ! Lake Model tuneable constants
+  ! Lake Model tuneable constants 
   !------------------------------------------------------------------
 
-  ! lake emissivity. This is used for both frozen and unfrozen lakes.
+  ! lake emissivity. This is used for both frozen and unfrozen lakes. 
   ! This is pulled in from CLM4 and the reference is unclear.
   real(r8), parameter :: emg_lake = 0.97_r8
 
@@ -41,15 +41,15 @@ module LakeCon
   ! absorbed in ~1 m of water (the surface layer za_lake).
   ! This is roughly the fraction over 700 nm but may depend on the details
   ! of atmospheric radiative transfer. As long as NIR = 700 nm and up, this can be zero.
-  real(r8) :: betavis = 0.0_r8
+  real(r8) :: betavis = 0.0_r8            
 
   ! Momentum Roughness length over frozen lakes without snow  (m)
   ! Typical value found in the literature, and consistent with Mironov expressions.
   ! See e.g. Morris EM 1989, Andreas EL 1987, Guest & Davidson 1991 (as cited in Vavrus 1996)
-  real(r8), parameter :: z0frzlake = 0.001_r8
+  real(r8), parameter :: z0frzlake = 0.001_r8  
 
   ! Base of surface light absorption layer for lakes (m)
-  real(r8), parameter :: za_lake = 0.6_r8
+  real(r8), parameter :: za_lake = 0.6_r8           
 
   ! For calculating prognostic roughness length
   real(r8), parameter :: cur0    = 0.01_r8  ! min. Charnock parameter
@@ -94,7 +94,7 @@ module LakeCon
   ! true => use old fcrit & minz0 as per Subin et al 2011 form
   ! See initLakeMod for details. Difference is very small for
   ! small lakes and negligible for large lakes. Currently hardwired off.
-  logical,  public :: lake_use_old_fcrit_minz0 = .false.
+  logical,  public :: lake_use_old_fcrit_minz0 = .false. 
 
   ! used in LakeTemperature
   ! Increase mixing by a large factor for deep lakes
@@ -102,10 +102,10 @@ module LakeCon
   ! See Subin et al 2011 (JAMES) for details
 
   ! (m) minimum lake depth to invoke deepmixing
-  real(r8), public :: deepmixing_depthcrit = 25._r8
+  real(r8), public :: deepmixing_depthcrit = 25._r8     
 
   ! factor to increase mixing by
-  real(r8), public :: deepmixing_mixfact   = 10._r8
+  real(r8), public :: deepmixing_mixfact   = 10._r8     
 
   ! true => Suppress enhanced diffusion. Small differences.
   ! Currently hardwired .false.
@@ -113,36 +113,19 @@ module LakeCon
   ! Enhanced diffusion is intended for under ice and at large depths.
   ! It is a much smaller change on its own than the "deepmixing"
   ! above, but it increases the effect of deepmixing under ice and for large depths.
-  logical,  public :: lake_no_ed = .false.
+  logical,  public :: lake_no_ed = .false.              
 
   ! puddling (not extensively tested and currently hardwired off)
   ! used in LakeTemperature and SurfaceAlbedo
 
   ! true => suppress convection when greater than minimum amount
   ! of ice is present. This also effectively sets lake_no_melt_icealb.
-  logical,  public :: lakepuddling = .false.
+  logical,  public :: lakepuddling = .false.            
 
   ! (m) minimum amount of total ice nominal thickness before
   ! convection is suppressed
-  real(r8), public :: lake_puddle_thick = 0.2_r8
+  real(r8), public :: lake_puddle_thick = 0.2_r8        
   !-----------------------------------------------------------------------
-  !$acc declare create(betavis)
-  !$acc declare copyin(z0frzlake)
-  !$acc declare copyin(za_lake)
-  !$acc declare copyin(cur0)
-  !$acc declare copyin(cus )
-  !$acc declare copyin(curm)
-  !$acc declare create(fcrit     )
-  !$acc declare create(minz0lake )
-  !$acc declare copyin(n2min)
-  !$acc declare copyin(lsadz)
-  !$acc declare create(pudz)
-  !$acc declare create(depthcrit)
-  !$acc declare create(mixfact)
-  !$acc declare copyin(lake_use_old_fcrit_minz0)
-  !$acc declare create(lakepuddling)
-  !$acc declare copyin(lake_puddle_thick)
-  !$acc declare create(lake_no_ed)
 
 contains
 
@@ -150,7 +133,7 @@ contains
   subroutine LakeConInit()
     !
     ! !DESCRIPTION:
-    ! Initialize time invariant variables for S Lake code
+    ! Initialize time invariant variables for S Lake code 
     !------------------------------------------------------------------------
 
     if (masterproc) write (iulog,*) 'Attempting to initialize time invariant variables for lakes'
@@ -159,18 +142,18 @@ contains
     if (lake_use_old_fcrit_minz0) then
        ! critical dimensionless fetch for Charnock parameter. From Vickers & Mahrt 1997
        ! but converted to use u instead of u* (Form used in Subin et al. 2011)
-       fcrit   = 22._r8
+       fcrit   = 22._r8 
 
        ! (m) Minimum allowed roughness length for unfrozen lakes.
        ! (Used in Subin et al. 2011)
-       minz0lake = 1.e-5_r8
+       minz0lake = 1.e-5_r8        
     else
        ! Vickers & Mahrt 1997
-       fcrit   = 100._r8
+       fcrit   = 100._r8  
 
        ! (m) Minimum allowed roughness length for unfrozen lakes.
        ! Now set low so it is only to avoid floating point exceptions.
-       minz0lake = 1.e-10_r8
+       minz0lake = 1.e-10_r8       
     end if
 
     if (lakepuddling) then
@@ -178,15 +161,15 @@ contains
        ! This option has not been extensively tested.
        ! This option turns on lake_no_melt_icealb, as the decrease in albedo will be based
        ! on whether there is water over nice, not purely a function of ice top temperature.
-       pudz = lake_puddle_thick
+       pudz = lake_puddle_thick    
     end if
 
     ! (m) Depth beneath which to increase mixing. See discussion in Subin et al. 2011
-    depthcrit = deepmixing_depthcrit
+    depthcrit = deepmixing_depthcrit 
 
     ! Mixing increase factor. ! Defaults are 25 m, increase by 10.
     ! Note some other namelists will be used directly in lake physics during model integration.
-    mixfact = deepmixing_mixfact
+    mixfact = deepmixing_mixfact 
 
     if (masterproc) write (iulog,*) 'Successfully initialized time invariant variables for lakes'
 
diff --git a/components/elm/src/biogeophys/LakeFluxesMod.F90 b/components/elm/src/biogeophys/LakeFluxesMod.F90
index 7fdd9ff77e..e2bf8e3fcb 100644
--- a/components/elm/src/biogeophys/LakeFluxesMod.F90
+++ b/components/elm/src/biogeophys/LakeFluxesMod.F90
@@ -14,6 +14,9 @@ module LakeFluxesMod
   use FrictionVelocityType , only : frictionvel_type
   use LakeStateType        , only : lakestate_type
   use SolarAbsorbedType    , only : solarabs_type
+  use TemperatureType      , only : temperature_type
+  use WaterfluxType        , only : waterflux_type
+  use WaterstateType       , only : waterstate_type
   use GridcellType         , only : grc_pp
   use TopounitDataType     , only : top_as, top_af ! atmospheric state and flux variables
   use ColumnType           , only : col_pp
@@ -33,8 +36,8 @@ module LakeFluxesMod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine LakeFluxes(num_lakep, filter_lakep, &
-       solarabs_vars, frictionvel_vars, &
+  subroutine LakeFluxes(bounds, num_lakec, filter_lakec, num_lakep, filter_lakep, &
+       atm2lnd_vars, solarabs_vars, frictionvel_vars, &
        energyflux_vars, lakestate_vars)
     !
     ! !DESCRIPTION:
@@ -44,112 +47,139 @@ contains
     ! WARNING: This subroutine assumes lake columns have one and only one pft.
     !
     ! !USES:
+      !$acc routine seq
+    use shr_flux_mod        , only : shr_flux_update_stress
     use elm_varpar          , only : nlevlak
     use elm_varcon          , only : hvap, hsub, hfus, cpair, cpliq, tkwat, tkice, tkair
     use elm_varcon          , only : sb, vkc, grav, denh2o, tfrz, spval, zsno
-    use elm_varctl          , only : use_lch4
+    use elm_varctl          , only : iulog, use_lch4, use_extrasnowlayers
     use LakeCon             , only : betavis, z0frzlake, tdmax, emg_lake
     use LakeCon             , only : lake_use_old_fcrit_minz0
     use LakeCon             , only : minz0lake, cur0, cus, curm, fcrit
     use QSatMod             , only : QSat
-    use FrictionVelocityMod , only : FrictionVelocity_noloop, MoninObukIni
+    use FrictionVelocityMod , only : FrictionVelocity, MoninObukIni, implicit_stress
+    use clm_time_manager    , only : get_nstep
     !
     ! !ARGUMENTS:
+    type(bounds_type)      , intent(in)    :: bounds
+    integer                , intent(in)    :: num_lakec         ! number of column non-lake points in column filter
+    integer                , intent(in)    :: filter_lakec(:)   ! column filter for non-lake points
     integer                , intent(in)    :: num_lakep         ! number of column non-lake points in pft filter
     integer                , intent(in)    :: filter_lakep(:)   ! patch filter for non-lake points
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(solarabs_type)    , intent(inout) :: solarabs_vars
     type(frictionvel_type) , intent(inout) :: frictionvel_vars
     type(energyflux_type)  , intent(inout) :: energyflux_vars
     type(lakestate_type)   , intent(inout) :: lakestate_vars
     !
     ! !LOCAL VARIABLES:
-    integer , parameter :: niters = 4      ! maximum number of iterations for surface temperature
-    real(r8), parameter :: beta1 = 1._r8   ! coefficient of convective velocity (in computing W_*) [-]
-    real(r8), parameter :: zii = 1000._r8  ! convective boundary height [m]
-    integer  :: i,fc,fp,g,t,c,p            ! do loop or array index
-    integer  :: iter                       ! iteration index
-    integer  :: nmozsgn    ! number of times moz changes sign
-    integer  :: jtop       ! top level for each column (no longer all 1)
-    real(r8) :: ax         ! used in iteration loop for calculating t_grnd (numerator of NR solution)
-    real(r8) :: bx         ! used in iteration loop for calculating t_grnd (denomin. of NR solution)
-    real(r8) :: degdT      ! d(eg)/dT
-    real(r8) :: dqh        ! diff of humidity between ref. height and surface
-    real(r8) :: dth        ! diff of virtual temp. between ref. height and surface
-    real(r8) :: dthv       ! diff of vir. poten. temp. between ref. height and surface
-    real(r8) :: dzsur      ! 1/2 the top layer thickness (m)
-    real(r8) :: eg         ! water vapor pressure at temperature T [pa]
-    real(r8) :: htvp      ! latent heat of vapor of water (or sublimation) [j/kg]
-    real(r8) :: obu       ! monin-obukhov length (m)
-    real(r8) :: obuold    ! monin-obukhov length of previous iteration
-    real(r8) :: qsatg     ! saturated humidity [kg/kg]
-    real(r8) :: qsatgdT   ! d(qsatg)/dT
+    real(r8), pointer :: z0mg_col(:)               ! roughness length over ground, momentum [m]
+    real(r8), pointer :: z0hg_col(:)               ! roughness length over ground, sensible heat [m]
+    real(r8), pointer :: z0qg_col(:)               ! roughness length over ground, latent heat [m]
+    real(r8), parameter :: dtaumin = 0.01_r8       ! max limit for stress convergence [Pa]
+    integer, parameter  :: itmax_expl = 4          ! maximum number of iterations with no tau update
+    integer, parameter  :: itmax_impl = 30         ! maximum number of iterations with tau update
+    real(r8), parameter :: beta1 = 1._r8           ! coefficient of convective velocity (in computing W_*) [-]
+    real(r8), parameter :: zii = 1000._r8          ! convective boundary height [m]
+    integer  :: i,fc,fp,g,t,c,p                    ! do loop or array index
+    integer  :: fncopy                             ! number of values in pft filter copy
+    integer  :: fnold                              ! previous number of pft filter values
+    integer  :: fpcopy(num_lakep)                  ! patch filter copy for iteration loop
+    integer  :: iter                               ! iteration index
+    integer  :: iter_final                         ! number of iterations used
+    integer  :: itmax                              ! maximum number of iterations
+    integer  :: nmozsgn(bounds%begp:bounds%endp)   ! number of times moz changes sign
+    integer  :: jtop(bounds%begc:bounds%endc)      ! top level for each column (no longer all 1)
+    real(r8) :: ax                                 ! used in iteration loop for calculating t_grnd (numerator of NR solution)
+    real(r8) :: bx                                 ! used in iteration loop for calculating t_grnd (denomin. of NR solution)
+    real(r8) :: degdT                              ! d(eg)/dT
+    real(r8) :: dqh(bounds%begp:bounds%endp)       ! diff of humidity between ref. height and surface
+    real(r8) :: dth(bounds%begp:bounds%endp)       ! diff of virtual temp. between ref. height and surface
+    real(r8) :: dthv                               ! diff of vir. poten. temp. between ref. height and surface
+    real(r8) :: dzsur(bounds%begc:bounds%endc)     ! 1/2 the top layer thickness (m)
+    real(r8) :: eg                                 ! water vapor pressure at temperature T [pa]
+    real(r8) :: htvp(bounds%begc:bounds%endc)      ! latent heat of vapor of water (or sublimation) [j/kg]
+    real(r8) :: obu(bounds%begp:bounds%endp)       ! monin-obukhov length (m)
+    real(r8) :: obuold(bounds%begp:bounds%endp)    ! monin-obukhov length of previous iteration
+    real(r8) :: qsatg(bounds%begc:bounds%endc)     ! saturated humidity [kg/kg]
+    real(r8) :: qsatgdT(bounds%begc:bounds%endc)   ! d(qsatg)/dT
     real(r8) :: qstar                              ! moisture scaling parameter
-    real(r8) :: ram       ! aerodynamical resistance [s/m]
-    real(r8) :: rah       ! thermal resistance [s/m]
-    real(r8) :: raw       ! moisture resistance [s/m]
-    real(r8) :: stftg3    ! derivative of fluxes w.r.t ground temperature
-    real(r8) :: temp1     ! relation for potential temperature profile
-    real(r8) :: temp12m   ! relation for potential temperature profile applied at 2-m
-    real(r8) :: temp2     ! relation for specific humidity profile
-    real(r8) :: temp22m   ! relation for specific humidity profile applied at 2-m
-    real(r8) :: tgbef     ! initial ground temperature
-    real(r8) :: thm       ! intermediate variable (forc_t+0.0098*forc_hgt_t_patch)
-    real(r8) :: thv       ! virtual potential temperature (kelvin)
-    real(r8) :: thvstar   ! virtual potential temperature scaling parameter
-    real(r8) :: tksur    ! thermal conductivity of snow/soil (w/m/kelvin)
-    real(r8) :: tsur     ! top layer temperature
-    real(r8) :: tstar    ! temperature scaling parameter
-    real(r8) :: um       ! wind speed including the stablity effect [m/s]
-    real(r8) :: ur       ! wind speed at reference height [m/s]
-    real(r8) :: ustar    ! friction velocity [m/s]
-    real(r8) :: wc       ! convective velocity [m/s]
-    real(r8) :: zeta     ! dimensionless height used in Monin-Obukhov theory
-    real(r8) :: zldis     ! reference height "minus" zero displacement height [m]
-    real(r8) :: displa    ! displacement (always zero) [m]
-    real(r8) :: z0mg      ! roughness length over ground, momentum [m]
-    real(r8) :: z0hg      ! roughness length over ground, sensible heat [m]
-    real(r8) :: z0qg      ! roughness length over ground, latent heat [m]
-    real(r8) :: u2m       ! 2 m wind speed (m/s)
-    real(r8) :: fm        ! needed for BGC only to diagnose 10m wind speed
-    real(r8) :: bw           ! partial density of water (ice + liquid)
-    real(r8) :: t_grnd_temp  ! Used in surface flux correction over frozen ground
-    real(r8) :: e_ref2m      ! 2 m height surface saturated vapor pressure [Pa]
-    real(r8) :: de2mdT       ! derivative of 2 m height surface saturated vapor pressure on t_ref2m
-    real(r8) :: qsat_ref2m   ! 2 m height surface saturated specific humidity [kg/kg]
-    real(r8) :: dqsat2mdT    ! derivative of 2 m height surface saturated specific humidity on t_ref2m
-    real(r8) :: sabg_nir     ! NIR that is absorbed (W/m^2)
+    real(r8) :: ram(bounds%begp:bounds%endp)       ! aerodynamical resistance [s/m]
+    real(r8) :: rah(bounds%begp:bounds%endp)       ! thermal resistance [s/m]
+    real(r8) :: raw(bounds%begp:bounds%endp)       ! moisture resistance [s/m]
+    real(r8) :: stftg3(bounds%begp:bounds%endp)    ! derivative of fluxes w.r.t ground temperature
+    real(r8) :: temp1(bounds%begp:bounds%endp)     ! relation for potential temperature profile
+    real(r8) :: temp12m(bounds%begp:bounds%endp)   ! relation for potential temperature profile applied at 2-m
+    real(r8) :: temp2(bounds%begp:bounds%endp)     ! relation for specific humidity profile
+    real(r8) :: temp22m(bounds%begp:bounds%endp)   ! relation for specific humidity profile applied at 2-m
+    real(r8) :: tgbef(bounds%begc:bounds%endc)     ! initial ground temperature
+    real(r8) :: thm(bounds%begp:bounds%endp)       ! intermediate variable (forc_t+0.0098*forc_hgt_t_patch)
+    real(r8) :: thv(bounds%begc:bounds%endc)       ! virtual potential temperature (kelvin)
+    real(r8) :: thvstar                            ! virtual potential temperature scaling parameter
+    real(r8) :: tksur(bounds%begc:bounds%endc)     ! thermal conductivity of snow/soil (w/m/kelvin)
+    real(r8) :: tsur(bounds%begc:bounds%endc)      ! top layer temperature
+    real(r8) :: tstar                              ! temperature scaling parameter
+    real(r8) :: um(bounds%begp:bounds%endp)        ! wind speed including the stablity effect [m/s]
+    real(r8) :: ur(bounds%begp:bounds%endp)        ! wind speed at reference height [m/s]
+    real(r8) :: ustar(bounds%begp:bounds%endp)     ! friction velocity [m/s]
+    real(r8) :: wc                                 ! convective velocity [m/s]
+    real(r8) :: zeta                               ! dimensionless height used in Monin-Obukhov theory
+    real(r8) :: zldis(bounds%begp:bounds%endp)     ! reference height "minus" zero displacement height [m]
+    real(r8) :: displa(bounds%begp:bounds%endp)    ! displacement (always zero) [m]
+    real(r8) :: z0mg(bounds%begp:bounds%endp)      ! roughness length over ground, momentum [m]
+    real(r8) :: z0hg(bounds%begp:bounds%endp)      ! roughness length over ground, sensible heat [m]
+    real(r8) :: z0qg(bounds%begp:bounds%endp)      ! roughness length over ground, latent heat [m]
+    real(r8) :: u2m                                ! 2 m wind speed (m/s)
+    real(r8) :: fm(bounds%begp:bounds%endp)        ! needed for BGC only to diagnose 10m wind speed
+    real(r8) :: bw                                 ! partial density of water (ice + liquid)
+    real(r8) :: t_grnd_temp                        ! Used in surface flux correction over frozen ground
+    real(r8) :: betaprime(bounds%begc:bounds%endc) ! Effective beta: sabg_lyr(p,jtop) for snow layers, beta otherwise
+    real(r8) :: e_ref2m                            ! 2 m height surface saturated vapor pressure [Pa]
+    real(r8) :: de2mdT                             ! derivative of 2 m height surface saturated vapor pressure on t_ref2m
+    real(r8) :: qsat_ref2m                         ! 2 m height surface saturated specific humidity [kg/kg]
+    real(r8) :: dqsat2mdT                          ! derivative of 2 m height surface saturated specific humidity on t_ref2m
+    real(r8) :: sabg_nir                           ! NIR that is absorbed (W/m^2)
 
     ! For calculating roughness lengths
-    real(r8) :: cur       ! Charnock parameter (-)
-    real(r8) :: fetch     ! Fetch (m)
-    real(r8) :: sqre0     ! root of roughness Reynolds number
+    real(r8) :: cur                                ! Charnock parameter (-)
+    real(r8) :: fetch(bounds%begc:bounds%endc)     ! Fetch (m)
+    real(r8) :: sqre0                              ! root of roughness Reynolds number
     real(r8), parameter :: kva0 = 1.51e-5_r8       ! kinematic viscosity of air (m^2/s) at 20C and 1.013e5 Pa
-    real(r8), parameter :: kva0temp = 20._r8 + tfrz! (K) temperature for kva0; will be set below
+    real(r8) :: kva0temp                           ! (K) temperature for kva0; will be set below
     real(r8), parameter :: kva0pres = 1.013e5_r8   ! (Pa) pressure for kva0
     real(r8) :: kva                                ! kinematic viscosity of air at ground temperature and forcing pressure
     real(r8), parameter :: prn = 0.713             ! Prandtl # for air at neutral stability
     real(r8), parameter :: sch = 0.66              ! Schmidt # for water in air at neutral stability
+    real(r8) :: wind_speed0(bounds%begp:bounds%endp) ! Wind speed from atmosphere at start of iteration
+    real(r8) :: wind_speed_adj(bounds%begp:bounds%endp) ! Adjusted wind speed for iteration
+    real(r8) :: tau(bounds%begp:bounds%endp)      ! Stress used in iteration
+    real(r8) :: tau_diff(bounds%begp:bounds%endp) ! Difference from previous iteration tau
+    real(r8) :: prev_tau(bounds%begp:bounds%endp) ! Previous iteration tau
+    real(r8) :: prev_tau_diff(bounds%begp:bounds%endp) ! Previous difference in iteration tau
     !-----------------------------------------------------------------------
 
-    associate(                                                           &
-         snl              =>    col_pp%snl                                , & ! Input:  [integer  (:)   ]  number of snow layers
-         dz               =>    col_pp%dz                                 , & ! Input:  [real(r8) (:,:) ]  layer thickness for soil or snow (m)
-         dz_lake          =>    col_pp%dz_lake                            , & ! Input:  [real(r8) (:,:) ]  layer thickness for lake (m)
-         lakedepth        =>    col_pp%lakedepth                          , & ! Input:  [real(r8) (:)   ]  variable lake depth (m)
-
-         forc_t           =>    top_as%tbot                            , & ! Input:  [real(r8) (:)   ]  atmospheric temperature (Kelvin)
-         forc_th          =>    top_as%thbot                           , & ! Input:  [real(r8) (:)   ]  atmospheric potential temperature (Kelvin)
-         forc_pbot        =>    top_as%pbot                            , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)
-         forc_q           =>    top_as%qbot                            , & ! Input:  [real(r8) (:)   ]  atmospheric specific humidity (kg/kg)
-         forc_rho         =>    top_as%rhobot                          , & ! Input:  [real(r8) (:)   ]  air density (kg/m**3)
-         forc_lwrad       =>    top_af%lwrad                           , & ! Input:  [real(r8) (:)   ]  downward infrared (longwave) radiation (W/m**2)
-         forc_snow        =>    top_af%snow                            , & ! Input:  [real(r8) (:)   ]  snow rate (kg H2O/m**2/s, or mm liquid H2O/s)
-         forc_rain        =>    top_af%rain                            , & ! Input:  [real(r8) (:)   ]  rain rate (kg H2O/m**2/s, or mm liquid H2O/s)
-         forc_u           =>    top_as%ubot                            , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in east direction (m/s)
-         forc_v           =>    top_as%vbot                            , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in north direction (m/s)
-
-         fsds_nir_d       =>    solarabs_vars%fsds_nir_d_patch         , & ! Input:  [real(r8) (:)   ]  incident direct beam nir solar radiation (W/m**2)
-         fsds_nir_i       =>    solarabs_vars%fsds_nir_i_patch         , & ! Input:  [real(r8) (:)   ]  incident diffuse nir solar radiation (W/m**2)
+    associate(                                                           & 
+         snl              =>    col_pp%snl                                , & ! Input:  [integer  (:)   ]  number of snow layers                              
+         dz               =>    col_pp%dz                                 , & ! Input:  [real(r8) (:,:) ]  layer thickness for soil or snow (m)            
+         dz_lake          =>    col_pp%dz_lake                            , & ! Input:  [real(r8) (:,:) ]  layer thickness for lake (m)                    
+         lakedepth        =>    col_pp%lakedepth                          , & ! Input:  [real(r8) (:)   ]  variable lake depth (m)                           
+         
+         forc_t           =>    top_as%tbot                            , & ! Input:  [real(r8) (:)   ]  atmospheric temperature (Kelvin)                  
+         forc_th          =>    top_as%thbot                           , & ! Input:  [real(r8) (:)   ]  atmospheric potential temperature (Kelvin)        
+         forc_pbot        =>    top_as%pbot                            , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)                         
+         forc_q           =>    top_as%qbot                            , & ! Input:  [real(r8) (:)   ]  atmospheric specific humidity (kg/kg)             
+         forc_rho         =>    top_as%rhobot                          , & ! Input:  [real(r8) (:)   ]  air density (kg/m**3)                                 
+         forc_lwrad       =>    top_af%lwrad                           , & ! Input:  [real(r8) (:)   ]  downward infrared (longwave) radiation (W/m**2)   
+         forc_snow        =>    top_af%snow                            , & ! Input:  [real(r8) (:)   ]  snow rate (kg H2O/m**2/s, or mm liquid H2O/s)                                  
+         forc_rain        =>    top_af%rain                            , & ! Input:  [real(r8) (:)   ]  rain rate (kg H2O/m**2/s, or mm liquid H2O/s)                                  
+         forc_u           =>    top_as%ubot                            , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in east direction (m/s)    
+         forc_v           =>    top_as%vbot                            , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in north direction (m/s)   
+         wsresp           =>    top_as%wsresp                          , & ! Input:  [real(r8) (:)   ]  response of wind to surface stress (m/s/Pa)
+         tau_est          =>    top_as%tau_est                         , & ! Input:  [real(r8) (:)   ]  approximate atmosphere change to zonal wind (m/s)
+         ugust            =>    top_as%ugust                           , & ! Input:  [real(r8) (:)   ]  gustiness from atmosphere (m/s)
+         
+         fsds_nir_d       =>    solarabs_vars%fsds_nir_d_patch         , & ! Input:  [real(r8) (:)   ]  incident direct beam nir solar radiation (W/m**2) 
+         fsds_nir_i       =>    solarabs_vars%fsds_nir_i_patch         , & ! Input:  [real(r8) (:)   ]  incident diffuse nir solar radiation (W/m**2)     
          fsr_nir_d        =>    solarabs_vars%fsr_nir_d_patch          , & ! Input:  [real(r8) (:)   ]  reflected direct beam nir solar radiation (W/m**2)
          fsr_nir_i        =>    solarabs_vars%fsr_nir_i_patch          , & ! Input:  [real(r8) (:)   ]  reflected diffuse nir solar radiation (W/m**2)
          sabg_lyr         =>    solarabs_vars%sabg_lyr_patch           , & ! Input:  [real(r8) (:,:) ]  absorbed solar radiation (pft,lyr) [W/m2]
@@ -168,11 +198,6 @@ contains
          forc_hgt_u_patch =>    frictionvel_vars%forc_hgt_u_patch      , & ! Input:  [real(r8) (:)   ]  observational height of wind at pft level [m]
          forc_hgt_t_patch =>    frictionvel_vars%forc_hgt_t_patch      , & ! Input:  [real(r8) (:)   ]  observational height of temperature at pft level [m]
          forc_hgt_q_patch =>    frictionvel_vars%forc_hgt_q_patch      , & ! Input:  [real(r8) (:)   ]  observational height of specific humidity at pft level [m]
-         vds              => frictionvel_vars%vds_patch        , & ! Output: [real(r8) (:) ] dry deposition velocity term (m/s) (for SO4 NH4NO3)
-         u10              => frictionvel_vars%u10_patch        , & ! Output: [real(r8) (:) ] 10-m wind (m/s) (for dust model)
-         u10_elm          => frictionvel_vars%u10_elm_patch    , & ! Output: [real(r8) (:) ] 10-m wind (m/s)
-         va               => frictionvel_vars%va_patch         , & ! Output: [real(r8) (:) ] atmospheric wind speed plus convective velocity (m/s)
-         fv               => frictionvel_vars%fv_patch         ,  & ! Output: [real(r8) (:) ] friction velocity (m/s) (for dust model)
 
          q_ref2m          =>    veg_ws%q_ref2m          , & ! Output: [real(r8) (:)   ]  2 m height surface specific humidity (kg/kg)
          rh_ref2m         =>    veg_ws%rh_ref2m         , & ! Output: [real(r8) (:)   ]  2 m height surface relative humidity (%)
@@ -202,26 +227,24 @@ contains
          taux             =>    veg_ef%taux             , & ! Output: [real(r8) (:)   ]  wind (shear) stress: e-w (kg/m/s**2)
          tauy             =>    veg_ef%tauy             , & ! Output: [real(r8) (:)   ]  wind (shear) stress: n-s (kg/m/s**2)
 
-         ks               =>    lakestate_vars%ks_col            , & ! Output: [real(r8) (:)   ]  coefficient passed to LakeTemperature
-         ws               =>    lakestate_vars%ws_col            , & ! Output: [real(r8) (:)   ]  surface friction velocity (m/s)
-         betaprime        =>    lakestate_vars%betaprime_col     , & ! Output: [real(r8) (:)   ]  fraction of solar rad absorbed at surface: equal to NIR fraction
-         ram1_lake        =>    lakestate_vars%ram1_lake_patch   , & ! Output: [real(r8) (:)   ]  aerodynamical resistance (s/m)
-         ust_lake         =>    lakestate_vars%ust_lake_col      , & ! Output: [real(r8) (:)   ]  friction velocity (m/s)
-         lake_raw         =>    lakestate_vars%lake_raw_col      , & ! Output: [real(r8) (:)   ]  aerodynamic resistance for moisture (s/m)
-         ! the following cause a crash if they are set as associated
-         z0mg_col         =>    frictionvel_vars%z0mg_col        , &
-         z0hg_col         =>    frictionvel_vars%z0hg_col        , &
-         z0qg_col         =>    frictionvel_vars%z0qg_col         &
+         ks               =>    lakestate_vars%ks_col                  , & ! Output: [real(r8) (:)   ]  coefficient passed to LakeTemperature
+         ws               =>    lakestate_vars%ws_col                  , & ! Output: [real(r8) (:)   ]  surface friction velocity (m/s)
+         betaprime        =>    lakestate_vars%betaprime_col           , & ! Output: [real(r8) (:)   ]  fraction of solar rad absorbed at surface: equal to NIR fraction
+         ram1_lake        =>    lakestate_vars%ram1_lake_patch         , & ! Output: [real(r8) (:)   ]  aerodynamical resistance (s/m)
+         ust_lake         =>    lakestate_vars%ust_lake_col            , & ! Output: [real(r8) (:)   ]  friction velocity (m/s)
+         lake_raw         =>    lakestate_vars%lake_raw_col            , & ! Output: [real(r8) (:)   ]  aerodynamic resistance for moisture (s/m)
+
+         begp             =>    bounds%begp                            , &
+         endp             =>    bounds%endp                              &
          )
 
+      ! the following cause a crash if they are set as associated
+      z0mg_col => frictionvel_vars%z0mg_col
+      z0hg_col => frictionvel_vars%z0hg_col
+      z0qg_col => frictionvel_vars%z0qg_col
 
+      kva0temp = 20._r8 + tfrz
 
-      ! kva0temp = 20._r8 + tfrz
-      !$acc parallel loop independent gang vector default(present) &
-      !$acc  private(p,c,t,g,eg, degdT, qsatg, qsatgdT, thv, dthv, zldis, &
-      !$acc  displa, z0mg, z0hg, z0qg, obu, iter, ur, um, ustar, &
-      !$acc  temp1, temp2, temp12m, temp22m,fm,e_ref2m, de2mdT, qsat_ref2m, dqsat2mdT) &
-      !$acc present(rh_ref2m(:)) 
       do fp = 1, num_lakep
          p = filter_lakep(fp)
          c = veg_pp%column(p)
@@ -238,47 +261,47 @@ contains
          ! depths less than 2% of their diameter.
 
          if (lakefetch(c) > 0._r8) then ! fetch available in surface data
-            fetch = lakefetch(c)
+            fetch(c) = lakefetch(c)
          else ! Estimate crudely based on lake depth
             if (lakedepth(c) < 4._r8) then
-               fetch = 100._r8 ! Roughly the smallest lakes resolveable in the GLWD
+               fetch(c) = 100._r8 ! Roughly the smallest lakes resolveable in the GLWD
             else
-               fetch = 25._r8*lakedepth(c)
+               fetch(c) = 25._r8*lakedepth(c)
             end if
          end if
 
          ! Initialize roughness lengths
 
          if (t_grnd(c) > tfrz) then   ! for unfrozen lake
-            z0mg = z0mg_col(c)
+            z0mg(p) = z0mg_col(c)
             kva = kva0 * (t_grnd(c)/kva0temp)**1.5_r8 * kva0pres/forc_pbot(t) ! kinematic viscosity of air
-            sqre0 = (max(z0mg*ust_lake(c)/kva,0.1_r8))**0.5_r8   ! Square root of roughness Reynolds number
-            z0hg = z0mg * exp( -vkc/prn*( 4._r8*sqre0 - 3.2_r8) ) ! SH roughness length
-            z0qg = z0mg * exp( -vkc/sch*( 4._r8*sqre0 - 4.2_r8) ) ! LH roughness length
-            z0qg = max(z0qg, minz0lake)
-            z0hg = max(z0hg, minz0lake)
+            sqre0 = (max(z0mg(p)*ust_lake(c)/kva,0.1_r8))**0.5_r8   ! Square root of roughness Reynolds number
+            z0hg(p) = z0mg(p) * exp( -vkc/prn*( 4._r8*sqre0 - 3.2_r8) ) ! SH roughness length
+            z0qg(p) = z0mg(p) * exp( -vkc/sch*( 4._r8*sqre0 - 4.2_r8) ) ! LH roughness length
+            z0qg(p) = max(z0qg(p), minz0lake)
+            z0hg(p) = max(z0hg(p), minz0lake)
          else if (snl(c) == 0) then    ! frozen lake with ice
-            z0mg = z0frzlake
-            z0hg = z0mg/exp(0.13_r8 * (ust_lake(c)*z0mg/1.5e-5_r8)**0.45_r8) ! Consistent with BareGroundFluxes
-            z0qg = z0hg
+            z0mg(p) = z0frzlake
+            z0hg(p) = z0mg(p)/exp(0.13_r8 * (ust_lake(c)*z0mg(p)/1.5e-5_r8)**0.45_r8) ! Consistent with BareGroundFluxes
+            z0qg(p) = z0hg(p)
          else                          ! use roughness over snow as in Biogeophysics1
-            z0mg = zsno
-            z0hg = z0mg/exp(0.13_r8 * (ust_lake(c)*z0mg/1.5e-5_r8)**0.45_r8) ! Consistent with BareGroundFluxes
-            z0qg = z0hg
+            z0mg(p) = zsno
+            z0hg(p) = z0mg(p)/exp(0.13_r8 * (ust_lake(c)*z0mg(p)/1.5e-5_r8)**0.45_r8) ! Consistent with BareGroundFluxes
+            z0qg(p) = z0hg(p)
          end if
 
          ! Surface temperature and fluxes
 
-         forc_hgt_u_patch(p) = forc_hgt_u_patch(p) + z0mg
-         forc_hgt_t_patch(p) = forc_hgt_t_patch(p) + z0mg
-         forc_hgt_q_patch(p) = forc_hgt_q_patch(p) + z0mg
+         forc_hgt_u_patch(p) = forc_hgt_u_patch(p) + z0mg(p)
+         forc_hgt_t_patch(p) = forc_hgt_t_patch(p) + z0mg(p)
+         forc_hgt_q_patch(p) = forc_hgt_q_patch(p) + z0mg(p)
 
          ! Find top layer
-         jtop = snl(c) + 1
+         jtop(c) = snl(c) + 1
 
          if (snl(c) < 0) then
-            betaprime(c) = sabg_lyr(p,jtop)/max(1.e-5_r8,sabg(p))  ! Assuming one pft
-            dzsur = dz(c,jtop)/2._r8
+            betaprime(c) = sabg_lyr(p,jtop(c))/max(1.e-5_r8,sabg(p))  ! Assuming one pft
+            dzsur(c) = dz(c,jtop(c))/2._r8
          else ! no snow layers
             ! Calculate the NIR fraction of absorbed solar.
             sabg_nir = fsds_nir_d(p) + fsds_nir_i(p) - fsr_nir_d(p) - fsr_nir_i(p)
@@ -286,7 +309,7 @@ contains
             betaprime(c) = sabg_nir/max(1.e-5_r8,sabg(p))
             ! Some fraction of the "visible" may be absorbed in the surface layer.
             betaprime(c) = betaprime(c) + (1._r8-betaprime(c))*betavis
-            dzsur = dz_lake(c,1)/2._r8
+            dzsur(c) = dz_lake(c,1)/2._r8
          end if
 
          sabg_chk(p)  = sabg(p)
@@ -295,148 +318,188 @@ contains
          ! Saturated vapor pressure, specific humidity and their derivatives
          ! at lake surface
 
-         call QSat(t_grnd(c), forc_pbot(t), eg, degdT, qsatg, qsatgdT)
+         call QSat(t_grnd(c), forc_pbot(t), eg, degdT, qsatg(c), qsatgdT(c))
 
          ! Potential, virtual potential temperature, and wind speed at the
          ! reference height
 
-         thm = forc_t(t) + 0.0098_r8*forc_hgt_t_patch(p)   ! intermediate variable
-         thv = forc_th(t)*(1._r8+0.61_r8*forc_q(t))     ! virtual potential T
+         thm(p) = forc_t(t) + 0.0098_r8*forc_hgt_t_patch(p)   ! intermediate variable
+         thv(c) = forc_th(t)*(1._r8+0.61_r8*forc_q(t))     ! virtual potential T
+      end do
+
+
+
+      do fp = 1, num_lakep
+         p = filter_lakep(fp)
+         c = veg_pp%column(p)
+         t = veg_pp%topounit(p)
+         g = veg_pp%gridcell(p)
 
-         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-         nmozsgn = 0
-         obuold = 0._r8
-         displa = 0._r8
+         nmozsgn(p) = 0
+         obuold(p) = 0._r8
+         displa(p) = 0._r8
 
          ! Latent heat
 
          if (t_grnd(c) > tfrz) then
-            htvp = hvap
+            htvp(c) = hvap
          else
-            htvp = hsub
+            htvp(c) = hsub
          end if
          ! Zack Subin, 3/26/09: Changed to ground temperature rather than the air temperature above.
 
          ! Initialize stability variables
 
-         ur    = max(1.0_r8,sqrt(forc_u(t)*forc_u(t)+forc_v(t)*forc_v(t)))
-         dth   = thm-t_grnd(c)
-         dqh   = forc_q(t)-qsatg
-         dthv     = dth*(1._r8+0.61_r8*forc_q(t))+0.61_r8*forc_th(t)*dqh
-         zldis = forc_hgt_u_patch(p) - 0._r8
+         ! Initialize winds for iteration.
+         if (implicit_stress) then
+            wind_speed0(p) = max(0.01_r8, hypot(forc_u(t), forc_v(t)))
+            wind_speed_adj(p) = wind_speed0(p)
+            ur(p) = max(1.0_r8, wind_speed_adj(p) + ugust(t))
+
+            prev_tau(p) = tau_est(t)
+         else
+            ur(p) = max(1.0_r8,sqrt(forc_u(t)*forc_u(t)+forc_v(t)*forc_v(t)) + ugust(t))
+         end if
+         tau_diff(p) = 1.e100_r8
+
+         dth(p)   = thm(p)-t_grnd(c)
+         dqh(p)   = forc_q(t)-qsatg(c)
+         dthv     = dth(p)*(1._r8+0.61_r8*forc_q(t))+0.61_r8*forc_th(t)*dqh(p)
+         zldis(p) = forc_hgt_u_patch(p) - 0._r8
 
          ! Initialize Monin-Obukhov length and wind speed
 
-         call MoninObukIni(ur, thv, dthv, zldis, z0mg, um, obu)
+         call MoninObukIni(ur(p), thv(c), dthv, zldis(p), z0mg(p), um(p), obu(p))
+      end do
 
       iter = 1
-      
+      fncopy = num_lakep
+      fpcopy(1:num_lakep) = filter_lakep(1:num_lakep)
+
       ! Begin stability iteration
-      
-      ITERATION : do while (iter <= niters )
+      if (implicit_stress) then
+         itmax = itmax_impl
+      else
+         itmax = itmax_expl
+      end if
+
+      ITERATION : do while (iter <= itmax .and. fncopy > 0)
 
          ! Determine friction velocity, and potential temperature and humidity
          ! profiles of the surface boundary layer
-         if (nmozsgn >= 3) iter = niters+1 ! stop iterating
 
-         call FrictionVelocity_noloop( &
-              displa, z0mg, z0hg, z0qg, &
-              obu, iter, ur, um, ustar, &
-              temp1, temp2, temp12m, temp22m, &
-              fm, forc_hgt_u_patch(p), forc_hgt_t_patch(p), forc_hgt_q_patch(p), &
-              vds(p), u10(p), u10_elm(p), va(p), fv(p))
+         call FrictionVelocity(begp, endp, fncopy, fpcopy, &
+              displa(begp:endp), z0mg(begp:endp), z0hg(begp:endp), z0qg(begp:endp), &
+              obu(begp:endp), iter, ur(begp:endp), um(begp:endp), ustar(begp:endp), &
+              temp1(begp:endp), temp2(begp:endp), temp12m(begp:endp), temp22m(begp:endp), &
+              fm(begp:endp), frictionvel_vars)
+
+         do fp = 1, fncopy
+            p = fpcopy(fp)
+            c = veg_pp%column(p)
+            t = veg_pp%topounit(p)
+            g = veg_pp%gridcell(p)
 
-            tgbef = t_grnd(c)
+            tgbef(c) = t_grnd(c)
             if (t_grnd(c) > tfrz .and. t_lake(c,1) > tfrz .and. snl(c) == 0) then
-               tksur = savedtke1(c)
+               tksur(c) = savedtke1(c)
                ! Set this to the eddy conductivity from the last
                ! timestep, as the molecular conductivity will be orders of magnitude too small.
                ! It will be initialized in initLakeMod to the molecular conductivity for the first timestep if arbinit.
-               tsur = t_lake(c,1)
+               tsur(c) = t_lake(c,1)
             else if (snl(c) == 0) then  !frozen but no snow layers
-               tksur = tkice   ! This is an approximation because the whole layer may not be frozen, and it is not
+               tksur(c) = tkice   ! This is an approximation because the whole layer may not be frozen, and it is not
                ! accounting for the physical (but not nominal) expansion of the frozen layer.
-               tsur = t_lake(c,1)
+               tsur(c) = t_lake(c,1)
             else
                !Need to calculate thermal conductivity of the top snow layer
-               bw = (h2osoi_ice(c,jtop)+h2osoi_liq(c,jtop))/dz(c,jtop)
-               tksur = tkair + (7.75e-5_r8 *bw + 1.105e-6_r8*bw*bw)*(tkice-tkair)
-               tsur = t_soisno(c,jtop)
+               bw = (h2osoi_ice(c,jtop(c))+h2osoi_liq(c,jtop(c)))/dz(c,jtop(c))
+               tksur(c) = tkair + (7.75e-5_r8 *bw + 1.105e-6_r8*bw*bw)*(tkice-tkair)
+               tsur(c) = t_soisno(c,jtop(c))
             end if
 
             ! Determine aerodynamic resistances
 
-            ram  = 1._r8/(ustar*ustar/um)
-            rah  = 1._r8/(temp1*ustar)
-            raw  = 1._r8/(temp2*ustar)
+            ram(p)  = 1._r8/(ustar(p)*ustar(p)/um(p))
+            rah(p)  = 1._r8/(temp1(p)*ustar(p))
+            raw(p)  = 1._r8/(temp2(p)*ustar(p))
             if (use_lch4) then
-               lake_raw(c) = raw ! Pass out for calculating ground ch4 conductance
+               lake_raw(c) = raw(p) ! Pass out for calculating ground ch4 conductance
             end if
-            ram1(p) = ram       ! pass value to global variable
+            ram1(p) = ram(p)       ! pass value to global variable
             ram1_lake(p) = ram1(p) ! for history
 
+            ! Calculate magnitude of stress and update wind speed.
+            if (implicit_stress) then
+               tau(p) = forc_rho(t)*wind_speed_adj(p)/ram(p)
+               call shr_flux_update_stress(wind_speed0(p), wsresp(t), tau_est(t), &
+                    tau(p), prev_tau(p), tau_diff(p), prev_tau_diff(p), &
+                    wind_speed_adj(p))
+               ur(p) = max(1.0_r8, wind_speed_adj(p) + ugust(t))
+            end if
+
             ! Get derivative of fluxes with respect to ground temperature
 
-            stftg3 = emg_lake*sb*tgbef*tgbef*tgbef
+            stftg3(p) = emg_lake*sb*tgbef(c)*tgbef(c)*tgbef(c)
 
-            ! Changed surface temperature from t_lake(c,1) to tsur.
+            ! Changed surface temperature from t_lake(c,1) to tsur(c).
             ! Also adjusted so that if there are snow layers present, the top layer absorption
             ! from SNICAR is assigned to the surface skin.
-            ax  = betaprime(c)*sabg(p) + emg_lake*forc_lwrad(t) + 3._r8*stftg3*tgbef &
-                 + forc_rho(t)*cpair/rah*thm &
-                 - htvp*forc_rho(t)/raw*(qsatg-qsatgdT*tgbef - forc_q(t)) &
-                 + tksur*tsur/dzsur
+            ax  = betaprime(c)*sabg(p) + emg_lake*forc_lwrad(t) + 3._r8*stftg3(p)*tgbef(c) &
+                 + forc_rho(t)*cpair/rah(p)*thm(p) &
+                 - htvp(c)*forc_rho(t)/raw(p)*(qsatg(c)-qsatgdT(c)*tgbef(c) - forc_q(t)) &
+                 + tksur(c)*tsur(c)/dzsur(c)
             !Changed sabg(p) to betaprime(c)*sabg(p).
-            bx  = 4._r8*stftg3 + forc_rho(t)*cpair/rah &
-                 + htvp*forc_rho(t)/raw*qsatgdT + tksur/dzsur
+            bx  = 4._r8*stftg3(p) + forc_rho(t)*cpair/rah(p) &
+                 + htvp(c)*forc_rho(t)/raw(p)*qsatgdT(c) + tksur(c)/dzsur(c)
 
             t_grnd(c) = ax/bx
             !prevent too large numerical step
-            if(t_grnd(c)>tgbef+20._r8)then
-              t_grnd(c)=tgbef+20._r8
-            elseif(t_grnd(c)<tgbef-20._r8)then
-              t_grnd(c)=tgbef-20._r8
+            if(t_grnd(c)>tgbef(c)+20._r8)then
+              t_grnd(c)=tgbef(c)+20._r8
+            elseif(t_grnd(c)<tgbef(c)-20._r8)then
+              t_grnd(c)=tgbef(c)-20._r8
             endif
             ! Update htvp
             if (t_grnd(c) > tfrz) then
-               htvp = hvap
+               htvp(c) = hvap
             else
-               htvp = hsub
+               htvp(c) = hsub
             end if
 
             ! Surface fluxes of momentum, sensible and latent heat
             ! using ground temperatures from previous time step
 
-            eflx_sh_grnd(p) = forc_rho(t)*cpair*(t_grnd(c)-thm)/rah
-            qflx_evap_soi(p) = forc_rho(t)*(qsatg+qsatgdT*(t_grnd(c)-tgbef)-forc_q(t))/raw
+            eflx_sh_grnd(p) = forc_rho(t)*cpair*(t_grnd(c)-thm(p))/rah(p)
+            qflx_evap_soi(p) = forc_rho(t)*(qsatg(c)+qsatgdT(c)*(t_grnd(c)-tgbef(c))-forc_q(t))/raw(p)
 
             ! Re-calculate saturated vapor pressure, specific humidity and their
             ! derivatives at lake surface
 
-            call QSat(t_grnd(c), forc_pbot(t), eg, degdT, qsatg, qsatgdT)
+            call QSat(t_grnd(c), forc_pbot(t), eg, degdT, qsatg(c), qsatgdT(c))
 
-            dth=thm-t_grnd(c)
-            dqh=forc_q(t)-qsatg
+            dth(p)=thm(p)-t_grnd(c)
+            dqh(p)=forc_q(t)-qsatg(c)
 
-            tstar = temp1*dth
-            qstar = temp2*dqh
+            tstar = temp1(p)*dth(p)
+            qstar = temp2(p)*dqh(p)
 
             thvstar=tstar*(1._r8+0.61_r8*forc_q(t)) + 0.61_r8*forc_th(t)*qstar
-            zeta=zldis*vkc * grav*thvstar/(ustar**2*thv)
+            zeta=zldis(p)*vkc * grav*thvstar/(ustar(p)**2*thv(c))
 
             if (zeta >= 0._r8) then     !stable
                zeta = min(2._r8,max(zeta,0.01_r8))
-               um = max(ur,0.1_r8)
+               um(p) = max(ur(p),0.1_r8)
             else                     !unstable
                zeta = max(-100._r8,min(zeta,-0.01_r8))
-               wc = beta1*(-grav*ustar*thvstar*zii/thv)**0.333_r8
-               um = sqrt(ur*ur+wc*wc)
+               wc = beta1*(-grav*ustar(p)*thvstar*zii/thv(c))**0.333_r8
+               um(p) = sqrt(ur(p)*ur(p)+wc*wc)
             end if
-            obu = zldis/zeta
+            obu(p) = zldis(p)/zeta
 
-            if (obuold*obu < 0._r8) nmozsgn = nmozsgn+1
+            if (obuold(p)*obu(p) < 0._r8) nmozsgn(p) = nmozsgn(p)+1
 
-            obuold = obu
+            obuold(p) = obu(p)
 
             if (t_grnd(c) > tfrz .and. snl(c) == 0) then ! t_grnd hasn't been corrected yet if snow layers but above frz
                ! Update roughness lengths using approach in Subin et al. 2011
@@ -445,40 +508,62 @@ contains
                   ! Original formulation in Subin et al. 2011; converted Vickers & Mahrt 1997 to use u instead of u*
                   ! assuming u = 0.1 u*.
                   ! That probably slightly overestimates the dimensionless fetch as u* is often smaller than 0.1 u
-                  cur = cur0 + curm* exp( max( -(fetch*grav/ur/ur)**(1._r8/3._r8)/fcrit, &   ! Fetch-limited
-                       -(lakedepth(c)*grav/ur/ur)**0.5_r8 ) )           ! depth-limited
+                  cur = cur0 + curm* exp( max( -(fetch(c)*grav/ur(p)/ur(p))**(1._r8/3._r8)/fcrit, &   ! Fetch-limited
+                       -(lakedepth(c)*grav/ur(p)/ur(p))**0.5_r8 ) )           ! depth-limited
                   ! In this case fcrit is 22, not 100 in elm_varcon
                else
                   ! Fetch relationship from Vickers & Mahrt 1997
-                  cur = cur0 + curm* exp( max( -(fetch*grav/ustar/ustar)**(1._r8/3._r8)/fcrit, &   ! Fetch-limited
-                       -(lakedepth(c)*grav/ur/ur)**0.5_r8 ) )           ! depth-limited
+                  cur = cur0 + curm* exp( max( -(fetch(c)*grav/ustar(p)/ustar(p))**(1._r8/3._r8)/fcrit, &   ! Fetch-limited
+                       -(lakedepth(c)*grav/ur(p)/ur(p))**0.5_r8 ) )           ! depth-limited
                end if
 
 
                kva = kva0 * (t_grnd(c)/kva0temp)**1.5_r8 * kva0pres/forc_pbot(t) ! kinematic viscosity of air
-               z0mg = max(cus*kva/max(ustar,1.e-4_r8), cur*ustar*ustar/grav) ! momentum roughness length
+               z0mg(p) = max(cus*kva/max(ustar(p),1.e-4_r8), cur*ustar(p)*ustar(p)/grav) ! momentum roughness length
                ! This lower limit on ustar is just to prevent floating point exceptions and
                ! should not be important
-               z0mg = max(z0mg, minz0lake) ! This limit is redundant with current values.
-               sqre0 = (max(z0mg*ustar/kva,0.1_r8))**0.5_r8   ! Square root of roughness Reynolds number
-               z0hg = z0mg * exp( -vkc/prn*( 4._r8*sqre0 - 3.2_r8) ) ! SH roughness length
-               z0qg = z0mg * exp( -vkc/sch*( 4._r8*sqre0 - 4.2_r8) ) ! LH roughness length
-               z0qg = max(z0qg, minz0lake)
-               z0hg = max(z0hg, minz0lake)
+               z0mg(p) = max(z0mg(p), minz0lake) ! This limit is redundant with current values.
+               sqre0 = (max(z0mg(p)*ustar(p)/kva,0.1_r8))**0.5_r8   ! Square root of roughness Reynolds number
+               z0hg(p) = z0mg(p) * exp( -vkc/prn*( 4._r8*sqre0 - 3.2_r8) ) ! SH roughness length
+               z0qg(p) = z0mg(p) * exp( -vkc/sch*( 4._r8*sqre0 - 4.2_r8) ) ! LH roughness length
+               z0qg(p) = max(z0qg(p), minz0lake)
+               z0hg(p) = max(z0hg(p), minz0lake)
             else if (snl(c) == 0) then
                ! in case it was above freezing and now below freezing
-               z0mg = z0frzlake
-               z0hg = z0mg/exp(0.13_r8 * (ustar*z0mg/1.5e-5_r8)**0.45_r8) ! Consistent with BareGroundFluxes
-               z0qg = z0hg
+               z0mg(p) = z0frzlake
+               z0hg(p) = z0mg(p)/exp(0.13_r8 * (ustar(p)*z0mg(p)/1.5e-5_r8)**0.45_r8) ! Consistent with BareGroundFluxes
+               z0qg(p) = z0hg(p)
             else ! Snow layers
                ! z0mg won't have changed
-               z0hg = z0mg/exp(0.13_r8 * (ustar*z0mg/1.5e-5_r8)**0.45_r8) ! Consistent with BareGroundFluxes
-               z0qg = z0hg
+               z0hg(p) = z0mg(p)/exp(0.13_r8 * (ustar(p)*z0mg(p)/1.5e-5_r8)**0.45_r8) ! Consistent with BareGroundFluxes
+               z0qg(p) = z0hg(p)
             end if
 
+         end do   ! end of filtered pft loop
+
+         iter_final = iter
          iter = iter + 1
+         if (iter <= itmax ) then
+            ! Rebuild copy of pft filter for next pass through the ITERATION loop
+
+            fnold = fncopy
+            fncopy = 0
+            do fp = 1, fnold
+               p = fpcopy(fp)
+               if (nmozsgn(p) < 3 .or. (implicit_stress .and. abs(tau_diff(p)) >= dtaumin)) then
+                  fncopy = fncopy + 1
+                  fpcopy(fncopy) = p
+               end if
+            end do   ! end of filtered pft loop
+         end if
 
-       end do ITERATION   ! end of stability iteration
+      end do ITERATION   ! end of stability iteration
+
+      do fp = 1, num_lakep
+         p = filter_lakep(fp)
+         c = veg_pp%column(p)
+         t = veg_pp%topounit(p)
+         g = veg_pp%gridcell(p)
 
          ! If there is snow on the ground or lake is frozen and t_grnd > tfrz: reset t_grnd = tfrz.
          ! Re-evaluate ground fluxes.
@@ -494,26 +579,26 @@ contains
          if ( (snl(c) < 0 .or. t_lake(c,1) <= tfrz) .and. t_grnd(c) > tfrz) then
             t_grnd_temp = t_grnd(c)
             t_grnd(c) = tfrz
-            eflx_sh_grnd(p) = forc_rho(t)*cpair*(t_grnd(c)-thm)/rah
-            qflx_evap_soi(p) = forc_rho(t)*(qsatg+qsatgdT*(t_grnd(c)-t_grnd_temp) - forc_q(t))/raw
+            eflx_sh_grnd(p) = forc_rho(t)*cpair*(t_grnd(c)-thm(p))/rah(p)
+            qflx_evap_soi(p) = forc_rho(t)*(qsatg(c)+qsatgdT(c)*(t_grnd(c)-t_grnd_temp) - forc_q(t))/raw(p)
          else if ( (t_lake(c,1) > t_grnd(c) .and. t_grnd(c) > tdmax) .or. &
               (t_lake(c,1) < t_grnd(c) .and. t_lake(c,1) > tfrz .and. t_grnd(c) < tdmax) ) then
             ! Convective mixing will occur at surface
             t_grnd_temp = t_grnd(c)
             t_grnd(c) = t_lake(c,1)
-            eflx_sh_grnd(p) = forc_rho(t)*cpair*(t_grnd(c)-thm)/rah
-            qflx_evap_soi(p) = forc_rho(t)*(qsatg+qsatgdT*(t_grnd(c)-t_grnd_temp) - forc_q(t))/raw
+            eflx_sh_grnd(p) = forc_rho(t)*cpair*(t_grnd(c)-thm(p))/rah(p)
+            qflx_evap_soi(p) = forc_rho(t)*(qsatg(c)+qsatgdT(c)*(t_grnd(c)-t_grnd_temp) - forc_q(t))/raw(p)
          end if
 
          ! Update htvp
          if (t_grnd(c) > tfrz) then
-            htvp = hvap
+            htvp(c) = hvap
          else
-            htvp = hsub
+            htvp(c) = hsub
          end if
 
          ! Net longwave from ground to atmosphere
-         ! eflx_lwrad_out(p) = (1._r8-emg_lake)*forc_lwrad(c) + stftg3*(-3._r8*tgbef+4._r8*t_grnd(c))
+         ! eflx_lwrad_out(p) = (1._r8-emg_lake)*forc_lwrad(c) + stftg3(p)*(-3._r8*tgbef(c)+4._r8*t_grnd(c))
          ! What is tgbef doing in this equation? Can't it be exact now? --Zack Subin, 4/14/09
 
          eflx_lwrad_out(p) = (1._r8-emg_lake)*forc_lwrad(t) + emg_lake*sb*t_grnd(c)**4._r8
@@ -521,7 +606,7 @@ contains
          ! Ground heat flux
 
          eflx_soil_grnd(p) = sabg(p) + forc_lwrad(t) - eflx_lwrad_out(p) - &
-              eflx_sh_grnd(p) - htvp*qflx_evap_soi(p)
+              eflx_sh_grnd(p) - htvp(c)*qflx_evap_soi(p)
          ! The original code in Biogeophysiclake had a bug that calculated incorrect fluxes but conserved energy.
          ! This is kept as the full sabg (not just that absorbed at surface) so that the energy balance check will be correct.
          !This is the effective energy flux into the ground including the lake [and now snow in CLM 4] solar absorption
@@ -529,21 +614,23 @@ contains
          ! The variable eflx_gnet will be used to pass the actual heat flux
          !from the ground interface into the lake.
 
-         !NOTE: ram could be raplaced with the global variabl and this done in the
-         !      last loop?
-         taux(p) = -forc_rho(t)*forc_u(t)/ram
-         tauy(p) = -forc_rho(t)*forc_v(t)/ram
+         taux(p) = -forc_rho(t)*forc_u(t)/ram(p)
+         tauy(p) = -forc_rho(t)*forc_v(t)/ram(p)
+         if (implicit_stress) then
+            taux(p) = taux(p) * (wind_speed_adj(p) / wind_speed0(p))
+            tauy(p) = tauy(p) * (wind_speed_adj(p) / wind_speed0(p))
+         end if
 
          eflx_sh_tot(p)   = eflx_sh_grnd(p)
          qflx_evap_tot(p) = qflx_evap_soi(p)
-         eflx_lh_tot(p)   = htvp*qflx_evap_soi(p)
-         eflx_lh_grnd(p)  = htvp*qflx_evap_soi(p)
+         eflx_lh_tot(p)   = htvp(c)*qflx_evap_soi(p)
+         eflx_lh_grnd(p)  = htvp(c)*qflx_evap_soi(p)
 
          ! 2 m height air temperature
-         t_ref2m(p) = thm + temp1*dth*(1._r8/temp12m - 1._r8/temp1)
+         t_ref2m(p) = thm(p) + temp1(p)*dth(p)*(1._r8/temp12m(p) - 1._r8/temp1(p))
 
          ! 2 m height specific humidity
-         q_ref2m(p) = forc_q(t) + temp2*dqh*(1._r8/temp22m - 1._r8/temp2)
+         q_ref2m(p) = forc_q(t) + temp2(p)*dqh(p)*(1._r8/temp22m(p) - 1._r8/temp2(p))
 
          ! 2 m height relative humidity
 
@@ -559,27 +646,38 @@ contains
          ! This is the actual heat flux from the ground interface into the lake, not including
          ! the light that penetrates the surface.
 
-         !u2m = max(1.0_r8,ustar/vkc*log(2._r8/z0mg))
+         !u2m = max(1.0_r8,ustar(p)/vkc*log(2._r8/z0mg(p)))
          ! u2 often goes below 1 m/s; it seems like the only reason for this minimum is to
          ! keep it from being zero in the ks equation below; 0.1 m/s is a better limit for
          ! stable conditions --ZS
-         u2m = max(0.1_r8,ustar/vkc*log(2._r8/z0mg))
+         u2m = max(0.1_r8,ustar(p)/vkc*log(2._r8/z0mg(p)))
 
          ws(c) = 1.2e-03_r8 * u2m
          ks(c) = 6.6_r8*sqrt(abs(sin(grc_pp%lat(g))))*(u2m**(-1.84_r8))
 
          ! Update column roughness lengths and friction velocity
-         z0mg_col(c) = z0mg
-         z0hg_col(c) = z0hg
-         z0qg_col(c) = z0qg
-         ust_lake(c) = ustar
-       enddo
-
-       !NOTE : this loop only uses global variables so keep it separate for potential
-       !       cache benefits?
-       !$acc parallel loop independent gang vector default(present) private(p,t)
-       do fp = 1, num_lakep
+         z0mg_col(c) = z0mg(p)
+         z0hg_col(c) = z0hg(p)
+         z0qg_col(c) = z0qg(p)
+         ust_lake(c) = ustar(p)
+
+         ! Check for convergence of stress.
+         if (implicit_stress .and. abs(tau_diff(p)) > dtaumin) then
+            if (get_nstep() > 0) then ! Suppress common warnings on the first time step.
+               write(iulog,*)'WARNING: Stress did not converge for lake ',&
+                    ' nstep = ',get_nstep(),' p= ',p,' prev_tau_diff= ',prev_tau_diff(p),&
+                    ' tau_diff= ',tau_diff(p),' tau= ',tau(p),&
+                    ' wind_speed_adj= ',wind_speed_adj(p),' iter_final= ',iter_final
+            end if
+         end if
+
+      end do
+
+      ! The following are needed for global average on history tape.
+
+      do fp = 1, num_lakep
          p = filter_lakep(fp)
+         c = veg_pp%column(p)
          t = veg_pp%topounit(p)
 
          t_veg(p) = forc_t(t)
@@ -588,10 +686,12 @@ contains
          qflx_dirct_rain(p) = 0._r8
          qflx_leafdrip(p) = 0._r8
 
-         ! Because they will be used in pft2col initialize here.
-         ! This will be overwritten in LakeHydrology
-         qflx_snwcp_ice(p) = 0._r8
-         qflx_snwcp_liq(p) = 0._r8
+         if (.not. use_extrasnowlayers) then
+            ! Because they will be used in pft2col initialize here.
+            ! This will be overwritten in LakeHydrology
+            qflx_snwcp_ice(p) = 0._r8
+            qflx_snwcp_liq(p) = 0._r8
+         end if
 
       end do
 
diff --git a/components/elm/src/biogeophys/LakeHydrologyMod.F90 b/components/elm/src/biogeophys/LakeHydrologyMod.F90
index d14892f6ec..72cc9bda28 100644
--- a/components/elm/src/biogeophys/LakeHydrologyMod.F90
+++ b/components/elm/src/biogeophys/LakeHydrologyMod.F90
@@ -26,6 +26,7 @@ module LakeHydrologyMod
   use VegetationDataType   , only : veg_ef, veg_wf
   use atm2lndType          , only : atm2lnd_type
   use AerosolType          , only : aerosol_type
+  use EnergyFluxType       , only : energyflux_type
   use FrictionVelocityType , only : frictionvel_type
   use LakeStateType        , only : lakestate_type
   use SoilStateType        , only : soilstate_type
@@ -49,7 +50,7 @@ contains
        num_lakec, filter_lakec, num_lakep, filter_lakep, &
        num_shlakesnowc, filter_shlakesnowc, num_shlakenosnowc, filter_shlakenosnowc, &
        atm2lnd_vars, soilstate_vars,  &
-       aerosol_vars, lakestate_vars)
+       energyflux_vars, aerosol_vars, lakestate_vars)
     !
     ! !DESCRIPTION:
     ! WARNING: This subroutine assumes lake columns have one and only one pft.
@@ -70,6 +71,7 @@ contains
     !    Cleanup and do water balance.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon      , only : denh2o, denice, spval, hfus, tfrz, cpliq, cpice
     use elm_varpar      , only : nlevsno, nlevgrnd, nlevsoi
     use elm_varctl      , only : iulog, use_extrasnowlayers, use_lake_wat_storage
@@ -77,7 +79,6 @@ contains
     use SnowHydrologyMod, only : SnowCompaction, CombineSnowLayers, SnowWater, BuildSnowFilter
     use SnowHydrologyMod, only : DivideSnowLayers, DivideExtraSnowLayers, SnowCapping
     use LakeCon         , only : lsadz
-    use abortutils , only : endrun 
     !
     ! !ARGUMENTS:
     type(bounds_type)      , intent(in)    :: bounds
@@ -91,26 +92,32 @@ contains
     integer                , intent(out)   :: filter_shlakenosnowc(:) ! column filter for non-snow points
     type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(soilstate_type)   , intent(in)    :: soilstate_vars
+    type(energyflux_type)  , intent(inout) :: energyflux_vars
     type(aerosol_type)     , intent(inout) :: aerosol_vars
     type(lakestate_type)   , intent(inout) :: lakestate_vars
+    real(r8)   :: dtime            ! land model time step (sec)
+
     !
     ! !LOCAL VARIABLES:
     integer  :: p,fp,g,t,l,c,j,fc,jtop                          ! indices
     integer  :: newnode                                         ! flag when new snow node is set, (1=yes, 0=no)
     real(r8) :: dz_snowf                                        ! layer thickness rate change due to precipitation [mm/s]
     real(r8) :: bifall                                          ! bulk density of newly fallen dry snow [kg/m3]
+    real(r8) :: fracsnow(bounds%begp:bounds%endp)               ! frac of precipitation that is snow
+    real(r8) :: fracrain(bounds%begp:bounds%endp)               ! frac of precipitation that is rain
+    real(r8) :: qflx_prec_grnd_snow(bounds%begp:bounds%endp)    ! snow precipitation incident on ground [mm/s]
+    real(r8) :: qflx_prec_grnd_rain(bounds%begp:bounds%endp)    ! rain precipitation incident on ground [mm/s]
     real(r8) :: qflx_evap_soi_lim                               ! temporary evap_soi limited by top snow layer content [mm/s]
     real(r8) :: qflx_snwcp                                      ! temporary snow cap flux
     real(r8) :: h2osno_temp                                     ! temporary h2osno [kg/m^2]
-    real(r8) :: sumsnowice(1:num_lakec)             ! sum of snow ice if snow layers found above unfrozen lake [kg/m&2]
-    logical  :: unfrozen(1:num_lakec)               ! true if top lake layer is unfrozen with snow layers above
+    real(r8) :: sumsnowice(bounds%begc:bounds%endc)             ! sum of snow ice if snow layers found above unfrozen lake [kg/m&2]
+    logical  :: unfrozen(bounds%begc:bounds%endc)               ! true if top lake layer is unfrozen with snow layers above
     real(r8) :: heatrem                                         ! used in case above [J/m^2]
-    real(r8) :: heatsum(1:num_lakec)                ! used in case above [J/m^2]
+    real(r8) :: heatsum(bounds%begc:bounds%endc)                ! used in case above [J/m^2]
     real(r8) :: snowmass                                        ! liquid+ice snow mass in a layer [kg/m2]
     real(r8) :: snowcap_scl_fct                                 ! temporary factor used to correct for snow capping
     real(r8), parameter :: snow_bd = 250._r8                    ! assumed snow bulk density (for lakes w/out resolved snow layers) [kg/m^3]
                                                                 ! Should only be used for frost below.
-    real(r8) :: sum1, sum2, sum3, sum4 
     !-----------------------------------------------------------------------
 
     associate(                                                            & 
@@ -212,35 +219,22 @@ contains
          begc => bounds%begc, &
          endc => bounds%endc  &
          )
-    !$acc enter data create(&
-    !$acc sumsnowice(:), &
-    !$acc unfrozen(:), &
-    !$acc heatsum(:), &
-    !$acc sum1, &
-    !$acc sum2, &
-    !$acc sum3 )
-      
+
+      ! Determine step size
+
+      dtime = dtime_mod
       ! Add soil water to water balance.
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3)
-      do fc = 1, num_lakec
-         c = filter_lakec(fc)
-         sum1 = 0._r8 
-         sum2 = 0._r8 
-         sum3 = 0._r8 
-         !$acc loop vector reduction(+:sum1,sum2,sum3)
-         do j = 1, nlevgrnd
-            sum1 = sum1 + h2osoi_ice(c,j) + h2osoi_liq(c,j)
-            sum2 = sum2 + h2osoi_liq(c,j)
-            sum3 = sum3 + h2osoi_ice(c,j)
+      do j = 1, nlevgrnd
+         do fc = 1, num_lakec
+            c = filter_lakec(fc)
+            begwb(c) = begwb(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)
+            h2osoi_liq_depth_intg(c) = h2osoi_liq_depth_intg(c) + h2osoi_liq(c,j)
+            h2osoi_ice_depth_intg(c) = h2osoi_ice_depth_intg(c) + h2osoi_ice(c,j)
          end do
-         begwb(c) = begwb(c) + sum1
-         h2osoi_liq_depth_intg(c) = h2osoi_liq_depth_intg(c) + sum2
-         h2osoi_ice_depth_intg(c) = h2osoi_ice_depth_intg(c) + sum3
       end do
 
       ! Add lake water storage to water balance.
       if (use_lake_wat_storage) then
-         !$acc parallel loop independent gang vector default(present)
          do fc = 1, num_lakec
             c = filter_lakec(fc)
             begwb(c) = begwb(c) + wslake(c)
@@ -250,33 +244,33 @@ contains
 
       !!!!!!!!!!!!!!!!!!!!!!!!!!!
       ! Do precipitation onto ground, etc., from CanopyHydrology
-      !$acc parallel loop independent gang vector default(present) 
+
       do fp = 1, num_lakep
          p = filter_lakep(fp)
          c = pcolumn(p)
          t = ptopounit(p)
 
-         ! qflx_prec_grnd_snow(p) = forc_snow(t)
-         ! qflx_prec_grnd_rain = forc_rain(t)
-         qflx_prec_grnd(p) = forc_snow(t) + forc_rain(t)
+         qflx_prec_grnd_snow(p) = forc_snow(t)
+         qflx_prec_grnd_rain(p) = forc_rain(t)
+         qflx_prec_grnd(p) = qflx_prec_grnd_snow(p) + qflx_prec_grnd_rain(p)
 
          qflx_dirct_rain(p) = 0._r8
          qflx_leafdrip(p) = 0._r8
          if (.not. use_extrasnowlayers) then
             if (do_capsnow(c)) then
-               qflx_snwcp_ice(p) = forc_snow(t)
-               qflx_snwcp_liq(p) = forc_rain(t)
+               qflx_snwcp_ice(p) = qflx_prec_grnd_snow(p)
+               qflx_snwcp_liq(p) = qflx_prec_grnd_rain(p)
                qflx_snow_grnd_patch(p) = 0._r8
                qflx_rain_grnd(p) = 0._r8
             else
                qflx_snwcp_ice(p) = 0._r8
                qflx_snwcp_liq(p) = 0._r8
-               qflx_snow_grnd_patch(p) = forc_snow(t)           ! ice onto ground (mm/s)
-               qflx_rain_grnd(p)     = forc_rain(t)           ! liquid water onto ground (mm/s)
+               qflx_snow_grnd_patch(p) = qflx_prec_grnd_snow(p)           ! ice onto ground (mm/s)
+               qflx_rain_grnd(p)     = qflx_prec_grnd_rain(p)           ! liquid water onto ground (mm/s)
             end if
          else
-            qflx_snow_grnd_patch(p) = forc_snow(t)           ! ice onto ground (mm/s)
-            qflx_rain_grnd(p)     = forc_rain(t)           ! liquid water onto ground (mm/s)
+            qflx_snow_grnd_patch(p) = qflx_prec_grnd_snow(p)           ! ice onto ground (mm/s)
+            qflx_rain_grnd(p)     = qflx_prec_grnd_rain(p)           ! liquid water onto ground (mm/s)
          end if
          ! Assuming one PFT; needed for below
          qflx_snow_grnd_col(c) = qflx_snow_grnd_patch(p)
@@ -285,7 +279,7 @@ contains
       end do ! (end pft loop)
 
       ! Determine snow height and snow water
-      !$acc parallel loop independent gang vector default(present) 
+
       do fc = 1, num_lakec
          c = filter_lakec(fc)
          t = col_pp%topounit(c)
@@ -305,8 +299,8 @@ contains
                bifall=50._r8
             end if
             dz_snowf = qflx_snow_grnd_col(c)/bifall
-            snow_depth(c) = snow_depth(c) + dz_snowf*dtime_mod
-            h2osno(c) = h2osno(c) + qflx_snow_grnd_col(c)*dtime_mod  ! snow water equivalent (mm)
+            snow_depth(c) = snow_depth(c) + dz_snowf*dtime
+            h2osno(c) = h2osno(c) + qflx_snow_grnd_col(c)*dtime  ! snow water equivalent (mm)
          end if
 
          ! When the snow accumulation exceeds 40 mm, initialize snow layer
@@ -327,26 +321,25 @@ contains
 
              ! intitialize SNICAR variables for fresh snow:
              !call aerosol_vars%Reset(column=c)
+             aerosol_vars%mss_bcpho_col(c,:)  = 0._r8
+             aerosol_vars%mss_bcphi_col(c,:)  = 0._r8
+             aerosol_vars%mss_bctot_col(c,:)  = 0._r8
              aerosol_vars%mss_bc_col_col(c)   = 0._r8
              aerosol_vars%mss_bc_top_col(c)   = 0._r8
+
+             aerosol_vars%mss_ocpho_col(c,:)  = 0._r8
+             aerosol_vars%mss_ocphi_col(c,:)  = 0._r8
+             aerosol_vars%mss_octot_col(c,:)  = 0._r8
              aerosol_vars%mss_oc_col_col(c)   = 0._r8
              aerosol_vars%mss_oc_top_col(c)   = 0._r8
+
+             aerosol_vars%mss_dst1_col(c,:)   = 0._r8
+             aerosol_vars%mss_dst2_col(c,:)   = 0._r8
+             aerosol_vars%mss_dst3_col(c,:)   = 0._r8
+             aerosol_vars%mss_dst4_col(c,:)   = 0._r8
+             aerosol_vars%mss_dsttot_col(c,:) = 0._r8
              aerosol_vars%mss_dst_col_col(c)  = 0._r8
              aerosol_vars%mss_dst_top_col(c)  = 0._r8
-             
-            !  do j = -nlevsno+1,0
-               aerosol_vars%mss_bcpho_col(c,:)  = 0._r8
-               aerosol_vars%mss_bcphi_col(c,:)  = 0._r8
-               aerosol_vars%mss_bctot_col(c,:)  = 0._r8
-               aerosol_vars%mss_ocpho_col(c,:)  = 0._r8
-               aerosol_vars%mss_ocphi_col(c,:)  = 0._r8
-               aerosol_vars%mss_octot_col(c,:)  = 0._r8
-               aerosol_vars%mss_dst1_col(c,:)   = 0._r8
-               aerosol_vars%mss_dst2_col(c,:)   = 0._r8
-               aerosol_vars%mss_dst3_col(c,:)   = 0._r8
-               aerosol_vars%mss_dst4_col(c,:)   = 0._r8
-               aerosol_vars%mss_dsttot_col(c,:) = 0._r8
-            !  end do 
              ! call waterstate_vars%Reset(column=c)
              col_ws%snw_rds(c,0) = snw_rds_min
 
@@ -357,14 +350,14 @@ contains
          ! later.
 
          if (snl(c) < 0 .and. newnode == 0) then
-            h2osoi_ice(c,snl(c)+1) = h2osoi_ice(c,snl(c)+1)+dtime_mod*qflx_snow_grnd_col(c)
-            dz(c,snl(c)+1) = dz(c,snl(c)+1)+dz_snowf*dtime_mod
+            h2osoi_ice(c,snl(c)+1) = h2osoi_ice(c,snl(c)+1)+dtime*qflx_snow_grnd_col(c)
+            dz(c,snl(c)+1) = dz(c,snl(c)+1)+dz_snowf*dtime
          end if
 
       end do
 
       ! Calculate sublimation and dew, adapted from HydrologyLake and Biogeophysics2.
-      !$acc parallel loop independent gang vector default(present) 
+
       do fp = 1,num_lakep
          p = filter_lakep(fp)
          c = pcolumn(p)
@@ -385,7 +378,7 @@ contains
                ! use the ratio of liquid to (liquid+ice) in the top layer to determine split
                ! Since we're not limiting evap over lakes, but still can't remove more from top
                ! snow layer than there is there, create temp. limited evap_soi.
-               qflx_evap_soi_lim = min(qflx_evap_soi(p), (h2osoi_liq(c,j)+h2osoi_ice(c,j))/dtime_mod)
+               qflx_evap_soi_lim = min(qflx_evap_soi(p), (h2osoi_liq(c,j)+h2osoi_ice(c,j))/dtime)
                if ((h2osoi_liq(c,j)+h2osoi_ice(c,j)) > 0._r8) then
                   qflx_evap_grnd(p) = max(qflx_evap_soi_lim*(h2osoi_liq(c,j)/(h2osoi_liq(c,j)+h2osoi_ice(c,j))), 0._r8)
                else
@@ -416,7 +409,7 @@ contains
             if (qflx_evap_soi(p) >= 0._r8) then
                ! Sublimation: do not allow for more sublimation than there is snow
                ! after melt.  Remaining surface evaporation used for infiltration.
-               qflx_sub_snow(p) = min(qflx_evap_soi(p), h2osno(c)/dtime_mod)
+               qflx_sub_snow(p) = min(qflx_evap_soi(p), h2osno(c)/dtime)
                qflx_evap_grnd(p) = qflx_evap_soi(p) - qflx_sub_snow(p)
             else
                if (t_grnd(c) < tfrz-0.1_r8) then
@@ -430,10 +423,19 @@ contains
 
             h2osno_temp = h2osno(c)
             if (do_capsnow(c) .and. .not. use_extrasnowlayers) then
+               h2osno(c) = h2osno(c) - qflx_sub_snow(p)*dtime
                qflx_snwcp_ice(p) = qflx_snwcp_ice(p) + qflx_dew_snow(p)
                qflx_snwcp_liq(p) = qflx_snwcp_liq(p) + qflx_dew_grnd(p)
+            else
+               h2osno(c) = h2osno(c) + (-qflx_sub_snow(p)+qflx_dew_snow(p))*dtime
+            end if
+            if (h2osno_temp > 0._r8) then
+               snow_depth(c) = snow_depth(c) * h2osno(c) / h2osno_temp
+            else
+               snow_depth(c) = h2osno(c)/snow_bd !Assume a constant snow bulk density = 250.
             end if
-            
+
+            h2osno(c) = max(h2osno(c), 0._r8)
          end if
 
          if (.not. use_extrasnowlayers) then
@@ -443,40 +445,10 @@ contains
 
       end do
 
-      !$acc parallel loop independent gang worker default(present) private(sum1,jtop,h2osno_temp)
-      do fc = 1, num_lakec
-         c = filter_lakec(fc)
-         jtop = snl(c)+1
-         
-         sum1 = 0._r8 
-         if(jtop > 0) then
-            h2osno_temp = h2osno(c)
-
-            !$acc loop vector reduction(+:sum1) 
-            do p = col_pp%pfti(c), col_pp%pftf(c)
-               if(veg_pp%active(p)) then
-                  if (do_capsnow(c) .and. .not. use_extrasnowlayers) then
-                     sum1 = sum1 - qflx_sub_snow(p)*dtime_mod
-                  else
-                     sum1 = sum1 + (-qflx_sub_snow(p)+qflx_dew_snow(p))*dtime_mod
-                  end if
-               end if
-            end do
-            h2osno(c) =  h2osno(c) + sum1 
-            if (h2osno_temp > 0._r8) then
-               snow_depth(c) = snow_depth(c) * h2osno(c) / h2osno_temp
-            else
-               snow_depth(c) = h2osno(c)/snow_bd !Assume a constant snow bulk density = 250.
-            end if
-            h2osno(c) = max(h2osno(c), 0._r8)
-         end if
-      end do 
-
       ! patch averages must be done here -- BEFORE SNOW CALCULATIONS AS THEY USE IT.
       ! for output to history tape and other uses
       ! (note that pft2col is called before LakeHydrology, so we can't use that routine
       ! to do these column -> pft averages)
-      !$acc parallel loop independent gang vector default(present) 
       do fp = 1,num_lakep
          p = filter_lakep(fp)
          c = pcolumn(p)
@@ -495,11 +467,10 @@ contains
       ! Determine initial snow/no-snow filters (will be modified possibly by
       ! routines CombineSnowLayers and DivideSnowLayers below)
 
-      call BuildSnowFilter( num_lakec, filter_lakec, &
+      call BuildSnowFilter(bounds, num_lakec, filter_lakec, &
            num_shlakesnowc, filter_shlakesnowc, num_shlakenosnowc, filter_shlakenosnowc)
 
       ! specify snow fraction
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_lakec
          c = filter_lakec(fc)
          if (h2osno(c) > 0.0_r8) then
@@ -525,9 +496,8 @@ contains
       ! pore space opens up. Conversely, if excess ice is melting and the liquid water exceeds the
       ! saturation value, then remove water.
 
-      ! changed to nlevsoi on 8/11/10 to make consistent with non-lake bedrock
-      !$acc parallel loop independent gang vector collapse(2) default(present) 
       do j = 1,nlevsoi  !nlevgrnd
+         ! changed to nlevsoi on 8/11/10 to make consistent with non-lake bedrock
          do fc = 1, num_lakec
             c = filter_lakec(fc)
 
@@ -563,12 +533,12 @@ contains
 
       ! Natural compaction and metamorphosis.
 
-      call SnowCompaction(bounds, num_shlakesnowc, filter_shlakesnowc,top_as, dtime_mod)
+      call SnowCompaction(bounds, num_shlakesnowc, filter_shlakesnowc,top_as, dtime)
 
       ! Combine thin snow elements
 
       call CombineSnowLayers(bounds, num_shlakesnowc, filter_shlakesnowc, &
-           aerosol_vars, dtime_mod)
+           aerosol_vars, dtime)
 
       ! Divide thick snow elements
       if (.not. use_extrasnowlayers) then
@@ -584,7 +554,6 @@ contains
       ! excessive because the fluxes were calculated with a fixed ground temperature of freezing, but the
       ! phase change was unable to restore the temperature to freezing.
 
-      !$acc parallel loop independent gang vector default(present) 
       do fp = 1, num_lakep
          p = filter_lakep(fp)
          c = pcolumn(p)
@@ -595,12 +564,12 @@ contains
             ! Remove layer
             ! Take extra heat of layer and release to sensible heat in order to maintain energy conservation.
             heatrem             = cpliq*h2osoi_liq(c,j)*(t_soisno(c,j) - tfrz)
-            eflx_sh_tot(p)      = eflx_sh_tot(p)    + heatrem/dtime_mod
-            eflx_sh_grnd(p)     = eflx_sh_grnd(p)   + heatrem/dtime_mod  ! Added this line 7/22/11 for consistency.
-            eflx_soil_grnd(p)   = eflx_soil_grnd(p) - heatrem/dtime_mod
-            eflx_gnet(p)        = eflx_gnet(p)      - heatrem/dtime_mod
+            eflx_sh_tot(p)      = eflx_sh_tot(p)    + heatrem/dtime
+            eflx_sh_grnd(p)     = eflx_sh_grnd(p)   + heatrem/dtime  ! Added this line 7/22/11 for consistency.
+            eflx_soil_grnd(p)   = eflx_soil_grnd(p) - heatrem/dtime
+            eflx_gnet(p)        = eflx_gnet(p)      - heatrem/dtime
 
-            eflx_grnd_lake(p)   = eflx_gnet(p) - heatrem/dtime_mod
+            eflx_grnd_lake(p)   = eflx_gnet(p) - heatrem/dtime
             qflx_sl_top_soil(c) = qflx_sl_top_soil(c) + h2osno(c)
             snl(c)              = 0
             h2osno(c)           = 0._r8
@@ -616,50 +585,47 @@ contains
       ! sufficient heat to melt the snow without freezing, then that will be done.
       ! Otherwise, the top layer will undergo freezing, but only if the top layer will
       ! not freeze completely.  Otherwise, let the snow layers persist and melt by diffusion.
-      !$acc parallel loop independent gang vector default(present) 
+
       do fc = 1, num_lakec
          c = filter_lakec(fc)
 
          if (t_lake(c,1) > tfrz .and. lake_icefrac(c,1) == 0._r8 .and. snl(c) < 0) then
-            unfrozen(fc) = .true.
+            unfrozen(c) = .true.
          else
-            unfrozen(fc) = .false.
+            unfrozen(c) = .false.
          end if
       end do
 
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-      do fc = 1, num_lakec
-         c = filter_lakec(fc)
+      do j = -nlevsno+1,0
+         do fc = 1, num_lakec
+            c = filter_lakec(fc)
 
-         if (unfrozen(fc)) then
-            sum1 = 0._r8 
-            sum2 = 0._r8
-            !$acc loop vector reduction(+:sum1,sum2)
-            do j = -nlevsno+1,0
+            if (unfrozen(c)) then
+               if (j == -nlevsno+1) then
+                  sumsnowice(c) = 0._r8
+                  heatsum(c) = 0._r8
+               end if
                if (j >= snl(c)+1) then
-                  sum1 = sum1 + h2osoi_ice(c,j)
-                  sum2 = sum2 + h2osoi_ice(c,j)*cpice*(tfrz - t_soisno(c,j)) &
+                  sumsnowice(c) = sumsnowice(c) + h2osoi_ice(c,j)
+                  heatsum(c) = heatsum(c) + h2osoi_ice(c,j)*cpice*(tfrz - t_soisno(c,j)) &
                        + h2osoi_liq(c,j)*cpliq*(tfrz - t_soisno(c,j))
                end if
-            end do
-            sumsnowice(fc) = sum1
-            heatsum(fc) = sum2 
-         end if
+            end if
+         end do
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_lakec
          c = filter_lakec(fc)
 
-         if (unfrozen(fc)) then
-            heatsum(fc) = heatsum(fc) + sumsnowice(fc)*hfus
-            heatrem = (t_lake(c,1) - tfrz)*cpliq*denh2o*dz_lake(c,1) - heatsum(fc)
+         if (unfrozen(c)) then
+            heatsum(c) = heatsum(c) + sumsnowice(c)*hfus
+            heatrem = (t_lake(c,1) - tfrz)*cpliq*denh2o*dz_lake(c,1) - heatsum(c)
 
             if (heatrem + denh2o*dz_lake(c,1)*hfus > 0._r8) then
                ! Remove snow and subtract the latent heat from the top layer.
-               qflx_snomelt(c) = qflx_snomelt(c) + h2osno(c)/dtime_mod
+               qflx_snomelt(c) = qflx_snomelt(c) + h2osno(c)/dtime
 
-               eflx_snomelt(c) = eflx_snomelt(c) + h2osno(c)*hfus/dtime_mod
+               eflx_snomelt(c) = eflx_snomelt(c) + h2osno(c)*hfus/dtime
 
                ! update snow melt for this case
                qflx_snow_melt(c)     = qflx_snow_melt(c)  + qflx_snomelt(c)
@@ -681,7 +647,7 @@ contains
       end do
 
       ! Set empty snow layers to zero
-      !$acc parallel loop independent gang vector collapse(2) default(present)
+
       do j = -nlevsno+1,0
          do fc = 1, num_shlakesnowc
             c = filter_shlakesnowc(fc)
@@ -698,94 +664,61 @@ contains
 
       ! Build new snow filter
 
-      call BuildSnowFilter(num_lakec, filter_lakec, &
+      call BuildSnowFilter(bounds, num_lakec, filter_lakec, &
            num_shlakesnowc, filter_shlakesnowc, num_shlakenosnowc, filter_shlakenosnowc)
-      
+
+      ! Vertically average t_soisno and sum of h2osoi_liq and h2osoi_ice
+      ! over all snow layers for history output
+
       do fc = 1, num_lakec
          c = filter_lakec(fc)
          snowice(c) = 0._r8
          snowliq(c) = 0._r8
       end do
 
-      ! Vertically average t_soisno and sum of h2osoi_liq and h2osoi_ice
-      ! over all snow layers for history output
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-      do fc = 1, num_shlakesnowc
-         c = filter_shlakesnowc(fc)
-         sum1 = 0._r8;
-         sum2 = 0._r8 
-         !$acc loop vector reduction(+:sum1,sum2)
-         do j = -nlevsno+1, 0
+      do j = -nlevsno+1, 0
+         do fc = 1, num_shlakesnowc
+            c = filter_shlakesnowc(fc)
             if (j >= snl(c)+1) then
-               sum1 = sum1 + h2osoi_ice(c,j)
-               sum2 = sum2 + h2osoi_liq(c,j)
+               snowice(c) = snowice(c) + h2osoi_ice(c,j)
+               snowliq(c) = snowliq(c) + h2osoi_liq(c,j)
             end if
          end do
-         snowice(c) = sum1 
-         snowliq(c) = sum2 
       end do
 
       ! Determine ending water balance and volumetric soil water
-      !$acc parallel loop independent gang worker default(present) private(sum1)
+
       do fc = 1, num_lakec
          c = filter_lakec(fc)
-         sum1 = h2osno(c)
-         !$acc loop vector reduction(+:sum1)
-         do j = 1, nlevgrnd
-            sum1 = sum1 + h2osoi_ice(c,j) + h2osoi_liq(c,j)
-         end do 
-         endwb(c) = sum1
+         endwb(c) = h2osno(c)
       end do
 
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = 1, nlevgrnd
          do fc = 1, num_lakec
             c = filter_lakec(fc)
+            endwb(c) = endwb(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)
             h2osoi_vol(c,j) = h2osoi_liq(c,j)/(dz(c,j)*denh2o) + h2osoi_ice(c,j)/(dz(c,j)*denice)
          end do
       end do
-      
-      !NOTE: Need to resolve the race condition here.  
-      !      Is it important to go through lake patches sequentially
-      !      for water storage? 
-      !      Currently num_lakec = num_lakep all timesteps?
-      !$acc parallel loop independent gang vector default(present) 
-      do fc = 1,num_lakec 
-         c = filter_lakec(fc)
-         g = col_pp%gridcell(c) 
-         t = col_pp%topounit(c) 
-          
+
+      do fp = 1,num_lakep
+         p = filter_lakep(fp)
+         c = pcolumn(p)
+         t = ptopounit(p)
+         g = pgridcell(p)
+
          qflx_drain_perched(c) = 0._r8
          qflx_h2osfc_surf(c)   = 0._r8
          qflx_rsub_sat(c)      = 0._r8
          qflx_infl(c)          = 0._r8
          qflx_surf(c)          = 0._r8
          qflx_drain(c)         = 0._r8
+         qflx_irrig(p)         = 0._r8
          qflx_irrig_col(c)     = 0._r8
 
-         qflx_floodc(c)    = qflx_floodg(g)
-         qflx_top_soil(c)  = forc_rain(t) + qflx_snomelt(c)
-
-      end do 
-
-      if(num_lakep .ne. num_lakec) then 
-         write(iulog,*) "num_lakep != num_lakec - may be race condition"
-         call endrun("LakeHydrology")
-      end if 
-
-      if(use_lake_wat_storage) then 
-         !$acc parallel loop independent gang vector default(present) 
-         do fp = 1, num_lakep 
-            p = filter_lakep(fp)
-            c = pcolumn(p) 
-            g = cgridcell(c) 
-            t = col_pp%topounit(c) 
-            
-            qflx_irrig(p)         = 0._r8
-            
-            ! Insure water balance using qflx_qrgwl
+         ! Insure water balance using qflx_qrgwl
+         if (use_lake_wat_storage) then
             qflx_qrgwl(c)     = 0._r8
-
             if (wslake(c) >= 5000._r8) then
                if (.not. use_extrasnowlayers) then
                   qflx_snwcp = qflx_snwcp_ice(p)
@@ -793,48 +726,34 @@ contains
                   qflx_snwcp = qflx_snwcp_ice_col(c)
                end if
                qflx_qrgwl(c) = forc_rain(t) + forc_snow(t) - qflx_evap_tot(p) - qflx_snwcp + &
-                              qflx_floodg(g) - (endwb(c) + wslake(c) -begwb(c))/dtime_mod
+               qflx_floodg(g) - (endwb(c) + wslake(c) -begwb(c))/dtime
             end if
             wslake(c) = (forc_rain(t) + forc_snow(t) - qflx_evap_tot(p) - &
-                qflx_snwcp_ice(p) + qflx_floodg(g) - qflx_qrgwl(c)) * dtime_mod - &
+                qflx_snwcp_ice(p) + qflx_floodg(g) - qflx_qrgwl(c)) * dtime - &
                 (endwb(c) - begwb(c))
             endwb(c) = endwb(c) + wslake(c)
-
-         end do 
-      else
-         ! NOTE: qrgwl calculation is un-predictable due to precision
-         !$acc parallel loop independent gang  vector default(present) 
-         do fp = 1,num_lakep
-            p = filter_lakep(fp)
-            c = pcolumn(p)
-            t = ptopounit(p)
-            g = pgridcell(p)
-
-            qflx_irrig(p)         = 0._r8
-
-            ! Insure water balance using qflx_qrgwl
+         else
             if (.not. use_extrasnowlayers) then
                qflx_snwcp = qflx_snwcp_ice(p)
             else
                qflx_snwcp = qflx_snwcp_ice_col(c)
             end if
             qflx_qrgwl(c) = forc_rain(t) + forc_snow(t) - qflx_evap_tot(p) - qflx_snwcp - &
-                (endwb(c)-begwb(c))/dtime_mod + qflx_floodg(g)
-            
-            qflx_runoff(c) = qflx_drain(c) + qflx_qrgwl(c)
-         enddo
+                (endwb(c)-begwb(c))/dtime + qflx_floodg(g)
+         end if
 
-      end if 
+         qflx_floodc(c)    = qflx_floodg(g)
+         qflx_runoff(c)    = qflx_drain(c) + qflx_qrgwl(c)
+         qflx_top_soil(c)  = qflx_prec_grnd_rain(p) + qflx_snomelt(c)
+      enddo
 
       ! top-layer diagnostics
-      !$acc parallel loop independent gang vector default(present) 
       do fc = 1, num_shlakesnowc
          c = filter_shlakesnowc(fc)
          h2osno_top(c)  = h2osoi_ice(c,snl(c)+1) + h2osoi_liq(c,snl(c)+1)
       end do
 
       ! Zero variables in columns without snow
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_shlakenosnowc
          c = filter_shlakenosnowc(fc)
 
@@ -847,13 +766,6 @@ contains
          sno_liq_top(c)     = spval
       end do
 
-    !$acc exit data delete(&
-    !$acc sumsnowice(:), &
-    !$acc unfrozen(:), &
-    !$acc heatsum(:), &
-    !$acc sum1, &
-    !$acc sum2, sum3)
-
     end associate
 
   end subroutine LakeHydrology
diff --git a/components/elm/src/biogeophys/LakeTemperatureMod.F90 b/components/elm/src/biogeophys/LakeTemperatureMod.F90
index 66bdc4be45..13ed09d1df 100644
--- a/components/elm/src/biogeophys/LakeTemperatureMod.F90
+++ b/components/elm/src/biogeophys/LakeTemperatureMod.F90
@@ -1,5 +1,7 @@
 module LakeTemperatureMod
 
+#include "shr_assert.h"
+
   !-----------------------------------------------------------------------
   ! !DESCRIPTION:
   ! Calculates surface fluxes and temperature for lakes.
@@ -10,6 +12,7 @@ module LakeTemperatureMod
   use shr_log_mod       , only : errMsg => shr_log_errMsg
   use decompMod         , only : bounds_type
   use CH4Mod            , only : ch4_type
+  use EnergyFluxType    , only : energyflux_type
   use LakeStateType     , only : lakestate_type
   use SoilStateType     , only : soilstate_type
   use SolarAbsorbedType , only : solarabs_type
@@ -38,7 +41,7 @@ contains
   !-----------------------------------------------------------------------
   subroutine LakeTemperature(bounds, num_lakec, filter_lakec, num_lakep, filter_lakep, &
        solarabs_vars, soilstate_vars, ch4_vars, &
-       lakestate_vars)
+       energyflux_vars, lakestate_vars)
     !
     ! !DESCRIPTION:
     ! Calculates temperatures in the 25-45 layer column of (possible) snow,
@@ -104,6 +107,7 @@ contains
     !      and dump small imbalance into sensible heat, or pass large errors to BalanceCheckMod for abort.
     !
     ! !USES:
+      !$acc routine seq
     use LakeCon            , only : betavis, za_lake, n2min, tdmax, pudz, depthcrit, mixfact
     use LakeCon            , only : lakepuddling, lake_no_ed
     use QSatMod            , only : QSat
@@ -122,12 +126,14 @@ contains
     type(solarabs_type)    , intent(in)    :: solarabs_vars
     type(soilstate_type)   , intent(in)    :: soilstate_vars
     type(ch4_type)         , intent(inout) :: ch4_vars
+    type(energyflux_type)  , intent(inout) :: energyflux_vars
     type(lakestate_type)   , intent(inout) :: lakestate_vars
+    real(r8)  :: dtime
     !
     ! !LOCAL VARIABLES:
     real(r8), parameter :: p0 = 1._r8                                      ! neutral value of turbulent prandtl number
     integer  :: i,j,fc,fp,g,c,p                                            ! do loop or array index
-   !  real(r8) :: beta(1:num_lakec)                              ! fraction of solar rad absorbed at surface: equal to NIR fraction
+    real(r8) :: beta(bounds%begc:bounds%endc)                              ! fraction of solar rad absorbed at surface: equal to NIR fraction
                                                                            ! of surface absorbed shortwave
     real(r8) :: eta                                                        ! light extinction coefficient (/m): depends on lake type
     real(r8) :: cwat                                                       ! specific heat capacity of water (j/m**3/kelvin)
@@ -137,84 +143,83 @@ contains
                                                                            ! using water density as above
     real(r8) :: km                                                         ! molecular diffusion coefficient (m**2/s)
     real(r8) :: tkice_eff                                                  ! effective conductivity since layer depth is constant
-    real(r8) :: a(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)     ! "a" vector for tridiagonal matrix
-    real(r8) :: b(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)     ! "b" vector for tridiagonal matrix
-    real(r8) :: c1(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)    ! "c" vector for tridiagonal matrix
-    real(r8) :: r(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)     ! "r" vector for tridiagonal solution
-    real(r8) :: rhow(1:num_lakec,nlevlak)                      ! density of water (kg/m**3)
-    real(r8) :: phi(1:num_lakec,nlevlak)                       ! solar radiation absorbed by layer (w/m**2)
-    real(r8) :: kme(1:num_lakec,nlevlak)                       ! molecular + eddy diffusion coefficient (m**2/s)
-    real(r8) :: rsfin                                          ! relative flux of solar radiation into layer
-    real(r8) :: rsfout                                         ! relative flux of solar radiation out of layer
-    real(r8) :: phi_soil(1:num_lakec)                          ! solar radiation into top soil layer (W/m**2)
-    real(r8) :: ri                                             ! richardson number
-    real(r8) :: fin(1:num_lakec)                               ! net heat flux into lake at ground interface (w/m**2)
-    real(r8) :: ocvts(1:num_lakec)                             ! (cwat*(t_lake[n  ])*dz
-    real(r8) :: ncvts(1:num_lakec)                             ! (cwat*(t_lake[n+1])*dz
-    real(r8) :: ke                                             ! eddy diffusion coefficient (m**2/s)
-    real(r8) :: zin                                            ! depth at top of layer (m)
-    real(r8) :: zout                                           ! depth at bottom of layer (m)
-    real(r8) :: drhodz                                         ! d [rhow] /dz (kg/m**4)
-    real(r8) :: n2                                             ! brunt-vaisala frequency (/s**2)
-    real(r8) :: num                                            ! used in calculating ri
-    real(r8) :: den                                            ! used in calculating ri
-    real(r8) :: tav_froz(1:num_lakec)                          ! used in aver temp for convectively mixed layers (C)
-    real(r8) :: tav_unfr(1:num_lakec)                          ! "
-    real(r8) :: nav(1:num_lakec)                               ! used in aver temp for convectively mixed layers
-    real(r8) :: phidum                                         ! temporary value of phi
-    real(r8) :: iceav(1:num_lakec)                             ! used in calc aver ice for convectively mixed layers
-    real(r8) :: qav(1:num_lakec)                               ! used in calc aver heat content for conv. mixed layers
-    integer  :: jtop(1:num_lakec)                              ! top level for each column (no longer all 1)
-    real(r8) :: cv(1:num_lakec,-nlevsno+1:nlevgrnd)           ! heat capacity of soil/snow [J/(m2 K)]
-    real(r8) :: tk(1:num_lakec,-nlevsno+1:nlevgrnd)           ! thermal conductivity of soil/snow [W/(m K)]
-                                                              ! (at interface below, except for j=0)
-    real(r8) :: cv_lake(1:num_lakec,1:nlevlak)                ! heat capacity [J/(m2 K)]
-    real(r8) :: tk_lake(1:num_lakec,1:nlevlak)                ! thermal conductivity at layer node [W/(m K)]
-    real(r8) :: cvx (1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)  ! heat capacity for whole column [J/(m2 K)]
-    real(r8) :: tkix(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)  ! thermal conductivity at layer interfaces
-                                                               ! for whole column [W/(m K)]
-    real(r8) :: tx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)    ! temperature of whole column [K]
-    real(r8) :: tktopsoillay(1:num_lakec)                      ! thermal conductivity [W/(m K)]
-    real(r8) :: fnx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)   ! heat diffusion through the layer interface below [W/m2]
-    real(r8) :: phix(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)  ! solar source term for whole column [W/m**2]
-    real(r8) :: zx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)    ! interface depth (+ below surface) for whole column [m]
-    real(r8) :: dzm                                            ! used in computing tridiagonal matrix [m]
-    real(r8) :: dzp                                            ! used in computing tridiagonal matrix [m]
-    integer  :: jprime                                         ! j - nlevlak
-    real(r8) :: factx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd) ! coefficient used in computing tridiagonal matrix
-    !NOTE: replace zsum with a scalar !
-    real(r8) :: zsum(1:num_lakec)                              ! temp for putting ice at the top during convection (m)
-
-    !NOTE: sabg_lyr_col seems poorly implemented
-    real(r8) :: sabg_lyr_col(1:num_lakec,-nlevsno+1:1)         ! absorbed ground solar in layer for column (W/m^2)
+    real(r8) :: a(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)     ! "a" vector for tridiagonal matrix
+    real(r8) :: b(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)     ! "b" vector for tridiagonal matrix
+    real(r8) :: c1(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)    ! "c" vector for tridiagonal matrix
+    real(r8) :: r(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)     ! "r" vector for tridiagonal solution
+    real(r8) :: rhow(bounds%begc:bounds%endc,nlevlak)                      ! density of water (kg/m**3)
+    real(r8) :: phi(bounds%begc:bounds%endc,nlevlak)                       ! solar radiation absorbed by layer (w/m**2)
+    real(r8) :: kme(bounds%begc:bounds%endc,nlevlak)                       ! molecular + eddy diffusion coefficient (m**2/s)
+    real(r8) :: rsfin                                                      ! relative flux of solar radiation into layer
+    real(r8) :: rsfout                                                     ! relative flux of solar radiation out of layer
+    real(r8) :: phi_soil(bounds%begc:bounds%endc)                          ! solar radiation into top soil layer (W/m**2)
+    real(r8) :: ri                                                         ! richardson number
+    real(r8) :: fin(bounds%begc:bounds%endc)                               ! net heat flux into lake at ground interface (w/m**2)
+    real(r8) :: ocvts(bounds%begc:bounds%endc)                             ! (cwat*(t_lake[n  ])*dz
+    real(r8) :: ncvts(bounds%begc:bounds%endc)                             ! (cwat*(t_lake[n+1])*dz
+    real(r8) :: ke                                                         ! eddy diffusion coefficient (m**2/s)
+    real(r8) :: zin                                                        ! depth at top of layer (m)
+    real(r8) :: zout                                                       ! depth at bottom of layer (m)
+    real(r8) :: drhodz                                                     ! d [rhow] /dz (kg/m**4)
+    real(r8) :: n2                                                         ! brunt-vaisala frequency (/s**2)
+    real(r8) :: num                                                        ! used in calculating ri
+    real(r8) :: den                                                        ! used in calculating ri
+    real(r8) :: tav_froz(bounds%begc:bounds%endc)                          ! used in aver temp for convectively mixed layers (C)
+    real(r8) :: tav_unfr(bounds%begc:bounds%endc)                          ! "
+    real(r8) :: nav(bounds%begc:bounds%endc)                               ! used in aver temp for convectively mixed layers
+    real(r8) :: phidum                                                     ! temporary value of phi
+    real(r8) :: iceav(bounds%begc:bounds%endc)                             ! used in calc aver ice for convectively mixed layers
+    real(r8) :: qav(bounds%begc:bounds%endc)                               ! used in calc aver heat content for conv. mixed layers
+    integer  :: jtop(bounds%begc:bounds%endc)                              ! top level for each column (no longer all 1)
+    real(r8) :: cv (bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)           ! heat capacity of soil/snow [J/(m2 K)]
+    real(r8) :: tk (bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)           ! thermal conductivity of soil/snow [W/(m K)]
+                                                                           ! (at interface below, except for j=0)
+    real(r8) :: cv_lake (bounds%begc:bounds%endc,1:nlevlak)                ! heat capacity [J/(m2 K)]
+    real(r8) :: tk_lake (bounds%begc:bounds%endc,1:nlevlak)                ! thermal conductivity at layer node [W/(m K)]
+    real(r8) :: cvx (bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)  ! heat capacity for whole column [J/(m2 K)]
+    real(r8) :: tkix(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)  ! thermal conductivity at layer interfaces
+                                                                           ! for whole column [W/(m K)]
+    real(r8) :: tx(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)    ! temperature of whole column [K]
+    real(r8) :: tktopsoillay(bounds%begc:bounds%endc)                      ! thermal conductivity [W/(m K)]
+    real(r8) :: fnx(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)   ! heat diffusion through the layer interface below [W/m2]
+    real(r8) :: phix(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)  ! solar source term for whole column [W/m**2]
+    real(r8) :: zx(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd)    ! interface depth (+ below surface) for whole column [m]
+    real(r8) :: dzm                                                        ! used in computing tridiagonal matrix [m]
+    real(r8) :: dzp                                                        ! used in computing tridiagonal matrix [m]
+    integer  :: jprime                                                     ! j - nlevlak
+    real(r8) :: factx(bounds%begc:bounds%endc,-nlevsno+1:nlevlak+nlevgrnd) ! coefficient used in computing tridiagonal matrix
+    real(r8) :: t_lake_bef(bounds%begc:bounds%endc,1:nlevlak)              ! beginning lake temp for energy conservation check [K]
+    real(r8) :: t_soisno_bef(bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)  ! beginning soil temp for E cons. check [K]
+    real(r8) :: lhabs(bounds%begc:bounds%endc)                             ! total per-column latent heat abs. from phase change  (J/m^2)
+    real(r8) :: esum1(bounds%begc:bounds%endc)                             ! temp for checking energy (J/m^2)
+    real(r8) :: esum2(bounds%begc:bounds%endc)                             ! ""
+    real(r8) :: zsum(bounds%begc:bounds%endc)                              ! temp for putting ice at the top during convection (m)
+    real(r8) :: wsum(bounds%begc:bounds%endc)                              ! temp for checking water (kg/m^2)
+    real(r8) :: wsum_end(bounds%begc:bounds%endc)                          ! temp for checking water (kg/m^2)
+    real(r8) :: sabg_col(bounds%begc:bounds%endc)                          ! absorbed ground solar for column (W/m^2)
+    real(r8) :: sabg_lyr_col(bounds%begc:bounds%endc,-nlevsno+1:1)         ! absorbed ground solar in layer for column (W/m^2)
     real(r8) :: sabg_nir                                                   ! NIR that is absorbed (W/m^2)
-    integer  :: jconvect(1:num_lakec)                          ! Lowest level where convection occurs
-    !NOTE: jconvectbot initialization seems unnecessary 
-    integer  :: jconvectbot(1:num_lakec)                       ! Hightest level where bottom-originating convection occurs
-    logical  :: bottomconvect(1:num_lakec)                     ! Convection originating in bottom layer of lake triggers special convection loop
+    integer  :: jconvect(bounds%begc:bounds%endc)                          ! Lowest level where convection occurs
+    integer  :: jconvectbot(bounds%begc:bounds%endc)                       ! Hightest level where bottom-originating convection occurs
+    logical  :: bottomconvect(bounds%begc:bounds%endc)                     ! Convection originating in bottom layer of lake triggers special convection loop
     real(r8) :: fangkm                                                     ! (m^2/s) extra diffusivity based on Fang & Stefan 1996, citing Ellis, 1991
 
     ! They think that mixing energy will generally get into lake to make
     ! diffusivity exceed molecular; the energy is damped out according to the Brunt-Vaisala
     ! frequency, yielding a maximum diffusivity for neutral stability of about 6 times molecular
     ! For puddling
-    logical  :: puddle(1:num_lakec)
-    real(r8) :: icesum ! m
-    logical  :: frzn(1:num_lakec)
-    integer  :: lake_col_to_filter(bounds%begc:bounds%endc)
-    real(r8) :: temp, sum1, sum2,sum3
-    real :: startt, stopt, start_all, stop_all  
-    real(r8) :: gam(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)
-
+    logical  :: puddle(bounds%begc:bounds%endc)
+    real(r8) :: icesum(bounds%begc:bounds%endc) ! m
+    logical  :: frzn(bounds%begc:bounds%endc)
     !-----------------------------------------------------------------------
 
     associate(                                                       &
-         dz_lake         =>   col_pp%dz_lake                       , & ! Input:  [real(r8) (:,:) ]  layer thickness for lake (m)
-         z_lake          =>   col_pp%z_lake                        , & ! Input:  [real(r8) (:,:) ]  layer depth for lake (m)
-         dz              =>   col_pp%dz                            , & ! Input:  [real(r8) (:,:) ]  layer thickness for snow & soil (m)
-         z               =>   col_pp%z                             , & ! Input:  [real(r8) (:,:) ]  layer depth for snow & soil (m)
-         snl             =>   col_pp%snl                           , & ! Input:  [integer  (:)   ]  negative of number of snow layers
-         lakedepth       =>   col_pp%lakedepth                     , & ! Input:  [real(r8) (:)   ]  column lake depth (m)
+         dz_lake         =>   col_pp%dz_lake                          , & ! Input:  [real(r8) (:,:) ]  layer thickness for lake (m)
+         z_lake          =>   col_pp%z_lake                           , & ! Input:  [real(r8) (:,:) ]  layer depth for lake (m)
+         dz              =>   col_pp%dz                               , & ! Input:  [real(r8) (:,:) ]  layer thickness for snow & soil (m)
+         z               =>   col_pp%z                                , & ! Input:  [real(r8) (:,:) ]  layer depth for snow & soil (m)
+         snl             =>   col_pp%snl                              , & ! Input:  [integer  (:)   ]  negative of number of snow layers
+         lakedepth       =>   col_pp%lakedepth                        , & ! Input:  [real(r8) (:)   ]  column lake depth (m)
 
          sabg            =>   solarabs_vars%sabg_patch             , & ! Input:  [real(r8) (:)   ]  solar radiation absorbed by ground (W/m**2)
          sabg_lyr        =>   solarabs_vars%sabg_lyr_patch         , & ! Input:  [real(r8) (:,:) ]  absorbed solar radiation (pft,lyr) [W/m2]
@@ -226,7 +231,7 @@ contains
          etal            =>   lakestate_vars%etal_col              , & ! Input:  [real(r8) (:)   ]  extinction coefficient from surface data (1/m)
          ks              =>   lakestate_vars%ks_col                , & ! Input:  [real(r8) (:)   ]  coefficient passed to LakeTemperature
          ws              =>   lakestate_vars%ws_col                , & ! Input:  [real(r8) (:)   ]  surface friction velocity (m/s)
-         lake_raw        =>   lakestate_vars%lake_raw_col          , & ! Input:  [real(r8) (:)   ]  aerodynamic resistance for moisture (s/m)
+         lake_raw       =>    lakestate_vars%lake_raw_col          , & ! Input:  [real(r8) (:)   ]  aerodynamic resistance for moisture (s/m)
 
          h2osno          =>   col_ws%h2osno           , & ! Input:  [real(r8) (:)   ]  snow water (mm H2O)
          h2osoi_liq      =>   col_ws%h2osoi_liq       , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2) [for snow & soil layers]
@@ -253,79 +258,46 @@ contains
          eflx_sh_grnd    =>   veg_ef%eflx_sh_grnd   , & ! Output: [real(r8) (:)   ]  sensible heat flux from ground (W/m**2) [+ to atm]
          eflx_sh_tot     =>   veg_ef%eflx_sh_tot    , & ! Output: [real(r8) (:)   ]  total sensible heat flux (W/m**2) [+ to atm]
          eflx_gnet       =>   veg_ef%eflx_gnet      , & ! Output: [real(r8) ( :)  ]  net heat flux into ground (W/m**2) at the surface interface
-         errsoi          =>   col_ef%errsoi           & ! Output: [real(r8) (:)   ]  soil/lake energy conservation error (W/m**2)
+         errsoi          =>   col_ef%errsoi             & ! Output: [real(r8) (:)   ]  soil/lake energy conservation error (W/m**2)
          )
-   
+
     ! 1!) Initialization
     ! Determine step size
-      !$acc enter data create(&
-      !! ! $acc   beta(1:num_lakec), &
-      !$acc   a(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd) ,& 
-      !$acc   b(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd) ,& 
-      !$acc   c1(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd),& 
-      !$acc   r(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd) ,&
-      !$acc   rhow(1:num_lakec,1:nlevlak)           ,& 
-      !$acc   phi(1:num_lakec,1:nlevlak),& 
-      !$acc   kme(1:num_lakec,1:nlevlak)            ,&  
-      !$acc   phi_soil(1:num_lakec)     ,& 
-      !$acc   fin(1:num_lakec)          ,&
-      !$acc   ocvts(1:num_lakec)        ,&
-      !$acc   ncvts(1:num_lakec)        ,&
-      !$acc   tav_froz(1:num_lakec)                 ,&
-      !$acc   tav_unfr(1:num_lakec)                 ,& 
-      !$acc   nav(1:num_lakec)                      ,&
-      !$acc   iceav(1:num_lakec)                     ,&
-      !$acc   qav(1:num_lakec)                       ,&
-      !$acc   jtop(1:num_lakec)                      ,&
-      !$acc   cv(1:num_lakec,-nlevsno+1:nlevgrnd)    ,&
-      !$acc   tk(1:num_lakec,-nlevsno+1:nlevgrnd)    ,&
-      !$acc   cv_lake(1:num_lakec,1:nlevlak)               ,&
-      !$acc   tk_lake(1:num_lakec,1:nlevlak)               ,&
-      !$acc   cvx (1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd),&
-      !$acc   tkix(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd),&
-      !$acc   tx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)  ,&
-      !$acc   tktopsoillay(1:num_lakec)                    ,&
-      !$acc   fnx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd) ,&
-      !$acc   phix(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd),&
-      !$acc   zx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)  ,&
-      !$acc   factx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd), &
-      !$acc   sabg_lyr_col(1:num_lakec,-nlevsno+1:1), &
-      !$acc   jconvect(1:num_lakec), &
-      !$acc   jconvectbot(1:num_lakec)  ,&
-      !$acc   bottomconvect(1:num_lakec) ,&
-      !$acc   puddle(1:num_lakec)  , & 
-      !$acc   frzn(1:num_lakec)    , zsum(1:num_lakec), &
-      !$acc   gam(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd), &
-      !$acc   lake_col_to_filter(bounds%begc:bounds%endc)  &
-      !$acc )
+
+    dtime = dtime_mod !get_step_size()
 
     ! Initialize constants
     cwat = cpliq*denh2o ! water heat capacity per unit volume
     cice_eff = cpice*denh2o !use water density because layer depth is not adjusted
-                            !for freezing
+                              !for freezing
     cfus = hfus*denh2o  ! latent heat per unit volume
     tkice_eff = tkice * denice/denh2o !effective conductivity since layer depth is constant
     km = tkwat/cwat     ! a constant (molecular diffusivity)
-    !$acc enter data copyin(cwat, cice_eff, cfus, tkice_eff, km)
-    !$acc enter data create(temp,sum1,sum2,sum3, icesum) 
-    
-    !Begin Calculations
-    !$acc parallel loop independent gang vector default(present) private(c) 
+
+    ! Needed for Lahey compiler which doesn't seem to allow shortcircuit logic for undefined variables.
+    puddle(bounds%begc:bounds%endc) = .false.
+    frzn(bounds%begc:bounds%endc) = .false.
+
+    ! Begin calculations
+
     do fc = 1, num_lakec
        c = filter_lakec(fc)
+
        ! Initialize quantities needed below
-       lake_col_to_filter(c) = fc 
-       ocvts(fc) = 0._r8
-       puddle(fc) = .false.
-       frzn(fc)   = .false.
-       bottomconvect(fc) = .false.
+
+       ocvts(c) = 0._r8
+       ncvts(c) = 0._r8
+       esum1(c) = 0._r8
+       esum2(c) = 0._r8
        hc_soisno(c) = 0._r8
        hc_soi(c)    = 0._r8
        if (use_lch4) then
-          jconvect(fc) = 0
-          jconvectbot(fc) = nlevlak+1
+          jconvect(c) = 0
+          jconvectbot(c) = nlevlak+1
           lakeresist(c) = 0._r8
        end if
+       bottomconvect(bounds%begc:bounds%endc) = .false.
+
        qflx_snofrz_col(c) = 0._r8
     end do
 
@@ -334,7 +306,6 @@ contains
     ! here because phase change will occur in this routine.
     ! Ice fraction of snow at previous time step
 
-    !$acc parallel loop independent gang vector collapse(2) default(present) !async(1)
     do j = -nlevsno+1,0
       do fc = 1, num_lakec
          c = filter_lakec(fc)
@@ -345,29 +316,31 @@ contains
     end do
 
     ! Prepare for lake layer temperature calculations below
-    !$acc parallel loop independent gang vector default(present) private(sabg_nir)
+
     do fp = 1, num_lakep
        p = filter_lakep(fp)
        c = veg_pp%column(p)
-       fc = lake_col_to_filter(c) 
-       fin(fc) = eflx_gnet(p)
+
+       ! fin(c) = betaprime * sabg(p) + forc_lwrad(c) - (eflx_lwrad_out(p) + &
+       !     eflx_sh_tot(p) + eflx_lh_tot(p))
+       ! fin(c) now passed from LakeFluxes as eflx_gnet
+       fin(c) = eflx_gnet(p)
 
        ! Calculate the NIR fraction of absorbed solar. This will now be the "beta" parameter.
        ! Total NIR absorbed:
        sabg_nir = fsds_nir_d(p) + fsds_nir_i(p) - fsr_nir_d(p) - fsr_nir_i(p)
        sabg_nir = min(sabg_nir, sabg(p))
-
-       sabg_nir  = sabg_nir/max(1.e-5_r8,sabg(p))
-       beta(c)  = sabg_nir + (1._r8-sabg_nir)*betavis
+       beta(c) = sabg_nir/max(1.e-5_r8,sabg(p))
+       beta(c) = beta(c) + (1._r8-beta(c))*betavis
 
     end do
-    
+
     ! 2!) Lake density
-    !$acc parallel loop independent gang vector collapse(2) default(present) private(c)
+
     do j = 1, nlevlak
        do fc = 1, num_lakec
           c = filter_lakec(fc)
-          rhow(fc,j) = (1._r8 - lake_icefrac(c,j)) * &
+          rhow(c,j) = (1._r8 - lake_icefrac(c,j)) * &
                       1000._r8*( 1.0_r8 - 1.9549e-05_r8*(abs(t_lake(c,j)-tdmax))**1.68_r8 ) &
                     + lake_icefrac(c,j)*denice
                     ! Allow for ice fraction; assume constant ice density.
@@ -378,13 +351,13 @@ contains
                     ! convective mixing.
        end do
     end do
+
     ! 3!) Diffusivity and implied thermal "conductivity" = diffusivity * cwat
-    !$acc parallel loop independent gang vector collapse(2) default(present) 
     do j = 1, nlevlak-1
        do fc = 1, num_lakec
           c = filter_lakec(fc)
-          drhodz = (rhow(fc,j+1)-rhow(fc,j)) / (z_lake(c,j+1)-z_lake(c,j))
-          n2 = grav / rhow(fc,j) * drhodz
+          drhodz = (rhow(c,j+1)-rhow(c,j)) / (z_lake(c,j+1)-z_lake(c,j))
+          n2 = grav / rhow(c,j) * drhodz
 
           ! Fixed sign error here: our z goes up going down into the lake, so no negative
           ! sign is needed to make this positive unlike in Hostetler. --ZS
@@ -392,77 +365,74 @@ contains
           den = max( (ws(c)**2._r8) * exp(-2._r8*ks(c)*z_lake(c,j)), 1.e-10_r8 )
           ri = ( -1._r8 + sqrt( max(1._r8+num/den, 0._r8) ) ) / 20._r8
 
-          if (lakepuddling .and. j == 1) frzn(fc) = .false.
+          if (lakepuddling .and. j == 1) frzn(c) = .false.
 
           if (t_grnd(c) > tfrz .and. t_lake(c,1) > tfrz .and. snl(c) == 0 .and. &
-              (.not. lakepuddling .or. (lake_icefrac(c,j) == 0._r8 .and. .not. frzn(fc))) ) then
+              (.not. lakepuddling .or. (lake_icefrac(c,j) == 0._r8 .and. .not. frzn(c))) ) then
              ke = vkc*ws(c)*z_lake(c,j)/p0 * exp(-ks(c)*z_lake(c,j)) / (1._r8+37._r8*ri*ri)
-             kme(fc,j) = km + ke
+             kme(c,j) = km + ke
 
              if (.not. lake_no_ed) then
-               ! Fang & Stefan 1996, citing Ellis et al 1991
-                fangkm = 1.039e-8_r8 * max(n2,n2min)**(-0.43_r8)  
-                kme(fc,j) = kme(fc,j) + fangkm
+                fangkm = 1.039e-8_r8 * max(n2,n2min)**(-0.43_r8)  ! Fang & Stefan 1996, citing Ellis et al 1991
+                kme(c,j) = kme(c,j) + fangkm
              end if
              if (lakedepth(c) >= depthcrit) then
-                kme(fc,j) = kme(fc,j) * mixfact
+                kme(c,j) = kme(c,j) * mixfact
              end if
 
-             tk_lake(fc,j) = kme(fc,j)*cwat
+             tk_lake(c,j) = kme(c,j)*cwat
           else
-             kme(fc,j) = km
+             kme(c,j) = km
              if (.not. lake_no_ed) then
                 fangkm = 1.039e-8_r8 * max(n2,n2min)**(-0.43_r8)
-                kme(fc,j) = kme(fc,j) + fangkm
+                kme(c,j) = kme(c,j) + fangkm
                 if (lakedepth(c) >= depthcrit) then
-                   kme(fc,j) = kme(fc,j) * mixfact
+                   kme(c,j) = kme(c,j) * mixfact
                 end if
-                tk_lake(fc,j) = kme(fc,j)*cwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &
-                               + kme(fc,j)*cwat*lake_icefrac(c,j) )
+                tk_lake(c,j) = kme(c,j)*cwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &
+                               + kme(c,j)*cwat*lake_icefrac(c,j) )
              else
-                tk_lake(fc,j) = tkwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &
+                tk_lake(c,j) = tkwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &
                                + tkwat*lake_icefrac(c,j) )
              ! Assume the resistances add as for the calculation of conductivities at layer interfaces.
              end if
-             if (lakepuddling) frzn(fc) = .true.
+             if (lakepuddling) frzn(c) = .true.
                 ! Prevent eddy mixing beneath frozen layers even when surface is unfrozen.
           end if
        end do
     end do
 
-    !$acc parallel loop independent gang vector default(present) private(c,j)
     do fc = 1, num_lakec
        c = filter_lakec(fc)
 
        j = nlevlak
-       kme(fc,nlevlak) = kme(fc,nlevlak-1)
+       kme(c,nlevlak) = kme(c,nlevlak-1)
 
        if (t_grnd(c) > tfrz .and. t_lake(c,1) > tfrz .and. snl(c) == 0 .and. &
-           (.not. lakepuddling .or. (lake_icefrac(c,j) == 0._r8 .and. .not. frzn(fc)) ) ) then
-          tk_lake(fc,j) = tk_lake(fc,j-1)
+           (.not. lakepuddling .or. (lake_icefrac(c,j) == 0._r8 .and. .not. frzn(c)) ) ) then
+          tk_lake(c,j) = tk_lake(c,j-1)
        else
           if (.not. lake_no_ed) then
-             tk_lake(fc,j) = kme(fc,j)*cwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &
-                               + kme(fc,j)*cwat*lake_icefrac(c,j) )
+             tk_lake(c,j) = kme(c,j)*cwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &
+                               + kme(c,j)*cwat*lake_icefrac(c,j) )
           else
-             tk_lake(fc,j) = tkwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &
+             tk_lake(c,j) = tkwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &
                                + tkwat*lake_icefrac(c,j) )
           end if
        end if
 
        ! Use in surface flux calculation for next timestep.
-       savedtke1(c) = kme(fc,1)*cwat ! Will only be used if unfrozen
+       savedtke1(c) = kme(c,1)*cwat ! Will only be used if unfrozen
        ! set number of column levels for use by Tridiagonal below
-       jtop(fc) = snl(c) + 1
+       jtop(c) = snl(c) + 1
     end do
 
     ! 4!) Heat source term
-    !$acc parallel loop independent gang vector collapse(2) default(present) 
     do j = 1, nlevlak
        do fp = 1, num_lakep
           p = filter_lakep(fp)
           c = veg_pp%column(p)
-          fc = lake_col_to_filter(c)
+
           ! If no eta from surface data,
           ! Set eta, the extinction coefficient, according to L Hakanson, Aquatic Sciences, 1995
           ! (regression of Secchi Depth with lake depth for small glacial basin lakes), and the
@@ -485,7 +455,7 @@ contains
           if (t_grnd(c) > tfrz .and. t_lake(c,1) > tfrz .and. snl(c) == 0) then
              phidum = (rsfin-rsfout) * sabg(p) * (1._r8-beta(c))
              if (j == nlevlak) then
-                phi_soil(fc) = rsfout * sabg(p) * (1._r8-beta(c))
+                phi_soil(c) = rsfout * sabg(p) * (1._r8-beta(c))
              end if
           else if (j == 1 .and. snl(c) == 0) then !if frozen but no snow layers
              phidum = sabg(p) * (1._r8-beta(c))
@@ -497,27 +467,29 @@ contains
           !radiation absorbed in snow layers will be applied below
           else
              phidum = 0._r8
-             if (j == nlevlak) phi_soil(fc) = 0._r8
+             if (j == nlevlak) phi_soil(c) = 0._r8
           end if
-          phi(fc,j) = phidum
+          phi(c,j) = phidum
 
        end do
     end do
 
     ! 5!) Set thermal properties and check initial energy content.
+
     ! For lake
-    !$acc parallel loop independent gang vector collapse(2) default(present)
     do j = 1, nlevlak
        do fc = 1, num_lakec
           c = filter_lakec(fc)
-          cv_lake(fc,j) = dz_lake(c,j) * (cwat*(1._r8-lake_icefrac(c,j)) + cice_eff*lake_icefrac(c,j))
+
+          cv_lake(c,j) = dz_lake(c,j) * (cwat*(1._r8-lake_icefrac(c,j)) + cice_eff*lake_icefrac(c,j))
        end do
     end do
+
     ! For snow / soil
     call SoilThermProp_Lake(bounds, num_lakec, filter_lakec, &
-         tk(1:num_lakec, :), &
-         cv(1:num_lakec, :), &
-         tktopsoillay(1:num_lakec), &
+         tk(bounds%begc:bounds%endc, :), &
+         cv(bounds%begc:bounds%endc, :), &
+         tktopsoillay(bounds%begc:bounds%endc), &
          soilstate_vars)
 
     ! Sum cv*t_lake for energy check
@@ -525,37 +497,30 @@ contains
     ! to prevent abrupt change in heat content due to changing heat capacity with phase change.
 
     ! This will need to be over all soil / lake / snow layers. Lake is below.
+    do j = 1, nlevlak
+       do fc = 1, num_lakec
+          c = filter_lakec(fc)
 
-    !$acc parallel loop independent gang worker default(present) private(c,temp) 
-    do fc = 1, num_lakec
-      c = filter_lakec(fc)
-      temp = 0._r8
-      !$acc loop  vector reduction(+:temp)
-      do j = 1, nlevlak
-        temp = temp + cv_lake(fc,j)*(t_lake(c,j)-tfrz) + cfus*dz_lake(c,j)*(1._r8-lake_icefrac(c,j))
-         !t_lake_bef(c,j) = t_lake(c,j)
-      end do
-      ocvts(fc) = ocvts(fc) + temp
+          ocvts(c) = ocvts(c) + cv_lake(c,j)*(t_lake(c,j)-tfrz) &
+                   + cfus*dz_lake(c,j)*(1._r8-lake_icefrac(c,j))
+          t_lake_bef(c,j) = t_lake(c,j)
+       end do
     end do
-      
-       
+
     ! Now do for soil / snow layers
-    !$acc parallel loop independent gang worker default(present) private(temp,c)
-    do fc = 1, num_lakec
-      c = filter_lakec(fc)
-      temp = 0._r8
-      !$acc loop vector reduction(+:temp)
-      do j = -nlevsno + 1, nlevgrnd
-          if (j >= jtop(fc)) then
-            temp = temp + cv(fc,j)*(t_soisno(c,j)-tfrz) + hfus*h2osoi_liq(c,j)
-             if (j == 1 .and. h2osno(c) > 0._r8 .and. j == jtop(fc)) then
-                temp = temp-h2osno(c)*hfus
+    do j = -nlevsno + 1, nlevgrnd
+       do fc = 1, num_lakec
+          c = filter_lakec(fc)
+
+          if (j >= jtop(c)) then
+             ocvts(c) = ocvts(c) + cv(c,j)*(t_soisno(c,j)-tfrz) &
+                      + hfus*h2osoi_liq(c,j)
+             if (j == 1 .and. h2osno(c) > 0._r8 .and. j == jtop(c)) then
+                ocvts(c) = ocvts(c) - h2osno(c)*hfus
              end if
-             !t_soisno_bef(c,j) = t_soisno(c,j)
+             t_soisno_bef(c,j) = t_soisno(c,j)
           end if
-
        end do
-       ocvts(fc) = ocvts(fc) + temp 
     end do
 
     !!!!!!!!!!!!!!!!!!!
@@ -565,53 +530,50 @@ contains
     ! but its capacity to absorb latent heat may be used during phase change.
 
     ! Transfer sabg and sabg_lyr to column level
-    !$acc parallel loop independent gang vector collapse(2) default(present) private(p,c,fc)
     do j = -nlevsno+1,1
        do fp = 1, num_lakep
           p = filter_lakep(fp)
           c = veg_pp%column(p)
-          fc = lake_col_to_filter(c)
 
-          if (j >= jtop(fc)) then
-            !  if (j == jtop(c)) sabg_col(c) = sabg(p)
-             sabg_lyr_col(fc,j) = sabg_lyr(p,j)
+          if (j >= jtop(c)) then
+             if (j == jtop(c)) sabg_col(c) = sabg(p)
+             sabg_lyr_col(c,j) = sabg_lyr(p,j)
           end if
        end do
     end do
-    
-   ! Set up interface depths, zx, heat capacities, cvx, solar source terms, phix, and temperatures, tx.
-    !$acc parallel loop independent gang vector collapse(2) default(present) private(c, jprime)
+
+    ! Set up interface depths, zx, heat capacities, cvx, solar source terms, phix, and temperatures, tx.
     do j = -nlevsno+1, nlevlak+nlevgrnd
        do fc = 1,num_lakec
           c = filter_lakec(fc)
 
           jprime = j - nlevlak
 
-          if (j >= jtop(fc)) then
+          if (j >= jtop(c)) then
              if (j < 1) then !snow layer
-                zx(fc,j) = z(c,j)
-                cvx(fc,j) = cv(fc,j)
-                if (j == jtop(fc)) then ! no absorption because it has already been assigned to the surface
+                zx(c,j) = z(c,j)
+                cvx(c,j) = cv(c,j)
+                if (j == jtop(c)) then ! no absorption because it has already been assigned to the surface
                                        ! interface
-                   phix(fc,j) = 0._r8
+                   phix(c,j) = 0._r8
                 else
-                   phix(fc,j) = sabg_lyr_col(fc,j) !New for SNICAR
+                   phix(c,j) = sabg_lyr_col(c,j) !New for SNICAR
                 end if
-                tx(fc,j) = t_soisno(c,j)
+                tx(c,j) = t_soisno(c,j)
              else if (j <= nlevlak) then !lake layer
-                zx(fc,j) = z_lake(c,j)
-                cvx(fc,j) = cv_lake(fc,j)
-                phix(fc,j) = phi(fc,j)
-                tx(fc,j) = t_lake(c,j)
+                zx(c,j) = z_lake(c,j)
+                cvx(c,j) = cv_lake(c,j)
+                phix(c,j) = phi(c,j)
+                tx(c,j) = t_lake(c,j)
              else !soil layer
-                zx(fc,j) = zx(fc,nlevlak) + dz_lake(c,nlevlak)/2._r8 + z(c,jprime)
-                cvx(fc,j) = cv(fc,jprime)
+                zx(c,j) = zx(c,nlevlak) + dz_lake(c,nlevlak)/2._r8 + z(c,jprime)
+                cvx(c,j) = cv(c,jprime)
                 if (j == nlevlak + 1) then !top soil layer
-                   phix(fc,j) = phi_soil(fc)
+                   phix(c,j) = phi_soil(c)
                 else !middle or bottom soil layer
-                   phix(fc,j) = 0._r8
+                   phix(c,j) = 0._r8
                 end if
-                tx(fc,j) = t_soisno(c,jprime)
+                tx(c,j) = t_soisno(c,jprime)
              end if
           end if
 
@@ -619,115 +581,98 @@ contains
     end do
 
     ! Determine interface thermal conductivities, tkix
-    !$acc parallel loop independent gang vector collapse(2) default(present) private(c)
+
     do j = -nlevsno+1, nlevlak+nlevgrnd
        do fc = 1,num_lakec
           c = filter_lakec(fc)
 
           jprime = j - nlevlak
 
-          if (j >= jtop(fc)) then
+          if (j >= jtop(c)) then
              if (j < 0) then !non-bottom snow layer
-                tkix(fc,j) = tk(fc,j)
+                tkix(c,j) = tk(c,j)
              else if (j == 0) then !bottom snow layer
-                dzp = zx(fc,j+1) - zx(fc,j)
-                tkix(fc,j) = tk_lake(fc,1)*tk(fc,j)*dzp / &
-                      (tk(fc,j)*z_lake(c,1) + tk_lake(fc,1)*(-z(c,j)) )
-                ! tk(fc,0) is the conductivity at the middle of that layer, as defined in SoilThermProp_Lake
+                dzp = zx(c,j+1) - zx(c,j)
+                tkix(c,j) = tk_lake(c,1)*tk(c,j)*dzp / &
+                      (tk(c,j)*z_lake(c,1) + tk_lake(c,1)*(-z(c,j)) )
+                ! tk(c,0) is the conductivity at the middle of that layer, as defined in SoilThermProp_Lake
              else if (j < nlevlak) then !non-bottom lake layer
-                tkix(fc,j) = ( tk_lake(fc,j)*tk_lake(fc,j+1) * (dz_lake(c,j+1)+dz_lake(c,j)) ) &
-                           / ( tk_lake(fc,j)*dz_lake(c,j+1) + tk_lake(fc,j+1)*dz_lake(c,j) )
+                tkix(c,j) = ( tk_lake(c,j)*tk_lake(c,j+1) * (dz_lake(c,j+1)+dz_lake(c,j)) ) &
+                           / ( tk_lake(c,j)*dz_lake(c,j+1) + tk_lake(c,j+1)*dz_lake(c,j) )
              else if (j == nlevlak) then !bottom lake layer
-                dzp = zx(fc,j+1) - zx(fc,j)
-                tkix(fc,j) = (tktopsoillay(fc)*tk_lake(fc,j)*dzp / &
-                    (tktopsoillay(fc)*dz_lake(c,j)/2._r8 + tk_lake(fc,j)*z(c,1) ) )
+                dzp = zx(c,j+1) - zx(c,j)
+                tkix(c,j) = (tktopsoillay(c)*tk_lake(c,j)*dzp / &
+                    (tktopsoillay(c)*dz_lake(c,j)/2._r8 + tk_lake(c,j)*z(c,1) ) )
                     ! tktopsoillay is the conductivity at the middle of that layer, as defined in SoilThermProp_Lake
              else !soil layer
-                tkix(fc,j) = tk(fc,jprime)
+                tkix(c,j) = tk(c,jprime)
              end if
          end if
 
       end do
    end do
 
+
     ! Determine heat diffusion through the layer interface and factor used in computing
     ! tridiagonal matrix and set up vector r and vectors a, b, c1 that define tridiagonal
     ! matrix and solve system
-   
-    !$acc parallel loop independent gang vector collapse(2) default(present) private(c) 
+
     do j = -nlevsno+1, nlevlak+nlevgrnd
        do fc = 1,num_lakec
-          if (j >= jtop(fc)) then
+          c = filter_lakec(fc)
+          if (j >= jtop(c)) then
              if (j < nlevlak+nlevgrnd) then !top or interior layer
-                factx(fc,j) = dtime_mod/cvx(fc,j)
-                fnx(fc,j) = tkix(fc,j)*(tx(fc,j+1)-tx(fc,j))/(zx(fc,j+1)-zx(fc,j))
+                factx(c,j) = dtime/cvx(c,j)
+                fnx(c,j) = tkix(c,j)*(tx(c,j+1)-tx(c,j))/(zx(c,j+1)-zx(c,j))
              else !bottom soil layer
-                factx(fc,j) = dtime_mod/cvx(fc,j)
-                fnx(fc,j) = 0._r8 !not used
+                factx(c,j) = dtime/cvx(c,j)
+                fnx(c,j) = 0._r8 !not used
              end if
           end if
        enddo
     end do
 
-    !$acc parallel loop independent gang vector collapse(2) default(present)
     do j = -nlevsno+1,nlevlak+nlevgrnd
        do fc = 1,num_lakec
           c = filter_lakec(fc)
-          if (j >= jtop(fc)) then
-             if (j == jtop(fc)) then !top layer
-                dzp    = zx(fc,j+1)-zx(fc,j)
-                a(fc,j) = 0._r8
-                b(fc,j) = 1+(1._r8-cnfac)*factx(fc,j)*tkix(fc,j)/dzp
-                c1(fc,j) =  -(1._r8-cnfac)*factx(fc,j)*tkix(fc,j)/dzp
-                r(fc,j) = tx(fc,j) + factx(fc,j)*( fin(fc) + phix(fc,j) + cnfac*fnx(fc,j) )
+          if (j >= jtop(c)) then
+             if (j == jtop(c)) then !top layer
+                dzp    = zx(c,j+1)-zx(c,j)
+                a(c,j) = 0._r8
+                b(c,j) = 1+(1._r8-cnfac)*factx(c,j)*tkix(c,j)/dzp
+                c1(c,j) =  -(1._r8-cnfac)*factx(c,j)*tkix(c,j)/dzp
+                r(c,j) = tx(c,j) + factx(c,j)*( fin(c) + phix(c,j) + cnfac*fnx(c,j) )
              else if (j < nlevlak+nlevgrnd) then !middle layer
-                dzm    = (zx(fc,j)-zx(fc,j-1))
-                dzp    = (zx(fc,j+1)-zx(fc,j))
-                a(fc,j) =   - (1._r8-cnfac)*factx(fc,j)* tkix(fc,j-1)/dzm
-                b(fc,j) = 1._r8+ (1._r8-cnfac)*factx(fc,j)*(tkix(fc,j)/dzp + tkix(fc,j-1)/dzm)
-                c1(fc,j) =   - (1._r8-cnfac)*factx(fc,j)* tkix(fc,j)/dzp
-                r(fc,j) = tx(fc,j) + cnfac*factx(fc,j)*( fnx(fc,j) - fnx(fc,j-1) ) + factx(fc,j)*phix(fc,j)
+                dzm    = (zx(c,j)-zx(c,j-1))
+                dzp    = (zx(c,j+1)-zx(c,j))
+                a(c,j) =   - (1._r8-cnfac)*factx(c,j)* tkix(c,j-1)/dzm
+                b(c,j) = 1._r8+ (1._r8-cnfac)*factx(c,j)*(tkix(c,j)/dzp + tkix(c,j-1)/dzm)
+                c1(c,j) =   - (1._r8-cnfac)*factx(c,j)* tkix(c,j)/dzp
+                r(c,j) = tx(c,j) + cnfac*factx(c,j)*( fnx(c,j) - fnx(c,j-1) ) + factx(c,j)*phix(c,j)
              else  !bottom soil layer
-                dzm     = (zx(fc,j)-zx(fc,j-1))
-                a(fc,j) =   - (1._r8-cnfac)*factx(fc,j)*tkix(fc,j-1)/dzm
-                b(fc,j) = 1._r8+ (1._r8-cnfac)*factx(fc,j)*tkix(fc,j-1)/dzm
-                c1(fc,j) = 0._r8
-                r(fc,j) = tx(fc,j) - cnfac*factx(fc,j)*fnx(fc,j-1)
+                dzm     = (zx(c,j)-zx(c,j-1))
+                a(c,j) =   - (1._r8-cnfac)*factx(c,j)*tkix(c,j-1)/dzm
+                b(c,j) = 1._r8+ (1._r8-cnfac)*factx(c,j)*tkix(c,j-1)/dzm
+                c1(c,j) = 0._r8
+                r(c,j) = tx(c,j) - cnfac*factx(c,j)*fnx(c,j-1)
              end if
           end if
        enddo
     end do
+    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
-    !$acc parallel loop independent gang vector  default(present) private(c)
-    do fc = 1,num_lakec
-      c = filter_lakec(fc)
-
-      !$acc loop seq 
-      do j = -nlevsno + 1, nlevlak + nlevgrnd
-          !if(l_is_col_active(ci))then
-         if (j >= jtop(fc)) then
-           if (j == jtop(fc)) then
-             tx(fc,j) = r(fc,j) / b(fc,jtop(fc))
-           else
-             gam(fc,j) = c1(fc,j-1) / b(fc,jtop(fc))
-             b(fc,jtop(fc)) = b(fc,j) - a(fc,j) * gam(fc,j)
-             tx(fc,j) = (r(fc,j) - a(fc,j)*tx(fc,j-1)) / b(fc,jtop(fc))
-           end if
-         end if
-          !endif
-       end do
 
-       !$acc loop seq 
-       do j = nlevlak + nlevgrnd-1,-nlevsno + 1,-1
-         if (j >= jtop(fc)) then
-            tx(fc,j) = tx(fc,j) - gam(fc,j+1) * tx(fc,j+1)
-         end if
-       end do 
+    ! 7!) Solve for tdsolution
+    call Tridiagonal(bounds, -nlevsno + 1, nlevlak + nlevgrnd, &
+         jtop(bounds%begc:bounds%endc), &
+         num_lakec, filter_lakec, &
+         a(bounds%begc:bounds%endc, :), &
+         b(bounds%begc:bounds%endc, :), &
+         c1(bounds%begc:bounds%endc, :), &
+         r(bounds%begc:bounds%endc, :), &
+         tx(bounds%begc:bounds%endc, :))
 
-    end do
-   
     ! Set t_soisno and t_lake
-    !$acc parallel loop independent gang vector  default(present) collapse(2) private(jprime)
     do j = -nlevsno+1, nlevlak + nlevgrnd
        do fc = 1, num_lakec
           c = filter_lakec(fc)
@@ -735,13 +680,13 @@ contains
           jprime = j - nlevlak
 
           ! Don't do anything with invalid snow layers.
-          if (j >= jtop(fc)) then
+          if (j >= jtop(c)) then
              if (j < 1) then !snow layer
-                t_soisno(c,j) = tx(fc,j)
+                t_soisno(c,j) = tx(c,j)
              else if (j <= nlevlak) then !lake layer
-                t_lake(c,j)   = tx(fc,j)
+                t_lake(c,j)   = tx(c,j)
              else !soil layer
-                t_soisno(c,jprime) = tx(fc,j)
+                t_soisno(c,jprime) = tx(c,j)
              end if
           end if
        end do
@@ -756,11 +701,13 @@ contains
 
     ! 9!) Phase change
     call PhaseChange_Lake(bounds, num_lakec, filter_lakec, &
-         cv(1:num_lakec, :), &
-         cv_lake(1:num_lakec, :), &
-         !lhabs(bounds%begc:bounds%endc), &
-         lakestate_vars, dtime_mod)
+         cv(bounds%begc:bounds%endc, :), &
+         cv_lake(bounds%begc:bounds%endc, :), &
+         lhabs(bounds%begc:bounds%endc), &
+         energyflux_vars, lakestate_vars, dtime)
+
     !!!!!!!!!!!!!!!!!!!!!!!
+
     ! 9.5!) Second energy check and water check.  Now check energy balance before and after phase
     !       change, considering the possibility of changed heat capacity during phase change, by
     !       using initial heat capacity in the first step, final heat capacity in the second step,
@@ -774,34 +721,30 @@ contains
     ! Either an unstable density profile or ice in a layer below an incompletely frozen layer will trigger.
 
     !Recalculate density
-
-    !$acc parallel loop independent gang vector default(present) collapse(2) 
     do j = 1, nlevlak
        do fc = 1, num_lakec
           c = filter_lakec(fc)
-          rhow(fc,j) = (1._r8 - lake_icefrac(c,j)) * &
+          rhow(c,j) = (1._r8 - lake_icefrac(c,j)) * &
                       1000._r8*( 1.0_r8 - 1.9549e-05_r8*(abs(t_lake(c,j)-tdmax))**1.68_r8 ) &
                     + lake_icefrac(c,j)*denice
        end do
     end do
 
-    
     if (lakepuddling) then
     ! For sensitivity tests
-       !$acc parallel loop independent gang vector default(present) collapse(2) 
-      do j = 1, nlevlak
-         do fc = 1, num_lakec
+       do j = 1, nlevlak
+          do fc = 1, num_lakec
              c = filter_lakec(fc)
 
              if (j == 1) then
-                icesum = 0._r8
-                puddle(fc) = .false.
+                icesum(c) = 0._r8
+                puddle(c) = .false.
              end if
 
-             icesum = icesum + lake_icefrac(c,j)*dz(c,j)
+             icesum(c) = icesum(c) + lake_icefrac(c,j)*dz(c,j)
 
              if (j == nlevlak) then
-                if (icesum >= pudz) puddle(fc) = .true.
+                if (icesum(c) >= pudz) puddle(c) = .true.
              end if
           end do
        end do
@@ -816,168 +759,154 @@ contains
 
     ! First examine top nlevlak-1 layers.
     do j = 1, nlevlak-2
-       !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3)
-      do fc = 1, num_lakec
-         c = filter_lakec(fc)
-         if (use_lch4) then
-            jconvect(fc) = j+1
-         end if
-         sum1 = 0._r8; sum2 = 0._r8; sum3 = 0._r8
-         if ( (.not. lakepuddling .or. .not. puddle(fc) )) then 
-            !$acc loop vector reduction(+:sum1,sum2,sum3)
-            do i = 1, j+1
-               if ( (rhow(fc,j) > rhow(fc,j+1) .or. &
-                  (lake_icefrac(c,j) < 1._r8 .and. lake_icefrac(c,j+1) > 0._r8) ) ) then
-                  
-                  sum1 = sum1 + dz_lake(c,i)*(t_lake(c,i)-tfrz) * &
+       do fc = 1, num_lakec
+          c = filter_lakec(fc)
+          qav(c) = 0._r8
+          nav(c) = 0._r8
+          iceav(c) = 0._r8
+       end do
+
+       do i = 1, j+1
+          do fc = 1, num_lakec
+             c = filter_lakec(fc)
+             if ( (.not. lakepuddling .or. .not. puddle(c) ) .and. (rhow(c,j) > rhow(c,j+1) .or. &
+                (lake_icefrac(c,j) < 1._r8 .and. lake_icefrac(c,j+1) > 0._r8) ) ) then
+                qav(c) = qav(c) + dz_lake(c,i)*(t_lake(c,i)-tfrz) * &
                         ((1._r8 - lake_icefrac(c,i))*cwat + lake_icefrac(c,i)*cice_eff)
-                  !tav(c) = tav(c) + t_lake(c,i)*dz_lake(c,i)
-                  sum2 = sum2 + lake_icefrac(c,i)*dz_lake(c,i)
-                  sum3 = sum3 + dz_lake(c,i)
-               end if
-            end do
-         end if 
-         qav(fc) = sum1 
-         iceav(fc) = sum2 
-         nav(fc) = sum3 
-      end do
+                !tav(c) = tav(c) + t_lake(c,i)*dz_lake(c,i)
+                iceav(c) = iceav(c) + lake_icefrac(c,i)*dz_lake(c,i)
+                nav(c) = nav(c) + dz_lake(c,i)
+                if (use_lch4) then
+                   jconvect(c) = j+1
+                end if
+             end if
+          end do
+       end do
 
-    !$acc parallel loop independent gang vector  default(present)
        do fc = 1, num_lakec
           c = filter_lakec(fc)
-          if ( (.not. lakepuddling .or. .not. puddle(fc) ) .and. (rhow(fc,j) > rhow(fc,j+1) .or. &
+
+          if ( (.not. lakepuddling .or. .not. puddle(c) ) .and. (rhow(c,j) > rhow(c,j+1) .or. &
                 (lake_icefrac(c,j) < 1._r8 .and. lake_icefrac(c,j+1) > 0._r8) ) ) then
-             qav(fc) = qav(fc)/nav(fc)
-             iceav(fc) = iceav(fc)/nav(fc)
+             qav(c) = qav(c)/nav(c)
+             iceav(c) = iceav(c)/nav(c)
              !If the average temperature is above freezing, put the extra energy into the water.
              !If it is below freezing, take it away from the ice.
-             if (qav(fc) > 0._r8) then
-                tav_froz(fc) = 0._r8 !Celsius
-                tav_unfr(fc) = qav(fc) / ((1._r8 - iceav(fc))*cwat)
-             else if (qav(fc) < 0._r8) then
-                tav_froz(fc) = qav(fc) / (iceav(fc)*cice_eff)
-                tav_unfr(fc) = 0._r8 !Celsius
+             if (qav(c) > 0._r8) then
+                tav_froz(c) = 0._r8 !Celsius
+                tav_unfr(c) = qav(c) / ((1._r8 - iceav(c))*cwat)
+             else if (qav(c) < 0._r8) then
+                tav_froz(c) = qav(c) / (iceav(c)*cice_eff)
+                tav_unfr(c) = 0._r8 !Celsius
              else
-                tav_froz(fc) = 0._r8
-                tav_unfr(fc) = 0._r8
+                tav_froz(c) = 0._r8
+                tav_unfr(c) = 0._r8
              end if
           end if
-       end do  
+       end do
 
-       !$acc parallel loop independent gang vector default(present) copyin(j)
-       do fc = 1, num_lakec
-         c = filter_lakec(fc)
+       do i = 1, j+1
+          do fc = 1, num_lakec
+             c = filter_lakec(fc)
+             if (nav(c) > 0._r8) then
 
-         if (nav(fc) > 0._r8) then
-         !$acc loop seq 
-            do i = 1, j+1
                 !Put all the ice at the top.!
                 !If the average temperature is above freezing, put the extra energy into the water.
                 !If it is below freezing, take it away from the ice.
                 !For the layer with both ice & water, be careful to use the average temperature
                 !that preserves the correct total heat content given what the heat capacity of that
                 !layer will actually be.
-                if (i == 1) zsum(fc) = 0._r8
-                if ((zsum(fc)+dz_lake(c,i))/nav(fc) <= iceav(fc)) then
+                if (i == 1) zsum(c) = 0._r8
+                if ((zsum(c)+dz_lake(c,i))/nav(c) <= iceav(c)) then
                    lake_icefrac(c,i) = 1._r8
-                   t_lake(c,i) = tav_froz(fc) + tfrz
-                else if (zsum(fc)/nav(fc) < iceav(fc)) then
-                   lake_icefrac(c,i) = (iceav(fc)*nav(fc) - zsum(fc)) / dz_lake(c,i)
+                   t_lake(c,i) = tav_froz(c) + tfrz
+                else if (zsum(c)/nav(c) < iceav(c)) then
+                   lake_icefrac(c,i) = (iceav(c)*nav(c) - zsum(c)) / dz_lake(c,i)
                    ! Find average value that preserves correct heat content.
-                   t_lake(c,i) = ( lake_icefrac(c,i)*tav_froz(fc)*cice_eff &
-                               + (1._r8 - lake_icefrac(c,i))*tav_unfr(fc)*cwat ) &
+                   t_lake(c,i) = ( lake_icefrac(c,i)*tav_froz(c)*cice_eff &
+                               + (1._r8 - lake_icefrac(c,i))*tav_unfr(c)*cwat ) &
                                / ( lake_icefrac(c,i)*cice_eff + (1-lake_icefrac(c,i))*cwat ) + tfrz
                 else
                    lake_icefrac(c,i) = 0._r8
-                   t_lake(c,i) = tav_unfr(fc) + tfrz
+                   t_lake(c,i) = tav_unfr(c) + tfrz
                 end if
-                zsum(fc) = zsum(fc) + dz_lake(c,i)
+                zsum(c) = zsum(c) + dz_lake(c,i)
 
-                rhow(fc,i) = (1._r8 - lake_icefrac(c,i)) * &
+                rhow(c,i) = (1._r8 - lake_icefrac(c,i)) * &
                             1000._r8*( 1.0_r8 - 1.9549e-05_r8*(abs(t_lake(c,i)-tdmax))**1.68_r8 ) &
                           + lake_icefrac(c,i)*denice
-            end do
-         end if
-
+             end if
+          end do
        end do
-
-    end do !j loop
+    end do
 
     ! Now check bottom layer
     j = nlevlak-1
-    !$acc parallel loop independent gang vector  default(present)
     do fc = 1, num_lakec
-      c = filter_lakec(fc)
+       c = filter_lakec(fc)
 
-       if ( (.not. lakepuddling .or. .not. puddle(fc) ) .and. (rhow(fc,j) > rhow(fc,j+1) .or. &
+       if ( (.not. lakepuddling .or. .not. puddle(c) ) .and. (rhow(c,j) > rhow(c,j+1) .or. &
             (lake_icefrac(c,j) < 1._r8 .and. lake_icefrac(c,j+1) > 0._r8) ) ) then
           ! convection originating in bottom layer. Could be coming from sediments-- be careful not to
           ! unnecessarily mix all the way to the top of the lake
-          bottomconvect(fc) = .true.
+          bottomconvect(c) = .true.
        end if
     end do
 
     ! Start mixing from bottom up. Only mix as high as the unstable density profile persists.
     do j = nlevlak-1, 1, -1
-       
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3)
-      do fc = 1, num_lakec
-         c = filter_lakec(fc)
-         sum1 = 0._r8; sum2 = 0._r8; sum3 = 0._r8 
-         if (use_lch4) then
-            jconvectbot(fc) = j
-         end if
-         if(bottomconvect(fc)) then 
-            !$acc loop vector reduction(+:sum1,sum2,sum3)
-            do i = j, nlevlak
-               if ((.not. lakepuddling .or. .not. puddle(fc) ) .and. (rhow(fc,j) > rhow(fc,j+1) .or. &
+       do fc = 1, num_lakec
+          c = filter_lakec(fc)
+          qav(c) = 0._r8
+          nav(c) = 0._r8
+          iceav(c) = 0._r8
+       end do
+
+       do i = j, nlevlak
+          do fc = 1, num_lakec
+             c = filter_lakec(fc)
+             if ( bottomconvect(c) .and. &
+                  (.not. lakepuddling .or. .not. puddle(c) ) .and. (rhow(c,j) > rhow(c,j+1) .or. &
                   (lake_icefrac(c,j) < 1._r8 .and. lake_icefrac(c,j+1) > 0._r8) ) ) then
-                
-                     sum1 = sum1 + dz_lake(c,i)*(t_lake(c,i)-tfrz) * &
+                qav(c) = qav(c) + dz_lake(c,i)*(t_lake(c,i)-tfrz) * &
                         ((1._r8 - lake_icefrac(c,i))*cwat + lake_icefrac(c,i)*cice_eff)
-                     !tav(c) = tav(c) + t_lake(c,i)*dz_lake(c,i)
-                     sum2 = sum2 + lake_icefrac(c,i)*dz_lake(c,i)
-                     sum3 = sum3 + dz_lake(c,i)
-               end if
-            end do
-         end if 
-         qav(fc) = sum1 
-         iceav(fc) = sum2
-         nav(fc) = sum3 
-      end do
+                !tav(c) = tav(c) + t_lake(c,i)*dz_lake(c,i)
+                iceav(c) = iceav(c) + lake_icefrac(c,i)*dz_lake(c,i)
+                nav(c) = nav(c) + dz_lake(c,i)
+                if (use_lch4) then
+                   jconvectbot(c) = j
+                end if
+             end if
+          end do
+       end do
 
-       !$acc parallel loop independent gang vector  default(present)
        do fc = 1, num_lakec
           c = filter_lakec(fc)
 
-          if ( bottomconvect(fc) .and. &
-               (.not. lakepuddling .or. .not. puddle(fc) ) .and. (rhow(fc,j) > rhow(fc,j+1) .or. &
+          if ( bottomconvect(c) .and. &
+               (.not. lakepuddling .or. .not. puddle(c) ) .and. (rhow(c,j) > rhow(c,j+1) .or. &
                (lake_icefrac(c,j) < 1._r8 .and. lake_icefrac(c,j+1) > 0._r8) ) ) then
-             qav(fc) = qav(fc)/nav(fc)
-             iceav(fc) = iceav(fc)/nav(fc)
+             qav(c) = qav(c)/nav(c)
+             iceav(c) = iceav(c)/nav(c)
              !If the average temperature is above freezing, put the extra energy into the water.
              !If it is below freezing, take it away from the ice.
-             if (qav(fc) > 0._r8) then
-                tav_froz(fc) = 0._r8 !Celsius
-                tav_unfr(fc) = qav(fc) / ((1._r8 - iceav(fc))*cwat)
-             else if (qav(fc) < 0._r8) then
-                tav_froz(fc) = qav(fc) / (iceav(fc)*cice_eff)
-                tav_unfr(fc) = 0._r8 !Celsius
+             if (qav(c) > 0._r8) then
+                tav_froz(c) = 0._r8 !Celsius
+                tav_unfr(c) = qav(c) / ((1._r8 - iceav(c))*cwat)
+             else if (qav(c) < 0._r8) then
+                tav_froz(c) = qav(c) / (iceav(c)*cice_eff)
+                tav_unfr(c) = 0._r8 !Celsius
              else
-                tav_froz(fc) = 0._r8
-                tav_unfr(fc) = 0._r8
+                tav_froz(c) = 0._r8
+                tav_unfr(c) = 0._r8
              end if
           end if
        end do
 
-       !$acc parallel loop independent gang vector default(present) copyin(j)
-       do fc = 1, num_lakec
-
-         c = filter_lakec(fc)
-         if (bottomconvect(fc) .and. nav(fc) > 0._r8) then
-            
-            !$acc loop seq 
-            do i = j, nlevlak
+       do i = j, nlevlak
+          do fc = 1, num_lakec
+             c = filter_lakec(fc)
+             if (bottomconvect(c) .and. nav(c) > 0._r8) then
 
                 !Put all the ice at the top.!
                 !If the average temperature is above freezing, put the extra energy into the water.
@@ -986,216 +915,138 @@ contains
                 !that preserves the correct total heat content given what the heat capacity of that
                 !layer will actually be.
 
-                if (i == j) zsum(fc) = 0._r8
-                if ((zsum(fc)+dz_lake(c,i))/nav(fc) <= iceav(fc)) then
+                if (i == j) zsum(c) = 0._r8
+                if ((zsum(c)+dz_lake(c,i))/nav(c) <= iceav(c)) then
                    lake_icefrac(c,i) = 1._r8
-                   t_lake(c,i) = tav_froz(fc) + tfrz
-                else if (zsum(fc)/nav(fc) < iceav(fc)) then
-                   lake_icefrac(c,i) = (iceav(fc)*nav(fc) - zsum(fc)) / dz_lake(c,i)
+                   t_lake(c,i) = tav_froz(c) + tfrz
+                else if (zsum(c)/nav(c) < iceav(c)) then
+                   lake_icefrac(c,i) = (iceav(c)*nav(c) - zsum(c)) / dz_lake(c,i)
                    ! Find average value that preserves correct heat content.
-                   t_lake(c,i) = ( lake_icefrac(c,i)*tav_froz(fc)*cice_eff &
-                               + (1._r8 - lake_icefrac(c,i))*tav_unfr(fc)*cwat ) &
+                   t_lake(c,i) = ( lake_icefrac(c,i)*tav_froz(c)*cice_eff &
+                               + (1._r8 - lake_icefrac(c,i))*tav_unfr(c)*cwat ) &
                                / ( lake_icefrac(c,i)*cice_eff + (1-lake_icefrac(c,i))*cwat ) + tfrz
                 else
                    lake_icefrac(c,i) = 0._r8
-                   t_lake(c,i) = tav_unfr(fc) + tfrz
+                   t_lake(c,i) = tav_unfr(c) + tfrz
                 end if
-                zsum(fc) = zsum(fc) + dz_lake(c,i)
+                zsum(c) = zsum(c) + dz_lake(c,i)
 
-                rhow(fc,i) = (1._r8 - lake_icefrac(c,i)) * &
+                rhow(c,i) = (1._r8 - lake_icefrac(c,i)) * &
                             1000._r8*( 1.0_r8 - 1.9549e-05_r8*(abs(t_lake(c,i)-tdmax))**1.68_r8 ) &
                           + lake_icefrac(c,i)*denice
-            end do
-         end if
-      end do
+             end if
+          end do
+       end do
+    end do
 
-    end do ! j loop
     ! Calculate lakeresist and grnd_ch4_cond for CH4 Module
     ! The CH4 will diffuse directly from the top soil layer to the atmosphere, so
     ! the whole lake resistance is included.
 
     if (use_lch4) then
-    !$acc parallel loop independent gang worker default(present) private(temp) 
-      do fc = 1, num_lakec
-         c = filter_lakec(fc)
-         temp = 0._r8 
-         !$acc loop vector reduction(+:temp)
-         do j = 1, nlevlak
-            if (j > jconvect(fc) .and. j < jconvectbot(fc)) then  ! Assume resistance is zero for levels that convect
-              temp = temp + dz(c,j)/kme(fc,j) ! dz/eddy or molecular diffusivity
-            end if
-            !  if (j == nlevlak) then ! Calculate grnd_ch4_cond
-            !     grnd_ch4_cond(c) = 1._r8 / (lakeresist(c) + lake_raw(c))
-
-            !     ! Lake water R + aerodynamic R
-            !     ! Snow will be considered in methane routine
-            !     ! No methane conduction through frozen lake
-            !     if (lake_icefrac(c,1) > 0.1_r8) grnd_ch4_cond(c) = 0._r8
-            !  end if
-         end do
-         !NOTE: lakeresist is initialized to zero. can be removed 
-         lakeresist(c) = lakeresist(c) + temp 
-         grnd_ch4_cond(c) = 1._r8 / (lakeresist(c) + lake_raw(c))
-
-         ! Lake water R + aerodynamic R
-         ! Snow will be considered in methane routine
-         ! No methane conduction through frozen lake
-         if (lake_icefrac(c,1) > 0.1_r8) grnd_ch4_cond(c) = 0._r8
+       do j = 1, nlevlak
+          do fc = 1, num_lakec
+             c = filter_lakec(fc)
+
+             if (j > jconvect(c) .and. j < jconvectbot(c)) then  ! Assume resistance is zero for levels that convect
+                lakeresist(c) = lakeresist(c) + dz(c,j)/kme(c,j) ! dz/eddy or molecular diffusivity
+             end if
+
+             if (j == nlevlak) then ! Calculate grnd_ch4_cond
+                grnd_ch4_cond(c) = 1._r8 / (lakeresist(c) + lake_raw(c))
+
+                ! Lake water R +  aerodynamic R
+                ! Snow will be considered in methane routine
+                ! No methane conduction through frozen lake
+                if (lake_icefrac(c,1) > 0.1_r8) grnd_ch4_cond(c) = 0._r8
+             end if
+
+          end do
        end do
     end if
 
     !!!!!!!!!!!!!!!!!!!!!!!
     ! 11!) Re-evaluate thermal properties and sum energy content.
     ! For lake
-    !$acc parallel loop independent gang vector collapse(2)  default(present)
     do j = 1, nlevlak
        do fc = 1, num_lakec
           c = filter_lakec(fc)
-          cv_lake(fc,j) = dz_lake(c,j) * (cwat*(1._r8-lake_icefrac(c,j)) + cice_eff*lake_icefrac(c,j))
+
+          cv_lake(c,j) = dz_lake(c,j) * (cwat*(1._r8-lake_icefrac(c,j)) + cice_eff*lake_icefrac(c,j))
        end do
     end do
 
     ! For snow / soil
     call SoilThermProp_Lake(bounds, num_lakec, filter_lakec, &
-         tk(1:num_lakec, :), &
-         cv(1:num_lakec, :), &
-         tktopsoillay(1:num_lakec), &
+         tk(bounds%begc:bounds%endc, :), &
+         cv(bounds%begc:bounds%endc, :), &
+         tktopsoillay(bounds%begc:bounds%endc), &
          soilstate_vars)
-    
+
+
     ! Do as above to sum energy content
-    !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3)
-    do fc = 1, num_lakec
-      c = filter_lakec(fc)
-      sum1 = 0._r8 
-      sum2 = 0._r8 
-      sum3 = 0._r8
-      !$acc loop vector reduction(+:sum1,sum2,sum3) 
-      do j = 1, nlevlak
-          sum1 = sum1 + cv_lake(fc,j)*(t_lake(c,j)-tfrz) &
+    do j = 1, nlevlak
+       do fc = 1, num_lakec
+          c = filter_lakec(fc)
+
+          ncvts(c) = ncvts(c) + cv_lake(c,j)*(t_lake(c,j)-tfrz) &
                    + cfus*dz_lake(c,j)*(1._r8-lake_icefrac(c,j))
-          sum2 = sum2 + phi(fc,j)
+          fin(c) = fin(c) + phi(c,j)
           ! New for CLM 4
-          sum3 = sum3 + cv_lake(fc,j)*t_lake(c,j)/1.e6
+          hc_soisno(c) = hc_soisno(c) + cv_lake(c,j)*t_lake(c,j)/1.e6
        end do
-       ncvts(fc) = sum1
-       fin(fc) = fin(fc) + sum2 
-       hc_soisno(c) = sum3
     end do
 
-    !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3,temp)
-    do fc = 1, num_lakec
-      c = filter_lakec(fc)
-      sum1 = 0._r8
-      sum2 = 0._r8 
-      sum3 = 0._r8
-      temp = 0._r8
-      !$acc loop vector reduction(+:sum1,sum2,sum3) 
-      do j = -nlevsno + 1, nlevgrnd
-          if (j >= jtop(fc)) then
-             sum1 = sum1 + cv(fc,j)*(t_soisno(c,j)-tfrz) &
+    do j = -nlevsno + 1, nlevgrnd
+       do fc = 1, num_lakec
+          c = filter_lakec(fc)
+
+          if (j >= jtop(c)) then
+             ncvts(c) = ncvts(c) + cv(c,j)*(t_soisno(c,j)-tfrz) &
                       + hfus*h2osoi_liq(c,j)
-            
-             if (j < 1) then 
-               sum2 = sum2 + phix(fc,j) !For SNICAR
-             end if 
-             if (j == 1 .and. h2osno(c) > 0._r8 .and. j == jtop(fc)) then
-                sum1 = sum1 - h2osno(c)*hfus
+             if (j < 1) fin(c) = fin(c) + phix(c,j) !For SNICAR
+             if (j == 1 .and. h2osno(c) > 0._r8 .and. j == jtop(c)) then
+                ncvts(c) = ncvts(c) - h2osno(c)*hfus
              end if
-             sum3 = sum3 + cv(fc,j)*t_soisno(c,j)/1.e6
-             if (j >= 1) then 
-               temp = temp + cv(fc,j)*t_soisno(c,j)/1.e6
-             end if 
-
+             hc_soisno(c) = hc_soisno(c) + cv(c,j)*t_soisno(c,j)/1.e6
+             if (j >= 1) hc_soi(c) = hc_soi(c) + cv(c,j)*t_soisno(c,j)/1.e6
           end if
-
-          if (j == 1) sum2 = sum2 + phi_soil(fc)
+          if (j == 1) fin(c) = fin(c) + phi_soil(c)
        end do
-       ncvts(fc) = ncvts(fc) + sum1 
-       fin(fc) = fin(fc) + sum2
-       hc_soisno(c) = hc_soisno(c) + sum3
-       hc_soi(c) = hc_soi(c) + temp
-    end do
-   
-    !$acc parallel loop independent gang vector default(present) private(c)
-    do fc = 1, num_lakec
-      c = filter_lakec(fc)
-      errsoi(c) = (ncvts(fc)-ocvts(fc)) / dtime_mod - fin(fc)
     end do
 
+
     ! Check energy conservation.
-    ! NOTE: separate this into two loops to avoid a filter to column index? 
-    !$acc parallel loop independent gang vector default(present) private(p,c,fc)
     do fp = 1, num_lakep
        p = filter_lakep(fp)
        c = veg_pp%column(p)
-
+       errsoi(c) = (ncvts(c)-ocvts(c)) / dtime - fin(c)
        if (abs(errsoi(c)) < 0.10_r8) then ! else send to Balance Check and abort
           eflx_sh_tot(p)    = eflx_sh_tot(p)    - errsoi(c)
           eflx_sh_grnd(p)   = eflx_sh_grnd(p)   - errsoi(c)
           eflx_soil_grnd(p) = eflx_soil_grnd(p) + errsoi(c)
           eflx_gnet(p)      = eflx_gnet(p)      + errsoi(c)
           if (abs(errsoi(c)) > 1.e-3_r8) then
-            print *, 'errsoi incorporated into sensible heat in LakeTemperature: c, (W/m^2):', c, errsoi(c)
+             write(iulog,*)'errsoi incorporated into sensible heat in LakeTemperature: c, (W/m^2):', c, errsoi(c)
           end if
           errsoi(c) = 0._r8
        end if
+
     end do
     ! This loop assumes only one point per column.
 
     ! lake_icethick diagnostic.
-    !$acc parallel loop independent gang worker default(present) private(sum1)
-    do fc = 1, num_lakec
-      c = filter_lakec(fc)
-      sum1 = 0._r8
-      !$acc loop vector reduction(+:sum1)
-      do j = 1, nlevlak
-         ! Convert from nominal to physical thickness
-          sum1 = sum1 + lake_icefrac(c,j)*dz_lake(c,j)*denh2o/denice
+    do j = 1, nlevlak
+       do fc = 1, num_lakec
+          c = filter_lakec(fc)
+
+          if (j == 1) lake_icethick(c) = 0._r8
+
+          lake_icethick(c) = lake_icethick(c) + lake_icefrac(c,j)*dz_lake(c,j)*denh2o/denice
+                                                           ! Convert from nominal to physical thickness
        end do
-       lake_icethick(c) = sum1
     end do
-    !$acc exit data delete(&
-    !!!!  !$acc   beta(1:num_lakec), &
-      !$acc   a(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd) ,& 
-      !$acc   b(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd) ,& 
-      !$acc   c1(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd),& 
-      !$acc   r(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd) ,&
-      !$acc   rhow(1:num_lakec,1:nlevlak)           ,& 
-      !$acc   phi(1:num_lakec,1:nlevlak),& 
-      !$acc   kme(1:num_lakec,1:nlevlak)            ,&  
-      !$acc   phi_soil(1:num_lakec)     ,& 
-      !$acc   fin(1:num_lakec)          ,&
-      !$acc   ocvts(1:num_lakec)        ,&
-      !$acc   ncvts(1:num_lakec)        ,&
-      !$acc   tav_froz(1:num_lakec)                 ,&
-      !$acc   tav_unfr(1:num_lakec)                 ,& 
-      !$acc   nav(1:num_lakec)                      ,&
-      !$acc   iceav(1:num_lakec)                     ,&
-      !$acc   qav(1:num_lakec)                       ,&
-      !$acc   jtop(1:num_lakec)                      ,&
-      !$acc   cv(1:num_lakec,-nlevsno+1:nlevgrnd)    ,&
-      !$acc   tk(1:num_lakec,-nlevsno+1:nlevgrnd)    ,&
-      !$acc   cv_lake(1:num_lakec,1:nlevlak)               ,&
-      !$acc   tk_lake(1:num_lakec,1:nlevlak)               ,&
-      !$acc   cvx (1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd),&
-      !$acc   tkix(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd),&
-      !$acc   tx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)  ,&
-      !$acc   tktopsoillay(1:num_lakec)                    ,&
-      !$acc   fnx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd) ,&
-      !$acc   phix(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd),&
-      !$acc   zx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd)  ,&
-      !$acc   factx(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd), &
-      !$acc   sabg_lyr_col(1:num_lakec,-nlevsno+1:1), &
-      !$acc   jconvect(1:num_lakec), &
-      !$acc   jconvectbot(1:num_lakec)  ,&
-      !$acc   bottomconvect(1:num_lakec) ,&
-      !$acc   puddle(1:num_lakec)  , & 
-      !$acc   frzn(1:num_lakec)    ,zsum(1:num_lakec), &
-      !$acc   gam(1:num_lakec,-nlevsno+1:nlevlak+nlevgrnd), &
-      !$acc   lake_col_to_filter(bounds%begc:bounds%endc) ,&
-      !$acc    cwat, cice_eff, cfus, tkice_eff, km )
-
-    !$acc exit data delete(temp,sum1,sum2,sum3, icesum) 
+
     end associate
    end subroutine LakeTemperature
 
@@ -1220,6 +1071,7 @@ contains
      ! For lakes, the proper soil layers (not snow) should always be saturated.
      !
      ! !USES:
+      !$acc routine seq
      use elm_varcon  , only : denh2o, denice, tfrz, tkwat, tkice, tkair
      use elm_varcon  , only : cpice,  cpliq, thk_bedrock
      use elm_varpar  , only : nlevsno, nlevsoi, nlevgrnd
@@ -1228,9 +1080,9 @@ contains
      type(bounds_type)      , intent(in)  :: bounds
      integer                , intent(in)  :: num_lakec                        ! number of column lake points in column filter
      integer                , intent(in)  :: filter_lakec(:)                  ! column filter for lake points
-     real(r8)               , intent(out) :: cv( 1: , -nlevsno+1: ) ! heat capacity [J/(m2 K)] [col, lev]
-     real(r8)               , intent(out) :: tk( 1: , -nlevsno+1: ) ! thermal conductivity [W/(m K)] [col, lev]
-     real(r8)               , intent(out) :: tktopsoillay( 1: )     ! thermal conductivity [W/(m K)] [col]
+     real(r8)               , intent(out) :: cv( bounds%begc: , -nlevsno+1: ) ! heat capacity [J/(m2 K)] [col, lev]
+     real(r8)               , intent(out) :: tk( bounds%begc: , -nlevsno+1: ) ! thermal conductivity [W/(m K)] [col, lev]
+     real(r8)               , intent(out) :: tktopsoillay( bounds%begc: )     ! thermal conductivity [W/(m K)] [col]
      type(soilstate_type)   , intent(in)  :: soilstate_vars
 
      !
@@ -1242,7 +1094,7 @@ contains
      real(r8) :: dke                       ! kersten number
      real(r8) :: fl                        ! fraction of liquid or unfrozen water to total water
      real(r8) :: satw                      ! relative total water content of soil.
-     real(r8) :: thk(1:num_lakec,-nlevsno+1:nlevgrnd) ! thermal conductivity of layer
+     real(r8) :: thk(bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd) ! thermal conductivity of layer
      real(r8) :: xicevol                   ! (virtual excess ice volume per nominal soil volume)
      !-----------------------------------------------------------------------
 
@@ -1266,9 +1118,8 @@ contains
           t_soisno    => col_es%t_soisno    & ! Input:  [real(r8) (:,:)]  soil temperature (Kelvin)
           )
 
-      !$acc enter data create(thk(1:num_lakec,-nlevsno+1:nlevgrnd))
        ! Thermal conductivity of soil from Farouki (1981)
-      !$acc parallel loop independent gang vector collapse(2) default(present) private(c)
+
        do j = -nlevsno+1,nlevgrnd
           do fc = 1, num_lakec
              c = filter_lakec(fc)
@@ -1291,12 +1142,12 @@ contains
                    dke = satw
                    dksat = tkmg(c,j)*0.249_r8**(fl*watsat(c,j))*2.29_r8**watsat(c,j)
                 endif
-                thk(fc,j) = dke*dksat + (1._r8-dke)*tkdry(c,j)
+                thk(c,j) = dke*dksat + (1._r8-dke)*tkdry(c,j)
                 satw = (h2osoi_liq(c,j)/denh2o + h2osoi_ice(c,j)/denice)/(dz(c,j)*watsat(c,j))
                 ! Hydrology routine won't let the excess be liquid.
                 if (satw > 1._r8) then
                    xicevol = (satw-1._r8)*watsat(c,j)
-                   thk(fc,j) = (thk(fc,j) + xicevol*tkice)/(1._r8 + xicevol)/(1._r8 + xicevol)
+                   thk(c,j) = (thk(c,j) + xicevol*tkice)/(1._r8 + xicevol)/(1._r8 + xicevol)
                    ! Use simple mean because excess ice is likely to be in chunks, thus conductivities add
                    ! rather than the usual addition of resistances.
                    ! Conductivity is reduced by the extra virtual volume fraction, as dz is not changing.
@@ -1308,15 +1159,16 @@ contains
                 ! of the timestep or precise freezing trajectory.
                 ! Does real sediment under lakes heave or drain? Could revisit later.
              elseif (j > nlevsoi) then
-                thk(fc,j) = thk_bedrock
+                thk(c,j) = thk_bedrock
              endif
 
              ! Thermal conductivity of snow, which from Jordan (1991) pp. 18
              ! Only examine levels from snl(c)+1 -> 0 where snl(c) < 1
              if (snl(c)+1 < 1 .AND. (j >= snl(c)+1) .AND. (j <= 0)) then
                 bw = (h2osoi_ice(c,j)+h2osoi_liq(c,j))/dz(c,j)
-                thk(fc,j) = tkair + (7.75e-5_r8 *bw + 1.105e-6_r8*bw*bw)*(tkice-tkair)
+                thk(c,j) = tkair + (7.75e-5_r8 *bw + 1.105e-6_r8*bw*bw)*(tkice-tkair)
              end if
+
           end do
        end do
 
@@ -1326,34 +1178,32 @@ contains
        ! For the first case, the snow layer conductivity for the middle of the layer will be returned.
        ! Because the interfaces are below the soil layers, the conductivity for the top soil layer
        ! will have to be returned separately.
-       !$acc parallel loop independent collapse(2) gang vector default(present) private(c) 
        do j = -nlevsno+1,nlevgrnd
           do fc = 1,num_lakec
              c = filter_lakec(fc)
              if (j >= snl(c)+1 .AND. j <= nlevgrnd-1 .AND. j /= 0) then
-                tk(fc,j) = thk(fc,j)*thk(fc,j+1)*(z(c,j+1)-z(c,j)) &
-                     /(thk(fc,j)*(z(c,j+1)-zi(c,j))+thk(fc,j+1)*(zi(c,j)-z(c,j)))
+                tk(c,j) = thk(c,j)*thk(c,j+1)*(z(c,j+1)-z(c,j)) &
+                     /(thk(c,j)*(z(c,j+1)-zi(c,j))+thk(c,j+1)*(zi(c,j)-z(c,j)))
              else if (j == 0 .and. j >= snl(c)+1) then
-                tk(fc,j) = thk(fc,j)
+                tk(c,j) = thk(c,j)
              else if (j == nlevgrnd) then
-                tk(fc,j) = 0._r8
+                tk(c,j) = 0._r8
              end if
              ! For top soil layer.
-             if (j == 1) tktopsoillay(fc) = thk(fc,j)
+             if (j == 1) tktopsoillay(c) = thk(c,j)
           end do
        end do
 
        ! Soil heat capacity, from de Vires (1963)
 
-       !$acc parallel loop collapse(2) gang vector default(present) private(c)
        do j = 1, nlevgrnd
           do fc = 1,num_lakec
              c = filter_lakec(fc)
-             cv(fc,j) = csol(c,j)*(1-watsat(c,j))*dz(c,j) +   &
+             cv(c,j) = csol(c,j)*(1-watsat(c,j))*dz(c,j) +   &
                   (h2osoi_ice(c,j)*cpice + h2osoi_liq(c,j)*cpliq)
              !   if (j == 1) then
              !      if (snl(c)+1 == 1 .AND. h2osno(c) > 0._r8) then
-             !         cv(fc,j) = cv(fc,j) + cpice*h2osno(c)
+             !         cv(c,j) = cv(c,j) + cpice*h2osno(c)
              !      end if
              !   end if
              ! Won't worry about heat capacity for thin snow on lake with no snow layers.
@@ -1362,25 +1212,23 @@ contains
        end do
 
        ! Snow heat capacity
-       !$acc parallel loop collapse(2) gang vector default(present) private(c)
+
        do j = -nlevsno+1,0
           do fc = 1,num_lakec
              c = filter_lakec(fc)
              if (snl(c)+1 < 1 .and. j >= snl(c)+1) then
-                cv(fc,j) = cpliq*h2osoi_liq(c,j) + cpice*h2osoi_ice(c,j)
+                cv(c,j) = cpliq*h2osoi_liq(c,j) + cpice*h2osoi_ice(c,j)
              end if
           end do
        end do
 
-       !$acc exit data delete(thk(1:num_lakec,-nlevsno+1:nlevgrnd))
-
      end associate
 
    end subroutine SoilThermProp_Lake
 
    !-----------------------------------------------------------------------
-   subroutine PhaseChange_Lake (bounds, num_lakec, filter_lakec, cv, cv_lake, &
-        lakestate_vars,  dtime_mod )
+   subroutine PhaseChange_Lake (bounds, num_lakec, filter_lakec, cv, cv_lake, lhabs, &
+        energyflux_vars, lakestate_vars,  dtime )
      !
      ! !DESCRIPTION:
      ! Calculation of the phase change within snow, soil, & lake layers:
@@ -1399,6 +1247,7 @@ contains
      ! Errors will be trapped at the end of LakeTemperature.
      !
      ! !USES:
+      !$acc routine seq
      use elm_varcon       , only : tfrz, hfus, denh2o, denice, cpliq, cpice
      use elm_varpar       , only : nlevsno, nlevgrnd, nlevlak
      !
@@ -1406,10 +1255,12 @@ contains
      type(bounds_type)      , intent(in)    :: bounds
      integer                , intent(in)    :: num_lakec                        ! number of lake columns
      integer                , intent(in)    :: filter_lakec(:)                  ! column filter for lake points
-     real(r8)               , intent(inout) :: cv( 1: , -nlevsno+1: ) ! heat capacity [J/(m2 K)] [col, lev]
-     real(r8)               , intent(inout) :: cv_lake( 1: , 1: )     ! heat capacity [J/(m2 K)] [col, levlak]
+     real(r8)               , intent(inout) :: cv( bounds%begc: , -nlevsno+1: ) ! heat capacity [J/(m2 K)] [col, lev]
+     real(r8)               , intent(inout) :: cv_lake( bounds%begc: , 1: )     ! heat capacity [J/(m2 K)] [col, levlak]
+     real(r8)               , intent(out)   :: lhabs( bounds%begc: )            ! total per-column latent heat abs. (J/m^2) [col]
+     type(energyflux_type)  , intent(inout) :: energyflux_vars
      type(lakestate_type)   , intent(inout) :: lakestate_vars
-     real(r8), intent(in) :: dtime_mod
+     real(r8), intent(in) :: dtime
      !
      ! !LOCAL VARIABLES:
      integer  :: j,c,g                              ! do loop index
@@ -1417,6 +1268,7 @@ contains
      real(r8) :: heatavail                          ! available energy for melting or freezing (J/m^2)
      real(r8) :: heatrem                            ! energy residual or loss after melting or freezing
      real(r8) :: melt                               ! actual melting (+) or freezing (-) [kg/m2]
+     !real(r8), parameter :: smallnumber = 1.e-7_r8 ! to prevent tiny residuals from rounding error
      real(r8), parameter :: smallnumber = 1.e-12_r8 ! The above actually was enough to cause a 0.1 W/m^2 energy imbalance
      ! when the bottom lake layer started freezing in a 50m Arctic lake
      logical  :: dophasechangeflag
@@ -1450,15 +1302,16 @@ contains
 
 
        ! Initialization
-      !$acc parallel loop independent gang vector default(present)
+
        do fc = 1,num_lakec
           c = filter_lakec(fc)
+
           qflx_snomelt(c)   = 0._r8
           eflx_snomelt(c)   = 0._r8
+          lhabs(c)          = 0._r8
           qflx_snow_melt(c) = 0._r8
        end do
 
-       !$acc parallel loop independent gang vector default(present)
        do j = -nlevsno+1,0
           do fc = 1,num_lakec
              c = filter_lakec(fc)
@@ -1470,20 +1323,21 @@ contains
        end do
 
        ! Check for case of snow without snow layers and top lake layer temp above freezing.
-       !$acc parallel loop independent gang vector default(present) private(c, melt) 
+
        do fc = 1,num_lakec
           c = filter_lakec(fc)
 
           if (snl(c) == 0 .and. h2osno(c) > 0._r8 .and. t_lake(c,1) > tfrz) then
-             heatavail = (t_lake(c,1) - tfrz) * cv_lake(fc,1)
+             heatavail = (t_lake(c,1) - tfrz) * cv_lake(c,1)
              melt = min(h2osno(c), heatavail/hfus)
              heatrem = max(heatavail - melt*hfus, 0._r8)
              !catch small negative value to keep t at tfrz
-             t_lake(c,1) = tfrz + heatrem/(cv_lake(fc,1))
+             t_lake(c,1) = tfrz + heatrem/(cv_lake(c,1))
              snow_depth(c) = snow_depth(c)*(1._r8 - melt/h2osno(c))
              h2osno(c) = h2osno(c) - melt
-             qflx_snomelt(c)   = qflx_snomelt(c)   + melt/dtime_mod
-             qflx_snow_melt(c) = qflx_snow_melt(c) + melt/dtime_mod
+             lhabs(c) = lhabs(c) + melt*hfus
+             qflx_snomelt(c)   = qflx_snomelt(c)   + melt/dtime
+             qflx_snow_melt(c) = qflx_snow_melt(c) + melt/dtime
              ! Prevent tiny residuals
              if (h2osno(c) < smallnumber) h2osno(c) = 0._r8
              if (snow_depth(c) < smallnumber) snow_depth(c) = 0._r8
@@ -1491,7 +1345,7 @@ contains
        end do
 
        ! Lake phase change
-       !$acc parallel loop independent gang vector collapse(2) default(present) private(c,melt,heatrem,dophasechangeflag)
+
        do j = 1,nlevlak
           do fc = 1,num_lakec
              c = filter_lakec(fc)
@@ -1499,14 +1353,14 @@ contains
              dophasechangeflag = .false.
              if (t_lake(c,j) > tfrz .and. lake_icefrac(c,j) > 0._r8) then ! melting
                 dophasechangeflag = .true.
-                heatavail = (t_lake(c,j) - tfrz) * cv_lake(fc,j)
+                heatavail = (t_lake(c,j) - tfrz) * cv_lake(c,j)
                 melt = min(lake_icefrac(c,j)*denh2o*dz_lake(c,j), heatavail/hfus)
                 !denh2o is used because layer thickness is not adjusted for freezing
                 heatrem = max(heatavail - melt*hfus, 0._r8)
                 !catch small negative value to keep t at tfrz
              else if (t_lake(c,j) < tfrz .and. lake_icefrac(c,j) < 1._r8) then !freezing
                 dophasechangeflag = .true.
-                heatavail = (t_lake(c,j) - tfrz) * cv_lake(fc,j)
+                heatavail = (t_lake(c,j) - tfrz) * cv_lake(c,j)
                 melt = max(-(1._r8-lake_icefrac(c,j))*denh2o*dz_lake(c,j), heatavail/hfus)
                 !denh2o is used because layer thickness is not adjusted for freezing
                 heatrem = min(heatavail - melt*hfus, 0._r8)
@@ -1515,9 +1369,10 @@ contains
              ! Update temperature and ice fraction.
              if (dophasechangeflag) then
                 lake_icefrac(c,j) = lake_icefrac(c,j) - melt/(denh2o*dz_lake(c,j))
+                lhabs(c) = lhabs(c) + melt*hfus
                 ! Update heat capacity
-                cv_lake(fc,j) = cv_lake(fc,j) + melt*(cpliq-cpice)
-                t_lake(c,j) = tfrz + heatrem/cv_lake(fc,j)
+                cv_lake(c,j) = cv_lake(c,j) + melt*(cpliq-cpice)
+                t_lake(c,j) = tfrz + heatrem/cv_lake(c,j)
                 ! Prevent tiny residuals
                 if (lake_icefrac(c,j) > 1._r8 - smallnumber) lake_icefrac(c,j) = 1._r8
                 if (lake_icefrac(c,j) < smallnumber)         lake_icefrac(c,j) = 0._r8
@@ -1527,7 +1382,7 @@ contains
 
        ! Snow & soil phase change
        ! Currently, does not do freezing point depression.
-       !$acc parallel loop independent gang vector default(present) collapse(2) private(c,melt,heatrem,dophasechangeflag)
+
        do j = -nlevsno+1,nlevgrnd
           do fc = 1,num_lakec
              c = filter_lakec(fc)
@@ -1537,27 +1392,28 @@ contains
 
                 if (t_soisno(c,j) > tfrz .and. h2osoi_ice(c,j) > 0._r8) then ! melting
                    dophasechangeflag = .true.
-                   heatavail = (t_soisno(c,j) - tfrz) * cv(fc,j)
+                   heatavail = (t_soisno(c,j) - tfrz) * cv(c,j)
                    melt = min(h2osoi_ice(c,j), heatavail/hfus)
                    heatrem = max(heatavail - melt*hfus, 0._r8)
                    !catch small negative value to keep t at tfrz
                    if (j <= 0) then !snow
                       imelt(c,j) = 1
-                      qflx_snomelt(c) = qflx_snomelt(c) + melt/dtime_mod
+                      qflx_snomelt(c) = qflx_snomelt(c) + melt/dtime
                    end if
                 else if (t_soisno(c,j) < tfrz .and. h2osoi_liq(c,j) > 0._r8) then !freezing
                    dophasechangeflag = .true.
-                   heatavail = (t_soisno(c,j) - tfrz) * cv(fc,j)
+                   heatavail = (t_soisno(c,j) - tfrz) * cv(c,j)
                    melt = max(-h2osoi_liq(c,j), heatavail/hfus)
                    heatrem = min(heatavail - melt*hfus, 0._r8)
                    !catch small positive value to keep t at tfrz
                    if (j <= 0) then !snow
                       imelt(c,j) = 2
+                      !qflx_snomelt(c) = qflx_snomelt(c) + melt
                       ! Does this works for both signs of melt in SnowHydrology? I think
                       ! qflx_snomelt(c) is just output.
                       ! It looks like qflx_snomelt is just supposed to be positive.
                       ! New variable for CLM 4
-                      qflx_snofrz_lyr(c,j) = -melt/dtime_mod
+                      qflx_snofrz_lyr(c,j) = -melt/dtime
                    end if
                 end if
 
@@ -1565,9 +1421,10 @@ contains
                 if (dophasechangeflag) then
                    h2osoi_ice(c,j) = h2osoi_ice(c,j) - melt
                    h2osoi_liq(c,j) = h2osoi_liq(c,j) + melt
+                   lhabs(c) = lhabs(c) + melt*hfus
                    ! Update heat capacity
-                   cv(fc,j) = cv(fc,j) + melt*(cpliq-cpice)
-                   t_soisno(c,j) = tfrz + heatrem/cv(fc,j)
+                   cv(c,j) = cv(c,j) + melt*(cpliq-cpice)
+                   t_soisno(c,j) = tfrz + heatrem/cv(c,j)
                    ! Prevent tiny residuals
                    if (h2osoi_ice(c,j) < smallnumber) h2osoi_ice(c,j) = 0._r8
                    if (h2osoi_liq(c,j) < smallnumber) h2osoi_liq(c,j) = 0._r8
@@ -1578,13 +1435,10 @@ contains
        end do
 
        ! Update eflx_snomelt(c)
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1,num_lakec
           c = filter_lakec(fc)
           eflx_snomelt(c) = qflx_snomelt(c)*hfus
        end do
-
-       !$acc parallel loop independent gang vector default(present) collapse(2) private(c)
        do j = -nlevsno+1,0
           do fc = 1,num_lakec
              c = filter_lakec(fc)
diff --git a/components/elm/src/biogeophys/PhotosynthesisMod.F90 b/components/elm/src/biogeophys/PhotosynthesisMod.F90
index dcdf0941a1..c2825484e9 100644
--- a/components/elm/src/biogeophys/PhotosynthesisMod.F90
+++ b/components/elm/src/biogeophys/PhotosynthesisMod.F90
@@ -38,6 +38,7 @@ module  PhotosynthesisMod
   use VegetationDataType  , only : veg_wf, veg_ws
   use ColumnDataType      , only : col_es, col_ws, col_wf
   use SoilStateType       , only : soilstate_type
+  use WaterfluxType       , only : waterflux_type
   !
   implicit none
   save
@@ -93,18 +94,18 @@ module  PhotosynthesisMod
   !$acc declare copyin(stomatalcond_mtd_bb1987)
   !$acc declare copyin(stomatalcond_mtd_medlyn2011)
   type :: photo_params_type
-     real(r8),pointer , public :: krmax              (:)   => null()
+     real(r8),pointer , public  :: krmax              (:)   => null()
      real(r8),pointer , public :: kmax               (:,:) => null()
      real(r8),pointer , public :: psi50              (:,:) => null()
      real(r8),pointer , public :: ck                 (:,:) => null()
-     real(r8),pointer , public :: psi_soil_ref       (:)   => null()
+     real(r8),pointer , public  :: psi_soil_ref       (:)   => null()
      real(r8),pointer , public :: lmr_intercept_atkin(:)   => null()
   contains
      procedure, private :: allocParams
      procedure, public :: readParams
   end type photo_params_type
   !
-  type(photo_params_type), public :: params_inst  ! params_inst is populated in readParamsMod
+  type(photo_params_type), public, protected :: params_inst  ! params_inst is populated in readParamsMod
   !$acc declare create(params_inst)
 
 contains
@@ -206,14 +207,12 @@ contains
  end subroutine readParams
 
 
+
   !------------------------------------------------------------------------------
-  subroutine Photosynthesis ( bounds, fn, filterp,converged, &
+  subroutine Photosynthesis ( bounds, fn, filterp, &
        esat_tv, eair, oair, cair, rb, btran, &
-       dayl_factor, surfalb_vars, solarabs_vars, &
-       canopystate_vars, photosyns_vars, phase, &
-       par_z, lai_z, vcmaxcint, alphapsn, &
-       ci_z, rs, rs_z, lmr, lmr_z, psn, &
-       psn_z, psn_wc, psn_wj, psn_wp)
+       dayl_factor, atm2lnd_vars, surfalb_vars, solarabs_vars, &
+       canopystate_vars, photosyns_vars, phase)
     !
     ! !DESCRIPTION:
     ! Leaf photosynthesis and stomatal conductance calculation as described by
@@ -223,6 +222,7 @@ contains
     ! Note: This subroutine is not called via FATES (RGK)
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : rgas, tfrz
     use elm_varctl     , only : carbon_only
     use pftvarcon      , only : nbrdlf_dcd_tmp_shrub, nsoybean, nsoybeanirrig, npcropmin
@@ -230,46 +230,31 @@ contains
     !
     ! !ARGUMENTS:
     type(bounds_type)      , intent(in)    :: bounds
-    integer                , intent(in)    :: fn                   ! size of pft filter
-    integer                , intent(in)    :: filterp(1:fn)          ! patch filter
-    integer                , intent(in)    :: converged(1:fn) 
-    real(r8)               , intent(in)    :: esat_tv( 1:fn )      ! saturation vapor pressure at t_veg (Pa) [pft]
-    real(r8)               , intent(in)    :: eair(1:fn)           ! vapor pressure of canopy air (Pa) [pft]
-    real(r8)               , intent(in)    :: oair(1:fn)           ! Atmospheric O2 partial pressure (Pa) [pft]
-    real(r8)               , intent(in)    :: cair(1:fn)           ! Atmospheric CO2 partial pressure (Pa) [pft]
-    real(r8)               , intent(in)    :: rb( 1:fn )           ! boundary layer resistance (s/m) [pft]
-    real(r8)               , intent(in)    :: btran( bounds%begp: )! transpiration wetness factor (0 to 1) [pft]
-    real(r8)               , intent(in)    :: dayl_factor( 1:fn )  ! scalar (0-1) for daylength
-    type(surfalb_type)     , intent(inout) :: surfalb_vars
-    type(solarabs_type)    , intent(inout) :: solarabs_vars
-    type(canopystate_type) , intent(inout) :: canopystate_vars
-    type(photosyns_type)   , intent(inout) :: photosyns_vars
-    character(len=3)       , intent(in)    :: phase               ! 'sun' or 'sha'
-    !!passing these variables as arguments to avoid deep copying the local pointers to GPU
-    real(r8), intent(in) :: par_z    (bounds%begp:,:)  ! Input:  [real(r8) (:,:) ] par absorbed per unit lai for canopy layer (w/m**2)
-    real(r8), intent(in) :: lai_z    (bounds%begp:,:)  ! Input:  [real(r8) (:,:) ] leaf area index for canopy layer, sunlit or shaded
-    real(r8), intent(in) :: vcmaxcint(bounds%begp:)    ! Input:  [real(r8) (:)   ] leaf to canopy scaling coefficient
-    real(r8), intent(inout) :: alphapsn (bounds%begp:) ! Output:  [real(r8) (:)   ] 13C fractionation factor for PSN ()
-    real(r8), intent(inout) :: ci_z  (bounds%begp:,:)  ! Output: [real(r8) (:,:) ] intracellular leaf CO2 (Pa)
-    real(r8), intent(inout) :: rs    (bounds%begp:)    ! Output: [real(r8) (:)   ] leaf stomatal resistance (s/m)
-    real(r8), intent(inout) :: rs_z  (bounds%begp:,:)  ! Output: [real(r8) (:,:) ] canopy layer: leaf stomatal resistance (s/m)
-    real(r8), intent(inout) :: lmr   (bounds%begp:)    ! Output: [real(r8) (:)   ] leaf maintenance respiration rate (umol CO2/m**2/s)
-    real(r8), intent(inout) :: lmr_z (bounds%begp:,:)  ! Output: [real(r8) (:,:) ] canopy layer: leaf maintenance respiration rate (umol CO2/m**2/s)
-    real(r8), intent(inout) :: psn   (bounds%begp:)    ! Output: [real(r8) (:)   ] foliage photosynthesis (umol co2 /m**2/ s) [always +]
-    real(r8), intent(inout) :: psn_z (bounds%begp:,:)  ! Output: [real(r8) (:,:) ] canopy layer: foliage photosynthesis (umol co2 /m**2/ s) [always +]
-    real(r8), intent(inout) :: psn_wc(bounds%begp:)    ! Output: [real(r8) (:)   ] Rubisco-limited foliage photosynthesis (umol co2 /m**2/ s) [always +]
-    real(r8), intent(inout) :: psn_wj(bounds%begp:)    ! Output: [real(r8) (:)   ] RuBP-limited foliage photosynthesis (umol co2 /m**2/ s) [always +]
-    real(r8), intent(inout) :: psn_wp(bounds%begp:)    ! Output: [real(r8) (:)   ] product-limited foliage photosynthesis (umol co2 /m**2/ s) [always +]
+    integer                , intent(in)    :: fn                             ! size of pft filter
+    integer                , intent(in)    :: filterp(fn)                    ! patch filter
+    real(r8)               , intent(in)    :: esat_tv( bounds%begp: )        ! saturation vapor pressure at t_veg (Pa) [pft]
+    real(r8)               , intent(in)    :: eair( bounds%begp: )           ! vapor pressure of canopy air (Pa) [pft]
+    real(r8)               , intent(in)    :: oair( bounds%begp: )           ! Atmospheric O2 partial pressure (Pa) [pft]
+    real(r8)               , intent(in)    :: cair( bounds%begp: )           ! Atmospheric CO2 partial pressure (Pa) [pft]
+    real(r8)               , intent(in)    :: rb( bounds%begp: )             ! boundary layer resistance (s/m) [pft]
+    real(r8)               , intent(in)    :: btran( bounds%begp: )          ! transpiration wetness factor (0 to 1) [pft]
+    real(r8)               , intent(in)    :: dayl_factor( bounds%begp: )    ! scalar (0-1) for daylength
+    type(atm2lnd_type)     , intent(inout)    :: atm2lnd_vars
+    type(surfalb_type)     , intent(inout)    :: surfalb_vars
+    type(solarabs_type)    , intent(inout)    :: solarabs_vars
+    type(canopystate_type) , intent(inout)    :: canopystate_vars
+    type(photosyns_type)   , intent(inout)    :: photosyns_vars
+    character(len=3)       , intent(in)    :: phase                          ! 'sun' or 'sha'
 
     !
     ! !LOCAL VARIABLES:
     !
     ! Leaf photosynthesis parameters
-    real(r8) :: jmax_z(1:fn,nlevcan)  ! maximum electron transport rate (umol electrons/m**2/s)
-    real(r8) :: lnc(1:fn)   ! leaf N concentration (gN leaf/m^2)
-    real(r8) :: bbbopt      ! Ball-Berry minimum leaf conductance, unstressed (umol H2O/m**2/s)
-    ! real(r8) :: mbbopt(1:fn)! Ball-Berry slope of conductance-photosynthesis relationship, unstressed
-    real(r8) :: kn(1:fn)    ! leaf nitrogen decay coefficient
+    real(r8) :: jmax_z(bounds%begp:bounds%endp,nlevcan)  ! maximum electron transport rate (umol electrons/m**2/s)
+    real(r8) :: lnc(bounds%begp:bounds%endp)   ! leaf N concentration (gN leaf/m^2)
+    real(r8) :: bbbopt(bounds%begp:bounds%endp)! Ball-Berry minimum leaf conductance, unstressed (umol H2O/m**2/s)
+    real(r8) :: mbbopt(bounds%begp:bounds%endp)! Ball-Berry slope of conductance-photosynthesis relationship, unstressed
+    real(r8) :: kn(bounds%begp:bounds%endp)    ! leaf nitrogen decay coefficient
     real(r8) :: vcmax25top     ! canopy top: maximum rate of carboxylation at 25C (umol CO2/m**2/s)
     real(r8) :: jmax25top      ! canopy top: maximum electron transport rate at 25C (umol electrons/m**2/s)
     real(r8) :: tpu25top       ! canopy top: triose phosphate utilization rate at 25C (umol CO2/m**2/s)
@@ -289,7 +274,7 @@ contains
     real(r8) :: jmaxha         ! activation energy for jmax (J/mol)
     real(r8) :: tpuha          ! activation energy for tpu (J/mol)
     real(r8) :: lmrha          ! activation energy for lmr (J/mol)
-    ! real(r8) :: kcha           ! activation energy for kc (J/mol)
+    real(r8) :: kcha           ! activation energy for kc (J/mol)
     real(r8) :: koha           ! activation energy for ko (J/mol)
     real(r8) :: cpha           ! activation energy for cp (J/mol)
 
@@ -308,14 +293,15 @@ contains
     real(r8) :: tpuc           ! scaling factor for high temperature inhibition (25 C = 1.0)
     real(r8) :: lmrc           ! scaling factor for high temperature inhibition (25 C = 1.0)
 
-    real(r8), parameter :: fnps = 0.15_r8  ! fraction of light absorbed by non-photosynthetic pigments
-    real(r8), parameter :: theta_psii = 0.7_r8 ! empirical curvature parameter for electron transport rate
-    real(r8), parameter :: theta_ip = 0.95_r8  ! empirical curvature parameter for ap photosynthesis co-limitation
-    real(r8), parameter :: rsmax0  = 2.e4_r8 ! maximum stomatal resistance [s/m]
+    real(r8) :: fnps           ! fraction of light absorbed by non-photosynthetic pigments
+    real(r8) :: theta_psii     ! empirical curvature parameter for electron transport rate
+
+    real(r8) :: theta_ip          ! empirical curvature parameter for ap photosynthesis co-limitation
 
     ! Other
     integer  :: f,p,c,t,iv        ! indices
     real(r8) :: cf                ! s m**2/umol -> s/m
+    real(r8) :: rsmax0            ! maximum stomatal resistance [s/m]
     real(r8) :: gb                ! leaf boundary layer conductance (m/s)
     real(r8) :: cs                ! CO2 partial pressure at leaf surface (Pa)
     real(r8) :: gs                ! leaf stomatal conductance (m/s)
@@ -340,9 +326,9 @@ contains
 
     real(r8) :: ai                ! intermediate co-limited photosynthesis (umol CO2/m**2/s)
 
-    real(r8) :: psn_wc_z(1:fn,nlevcan) ! Rubisco-limited contribution to psn_z (umol CO2/m**2/s)
-    real(r8) :: psn_wj_z(1:fn,nlevcan) ! RuBP-limited contribution to psn_z (umol CO2/m**2/s)
-    real(r8) :: psn_wp_z(1:fn,nlevcan) ! product-limited contribution to psn_z (umol CO2/m**2/s)
+    real(r8) :: psn_wc_z(bounds%begp:bounds%endp,nlevcan) ! Rubisco-limited contribution to psn_z (umol CO2/m**2/s)
+    real(r8) :: psn_wj_z(bounds%begp:bounds%endp,nlevcan) ! RuBP-limited contribution to psn_z (umol CO2/m**2/s)
+    real(r8) :: psn_wp_z(bounds%begp:bounds%endp,nlevcan) ! product-limited contribution to psn_z (umol CO2/m**2/s)
 
     real(r8) :: psncan            ! canopy sum of psn_z
     real(r8) :: psncan_wc         ! canopy sum of psn_wc_z
@@ -353,119 +339,188 @@ contains
     real(r8) :: laican            ! canopy sum of lai_z
     real(r8) :: rh_can
 
-
-    real(r8) :: lpc   ! leaf P concentration (gP leaf/m^2)
+    real(r8) , pointer :: lai_z       (:,:)
+    real(r8) , pointer :: par_z       (:,:)
+    real(r8) , pointer :: vcmaxcint   (:)
+    real(r8) , pointer :: alphapsn    (:)
+    real(r8) , pointer :: psn         (:)
+    real(r8) , pointer :: psn_wc      (:)
+    real(r8) , pointer :: psn_wj      (:)
+    real(r8) , pointer :: psn_wp      (:)
+    real(r8) , pointer :: psn_z       (:,:)
+    real(r8) , pointer :: lmr         (:)
+    real(r8) , pointer :: lmr_z       (:,:)
+    real(r8) , pointer :: rs          (:)
+    real(r8) , pointer :: rs_z        (:,:)
+    real(r8) , pointer :: ci_z        (:,:)
+    real(r8) , pointer :: alphapsnsun (:)
+    real(r8) , pointer :: alphapsnsha (:)
+
+    real(r8) :: lpc(bounds%begp:bounds%endp)   ! leaf P concentration (gP leaf/m^2)
     real(r8) :: sum_nscaler
     real(r8) :: total_lai
-    integer  :: rad_layers_patch,i_type
-    real :: startt, stopt
+    integer  :: rad_layers_patch
     !------------------------------------------------------------------------------
     ! Temperature and soil water response functions
-    !------------------------------------------------------------------------------
-    associate(                                                  &
-         c3psn         => veg_vp%c3psn     , & ! Input:  [real(r8) (:)   ]  photosynthetic pathway: 0. = c4, 1. = c3
-         leafcn        => veg_vp%leafcn    , & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
-         flnr          => veg_vp%flnr      , & ! Input:  [real(r8) (:)   ]  fraction of leaf N in the Rubisco enzyme (gN Rubisco / gN leaf)
-         fnitr         => veg_vp%fnitr     , & ! Input:  [real(r8) (:)   ]  foliage nitrogen limitation factor (-)
-         slatop        => veg_vp%slatop    , & ! Input:  [real(r8) (:)   ]  specific leaf area at top of canopy, projected area basis [m^2/gC]
 
-         forc_pbot     => top_as%pbot      , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)
+    associate(                                                       &
+         c3psn         => veg_vp%c3psn                         , & ! Input:  [real(r8) (:)   ]  photosynthetic pathway: 0. = c4, 1. = c3
+         leafcn        => veg_vp%leafcn                        , & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
+         flnr          => veg_vp%flnr                          , & ! Input:  [real(r8) (:)   ]  fraction of leaf N in the Rubisco enzyme (gN Rubisco / gN leaf)
+         fnitr         => veg_vp%fnitr                         , & ! Input:  [real(r8) (:)   ]  foliage nitrogen limitation factor (-)
+         slatop        => veg_vp%slatop                        , & ! Input:  [real(r8) (:)   ]  specific leaf area at top of canopy, projected area basis [m^2/gC]
+
+         forc_pbot     => top_as%pbot                              , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)
 
          t_veg         => veg_es%t_veg             , & ! Input:  [real(r8) (:)   ]  vegetation temperature (Kelvin)
          t10           => veg_es%t_a10             , & ! Input:  [real(r8) (:)   ]  10-day running mean of the 2 m temperature (K)
          tgcm          => veg_es%thm               , & ! Input:  [real(r8) (:)   ]  air temperature at agcm reference height (kelvin)
 
-         nrad          => surfalb_vars%nrad_patch   , & ! Input:  [integer  (:)   ]  pft number of canopy layers, above snow for radiative transfer
-         tlai_z        => surfalb_vars%tlai_z_patch , & ! Input:  [real(r8) (:,:) ]  pft total leaf area index for canopy layer
-
-         c3flag        => photosyns_vars%c3flag_patch    , & ! Output: [logical  (:)   ]  true if C3 and false if C4
-         ac            => photosyns_vars%ac_patch        , & ! Output: [real(r8) (:,:) ]  Rubisco-limited gross photosynthesis (umol CO2/m**2/s)
-         aj            => photosyns_vars%aj_patch        , & ! Output: [real(r8) (:,:) ]  RuBP-limited gross photosynthesis (umol CO2/m**2/s)
-         ap            => photosyns_vars%ap_patch        , & ! Output: [real(r8) (:,:) ]  product-limited (C3) or CO2-limited (C4) gross photosynthesis (umol CO2/m**2/s)
-         ag            => photosyns_vars%ag_patch        , & ! Output: [real(r8) (:,:) ]  co-limited gross leaf photosynthesis (umol CO2/m**2/s)
-         an            => photosyns_vars%an_patch        , & ! Output: [real(r8) (:,:) ]  net leaf photosynthesis (umol CO2/m**2/s)
-         gb_mol        => photosyns_vars%gb_mol_patch    , & ! Output: [real(r8) (:)   ]  leaf boundary layer conductance (umol H2O/m**2/s)
-         gs_mol        => photosyns_vars%gs_mol_patch    , & ! Output: [real(r8) (:,:) ]  leaf stomatal conductance (umol H2O/m**2/s)
-         vcmax_z       => photosyns_vars%vcmax_z_patch   , & ! Output: [real(r8) (:,:) ]  maximum rate of carboxylation (umol co2/m**2/s)
-         cp            => photosyns_vars%cp_patch        , & ! Output: [real(r8) (:)   ]  CO2 compensation point (Pa)
-         kc            => photosyns_vars%kc_patch        , & ! Output: [real(r8) (:)   ]  Michaelis-Menten constant for CO2 (Pa)
-         ko            => photosyns_vars%ko_patch        , & ! Output: [real(r8) (:)   ]  Michaelis-Menten constant for O2 (Pa)
-         qe            => photosyns_vars%qe_patch        , & ! Output: [real(r8) (:)   ]  quantum efficiency, used only for C4 (mol CO2 / mol photons)
-         tpu_z         => photosyns_vars%tpu_z_patch     , & ! Output: [real(r8) (:,:) ]  triose phosphate utilization rate (umol CO2/m**2/s)
-         kp_z          => photosyns_vars%kp_z_patch      , & ! Output: [real(r8) (:,:) ]  initial slope of CO2 response curve (C4 plants)
-         theta_cj      => photosyns_vars%theta_cj_patch  , & ! Output: [real(r8) (:)   ]  empirical curvature parameter for ac, aj photosynthesis co-limitation
-         bbb           => photosyns_vars%bbb_patch       , & ! Output: [real(r8) (:)   ]  Ball-Berry minimum leaf conductance (umol H2O/m**2/s)
-         mbb           => photosyns_vars%mbb_patch       , & ! Output: [real(r8) (:)   ]  Ball-Berry slope of conductance-photosynthesis relationship
-         rh_leaf       => photosyns_vars%rh_leaf_patch   , & ! Output: [real(r8) (:)   ]  fractional humidity at leaf surface (dimensionless)
+         nrad          => surfalb_vars%nrad_patch                  , & ! Input:  [integer  (:)   ]  pft number of canopy layers, above snow for radiative transfer
+         tlai_z        => surfalb_vars%tlai_z_patch                , & ! Input:  [real(r8) (:,:) ]  pft total leaf area index for canopy layer
+
+         c3flag        => photosyns_vars%c3flag_patch              , & ! Output: [logical  (:)   ]  true if C3 and false if C4
+         ac            => photosyns_vars%ac_patch                  , & ! Output: [real(r8) (:,:) ]  Rubisco-limited gross photosynthesis (umol CO2/m**2/s)
+         aj            => photosyns_vars%aj_patch                  , & ! Output: [real(r8) (:,:) ]  RuBP-limited gross photosynthesis (umol CO2/m**2/s)
+         ap            => photosyns_vars%ap_patch                  , & ! Output: [real(r8) (:,:) ]  product-limited (C3) or CO2-limited (C4) gross photosynthesis (umol CO2/m**2/s)
+         ag            => photosyns_vars%ag_patch                  , & ! Output: [real(r8) (:,:) ]  co-limited gross leaf photosynthesis (umol CO2/m**2/s)
+         an            => photosyns_vars%an_patch                  , & ! Output: [real(r8) (:,:) ]  net leaf photosynthesis (umol CO2/m**2/s)
+         gb_mol        => photosyns_vars%gb_mol_patch              , & ! Output: [real(r8) (:)   ]  leaf boundary layer conductance (umol H2O/m**2/s)
+         gs_mol        => photosyns_vars%gs_mol_patch              , & ! Output: [real(r8) (:,:) ]  leaf stomatal conductance (umol H2O/m**2/s)
+         vcmax_z       => photosyns_vars%vcmax_z_patch             , & ! Output: [real(r8) (:,:) ]  maximum rate of carboxylation (umol co2/m**2/s)
+         cp            => photosyns_vars%cp_patch                  , & ! Output: [real(r8) (:)   ]  CO2 compensation point (Pa)
+         kc            => photosyns_vars%kc_patch                  , & ! Output: [real(r8) (:)   ]  Michaelis-Menten constant for CO2 (Pa)
+         ko            => photosyns_vars%ko_patch                  , & ! Output: [real(r8) (:)   ]  Michaelis-Menten constant for O2 (Pa)
+         qe            => photosyns_vars%qe_patch                  , & ! Output: [real(r8) (:)   ]  quantum efficiency, used only for C4 (mol CO2 / mol photons)
+         tpu_z         => photosyns_vars%tpu_z_patch               , & ! Output: [real(r8) (:,:) ]  triose phosphate utilization rate (umol CO2/m**2/s)
+         kp_z          => photosyns_vars%kp_z_patch                , & ! Output: [real(r8) (:,:) ]  initial slope of CO2 response curve (C4 plants)
+         theta_cj      => photosyns_vars%theta_cj_patch            , & ! Output: [real(r8) (:)   ]  empirical curvature parameter for ac, aj photosynthesis co-limitation
+         bbb           => photosyns_vars%bbb_patch                 , & ! Output: [real(r8) (:)   ]  Ball-Berry minimum leaf conductance (umol H2O/m**2/s)
+         mbb           => photosyns_vars%mbb_patch                 , & ! Output: [real(r8) (:)   ]  Ball-Berry slope of conductance-photosynthesis relationship
+         rh_leaf       => photosyns_vars%rh_leaf_patch             , & ! Output: [real(r8) (:)   ]  fractional humidity at leaf surface (dimensionless)
 
          leafn         => veg_ns%leafn           , &
          leafn_storage => veg_ns%leafn_storage   , &
          leafn_xfer    => veg_ns%leafn_xfer      , &
-         leafp         => veg_ps%leafp           , &
-         leafp_storage => veg_ps%leafp_storage   , &
-         leafp_xfer    => veg_ps%leafp_xfer      , &
-         i_vcmax       => veg_vp%i_vc            , &
-         s_vcmax       => veg_vp%s_vc              &
+         leafp         => veg_ps%leafp         , &
+         leafp_storage => veg_ps%leafp_storage , &
+         leafp_xfer    => veg_ps%leafp_xfer    , &
+         i_vcmax       => veg_vp%i_vc                          , &
+         s_vcmax       => veg_vp%s_vc                            &
          )
 
+      if (phase == 'sun') then !sun
+         par_z     =>    solarabs_vars%parsun_z_patch        ! Input:  [real(r8) (:,:) ]  par absorbed per unit lai for canopy layer (w/m**2)
+         lai_z     =>    canopystate_vars%laisun_z_patch     ! Input:  [real(r8) (:,:) ]  leaf area index for canopy layer, sunlit or shaded
+         vcmaxcint =>    surfalb_vars%vcmaxcintsun_patch     ! Input:  [real(r8) (:)   ]  leaf to canopy scaling coefficient
+         alphapsn  =>    photosyns_vars%alphapsnsun_patch    ! Input:  [real(r8) (:)   ]  13C fractionation factor for PSN ()
+         ci_z      =>    photosyns_vars%cisun_z_patch        ! Output: [real(r8) (:,:) ]  intracellular leaf CO2 (Pa)
+         rs        =>    photosyns_vars%rssun_patch          ! Output: [real(r8) (:)   ]  leaf stomatal resistance (s/m)
+         rs_z      =>    photosyns_vars%rssun_z_patch        ! Output: [real(r8) (:,:) ]  canopy layer: leaf stomatal resistance (s/m)
+         lmr       =>    photosyns_vars%lmrsun_patch         ! Output: [real(r8) (:)   ]  leaf maintenance respiration rate (umol CO2/m**2/s)
+         lmr_z     =>    photosyns_vars%lmrsun_z_patch       ! Output: [real(r8) (:,:) ]  canopy layer: leaf maintenance respiration rate (umol CO2/m**2/s)
+         psn       =>    photosyns_vars%psnsun_patch         ! Output: [real(r8) (:)   ]  foliage photosynthesis (umol co2 /m**2/ s) [always +]
+         psn_z     =>    photosyns_vars%psnsun_z_patch       ! Output: [real(r8) (:,:) ]  canopy layer: foliage photosynthesis (umol co2 /m**2/ s) [always +]
+         psn_wc    =>    photosyns_vars%psnsun_wc_patch      ! Output: [real(r8) (:)   ]  Rubisco-limited foliage photosynthesis (umol co2 /m**2/ s) [always +]
+         psn_wj    =>    photosyns_vars%psnsun_wj_patch      ! Output: [real(r8) (:)   ]  RuBP-limited foliage photosynthesis (umol co2 /m**2/ s) [always +]
+         psn_wp    =>    photosyns_vars%psnsun_wp_patch      ! Output: [real(r8) (:)   ]  product-limited foliage photosynthesis (umol co2 /m**2/ s) [always +]
+      else if (phase == 'sha') then !shade
+         par_z     =>    solarabs_vars%parsha_z_patch        ! Input:  [real(r8) (:,:) ]  par absorbed per unit lai for canopy layer (w/m**2)
+         lai_z     =>    canopystate_vars%laisha_z_patch     ! Input:  [real(r8) (:,:) ]  leaf area index for canopy layer, sunlit or shaded
+         vcmaxcint =>    surfalb_vars%vcmaxcintsha_patch     ! Input:  [real(r8) (:)   ]  leaf to canopy scaling coefficient
+         alphapsn  =>    photosyns_vars%alphapsnsha_patch    ! Input:  [real(r8) (:)   ]  13C fractionation factor for PSN ()
+         ci_z      =>    photosyns_vars%cisha_z_patch        ! Output: [real(r8) (:,:) ]  intracellular leaf CO2 (Pa)
+         rs        =>    photosyns_vars%rssha_patch          ! Output: [real(r8) (:)   ]  leaf stomatal resistance (s/m)
+         rs_z      =>    photosyns_vars%rssha_z_patch        ! Output: [real(r8) (:,:) ]  canopy layer: leaf stomatal resistance (s/m)
+         lmr       =>    photosyns_vars%lmrsha_patch         ! Output: [real(r8) (:)   ]  leaf maintenance respiration rate (umol CO2/m**2/s)
+         lmr_z     =>    photosyns_vars%lmrsha_z_patch       ! Output: [real(r8) (:,:) ]  canopy layer: leaf maintenance respiration rate (umol CO2/m**2/s)
+         psn       =>    photosyns_vars%psnsha_patch         ! Output: [real(r8) (:)   ]  foliage photosynthesis (umol co2 /m**2/ s) [always +]
+         psn_z     =>    photosyns_vars%psnsha_z_patch       ! Output: [real(r8) (:,:) ]  canopy layer: foliage photosynthesis (umol co2 /m**2/ s) [always +]
+         psn_wc    =>    photosyns_vars%psnsha_wc_patch      ! Output: [real(r8) (:)   ]  Rubisco-limited foliage photosynthesis (umol co2 /m**2/ s) [always +]
+         psn_wj    =>    photosyns_vars%psnsha_wj_patch      ! Output: [real(r8) (:)   ]  RuBP-limited foliage photosynthesis (umol co2 /m**2/ s) [always +]
+         psn_wp    =>    photosyns_vars%psnsha_wp_patch      ! Output: [real(r8) (:)   ]  product-limited foliage photosynthesis (umol co2 /m**2/ s) [always +]
+      end if
+
+
+
+      ! Enforce expected array sizes
+
       !==============================================================================!
       ! Photosynthesis and stomatal conductance parameters, from:
       ! Bonan et al (2011) JGR, 116, doi:10.1029/2010JG001593
       !==============================================================================!
 
-      !$acc enter data create(fnr,act25,vcmaxha,jmaxha,tpuha,lmrha,vcmaxhd,jmaxhd,tpuhd,lmrhd,lmrse,lmrc) 
       ! Miscellaneous parameters, from Bonan et al (2011) JGR, 116, doi:10.1029/2010JG001593
-      ! vcmax25 parameters, from CN
-      !$acc serial default(present)  
-      p = filterp(1)
-      i_type = veg_pp%itype(p)
-      fnr   = veg_vp%fnr(i_type)   !7.16_r8
-      act25 = veg_vp%act25(i_type) !3.6_r8   !umol/mgRubisco/min
-      
-      ! Convert rubisco activity units from umol/mgRubisco/min ->
-      ! umol/gRubisco/s
-      act25 = act25 * 1000.0_r8 / 60.0_r8
-      
-      ! Activation energy, from:
-      ! Bernacchi et al (2001) Plant, Cell and Environment 24:253-259
-      ! Bernacchi et al (2003) Plant, Cell and Environment 26:1419-1430
-      ! except TPU from: Harley et al (1992) Plant, Cell and Environment
-      ! 15:271-282
-      vcmaxha = veg_vp%vcmaxha(i_type) !72000._r8
-      jmaxha  = veg_vp%jmaxha(i_type) !50000._r8
-      tpuha   = veg_vp%tpuha(i_type)  !72000._r8
-      lmrha   = veg_vp%lmrha(i_type)  !46390._r8
-      
-      ! High temperature deactivation, from:
-      ! Leuning (2002) Plant, Cell and Environment 25:1205-1210
-      ! The factor "c" scales the deactivation to a value of 1.0 at 25C
-      vcmaxhd = veg_vp%vcmaxhd(i_type) !200000._r8
-      jmaxhd  = veg_vp%jmaxhd(i_type)  !200000._r8
-      tpuhd   = veg_vp%tpuhd(i_type)   !200000._r8
-      lmrhd   = veg_vp%lmrhd(i_type)   !150650._r8
-      lmrse   = veg_vp%lmrse(i_type)   !490._r8
-      lmrc    = fth25 (lmrhd, lmrse)
-      !$acc end serial 
-      !$acc enter data create(jmax_z(:,:), lnc(:),kn(:),psn_wc_z(:,:),psn_wj_z(:,:), psn_wp_z(:,:) )
-
-      !$acc parallel loop independent gang vector default(present) private(p,c,t,i_type,kc25,ko25,sco,cp25)
+
+      fnps = 0.15_r8
+      theta_psii = 0.7_r8
+      theta_ip = 0.95_r8
+
       do f = 1, fn
-         if(converged(f)) cycle
          p = filterp(f)
          c = veg_pp%column(p)
          t = veg_pp%topounit(p)
-         i_type = veg_pp%itype(p)
+
+         ! vcmax25 parameters, from CN
+
+         fnr   = veg_vp%fnr(veg_pp%itype(p))   !7.16_r8
+         act25 = veg_vp%act25(veg_pp%itype(p)) !3.6_r8   !umol/mgRubisco/min
+         ! Convert rubisco activity units from umol/mgRubisco/min ->
+         ! umol/gRubisco/s
+         act25 = act25 * 1000.0_r8 / 60.0_r8
+
+         ! Activation energy, from:
+         ! Bernacchi et al (2001) Plant, Cell and Environment 24:253-259
+         ! Bernacchi et al (2003) Plant, Cell and Environment 26:1419-1430
+         ! except TPU from: Harley et al (1992) Plant, Cell and Environment
+         ! 15:271-282
+
+         kcha    = veg_vp%kcha(veg_pp%itype(p)) !79430._r8
+         koha    = veg_vp%koha(veg_pp%itype(p)) !36380._r8
+         cpha    = veg_vp%cpha(veg_pp%itype(p)) !37830._r8
+         vcmaxha = veg_vp%vcmaxha(veg_pp%itype(p)) !72000._r8
+         jmaxha  = veg_vp%jmaxha(veg_pp%itype(p)) !50000._r8
+         tpuha   = veg_vp%tpuha(veg_pp%itype(p))  !72000._r8
+         lmrha   = veg_vp%lmrha(veg_pp%itype(p))  !46390._r8
+
+         ! High temperature deactivation, from:
+         ! Leuning (2002) Plant, Cell and Environment 25:1205-1210
+         ! The factor "c" scales the deactivation to a value of 1.0 at 25C
+
+         vcmaxhd = veg_vp%vcmaxhd(veg_pp%itype(p)) !200000._r8
+         jmaxhd  = veg_vp%jmaxhd(veg_pp%itype(p))  !200000._r8
+         tpuhd   = veg_vp%tpuhd(veg_pp%itype(p))   !200000._r8
+         lmrhd   = veg_vp%lmrhd(veg_pp%itype(p))   !150650._r8
+         lmrse   = veg_vp%lmrse(veg_pp%itype(p))   !490._r8
+         lmrc    = fth25 (lmrhd, lmrse)
+
          ! C3 or C4 photosynthesis logical variable
-         if (nint(c3psn(i_type)) == 1) then
+
+         if (nint(c3psn(veg_pp%itype(p))) == 1) then
             c3flag(p) = .true.
-         else if (nint(c3psn(i_type)) == 0) then
+         else if (nint(c3psn(veg_pp%itype(p))) == 0) then
             c3flag(p) = .false.
          end if
+
+         ! C3 and C4 dependent parameters
+
+         if (c3flag(p)) then
+            qe(p)       = veg_vp%qe(veg_pp%itype(p))       !0._r8
+            theta_cj(p) = veg_vp%theta_cj(veg_pp%itype(p)) !0.98_r8
+            bbbopt(p)   = veg_vp%bbbopt(veg_pp%itype(p))   !10000._r8
+            mbbopt(p)   = veg_vp%mbbopt(veg_pp%itype(p))   !9._r8
+         else
+            qe(p)       = veg_vp%qe(veg_pp%itype(p))       !0.05_r8
+            theta_cj(p) = veg_vp%theta_cj(veg_pp%itype(p)) !0.80_r8
+            bbbopt(p)   = veg_vp%bbbopt(veg_pp%itype(p))   !40000._r8
+            mbbopt(p)   = veg_vp%mbbopt(veg_pp%itype(p))   !4._r8
+         end if
+
          ! Soil water stress applied to Ball-Berry parameters
-         theta_cj(p) = veg_vp%theta_cj(i_type) !0.98_r8
-         qe(p)  = veg_vp%qe(i_type)
-         bbb(p) = max (veg_vp%bbbopt(i_type) * btran(p), 1._r8)
-         mbb(p) = veg_vp%mbbopt(i_type)
+
+         bbb(p) = max (bbbopt(p)*btran(p), 1._r8)
+         mbb(p) = mbbopt(p)
+
          ! kc, ko, cp, from: Bernacchi et al (2001) Plant, Cell and Environment 24:253-259
          !
          !       kc25 = 404.9 umol/mol
@@ -475,50 +530,49 @@ contains
          ! Derive sco from cp and O2 using present-day O2 (0.209 mol/mol) and re-calculate
          ! cp to account for variation in O2 using cp = 0.5 O2 / sco
          !
+
          kc25 = (404.9_r8 / 1.e06_r8) * forc_pbot(t)
          ko25 = (278.4_r8 / 1.e03_r8) * forc_pbot(t)
          sco  = 0.5_r8 * 0.209_r8 / (42.75_r8 / 1.e06_r8)
-         cp25 = 0.5_r8 * oair(f) / sco
+         cp25 = 0.5_r8 * oair(p) / sco
 
-         kc(p) = kc25 * ft(t_veg(p), veg_vp%kcha(i_type) )!79430._r8
-         ko(p) = ko25 * ft(t_veg(p), veg_vp%koha(i_type) )!36380._r8
-         cp(p) = cp25 * ft(t_veg(p), veg_vp%cpha(i_type) )!37830._r8
+         kc(p) = kc25 * ft(t_veg(p), kcha)
+         ko(p) = ko25 * ft(t_veg(p), koha)
+         cp(p) = cp25 * ft(t_veg(p), cpha)
 
       end do
-      
+
       ! Multi-layer parameters scaled by leaf nitrogen profile.
       ! Loop through each canopy layer to calculate nitrogen profile using
       ! cumulative lai at the midpoint of the layer
-      
-      !$acc parallel loop independent gang vector default(present) present(&
-      !$acc btran(:),leafn(:),kp_z(:,:),lmr_z(:,:), par_z(:,:),nrad(:),vcmaxcint(:),&
-      !$acc vcmax_z(:,:),t10(:),leafp(:),tpu_z(:,:),tlai_z(:,:),alphapsn(:),c3flag(:))
+
       do f = 1, fn
-         if(converged(f)) cycle
          p = filterp(f)
-         i_type = veg_pp%itype(p)
          if ( .not. nu_com_leaf_physiology) then
             ! Leaf nitrogen concentration at the top of the canopy (g N leaf / m**2 leaf)
-            lnc(f) = 1._r8 / (slatop(i_type) * leafcn(i_type))
+            lnc(p) = 1._r8 / (slatop(veg_pp%itype(p)) * leafcn(veg_pp%itype(p)))
 
             ! vcmax25 at canopy top, as in CN but using lnc at top of the canopy
-            vcmax25top = lnc(f) * flnr(i_type) * fnr * act25 * dayl_factor(f)
+            vcmax25top = lnc(p) * flnr(veg_pp%itype(p)) * fnr * act25 * dayl_factor(p)
             if (.not. use_cn) then
-               vcmax25top = vcmax25top * fnitr(i_type)
-            else if ( Carbon_only ) then
-               vcmax25top = vcmax25top * fnitr(i_type)
+               vcmax25top = vcmax25top * fnitr(veg_pp%itype(p))
+            else
+               if ( Carbon_only ) vcmax25top = vcmax25top * fnitr(veg_pp%itype(p))
             end if
+
             ! Parameters derived from vcmax25top. Bonan et al (2011) JGR, 116, doi:10.1029/2010JG001593
             ! used jmax25 = 1.97 vcmax25, from Wullschleger (1993) Journal of Experimental Botany 44:907-920.
             jmax25top = (2.59_r8 - 0.035_r8*min(max((t10(p)-tfrz),11._r8),35._r8)) * vcmax25top
 
          else
+
             ! leaf level nutrient control on photosynthesis rate added by Q. Zhu Aug 2015
+
             if ( Carbon_only  .or.  carbonphosphorus_only ) then
 
-               lnc(f) = 1._r8 / (slatop(i_type) * leafcn(i_type))
-               vcmax25top = lnc(f) * flnr(i_type) * fnr * act25 * dayl_factor(f)
-               vcmax25top = vcmax25top * fnitr(i_type)
+               lnc(p) = 1._r8 / (slatop(veg_pp%itype(p)) * leafcn(veg_pp%itype(p)))
+               vcmax25top = lnc(p) * flnr(veg_pp%itype(p)) * fnr * act25 * dayl_factor(p)
+               vcmax25top = vcmax25top * fnitr(veg_pp%itype(p))
                jmax25top = (2.59_r8 - 0.035_r8*min(max((t10(p)-tfrz),11._r8),35._r8)) * vcmax25top
 
             else if (  carbonnitrogen_only  ) then ! only N control, from Kattge 2009 Global Change Biology 15 (4), 976-991
@@ -527,7 +581,6 @@ contains
                sum_nscaler = 0.0_r8
                laican      = 0.0_r8
                total_lai   = 0.0_r8
-              !$acc loop seq 
                do iv = 1, nrad(p)
                   if (iv == 1) then
                      laican = 0.5_r8 * tlai_z(p,iv)
@@ -540,7 +593,7 @@ contains
                   if (nlevcan == 1) then
                      nscaler = 1.0_r8
                   else if (nlevcan > 1) then
-                     nscaler = exp(-kn(f) * laican)
+                     nscaler = exp(-kn(p) * laican)
                   end if
                   sum_nscaler = sum_nscaler + nscaler
                end do
@@ -549,13 +602,13 @@ contains
                   ! dividing by LAI to convert total leaf nitrogen
                   ! from m2 ground to m2 leaf; dividing by sum_nscaler to
                   ! convert total leaf N to leaf N at canopy top
-                  lnc(f) = leafn(p) / (total_lai * sum_nscaler)
-                  lnc(f) = min(max(lnc(f),0.25_r8),3.0_r8) ! based on doi: 10.1002/ece3.1173
+                  lnc(p) = leafn(p) / (total_lai * sum_nscaler)
+                  lnc(p) = min(max(lnc(p),0.25_r8),3.0_r8) ! based on doi: 10.1002/ece3.1173
                else
-                  lnc(f) = 0.0_r8
+                  lnc(p) = 0.0_r8
                end if
 
-               vcmax25top = (i_vcmax(i_type) + s_vcmax(i_type) * lnc(f)) * dayl_factor(f)
+               vcmax25top = (i_vcmax(veg_pp%itype(p)) + s_vcmax(veg_pp%itype(p)) * lnc(p)) * dayl_factor(p)
                jmax25top = (2.59_r8 - 0.035_r8*min(max((t10(p)-tfrz),11._r8),35._r8)) * vcmax25top
                vcmax25top = min(max(vcmax25top, 10.0_r8), 150.0_r8)
                jmax25top = min(max(jmax25top, 10.0_r8), 250.0_r8)
@@ -564,12 +617,13 @@ contains
 
                ! nu_com_leaf_physiology is true, vcmax25, jmax25 is derived from leafn, leafp concentration
                ! Anthony Walker 2014 DOI: 10.1002/ece3.1173
-               if (veg_pp%active(p) .and. (i_type .ne. noveg)) then
+
+               if (veg_pp%active(p) .and. (veg_pp%itype(p) .ne. noveg)) then
                   ! Leaf nitrogen concentration at the top of the canopy (g N leaf / m**2 leaf)
                   sum_nscaler = 0.0_r8
                   laican      = 0.0_r8
                   total_lai   = 0.0_r8
-                  !$acc loop seq
+
                   do iv = 1, nrad(p)
                      if (iv == 1) then
                         laican = 0.5_r8 * tlai_z(p,iv)
@@ -582,7 +636,7 @@ contains
                      if (nlevcan == 1) then
                         nscaler = 1.0_r8
                      else if (nlevcan > 1) then
-                        nscaler = exp(-kn(f) * laican)
+                        nscaler = exp(-kn(p) * laican)
                      end if
                      sum_nscaler = sum_nscaler + nscaler
                   end do
@@ -591,23 +645,24 @@ contains
                      ! dividing by LAI to convert total leaf nitrogen
                      ! from m2 ground to m2 leaf; dividing by sum_nscaler to
                      ! convert total leaf N to leaf N at canopy top
-                     lnc(f) = leafn(p) / (total_lai * sum_nscaler)
-                     lpc   = leafp(p) / (total_lai * sum_nscaler)
-                     lnc(f) = min(max(lnc(f),0.25_r8),3.0_r8) ! based on doi: 10.1002/ece3.1173
-                     lpc = min(max(lpc,0.014_r8),0.85_r8) ! based on doi: 10.1002/ece3.1173
-                     vcmax25top = exp(vcmax_np1(i_type) + vcmax_np2(i_type)*log(lnc(f)) + &
-                          vcmax_np3(i_type)*log(lpc) + vcmax_np4(i_type)*log(lnc(f))*log(lpc ))&
-                          * dayl_factor(f)
-                     jmax25top = exp(jmax_np1 + jmax_np2*log(vcmax25top) + jmax_np3*log(lpc )) * dayl_factor(f)
+                     lnc(p) = leafn(p) / (total_lai * sum_nscaler)
+                     lpc(p) = leafp(p) / (total_lai * sum_nscaler)
+                     lnc(p) = min(max(lnc(p),0.25_r8),3.0_r8) ! based on doi: 10.1002/ece3.1173
+                     lpc(p) = min(max(lpc(p),0.014_r8),0.85_r8) ! based on doi: 10.1002/ece3.1173
+                     vcmax25top = exp(vcmax_np1(veg_pp%itype(p)) + vcmax_np2(veg_pp%itype(p))*log(lnc(p)) + &
+                          vcmax_np3(veg_pp%itype(p))*log(lpc(p)) + vcmax_np4(veg_pp%itype(p))*log(lnc(p))*log(lpc(p)))&
+                          * dayl_factor(p)
+                     jmax25top = exp(jmax_np1 + jmax_np2*log(vcmax25top) + jmax_np3*log(lpc(p))) * dayl_factor(p)
                      vcmax25top = min(max(vcmax25top, 10.0_r8), 150.0_r8)
                      jmax25top = min(max(jmax25top, 10.0_r8), 250.0_r8)
                   else
-                     lnc(f) = 0.0_r8
+                     lnc(p) = 0.0_r8
+                     lpc(p) = 0.0_r8
                      vcmax25top = 0.0_r8
                      jmax25top = 0.0_r8
                   end if
                else
-                  lnc(f)     = 0.0_r8
+                  lnc(p)     = 0.0_r8
                   vcmax25top = 0.0_r8
                   jmax25top  = 0.0_r8
                end if
@@ -623,10 +678,10 @@ contains
          ! But not used as defined here if using sun/shade big leaf code. Instead,
          ! will use canopy integrated scaling factors from SurfaceAlbedo.
 
-         if (dayl_factor(f) .eq. 0._r8) then
-            kn(f) =  0._r8
+         if (dayl_factor(p) .eq. 0._r8) then
+            kn(p) =  0._r8
          else
-            kn(f) = exp(0.00963_r8 * vcmax25top/dayl_factor(f) - 2.43_r8)
+            kn(p) = exp(0.00963_r8 * vcmax25top/dayl_factor(p) - 2.43_r8)
          end if
 
          if (use_cn) then
@@ -646,9 +701,8 @@ contains
             !
             ! Then scale this value at the top of the canopy for canopy depth
 
-            !NOTE:   This seems like a strange way to calc sqrt of Q10_mr??
             lmr25top = 2.525e-6_r8 * (ParamsShareInst%Q10_mr ** ((25._r8 - 20._r8)/10._r8))
-            lmr25top = lmr25top * lnc(f) / 12.e-06_r8
+            lmr25top = lmr25top * lnc(p) / 12.e-06_r8
          else
             ! Leaf maintenance respiration in proportion to vcmax25top
 
@@ -663,7 +717,6 @@ contains
          ! calculated every timestep. Others are calculated only if daytime
          laican = 0._r8
          rad_layers_patch = nrad(p)
-         !$acc loop seq
          do iv = 1, rad_layers_patch
             ! Cumulative lai at middle of layer
 
@@ -679,10 +732,11 @@ contains
                nscaler = vcmaxcint(p)
                if (nu_com_leaf_physiology) nscaler = 1
             else if (nlevcan > 1) then
-               nscaler = exp(-kn(f) * laican)
+               nscaler = exp(-kn(p) * laican)
             end if
 
             ! Maintenance respiration
+
             lmr25 = lmr25top * nscaler
             if (c3flag(p)) then
                lmr_z(p,iv) = lmr25 * ft(t_veg(p), lmrha) * fth(t_veg(p), lmrhd, lmrse, lmrc)
@@ -691,18 +745,18 @@ contains
                lmr_z(p,iv) = lmr_z(p,iv) / (1._r8 + exp( 1.3_r8*(t_veg(p)-(tfrz+55._r8)) ))
             end if
 
-            if (par_z(p,iv) <= 0._r8) then ! night time
-               !
+            if (par_z(p,iv) <= 0._r8) then           ! night time
+
                vcmax_z(p,iv) = 0._r8
-               jmax_z(f,iv)  = 0._r8
-               tpu_z(p,iv)   = 0._r8
-               kp_z(p,iv)    = 0._r8
-               !
+               jmax_z(p,iv) = 0._r8
+               tpu_z(p,iv) = 0._r8
+               kp_z(p,iv) = 0._r8
+
                if ( use_c13 ) then
                   alphapsn(p) = 1._r8
                end if
-               !
-            else                           ! day time
+
+            else                                     ! day time
 
                vcmax25 = vcmax25top * nscaler
                jmax25 = jmax25top * nscaler
@@ -710,6 +764,7 @@ contains
                kp25 = kp25top * nscaler
 
                ! Adjust for temperature
+
                vcmaxse = 668.39_r8 - 1.07_r8 * min(max((t10(p)-tfrz),11._r8),35._r8)
                jmaxse  = 659.70_r8 - 0.75_r8 * min(max((t10(p)-tfrz),11._r8),35._r8)
                tpuse = vcmaxse
@@ -717,7 +772,7 @@ contains
                jmaxc  = fth25 (jmaxhd, jmaxse)
                tpuc   = fth25 (tpuhd, tpuse)
                vcmax_z(p,iv) = vcmax25 * ft(t_veg(p), vcmaxha) * fth(t_veg(p), vcmaxhd, vcmaxse, vcmaxc)
-               jmax_z(f,iv) = jmax25 * ft(t_veg(p), jmaxha) * fth(t_veg(p), jmaxhd, jmaxse, jmaxc)
+               jmax_z(p,iv) = jmax25 * ft(t_veg(p), jmaxha) * fth(t_veg(p), jmaxhd, jmaxse, jmaxc)
                tpu_z(p,iv) = tpu25 * ft(t_veg(p), tpuha) * fth(t_veg(p), tpuhd, tpuse, tpuc)
 
                if (.not. c3flag(p)) then
@@ -729,34 +784,33 @@ contains
                kp_z(p,iv) = kp25 * 2._r8**((t_veg(p)-(tfrz+25._r8))/10._r8)
 
             end if
+
             ! Adjust for soil water
+
             vcmax_z(p,iv) = vcmax_z(p,iv) * btran(p)
             lmr_z(p,iv) = lmr_z(p,iv) * btran(p)
          end do       ! canopy layer loop
-      end do     ! patch loop
+      end do          ! patch loop
+
       !==============================================================================!
       ! Leaf-level photosynthesis and stomatal conductance
       !==============================================================================!
-      
-      !$acc parallel loop independent gang vector  default(present) present(&
-      !$acc c3flag(:),nrad(:),bbb(:),rh_leaf(:),ap(:,:),ac(:,:),ag(:,:),psn_z(:,:),&
-      !$acc rs_z(:,:),an(:,:),aj(:,:),ci_z(p,:))
+
+      rsmax0 = 2.e4_r8
+
       do f = 1, fn
-         if(converged(f)) cycle
          p = filterp(f)
-         
-         !$acc loop seq 
-         do iv = 1, nrad(p)
-            p = filterp(f)
-            c = veg_pp%column(p)
-            t = veg_pp%topounit(p)
+         c = veg_pp%column(p)
+         t = veg_pp%topounit(p)
+
+         ! Leaf boundary layer conductance, umol/m**2/s
 
-            ! Leaf boundary layer conductance, umol/m**2/s
-            cf = forc_pbot(t)/(rgas*1.e-3_r8*tgcm(p))*1.e06_r8
-            gb = 1._r8/rb(f)
-            gb_mol(p) = gb * cf
+         cf = forc_pbot(t)/(rgas*1.e-3_r8*tgcm(p))*1.e06_r8
+         gb = 1._r8/rb(p)
+         gb_mol(p) = gb * cf
 
-            ! Loop through canopy layers (above snow). Only do calculations if daytime
+         ! Loop through canopy layers (above snow). Only do calculations if daytime
+        do iv = 1, nrad(p)
 
             if (par_z(p,iv) <= 0._r8) then           ! night time
 
@@ -766,9 +820,9 @@ contains
                ag(p,iv) = 0._r8
                an(p,iv) = ag(p,iv) - lmr_z(p,iv)
                psn_z(p,iv) = 0._r8
-               psn_wc_z(f,iv) = 0._r8
-               psn_wj_z(f,iv) = 0._r8
-               psn_wp_z(f,iv) = 0._r8
+               psn_wc_z(p,iv) = 0._r8
+               psn_wj_z(p,iv) = 0._r8
+               psn_wp_z(p,iv) = 0._r8
                rs_z(p,iv) = min(rsmax0, 1._r8/bbb(p) * cf)
                ci_z(p,iv) = 0._r8
                rh_leaf(p) = 0._r8
@@ -776,47 +830,51 @@ contains
             else                                     ! day time
 
                !now the constraint is no longer needed, Jinyun Tang
-               ceair = min( eair(f),  esat_tv(f) )
-               rh_can = ceair / esat_tv(f)
+               ceair = min( eair(p),  esat_tv(p) )
+               rh_can = ceair / esat_tv(p)
 
                ! Electron transport rate for C3 plants. Convert par from W/m2 to
                ! umol photons/m**2/s using the factor 4.6
 
                qabs  = 0.5_r8 * (1._r8 - fnps) * par_z(p,iv) * 4.6_r8
                aquad = theta_psii
-               bquad = -(qabs + jmax_z(f,iv))
-               cquad = qabs * jmax_z(f,iv)
+               bquad = -(qabs + jmax_z(p,iv))
+               cquad = qabs * jmax_z(p,iv)
                call quadratic (aquad, bquad, cquad, r1, r2)
                je = min(r1,r2)
 
                ! Iterative loop for ci beginning with initial guess
+
                if (c3flag(p)) then
-                  ci_z(p,iv) = 0.7_r8 * cair(f)
+                  ci_z(p,iv) = 0.7_r8 * cair(p)
                else
-                  ci_z(p,iv) = 0.4_r8 * cair(f)
+                  ci_z(p,iv) = 0.4_r8 * cair(p)
                end if
 
                niter = 0
 
                ! Increment iteration counter. Stop if too many iterations
+
                niter = niter + 1
 
                ! Save old ci
+
                ciold = ci_z(p,iv)
 
                !find ci and stomatal conductance
-               call hybrid(ciold, p, iv, c, t, gb_mol(p), je, cair(f), oair(f), &
+               call hybrid(ciold, p, iv, c, t, gb_mol(p), je, cair(p), oair(p), &
                     lmr_z(p,iv), par_z(p,iv), rh_can, gs_mol(p,iv), niter, &
-                    photosyns_vars)
+                    atm2lnd_vars, photosyns_vars)
 
                ! End of ci iteration.  Check for an < 0, in which case gs_mol = bbb
+
                if (an(p,iv) < 0._r8) gs_mol(p,iv) = bbb(p)
 
                ! Final estimates for cs and ci (needed for early exit of ci iteration when an < 0)
 
-               cs = cair(f) - 1.4_r8/gb_mol(p) * an(p,iv) * forc_pbot(t)
+               cs = cair(p) - 1.4_r8/gb_mol(p) * an(p,iv) * forc_pbot(t)
                cs = max(cs,1.e-06_r8)
-               ci_z(p,iv) = cair(f) - an(p,iv) * forc_pbot(t) * (1.4_r8*gs_mol(p,iv)+1.6_r8*gb_mol(p)) / (gb_mol(p)*gs_mol(p,iv))
+               ci_z(p,iv) = cair(p) - an(p,iv) * forc_pbot(t) * (1.4_r8*gs_mol(p,iv)+1.6_r8*gb_mol(p)) / (gb_mol(p)*gs_mol(p,iv))
 
                ! Convert gs_mol (umol H2O/m**2/s) to gs (m/s) and then to rs (s/m)
 
@@ -827,40 +885,42 @@ contains
 
                psn_z(p,iv) = ag(p,iv)
 
-               psn_wc_z(f,iv) = 0._r8
-               psn_wj_z(f,iv) = 0._r8
-               psn_wp_z(f,iv) = 0._r8
+               psn_wc_z(p,iv) = 0._r8
+               psn_wj_z(p,iv) = 0._r8
+               psn_wp_z(p,iv) = 0._r8
 
                if (ac(p,iv) <= aj(p,iv) .and. ac(p,iv) <= ap(p,iv)) then
-                  psn_wc_z(f,iv) =  psn_z(p,iv)
+                  psn_wc_z(p,iv) =  psn_z(p,iv)
                else if (aj(p,iv) < ac(p,iv) .and. aj(p,iv) <= ap(p,iv)) then
-                  psn_wj_z(f,iv) =  psn_z(p,iv)
+                  psn_wj_z(p,iv) =  psn_z(p,iv)
                else if (ap(p,iv) < ac(p,iv) .and. ap(p,iv) < aj(p,iv)) then
-                  psn_wp_z(f,iv) =  psn_z(p,iv)
+                  psn_wp_z(p,iv) =  psn_z(p,iv)
                end if
 
                ! Make sure iterative solution is correct
-#ifndef _OPENACC
+
                if (gs_mol(p,iv) < 0._r8) then
-                  print *, 'Negative stomatal conductance:'
+                  write(iulog,*) 'Negative stomatal conductance:'
                   write (iulog,*)'p,iv,gs_mol= ',p,iv,gs_mol(p,iv)
                   call endrun(decomp_index=p, elmlevel=namep, msg=errmsg(__FILE__, __LINE__))
+                  stop
                end if
-#endif
+
                ! Compare with Ball-Berry model: gs_mol = m * an * hs/cs p + b
 
-               hs = (gb_mol(p)*ceair + gs_mol(p,iv)*esat_tv(f)) / ((gb_mol(p)+gs_mol(p,iv))*esat_tv(f))
+               hs = (gb_mol(p)*ceair + gs_mol(p,iv)*esat_tv(p)) / ((gb_mol(p)+gs_mol(p,iv))*esat_tv(p))
                rh_leaf(p) = hs
                gs_mol_err = mbb(p)*max(an(p,iv), 0._r8)*hs/cs*forc_pbot(t) + bbb(p)
-#ifndef _OPENACC
+
                if (abs(gs_mol(p,iv)-gs_mol_err) > 1.e-01_r8) then
-                  print *, 'Ball-Berry error check - stomatal conductance error:'
+                  write(iulog,*) 'Ball-Berry error check - stomatal conductance error:'
                   write (iulog,*) gs_mol(p,iv), gs_mol_err
                end if
-#endif
+
             end if    ! night or day if branch
          end do       ! canopy layer loop
       end do          ! patch loop
+
       !==============================================================================!
       ! Canopy photosynthesis and stomatal conductance
       !==============================================================================!
@@ -868,12 +928,10 @@ contains
       ! Sum canopy layer fluxes and then derive effective leaf-level fluxes (per
       ! unit leaf area), which are used in other parts of the model. Here, laican
       ! sums to either laisun or laisha.
-      !$acc parallel loop gang worker independent default(present) present(&
-      !$acc lai_z(:,:),nrad(:),rs_z(:,:),rs(:),psn_z(:,:),psn_wp(:),psn_wc(:),&
-      !$acc psn_wj(:),lmr(:),lmr_z(:,:),psn(:)) 
+
       do f = 1, fn
-         if(converged(f)) cycle
          p = filterp(f)
+
          psncan = 0._r8
          psncan_wc = 0._r8
          psncan_wj = 0._r8
@@ -881,14 +939,13 @@ contains
          lmrcan = 0._r8
          gscan = 0._r8
          laican = 0._r8
-         !$acc loop vector reduction(+:psncan,psncan_wc,psncan_wj, psncan_wp,lmrcan,gscan,laican)
          do iv = 1, nrad(p)
             psncan = psncan + psn_z(p,iv) * lai_z(p,iv)
-            psncan_wc = psncan_wc + psn_wc_z(f,iv) * lai_z(p,iv)
-            psncan_wj = psncan_wj + psn_wj_z(f,iv) * lai_z(p,iv)
-            psncan_wp = psncan_wp + psn_wp_z(f,iv) * lai_z(p,iv)
+            psncan_wc = psncan_wc + psn_wc_z(p,iv) * lai_z(p,iv)
+            psncan_wj = psncan_wj + psn_wj_z(p,iv) * lai_z(p,iv)
+            psncan_wp = psncan_wp + psn_wp_z(p,iv) * lai_z(p,iv)
             lmrcan = lmrcan + lmr_z(p,iv) * lai_z(p,iv)
-            gscan = gscan + lai_z(p,iv) / (rb(f)+rs_z(p,iv))
+            gscan = gscan + lai_z(p,iv) / (rb(p)+rs_z(p,iv))
             laican = laican + lai_z(p,iv)
          end do
          if (laican > 0._r8) then
@@ -897,7 +954,7 @@ contains
             psn_wj(p) = psncan_wj / laican
             psn_wp(p) = psncan_wp / laican
             lmr(p) = lmrcan / laican
-            rs(p) = laican / gscan - rb(f)
+            rs(p) = laican / gscan - rb(p)
          else
             psn(p) =  0._r8
             psn_wc(p) =  0._r8
@@ -908,24 +965,23 @@ contains
          end if
       end do
 
-      !$acc exit data delete(fnr,act25,vcmaxha,jmaxha,tpuha,lmrha,vcmaxhd,jmaxhd,tpuhd,lmrhd,lmrse,lmrc &
-      !$acc ,jmax_z(:,:), lnc(:), kn(:),psn_wc_z(:,:nlevcan),psn_wj_z(:,:nlevcan), psn_wp_z(:,:nlevcan) )
-
     end associate
 
   end subroutine Photosynthesis
 
   !------------------------------------------------------------------------------
   subroutine PhotosynthesisTotal (fn, filterp, &
-       cnstate_vars, canopystate_vars, photosyns_vars)
+       atm2lnd_vars, cnstate_vars, canopystate_vars, photosyns_vars)
 
     ! Note: This subroutine is not called via FATES (RGK)
+    !$acc routine seq
     !
     ! Determine total photosynthesis
     !
     ! !ARGUMENTS:
     integer                , intent(in)    :: fn                             ! size of pft filter
     integer                , intent(in)    :: filterp(fn)                    ! patch filter
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(cnstate_type)     , intent(in)    :: cnstate_vars
     type(canopystate_type) , intent(in)    :: canopystate_vars
     type(photosyns_type)   , intent(inout) :: photosyns_vars
@@ -967,7 +1023,6 @@ contains
          fpsn_wp     => photosyns_vars%fpsn_wp_patch       & ! Output: [real(r8) (:) ]  product-limited photosynthesis (umol CO2 /m**2 /s)
          )
 
-      !$acc parallel loop independent gang vector default(present)
       do f = 1, fn
          p = filterp(f)
          g = veg_pp%gridcell(p)
@@ -1014,6 +1069,7 @@ contains
     ! limitation is taken into account in the CNAllocation module.
     !
     ! !ARGUMENTS:
+   !$acc routine seq
     type(bounds_type)     , intent(in   )    :: bounds
     integer               , intent(in   )    :: fn                   ! size of pft filter
     integer               , intent(in   )    :: filterp(fn)          ! patch filter
@@ -1027,7 +1083,7 @@ contains
     real(r8) , pointer :: par_z (:,:)   ! needed for backwards compatiblity
     real(r8) , pointer :: alphapsn (:)  ! needed for backwards compatiblity
     integer  :: f,p,c,t,g,iv            ! indices
-    real(r8) :: co2  ! atmospheric co2 partial pressure (pa)
+    real(r8) :: co2(bounds%begp:bounds%endp)  ! atmospheric co2 partial pressure (pa)
     real(r8) :: ci
     !------------------------------------------------------------------------------
 
@@ -1043,67 +1099,37 @@ contains
 
          an          => photosyns_vars%an_patch               , & ! Input:  [real(r8) (:,:) ]  net leaf photosynthesis (umol CO2/m**2/s)
          gb_mol      => photosyns_vars%gb_mol_patch           , & ! Input:  [real(r8) (:)   ]  leaf boundary layer conductance (umol H2O/m**2/s)
-         gs_mol      => photosyns_vars%gs_mol_patch           , & ! Input:  [real(r8) (:,:) ]  leaf stomatal conductance (umol H2O/m**2/s)
-         par_z_sun    =>    solarabs_vars%parsun_z_patch      , & ! Input :  [real(r8) (:,:)]  par absorbed per unit lai for canopy layer (w/m**2)
-         alphapsn_sun =>    photosyns_vars%alphapsnsun_patch  , & ! Output:  [real(r8) (:)]
-         par_z_sha    =>    solarabs_vars%parsha_z_patch      , & ! Input :  [real(r8) (:,:)]  par absorbed per unit lai for canopy layer (w/m**2)
-         alphapsn_sha =>    photosyns_vars%alphapsnsha_patch   &  ! Output:  [real(r8) (:)]
+         gs_mol      => photosyns_vars%gs_mol_patch             & ! Input:  [real(r8) (:,:) ]  leaf stomatal conductance (umol H2O/m**2/s)
          )
 
-      ! if (phase == 1) then
-      !    par_z    =>    solarabs_vars%parsun_z_patch     ! Input :  [real(r8) (:,:)]  par absorbed per unit lai for canopy layer (w/m**2)
-      !    alphapsn =>    photosyns_vars%alphapsnsun_patch ! Output:  [real(r8) (:)]
-      ! else if (phase == 0) then
-      !    par_z    =>    solarabs_vars%parsha_z_patch     ! Input :  [real(r8) (:,:)]  par absorbed per unit lai for canopy layer (w/m**2)
-      !    alphapsn =>    photosyns_vars%alphapsnsha_patch ! Output:  [real(r8) (:)]
-      ! end if
-
-      if( phase == 1) then
-         !$acc parallel loop independent gang vector collapse(2) default(present)
-         do iv = 1,nrad(p)
-            do f = 1, fn
-               p = filterp(f)
-               c = veg_pp%column(p)
-               t = veg_pp%topounit(p)
-               g = veg_pp%gridcell(p)
-
-               co2 = forc_pco2(t)
-               if (par_z_sun(p,iv) <= 0._r8) then           ! night time
-                  alphapsn_sun(p) = 1._r8
-               else                                     ! day time
-                  ci = co2 - ((an(p,iv) * (1._r8-downreg(p)) ) * &
-                        forc_pbot(t) * &
-                        (1.4_r8*gs_mol(p,iv)+1.6_r8*gb_mol(p)) / (gb_mol(p)*gs_mol(p,iv)))
-                   alphapsn_sun(p) = 1._r8 + (((c3psn(veg_pp%itype(p)) * &
-                               (4.4_r8 + (22.6_r8*(ci/co2)))) + &
-                               ((1._r8 - c3psn(veg_pp%itype(p))) * 4.4_r8))/1000._r8)
-               end if
-            end do
-         end do
+      if (phase == 1) then
+         par_z    =>    solarabs_vars%parsun_z_patch     ! Input :  [real(r8) (:,:)]  par absorbed per unit lai for canopy layer (w/m**2)
+         alphapsn =>    photosyns_vars%alphapsnsun_patch ! Output:  [real(r8) (:)]
       else if (phase == 0) then
-         !$acc parallel loop independent gang vector collapse(2) default(present)
+         par_z    =>    solarabs_vars%parsha_z_patch     ! Input :  [real(r8) (:,:)]  par absorbed per unit lai for canopy layer (w/m**2)
+         alphapsn =>    photosyns_vars%alphapsnsha_patch ! Output:  [real(r8) (:)]
+      end if
+
+      do f = 1, fn
+         p = filterp(f)
+         c = veg_pp%column(p)
+         t = veg_pp%topounit(p)
+         g = veg_pp%gridcell(p)
+
+         co2(p) = forc_pco2(t)
          do iv = 1,nrad(p)
-            do f = 1, fn
-               p = filterp(f)
-               c = veg_pp%column(p)
-               t = veg_pp%topounit(p)
-               g = veg_pp%gridcell(p)
-
-               co2 = forc_pco2(t)
-               if (par_z_sha(p,iv) <= 0._r8) then           ! night time
-                  alphapsn_sha(p) = 1._r8
-               else                                     ! day time
-                  ci = co2 - ((an(p,iv) * (1._r8-downreg(p)) ) * &
-                        forc_pbot(t) * &
-                        (1.4_r8*gs_mol(p,iv)+1.6_r8*gb_mol(p)) / (gb_mol(p)*gs_mol(p,iv)))
-
-                   alphapsn_sha(p) = 1._r8 + (((c3psn(veg_pp%itype(p)) * &
-                               (4.4_r8 + (22.6_r8*(ci/co2)))) + &
-                               ((1._r8 - c3psn(veg_pp%itype(p))) * 4.4_r8))/1000._r8)
-               end if
-            end do
+            if (par_z(p,iv) <= 0._r8) then           ! night time
+               alphapsn(p) = 1._r8
+            else                                     ! day time
+               ci = co2(p) - ((an(p,iv) * (1._r8-downreg(p)) ) * &
+                    forc_pbot(t) * &
+                    (1.4_r8*gs_mol(p,iv)+1.6_r8*gb_mol(p)) / (gb_mol(p)*gs_mol(p,iv)))
+               alphapsn(p) = 1._r8 + (((c3psn(veg_pp%itype(p)) * &
+                    (4.4_r8 + (22.6_r8*(ci/co2(p))))) + &
+                    ((1._r8 - c3psn(veg_pp%itype(p))) * 4.4_r8))/1000._r8)
+            end if
          end do
-      end if
+      end do
 
     end associate
 
@@ -1111,21 +1137,23 @@ contains
 
   !-------------------------------------------------------------------------------
   subroutine hybrid(x0, p, iv, c, t, gb_mol, je, cair, oair, lmr_z, par_z,&
-       rh_can, gs_mol,iter, photosyns_vars)
+       rh_can, gs_mol,iter, &
+       atm2lnd_vars, photosyns_vars)
     !
-    ! DESCRIPTION:
+    !! DESCRIPTION:
     ! use a hybrid solver to find the root of equation
     ! f(x) = x- h(x),
     !we want to find x, s.t. f(x) = 0.
     !the hybrid approach combines the strength of the newton secant approach (find the solution domain)
     !and the bisection approach implemented with the Brent's method to guarrantee convergence.
+
     !
-    ! REVISION HISTORY:
+    !! REVISION HISTORY:
     !Dec 14/2012: created by Jinyun Tang
     !
-    !USES:
+    !!USES:
     !
-    ! ARGUMENTS:
+    !! ARGUMENTS:
       !$acc routine seq
     implicit none
     real(r8), intent(inout) :: x0              !initial guess and final value of the solution
@@ -1139,6 +1167,7 @@ contains
     integer,  intent(in) :: p, iv, c, t        ! pft, c3/c4, column, and topounit index
     real(r8), intent(out) :: gs_mol            ! leaf stomatal conductance (umol H2O/m**2/s)
     integer,  intent(out) :: iter              !number of iterations used, for record only
+    type(atm2lnd_type)  , intent(in)    :: atm2lnd_vars
     type(photosyns_type), intent(inout) :: photosyns_vars
     !
     !! LOCAL VARIABLES
@@ -1152,7 +1181,7 @@ contains
     real(r8) :: tol,minx,minf
 
     call ci_func(x0, f0, p, iv, c, t, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, &
-                 photosyns_vars)
+         atm2lnd_vars, photosyns_vars)
 
     if(f0 == 0._r8)return
 
@@ -1161,7 +1190,7 @@ contains
     x1 = x0 * 0.99_r8
 
     call ci_func(x1,f1, p, iv, c, t, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, &
-                  photosyns_vars)
+         atm2lnd_vars, photosyns_vars)
 
     if(f1==0._r8)then
        x0 = x1
@@ -1188,7 +1217,7 @@ contains
        x1 = x
 
        call ci_func(x1,f1, p, iv, c, t, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, &
-                     photosyns_vars)
+            atm2lnd_vars, photosyns_vars)
 
        if(f1<minf)then
           minx=x1
@@ -1204,7 +1233,7 @@ contains
 
           call brent(x, x0,x1,f0,f1, tol, p, iv, c, t, gb_mol, je, cair, oair, &
                lmr_z, par_z, rh_can, gs_mol, &
-               photosyns_vars)
+               atm2lnd_vars, photosyns_vars)
 
           x0=x
           exit
@@ -1216,7 +1245,7 @@ contains
           !and it happens usually in very dry places and more likely with c4 plants.
 
           call ci_func(minx,f1, p, iv, c, t, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, &
-                       photosyns_vars)
+               atm2lnd_vars, photosyns_vars)
 
           exit
        endif
@@ -1227,7 +1256,7 @@ contains
   !------------------------------------------------------------------------------
   subroutine brent(x, x1,x2,f1, f2, tol, ip, iv, ic, it, gb_mol, je, cair, oair,&
        lmr_z, par_z, rh_can, gs_mol, &
-       photosyns_vars)
+       atm2lnd_vars, photosyns_vars)
      !$acc routine seq
 
     !!DESCRIPTION:
@@ -1250,6 +1279,7 @@ contains
     real(r8), intent(in) :: rh_can            ! inside canopy relative humidity
     integer,  intent(in) :: ip, iv, ic, it    ! pft, c3/c4, column, and topounit index
     real(r8), intent(out) :: gs_mol           ! leaf stomatal conductance (umol H2O/m**2/s)
+    type(atm2lnd_type)  , intent(in)    :: atm2lnd_vars
     type(photosyns_type), intent(inout) :: photosyns_vars
     !
     !!LOCAL VARIABLES:
@@ -1263,12 +1293,10 @@ contains
     b=x2
     fa=f1
     fb=f2
-#ifndef _OPENACC
     if((fa > 0._r8 .and. fb > 0._r8).or.(fa < 0._r8 .and. fb < 0._r8))then
        write(iulog,*) 'root must be bracketed for brent'
        call endrun(msg=errmsg(__FILE__, __LINE__))
     endif
-#endif
     c=b
     fc=fb
     iter = 0
@@ -1328,7 +1356,7 @@ contains
        endif
 
        call ci_func(b, fb, ip, iv, ic, it, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, &
-                    photosyns_vars)
+         atm2lnd_vars, photosyns_vars)
 
        if(fb==0._r8)exit
 
@@ -1418,9 +1446,9 @@ contains
 
   !------------------------------------------------------------------------------
   subroutine ci_func(ci, fval, p, iv, c, t, gb_mol, je, cair, oair, lmr_z, par_z,&
-       rh_can, gs_mol, photosyns_vars)
+       rh_can, gs_mol, atm2lnd_vars, photosyns_vars)
     !$acc routine seq
-    ! DESCRIPTION:
+    !! DESCRIPTION:
     ! evaluate the function
     ! f(ci)=ci - (ca - (1.37rb+1.65rs))*patm*an
     !
@@ -1429,7 +1457,7 @@ contains
     ! photosynthesis model, I have decided to add these relevant variables to
     ! the relevant data types.
     !
-    ! ARGUMENTS:
+    !!ARGUMENTS:
     real(r8)             , intent(in)    :: ci       ! intracellular leaf CO2 (Pa)
     real(r8)             , intent(in)    :: lmr_z    ! canopy layer: leaf maintenance respiration rate (umol CO2/m**2/s)
     real(r8)             , intent(in)    :: par_z    ! par absorbed per unit lai for canopy layer (w/m**2)
@@ -1441,6 +1469,7 @@ contains
     integer              , intent(in)    :: p,iv,c,t ! pft, vegetation type, column, and topounit indexes
     real(r8)             , intent(out)   :: fval     ! return function of the value f(ci)
     real(r8)             , intent(out)   :: gs_mol   ! leaf stomatal conductance (umol H2O/m**2/s)
+    type(atm2lnd_type)   , intent(in)    :: atm2lnd_vars
     type(photosyns_type) , intent(inout) :: photosyns_vars
     !
     !local variables
@@ -1535,7 +1564,8 @@ contains
       gs_mol = max(r1,r2)
 
       ! Derive new estimate for ci
-      fval = ci - cair + an(p,iv) * forc_pbot(t) * (1.4_r8*gs_mol+1.6_r8*gb_mol) / (gb_mol*gs_mol)
+
+      fval =ci - cair + an(p,iv) * forc_pbot(t) * (1.4_r8*gs_mol+1.6_r8*gb_mol) / (gb_mol*gs_mol)
 
     end associate
 
@@ -2099,7 +2129,7 @@ contains
                   if (nlevcan == 1) then
                      nscaler = 1.0_r8
                   else if (nlevcan > 1) then
-                     nscaler = exp(-kn(f) * laican)
+                     nscaler = exp(-kn(p) * laican)
                   end if
                   sum_nscaler = sum_nscaler + nscaler
                end do
@@ -2144,7 +2174,7 @@ contains
                      if (nlevcan == 1) then
                         nscaler = 1.0_r8
                      else if (nlevcan > 1) then
-                        nscaler = exp(-kn(f) * laican)
+                        nscaler = exp(-kn(p) * laican)
                      end if
                      sum_nscaler = sum_nscaler + nscaler
                   end do
@@ -2192,9 +2222,9 @@ contains
          ! will use canopy integrated scaling factors from SurfaceAlbedo.
 
          if (dayl_factor(p) .eq. 0._r8) then
-            kn(f) =  0._r8
+            kn(p) =  0._r8
          else
-            kn(f) = exp(0.00963_r8 * vcmax25top/dayl_factor(p) - 2.43_r8)
+            kn(p) = exp(0.00963_r8 * vcmax25top/dayl_factor(p) - 2.43_r8)
          end if
 
 
@@ -2254,8 +2284,8 @@ contains
                nscaler_sun = vcmaxcint_sun(p)
                nscaler_sha = vcmaxcint_sha(p)
             else if (nlevcan > 1) then
-               nscaler_sun = exp(-kn(f) * laican)
-               nscaler_sha = exp(-kn(f) * laican)
+               nscaler_sun = exp(-kn(p) * laican)
+               nscaler_sha = exp(-kn(p) * laican)
             end if
 
             ! Maintenance respiration
@@ -2503,13 +2533,12 @@ contains
                end if
 
                ! Make sure iterative solution is correct
-#ifndef _OPENACC
+
                if (gs_mol_sun(p,iv) < 0._r8 .or. gs_mol_sha(p,iv) < 0._r8) then
                   write (iulog,*)'Negative stomatal conductance:'
                   write (iulog,*)'p,iv,gs_mol_sun,gs_mol_sha= ',p,iv,gs_mol_sun(p,iv),gs_mol_sha(p,iv)
                   call endrun(decomp_index=p, elmlevel=namep, msg=errmsg(__FILE__, __LINE__))
                end if
-#endif
 
                ! Compare with Ball-Berry model: gs_mol = m * an * hs/cs p + b
 
@@ -2518,23 +2547,20 @@ contains
                !KO  Follow CLM photosynthesis to limit bbb
                gs_mol_err = mbb(p)*max(an_sun(p,iv), 0._r8)*hs/cs_sun*forc_pbot(t) + max( bsun(p)*bbb(p), 1._r8 )
 
-#ifndef _OPENACC
                if (abs(gs_mol_sun(p,iv)-gs_mol_err) > 1.e-01_r8) then
                   write (iulog,*) 'Ball-Berry error check - sunlit stomatal conductance error:'
                   write (iulog,*) gs_mol_sun(p,iv), gs_mol_err
                end if
-#endif
+
                hs = (gb_mol(p)*ceair + gs_mol_sha(p,iv)*esat_tv(p)) / ((gb_mol(p)+gs_mol_sha(p,iv))*esat_tv(p))
                rh_leaf_sha(p) = hs
                !KO  Follow CLM photosynthesis to limit bbb
                gs_mol_err = mbb(p)*max(an_sha(p,iv), 0._r8)*hs/cs_sha*forc_pbot(t) + max( bsha(p)*bbb(p), 1._r8)
 
-#ifndef _OPENACC
                if (abs(gs_mol_sha(p,iv)-gs_mol_err) > 1.e-01_r8) then
                   write (iulog,*) 'Ball-Berry error check - shaded stomatal conductance error:'
                   write (iulog,*) gs_mol_sha(p,iv), gs_mol_err
                end if
-#endif
 
             end if    ! night or day if branch
          end do       ! canopy layer loop
@@ -2929,14 +2955,12 @@ contains
     fa(:)=(/f1sun,f1sha/)
     fb(:)=(/f2sun,f2sha/)
 
-#ifndef _OPENACC
     do phase=1, nphs
        if ( (fa(phase) > 0._r8 .and. fb(phase) > 0._r8) .or. (fa(phase) < 0._r8 .and. fb(phase) < 0._r8) ) then
           write(iulog,*) 'root must be bracketed for brent'
           call endrun(msg=errmsg(__FILE__, __LINE__))
        endif
     enddo
-#endif
 
     c=b
     fc=fb
@@ -3012,9 +3036,7 @@ contains
 
        if( (fb(sun) == 0._r8) .and. (fb(sha) == 0._r8) ) exit
     enddo
-#ifndef _OPENACC
     if( iter == itmax) write(iulog,*) 'brent exceeding maximum iterations', b, fb
-#endif
     xsun=b(sun)
     xsha=b(sha)
 
diff --git a/components/elm/src/biogeophys/QSatMod.F90 b/components/elm/src/biogeophys/QSatMod.F90
index 511028c671..e6636bf6e9 100644
--- a/components/elm/src/biogeophys/QSatMod.F90
+++ b/components/elm/src/biogeophys/QSatMod.F90
@@ -68,7 +68,7 @@ contains
     ! Reference:  Polynomial approximations from:
     !             Piotr J. Flatau, et al.,1992:  Polynomial fits to saturation
     !             vapor pressure.  Journal of Applied Meteorology, 31, 1507-1513.
-    !$acc routine seq 
+    !
     ! !USES:
     use shr_kind_mod , only: r8 => shr_kind_r8
     use shr_const_mod, only: SHR_CONST_TKFRZ
diff --git a/components/elm/src/biogeophys/RootBiophysMod.F90 b/components/elm/src/biogeophys/RootBiophysMod.F90
index 59f8567529..42a6b1e831 100644
--- a/components/elm/src/biogeophys/RootBiophysMod.F90
+++ b/components/elm/src/biogeophys/RootBiophysMod.F90
@@ -16,7 +16,7 @@ module RootBiophysMod
 
   integer :: root_prof_method              !select the type of root profile parameterization   
   !-------------------------------------------------------------------------------------- 
-  !$acc declare create(root_prof_method)
+
 contains
 
   !-------------------------------------------------------------------------------------- 
@@ -35,13 +35,13 @@ contains
     !
     !DESCRIPTION
     !initialize plant root profiles
-    !$acc routine seq 
+    !
     ! USES
     use shr_kind_mod   , only : r8 => shr_kind_r8   
-    !use shr_assert_mod , only : shr_assert
+    use shr_assert_mod , only : shr_assert
     use shr_log_mod    , only : errMsg => shr_log_errMsg
     use decompMod      , only : bounds_type
-    !use abortutils     , only : endrun         
+    use abortutils     , only : endrun         
     !
     ! !ARGUMENTS:
     implicit none
@@ -52,10 +52,10 @@ contains
     real(r8),          intent(out):: rootfr(bounds%begp: , 1: ) !
     !
     ! !LOCAL VARIABLES:
-    !character(len=32) :: subname = 'init_vegrootfr'  ! subroutine name
+    character(len=32) :: subname = 'init_vegrootfr'  ! subroutine name
     !------------------------------------------------------------------------
 
-    !SHR_ASSERT_ALL((ubound(rootfr) == (/bounds%endp, nlevgrnd/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(rootfr) == (/bounds%endp, nlevgrnd/)), errMsg(__FILE__, __LINE__))
 
     select case (root_prof_method)
     case (zeng_2001_root)
@@ -68,7 +68,7 @@ contains
        !schenk and Jackson root, 2002, to be defined later
        !rootfr(bounds%begp:bounds%endp, 1 : ubj) = schenk2002_rootfr(bounds, ubj, pcolumn, ivt, zi)        
     case default
-       !call endrun(subname // ':: a root fraction function must be specified!')   
+       call endrun(subname // ':: a root fraction function must be specified!')   
     end select
     rootfr(bounds%begp:bounds%endp,nlevsoi+1:nlevgrnd)=0._r8   
 
@@ -80,7 +80,7 @@ contains
     ! DESCRIPTION
     ! compute root profile for soil water uptake
     ! using equation from Zeng 2001, J. Hydrometeorology
-    !$acc routine seq 
+    !
     ! USES
     use shr_kind_mod   , only : r8 => shr_kind_r8   
     use shr_assert_mod , only : shr_assert
diff --git a/components/elm/src/biogeophys/SnowHydrologyMod.F90 b/components/elm/src/biogeophys/SnowHydrologyMod.F90
index 598eb3b30d..62f2ba2424 100644
--- a/components/elm/src/biogeophys/SnowHydrologyMod.F90
+++ b/components/elm/src/biogeophys/SnowHydrologyMod.F90
@@ -130,6 +130,7 @@ contains
     ! to being called.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon        , only : denh2o, denice, wimp, ssi
     use landunit_varcon   , only : istsoil
     use AerosolMod        , only : AerosolFluxes
@@ -143,33 +144,34 @@ contains
     integer               , intent(in)    :: filter_nosnowc(:) ! column filter for non-snow points
     type(atm2lnd_type)    , intent(in)    :: atm2lnd_vars
     type(aerosol_type)    , intent(inout) :: aerosol_vars
+    real(r8)   :: dtime
     !
     ! !LOCAL VARIABLES:
     integer  :: g                                                  ! gridcell loop index
     integer  :: c, j, fc, l                                        ! do loop/array indices
-    real(r8) :: qin         (1:num_snowc)                       ! water flow into the elmement (mm/s)
-    real(r8) :: qout        (1:num_snowc)                      ! water flow out of the elmement (mm/s)
-    real(r8) :: qin_bc_phi  (1:num_snowc)              ! flux of hydrophilic BC into   layer [kg]
-    real(r8) :: qout_bc_phi (1:num_snowc)              ! flux of hydrophilic BC out of layer [kg]
-    real(r8) :: qin_bc_pho  (1:num_snowc)              ! flux of hydrophobic BC into   layer [kg]
-    real(r8) :: qout_bc_pho (1:num_snowc)              ! flux of hydrophobic BC out of layer [kg]
-    real(r8) :: qin_oc_phi  (1:num_snowc)              ! flux of hydrophilic OC into   layer [kg]
-    real(r8) :: qout_oc_phi (1:num_snowc)              ! flux of hydrophilic OC out of layer [kg]
-    real(r8) :: qin_oc_pho  (1:num_snowc)              ! flux of hydrophobic OC into   layer [kg]
-    real(r8) :: qout_oc_pho (1:num_snowc)              ! flux of hydrophobic OC out of layer [kg]
-    real(r8) :: qin_dst1    (1:num_snowc)              ! flux of dust species 1 into   layer [kg]
-    real(r8) :: qout_dst1   (1:num_snowc)              ! flux of dust species 1 out of layer [kg]
-    real(r8) :: qin_dst2    (1:num_snowc)              ! flux of dust species 2 into   layer [kg]
-    real(r8) :: qout_dst2   (1:num_snowc)              ! flux of dust species 2 out of layer [kg]
-    real(r8) :: qin_dst3    (1:num_snowc)              ! flux of dust species 3 into   layer [kg]
-    real(r8) :: qout_dst3   (1:num_snowc)              ! flux of dust species 3 out of layer [kg]
-    real(r8) :: qin_dst4    (1:num_snowc)              ! flux of dust species 4 into   layer [kg]
-    real(r8) :: qout_dst4   (1:num_snowc)              ! flux of dust species 4 out of layer [kg]
+    real(r8) :: qin(bounds%begc:bounds%endc)                       ! water flow into the elmement (mm/s)
+    real(r8) :: qout(bounds%begc:bounds%endc)                      ! water flow out of the elmement (mm/s)
+    real(r8) :: qin_bc_phi  (bounds%begc:bounds%endc)              ! flux of hydrophilic BC into   layer [kg]
+    real(r8) :: qout_bc_phi (bounds%begc:bounds%endc)              ! flux of hydrophilic BC out of layer [kg]
+    real(r8) :: qin_bc_pho  (bounds%begc:bounds%endc)              ! flux of hydrophobic BC into   layer [kg]
+    real(r8) :: qout_bc_pho (bounds%begc:bounds%endc)              ! flux of hydrophobic BC out of layer [kg]
+    real(r8) :: qin_oc_phi  (bounds%begc:bounds%endc)              ! flux of hydrophilic OC into   layer [kg]
+    real(r8) :: qout_oc_phi (bounds%begc:bounds%endc)              ! flux of hydrophilic OC out of layer [kg]
+    real(r8) :: qin_oc_pho  (bounds%begc:bounds%endc)              ! flux of hydrophobic OC into   layer [kg]
+    real(r8) :: qout_oc_pho (bounds%begc:bounds%endc)              ! flux of hydrophobic OC out of layer [kg]
+    real(r8) :: qin_dst1    (bounds%begc:bounds%endc)              ! flux of dust species 1 into   layer [kg]
+    real(r8) :: qout_dst1   (bounds%begc:bounds%endc)              ! flux of dust species 1 out of layer [kg]
+    real(r8) :: qin_dst2    (bounds%begc:bounds%endc)              ! flux of dust species 2 into   layer [kg]
+    real(r8) :: qout_dst2   (bounds%begc:bounds%endc)              ! flux of dust species 2 out of layer [kg]
+    real(r8) :: qin_dst3    (bounds%begc:bounds%endc)              ! flux of dust species 3 into   layer [kg]
+    real(r8) :: qout_dst3   (bounds%begc:bounds%endc)              ! flux of dust species 3 out of layer [kg]
+    real(r8) :: qin_dst4    (bounds%begc:bounds%endc)              ! flux of dust species 4 into   layer [kg]
+    real(r8) :: qout_dst4   (bounds%begc:bounds%endc)              ! flux of dust species 4 out of layer [kg]
     real(r8) :: wgdif                                              ! ice mass after minus sublimation
-    real(r8) :: vol_liq(1:num_snowc,-nlevsno+1:0)      ! partial volume of liquid water in layer
-    real(r8) :: vol_ice(1:num_snowc,-nlevsno+1:0)      ! partial volume of ice lens in layer
-    real(r8) :: eff_porosity(1:num_snowc,-nlevsno+1:0) ! effective porosity = porosity - vol_ice
-    real(r8) :: mss_liqice(1:num_snowc,-nlevsno+1:0)   ! mass of liquid+ice in a layer
+    real(r8) :: vol_liq(bounds%begc:bounds%endc,-nlevsno+1:0)      ! partial volume of liquid water in layer
+    real(r8) :: vol_ice(bounds%begc:bounds%endc,-nlevsno+1:0)      ! partial volume of ice lens in layer
+    real(r8) :: eff_porosity(bounds%begc:bounds%endc,-nlevsno+1:0) ! effective porosity = porosity - vol_ice
+    real(r8) :: mss_liqice(bounds%begc:bounds%endc,-nlevsno+1:0)   ! mass of liquid+ice in a layer
     !-----------------------------------------------------------------------
     !mgf++
     real(r8) :: refrzsnow                   ! re-frozen snow [kg m-2]
@@ -201,7 +203,7 @@ contains
          qflx_dew_grnd  => col_wf%qflx_dew_grnd  , & ! Input:  [real(r8) (:)   ] ground surface dew formation (mm H2O /s) [+]
          qflx_snow_melt => col_wf%qflx_snow_melt , & ! Output: [real(r8) (:)   ] net snow melt
          qflx_top_soil  => col_wf%qflx_top_soil  , & ! Output: [real(r8) (:)   ] net water input into soil from top (mm/s)
-         ! qflx_snofrz_lyr => cwf%qflx_snofrz_lyr     , & ! HW+++ snow freezing rate (col,lyr) [kg m-2 s-1]
+!         qflx_snofrz_lyr => cwf%qflx_snofrz_lyr     , & ! HW+++ snow freezing rate (col,lyr) [kg m-2 s-1]
 
          mflx_neg_snow_col_1d =>  col_wf%mflx_neg_snow_1d , & ! Output:  [real(r8) (:)   ]  mass flux from top soil layer due to negative water content in snow layers (kg H2O /s)
 
@@ -217,55 +219,32 @@ contains
          begc           => bounds%begc                       , &
          endc           => bounds%endc                         &
          )
-    !$acc enter data create(&
-    !$acc qin(:), &
-    !$acc qout(:), &
-    !$acc qin_bc_phi(:), &
-    !$acc qout_bc_phi(:), &
-    !$acc qin_bc_pho(:), &
-    !$acc qout_bc_pho(:), &
-    !$acc qin_oc_phi(:), &
-    !$acc qout_oc_phi(:), &
-    !$acc qin_oc_pho(:), &
-    !$acc qout_oc_pho(:), &
-    !$acc qin_dst1(:), &
-    !$acc qout_dst1(:), &
-    !$acc qin_dst2(:), &
-    !$acc qout_dst2(:), &
-    !$acc qin_dst3(:), &
-    !$acc qout_dst3(:), &
-    !$acc qin_dst4(:), &
-    !$acc qout_dst4(:), &
-    !$acc vol_liq(:,:), &
-    !$acc vol_ice(:,:), &
-    !$acc eff_porosity(:,:), &
-    !$acc mss_liqice(:,:))
 
+      ! Determine model time step
 
+      dtime = dtime_mod
 
       ! Renew the mass of ice lens (h2osoi_ice) and liquid (h2osoi_liq) in the
       ! surface snow layer resulting from sublimation (frost) / evaporation (condense)
 
-      !TODO: check where else this is needed 
-      !mflx_neg_snow_col_1d(:) = 0._r8
+      mflx_neg_snow_col_1d(:) = 0._r8
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1,num_snowc
          c = filter_snowc(fc)
          l=col_pp%landunit(c)
 
          if (do_capsnow(c) .and. .not. use_extrasnowlayers) then
-            wgdif = h2osoi_ice(c,snl(c)+1) - frac_sno_eff(c)*qflx_sub_snow(c)*dtime_mod
+            wgdif = h2osoi_ice(c,snl(c)+1) - frac_sno_eff(c)*qflx_sub_snow(c)*dtime
             h2osoi_ice(c,snl(c)+1) = wgdif
             if (wgdif < 0._r8) then
                h2osoi_ice(c,snl(c)+1) = 0._r8
                h2osoi_liq(c,snl(c)+1) = h2osoi_liq(c,snl(c)+1) + wgdif
             end if
             h2osoi_liq(c,snl(c)+1) = h2osoi_liq(c,snl(c)+1) &
-                 - frac_sno_eff(c)*qflx_evap_grnd(c) * dtime_mod
+                 - frac_sno_eff(c)*qflx_evap_grnd(c) * dtime
          else
             wgdif = h2osoi_ice(c,snl(c)+1) &
-                 + frac_sno_eff(c) * (qflx_dew_snow(c) - qflx_sub_snow(c)) * dtime_mod
+                 + frac_sno_eff(c) * (qflx_dew_snow(c) - qflx_sub_snow(c)) * dtime
             h2osoi_ice(c,snl(c)+1) = wgdif
             if (wgdif < 0._r8) then
                h2osoi_ice(c,snl(c)+1) = 0._r8
@@ -273,11 +252,10 @@ contains
             end if
             h2osoi_liq(c,snl(c)+1) = h2osoi_liq(c,snl(c)+1) +  &
                  frac_sno_eff(c) * (qflx_rain_grnd(c) + qflx_dew_grnd(c) &
-                 - qflx_evap_grnd(c)) * dtime_mod
+                 - qflx_evap_grnd(c)) * dtime
          end if
          ! if negative, reduce deeper layer's liquid water content sequentially
          if(h2osoi_liq(c,snl(c)+1) < 0._r8) then
-            !$acc loop seq
             do j = snl(c)+1, 1
                wgdif=h2osoi_liq(c,j)
                if (wgdif >= 0._r8) exit
@@ -285,7 +263,7 @@ contains
                if (.not.(j+1 > 0 .and. use_vsfm)) then
                   h2osoi_liq(c,j+1) = h2osoi_liq(c,j+1) + wgdif
                else
-                  mflx_neg_snow_col_1d(c-bounds%begc+1) = wgdif/dtime_mod
+                  mflx_neg_snow_col_1d(c-bounds%begc+1) = wgdif/dtime
                endif
             enddo
          end if
@@ -293,15 +271,14 @@ contains
 
       ! Porosity and partial volume
 
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = -nlevsno+1, 0
          do fc = 1, num_snowc
             c = filter_snowc(fc)
             if (j >= snl(c)+1) then
                ! need to scale dz by frac_sno to convert to grid cell average depth
-               vol_ice(fc,j)      = min(1._r8, h2osoi_ice(c,j)/(dz(c,j)*frac_sno_eff(c)*denice))
-               eff_porosity(fc,j) = 1._r8 - vol_ice(fc,j)
-               vol_liq(fc,j)      = min(eff_porosity(fc,j),h2osoi_liq(c,j)/(dz(c,j)*frac_sno_eff(c)*denh2o))
+               vol_ice(c,j)      = min(1._r8, h2osoi_ice(c,j)/(dz(c,j)*frac_sno_eff(c)*denice))
+               eff_porosity(c,j) = 1._r8 - vol_ice(c,j)
+               vol_liq(c,j)      = min(eff_porosity(c,j),h2osoi_liq(c,j)/(dz(c,j)*frac_sno_eff(c)*denh2o))
             end if
          end do
       end do
@@ -323,147 +300,142 @@ contains
       ! 4) update mass of aerosol in top layer, accordingly
       ! 5) update mass concentration of aerosol accordingly
 
-      !$acc parallel loop independent gang vector default(present)
-      do fc = 1,num_snowc
-         c = filter_snowc(fc)
-         qin(fc)         = 0._r8
-         qin_bc_phi(fc) = 0._r8
-         qin_bc_pho(fc) = 0._r8
-         qin_oc_phi(fc) = 0._r8
-         qin_oc_pho(fc) = 0._r8
-         qin_dst1(fc) = 0._r8
-         qin_dst2(fc) = 0._r8
-         qin_dst3(fc) = 0._r8
-         qin_dst4(fc) = 0._r8
+      do c = bounds%begc,bounds%endc
+         qin(c)         = 0._r8
+         qin_bc_phi (c) = 0._r8
+         qin_bc_pho (c) = 0._r8
+         qin_oc_phi (c) = 0._r8
+         qin_oc_pho (c) = 0._r8
+         qin_dst1   (c) = 0._r8
+         qin_dst2   (c) = 0._r8
+         qin_dst3   (c) = 0._r8
+         qin_dst4   (c) = 0._r8
       end do
 
-      !NOTE : look into qout race condition?
-
-      !$acc parallel loop independent gang vector default(present)
-      do fc = 1, num_snowc
-         c = filter_snowc(fc)
-         !$acc loop seq 
-         do j = -nlevsno+1, 0
+      do j = -nlevsno+1, 0
+         do fc = 1, num_snowc
+            c = filter_snowc(fc)
             if (j >= snl(c)+1) then
 
-               h2osoi_liq(c,j) = h2osoi_liq(c,j) + qin(fc)  
+               h2osoi_liq(c,j) = h2osoi_liq(c,j) + qin(c)
 
-               mss_bcphi(c,j) = mss_bcphi(c,j) + qin_bc_phi(fc)
-               mss_bcpho(c,j) = mss_bcpho(c,j) + qin_bc_pho(fc)
-               mss_ocphi(c,j) = mss_ocphi(c,j) + qin_oc_phi(fc)
-               mss_ocpho(c,j) = mss_ocpho(c,j) + qin_oc_pho(fc)
+               mss_bcphi(c,j) = mss_bcphi(c,j) + qin_bc_phi(c)
+               mss_bcpho(c,j) = mss_bcpho(c,j) + qin_bc_pho(c)
+               mss_ocphi(c,j) = mss_ocphi(c,j) + qin_oc_phi(c)
+               mss_ocpho(c,j) = mss_ocpho(c,j) + qin_oc_pho(c)
 
-               mss_dst1(c,j)  = mss_dst1(c,j) + qin_dst1(fc)
-               mss_dst2(c,j)  = mss_dst2(c,j) + qin_dst2(fc)
-               mss_dst3(c,j)  = mss_dst3(c,j) + qin_dst3(fc)
-               mss_dst4(c,j)  = mss_dst4(c,j) + qin_dst4(fc)
+               mss_dst1(c,j)  = mss_dst1(c,j) + qin_dst1(c)
+               mss_dst2(c,j)  = mss_dst2(c,j) + qin_dst2(c)
+               mss_dst3(c,j)  = mss_dst3(c,j) + qin_dst3(c)
+               mss_dst4(c,j)  = mss_dst4(c,j) + qin_dst4(c)
 
                if (j <= -1) then
                   ! No runoff over snow surface, just ponding on surface
-                  if (eff_porosity(fc,j) < wimp .OR. eff_porosity(fc,j+1) < wimp) then
-                     qout(fc) = 0._r8
+                  if (eff_porosity(c,j) < wimp .OR. eff_porosity(c,j+1) < wimp) then
+                     qout(c) = 0._r8
                   else
                      ! dz must be scaled by frac_sno to obtain gridcell average value
-                     qout(fc) = max(0._r8,(vol_liq(fc,j) &
-                          - ssi*eff_porosity(fc,j))*dz(c,j)*frac_sno_eff(c))
-                     qout(fc) = min(qout(fc),(1._r8-vol_ice(fc,j+1) &
-                          - vol_liq(fc,j+1))*dz(c,j+1)*frac_sno_eff(c))
+                     qout(c) = max(0._r8,(vol_liq(c,j) &
+                          - ssi*eff_porosity(c,j))*dz(c,j)*frac_sno_eff(c))
+                     qout(c) = min(qout(c),(1._r8-vol_ice(c,j+1) &
+                          - vol_liq(c,j+1))*dz(c,j+1)*frac_sno_eff(c))
                   end if
                else
-                  qout(fc) = max(0._r8,(vol_liq(fc,j) &
-                       - ssi*eff_porosity(fc,j))*dz(c,j)*frac_sno_eff(c))
+                  qout(c) = max(0._r8,(vol_liq(c,j) &
+                       - ssi*eff_porosity(c,j))*dz(c,j)*frac_sno_eff(c))
                end if
-               qout(fc) = qout(fc)*1000._r8
-               h2osoi_liq(c,j) = h2osoi_liq(c,j) - qout(fc)
-               qin(fc) = qout(fc)
+               qout(c) = qout(c)*1000._r8
+               h2osoi_liq(c,j) = h2osoi_liq(c,j) - qout(c)
+               qin(c) = qout(c)
 
                ! mass of ice+water: in extremely rare circumstances, this can
                ! be zero, even though there is a snow layer defined. In
                ! this case, set the mass to a very small value to
                ! prevent division by zero.
 
-               mss_liqice(fc,j) = h2osoi_liq(c,j)+h2osoi_ice(c,j)
-               if (mss_liqice(fc,j) < 1E-30_r8) then
-                  mss_liqice(fc,j) = 1E-30_r8
+               mss_liqice(c,j) = h2osoi_liq(c,j)+h2osoi_ice(c,j)
+               if (mss_liqice(c,j) < 1E-30_r8) then
+                  mss_liqice(c,j) = 1E-30_r8
                endif
 
                ! BCPHI:
                ! 1. flux with meltwater:
-               qout_bc_phi(fc) = qout(fc)*scvng_fct_mlt_bcphi*(mss_bcphi(c,j)/mss_liqice(fc,j))
-               if (qout_bc_phi(fc) > mss_bcphi(c,j)) then
-                  qout_bc_phi(fc) = mss_bcphi(c,j)
+               qout_bc_phi(c) = qout(c)*scvng_fct_mlt_bcphi*(mss_bcphi(c,j)/mss_liqice(c,j))
+               if (qout_bc_phi(c) > mss_bcphi(c,j)) then
+                  qout_bc_phi(c) = mss_bcphi(c,j)
                endif
-               mss_bcphi(c,j) = mss_bcphi(c,j) - qout_bc_phi(fc)
-               qin_bc_phi(fc) = qout_bc_phi(fc)
+               mss_bcphi(c,j) = mss_bcphi(c,j) - qout_bc_phi(c)
+               qin_bc_phi(c) = qout_bc_phi(c)
 
                ! BCPHO:
                ! 1. flux with meltwater:
-               qout_bc_pho(fc) = qout(fc)*scvng_fct_mlt_bcpho*(mss_bcpho(c,j)/mss_liqice(fc,j))
-               if (qout_bc_pho(fc) > mss_bcpho(c,j)) then
-                  qout_bc_pho(fc) = mss_bcpho(c,j)
+               qout_bc_pho(c) = qout(c)*scvng_fct_mlt_bcpho*(mss_bcpho(c,j)/mss_liqice(c,j))
+               if (qout_bc_pho(c) > mss_bcpho(c,j)) then
+                  qout_bc_pho(c) = mss_bcpho(c,j)
                endif
-               mss_bcpho(c,j) = mss_bcpho(c,j) - qout_bc_pho(fc)
-               qin_bc_pho(fc) = qout_bc_pho(fc)
+               mss_bcpho(c,j) = mss_bcpho(c,j) - qout_bc_pho(c)
+               qin_bc_pho(c) = qout_bc_pho(c)
 
                ! OCPHI:
                ! 1. flux with meltwater:
-               qout_oc_phi(fc) = qout(fc)*scvng_fct_mlt_ocphi*(mss_ocphi(c,j)/mss_liqice(fc,j))
-               if (qout_oc_phi(fc) > mss_ocphi(c,j)) then
-                  qout_oc_phi(fc) = mss_ocphi(c,j)
+               qout_oc_phi(c) = qout(c)*scvng_fct_mlt_ocphi*(mss_ocphi(c,j)/mss_liqice(c,j))
+               if (qout_oc_phi(c) > mss_ocphi(c,j)) then
+                  qout_oc_phi(c) = mss_ocphi(c,j)
                endif
-               mss_ocphi(c,j) = mss_ocphi(c,j) - qout_oc_phi(fc)
-               qin_oc_phi(fc) = qout_oc_phi(fc)
+               mss_ocphi(c,j) = mss_ocphi(c,j) - qout_oc_phi(c)
+               qin_oc_phi(c) = qout_oc_phi(c)
 
                ! OCPHO:
                ! 1. flux with meltwater:
-               qout_oc_pho(fc) = qout(fc)*scvng_fct_mlt_ocpho*(mss_ocpho(c,j)/mss_liqice(fc,j))
-               if (qout_oc_pho(fc) > mss_ocpho(c,j)) then
-                  qout_oc_pho(fc) = mss_ocpho(c,j)
+               qout_oc_pho(c) = qout(c)*scvng_fct_mlt_ocpho*(mss_ocpho(c,j)/mss_liqice(c,j))
+               if (qout_oc_pho(c) > mss_ocpho(c,j)) then
+                  qout_oc_pho(c) = mss_ocpho(c,j)
                endif
-               mss_ocpho(c,j) = mss_ocpho(c,j) - qout_oc_pho(fc)
-               qin_oc_pho(fc) = qout_oc_pho(fc)
+               mss_ocpho(c,j) = mss_ocpho(c,j) - qout_oc_pho(c)
+               qin_oc_pho(c) = qout_oc_pho(c)
 
                ! DUST 1:
                ! 1. flux with meltwater:
-               qout_dst1(fc) = qout(fc)*scvng_fct_mlt_dst1*(mss_dst1(c,j)/mss_liqice(fc,j))
-               if (qout_dst1(fc) > mss_dst1(c,j)) then
-                  qout_dst1(fc) = mss_dst1(c,j)
+               qout_dst1(c) = qout(c)*scvng_fct_mlt_dst1*(mss_dst1(c,j)/mss_liqice(c,j))
+               if (qout_dst1(c) > mss_dst1(c,j)) then
+                  qout_dst1(c) = mss_dst1(c,j)
                endif
-               mss_dst1(c,j) = mss_dst1(c,j) - qout_dst1(fc)
-               qin_dst1(fc) = qout_dst1(fc)
+               mss_dst1(c,j) = mss_dst1(c,j) - qout_dst1(c)
+               qin_dst1(c) = qout_dst1(c)
 
                ! DUST 2:
                ! 1. flux with meltwater:
-               qout_dst2(fc) = qout(fc)*scvng_fct_mlt_dst2*(mss_dst2(c,j)/mss_liqice(fc,j))
-               if (qout_dst2(fc) > mss_dst2(c,j)) then
-                  qout_dst2(fc) = mss_dst2(c,j)
+               qout_dst2(c) = qout(c)*scvng_fct_mlt_dst2*(mss_dst2(c,j)/mss_liqice(c,j))
+               if (qout_dst2(c) > mss_dst2(c,j)) then
+                  qout_dst2(c) = mss_dst2(c,j)
                endif
-               mss_dst2(c,j) = mss_dst2(c,j) - qout_dst2(fc)
-               qin_dst2(fc) = qout_dst2(fc)
+               mss_dst2(c,j) = mss_dst2(c,j) - qout_dst2(c)
+               qin_dst2(c) = qout_dst2(c)
 
                ! DUST 3:
                ! 1. flux with meltwater:
-               qout_dst3(fc) = qout(fc)*scvng_fct_mlt_dst3*(mss_dst3(c,j)/mss_liqice(fc,j))
-               if (qout_dst3(fc) > mss_dst3(c,j)) then
-                  qout_dst3(fc) = mss_dst3(c,j)
+               qout_dst3(c) = qout(c)*scvng_fct_mlt_dst3*(mss_dst3(c,j)/mss_liqice(c,j))
+               if (qout_dst3(c) > mss_dst3(c,j)) then
+                  qout_dst3(c) = mss_dst3(c,j)
                endif
-               mss_dst3(c,j) = mss_dst3(c,j) - qout_dst3(fc)
-               qin_dst3(fc) = qout_dst3(fc)
+               mss_dst3(c,j) = mss_dst3(c,j) - qout_dst3(c)
+               qin_dst3(c) = qout_dst3(c)
 
                ! DUST 4:
                ! 1. flux with meltwater:
-               qout_dst4(fc) = qout(fc)*scvng_fct_mlt_dst4*(mss_dst4(c,j)/mss_liqice(fc,j))
-               if (qout_dst4(fc) > mss_dst4(c,j)) then
-                  qout_dst4(fc) = mss_dst4(c,j)
+               qout_dst4(c) = qout(c)*scvng_fct_mlt_dst4*(mss_dst4(c,j)/mss_liqice(c,j))
+               if (qout_dst4(c) > mss_dst4(c,j)) then
+                  qout_dst4(c) = mss_dst4(c,j)
                endif
-               mss_dst4(c,j) = mss_dst4(c,j) - qout_dst4(fc)
-               qin_dst4(fc) = qout_dst4(fc)
+               mss_dst4(c,j) = mss_dst4(c,j) - qout_dst4(c)
+               qin_dst4(c) = qout_dst4(c)
 
             end if
          end do
       end do
 
-      ! Compute aerosol fluxes through snowpack and aerosol deposition fluxes into top layer
+      ! Compute aerosol fluxes through snowpack and aerosol deposition fluxes into top layere
+
       call AerosolFluxes(bounds, num_snowc, filter_snowc, &
            atm2lnd_vars, aerosol_vars)
 
@@ -473,7 +445,6 @@ contains
       ! Layer interfaces (zi) and node depths (z) do not need adjustment here because they
       ! are adjusted in CombineSnowLayers and are not used up to that point.
 
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
       do j = -nlevsno+1, 0
          do fc = 1, num_snowc
             c = filter_snowc(fc)
@@ -483,19 +454,17 @@ contains
          end do
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_snowc
          c = filter_snowc(fc)
          ! Qout from snow bottom
-         qflx_snow_melt(c) = qflx_snow_melt(c) + (qout(fc) / dtime_mod)
+         qflx_snow_melt(c) = qflx_snow_melt(c) + (qout(c) / dtime)
 
-         qflx_top_soil(c) = (qout(fc) / dtime_mod) &
+         qflx_top_soil(c) = (qout(c) / dtime) &
               + (1.0_r8 - frac_sno_eff(c)) * qflx_rain_grnd(c)
          int_snow(c) = int_snow(c) + frac_sno_eff(c) &
-                       * (qflx_dew_snow(c) + qflx_dew_grnd(c) + qflx_rain_grnd(c)) * dtime_mod
+                       * (qflx_dew_snow(c) + qflx_dew_grnd(c) + qflx_rain_grnd(c)) * dtime
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_nosnowc
          c = filter_nosnowc(fc)
          qflx_snow_melt(c) = qflx_snomelt(c)
@@ -513,13 +482,12 @@ contains
     ! state based on snow sublimation and re-freezing of liquid water.
     ! Re-freezing effect is inactived by default because of
     ! uncertainty in how this process operates.
-    !$acc parallel loop independent gang vector default(present) collapse(2) 
     do j = -nlevsno+1, 0
        do fc = 1, num_snowc
           c = filter_snowc(fc)
           if (j >= snl(c)+1) then
              !! snow that has re-frozen [kg/m2]
-             !refrzsnow = max(0._r8, (qflx_snofrz_lyr(c,j)*dtime_mod))
+             !refrzsnow = max(0._r8, (qflx_snofrz_lyr(c,j)*dtime))
              !
              !! fraction of layer mass that is re-frozen
              !if ((h2osoi_liq(c,j) + h2osoi_ice(c,j)) > 0._r8) then
@@ -530,7 +498,7 @@ contains
 
              if (j == snl(c)+1) then
                 ! snow that has sublimated [kg/m2] (top layer only)
-                subsnow = max(0._r8, (qflx_sub_snow(c)*dtime_mod))
+                subsnow = max(0._r8, (qflx_sub_snow(c)*dtime))
 
                 ! fraction of layer mass that has sublimated:
                 if ((h2osoi_liq(c,j) + h2osoi_ice(c,j)) > 0._r8) then
@@ -568,40 +536,13 @@ contains
     !mgf--
 #endif
 
-
-
-
-    !$acc exit data delete(&
-    !$acc qin(:), &
-    !$acc qout(:), &
-    !$acc qin_bc_phi(:), &
-    !$acc qout_bc_phi(:), &
-    !$acc qin_bc_pho(:), &
-    !$acc qout_bc_pho(:), &
-    !$acc qin_oc_phi(:), &
-    !$acc qout_oc_phi(:), &
-    !$acc qin_oc_pho(:), &
-    !$acc qout_oc_pho(:), &
-    !$acc qin_dst1(:), &
-    !$acc qout_dst1(:), &
-    !$acc qin_dst2(:), &
-    !$acc qout_dst2(:), &
-    !$acc qin_dst3(:), &
-    !$acc qout_dst3(:), &
-    !$acc qin_dst4(:), &
-    !$acc qout_dst4(:), &
-    !$acc vol_liq(:,:), &
-    !$acc vol_ice(:,:), &
-    !$acc eff_porosity(:,:), &
-    !$acc mss_liqice(:,:))
-
     end associate
 
    end subroutine SnowWater
 
    !-----------------------------------------------------------------------
    subroutine SnowCompaction(bounds, num_snowc, filter_snowc, &
-         top_as, dtime)
+         top_as_inst, dtime)
      !
      ! !DESCRIPTION:
      ! Determine the change in snow layer thickness due to compaction and
@@ -613,6 +554,7 @@ contains
      ! fraction after the melting versus before the melting.
      !
      ! !USES:
+      !$acc routine seq
      use elm_varcon      , only : denice, denh2o, tfrz, rpi, grav, rgas
      use landunit_varcon , only : istice_mec, istdlak, istsoil, istcrop
      use elm_varctl      , only : subgridflag
@@ -621,7 +563,7 @@ contains
      type(bounds_type)      , intent(in) :: bounds
      integer                , intent(in) :: num_snowc       ! number of column snow points in column filter
      integer                , intent(in) :: filter_snowc(:) ! column filter for snow points
-     type(topounit_atmospheric_state), intent(in) :: top_as
+     type(topounit_atmospheric_state), intent(in) :: top_as_inst
      real(r8), intent(in)  :: dtime
      !
      ! !LOCAL VARIABLES:
@@ -639,9 +581,9 @@ contains
      real(r8), parameter :: k_creep_firn = 1.2e-9_r8 ! Creep coefficient for firn (bi > 550 kg / m3)
      !
      real(r8) :: p_gls                           ! grain load stress [kg / m-s2]
-     real(r8) :: burden (1:num_snowc) ! pressure of overlying snow [kg/m2]
-     real(r8) :: zpseudo(1:num_snowc)! wind drift compaction / pseudo depth
-     logical  :: mobile (1:num_snowc) ! current snow layer is mobile, i.e. susceptible to wind drift
+     real(r8) :: burden(bounds%begc:bounds%endc) ! pressure of overlying snow [kg/m2]
+     real(r8) :: zpseudo(bounds%begc:bounds%endc)! wind drift compaction / pseudo depth
+     logical  :: mobile(bounds%begc:bounds%endc) ! current snow layer is mobile, i.e. susceptible to wind drift
      real(r8) :: snw_ssa                         ! Equivalent snow specific surface area [m2/kg] 
      real(r8) :: ddz1_fresh                      ! Rate of settling of dendritic snowpack (Lehning et al., 2002) [1/s]
      real(r8) :: ddz1                            ! Rate of settling of snowpack due to destructive metamorphism.
@@ -657,7 +599,6 @@ contains
      real(r8) :: bi                              ! partial density of ice [kg/m3]
      real(r8) :: wsum                            ! snowpack total water mass (ice+liquid) [kg/m2]
      real(r8) :: fsno_melt
-     real(r8) :: burden_noextra 
      !-----------------------------------------------------------------------
 
      associate(                                              &
@@ -665,7 +606,7 @@ contains
           n_melt       => col_pp%n_melt                       , & ! Input:  [real(r8) (:)   ] SCA shape parameter
           ltype        => lun_pp%itype                        , & ! Input:  [integer (:)    ] landunit type
 
-          forc_wind    => top_as%windbot                 , & ! Input:  [real(r8) (:) ]  atmospheric wind speed (m/s)
+          forc_wind    => top_as_inst%windbot                 , & ! Input:  [real(r8) (:) ]  atmospheric wind speed (m/s)
           t_soisno     => col_es%t_soisno    , & ! Input:  [real(r8) (:,:) ] soil temperature (Kelvin)
           imelt        => col_ef%imelt       , & ! Input:  [integer (:,:)  ] flag for melting (=1), freezing (=2), Not=0
 
@@ -679,54 +620,56 @@ contains
           snw_rds      => col_ws%snw_rds      , & ! Output: [real(r8) (:,:) ] effective snow grain radius (col,lyr) [microns, m^-6]
           dz           => col_pp%dz                             & ! Output: [real(r8) (: ,:) ] layer depth (m)                        
           )
-     !$acc enter data create(&
-     !$acc burden(:), &
-     !$acc zpseudo(:), &
-     !$acc mobile(:), &
-     !$acc ddz1_fresh, &
-     !$acc ddz1, &
-     !$acc ddz3, &
-     !$acc burden_noextra)
-
-
-
 
        ! Begin calculation - note that the following column loops are only invoked if snl(c) < 0
-          if (use_extrasnowlayers) then
+
+       if (use_extrasnowlayers) then
           do fc = 1, num_snowc
-             burden(fc) = 0._r8
-             zpseudo(fc) = 0._r8
-             mobile(fc) = .true.
+             c = filter_snowc(fc)
+             burden(c) = 0._r8
+             zpseudo(c) = 0._r8
+             mobile(c) = .true.
           end do
-      !  else
-      !    !$acc parallel loop independent gang vector default(present)
-      !    do fc = 1, num_snowc
-      !       burden(fc) = 0._r8
-      !    end do 
+       else
+          burden(bounds%begc : bounds%endc) = 0._r8
        end if
 
-       if( use_extrasnowlayers) then 
-         do j = -nlevsno+1, 0
-            do fc = 1, num_snowc
-               c = filter_snowc(fc)
-               t = col_pp%topounit(c)
-               l = col_pp%landunit(c)
-               if (j >= snl(c)+1) then
-
-                  wx = (h2osoi_ice(c,j) + h2osoi_liq(c,j))
-                  void = 1._r8 - (h2osoi_ice(c,j)/denice + h2osoi_liq(c,j)/denh2o)&
-                       /(frac_sno(c) * dz(c,j))
-                  
-                  ! Allow compaction only for non-saturated node and higher ice lens node.
-                  if (void > 0.001_r8 .and. h2osoi_ice(c,j) > .1_r8) then
-
-                     bi = h2osoi_ice(c,j) / (frac_sno(c) * dz(c,j))
-                     fi = h2osoi_ice(c,j) / wx
-                     td = tfrz-t_soisno(c,j)
-                     dexpf = exp(-c4*td)
-
-                     ! Settling as a result of destructive metamorphism
-                     ddz1_fresh = (-grav * (burden(fc) + wx/2._r8)) / &
+       do j = -nlevsno+1, 0
+          do fc = 1, num_snowc
+             c = filter_snowc(fc)
+             if (use_extrasnowlayers) then
+                t = col_pp%topounit(c)
+             end if
+             if (j >= snl(c)+1) then
+                wx = (h2osoi_ice(c,j) + h2osoi_liq(c,j))
+                void = 1._r8 - (h2osoi_ice(c,j)/denice + h2osoi_liq(c,j)/denh2o)&
+                     /(frac_sno(c) * dz(c,j))
+                ! If void is negative, then increase dz such that void = 0.
+                ! This should be done for any landunit, but for now is done only for glacier_mec 1andunits.
+                
+                if (.not. use_extrasnowlayers) then
+                   ! I don't think the next 5 lines are necessary (removed in CLMv5)
+                   l = col_pp%landunit(c)
+                   if (ltype(l)==istice_mec .and. void < 0._r8) then
+                      dz(c,j) = h2osoi_ice(c,j)/denice + h2osoi_liq(c,j)/denh2o
+                      void = 0._r8
+                   endif
+                endif
+
+                ! Allow compaction only for non-saturated node and higher ice lens node.
+                if (void > 0.001_r8 .and. h2osoi_ice(c,j) > .1_r8) then
+
+                   bi = h2osoi_ice(c,j) / (frac_sno(c) * dz(c,j))
+                   fi = h2osoi_ice(c,j) / wx
+                   td = tfrz-t_soisno(c,j)
+                   dexpf = exp(-c4*td)
+
+                   ! Settling as a result of destructive metamorphism
+                   if (.not. use_extrasnowlayers) then
+                      ddz1 = -c3*dexpf 
+                      if (bi > dm) ddz1 = ddz1*exp(-46.0e-3_r8*(bi-dm))
+                   else
+                      ddz1_fresh = (-grav * (burden(c) + wx/2._r8)) / &
                                    (0.007_r8 * bi**(4.75_r8 + td/40._r8))
                       snw_ssa = 3.e6_r8 / (denice * snw_rds(c,j))
                       if (snw_ssa < 50._r8) then
@@ -735,12 +678,17 @@ contains
                       ddz1 = -c3_ams*dexpf
                       if (bi > rho_dm) ddz1 = ddz1*exp(-46.0e-3_r8*(bi-rho_dm))
                       ddz1 = ddz1 + ddz1_fresh
-                      ! Liquid water term
+                   endif
+
+                   ! Liquid water term
 
-                     if (h2osoi_liq(c,j) > 0.01_r8*dz(c,j)*frac_sno(c)) ddz1=ddz1*c5
+                   if (h2osoi_liq(c,j) > 0.01_r8*dz(c,j)*frac_sno(c)) ddz1=ddz1*c5
 
-                     ! Compaction due to overburden
-                     p_gls = max(denice / bi, 1._r8) * grav * (burden(fc) + wx/2._r8)
+                   ! Compaction due to overburden
+                   if (.not. use_extrasnowlayers) then
+                      ddz2 = -(burden(c)+wx/2._r8)*exp(-0.08_r8*td - c2*bi)/eta0 
+                   else
+                      p_gls = max(denice / bi, 1._r8) * grav * (burden(c) + wx/2._r8)
                       if (bi <= 550._r8) then ! Low density, i.e. snow
                          ddz2 = (-k_creep_snow * (max(denice / bi, 1._r8) - 1._r8) * &
                                  exp(-60.e6_r8 / (rgas * t_soisno(c,j))) * p_gls) / &
@@ -752,38 +700,44 @@ contains
                                  (snw_rds(c,j) * 1.e-6_r8 * snw_rds(c,j) * 1.e-6_r8) - &
                                  2.7e-11_r8
                       endif
+                   endif
+
+                   ! Compaction occurring during melt
+
+                   if (imelt(c,j) == 1) then
+                      if(subgridflag==1 .and. (ltype(col_pp%landunit(c)) == istsoil .or. ltype(col_pp%landunit(c)) == istcrop)) then
+                         ! first term is delta mass over mass
+                         ddz3 = max(0._r8,min(1._r8,(swe_old(c,j) - wx)/wx))
 
-                     ! Compaction occurring during melt
-                     if (imelt(c,j) == 1) then
-                        if(subgridflag==1 .and. (ltype(col_pp%landunit(c)) == istsoil .or. ltype(col_pp%landunit(c)) == istcrop)) then
-                           ! first term is delta mass over mass
-                           ddz3 = max(0._r8,min(1._r8,(swe_old(c,j) - wx)/wx))
-
-                           ! 2nd term is delta fsno over fsno, allowing for negative values for ddz3
-                           if ((swe_old(c,j) - wx) > 0._r8) then
-                              wsum = sum(h2osoi_liq(c,snl(c)+1:0)+h2osoi_ice(c,snl(c)+1:0))
-                              fsno_melt = 1. - (acos(2.*min(1._r8,wsum/int_snow(c)) - 1._r8)/rpi)**(n_melt(c))
-
-                              ddz3 = ddz3 - max(0._r8,(fsno_melt - frac_sno(c))/frac_sno(c))
-                           endif
-                           ddz3 = -1._r8/dtime * ddz3
-                        else
-                           ddz3 = - 1._r8/dtime * max(0._r8,(frac_iceold(c,j) - fi)/frac_iceold(c,j))
-                        endif
-                     else
-                        ddz3 = 0._r8
-                     end if
-
-                     ! Compaction occurring due to wind drift
-                     call WindDriftCompaction( &
-                     bi = bi, &
-                     forc_wind = forc_wind(t), &
-                     dz = dz(c,j), &
-                     zpseudo = zpseudo(fc), &
-                     mobile = mobile(fc), &
-                     compaction_rate = ddz4)
-
-                      ! Time rate of fractional change in dz (units of s-1)
+                         ! 2nd term is delta fsno over fsno, allowing for negative values for ddz3
+                         if ((swe_old(c,j) - wx) > 0._r8) then
+                            wsum = sum(h2osoi_liq(c,snl(c)+1:0)+h2osoi_ice(c,snl(c)+1:0))
+                            fsno_melt = 1. - (acos(2.*min(1._r8,wsum/int_snow(c)) - 1._r8)/rpi)**(n_melt(c))
+
+                            ddz3 = ddz3 - max(0._r8,(fsno_melt - frac_sno(c))/frac_sno(c))
+                         endif
+                         ddz3 = -1._r8/dtime * ddz3
+                      else
+                         ddz3 = - 1._r8/dtime * max(0._r8,(frac_iceold(c,j) - fi)/frac_iceold(c,j))
+                      endif
+                   else
+                      ddz3 = 0._r8
+                   end if
+                   
+                   if (use_extrasnowlayers) then
+                      ! Compaction occurring due to wind drift
+                      call WindDriftCompaction( &
+                           bi = bi, &
+                           forc_wind = forc_wind(t), &
+                           dz = dz(c,j), &
+                           zpseudo = zpseudo(c), &
+                           mobile = mobile(c), &
+                           compaction_rate = ddz4)
+                   else
+                      ddz4 = 0.0_r8
+                   end if
+                   
+                   ! Time rate of fractional change in dz (units of s-1)
 
                    pdzdtc = ddz1 + ddz2 + ddz3 + ddz4
 
@@ -792,123 +746,24 @@ contains
 
                    dz(c,j) = max(dz(c,j) * (1._r8+pdzdtc*dtime),(h2osoi_ice(c,j)/denice+ h2osoi_liq(c,j)/denh2o)/frac_sno(c))
                 
-               else ! from CLMv5
+                else ! from CLMv5
                    ! saturated node is immobile
                    !
                    ! This is only needed if wind_dependent_snow_density is true, but it's
                    ! simplest just to update mobile always
-                   mobile(fc) = .false.
-               end if
-
-                  ! Pressure of overlying snow
-
-                  burden(fc) = burden(fc) + wx
-               end if 
-            end do
-         end do  
-      else 
-
-         !NOTE: revisit these loops 
-         !$acc parallel loop independent gang vector default(present) private(burden_noextra)
-         do fc = 1, num_snowc
-            c = filter_snowc(fc)
-            burden_noextra = 0._r8 
-            !$acc loop seq 
-            do j = snl(c)+1, 0
-               !if (j >= ) then
-                  wx = (h2osoi_ice(c,j) + h2osoi_liq(c,j))
-                  void = 1._r8 - (h2osoi_ice(c,j)/denice + h2osoi_liq(c,j)/denh2o)&
-                       /(frac_sno(c) * dz(c,j))
-                  ! If void is negative, then increase dz such that void = 0.
-                  ! This should be done for any landunit, but for now is done only for glacier_mec 1andunits.
-                
-                  ! I don't think the next 5 lines are necessary (removed in CLMv5)
-                  l = col_pp%landunit(c)
-                  if (ltype(l)==istice_mec .and. void < 0._r8) then
-                     dz(c,j) = h2osoi_ice(c,j)/denice + h2osoi_liq(c,j)/denh2o
-                     void = 0._r8
-                  endif
-
-                  ! Allow compaction only for non-saturated node and higher ice lens node.
-                  if (void > 0.001_r8 .and. h2osoi_ice(c,j) > .1_r8) then
-
-                      bi = h2osoi_ice(c,j) / (frac_sno(c) * dz(c,j))
-                      fi = h2osoi_ice(c,j) / wx
-                      td = tfrz-t_soisno(c,j)
-                      dexpf = exp(-c4*td)
-
-                      ! Settling as a result of destructive metamorphism
-                      ddz1 = -c3*dexpf 
-                      if (bi > dm) ddz1 = ddz1*exp(-46.0e-3_r8*(bi-dm))
-
-                      ! Liquid water term
-
-                      if (h2osoi_liq(c,j) > 0.01_r8*dz(c,j)*frac_sno(c)) ddz1=ddz1*c5
-
-                      ! Compaction due to overburden
-                     ddz2 = -(burden_noextra+wx/2._r8)*exp(-0.08_r8*td - c2*bi)/eta0 
-
-                      ! Compaction occurring during melt
-
-                      if (imelt(c,j) == 1) then
-                         if(subgridflag==1 .and. (ltype(col_pp%landunit(c)) == istsoil .or. ltype(col_pp%landunit(c)) == istcrop)) then
-                            ! first term is delta mass over mass
-                            ddz3 = max(0._r8,min(1._r8,(swe_old(c,j) - wx)/wx))
-
-                            ! 2nd term is delta fsno over fsno, allowing for negative values for ddz3
-                            if ((swe_old(c,j) - wx) > 0._r8) then
-                               wsum = sum(h2osoi_liq(c,snl(c)+1:0)+h2osoi_ice(c,snl(c)+1:0))
-                               fsno_melt = 1. - (acos(2.*min(1._r8,wsum/int_snow(c)) - 1._r8)/rpi)**(n_melt(c))
-
-                               ddz3 = ddz3 - max(0._r8,(fsno_melt - frac_sno(c))/frac_sno(c))
-                            endif
-                            ddz3 = -1._r8/dtime * ddz3
-                         else
-                            ddz3 = - 1._r8/dtime * max(0._r8,(frac_iceold(c,j) - fi)/frac_iceold(c,j))
-                         endif
-                      else
-                         ddz3 = 0._r8
-                      end if
-
-                     ddz4 = 0.0_r8
-
-                     ! Time rate of fractional change in dz (units of s-1)
-                      pdzdtc = ddz1 + ddz2 + ddz3 + ddz4
-
-                      ! The change in dz due to compaction
-                      ! Limit compaction to be no greater than fully saturated layer thickness
-
-                      dz(c,j) = max(dz(c,j) * (1._r8+pdzdtc*dtime),(h2osoi_ice(c,j)/denice+ h2osoi_liq(c,j)/denh2o)/frac_sno(c))
-                  
-                  ! NOTE: This seems irrelevant unless extra snow layers is true?
-                  ! else ! from CLMv5
-                  !    ! saturated node is immobile
-                  !    !
-                  !    ! This is only needed if wind_dependent_snow_density is true, but it's
-                  !    ! simplest just to update mobile always
-                  !    mobile(fc) = .false.
-
-                  end if
-
-                  ! Pressure of overlying snow
-                  burden_noextra = burden_noextra + wx
-               !end if 
-            end do !j loop now 
-         end do  ! filter loop 
-      end if
+                   mobile(c) = .false.
+                end if
 
+                ! Pressure of overlying snow
 
+                burden(c) = burden(c) + wx
 
-     !$acc exit data delete(&
-     !$acc burden(:), &
-     !$acc zpseudo(:), &
-     !$acc mobile(:), &
-     !$acc ddz1_fresh, &
-     !$acc ddz1, &
-     !$acc ddz3, &
-     !$acc burden_noextra)
+             end if
+          end do
+       end do
 
      end associate
+
    end subroutine SnowCompaction
 
    !-----------------------------------------------------------------------
@@ -922,6 +777,7 @@ contains
      ! clm\_combo.f90 then executes the combination of mass and energy.
      !
      ! !USES:
+      !$acc routine seq
      use landunit_varcon  , only : istsoil, istdlak, istsoil, istwet, istice, istice_mec, istcrop
      use LakeCon          , only : lsadz
      use elm_varcon       , only : denh2o
@@ -937,16 +793,15 @@ contains
      integer :: c, fc                            ! column indices
      integer :: i,k                              ! loop indices
      integer :: j,l                              ! node indices
-     integer :: msn_old(1:num_snowc) ! number of top snow layer
-     integer :: mssi   (1:num_snowc)    ! node index
+     integer :: msn_old(bounds%begc:bounds%endc) ! number of top snow layer
+     integer :: mssi(bounds%begc:bounds%endc)    ! node index
      integer :: neibor                           ! adjacent node selected for combination
      real(r8):: dzminloc_mssi_c                  ! dzminloc evaluated at mssi(c)
-     real(r8):: zwice (1:num_snowc)   ! total ice mass in snow
-     real(r8):: zwliq (1:num_snowc)  ! total liquid water in snow
+     real(r8):: zwice(bounds%begc:bounds%endc)   ! total ice mass in snow
+     real(r8):: zwliq (bounds%begc:bounds%endc)  ! total liquid water in snow
      real(r8):: dzmin(5)                         ! minimum of top snow layer
      real(r8):: dzminloc(5)                ! minimum of top snow layer (local)
      real(r8):: dzminloc16(16)             ! minimum of top snow layer (local)
-     real(r8) :: sum1, sum2, sum3, sum4 
 
      data dzmin /0.010_r8, 0.015_r8, 0.025_r8, 0.055_r8, 0.115_r8/
 
@@ -975,7 +830,7 @@ contains
           h2osoi_ice       => col_ws%h2osoi_ice      , & ! Output: [real(r8) (:,:) ] ice lens (kg/m2)
           h2osoi_liq       => col_ws%h2osoi_liq      , & ! Output: [real(r8) (:,:) ] liquid water (kg/m2)
           snw_rds          => col_ws%snw_rds         , & ! Output: [real(r8) (:,:) ] effective snow grain radius (col,lyr) [microns, m^-6]
-          mflx_snowlyr_col => col_wf%mflx_snowlyr    , & ! Output: [real(r8) (:)   ]  mass flux to top soil layer due to disappearance of snow (kg H2O /s)
+          mflx_snowlyr_col => col_wf%mflx_snowlyr     , & ! Output: [real(r8) (:)   ]  mass flux to top soil layer due to disappearance of snow (kg H2O /s)
 
           qflx_sl_top_soil => col_wf%qflx_sl_top_soil , & ! Output: [real(r8) (:)   ] liquid water + ice from layer above soil to top soil layer or sent to qflx_qrgwl (mm H2O/s)
           qflx_snow2topsoi => col_wf%qflx_snow2topsoi , & ! Output: [real(r8) (:)   ] liquid water merged into top soil from snow
@@ -985,19 +840,10 @@ contains
           zi               => col_pp%zi                              , & ! Output: [real(r8) (:,:) ] interface level below a "z" level (m)
           z                => col_pp%z                                 & ! Output: [real(r8) (:,:) ] layer thickness (m)
           )
-     !$acc enter data create(&
-     !$acc msn_old(:) , &
-     !$acc mssi(:)    , &
-     !$acc zwice(:)   , &
-     !$acc zwliq(:)   , &
-     !$acc dzmin(:)   , &
-     !$acc dzminloc(:), &
-     !$acc dzminloc16(:), &
-     !$acc sum1, sum2, sum3, sum4)
+
 
        ! Check the mass of ice lens of snow, when the total is less than a small value,
        ! combine it with the underlying neighbor.
-       
 
        ! dzmin will stay constant between timesteps
        if (.not. use_extrasnowlayers) then
@@ -1021,23 +867,21 @@ contains
           end if
        end if
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_snowc
           c = filter_snowc(fc)
 
-          msn_old(fc) = snl(c)
+          msn_old(c) = snl(c)
           qflx_sl_top_soil(c) = 0._r8
           qflx_snow2topsoi(c) = 0._r8
           mflx_snowlyr_col(c) = 0._r8
        end do
 
        ! The following loop is NOT VECTORIZED
-       !$acc parallel loop independent gang vector default(present)
+
        do fc = 1, num_snowc
           c = filter_snowc(fc)
           l = col_pp%landunit(c)
-          !$acc loop seq
-          do j = msn_old(fc)+1,0
+          do j = msn_old(c)+1,0
              ! use 0.01 to avoid runaway ice buildup
              if (h2osoi_ice(c,j) <= .01_r8) then
                 if (ltype(l) == istsoil .or. urbpoi(l) .or. ltype(l) == istcrop) then
@@ -1086,7 +930,6 @@ contains
 
                 ! shift all elements above this down one.
                 if (j > snl(c)+1 .and. snl(c) < -1) then
-                  !$acc loop seq 
                    do i = j, snl(c)+2, -1
                       ! If the layer closest to the surface is less than 0.1 mm and the ltype is not
                       ! urban, soil or crop, the h2osoi_liq and h2osoi_ice associated with this layer is sent
@@ -1117,30 +960,29 @@ contains
           end do
        end do
 
-       !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3,sum4)
        do fc = 1, num_snowc
-         c = filter_snowc(fc)
-         sum1 = 0._r8; sum2 = 0._r8; 
-         sum3 = 0._r8; sum4 = 0._r8;
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4)
-         do j = -nlevsno+1,0
+          c = filter_snowc(fc)
+          h2osno(c) = 0._r8
+          snow_depth(c) = 0._r8
+          zwice(c)  = 0._r8
+          zwliq(c)  = 0._r8
+       end do
+
+       do j = -nlevsno+1,0
+          do fc = 1, num_snowc
+             c = filter_snowc(fc)
              if (j >= snl(c)+1) then
-                sum1 = sum1 + h2osoi_ice(c,j) + h2osoi_liq(c,j)
-                sum2 = sum2 + dz(c,j)
-                sum3 = sum3 + h2osoi_ice(c,j)
-                sum4 = sum4 + h2osoi_liq(c,j)
+                h2osno(c) = h2osno(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)
+                snow_depth(c) = snow_depth(c) + dz(c,j)
+                zwice(c)  = zwice(c) + h2osoi_ice(c,j)
+                zwliq(c)  = zwliq(c) + h2osoi_liq(c,j)
              end if
-         end do
-         h2osno(c) = sum1 
-         snow_depth(c) = sum2
-         zwice(fc)  = sum3 
-         zwliq(fc) = sum4  
+          end do
        end do
 
        ! Check the snow depth - all snow gone
        ! The liquid water assumes ponding on soil surface.
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_snowc
           c = filter_snowc(fc)
           l = col_pp%landunit(c)
@@ -1150,7 +992,7 @@ contains
                   .or. (h2osno(c)/(frac_sno_eff(c)*snow_depth(c)) < 50._r8)))) then
 
                 snl(c) = 0
-                h2osno(c) = zwice(fc)
+                h2osno(c) = zwice(c)
 
                 mss_bcphi(c,:) = 0._r8
                 mss_bcpho(c,:) = 0._r8
@@ -1165,9 +1007,9 @@ contains
                 ! this is where water is transfered from layer 0 (snow) to layer 1 (soil)
                 if (ltype(l) == istsoil .or. urbpoi(l) .or. ltype(l) == istcrop) then
                    h2osoi_liq(c,0) = 0.0_r8
-                   h2osoi_liq(c,1) = h2osoi_liq(c,1) + zwliq(fc)
-                   qflx_snow2topsoi(c) = zwliq(fc)/dtime
-                   mflx_snowlyr_col(c) = mflx_snowlyr_col(c) + zwliq(fc)/dtime
+                   h2osoi_liq(c,1) = h2osoi_liq(c,1) + zwliq(c)
+                   qflx_snow2topsoi(c) = zwliq(c)/dtime
+                   mflx_snowlyr_col(c) = mflx_snowlyr_col(c) + zwliq(c)/dtime
                 end if
                 if (ltype(l) == istwet) then
                    h2osoi_liq(c,0) = 0.0_r8
@@ -1195,14 +1037,14 @@ contains
 
           if (snl(c) < -1) then
 
-             msn_old(fc) = snl(c)
-             mssi(fc) = 1
+             msn_old(c) = snl(c)
+             mssi(c) = 1
 
-             do i = msn_old(fc)+1,0
+             do i = msn_old(c)+1,0
                 if (.not. use_extrasnowlayers) then
-                    dzminloc_mssi_c = dzminloc(mssi(fc))
+                    dzminloc_mssi_c = dzminloc(mssi(c))
                 else
-                    dzminloc_mssi_c = dzminloc16(mssi(fc))
+                    dzminloc_mssi_c = dzminloc16(mssi(c))
                 end if
                 if ((frac_sno_eff(c)*dz(c,i) < dzminloc_mssi_c) .or. &
                      ((h2osoi_ice(c,i) + h2osoi_liq(c,i))/(frac_sno_eff(c)*dz(c,i)) < 50._r8)) then
@@ -1276,7 +1118,7 @@ contains
                 else
 
                    ! The layer thickness is greater than the prescribed minimum value
-                   mssi(fc) = mssi(fc) + 1
+                   mssi(c) = mssi(c) + 1
 
                 end if
              end do
@@ -1286,48 +1128,18 @@ contains
        end do
 
        ! Reset the node depth and the depth of layer interface
-       !NOTE: racecondition? Testing out two loop structure:
-       !$acc parallel default(present) 
-      !$acc loop independent gang vector 
-      do fc = 1, num_snowc
-         c = filter_snowc(fc)
-         !NOTE: can replace the loop bounds with [0,snl(c)+1] here now? 
-         !$acc loop seq 
-         do j = 0, -nlevsno+1, -1 
-            if(j >= snl(c) + 1) then 
-               zi(c,j-1) = zi(c,j) - dz(c,j)
-            end if 
-         end do 
-      end do 
-             
-      !$acc loop independent gang vector collapse(2) 
-      do j = 0, -nlevsno+1, -1
-         do fc = 1, num_snowc
-            c = filter_snowc(fc)
-            if (j >= snl(c) + 1) then
-               z(c,j) = zi(c,j) - 0.5_r8*dz(c,j)
-            end if
-         end do
-      end do
-       !$acc end parallel 
-    
-
 
-     !$acc exit data delete(&
-     !$acc msn_old(:), &
-     !$acc mssi(:), &
-     !$acc zwice(:), &
-     !$acc zwliq(:), &
-     !$acc dzmin(:), &
-     !$acc dzminloc(:), &
-     !$acc dzminloc16(:), &
-     !$acc sum1, &
-     !$acc sum2, &
-     !$acc sum3, &
-     !$acc sum4)
+       do j = 0, -nlevsno+1, -1
+          do fc = 1, num_snowc
+             c = filter_snowc(fc)
+             if (j >= snl(c) + 1) then
+                z(c,j) = zi(c,j) - 0.5_r8*dz(c,j)
+                zi(c,j-1) = zi(c,j) - dz(c,j)
+             end if
+          end do
+       end do
 
     end associate
-
    end subroutine CombineSnowLayers
 
    !-----------------------------------------------------------------------
@@ -1338,6 +1150,7 @@ contains
      ! Subdivides snow layers if they exceed their prescribed maximum thickness.
      !
      ! !USES:
+      !$acc routine seq
      use elm_varcon,  only : tfrz
      use LakeCon   ,  only : lsadz
      !
@@ -1349,42 +1162,40 @@ contains
      logical                , intent(in)    :: is_lake  !TODO - this should be examined and removed in the future
      !
      ! !LOCAL VARIABLES:
-     integer  :: j, c, fc, k                  ! indices
-     real(r8) :: drr                          ! thickness of the combined [m]
-     integer  :: msno                         ! number of snow layer 1 (top) to msno (bottom)
-     real(r8) :: dzsno(1:num_snowc,nlevsno)   ! Snow layer thickness [m]
-     real(r8) :: swice(1:num_snowc,nlevsno)   ! Partial volume of ice [m3/m3]
-     real(r8) :: swliq(1:num_snowc,nlevsno)   ! Partial volume of liquid water [m3/m3]
-     real(r8) :: tsno(1:num_snowc ,nlevsno)   ! Nodel temperature [K]
-     real(r8) :: zwice                        ! temporary
-     real(r8) :: zwliq                        ! temporary
-     real(r8) :: propor                       ! temporary
-     real(r8) :: dtdz                         ! temporary
+     integer  :: j, c, fc, k                              ! indices
+     real(r8) :: drr                                      ! thickness of the combined [m]
+     integer  :: msno                                     ! number of snow layer 1 (top) to msno (bottom)
+     real(r8) :: dzsno(bounds%begc:bounds%endc,nlevsno)   ! Snow layer thickness [m]
+     real(r8) :: swice(bounds%begc:bounds%endc,nlevsno)   ! Partial volume of ice [m3/m3]
+     real(r8) :: swliq(bounds%begc:bounds%endc,nlevsno)   ! Partial volume of liquid water [m3/m3]
+     real(r8) :: tsno(bounds%begc:bounds%endc ,nlevsno)   ! Nodel temperature [K]
+     real(r8) :: zwice                                    ! temporary
+     real(r8) :: zwliq                                    ! temporary
+     real(r8) :: propor                                   ! temporary
+     real(r8) :: dtdz                                     ! temporary
      ! temporary variables mimicking the structure of other layer division variables
-     real(r8) :: mbc_phi(1:num_snowc,nlevsno) ! mass of BC in each snow layer
-     real(r8) :: zmbc_phi                     ! temporary
-     real(r8) :: mbc_pho(1:num_snowc,nlevsno) ! mass of BC in each snow layer
-     real(r8) :: zmbc_pho                     ! temporary
-     real(r8) :: moc_phi(1:num_snowc,nlevsno) ! mass of OC in each snow layer
-     real(r8) :: zmoc_phi                     ! temporary
-     real(r8) :: moc_pho(1:num_snowc,nlevsno) ! mass of OC in each snow layer
-     real(r8) :: zmoc_pho                     ! temporary
-     real(r8) :: mdst1(1:num_snowc,nlevsno)   ! mass of dust 1 in each snow layer
-     real(r8) :: zmdst1                       ! temporary
-     real(r8) :: mdst2(1:num_snowc,nlevsno)   ! mass of dust 2 in each snow layer
-     real(r8) :: zmdst2                       ! temporary
-     real(r8) :: mdst3(1:num_snowc,nlevsno)   ! mass of dust 3 in each snow layer
-     real(r8) :: zmdst3                       ! temporary
-     real(r8) :: mdst4(1:num_snowc,nlevsno)   ! mass of dust 4 in each snow layer
-     real(r8) :: zmdst4                       ! temporary
-     real(r8) :: rds(1:num_snowc,nlevsno)
+     real(r8) :: mbc_phi(bounds%begc:bounds%endc,nlevsno) ! mass of BC in each snow layer
+     real(r8) :: zmbc_phi                                 ! temporary
+     real(r8) :: mbc_pho(bounds%begc:bounds%endc,nlevsno) ! mass of BC in each snow layer
+     real(r8) :: zmbc_pho                                 ! temporary
+     real(r8) :: moc_phi(bounds%begc:bounds%endc,nlevsno) ! mass of OC in each snow layer
+     real(r8) :: zmoc_phi                                 ! temporary
+     real(r8) :: moc_pho(bounds%begc:bounds%endc,nlevsno) ! mass of OC in each snow layer
+     real(r8) :: zmoc_pho                                 ! temporary
+     real(r8) :: mdst1(bounds%begc:bounds%endc,nlevsno)   ! mass of dust 1 in each snow layer
+     real(r8) :: zmdst1                                   ! temporary
+     real(r8) :: mdst2(bounds%begc:bounds%endc,nlevsno)   ! mass of dust 2 in each snow layer
+     real(r8) :: zmdst2                                   ! temporary
+     real(r8) :: mdst3(bounds%begc:bounds%endc,nlevsno)   ! mass of dust 3 in each snow layer
+     real(r8) :: zmdst3                                   ! temporary
+     real(r8) :: mdst4(bounds%begc:bounds%endc,nlevsno)   ! mass of dust 4 in each snow layer
+     real(r8) :: zmdst4                                   ! temporary
+     real(r8) :: rds(bounds%begc:bounds%endc,nlevsno)
      ! Variables for consistency check
-     real(r8) :: dztot(1:num_snowc)
-     real(r8) :: snwicetot(1:num_snowc)
-     real(r8) :: snwliqtot(1:num_snowc)
+     real(r8) :: dztot(bounds%begc:bounds%endc)
+     real(r8) :: snwicetot(bounds%begc:bounds%endc)
+     real(r8) :: snwliqtot(bounds%begc:bounds%endc)
      real(r8) :: offset ! temporary
-     real(r8) :: sum1, sum2, sum3 
-     integer :: snl_idx
      !-----------------------------------------------------------------------
 
      associate(                                            &
@@ -1395,96 +1206,71 @@ contains
           frac_sno   => col_ws%frac_sno_eff , & ! Output: [real(r8) (:)   ] fraction of ground covered by snow (0 to 1)
           snw_rds    => col_ws%snw_rds      , & ! Output: [real(r8) (:,:) ] effective snow grain radius (col,lyr) [microns, m^-6]
 
-          mss_bcphi  => aerosol_vars%mss_bcphi_col  , & ! Output: [real(r8) (:,:) ] hydrophilic BC mass in snow (col,lyr) [kg]
-          mss_bcpho  => aerosol_vars%mss_bcpho_col  , & ! Output: [real(r8) (:,:) ] hydrophobic BC mass in snow (col,lyr) [kg]
-          mss_ocphi  => aerosol_vars%mss_ocphi_col  , & ! Output: [real(r8) (:,:) ] hydrophilic OC mass in snow (col,lyr) [kg]
-          mss_ocpho  => aerosol_vars%mss_ocpho_col  , & ! Output: [real(r8) (:,:) ] hydrophobic OC mass in snow (col,lyr) [kg]
-          mss_dst1   => aerosol_vars%mss_dst1_col   , & ! Output: [real(r8) (:,:) ] dust species 1 mass in snow (col,lyr) [kg]
-          mss_dst2   => aerosol_vars%mss_dst2_col   , & ! Output: [real(r8) (:,:) ] dust species 2 mass in snow (col,lyr) [kg]
-          mss_dst3   => aerosol_vars%mss_dst3_col   , & ! Output: [real(r8) (:,:) ] dust species 3 mass in snow (col,lyr) [kg]
-          mss_dst4   => aerosol_vars%mss_dst4_col   , & ! Output: [real(r8) (:,:) ] dust species 4 mass in snow (col,lyr) [kg]
-
-          snl        => col_pp%snl                  , & ! Output: [integer  (:)   ] number of snow layers
-          dz         => col_pp%dz                   , & ! Output: [real(r8) (:,:) ] layer depth (m)
-          zi         => col_pp%zi                   , & ! Output: [real(r8) (:,:) ] interface level below a "z" level (m)
-          z          => col_pp%z                      & ! Output: [real(r8) (:,:) ] layer thickness (m)
+          mss_bcphi  => aerosol_vars%mss_bcphi_col       , & ! Output: [real(r8) (:,:) ] hydrophilic BC mass in snow (col,lyr) [kg]
+          mss_bcpho  => aerosol_vars%mss_bcpho_col       , & ! Output: [real(r8) (:,:) ] hydrophobic BC mass in snow (col,lyr) [kg]
+          mss_ocphi  => aerosol_vars%mss_ocphi_col       , & ! Output: [real(r8) (:,:) ] hydrophilic OC mass in snow (col,lyr) [kg]
+          mss_ocpho  => aerosol_vars%mss_ocpho_col       , & ! Output: [real(r8) (:,:) ] hydrophobic OC mass in snow (col,lyr) [kg]
+          mss_dst1   => aerosol_vars%mss_dst1_col        , & ! Output: [real(r8) (:,:) ] dust species 1 mass in snow (col,lyr) [kg]
+          mss_dst2   => aerosol_vars%mss_dst2_col        , & ! Output: [real(r8) (:,:) ] dust species 2 mass in snow (col,lyr) [kg]
+          mss_dst3   => aerosol_vars%mss_dst3_col        , & ! Output: [real(r8) (:,:) ] dust species 3 mass in snow (col,lyr) [kg]
+          mss_dst4   => aerosol_vars%mss_dst4_col        , & ! Output: [real(r8) (:,:) ] dust species 4 mass in snow (col,lyr) [kg]
+
+          snl        => col_pp%snl                          , & ! Output: [integer  (:)   ] number of snow layers
+          dz         => col_pp%dz                           , & ! Output: [real(r8) (:,:) ] layer depth (m)
+          zi         => col_pp%zi                           , & ! Output: [real(r8) (:,:) ] interface level below a "z" level (m)
+          z          => col_pp%z                              & ! Output: [real(r8) (:,:) ] layer thickness (m)
           )
-     !$acc enter data create(&
-     !$acc dzsno(:,:), &
-     !$acc swice(:,:), &
-     !$acc swliq(:,:), &
-     !$acc tsno(:,:), &
-     !$acc mbc_phi(:,:), &
-     !$acc mbc_pho(:,:), &
-     !$acc moc_phi(:,:), &
-     !$acc moc_pho(:,:), &
-     !$acc mdst1(:,:), &
-     !$acc mdst2(:,:), &
-     !$acc mdst3(:,:), &
-     !$acc mdst4(:,:), &
-     !$acc rds(:,:), &
-     !$acc dztot(:), &
-     !$acc snwicetot(:), &
-     !$acc snwliqtot(:), &
-     !$acc sum1, &
-     !$acc sum2, &
-     !$acc sum3)
 
        if ( is_lake ) then
           ! Initialize for consistency check
-         !$acc parallel loop independent gang vector default(present) private(sum1,sum2,sum3)
-         do fc = 1, num_snowc
-            c = filter_snowc(fc)
-            sum1 = 0._r8; sum2 = 0._r8; sum3 =0._r8  
-            !$acc loop vector reduction(+:sum1,sum2,sum3)
-            do j = -nlevsno+1,0
+          do j = -nlevsno+1,0
+             do fc = 1, num_snowc
+                c = filter_snowc(fc)
+
+                if (j == -nlevsno+1) then
+                   dztot(c) = 0._r8
+                   snwicetot(c) = 0._r8
+                   snwliqtot(c) = 0._r8
+                end if
+
                 if (j >= snl(c)+1) then
-                   sum1 = sum1 + dz(c,j)
-                   sum2 = sum2 + h2osoi_ice(c,j)
-                   sum3 = sum3 + h2osoi_liq(c,j)
+                   dztot(c) = dztot(c) + dz(c,j)
+                   snwicetot(c) = snwicetot(c) + h2osoi_ice(c,j)
+                   snwliqtot(c) = snwliqtot(c) + h2osoi_liq(c,j)
                 end if
              end do
-             dztot(fc)    = sum1  
-            snwicetot(fc) = sum2 
-            snwliqtot(fc) = sum3
           end do
        end if
 
        ! Begin calculation - note that the following column loops are only invoked
        ! for snow-covered columns
 
-       !$acc parallel loop independent gang vector default(present) collapse(2) 
-       !!!$acc present(mss_bcphi(:,:),mss_bcpho(:,:),mss_ocphi(:,:),mss_ocpho(:,:) &
-       !!!$acc ,mss_dst1(:,:),mss_dst2(:,:),mss_dst3(:,:),mss_dst4(:,:) ,snw_rds(:,:), &
-       !!!$acc  h2osoi_ice(:,:),h2osoi_liq(:,:), t_soisno(:,:),dz(:,:),snl(:))
        do j = 1,nlevsno
           do fc = 1, num_snowc
              c = filter_snowc(fc)
-             snl_idx = j+snl(c)
              if (j <= abs(snl(c))) then
                 if (is_lake) then
-                   dzsno(fc,j) = dz(c,snl_idx)
+                   dzsno(c,j) = dz(c,j+snl(c))
                 else
-                   dzsno(fc,j) = frac_sno(c)*dz(c,snl_idx)
+                   dzsno(c,j) = frac_sno(c)*dz(c,j+snl(c))
                 end if
-                swice(fc,j) = h2osoi_ice(c,snl_idx)
-                swliq(fc,j) = h2osoi_liq(c,snl_idx)
-                tsno (fc,j) = t_soisno(c,snl_idx)
-
-                mbc_phi(fc,j) = mss_bcphi(c,snl_idx)
-                mbc_pho(fc,j) = mss_bcpho(c,snl_idx)
-                moc_phi(fc,j) = mss_ocphi(c,snl_idx)
-                moc_pho(fc,j) = mss_ocpho(c,snl_idx)
-                mdst1(fc,j)   = mss_dst1(c,snl_idx)
-                mdst2(fc,j)   = mss_dst2(c,snl_idx)
-                mdst3(fc,j)   = mss_dst3(c,snl_idx)
-                mdst4(fc,j)   = mss_dst4(c,snl_idx)
-                rds(fc,j)     = snw_rds(c,snl_idx)
+                swice(c,j) = h2osoi_ice(c,j+snl(c))
+                swliq(c,j) = h2osoi_liq(c,j+snl(c))
+                tsno(c,j)  = t_soisno(c,j+snl(c))
+
+                mbc_phi(c,j) = mss_bcphi(c,j+snl(c))
+                mbc_pho(c,j) = mss_bcpho(c,j+snl(c))
+                moc_phi(c,j) = mss_ocphi(c,j+snl(c))
+                moc_pho(c,j) = mss_ocpho(c,j+snl(c))
+                mdst1(c,j)   = mss_dst1(c,j+snl(c))
+                mdst2(c,j)   = mss_dst2(c,j+snl(c))
+                mdst3(c,j)   = mss_dst3(c,j+snl(c))
+                mdst4(c,j)   = mss_dst4(c,j+snl(c))
+                rds(c,j)     = snw_rds(c,j+snl(c))
              end if
           end do
        end do
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_snowc
            c = filter_snowc(fc)
 
@@ -1497,33 +1283,33 @@ contains
               else
                  offset = 0._r8
               end if
-              if (dzsno(fc,1) > 0.03_r8 + offset) then
+              if (dzsno(c,1) > 0.03_r8 + offset) then
                  msno = 2
-                 dzsno(fc,1) = dzsno(fc,1)/2._r8
-                 swice(fc,1) = swice(fc,1)/2._r8
-                 swliq(fc,1) = swliq(fc,1)/2._r8
-                 dzsno(fc,2) = dzsno(fc,1)
-                 swice(fc,2) = swice(fc,1)
-                 swliq(fc,2) = swliq(fc,1)
-                 tsno(fc,2)  = tsno(fc,1)
-
-                 mbc_phi(fc,1) = mbc_phi(fc,1)/2._r8
-                 mbc_phi(fc,2) = mbc_phi(fc,1)
-                 mbc_pho(fc,1) = mbc_pho(fc,1)/2._r8
-                 mbc_pho(fc,2) = mbc_pho(fc,1)
-                 moc_phi(fc,1) = moc_phi(fc,1)/2._r8
-                 moc_phi(fc,2) = moc_phi(fc,1)
-                 moc_pho(fc,1) = moc_pho(fc,1)/2._r8
-                 moc_pho(fc,2) = moc_pho(fc,1)
-                 mdst1(fc,1) = mdst1(fc,1)/2._r8
-                 mdst1(fc,2) = mdst1(fc,1)
-                 mdst2(fc,1) = mdst2(fc,1)/2._r8
-                 mdst2(fc,2) = mdst2(fc,1)
-                 mdst3(fc,1) = mdst3(fc,1)/2._r8
-                 mdst3(fc,2) = mdst3(fc,1)
-                 mdst4(fc,1) = mdst4(fc,1)/2._r8
-                 mdst4(fc,2) = mdst4(fc,1)
-                 rds(fc,2) = rds(fc,1)
+                 dzsno(c,1) = dzsno(c,1)/2._r8
+                 swice(c,1) = swice(c,1)/2._r8
+                 swliq(c,1) = swliq(c,1)/2._r8
+                 dzsno(c,2) = dzsno(c,1)
+                 swice(c,2) = swice(c,1)
+                 swliq(c,2) = swliq(c,1)
+                 tsno(c,2)  = tsno(c,1)
+
+                 mbc_phi(c,1) = mbc_phi(c,1)/2._r8
+                 mbc_phi(c,2) = mbc_phi(c,1)
+                 mbc_pho(c,1) = mbc_pho(c,1)/2._r8
+                 mbc_pho(c,2) = mbc_pho(c,1)
+                 moc_phi(c,1) = moc_phi(c,1)/2._r8
+                 moc_phi(c,2) = moc_phi(c,1)
+                 moc_pho(c,1) = moc_pho(c,1)/2._r8
+                 moc_pho(c,2) = moc_pho(c,1)
+                 mdst1(c,1) = mdst1(c,1)/2._r8
+                 mdst1(c,2) = mdst1(c,1)
+                 mdst2(c,1) = mdst2(c,1)/2._r8
+                 mdst2(c,2) = mdst2(c,1)
+                 mdst3(c,1) = mdst3(c,1)/2._r8
+                 mdst3(c,2) = mdst3(c,1)
+                 mdst4(c,1) = mdst4(c,1)/2._r8
+                 mdst4(c,2) = mdst4(c,1)
+                 rds(c,2) = rds(c,1)
 
               end if
            end if
@@ -1534,74 +1320,72 @@ contains
               else
                  offset = 0._r8
               end if
-              if (dzsno(fc,1) > 0.02_r8 + offset) then
+              if (dzsno(c,1) > 0.02_r8 + offset) then
                  if (is_lake) then
-                    drr = dzsno(fc,1) - 0.02_r8 - lsadz
+                    drr = dzsno(c,1) - 0.02_r8 - lsadz
                  else
-                    drr = dzsno(fc,1) - 0.02_r8
+                    drr = dzsno(c,1) - 0.02_r8
                  end if
-                 propor = drr/dzsno(fc,1)
-                 zwice = propor*swice(fc,1)
-                 zwliq = propor*swliq(fc,1)
-
-                 zmbc_phi = propor*mbc_phi(fc,1)
-                 zmbc_pho = propor*mbc_pho(fc,1)
-                 zmoc_phi = propor*moc_phi(fc,1)
-                 zmoc_pho = propor*moc_pho(fc,1)
-                 zmdst1 = propor*mdst1(fc,1)
-                 zmdst2 = propor*mdst2(fc,1)
-                 zmdst3 = propor*mdst3(fc,1)
-                 zmdst4 = propor*mdst4(fc,1)
+                 propor = drr/dzsno(c,1)
+                 zwice = propor*swice(c,1)
+                 zwliq = propor*swliq(c,1)
+
+                 zmbc_phi = propor*mbc_phi(c,1)
+                 zmbc_pho = propor*mbc_pho(c,1)
+                 zmoc_phi = propor*moc_phi(c,1)
+                 zmoc_pho = propor*moc_pho(c,1)
+                 zmdst1 = propor*mdst1(c,1)
+                 zmdst2 = propor*mdst2(c,1)
+                 zmdst3 = propor*mdst3(c,1)
+                 zmdst4 = propor*mdst4(c,1)
 
                  if (is_lake) then
-                    propor = (0.02_r8+lsadz)/dzsno(fc,1)
+                    propor = (0.02_r8+lsadz)/dzsno(c,1)
                  else
-                    propor = 0.02_r8/dzsno(fc,1)
+                    propor = 0.02_r8/dzsno(c,1)
                  endif 
 
-                 swice(fc,1) = propor*swice(fc,1)
-                 swliq(fc,1) = propor*swliq(fc,1)
+                 swice(c,1) = propor*swice(c,1)
+                 swliq(c,1) = propor*swliq(c,1)
 
-                 mbc_phi(fc,1) = propor*mbc_phi(fc,1)
-                 mbc_pho(fc,1) = propor*mbc_pho(fc,1)
-                 moc_phi(fc,1) = propor*moc_phi(fc,1)
-                 moc_pho(fc,1) = propor*moc_pho(fc,1)
-                 mdst1(fc,1) = propor*mdst1(fc,1)
-                 mdst2(fc,1) = propor*mdst2(fc,1)
-                 mdst3(fc,1) = propor*mdst3(fc,1)
-                 mdst4(fc,1) = propor*mdst4(fc,1)
+                 mbc_phi(c,1) = propor*mbc_phi(c,1)
+                 mbc_pho(c,1) = propor*mbc_pho(c,1)
+                 moc_phi(c,1) = propor*moc_phi(c,1)
+                 moc_pho(c,1) = propor*moc_pho(c,1)
+                 mdst1(c,1) = propor*mdst1(c,1)
+                 mdst2(c,1) = propor*mdst2(c,1)
+                 mdst3(c,1) = propor*mdst3(c,1)
+                 mdst4(c,1) = propor*mdst4(c,1)
 
                  if (is_lake) then
-                    dzsno(fc,1) = 0.02_r8 + lsadz
+                    dzsno(c,1) = 0.02_r8 + lsadz
                  else
-                    dzsno(fc,1) = 0.02_r8
+                    dzsno(c,1) = 0.02_r8
                  end if
 
-                 mbc_phi(fc,2) = mbc_phi(fc,2)+zmbc_phi  ! (combo)
-                 mbc_pho(fc,2) = mbc_pho(fc,2)+zmbc_pho  ! (combo)
-                 moc_phi(fc,2) = moc_phi(fc,2)+zmoc_phi  ! (combo)
-                 moc_pho(fc,2) = moc_pho(fc,2)+zmoc_pho  ! (combo)
-                 mdst1(fc,2) = mdst1(fc,2)+zmdst1  ! (combo)
-                 mdst2(fc,2) = mdst2(fc,2)+zmdst2  ! (combo)
-                 mdst3(fc,2) = mdst3(fc,2)+zmdst3  ! (combo)
-                 mdst4(fc,2) = mdst4(fc,2)+zmdst4  ! (combo)
+                 mbc_phi(c,2) = mbc_phi(c,2)+zmbc_phi  ! (combo)
+                 mbc_pho(c,2) = mbc_pho(c,2)+zmbc_pho  ! (combo)
+                 moc_phi(c,2) = moc_phi(c,2)+zmoc_phi  ! (combo)
+                 moc_pho(c,2) = moc_pho(c,2)+zmoc_pho  ! (combo)
+                 mdst1(c,2) = mdst1(c,2)+zmdst1  ! (combo)
+                 mdst2(c,2) = mdst2(c,2)+zmdst2  ! (combo)
+                 mdst3(c,2) = mdst3(c,2)+zmdst3  ! (combo)
+                 mdst4(c,2) = mdst4(c,2)+zmdst4  ! (combo)
 #ifdef MODAL_AER
               !mgf++ bugfix
-              rds(fc,2) = (rds(fc,2)*(swliq(fc,2)+swice(fc,2)) + rds(fc,1)*(zwliq+zwice))/(swliq(fc,2)+swice(fc,2)+zwliq+zwice)
-                if ((rds(fc,2) < 30.) .or. (rds(fc,2) > 1500.)) then
-                   write (iulog,*) "2. SNICAR ERROR: snow grain radius of",rds(fc,2),rds(fc,1)
-                   write (iulog,*) "swliq, swice, zwliq, zwice", swliq(fc,2), swice(fc,2),zwliq, zwice
-                   write (iulog,*) "propor: ", propor
-                   write (iulog,*) "dzsno : ", dzsno(fc,1)
+              rds(c,2) = (rds(c,2)*(swliq(c,2)+swice(c,2)) + rds(c,1)*(zwliq+zwice))/(swliq(c,2)+swice(c,2)+zwliq+zwice)
+                if ((rds(c,2) < 30.) .or. (rds(c,2) > 1500.)) then
+                   write (iulog,*) "2. SNICAR ERROR: snow grain radius of",rds(c,2),rds(c,1)
+                   write (iulog,*) "swliq, swice, zwliq, zwice", swliq(c,2), swice(c,2),zwliq, zwice
                    write (iulog,*) "layers ", msno
                 endif
               !mgf--
 #else
-              rds(fc,2) = rds(fc,1) ! (combo)
+              rds(c,2) = rds(c,1) ! (combo)
 #endif
 
-                 call Combo (dzsno(fc,2), swliq(fc,2), swice(fc,2), tsno(fc,2), drr, &
-                      zwliq, zwice, tsno(fc,1))
+                 call Combo (dzsno(c,2), swliq(c,2), swice(c,2), tsno(c,2), drr, &
+                      zwliq, zwice, tsno(c,1))
 
                  ! Subdivide a new layer
                  if (is_lake) then
@@ -1609,39 +1393,39 @@ contains
                  else
                     offset = 0._r8
                  end if
-                 if (msno <= 2 .and. dzsno(fc,2) > 0.07_r8 + offset) then
+                 if (msno <= 2 .and. dzsno(c,2) > 0.07_r8 + offset) then
                     msno = 3
-                    dtdz = (tsno(fc,1) - tsno(fc,2))/((dzsno(fc,1)+dzsno(fc,2))/2._r8) 
-                    dzsno(fc,2) = dzsno(fc,2)/2._r8
-                    swice(fc,2) = swice(fc,2)/2._r8
-                    swliq(fc,2) = swliq(fc,2)/2._r8
-                    dzsno(fc,3) = dzsno(fc,2)
-                    swice(fc,3) = swice(fc,2)
-                    swliq(fc,3) = swliq(fc,2)
-                    tsno(fc,3) = tsno(fc,2) - dtdz*dzsno(fc,2)/2._r8
-                    if (tsno(fc,3) >= tfrz) then 
-                       tsno(fc,3)  = tsno(fc,2)
+                    dtdz = (tsno(c,1) - tsno(c,2))/((dzsno(c,1)+dzsno(c,2))/2._r8) 
+                    dzsno(c,2) = dzsno(c,2)/2._r8
+                    swice(c,2) = swice(c,2)/2._r8
+                    swliq(c,2) = swliq(c,2)/2._r8
+                    dzsno(c,3) = dzsno(c,2)
+                    swice(c,3) = swice(c,2)
+                    swliq(c,3) = swliq(c,2)
+                    tsno(c,3) = tsno(c,2) - dtdz*dzsno(c,2)/2._r8
+                    if (tsno(c,3) >= tfrz) then 
+                       tsno(c,3)  = tsno(c,2)
                     else
-                       tsno(fc,2) = tsno(fc,2) + dtdz*dzsno(fc,2)/2._r8 
+                       tsno(c,2) = tsno(c,2) + dtdz*dzsno(c,2)/2._r8 
                     endif
 
-                    mbc_phi(fc,2) = mbc_phi(fc,2)/2._r8
-                    mbc_phi(fc,3) = mbc_phi(fc,2)
-                    mbc_pho(fc,2) = mbc_pho(fc,2)/2._r8
-                    mbc_pho(fc,3) = mbc_pho(fc,2)
-                    moc_phi(fc,2) = moc_phi(fc,2)/2._r8
-                    moc_phi(fc,3) = moc_phi(fc,2)
-                    moc_pho(fc,2) = moc_pho(fc,2)/2._r8
-                    moc_pho(fc,3) = moc_pho(fc,2)
-                    mdst1(fc,2) = mdst1(fc,2)/2._r8
-                    mdst1(fc,3) = mdst1(fc,2)
-                    mdst2(fc,2) = mdst2(fc,2)/2._r8
-                    mdst2(fc,3) = mdst2(fc,2)
-                    mdst3(fc,2) = mdst3(fc,2)/2._r8
-                    mdst3(fc,3) = mdst3(fc,2)
-                    mdst4(fc,2) = mdst4(fc,2)/2._r8
-                    mdst4(fc,3) = mdst4(fc,2)
-                    rds(fc,3) = rds(fc,2)
+                    mbc_phi(c,2) = mbc_phi(c,2)/2._r8
+                    mbc_phi(c,3) = mbc_phi(c,2)
+                    mbc_pho(c,2) = mbc_pho(c,2)/2._r8
+                    mbc_pho(c,3) = mbc_pho(c,2)
+                    moc_phi(c,2) = moc_phi(c,2)/2._r8
+                    moc_phi(c,3) = moc_phi(c,2)
+                    moc_pho(c,2) = moc_pho(c,2)/2._r8
+                    moc_pho(c,3) = moc_pho(c,2)
+                    mdst1(c,2) = mdst1(c,2)/2._r8
+                    mdst1(c,3) = mdst1(c,2)
+                    mdst2(c,2) = mdst2(c,2)/2._r8
+                    mdst2(c,3) = mdst2(c,2)
+                    mdst3(c,2) = mdst3(c,2)/2._r8
+                    mdst3(c,3) = mdst3(c,2)
+                    mdst4(c,2) = mdst4(c,2)/2._r8
+                    mdst4(c,3) = mdst4(c,2)
+                    rds(c,3) = rds(c,2)
 
                  end if
               end if
@@ -1653,73 +1437,73 @@ contains
               else
                  offset = 0._r8
               end if
-              if (dzsno(fc,2) > 0.05_r8+offset) then
+              if (dzsno(c,2) > 0.05_r8+offset) then
                  if (is_lake) then
-                    drr = dzsno(fc,2) - 0.05_r8 - lsadz
+                    drr = dzsno(c,2) - 0.05_r8 - lsadz
                  else
-                    drr = dzsno(fc,2) - 0.05_r8
+                    drr = dzsno(c,2) - 0.05_r8
                  end if
-                 propor = drr/dzsno(fc,2)
-                 zwice = propor*swice(fc,2)
-                 zwliq = propor*swliq(fc,2)
-
-                 zmbc_phi = propor*mbc_phi(fc,2)
-                 zmbc_pho = propor*mbc_pho(fc,2)
-                 zmoc_phi = propor*moc_phi(fc,2)
-                 zmoc_pho = propor*moc_pho(fc,2)
-                 zmdst1 = propor*mdst1(fc,2)
-                 zmdst2 = propor*mdst2(fc,2)
-                 zmdst3 = propor*mdst3(fc,2)
-                 zmdst4 = propor*mdst4(fc,2)
+                 propor = drr/dzsno(c,2)
+                 zwice = propor*swice(c,2)
+                 zwliq = propor*swliq(c,2)
+
+                 zmbc_phi = propor*mbc_phi(c,2)
+                 zmbc_pho = propor*mbc_pho(c,2)
+                 zmoc_phi = propor*moc_phi(c,2)
+                 zmoc_pho = propor*moc_pho(c,2)
+                 zmdst1 = propor*mdst1(c,2)
+                 zmdst2 = propor*mdst2(c,2)
+                 zmdst3 = propor*mdst3(c,2)
+                 zmdst4 = propor*mdst4(c,2)
 
                  if (is_lake) then
-                    propor = (0.05_r8+lsadz)/dzsno(fc,2)
+                    propor = (0.05_r8+lsadz)/dzsno(c,2)
                  else
-                    propor = 0.05_r8/dzsno(fc,2)
+                    propor = 0.05_r8/dzsno(c,2)
                  end if
-                 swice(fc,2) = propor*swice(fc,2)
-                 swliq(fc,2) = propor*swliq(fc,2)
-
-                 mbc_phi(fc,2) = propor*mbc_phi(fc,2)
-                 mbc_pho(fc,2) = propor*mbc_pho(fc,2)
-                 moc_phi(fc,2) = propor*moc_phi(fc,2)
-                 moc_pho(fc,2) = propor*moc_pho(fc,2)
-                 mdst1(fc,2) = propor*mdst1(fc,2)
-                 mdst2(fc,2) = propor*mdst2(fc,2)
-                 mdst3(fc,2) = propor*mdst3(fc,2)
-                 mdst4(fc,2) = propor*mdst4(fc,2)
+                 swice(c,2) = propor*swice(c,2)
+                 swliq(c,2) = propor*swliq(c,2)
+
+                 mbc_phi(c,2) = propor*mbc_phi(c,2)
+                 mbc_pho(c,2) = propor*mbc_pho(c,2)
+                 moc_phi(c,2) = propor*moc_phi(c,2)
+                 moc_pho(c,2) = propor*moc_pho(c,2)
+                 mdst1(c,2) = propor*mdst1(c,2)
+                 mdst2(c,2) = propor*mdst2(c,2)
+                 mdst3(c,2) = propor*mdst3(c,2)
+                 mdst4(c,2) = propor*mdst4(c,2)
 
                  if (is_lake) then
-                    dzsno(fc,2) = 0.05_r8+lsadz
+                    dzsno(c,2) = 0.05_r8+lsadz
                  else
-                    dzsno(fc,2) = 0.05_r8
+                    dzsno(c,2) = 0.05_r8
                  end if
 
-                 mbc_phi(fc,3) = mbc_phi(fc,3)+zmbc_phi  ! (combo)
-                 mbc_pho(fc,3) = mbc_pho(fc,3)+zmbc_pho  ! (combo)
-                 moc_phi(fc,3) = moc_phi(fc,3)+zmoc_phi  ! (combo)
-                 moc_pho(fc,3) = moc_pho(fc,3)+zmoc_pho  ! (combo)
-                 mdst1(fc,3) = mdst1(fc,3)+zmdst1  ! (combo)
-                 mdst2(fc,3) = mdst2(fc,3)+zmdst2  ! (combo)
-                 mdst3(fc,3) = mdst3(fc,3)+zmdst3  ! (combo)
-                 mdst4(fc,3) = mdst4(fc,3)+zmdst4  ! (combo)
+                 mbc_phi(c,3) = mbc_phi(c,3)+zmbc_phi  ! (combo)
+                 mbc_pho(c,3) = mbc_pho(c,3)+zmbc_pho  ! (combo)
+                 moc_phi(c,3) = moc_phi(c,3)+zmoc_phi  ! (combo)
+                 moc_pho(c,3) = moc_pho(c,3)+zmoc_pho  ! (combo)
+                 mdst1(c,3) = mdst1(c,3)+zmdst1  ! (combo)
+                 mdst2(c,3) = mdst2(c,3)+zmdst2  ! (combo)
+                 mdst3(c,3) = mdst3(c,3)+zmdst3  ! (combo)
+                 mdst4(c,3) = mdst4(c,3)+zmdst4  ! (combo)
 #ifdef MODAL_AER
               !mgf++ bugfix
-              rds(fc,3) = (rds(fc,3)*(swliq(fc,3)+swice(fc,3)) + rds(fc,2)*(zwliq+zwice))/(swliq(fc,3)+swice(fc,3)+zwliq+zwice)
-                if ((rds(fc,3) < 30.) .or. (rds(fc,3) > 1500.)) then
+              rds(c,3) = (rds(c,3)*(swliq(c,3)+swice(c,3)) + rds(c,2)*(zwliq+zwice))/(swliq(c,3)+swice(c,3)+zwliq+zwice)
+                if ((rds(c,3) < 30.) .or. (rds(c,3) > 1500.)) then
 #ifndef _OPENACC
-                   write (iulog,*) "3. SNICAR ERROR: snow grain radius of",rds(fc,3),rds(fc,2)
-                   write (iulog,*) "swliq, swice, zwliq, zwice", swliq(fc,3), swice(fc,3),zwliq, zwice
+                   write (iulog,*) "3. SNICAR ERROR: snow grain radius of",rds(c,3),rds(c,2)
+                   write (iulog,*) "swliq, swice, zwliq, zwice", swliq(c,3), swice(c,3),zwliq, zwice
                    write (iulog,*) "layers ", msno
 #endif
                 endif
               !mgf--
 #else
-              rds(fc,3) = rds(fc,2) ! (combo)
+              rds(c,3) = rds(c,2) ! (combo)
 #endif
 
-                 call Combo (dzsno(fc,3), swliq(fc,3), swice(fc,3), tsno(fc,3), drr, &
-                      zwliq, zwice, tsno(fc,2))
+                 call Combo (dzsno(c,3), swliq(c,3), swice(c,3), tsno(c,3), drr, &
+                      zwliq, zwice, tsno(c,2))
 
                  ! Subdivided a new layer
                  if (is_lake) then
@@ -1727,39 +1511,39 @@ contains
                  else
                     offset = 0._r8
                  end if
-                 if (msno <= 3 .and. dzsno(fc,3) > 0.18_r8+offset) then
+                 if (msno <= 3 .and. dzsno(c,3) > 0.18_r8+offset) then
                     msno =  4
-                    dtdz = (tsno(fc,2) - tsno(fc,3))/((dzsno(fc,2)+dzsno(fc,3))/2._r8) 
-                    dzsno(fc,3) = dzsno(fc,3)/2._r8
-                    swice(fc,3) = swice(fc,3)/2._r8
-                    swliq(fc,3) = swliq(fc,3)/2._r8
-                    dzsno(fc,4) = dzsno(fc,3)
-                    swice(fc,4) = swice(fc,3)
-                    swliq(fc,4) = swliq(fc,3)
-                    tsno(fc,4) = tsno(fc,3) - dtdz*dzsno(fc,3)/2._r8
-                    if (tsno(fc,4) >= tfrz) then 
-                       tsno(fc,4)  = tsno(fc,3)
+                    dtdz = (tsno(c,2) - tsno(c,3))/((dzsno(c,2)+dzsno(c,3))/2._r8) 
+                    dzsno(c,3) = dzsno(c,3)/2._r8
+                    swice(c,3) = swice(c,3)/2._r8
+                    swliq(c,3) = swliq(c,3)/2._r8
+                    dzsno(c,4) = dzsno(c,3)
+                    swice(c,4) = swice(c,3)
+                    swliq(c,4) = swliq(c,3)
+                    tsno(c,4) = tsno(c,3) - dtdz*dzsno(c,3)/2._r8
+                    if (tsno(c,4) >= tfrz) then 
+                       tsno(c,4)  = tsno(c,3)
                     else
-                       tsno(fc,3) = tsno(fc,3) + dtdz*dzsno(fc,3)/2._r8 
+                       tsno(c,3) = tsno(c,3) + dtdz*dzsno(c,3)/2._r8 
                     endif
 
-                    mbc_phi(fc,3) = mbc_phi(fc,3)/2._r8
-                    mbc_phi(fc,4) = mbc_phi(fc,3)
-                    mbc_pho(fc,3) = mbc_pho(fc,3)/2._r8
-                    mbc_pho(fc,4) = mbc_pho(fc,3)
-                    moc_phi(fc,3) = moc_phi(fc,3)/2._r8
-                    moc_phi(fc,4) = moc_phi(fc,3)
-                    moc_pho(fc,3) = moc_pho(fc,3)/2._r8
-                    moc_pho(fc,4) = moc_pho(fc,3)
-                    mdst1(fc,3) = mdst1(fc,3)/2._r8
-                    mdst1(fc,4) = mdst1(fc,3)
-                    mdst2(fc,3) = mdst2(fc,3)/2._r8
-                    mdst2(fc,4) = mdst2(fc,3)
-                    mdst3(fc,3) = mdst3(fc,3)/2._r8
-                    mdst3(fc,4) = mdst3(fc,3)
-                    mdst4(fc,3) = mdst4(fc,3)/2._r8
-                    mdst4(fc,4) = mdst4(fc,3)
-                    rds(fc,4) = rds(fc,3)
+                    mbc_phi(c,3) = mbc_phi(c,3)/2._r8
+                    mbc_phi(c,4) = mbc_phi(c,3)
+                    mbc_pho(c,3) = mbc_pho(c,3)/2._r8
+                    mbc_pho(c,4) = mbc_pho(c,3)
+                    moc_phi(c,3) = moc_phi(c,3)/2._r8
+                    moc_phi(c,4) = moc_phi(c,3)
+                    moc_pho(c,3) = moc_pho(c,3)/2._r8
+                    moc_pho(c,4) = moc_pho(c,3)
+                    mdst1(c,3) = mdst1(c,3)/2._r8
+                    mdst1(c,4) = mdst1(c,3)
+                    mdst2(c,3) = mdst2(c,3)/2._r8
+                    mdst2(c,4) = mdst2(c,3)
+                    mdst3(c,3) = mdst3(c,3)/2._r8
+                    mdst3(c,4) = mdst3(c,3)
+                    mdst4(c,3) = mdst4(c,3)/2._r8
+                    mdst4(c,4) = mdst4(c,3)
+                    rds(c,4) = rds(c,3)
 
                  end if
               end if
@@ -1771,71 +1555,71 @@ contains
               else
                  offset = 0._r8
               end if
-              if (dzsno(fc,3) > 0.11_r8 + offset) then
+              if (dzsno(c,3) > 0.11_r8 + offset) then
                  if (is_lake) then
-                    drr = dzsno(fc,3) - 0.11_r8 - lsadz
+                    drr = dzsno(c,3) - 0.11_r8 - lsadz
                  else
-                    drr = dzsno(fc,3) - 0.11_r8
+                    drr = dzsno(c,3) - 0.11_r8
                  end if
-                 propor = drr/dzsno(fc,3)
-                 zwice = propor*swice(fc,3)
-                 zwliq = propor*swliq(fc,3)
-
-                 zmbc_phi = propor*mbc_phi(fc,3)
-                 zmbc_pho = propor*mbc_pho(fc,3)
-                 zmoc_phi = propor*moc_phi(fc,3)
-                 zmoc_pho = propor*moc_pho(fc,3)
-                 zmdst1 = propor*mdst1(fc,3)
-                 zmdst2 = propor*mdst2(fc,3)
-                 zmdst3 = propor*mdst3(fc,3)
-                 zmdst4 = propor*mdst4(fc,3)
+                 propor = drr/dzsno(c,3)
+                 zwice = propor*swice(c,3)
+                 zwliq = propor*swliq(c,3)
+
+                 zmbc_phi = propor*mbc_phi(c,3)
+                 zmbc_pho = propor*mbc_pho(c,3)
+                 zmoc_phi = propor*moc_phi(c,3)
+                 zmoc_pho = propor*moc_pho(c,3)
+                 zmdst1 = propor*mdst1(c,3)
+                 zmdst2 = propor*mdst2(c,3)
+                 zmdst3 = propor*mdst3(c,3)
+                 zmdst4 = propor*mdst4(c,3)
 
                  if (is_lake) then
-                    propor = (0.11_r8+lsadz)/dzsno(fc,3)
+                    propor = (0.11_r8+lsadz)/dzsno(c,3)
                  else
-                    propor = 0.11_r8/dzsno(fc,3)
+                    propor = 0.11_r8/dzsno(c,3)
                  end if
-                 swice(fc,3) = propor*swice(fc,3)
-                 swliq(fc,3) = propor*swliq(fc,3)
-
-                 mbc_phi(fc,3) = propor*mbc_phi(fc,3)
-                 mbc_pho(fc,3) = propor*mbc_pho(fc,3)
-                 moc_phi(fc,3) = propor*moc_phi(fc,3)
-                 moc_pho(fc,3) = propor*moc_pho(fc,3)
-                 mdst1(fc,3) = propor*mdst1(fc,3)
-                 mdst2(fc,3) = propor*mdst2(fc,3)
-                 mdst3(fc,3) = propor*mdst3(fc,3)
-                 mdst4(fc,3) = propor*mdst4(fc,3)
+                 swice(c,3) = propor*swice(c,3)
+                 swliq(c,3) = propor*swliq(c,3)
+
+                 mbc_phi(c,3) = propor*mbc_phi(c,3)
+                 mbc_pho(c,3) = propor*mbc_pho(c,3)
+                 moc_phi(c,3) = propor*moc_phi(c,3)
+                 moc_pho(c,3) = propor*moc_pho(c,3)
+                 mdst1(c,3) = propor*mdst1(c,3)
+                 mdst2(c,3) = propor*mdst2(c,3)
+                 mdst3(c,3) = propor*mdst3(c,3)
+                 mdst4(c,3) = propor*mdst4(c,3)
 
                  if (is_lake) then
-                    dzsno(fc,3) = 0.11_r8 + lsadz
+                    dzsno(c,3) = 0.11_r8 + lsadz
                  else
-                    dzsno(fc,3) = 0.11_r8
+                    dzsno(c,3) = 0.11_r8
                  end if
 
-                 mbc_phi(fc,4) = mbc_phi(fc,4)+zmbc_phi  ! (combo)
-                 mbc_pho(fc,4) = mbc_pho(fc,4)+zmbc_pho  ! (combo)
-                 moc_phi(fc,4) = moc_phi(fc,4)+zmoc_phi  ! (combo)
-                 moc_pho(fc,4) = moc_pho(fc,4)+zmoc_pho  ! (combo)
-                 mdst1(fc,4) = mdst1(fc,4)+zmdst1  ! (combo)
-                 mdst2(fc,4) = mdst2(fc,4)+zmdst2  ! (combo)
-                 mdst3(fc,4) = mdst3(fc,4)+zmdst3  ! (combo)
-                 mdst4(fc,4) = mdst4(fc,4)+zmdst4  ! (combo)
+                 mbc_phi(c,4) = mbc_phi(c,4)+zmbc_phi  ! (combo)
+                 mbc_pho(c,4) = mbc_pho(c,4)+zmbc_pho  ! (combo)
+                 moc_phi(c,4) = moc_phi(c,4)+zmoc_phi  ! (combo)
+                 moc_pho(c,4) = moc_pho(c,4)+zmoc_pho  ! (combo)
+                 mdst1(c,4) = mdst1(c,4)+zmdst1  ! (combo)
+                 mdst2(c,4) = mdst2(c,4)+zmdst2  ! (combo)
+                 mdst3(c,4) = mdst3(c,4)+zmdst3  ! (combo)
+                 mdst4(c,4) = mdst4(c,4)+zmdst4  ! (combo)
 #ifdef MODAL_AER
               !mgf++ bugfix
-              rds(fc,4) = (rds(fc,4)*(swliq(fc,4)+swice(fc,4)) + rds(fc,3)*(zwliq+zwice))/(swliq(fc,4)+swice(fc,4)+zwliq+zwice)
-                if ((rds(fc,4) < 30.) .or. (rds(fc,4) > 1500.)) then
-                   write (iulog,*) "4. SNICAR ERROR: snow grain radius of",rds(fc,4),rds(fc,3)
-                   write (iulog,*) "swliq, swice, zwliq, zwice", swliq(fc,4), swice(fc,4),zwliq, zwice
+              rds(c,4) = (rds(c,4)*(swliq(c,4)+swice(c,4)) + rds(c,3)*(zwliq+zwice))/(swliq(c,4)+swice(c,4)+zwliq+zwice)
+                if ((rds(c,4) < 30.) .or. (rds(c,4) > 1500.)) then
+                   write (iulog,*) "4. SNICAR ERROR: snow grain radius of",rds(c,4),rds(c,3)
+                   write (iulog,*) "swliq, swice, zwliq, zwice", swliq(c,4), swice(c,4),zwliq, zwice
                    write (iulog,*) "layers ", msno
                 endif
               !mgf--
 #else
-              rds(fc,4) = rds(fc,3) ! (combo)
+              rds(c,4) = rds(c,3) ! (combo)
 #endif
 
-                 call Combo (dzsno(fc,4), swliq(fc,4), swice(fc,4), tsno(fc,4), drr, &
-                      zwliq, zwice, tsno(fc,3))
+                 call Combo (dzsno(c,4), swliq(c,4), swice(c,4), tsno(c,4), drr, &
+                      zwliq, zwice, tsno(c,3))
 
                  ! Subdivided a new layer
                  if (is_lake) then
@@ -1843,39 +1627,39 @@ contains
                  else
                     offset = 0._r8
                  end if
-                 if (msno <= 4 .and. dzsno(fc,4) > 0.41_r8 + offset) then
+                 if (msno <= 4 .and. dzsno(c,4) > 0.41_r8 + offset) then
                     msno = 5
-                    dtdz = (tsno(fc,3) - tsno(fc,4))/((dzsno(fc,3)+dzsno(fc,4))/2._r8) 
-                    dzsno(fc,4) = dzsno(fc,4)/2._r8
-                    swice(fc,4) = swice(fc,4)/2._r8
-                    swliq(fc,4) = swliq(fc,4)/2._r8
-                    dzsno(fc,5) = dzsno(fc,4)
-                    swice(fc,5) = swice(fc,4)
-                    swliq(fc,5) = swliq(fc,4)
-                    tsno(fc,5) = tsno(fc,4) - dtdz*dzsno(fc,4)/2._r8 
-                    if (tsno(fc,5) >= tfrz) then 
-                       tsno(fc,5)  = tsno(fc,4)
+                    dtdz = (tsno(c,3) - tsno(c,4))/((dzsno(c,3)+dzsno(c,4))/2._r8) 
+                    dzsno(c,4) = dzsno(c,4)/2._r8
+                    swice(c,4) = swice(c,4)/2._r8
+                    swliq(c,4) = swliq(c,4)/2._r8
+                    dzsno(c,5) = dzsno(c,4)
+                    swice(c,5) = swice(c,4)
+                    swliq(c,5) = swliq(c,4)
+                    tsno(c,5) = tsno(c,4) - dtdz*dzsno(c,4)/2._r8 
+                    if (tsno(c,5) >= tfrz) then 
+                       tsno(c,5)  = tsno(c,4)
                     else
-                       tsno(fc,4) = tsno(fc,4) + dtdz*dzsno(fc,4)/2._r8 
+                       tsno(c,4) = tsno(c,4) + dtdz*dzsno(c,4)/2._r8 
                     endif
 
-                    mbc_phi(fc,4) = mbc_phi(fc,4)/2._r8
-                    mbc_phi(fc,5) = mbc_phi(fc,4)
-                    mbc_pho(fc,4) = mbc_pho(fc,4)/2._r8
-                    mbc_pho(fc,5) = mbc_pho(fc,4)              
-                    moc_phi(fc,4) = moc_phi(fc,4)/2._r8
-                    moc_phi(fc,5) = moc_phi(fc,4)
-                    moc_pho(fc,4) = moc_pho(fc,4)/2._r8
-                    moc_pho(fc,5) = moc_pho(fc,4)
-                    mdst1(fc,4) = mdst1(fc,4)/2._r8
-                    mdst1(fc,5) = mdst1(fc,4)
-                    mdst2(fc,4) = mdst2(fc,4)/2._r8
-                    mdst2(fc,5) = mdst2(fc,4)
-                    mdst3(fc,4) = mdst3(fc,4)/2._r8
-                    mdst3(fc,5) = mdst3(fc,4)
-                    mdst4(fc,4) = mdst4(fc,4)/2._r8
-                    mdst4(fc,5) = mdst4(fc,4)
-                    rds(fc,5) = rds(fc,4)
+                    mbc_phi(c,4) = mbc_phi(c,4)/2._r8
+                    mbc_phi(c,5) = mbc_phi(c,4)
+                    mbc_pho(c,4) = mbc_pho(c,4)/2._r8
+                    mbc_pho(c,5) = mbc_pho(c,4)              
+                    moc_phi(c,4) = moc_phi(c,4)/2._r8
+                    moc_phi(c,5) = moc_phi(c,4)
+                    moc_pho(c,4) = moc_pho(c,4)/2._r8
+                    moc_pho(c,5) = moc_pho(c,4)
+                    mdst1(c,4) = mdst1(c,4)/2._r8
+                    mdst1(c,5) = mdst1(c,4)
+                    mdst2(c,4) = mdst2(c,4)/2._r8
+                    mdst2(c,5) = mdst2(c,4)
+                    mdst3(c,4) = mdst3(c,4)/2._r8
+                    mdst3(c,5) = mdst3(c,4)
+                    mdst4(c,4) = mdst4(c,4)/2._r8
+                    mdst4(c,5) = mdst4(c,4)
+                    rds(c,5) = rds(c,4)
 
                  end if
               end if
@@ -1887,71 +1671,71 @@ contains
               else
                  offset = 0._r8
               end if
-              if (dzsno(fc,4) > 0.23_r8+offset) then
+              if (dzsno(c,4) > 0.23_r8+offset) then
                  if (is_lake) then
-                    drr = dzsno(fc,4) - 0.23_r8 - lsadz
+                    drr = dzsno(c,4) - 0.23_r8 - lsadz
                  else
-                    drr = dzsno(fc,4) - 0.23_r8
+                    drr = dzsno(c,4) - 0.23_r8
                  end if
-                 propor = drr/dzsno(fc,4)
-                 zwice = propor*swice(fc,4)
-                 zwliq = propor*swliq(fc,4)
-
-                 zmbc_phi = propor*mbc_phi(fc,4)
-                 zmbc_pho = propor*mbc_pho(fc,4)
-                 zmoc_phi = propor*moc_phi(fc,4)
-                 zmoc_pho = propor*moc_pho(fc,4)
-                 zmdst1 = propor*mdst1(fc,4)
-                 zmdst2 = propor*mdst2(fc,4)
-                 zmdst3 = propor*mdst3(fc,4)
-                 zmdst4 = propor*mdst4(fc,4)
+                 propor = drr/dzsno(c,4)
+                 zwice = propor*swice(c,4)
+                 zwliq = propor*swliq(c,4)
+
+                 zmbc_phi = propor*mbc_phi(c,4)
+                 zmbc_pho = propor*mbc_pho(c,4)
+                 zmoc_phi = propor*moc_phi(c,4)
+                 zmoc_pho = propor*moc_pho(c,4)
+                 zmdst1 = propor*mdst1(c,4)
+                 zmdst2 = propor*mdst2(c,4)
+                 zmdst3 = propor*mdst3(c,4)
+                 zmdst4 = propor*mdst4(c,4)
 
                  if (is_lake) then
-                    propor = (0.23_r8+lsadz)/dzsno(fc,4)
+                    propor = (0.23_r8+lsadz)/dzsno(c,4)
                  else
-                    propor = 0.23_r8/dzsno(fc,4)
+                    propor = 0.23_r8/dzsno(c,4)
                  end if
-                 swice(fc,4) = propor*swice(fc,4)
-                 swliq(fc,4) = propor*swliq(fc,4)
-
-                 mbc_phi(fc,4) = propor*mbc_phi(fc,4)
-                 mbc_pho(fc,4) = propor*mbc_pho(fc,4)
-                 moc_phi(fc,4) = propor*moc_phi(fc,4)
-                 moc_pho(fc,4) = propor*moc_pho(fc,4)
-                 mdst1(fc,4) = propor*mdst1(fc,4)
-                 mdst2(fc,4) = propor*mdst2(fc,4)
-                 mdst3(fc,4) = propor*mdst3(fc,4)
-                 mdst4(fc,4) = propor*mdst4(fc,4)
+                 swice(c,4) = propor*swice(c,4)
+                 swliq(c,4) = propor*swliq(c,4)
+
+                 mbc_phi(c,4) = propor*mbc_phi(c,4)
+                 mbc_pho(c,4) = propor*mbc_pho(c,4)
+                 moc_phi(c,4) = propor*moc_phi(c,4)
+                 moc_pho(c,4) = propor*moc_pho(c,4)
+                 mdst1(c,4) = propor*mdst1(c,4)
+                 mdst2(c,4) = propor*mdst2(c,4)
+                 mdst3(c,4) = propor*mdst3(c,4)
+                 mdst4(c,4) = propor*mdst4(c,4)
 
                  if (is_lake) then
-                    dzsno(fc,4) = 0.23_r8 + lsadz
+                    dzsno(c,4) = 0.23_r8 + lsadz
                  else
-                    dzsno(fc,4) = 0.23_r8
+                    dzsno(c,4) = 0.23_r8
                  end if
 
-                 mbc_phi(fc,5) = mbc_phi(fc,5)+zmbc_phi  ! (combo)
-                 mbc_pho(fc,5) = mbc_pho(fc,5)+zmbc_pho  ! (combo)
-                 moc_phi(fc,5) = moc_phi(fc,5)+zmoc_phi  ! (combo)
-                 moc_pho(fc,5) = moc_pho(fc,5)+zmoc_pho  ! (combo)
-                 mdst1(fc,5) = mdst1(fc,5)+zmdst1  ! (combo)
-                 mdst2(fc,5) = mdst2(fc,5)+zmdst2  ! (combo)
-                 mdst3(fc,5) = mdst3(fc,5)+zmdst3  ! (combo)
-                 mdst4(fc,5) = mdst4(fc,5)+zmdst4  ! (combo)
+                 mbc_phi(c,5) = mbc_phi(c,5)+zmbc_phi  ! (combo)
+                 mbc_pho(c,5) = mbc_pho(c,5)+zmbc_pho  ! (combo)
+                 moc_phi(c,5) = moc_phi(c,5)+zmoc_phi  ! (combo)
+                 moc_pho(c,5) = moc_pho(c,5)+zmoc_pho  ! (combo)
+                 mdst1(c,5) = mdst1(c,5)+zmdst1  ! (combo)
+                 mdst2(c,5) = mdst2(c,5)+zmdst2  ! (combo)
+                 mdst3(c,5) = mdst3(c,5)+zmdst3  ! (combo)
+                 mdst4(c,5) = mdst4(c,5)+zmdst4  ! (combo)
 #ifdef MODAL_AER
               !mgf++ bugfix
-              rds(fc,5) = (rds(fc,5)*(swliq(fc,5)+swice(fc,5)) + rds(fc,4)*(zwliq+zwice))/(swliq(fc,5)+swice(fc,5)+zwliq+zwice)
-                if ((rds(fc,5) < 30.) .or. (rds(fc,5) > 1500.)) then
+              rds(c,5) = (rds(c,5)*(swliq(c,5)+swice(c,5)) + rds(c,4)*(zwliq+zwice))/(swliq(c,5)+swice(c,5)+zwliq+zwice)
+                if ((rds(c,5) < 30.) .or. (rds(c,5) > 1500.)) then
                    write (iulog,*) "5. SNICAR ERROR: snow grain radius of",rds(c,5),rds(c,4)
                    write (iulog,*) "swliq, swice, zwliq, zwice", swliq(c,5), swice(c,5),zwliq, zwice
                    write (iulog,*) "layers ", msno
                 endif
               !mgf--
 #else
-              rds(fc,5) = rds(fc,4) ! (combo)
+              rds(c,5) = rds(c,4) ! (combo)
 #endif
 
-                 call Combo (dzsno(fc,5), swliq(fc,5), swice(fc,5), tsno(fc,5), drr, &
-                      zwliq, zwice, tsno(fc,4))
+                 call Combo (dzsno(c,5), swliq(c,5), swice(c,5), tsno(c,5), drr, &
+                      zwliq, zwice, tsno(c,4))
               end if
            end if
 
@@ -1959,28 +1743,27 @@ contains
 
        end do
 
-       !$acc parallel loop independent gang vector default(present) collapse(2) 
        do j = -nlevsno+1,0
           do fc = 1, num_snowc
              c = filter_snowc(fc)
              if (j >= snl(c)+1) then
                 if (is_lake) then
-                   dz(c,j) = dzsno(fc,j-snl(c))
+                   dz(c,j) = dzsno(c,j-snl(c))
                 else
-                   dz(c,j) = dzsno(fc,j-snl(c))/frac_sno(c)
+                   dz(c,j) = dzsno(c,j-snl(c))/frac_sno(c)
                 end if
-                h2osoi_ice(c,j) = swice(fc,j-snl(c))
-                h2osoi_liq(c,j) = swliq(fc,j-snl(c))
-                t_soisno(c,j)   = tsno(fc,j-snl(c))
-                mss_bcphi(c,j)   = mbc_phi(fc,j-snl(c))
-                mss_bcpho(c,j)   = mbc_pho(fc,j-snl(c))
-                mss_ocphi(c,j)   = moc_phi(fc,j-snl(c))
-                mss_ocpho(c,j)   = moc_pho(fc,j-snl(c))
-                mss_dst1(c,j)    = mdst1(fc,j-snl(c))
-                mss_dst2(c,j)    = mdst2(fc,j-snl(c))
-                mss_dst3(c,j)    = mdst3(fc,j-snl(c))
-                mss_dst4(c,j)    = mdst4(fc,j-snl(c))
-                snw_rds(c,j)     = rds(fc,j-snl(c))
+                h2osoi_ice(c,j) = swice(c,j-snl(c))
+                h2osoi_liq(c,j) = swliq(c,j-snl(c))
+                t_soisno(c,j)   = tsno(c,j-snl(c))
+                mss_bcphi(c,j)   = mbc_phi(c,j-snl(c))
+                mss_bcpho(c,j)   = mbc_pho(c,j-snl(c))
+                mss_ocphi(c,j)   = moc_phi(c,j-snl(c))
+                mss_ocpho(c,j)   = moc_pho(c,j-snl(c))
+                mss_dst1(c,j)    = mdst1(c,j-snl(c))
+                mss_dst2(c,j)    = mdst2(c,j-snl(c))
+                mss_dst3(c,j)    = mdst3(c,j-snl(c))
+                mss_dst4(c,j)    = mdst4(c,j-snl(c))
+                snw_rds(c,j)     = rds(c,j-snl(c))
 
              end if
           end do
@@ -1988,31 +1771,28 @@ contains
 
        ! Consistency check
        if (is_lake) then
-
-         do fc = 1, num_snowc
-            c = filter_snowc(fc)
-            
-            do j = -nlevsno + 1, 0
+          do j = -nlevsno + 1, 0
+             do fc = 1, num_snowc
+                c = filter_snowc(fc)
 
                 if (j >= snl(c)+1) then
-                   dztot(fc) = dztot(fc) - dz(c,j)
-                   snwicetot(fc) = snwicetot(fc) - h2osoi_ice(c,j)
-                   snwliqtot(fc) = snwliqtot(fc) - h2osoi_liq(c,j)
+                   dztot(c) = dztot(c) - dz(c,j)
+                   snwicetot(c) = snwicetot(c) - h2osoi_ice(c,j)
+                   snwliqtot(c) = snwliqtot(c) - h2osoi_liq(c,j)
                 end if
 
                 if (j == 0) then
-                   if ( abs(dztot(fc)) > 1.e-10_r8 .or. abs(snwicetot(fc)) > 1.e-7_r8 .or. &
-                        abs(snwliqtot(fc)) > 1.e-7_r8 ) then
+                   if ( abs(dztot(c)) > 1.e-10_r8 .or. abs(snwicetot(c)) > 1.e-7_r8 .or. &
+                        abs(snwliqtot(c)) > 1.e-7_r8 ) then
                       write(iulog,*)'Inconsistency in SnowDivision_Lake! c, remainders', &
                            'dztot, snwicetot, snwliqtot = ',c,dztot(c),snwicetot(c),snwliqtot(c)
                       call endrun(decomp_index=c, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
                    end if
                 end if
-            end do
-         end do
+             end do
+          end do
        end if
 
-       !$acc parallel loop independent gang vector default(present) collapse(2) 
        do j = 0, -nlevsno+1, -1
           do fc = 1, num_snowc
              c = filter_snowc(fc)
@@ -2023,27 +1803,6 @@ contains
           end do
        end do
 
-     !$acc exit data delete(&
-     !$acc dzsno(:,:), &
-     !$acc swice(:,:), &
-     !$acc swliq(:,:), &
-     !$acc tsno(:,:), &
-     !$acc mbc_phi(:,:), &
-     !$acc mbc_pho(:,:), &
-     !$acc moc_phi(:,:), &
-     !$acc moc_pho(:,:), &
-     !$acc mdst1(:,:), &
-     !$acc mdst2(:,:), &
-     !$acc mdst3(:,:), &
-     !$acc mdst4(:,:), &
-     !$acc rds(:,:), &
-     !$acc dztot(:), &
-     !$acc snwicetot(:), &
-     !$acc snwliqtot(:), &
-     !$acc sum1, &
-     !$acc sum2, &
-     !$acc sum3)
-
      end associate
 
    end subroutine DivideSnowLayers
@@ -2071,36 +1830,36 @@ contains
      integer  :: j, c, fc, k                              ! indices
      real(r8) :: drr                                      ! thickness of the combined [m]
      integer  :: msno                                     ! number of snow layer 1 (top) to msno (bottom)
-     real(r8) :: dzsno(1:num_snowc,nlevsno)   ! Snow layer thickness [m]
-     real(r8) :: swice(1:num_snowc,nlevsno)   ! Partial volume of ice [m3/m3]
-     real(r8) :: swliq(1:num_snowc,nlevsno)   ! Partial volume of liquid water [m3/m3]
-     real(r8) :: tsno(1:num_snowc ,nlevsno)   ! Nodel temperature [K]
+     real(r8) :: dzsno(bounds%begc:bounds%endc,nlevsno)   ! Snow layer thickness [m]
+     real(r8) :: swice(bounds%begc:bounds%endc,nlevsno)   ! Partial volume of ice [m3/m3]
+     real(r8) :: swliq(bounds%begc:bounds%endc,nlevsno)   ! Partial volume of liquid water [m3/m3]
+     real(r8) :: tsno(bounds%begc:bounds%endc ,nlevsno)   ! Nodel temperature [K]
      real(r8) :: zwice                                    ! temporary
      real(r8) :: zwliq                                    ! temporary
      real(r8) :: propor                                   ! temporary
      real(r8) :: dtdz                                     ! temporary
      ! temporary variables mimicking the structure of other layer division variables
-     real(r8) :: mbc_phi(1:num_snowc,nlevsno) ! mass of BC in each snow layer
+     real(r8) :: mbc_phi(bounds%begc:bounds%endc,nlevsno) ! mass of BC in each snow layer
      real(r8) :: zmbc_phi                                 ! temporary
-     real(r8) :: mbc_pho(1:num_snowc,nlevsno) ! mass of BC in each snow layer
+     real(r8) :: mbc_pho(bounds%begc:bounds%endc,nlevsno) ! mass of BC in each snow layer
      real(r8) :: zmbc_pho                                 ! temporary
-     real(r8) :: moc_phi(1:num_snowc,nlevsno) ! mass of OC in each snow layer
+     real(r8) :: moc_phi(bounds%begc:bounds%endc,nlevsno) ! mass of OC in each snow layer
      real(r8) :: zmoc_phi                                 ! temporary
-     real(r8) :: moc_pho(1:num_snowc,nlevsno) ! mass of OC in each snow layer
+     real(r8) :: moc_pho(bounds%begc:bounds%endc,nlevsno) ! mass of OC in each snow layer
      real(r8) :: zmoc_pho                                 ! temporary
-     real(r8) :: mdst1(1:num_snowc,nlevsno)   ! mass of dust 1 in each snow layer
+     real(r8) :: mdst1(bounds%begc:bounds%endc,nlevsno)   ! mass of dust 1 in each snow layer
      real(r8) :: zmdst1                                   ! temporary
-     real(r8) :: mdst2(1:num_snowc,nlevsno)   ! mass of dust 2 in each snow layer
+     real(r8) :: mdst2(bounds%begc:bounds%endc,nlevsno)   ! mass of dust 2 in each snow layer
      real(r8) :: zmdst2                                   ! temporary
-     real(r8) :: mdst3(1:num_snowc,nlevsno)   ! mass of dust 3 in each snow layer
+     real(r8) :: mdst3(bounds%begc:bounds%endc,nlevsno)   ! mass of dust 3 in each snow layer
      real(r8) :: zmdst3                                   ! temporary
-     real(r8) :: mdst4(1:num_snowc,nlevsno)   ! mass of dust 4 in each snow layer
+     real(r8) :: mdst4(bounds%begc:bounds%endc,nlevsno)   ! mass of dust 4 in each snow layer
      real(r8) :: zmdst4                                   ! temporary
-     real(r8) :: rds(1:num_snowc,nlevsno)
+     real(r8) :: rds(bounds%begc:bounds%endc,nlevsno)
      ! Variables for consistency check
-     real(r8) :: dztot(1:num_snowc)
-     real(r8) :: snwicetot(1:num_snowc)
-     real(r8) :: snwliqtot(1:num_snowc)
+     real(r8) :: dztot(bounds%begc:bounds%endc)
+     real(r8) :: snwicetot(bounds%begc:bounds%endc)
+     real(r8) :: snwliqtot(bounds%begc:bounds%endc)
      real(r8) :: offset ! temporary
      !-----------------------------------------------------------------------
      
@@ -2126,27 +1885,6 @@ contains
           zi         => col_pp%zi                           , & ! Output: [real(r8) (:,:) ] interface level below a "z" level (m)  
           z          => col_pp%z                              & ! Output: [real(r8) (:,:) ] layer thickness (m)                   
           )
-     !$acc enter data create(&
-     !$acc dzsno(:,:), &
-     !$acc swice(:,:), &
-     !$acc swliq(:,:), &
-     !$acc tsno(:,:), &
-     !$acc mbc_phi(:,:), &
-     !$acc mbc_pho(:,:), &
-     !$acc moc_phi(:,:), &
-     !$acc moc_pho(:,:), &
-     !$acc mdst1(:,:), &
-     !$acc mdst2(:,:), &
-     !$acc mdst3(:,:), &
-     !$acc mdst4(:,:), &
-     !$acc rds(:,:), &
-     !$acc dztot(:), &
-     !$acc snwicetot(:), &
-     !$acc snwliqtot(:), &
-     !$acc msno)
-
-      
-         
 
        if ( is_lake ) then
           ! Initialize for consistency check
@@ -2155,15 +1893,15 @@ contains
                 c = filter_snowc(fc)
                 
                 if (j == -nlevsno+1) then
-                   dztot(fc) = 0._r8
-                   snwicetot(fc) = 0._r8
-                   snwliqtot(fc) = 0._r8
+                   dztot(c) = 0._r8
+                   snwicetot(c) = 0._r8
+                   snwliqtot(c) = 0._r8
                 end if
                 
                 if (j >= snl(c)+1) then
-                   dztot(fc) = dztot(fc) + dz(c,j)
-                   snwicetot(fc) = snwicetot(fc) + h2osoi_ice(c,j)
-                   snwliqtot(fc) = snwliqtot(fc) + h2osoi_liq(c,j)
+                   dztot(c) = dztot(c) + dz(c,j)
+                   snwicetot(c) = snwicetot(c) + h2osoi_ice(c,j)
+                   snwliqtot(c) = snwliqtot(c) + h2osoi_liq(c,j)
                 end if
              end do
           end do
@@ -2172,34 +1910,32 @@ contains
        ! Begin calculation - note that the following column loops are only invoked
        ! for snow-covered columns
 
-       !$acc parallel loop independent gang vector default(present) collapse(2) 
        do j = 1,nlevsno
           do fc = 1, num_snowc
              c = filter_snowc(fc)
              if (j <= abs(snl(c))) then
                 if (is_lake) then
-                   dzsno(fc,j) = dz(c,j+snl(c))
+                   dzsno(c,j) = dz(c,j+snl(c))
                 else
-                   dzsno(fc,j) = frac_sno(c)*dz(c,j+snl(c))
+                   dzsno(c,j) = frac_sno(c)*dz(c,j+snl(c))
                 end if
-                swice(fc,j) = h2osoi_ice(c,j+snl(c))
-                swliq(fc,j) = h2osoi_liq(c,j+snl(c))
-                tsno(fc,j)  = t_soisno(c,j+snl(c))
-
-                mbc_phi(fc,j) = mss_bcphi(c,j+snl(c))
-                mbc_pho(fc,j) = mss_bcpho(c,j+snl(c))
-                moc_phi(fc,j) = mss_ocphi(c,j+snl(c))
-                moc_pho(fc,j) = mss_ocpho(c,j+snl(c))
-                mdst1(fc,j)   = mss_dst1(c,j+snl(c))
-                mdst2(fc,j)   = mss_dst2(c,j+snl(c))
-                mdst3(fc,j)   = mss_dst3(c,j+snl(c))
-                mdst4(fc,j)   = mss_dst4(c,j+snl(c))
-                rds(fc,j)     = snw_rds(c,j+snl(c))
+                swice(c,j) = h2osoi_ice(c,j+snl(c))
+                swliq(c,j) = h2osoi_liq(c,j+snl(c))
+                tsno(c,j)  = t_soisno(c,j+snl(c))
+
+                mbc_phi(c,j) = mss_bcphi(c,j+snl(c))
+                mbc_pho(c,j) = mss_bcpho(c,j+snl(c))
+                moc_phi(c,j) = mss_ocphi(c,j+snl(c))
+                moc_pho(c,j) = mss_ocpho(c,j+snl(c))
+                mdst1(c,j)   = mss_dst1(c,j+snl(c))
+                mdst2(c,j)   = mss_dst2(c,j+snl(c))
+                mdst3(c,j)   = mss_dst3(c,j+snl(c))
+                mdst4(c,j)   = mss_dst4(c,j+snl(c))
+                rds(c,j)     = snw_rds(c,j+snl(c))
              end if
           end do
        end do
 
-       !$acc parallel loop independent gang vector default(present)
        loop_snowcolumns: do fc = 1, num_snowc
            c = filter_snowc(fc)
 
@@ -2221,49 +1957,49 @@ contains
                     offset = 0._r8
                  end if
 
-                 if (dzsno(fc,k) > dzmax_l(k) + offset) then
+                 if (dzsno(c,k) > dzmax_l(k) + offset) then
                     ! Subdivide layer into two layers with equal thickness, water
                     ! content, ice content and temperature
                     msno = msno + 1
-                    dzsno(fc,k)     = dzsno(fc,k) / 2.0_r8
-                    dzsno(fc,k+1)   = dzsno(fc,k)
-                    swice(fc,k)     = swice(fc,k) / 2.0_r8
-                    swice(fc,k+1)   = swice(fc,k)
-                    swliq(fc,k)     = swliq(fc,k) / 2.0_r8
-                    swliq(fc,k+1)   = swliq(fc,k)
+                    dzsno(c,k)     = dzsno(c,k) / 2.0_r8
+                    dzsno(c,k+1)   = dzsno(c,k)
+                    swice(c,k)     = swice(c,k) / 2.0_r8
+                    swice(c,k+1)   = swice(c,k)
+                    swliq(c,k)     = swliq(c,k) / 2.0_r8
+                    swliq(c,k+1)   = swliq(c,k)
 
                     if (k == 1) then
                        ! special case
-                       tsno(fc,k+1)    = tsno(fc,k)
+                       tsno(c,k+1)    = tsno(c,k)
                     else
                        ! use temperature gradient
-                       dtdz           = (tsno(fc,k-1) - tsno(fc,k))/((dzsno(fc,k-1)+2*dzsno(fc,k))/2.0_r8)
-                       tsno(fc,k+1) = tsno(fc,k) - dtdz*dzsno(fc,k)/2.0_r8
-                       if (tsno(fc,k+1) >= tfrz) then
-                          tsno(fc,k+1)  = tsno(fc,k)
+                       dtdz           = (tsno(c,k-1) - tsno(c,k))/((dzsno(c,k-1)+2*dzsno(c,k))/2.0_r8)
+                       tsno(c,k+1) = tsno(c,k) - dtdz*dzsno(c,k)/2.0_r8
+                       if (tsno(c,k+1) >= tfrz) then
+                          tsno(c,k+1)  = tsno(c,k)
                        else
-                          tsno(fc,k) = tsno(fc,k) + dtdz*dzsno(fc,k)/2.0_r8
+                          tsno(c,k) = tsno(c,k) + dtdz*dzsno(c,k)/2.0_r8
                        endif
                     end if
 
-                    mbc_phi(fc,k)   = mbc_phi(fc,k) / 2.0_r8
-                    mbc_phi(fc,k+1) = mbc_phi(fc,k)
-                    mbc_pho(fc,k)   = mbc_pho(fc,k) / 2.0_r8
-                    mbc_pho(fc,k+1) = mbc_pho(fc,k)
-                    moc_phi(fc,k)   = moc_phi(fc,k) / 2.0_r8
-                    moc_phi(fc,k+1) = moc_phi(fc,k)
-                    moc_pho(fc,k)   = moc_pho(fc,k) / 2.0_r8
-                    moc_pho(fc,k+1) = moc_pho(fc,k)
-                    mdst1(fc,k)     = mdst1(fc,k) / 2.0_r8
-                    mdst1(fc,k+1)   = mdst1(fc,k)
-                    mdst2(fc,k)     = mdst2(fc,k) / 2.0_r8
-                    mdst2(fc,k+1)   = mdst2(fc,k)
-                    mdst3(fc,k)     = mdst3(fc,k) / 2.0_r8
-                    mdst3(fc,k+1)   = mdst3(fc,k)
-                    mdst4(fc,k)     = mdst4(fc,k) / 2.0_r8
-                    mdst4(fc,k+1)   = mdst4(fc,k)
-
-                    rds(fc,k+1)     = rds(fc,k)
+                    mbc_phi(c,k)   = mbc_phi(c,k) / 2.0_r8
+                    mbc_phi(c,k+1) = mbc_phi(c,k)
+                    mbc_pho(c,k)   = mbc_pho(c,k) / 2.0_r8
+                    mbc_pho(c,k+1) = mbc_pho(c,k)
+                    moc_phi(c,k)   = moc_phi(c,k) / 2.0_r8
+                    moc_phi(c,k+1) = moc_phi(c,k)
+                    moc_pho(c,k)   = moc_pho(c,k) / 2.0_r8
+                    moc_pho(c,k+1) = moc_pho(c,k)
+                    mdst1(c,k)     = mdst1(c,k) / 2.0_r8
+                    mdst1(c,k+1)   = mdst1(c,k)
+                    mdst2(c,k)     = mdst2(c,k) / 2.0_r8
+                    mdst2(c,k+1)   = mdst2(c,k)
+                    mdst3(c,k)     = mdst3(c,k) / 2.0_r8
+                    mdst3(c,k+1)   = mdst3(c,k)
+                    mdst4(c,k)     = mdst4(c,k) / 2.0_r8
+                    mdst4(c,k+1)   = mdst4(c,k)
+
+                    rds(c,k+1)     = rds(c,k)
                  end if
               end if
 
@@ -2277,53 +2013,53 @@ contains
                     offset = 0._r8
                  end if
 
-                 if (dzsno(fc,k) > dzmax_u(k) + offset ) then
+                 if (dzsno(c,k) > dzmax_u(k) + offset ) then
                     ! Only dump excess snow to underlying layer in a conservative fashion.
                     ! Other quantities will depend on the height of the excess snow: a ratio is used for this.
-                    drr      = dzsno(fc,k) - dzmax_u(k) - offset
-
-                    propor   = drr/dzsno(fc,k)
-                    zwice    = propor*swice(fc,k)
-                    zwliq    = propor*swliq(fc,k)
-                    zmbc_phi = propor*mbc_phi(fc,k)
-                    zmbc_pho = propor*mbc_pho(fc,k)
-                    zmoc_phi = propor*moc_phi(fc,k)
-                    zmoc_pho = propor*moc_pho(fc,k)
-                    zmdst1   = propor*mdst1(fc,k)
-                    zmdst2   = propor*mdst2(fc,k)
-                    zmdst3   = propor*mdst3(fc,k)
-                    zmdst4   = propor*mdst4(fc,k)
-
-                    propor         = (dzmax_u(k)+offset)/dzsno(fc,k)
-                    swice(fc,k)     = propor*swice(fc,k)
-                    swliq(fc,k)     = propor*swliq(fc,k)
-                    mbc_phi(fc,k)   = propor*mbc_phi(fc,k)
-                    mbc_pho(fc,k)   = propor*mbc_pho(fc,k)
-                    moc_phi(fc,k)   = propor*moc_phi(fc,k)
-                    moc_pho(fc,k)   = propor*moc_pho(fc,k)
-                    mdst1(fc,k)     = propor*mdst1(fc,k)
-                    mdst2(fc,k)     = propor*mdst2(fc,k)
-                    mdst3(fc,k)     = propor*mdst3(fc,k)
-                    mdst4(fc,k)     = propor*mdst4(fc,k)
+                    drr      = dzsno(c,k) - dzmax_u(k) - offset
+
+                    propor   = drr/dzsno(c,k)
+                    zwice    = propor*swice(c,k)
+                    zwliq    = propor*swliq(c,k)
+                    zmbc_phi = propor*mbc_phi(c,k)
+                    zmbc_pho = propor*mbc_pho(c,k)
+                    zmoc_phi = propor*moc_phi(c,k)
+                    zmoc_pho = propor*moc_pho(c,k)
+                    zmdst1   = propor*mdst1(c,k)
+                    zmdst2   = propor*mdst2(c,k)
+                    zmdst3   = propor*mdst3(c,k)
+                    zmdst4   = propor*mdst4(c,k)
+
+                    propor         = (dzmax_u(k)+offset)/dzsno(c,k)
+                    swice(c,k)     = propor*swice(c,k)
+                    swliq(c,k)     = propor*swliq(c,k)
+                    mbc_phi(c,k)   = propor*mbc_phi(c,k)
+                    mbc_pho(c,k)   = propor*mbc_pho(c,k)
+                    moc_phi(c,k)   = propor*moc_phi(c,k)
+                    moc_pho(c,k)   = propor*moc_pho(c,k)
+                    mdst1(c,k)     = propor*mdst1(c,k)
+                    mdst2(c,k)     = propor*mdst2(c,k)
+                    mdst3(c,k)     = propor*mdst3(c,k)
+                    mdst4(c,k)     = propor*mdst4(c,k)
 
                     ! Set depth layer k to maximum allowed value
-                    dzsno(fc,k)  = dzmax_u(k)  + offset
+                    dzsno(c,k)  = dzmax_u(k)  + offset
 
-                    mbc_phi(fc,k+1) = mbc_phi(fc,k+1)+zmbc_phi  ! (combo)
-                    mbc_pho(fc,k+1) = mbc_pho(fc,k+1)+zmbc_pho  ! (combo)
-                    moc_phi(fc,k+1) = moc_phi(fc,k+1)+zmoc_phi  ! (combo)
-                    moc_pho(fc,k+1) = moc_pho(fc,k+1)+zmoc_pho  ! (combo)
-                    mdst1(fc,k+1)   = mdst1(fc,k+1)+zmdst1  ! (combo)
-                    mdst2(fc,k+1)   = mdst2(fc,k+1)+zmdst2  ! (combo)
-                    mdst3(fc,k+1)   = mdst3(fc,k+1)+zmdst3  ! (combo)
-                    mdst4(fc,k+1)   = mdst4(fc,k+1)+zmdst4  ! (combo)
+                    mbc_phi(c,k+1) = mbc_phi(c,k+1)+zmbc_phi  ! (combo)
+                    mbc_pho(c,k+1) = mbc_pho(c,k+1)+zmbc_pho  ! (combo)
+                    moc_phi(c,k+1) = moc_phi(c,k+1)+zmoc_phi  ! (combo)
+                    moc_pho(c,k+1) = moc_pho(c,k+1)+zmoc_pho  ! (combo)
+                    mdst1(c,k+1)   = mdst1(c,k+1)+zmdst1  ! (combo)
+                    mdst2(c,k+1)   = mdst2(c,k+1)+zmdst2  ! (combo)
+                    mdst3(c,k+1)   = mdst3(c,k+1)+zmdst3  ! (combo)
+                    mdst4(c,k+1)   = mdst4(c,k+1)+zmdst4  ! (combo)
 
                     ! Mass-weighted combination of radius
-                    rds(fc,k+1) = MassWeightedSnowRadius( rds(fc,k), rds(fc,k+1), &
-                         (swliq(fc,k+1)+swice(fc,k+1)), (zwliq+zwice) )
+                    rds(c,k+1) = MassWeightedSnowRadius( rds(c,k), rds(c,k+1), &
+                         (swliq(c,k+1)+swice(c,k+1)), (zwliq+zwice) )
 
-                    call Combo (dzsno(fc,k+1), swliq(fc,k+1), swice(fc,k+1), tsno(fc,k+1), drr, &
-                         zwliq, zwice, tsno(fc,k))
+                    call Combo (dzsno(c,k+1), swliq(c,k+1), swice(c,k+1), tsno(c,k+1), drr, &
+                         zwliq, zwice, tsno(c,k))
                  end if
               end if
               k = k+1
@@ -2333,28 +2069,27 @@ contains
 
        end do loop_snowcolumns
 
-       !$acc parallel loop independent gang vector default(present) collapse(2) 
        do j = -nlevsno+1,0
           do fc = 1, num_snowc
              c = filter_snowc(fc)
              if (j >= snl(c)+1) then
                 if (is_lake) then
-                   dz(c,j) = dzsno(fc,j-snl(c))
+                   dz(c,j) = dzsno(c,j-snl(c))
                 else
-                   dz(c,j) = dzsno(fc,j-snl(c))/frac_sno(c)
+                   dz(c,j) = dzsno(c,j-snl(c))/frac_sno(c)
                 end if
-                h2osoi_ice(c,j) = swice(fc,j-snl(c))
-                h2osoi_liq(c,j) = swliq(fc,j-snl(c))
-                t_soisno(c,j)   = tsno(fc,j-snl(c))
-                mss_bcphi(c,j)   = mbc_phi(fc,j-snl(c))
-                mss_bcpho(c,j)   = mbc_pho(fc,j-snl(c))
-                mss_ocphi(c,j)   = moc_phi(fc,j-snl(c))
-                mss_ocpho(c,j)   = moc_pho(fc,j-snl(c))
-                mss_dst1(c,j)    = mdst1(fc,j-snl(c))
-                mss_dst2(c,j)    = mdst2(fc,j-snl(c))
-                mss_dst3(c,j)    = mdst3(fc,j-snl(c))
-                mss_dst4(c,j)    = mdst4(fc,j-snl(c))
-                snw_rds(c,j)     = rds(fc,j-snl(c))
+                h2osoi_ice(c,j) = swice(c,j-snl(c))
+                h2osoi_liq(c,j) = swliq(c,j-snl(c))
+                t_soisno(c,j)   = tsno(c,j-snl(c))
+                mss_bcphi(c,j)   = mbc_phi(c,j-snl(c))
+                mss_bcpho(c,j)   = mbc_pho(c,j-snl(c))
+                mss_ocphi(c,j)   = moc_phi(c,j-snl(c))
+                mss_ocpho(c,j)   = moc_pho(c,j-snl(c))
+                mss_dst1(c,j)    = mdst1(c,j-snl(c))
+                mss_dst2(c,j)    = mdst2(c,j-snl(c))
+                mss_dst3(c,j)    = mdst3(c,j-snl(c))
+                mss_dst4(c,j)    = mdst4(c,j-snl(c))
+                snw_rds(c,j)     = rds(c,j-snl(c))
              end if
           end do
        end do
@@ -2366,17 +2101,17 @@ contains
                 c = filter_snowc(fc)
 
                 if (j >= snl(c)+1) then
-                   dztot(fc) = dztot(fc) - dz(c,j)
-                   snwicetot(fc) = snwicetot(fc) - h2osoi_ice(c,j)
-                   snwliqtot(fc) = snwliqtot(fc) - h2osoi_liq(c,j)
+                   dztot(c) = dztot(c) - dz(c,j)
+                   snwicetot(c) = snwicetot(c) - h2osoi_ice(c,j)
+                   snwliqtot(c) = snwliqtot(c) - h2osoi_liq(c,j)
                 end if
 
                 if (j == 0) then
-                   if ( abs(dztot(fc)) > 1.e-10_r8 .or. abs(snwicetot(fc)) > 1.e-7_r8 .or. &
-                        abs(snwliqtot(fc)) > 1.e-7_r8 ) then
+                   if ( abs(dztot(c)) > 1.e-10_r8 .or. abs(snwicetot(c)) > 1.e-7_r8 .or. &
+                        abs(snwliqtot(c)) > 1.e-7_r8 ) then
 #ifndef _OPENACC
                       write(iulog,*)'Inconsistency in SnowDivision_Lake! c, remainders', &
-                           'dztot, snwicetot, snwliqtot = ',c,dztot(fc),snwicetot(fc),snwliqtot(fc)
+                           'dztot, snwicetot, snwliqtot = ',c,dztot(c),snwicetot(c),snwliqtot(c)
                       call endrun(decomp_index=c, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
 #endif
                    end if
@@ -2385,7 +2120,6 @@ contains
           end do
        end if
 
-       !$acc parallel loop independent gang vector default(present) collapse(2) 
        do j = 0, -nlevsno+1, -1
           do fc = 1, num_snowc
              c = filter_snowc(fc)
@@ -2396,25 +2130,6 @@ contains
           end do
        end do
 
-     !$acc exit data delete(&
-     !$acc dzsno(:,:), &
-     !$acc swice(:,:), &
-     !$acc swliq(:,:), &
-     !$acc tsno(:,:), &
-     !$acc mbc_phi(:,:), &
-     !$acc mbc_pho(:,:), &
-     !$acc moc_phi(:,:), &
-     !$acc moc_pho(:,:), &
-     !$acc mdst1(:,:), &
-     !$acc mdst2(:,:), &
-     !$acc mdst3(:,:), &
-     !$acc mdst4(:,:), &
-     !$acc rds(:,:), &
-     !$acc dztot(:), &
-     !$acc snwicetot(:), &
-     !$acc snwliqtot(:), &
-     !$acc msno)
-
      end associate
 
    end subroutine DivideExtraSnowLayers   
@@ -2635,7 +2350,7 @@ contains
    end subroutine SnowCapping
    
    !-----------------------------------------------------------------------
-   subroutine NewSnowBulkDensity(bounds, num_c, filter_c, top_as, bifall)
+   subroutine NewSnowBulkDensity(bounds, num_c, filter_c, top_as_inst, bifall)
       ! (subroutine from CLMv5)
       ! !DESCRIPTION:
       ! Compute the bulk density of any newly-fallen snow.
@@ -2650,7 +2365,7 @@ contains
       type(bounds_type)  , intent(in)    :: bounds
       integer            , intent(in)    :: num_c                ! number of columns in filterc
       integer            , intent(in)    :: filter_c(:)          ! column-level filter to operate on
-      type(topounit_atmospheric_state) , intent(in)   :: top_as  
+      type(topounit_atmospheric_state) , intent(in)   :: top_as_inst  
       real(r8)           , intent(inout) :: bifall(bounds%begc:) ! bulk density of newly fallen dry snow [kg/m3]
       !
       ! !LOCAL VARIABLES:
@@ -2660,8 +2375,8 @@ contains
       character(len=*), parameter :: subname = 'NewSnowBulkDensity'
       !-----------------------------------------------------------------------
 
-      associate(forc_t    => top_as%tbot   , & ! Input:  [real(r8) (:) ]  atmospheric temperature (Kelvin)
-                forc_wind => top_as%windbot  & ! Input:  [real(r8) (:) ]  atmospheric wind speed (m/s)
+      associate(forc_t    => top_as_inst%tbot   , & ! Input:  [real(r8) (:) ]  atmospheric temperature (Kelvin)
+                forc_wind => top_as_inst%windbot  & ! Input:  [real(r8) (:) ]  atmospheric wind speed (m/s)
                 )
 
       do fc = 1, num_c
@@ -2719,7 +2434,6 @@ contains
      ! !USES:
      !
      ! !ARGUMENTS:
-      !$acc routine seq 
      real(r8) , intent(in)    :: bi              ! partial density of ice [kg/m3]
      real(r8) , intent(in)    :: forc_wind       ! atmospheric wind speed [m/s]
      real(r8) , intent(in)    :: dz              ! layer depth for this column and level [m]
@@ -2827,7 +2541,7 @@ contains
      ! (from CLMv5)
      ! !DESCRIPTION:
      ! Calculate the mass weighted snow radius when two layers are combined
-     !$acc routine seq 
+     !
      ! !USES:
      use AerosolMod   , only : snw_rds_min
      use SnowSnicarMod, only : snw_rds_max
@@ -2849,7 +2563,7 @@ contains
    end function MassWeightedSnowRadius
    !-----------------------------------------------------------------------
    
-   subroutine BuildSnowFilter(num_nolakec, filter_nolakec, &
+   subroutine BuildSnowFilter(bounds, num_nolakec, filter_nolakec, &
         num_snowc, filter_snowc, num_nosnowc, filter_nosnowc)
      !
      ! !DESCRIPTION:
@@ -2858,6 +2572,8 @@ contains
      ! !USES:
      !
      ! !ARGUMENTS:
+      !$acc routine seq
+     type(bounds_type) , intent(in)  :: bounds
      integer           , intent(in)  :: num_nolakec       ! number of column non-lake points in column filter
      integer           , intent(in)  :: filter_nolakec(:) ! column filter for non-lake points
      integer           , intent(out) :: num_snowc         ! number of column snow points in column filter
@@ -2866,40 +2582,23 @@ contains
      integer           , intent(out) :: filter_nosnowc(:) ! column filter for non-snow points
      !
      ! !LOCAL VARIABLES:
-     integer  :: fc, c, fsnow, fnosnow 
-     integer :: snow_tot, nosnow_tot
+     integer  :: fc, c
      !-----------------------------------------------------------------------
 
      ! Build snow/no-snow filters for other subroutines
-     !$acc enter data create(fsnow, fnosnow)
 
-     snow_tot = 0
-     nosnow_tot = 0
-     !$acc parallel loop independent gang vector present(filter_snowc(:),filter_nosnowc(:),filter_nolakec(:)) &
-     !$acc private(fsnow,fnosnow) copy(snow_tot, nosnow_tot)
+     num_snowc = 0
+     num_nosnowc = 0
      do fc = 1, num_nolakec
-      
         c = filter_nolakec(fc)
         if (col_pp%snl(c) < 0) then
-            !$acc atomic capture 
-            snow_tot = snow_tot + 1
-            fsnow = snow_tot 
-            !$acc end atomic 
-            filter_snowc(fsnow) = c
+           num_snowc = num_snowc + 1
+           filter_snowc(num_snowc) = c
         else
-            !$acc atomic capture 
-            nosnow_tot = nosnow_tot + 1
-            fnosnow = nosnow_tot 
-            !$acc end atomic 
-            filter_nosnowc(fnosnow) = c
+           num_nosnowc = num_nosnowc + 1
+           filter_nosnowc(num_nosnowc) = c
         end if
      end do
-
-     num_snowc = snow_tot 
-     num_nosnowc = nosnow_tot
-
-     !$acc exit data delete(fsnow, fnosnow)
-
    end subroutine BuildSnowFilter
 
 end module SnowHydrologyMod
diff --git a/components/elm/src/biogeophys/SnowSnicarMod.F90 b/components/elm/src/biogeophys/SnowSnicarMod.F90
index ba8e42b6ff..3c7b569e2f 100644
--- a/components/elm/src/biogeophys/SnowSnicarMod.F90
+++ b/components/elm/src/biogeophys/SnowSnicarMod.F90
@@ -12,7 +12,7 @@ module SnowSnicarMod
   use shr_sys_mod     , only : shr_sys_flush
   use shr_log_mod     , only : errMsg => shr_log_errMsg
   use elm_varctl      , only : iulog, use_extrasnowlayers
-  use elm_varcon      , only : namec
+  use elm_varcon      , only : namec 
   use shr_const_mod   , only : SHR_CONST_RHOICE
   use abortutils      , only : endrun
   use decompMod       , only : bounds_type
@@ -28,7 +28,7 @@ module SnowSnicarMod
   save
   !
   ! !PUBLIC MEMBER FUNCTIONS:
-  public :: SNICAR_RT, SNICAR_AD_RT  ! Snow albedo and vertically-resolved solar absorption
+  public :: SNICAR_RT        ! Snow albedo and vertically-resolved solar absorption
   public :: SnowAge_grain    ! Snow effective grain size evolution
   public :: SnowAge_init     ! Initial read in of snow-aging file
   public :: SnowOptics_init  ! Initial read in of snow-optics file
@@ -75,6 +75,8 @@ module SnowSnicarMod
   !$acc declare copyin(idx_bcint_icerds_max)
 #endif
 
+
+
   integer,  parameter :: snw_rds_max_tbl = 1500          ! maximum effective radius defined in Mie lookup table [microns]
   integer,  parameter :: snw_rds_min_tbl = 30            ! minimium effective radius defined in Mie lookup table [microns]
   real(r8), parameter :: snw_rds_max     = 1500._r8      ! maximum allowed snow effective radius [microns]
@@ -120,12 +122,12 @@ module SnowSnicarMod
   real(r8) :: asm_prm_snw_dfs    (idx_Mie_snw_mx,numrad_snw);
   real(r8) :: ext_cff_mss_snw_dfs(idx_Mie_snw_mx,numrad_snw);
 
-  !$acc declare create(ss_alb_snw_drc     (:,:))
-  !$acc declare create(asm_prm_snw_drc    (:,:))
-  !$acc declare create(ext_cff_mss_snw_drc(:,:))
-  !$acc declare create(ss_alb_snw_dfs     (:,:))
-  !$acc declare create(asm_prm_snw_dfs    (:,:))
-  !$acc declare create(ext_cff_mss_snw_dfs(:,:))
+  !$acc declare create(ss_alb_snw_drc     )
+  !$acc declare create(asm_prm_snw_drc    )
+  !$acc declare create(ext_cff_mss_snw_drc)
+  !$acc declare create(ss_alb_snw_dfs     )
+  !$acc declare create(asm_prm_snw_dfs    )
+  !$acc declare create(ext_cff_mss_snw_dfs)
 
 #ifdef MODAL_AER
   !mgf++
@@ -138,9 +140,9 @@ module SnowSnicarMod
   real(r8) :: ss_alb_bc1     (numrad_snw,idx_bc_nclrds_max);
   real(r8) :: asm_prm_bc1    (numrad_snw,idx_bc_nclrds_max);
   real(r8) :: ext_cff_mss_bc1(numrad_snw,idx_bc_nclrds_max);
-  !$acc declare create(ss_alb_bc1     (:,:))
-  !$acc declare create(asm_prm_bc1    (:,:))
-  !$acc declare create(ext_cff_mss_bc1(:,:))
+  !$acc declare create(ss_alb_bc1     )
+  !$acc declare create(asm_prm_bc1    )
+  !$acc declare create(ext_cff_mss_bc1)
 
   ! external BC
   real(r8) :: ss_alb_bc2     (numrad_snw,idx_bc_nclrds_max);
@@ -155,17 +157,19 @@ module SnowSnicarMod
   real(r8) :: ss_alb_bc1     (numrad_snw);
   real(r8) :: asm_prm_bc1    (numrad_snw);
   real(r8) :: ext_cff_mss_bc1(numrad_snw);
-  !$acc declare create(ss_alb_bc1     (:))
-  !$acc declare create(asm_prm_bc1    (:))
-  !$acc declare create(ext_cff_mss_bc1(:))
+  !$acc declare create(ss_alb_bc1     )
+  !$acc declare create(asm_prm_bc1    )
+  !$acc declare create(ext_cff_mss_bc1)
 
   ! hydrophobic BC
   real(r8) :: ss_alb_bc2     (numrad_snw);
   real(r8) :: asm_prm_bc2    (numrad_snw);
   real(r8) :: ext_cff_mss_bc2(numrad_snw);
-  !$acc declare create(ss_alb_bc2     (:))
-  !$acc declare create(asm_prm_bc2    (:))
-  !$acc declare create(ext_cff_mss_bc2(:))
+  !$acc declare create(ss_alb_bc2     )
+  !$acc declare create(asm_prm_bc2    )
+  !$acc declare create(ext_cff_mss_bc2)
+
+
 #endif
 
 !  ! hydrophiliic BC
@@ -182,25 +186,25 @@ module SnowSnicarMod
   real(r8) :: ss_alb_oc1     (numrad_snw);
   real(r8) :: asm_prm_oc1    (numrad_snw);
   real(r8) :: ext_cff_mss_oc1(numrad_snw);
-  !$acc declare create(ss_alb_oc1     (:))
-  !$acc declare create(asm_prm_oc1    (:))
-  !$acc declare create(ext_cff_mss_oc1(:))
+  !$acc declare create(ss_alb_oc1     )
+  !$acc declare create(asm_prm_oc1    )
+  !$acc declare create(ext_cff_mss_oc1)
 
   ! hydrophilic OC
   real(r8) :: ss_alb_oc2     (numrad_snw);
   real(r8) :: asm_prm_oc2    (numrad_snw);
   real(r8) :: ext_cff_mss_oc2(numrad_snw);
-  !$acc declare create(ss_alb_oc2     (:))
-  !$acc declare create(asm_prm_oc2    (:))
-  !$acc declare create(ext_cff_mss_oc2(:))
+  !$acc declare create(ss_alb_oc2     )
+  !$acc declare create(asm_prm_oc2    )
+  !$acc declare create(ext_cff_mss_oc2)
 
   ! dust species 1:
   real(r8) :: ss_alb_dst1     (numrad_snw);
   real(r8) :: asm_prm_dst1    (numrad_snw);
   real(r8) :: ext_cff_mss_dst1(numrad_snw);
-  !$acc declare create(ss_alb_dst1     (:))
-  !$acc declare create(asm_prm_dst1    (:))
-  !$acc declare create(ext_cff_mss_dst1(:))
+  !$acc declare create(ss_alb_dst1     )
+  !$acc declare create(asm_prm_dst1    )
+  !$acc declare create(ext_cff_mss_dst1)
 
   ! dust species 2:
   real(r8) :: ss_alb_dst2     (numrad_snw);
@@ -214,24 +218,24 @@ module SnowSnicarMod
   real(r8) :: ss_alb_dst3     (numrad_snw);
   real(r8) :: asm_prm_dst3    (numrad_snw);
   real(r8) :: ext_cff_mss_dst3(numrad_snw);
-  !$acc declare create(ss_alb_dst3     (:))
-  !$acc declare create(asm_prm_dst3    (:))
-  !$acc declare create(ext_cff_mss_dst3(:))
+  !$acc declare create(ss_alb_dst3     )
+  !$acc declare create(asm_prm_dst3    )
+  !$acc declare create(ext_cff_mss_dst3)
 
   ! dust species 4:
   real(r8) :: ss_alb_dst4     (numrad_snw);
   real(r8) :: asm_prm_dst4    (numrad_snw);
   real(r8) :: ext_cff_mss_dst4(numrad_snw);
-  !$acc declare create(ss_alb_dst4     (:))
-  !$acc declare create(asm_prm_dst4    (:))
-  !$acc declare create(ext_cff_mss_dst4(:))
+  !$acc declare create(ss_alb_dst4     )
+  !$acc declare create(asm_prm_dst4    )
+  !$acc declare create(ext_cff_mss_dst4)
 
 
 #ifdef MODAL_AER
   !mgf++
   ! Absorption enhancement factors for within-ice BC
   real(r8) :: bcenh(numrad_snw,idx_bc_nclrds_max,idx_bcint_icerds_max);
-  !$acc declare create(bcenh(:,:,:))
+  !$acc declare create(bcenh)
   !mgf--
 #endif
 
@@ -254,7 +258,7 @@ module SnowSnicarMod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine SNICAR_RT (flg_snw_ice, fc, num_nourbanc, filter_nourbanc,  &
+  subroutine SNICAR_RT (flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,  &
                         coszen, flg_slr_in, h2osno_liq, h2osno_ice, snw_rds,   &
                         mss_cnc_aer_in, albsfc, albout, flx_abs)
     !
@@ -277,24 +281,24 @@ contains
     ! J. Geophys. Res., 112, D11202, doi: 10.1029/2006JD008003
     !
     ! !USES:
-    !!   !$acc routine seq
+      !$acc routine seq
     use elm_varpar       , only : nlevsno, numrad
     use shr_const_mod    , only : SHR_CONST_PI
     !
     ! !ARGUMENTS:
-    integer, value    , intent(in)  :: flg_snw_ice                     ! flag: =1 when called from CLM, =2 when called from CSIM
-    integer, value    , intent(in)  :: fc
-    integer, value    , intent(in)  :: num_nourbanc                    ! number of columns in non-urban filter
-    integer           , intent(in)  :: filter_nourbanc(:)              ! column filter for non-urban points
-    real(r8) , value  , intent(in)  :: coszen                          ! cosine of solar zenith angle for next time step (col) [unitless]
-    integer  , value  , intent(in)  :: flg_slr_in                      ! flag: =1 for direct-beam incident flux,=2 for diffuse incident flux
-    real(r8)          , intent(in)  :: h2osno_liq     ( -nlevsno+1: )      ! liquid water content (col,lyr) [kg/m2]
-    real(r8)          , intent(in)  :: h2osno_ice     ( -nlevsno+1: )      ! ice content (col,lyr) [kg/m2]
-    integer           , intent(in)  :: snw_rds        ( -nlevsno+1: )      ! snow effective radius (col,lyr) [microns, m^-6]
-    real(r8)          , intent(in)  :: mss_cnc_aer_in ( -nlevsno+1: , 1: ) ! mass concentration of all aerosol species (col,lyr,aer) [kg/kg]
-    real(r8)          , intent(in)  :: albsfc         ( 1: )               ! albedo of surface underlying snow (col,bnd) [frc]
-    real(r8)          , intent(out) :: albout         ( 1: )               ! snow albedo, averaged into 2 bands (=0 if no sun or no snow) (col,bnd) [frc]
-    real(r8)          , intent(out) :: flx_abs        ( -nlevsno+1: , 1: ) ! absorbed flux in each layer per unit flux incident (col, lyr, bnd)
+    integer           , intent(in)  :: flg_snw_ice                                        ! flag: =1 when called from CLM, =2 when called from CSIM
+    type (bounds_type), intent(in)  :: bounds
+    integer           , intent(in)  :: num_nourbanc                                       ! number of columns in non-urban filter
+    integer           , intent(in)  :: filter_nourbanc(:)                                 ! column filter for non-urban points
+    real(r8)          , intent(in)  :: coszen         ( bounds%begc: )                    ! cosine of solar zenith angle for next time step (col) [unitless]
+    integer           , intent(in)  :: flg_slr_in                                         ! flag: =1 for direct-beam incident flux,=2 for diffuse incident flux
+    real(r8)          , intent(in)  :: h2osno_liq     ( bounds%begc: , -nlevsno+1: )      ! liquid water content (col,lyr) [kg/m2]
+    real(r8)          , intent(in)  :: h2osno_ice     ( bounds%begc: , -nlevsno+1: )      ! ice content (col,lyr) [kg/m2]
+    integer           , intent(in)  :: snw_rds        ( bounds%begc: , -nlevsno+1: )      ! snow effective radius (col,lyr) [microns, m^-6]
+    real(r8)          , intent(in)  :: mss_cnc_aer_in ( bounds%begc: , -nlevsno+1: , 1: ) ! mass concentration of all aerosol species (col,lyr,aer) [kg/kg]
+    real(r8)          , intent(in)  :: albsfc         ( bounds%begc: , 1: )               ! albedo of surface underlying snow (col,bnd) [frc]
+    real(r8)          , intent(out) :: albout         ( bounds%begc: , 1: )               ! snow albedo, averaged into 2 bands (=0 if no sun or no snow) (col,bnd) [frc]
+    real(r8)          , intent(out) :: flx_abs        ( bounds%begc: , -nlevsno+1: , 1: ) ! absorbed flux in each layer per unit flux incident (col, lyr, bnd)
     !
     ! !LOCAL VARIABLES:
     !
@@ -303,13 +307,13 @@ contains
     ! Local variables representing single-column values of arrays:
     integer :: snl_lcl                            ! negative number of snow layers [nbr]
     integer :: snw_rds_lcl(-nlevsno+1:0)          ! snow effective radius [m^-6]
-    real(r8):: flx_slrd_lcl          ! direct beam incident irradiance [W/m2] (set to 1)
-    real(r8):: flx_slri_lcl          ! diffuse incident irradiance [W/m2] (set to 1)
-    !real(r8):: mss_cnc_aer_lcl(-nlevsno+1:0,1:sno_nbr_aer) ! aerosol mass concentration (lyr,aer_nbr) [kg/kg]
+    real(r8):: flx_slrd_lcl(1:numrad_snw)         ! direct beam incident irradiance [W/m2] (set to 1)
+    real(r8):: flx_slri_lcl(1:numrad_snw)         ! diffuse incident irradiance [W/m2] (set to 1)
+    real(r8):: mss_cnc_aer_lcl(-nlevsno+1:0,1:sno_nbr_aer) ! aerosol mass concentration (lyr,aer_nbr) [kg/kg]
     real(r8):: h2osno_lcl                         ! total column snow mass [kg/m2]
     real(r8):: h2osno_liq_lcl(-nlevsno+1:0)       ! liquid water mass [kg/m2]
     real(r8):: h2osno_ice_lcl(-nlevsno+1:0)       ! ice mass [kg/m2]
-    real(r8):: albsfc_lcl           ! albedo of underlying surface [frc]
+    real(r8):: albsfc_lcl(1:numrad_snw)           ! albedo of underlying surface [frc]
     real(r8):: ss_alb_snw_lcl(-nlevsno+1:0)       ! single-scatter albedo of ice grains (lyr) [frc]
     real(r8):: asm_prm_snw_lcl(-nlevsno+1:0)      ! asymmetry parameter of ice grains (lyr) [frc]
     real(r8):: ext_cff_mss_snw_lcl(-nlevsno+1:0)  ! mass extinction coefficient of ice grains (lyr) [m2/kg]
@@ -319,8 +323,8 @@ contains
 
 #ifdef MODAL_AER
     !mgf++
-    real(r8) :: rds_bcint_lcl       ! effective radius of within-ice BC [nm]
-    real(r8) :: rds_bcext_lcl       ! effective radius of external BC [nm]
+    real(r8) :: rds_bcint_lcl(-nlevsno+1:0)       ! effective radius of within-ice BC [nm]
+    real(r8) :: rds_bcext_lcl(-nlevsno+1:0)       ! effective radius of external BC [nm]
     !mgf--
 #endif
 
@@ -343,10 +347,10 @@ contains
     real(r8):: albout_lcl(numrad_snw)             ! snow albedo by band [frc]
     real(r8):: flx_abs_lcl(-nlevsno+1:1,numrad_snw)! absorbed flux per unit incident flux at top of snowpack (lyr,bnd) [frc]
 
-    real(r8):: L_snw     ! h2o mass (liquid+solid) in snow layer (lyr) [kg/m2]
-    real(r8):: tau_snw   ! snow optical depth (lyr) [unitless]
-    real(r8):: L_aer     ! aerosol mass in snow layer (lyr,nbr_aer) [kg/m2]
-    real(r8):: tau_aer   ! aerosol optical depth (lyr,nbr_aer) [unitless]
+    real(r8):: L_snw(-nlevsno+1:0)                ! h2o mass (liquid+solid) in snow layer (lyr) [kg/m2]
+    real(r8):: tau_snw(-nlevsno+1:0)              ! snow optical depth (lyr) [unitless]
+    real(r8):: L_aer(-nlevsno+1:0,sno_nbr_aer)    ! aerosol mass in snow layer (lyr,nbr_aer) [kg/m2]
+    real(r8):: tau_aer(-nlevsno+1:0,sno_nbr_aer)  ! aerosol optical depth (lyr,nbr_aer) [unitless]
     real(r8):: tau_sum                            ! cumulative (snow+aerosol) optical depth [unitless]
     real(r8):: tau_elm(-nlevsno+1:0)              ! column optical depth from layer bottom to snowpack top (lyr) [unitless]
     real(r8):: omega_sum                          ! temporary summation of single-scatter albedo of all aerosols [frc]
@@ -367,11 +371,13 @@ contains
                                                   ! Mie parameters from lookup table [idx]
     integer :: snl_btm                            ! index of bottom snow layer (0) [idx]
     integer :: snl_top                            ! index of top snow layer (-4 to 0) [idx]
+    integer :: fc                                 ! column filter index
     integer :: i                                  ! layer index [idx]
     integer :: j                                  ! aerosol number index [idx]
     integer :: n                                  ! tridiagonal matrix index [idx]
     integer :: m                                  ! secondary layer index [idx]
-
+    integer :: nint_snw_rds_min                   ! nearest integer value of snw_rds_min
+    
     real(r8):: F_direct(-nlevsno+1:0)             ! direct-beam radiation at bottom of layer interface (lyr) [W/m^2]
     real(r8):: F_net(-nlevsno+1:0)                ! net radiative flux at bottom of layer interface (lyr) [W/m^2]
     real(r8):: F_abs(-nlevsno+1:0)                ! net absorbed radiative energy (lyr) [W/m^2]
@@ -389,6 +395,8 @@ contains
     integer :: sfctype                            ! underlying surface type (debugging only)
     real(r8):: pi                                 ! 3.1415...
 
+    integer :: nstep
+
     ! intermediate variables for radiative transfer approximation:
     real(r8):: gamma1(-nlevsno+1:0)               ! two-stream coefficient from Toon et al. (lyr) [unitless]
     real(r8):: gamma2(-nlevsno+1:0)               ! two-stream coefficient from Toon et al. (lyr) [unitless]
@@ -411,7 +419,7 @@ contains
     real(r8):: E(-2*nlevsno+1:0)                  ! tri-diag intermediate variable from Toon et al. (2*lyr)
     real(r8):: AS(-2*nlevsno+1:0)                 ! tri-diag intermediate variable from Toon et al. (2*lyr)
     real(r8):: DS(-2*nlevsno+1:0)                 ! tri-diag intermediate variable from Toon et al. (2*lyr)
-    real(r8):: X_i!(-2*nlevsno+1:0)                  ! tri-diag intermediate variable from Toon et al. (2*lyr)
+    real(r8):: X(-2*nlevsno+1:0)                  ! tri-diag intermediate variable from Toon et al. (2*lyr)
     real(r8):: Y(-2*nlevsno+1:0)                  ! tri-diag intermediate variable from Toon et al. (2*lyr)
     !-----------------------------------------------------------------------
 #ifdef MODAL_AER
@@ -424,37 +432,42 @@ contains
     !mgf--
 #endif
 
+    ! Enforce expected array sizes
+
     associate(&
          snl         =>   col_pp%snl     , & ! Input:  [integer (:)]  negative number of snow layers (col) [nbr]
+
          h2osno      =>   col_ws%h2osno        , & ! Input:  [real(r8) (:)]  snow liquid water equivalent (col) [kg/m2]
          frac_sno    =>   col_ws%frac_sno_eff    & ! Input:  [real(r8) (:)]  fraction of ground covered by snow (0 to 1)
          )
 
       ! Define constants
       pi = SHR_CONST_PI
+      nint_snw_rds_min = nint(snw_rds_min)
 
       ! always use Delta approximation for snow
       DELTA = 1
 
       ! Get current timestep
-      ! nstep = nstep_mod
+      nstep = nstep_mod
 
       ! Loop over all non-urban columns
       ! (when called from CSIM, there is only one column)
-      !do fc = 1,num_nourbanc
+      do fc = 1,num_nourbanc
          c_idx = filter_nourbanc(fc)
 
+
          ! Zero absorbed radiative fluxes:
-         flx_abs_lcl(:,:)   = 0._r8
          do i=-nlevsno+1,1,1
-            flx_abs(i,:) = 0._r8
+            flx_abs_lcl(:,:)   = 0._r8
+            flx_abs(c_idx,i,:) = 0._r8
          enddo
 
          ! set snow/ice mass to be used for RT:
          if (flg_snw_ice == 1) then
             h2osno_lcl = h2osno(c_idx)
          else
-            h2osno_lcl = h2osno_ice(0)
+            h2osno_lcl = h2osno_ice(c_idx,0)
          endif
 
 
@@ -462,9 +475,9 @@ contains
          !  1) sunlight from atmosphere model
          !  2) minimum amount of snow on ground.
          !     Otherwise, set snow albedo to zero
-         if ( (coszen  > 0._r8) .and. (h2osno_lcl > min_snw) ) then
+         if ((coszen(c_idx) > 0._r8) .and. (h2osno_lcl > min_snw)) then
 
-            ! Set variables specific to ELM
+            ! Set variables specific to CLM
             if (flg_snw_ice == 1) then
                ! If there is snow, but zero snow layers, we must create a layer locally.
                ! This layer is presumed to have the fresh snow effective radius.
@@ -473,13 +486,13 @@ contains
                   snl_lcl           =  -1
                   h2osno_ice_lcl(0) =  h2osno_lcl
                   h2osno_liq_lcl(0) =  0._r8
-                  snw_rds_lcl(0)    =  nint(snw_rds_min)
+                  snw_rds_lcl(0)    =  nint_snw_rds_min
                else
                   flg_nosnl         =  0
                   snl_lcl           =  snl(c_idx)
-                  h2osno_liq_lcl(:) =  h2osno_liq(:)
-                  h2osno_ice_lcl(:) =  h2osno_ice(:)
-                  snw_rds_lcl(:)    =  snw_rds(:)
+                  h2osno_liq_lcl(:) =  h2osno_liq(c_idx,:)
+                  h2osno_ice_lcl(:) =  h2osno_ice(c_idx,:)
+                  snw_rds_lcl(:)    =  snw_rds(c_idx,:)
                endif
 
                snl_btm   = 0
@@ -497,9 +510,9 @@ contains
             else
                flg_nosnl         = 0
                snl_lcl           = -1
-               h2osno_liq_lcl(:) = h2osno_liq(:)
-               h2osno_ice_lcl(:) = h2osno_ice(:)
-               snw_rds_lcl(:)    = snw_rds(:)
+               h2osno_liq_lcl(:) = h2osno_liq(c_idx,:)
+               h2osno_ice_lcl(:) = h2osno_ice(c_idx,:)
+               snw_rds_lcl(:)    = snw_rds(c_idx,:)
                snl_btm           = 0
                snl_top           = 0
                sfctype           = -1
@@ -515,16 +528,28 @@ contains
           ! 40nm) assumed for freshly-emitted BC in MAM.  Future
           ! implementations may prognose the BC effective radius in
           ! snow.
-          rds_bcint_lcl  =  100._r8
-          rds_bcext_lcl  =  100._r8
+          rds_bcint_lcl(:)  =  100._r8
+          rds_bcext_lcl(:)  =  100._r8
           !mgf--
 #endif
 
+            ! Set local aerosol array
+            do j=1,sno_nbr_aer
+               mss_cnc_aer_lcl(:,j) = mss_cnc_aer_in(c_idx,:,j)
+            enddo
+
+
+            ! Set spectral underlying surface albedos to their corresponding VIS or NIR albedos
+            albsfc_lcl(1)                       = albsfc(c_idx,1)
+            albsfc_lcl(nir_bnd_bgn:nir_bnd_end) = albsfc(c_idx,2)
+
+
             ! Error check for snow grain size:
 #ifndef _OPENACC
             do i=snl_top,snl_btm,1
                if ((snw_rds_lcl(i) < snw_rds_min_tbl) .or. (snw_rds_lcl(i) > snw_rds_max_tbl)) then
                   write (iulog,*)  "SNICAR ERROR: snow grain radius of out of bounds."
+                  write (iulog,*) "NSTEP= ", nstep
                   write (iulog,*) "flg_snw_ice= ", flg_snw_ice
                   write (iulog,*) "column: ", c_idx, " level: ", i, " snl(c)= ", snl_lcl
                   write (iulog,*) "lat= ", lat_coord, " lon= ", lon_coord
@@ -532,7 +557,7 @@ contains
                   call endrun(decomp_index=c_idx, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
                endif
             enddo
-#endif
+#endif _OPENACC
 
             ! Incident flux weighting parameters
             !  - sum of all VIS bands must equal 1
@@ -583,15 +608,9 @@ contains
             ! Loop over snow spectral bands
             do bnd_idx = 1,numrad_snw
 
-               ! Set spectral underlying surface albedos to their corresponding VIS or NIR albedos
-              if(bnd_idx == 1) then
-                albsfc_lcl = albsfc(1)
-              else
-                albsfc_lcl = albsfc(2)
-             end if
-                mu_not    = coszen  ! must set here, because of error handling
-                flg_dover = 1       ! default is to redo
-                err_idx   = 0       ! number of times through loop
+               mu_not    = coszen(c_idx)  ! must set here, because of error handling
+               flg_dover = 1              ! default is to redo
+               err_idx   = 0              ! number of times through loop
 
                do while (flg_dover > 0)
 
@@ -618,7 +637,7 @@ contains
                         APRX_TYP = 3
                      elseif (flg_dover == 3) then
                         APRX_TYP = 1
-                        if (coszen  > 0.5_r8) then
+                        if (coszen(c_idx) > 0.5_r8) then
                            mu_not = mu_not - 0.02_r8
                         else
                            mu_not = mu_not + 0.02_r8
@@ -634,7 +653,7 @@ contains
                         APRX_TYP = 1
                      elseif (flg_dover == 3) then
                         APRX_TYP = 3
-                        if (coszen  > 0.5_r8) then
+                        if (coszen(c_idx) > 0.5_r8) then
                            mu_not = mu_not - 0.02_r8
                         else
                            mu_not = mu_not + 0.02_r8
@@ -650,22 +669,22 @@ contains
                   ! Set direct or diffuse incident irradiance to 1
                   ! (This has to be within the bnd loop because mu_not is adjusted in rare cases)
                   if (flg_slr_in == 1) then
-                     flx_slrd_lcl = 1._r8/(mu_not*pi) ! this corresponds to incident irradiance of 1.0
-                     flx_slri_lcl = 0._r8
+                     flx_slrd_lcl(bnd_idx) = 1._r8/(mu_not*pi) ! this corresponds to incident irradiance of 1.0
+                     flx_slri_lcl(bnd_idx) = 0._r8
                   else
-                     flx_slrd_lcl = 0._r8
-                     flx_slri_lcl = 1._r8
+                     flx_slrd_lcl(bnd_idx) = 0._r8
+                     flx_slri_lcl(bnd_idx) = 1._r8
                   endif
 
                   ! Pre-emptive error handling: aerosols can reap havoc on these absorptive bands.
                   ! Since extremely high soot concentrations have a negligible effect on these bands, zero them.
-                  ! if ( (numrad_snw == 5).and.((bnd_idx == 5).or.(bnd_idx == 4)) ) then
-                  !    mss_cnc_aer_lcl(:,:) = 0._r8
-                  ! endif
-                  !
-                  ! if ( (numrad_snw == 3).and.(bnd_idx == 3) ) then
-                  !    mss_cnc_aer_lcl(:,:) = 0._r8
-                  ! endif
+                  if ( (numrad_snw == 5).and.((bnd_idx == 5).or.(bnd_idx == 4)) ) then
+                     mss_cnc_aer_lcl(:,:) = 0._r8
+                  endif
+
+                  if ( (numrad_snw == 3).and.(bnd_idx == 3) ) then
+                     mss_cnc_aer_lcl(:,:) = 0._r8
+                  endif
 
                   ! Define local Mie parameters based on snow grain size and aerosol species,
                   !  retrieved from a lookup table.
@@ -687,7 +706,7 @@ contains
                      enddo
                   endif
 
-                  !H. Wang
+!H. Wang
                   ! aerosol species 1 optical properties
                  ! ss_alb_aer_lcl(1)        = ss_alb_bc1(bnd_idx)
                  ! asm_prm_aer_lcl(1)       = asm_prm_bc1(bnd_idx)
@@ -697,7 +716,7 @@ contains
                  ! ss_alb_aer_lcl(2)        = ss_alb_bc2(bnd_idx)
                  ! asm_prm_aer_lcl(2)       = asm_prm_bc2(bnd_idx)
                  ! ext_cff_mss_aer_lcl(2)   = ext_cff_mss_bc2(bnd_idx)
-                 !H. Wang
+!H. Wang
                   ! aerosol species 3 optical properties
                   ss_alb_aer_lcl(3)        = ss_alb_oc1(bnd_idx)
                   asm_prm_aer_lcl(3)       = asm_prm_oc1(bnd_idx)
@@ -754,8 +773,8 @@ contains
                    endif
 
                    ! valid for 25 < bc_rds < 525 nm
-                   idx_bcint_nclrds = nint(rds_bcint_lcl/50)
-                   idx_bcext_nclrds = nint(rds_bcext_lcl/50)
+                   idx_bcint_nclrds = nint(rds_bcint_lcl(i)/50)
+                   idx_bcext_nclrds = nint(rds_bcext_lcl(i)/50)
 
                    ! check bounds:
                    if (idx_bcint_icerds < idx_bcint_icerds_min) idx_bcint_icerds = idx_bcint_icerds_min
@@ -765,6 +784,9 @@ contains
                    if (idx_bcext_nclrds < idx_bc_nclrds_min) idx_bcext_nclrds = idx_bc_nclrds_min
                    if (idx_bcext_nclrds > idx_bc_nclrds_max) idx_bcext_nclrds = idx_bc_nclrds_max
 
+                   ! print ice index (debug):
+                   !write(iulog,*) "MGF: ice index= ", idx_bcint_icerds
+
                    ! retrieve absorption enhancement factor for within-ice BC
                    enh_fct = bcenh(bnd_idx,idx_bcint_nclrds,idx_bcint_icerds)
 
@@ -794,39 +816,30 @@ contains
 #endif
                    !mgf--
 
-                     L_snw   = h2osno_ice_lcl(i)+h2osno_liq_lcl(i)
-                     tau_snw = L_snw * ext_cff_mss_snw_lcl(i)
 
-                     ! do j=1,sno_nbr_aer
-                     !    L_aer   = L_snw * mss_cnc_aer_lcl(i,j)
-                     !    tau_aer = L_aer *ext_cff_mss_aer_lcl(j)
-                     ! enddo
+
+                     L_snw(i)   = h2osno_ice_lcl(i)+h2osno_liq_lcl(i)
+                     tau_snw(i) = L_snw(i)*ext_cff_mss_snw_lcl(i)
+
+                     do j=1,sno_nbr_aer
+                        L_aer(i,j)   = L_snw(i)*mss_cnc_aer_lcl(i,j)
+                        tau_aer(i,j) = L_aer(i,j)*ext_cff_mss_aer_lcl(j)
+                     enddo
 
                      tau_sum   = 0._r8
                      omega_sum = 0._r8
                      g_sum     = 0._r8
 
                      do j=1,sno_nbr_aer
-
-                        if ( (numrad_snw == 5).and.((bnd_idx == 5).or.(bnd_idx == 4)) ) then
-                            L_aer = 0._r8
-                        elseif ( (numrad_snw == 3).and.(bnd_idx == 3) ) then
-                            L_aer = 0._r8
-                        else
-                            L_aer = L_snw * mss_cnc_aer_in(i,j)
-                        end if
-
-                        tau_aer  = L_aer * ext_cff_mss_aer_lcl(j)
-                        !
-                        tau_sum    = tau_sum + tau_aer
-                        omega_sum  = omega_sum + (tau_aer * ss_alb_aer_lcl(j))
-                        g_sum      = g_sum + (tau_aer * ss_alb_aer_lcl(j) * asm_prm_aer_lcl(j))
+                        tau_sum    = tau_sum + tau_aer(i,j)
+                        omega_sum  = omega_sum + (tau_aer(i,j)*ss_alb_aer_lcl(j))
+                        g_sum      = g_sum + (tau_aer(i,j)*ss_alb_aer_lcl(j)*asm_prm_aer_lcl(j))
                      enddo
 
-                     tau(i)    = tau_sum + tau_snw
-                     omega(i)  = (1/tau(i))*(omega_sum+(ss_alb_snw_lcl(i)*tau_snw ))
-                     g(i)      = (1/(tau(i)*omega(i)))*(g_sum+ (asm_prm_snw_lcl(i)*ss_alb_snw_lcl(i)*tau_snw))
-                  enddo  ! end MIE weights
+                     tau(i)    = tau_sum + tau_snw(i)
+                     omega(i)  = (1/tau(i))*(omega_sum+(ss_alb_snw_lcl(i)*tau_snw(i)))
+                     g(i)      = (1/(tau(i)*omega(i)))*(g_sum+ (asm_prm_snw_lcl(i)*ss_alb_snw_lcl(i)*tau_snw(i)))
+                  enddo
 
                   ! DELTA transformations, if requested
                   if (DELTA == 1) then
@@ -851,8 +864,8 @@ contains
                   enddo
 
                   ! Direct radiation at bottom of snowpack:
-                  F_direct_btm = albsfc_lcl*mu_not * &
-                       exp(-(tau_elm(snl_btm)+tau_star(snl_btm))/mu_not)*pi*flx_slrd_lcl
+                  F_direct_btm = albsfc_lcl(bnd_idx)*mu_not * &
+                       exp(-(tau_elm(snl_btm)+tau_star(snl_btm))/mu_not)*pi*flx_slrd_lcl(bnd_idx)
 
                   ! Intermediates
                   ! Gamma values are approximation-specific.
@@ -904,21 +917,21 @@ contains
                   do i=snl_top,snl_btm,1
                      if (flg_slr_in == 1) then
 
-                        C_pls_btm(i) = (omega_star(i)*pi*flx_slrd_lcl* &
+                        C_pls_btm(i) = (omega_star(i)*pi*flx_slrd_lcl(bnd_idx)* &
                              exp(-(tau_elm(i)+tau_star(i))/mu_not)*   &
                              (((gamma1(i)-(1/mu_not))*gamma3(i))+     &
                              (gamma4(i)*gamma2(i))))/((lambda(i)**2)-(1/(mu_not**2)))
 
-                        C_mns_btm(i) = (omega_star(i)*pi*flx_slrd_lcl* &
+                        C_mns_btm(i) = (omega_star(i)*pi*flx_slrd_lcl(bnd_idx)* &
                              exp(-(tau_elm(i)+tau_star(i))/mu_not)*   &
                              (((gamma1(i)+(1/mu_not))*gamma4(i))+     &
                              (gamma2(i)*gamma3(i))))/((lambda(i)**2)-(1/(mu_not**2)))
 
-                        C_pls_top(i) = (omega_star(i)*pi*flx_slrd_lcl* &
+                        C_pls_top(i) = (omega_star(i)*pi*flx_slrd_lcl(bnd_idx)* &
                              exp(-tau_elm(i)/mu_not)*(((gamma1(i)-(1/mu_not))* &
                              gamma3(i))+(gamma4(i)*gamma2(i))))/((lambda(i)**2)-(1/(mu_not**2)))
 
-                        C_mns_top(i) = (omega_star(i)*pi*flx_slrd_lcl* &
+                        C_mns_top(i) = (omega_star(i)*pi*flx_slrd_lcl(bnd_idx)* &
                              exp(-tau_elm(i)/mu_not)*(((gamma1(i)+(1/mu_not))* &
                              gamma4(i))+(gamma2(i)*gamma3(i))))/((lambda(i)**2)-(1/(mu_not**2)))
 
@@ -938,13 +951,13 @@ contains
                         A(i) = 0
                         B(i) = e1(snl_top)
                         D(i) = -e2(snl_top)
-                        E(i) = flx_slri_lcl - C_mns_top(snl_top)
+                        E(i) = flx_slri_lcl(bnd_idx)-C_mns_top(snl_top)
 
                      elseif(i==0) then
-                        A(i) = e1(snl_btm)-(albsfc_lcl * e3(snl_btm))
-                        B(i) = e2(snl_btm)-(albsfc_lcl * e4(snl_btm))
+                        A(i) = e1(snl_btm)-(albsfc_lcl(bnd_idx)*e3(snl_btm))
+                        B(i) = e2(snl_btm)-(albsfc_lcl(bnd_idx)*e4(snl_btm))
                         D(i) = 0
-                        E(i) = F_direct_btm-C_pls_btm(snl_btm)+(albsfc_lcl*C_mns_btm(snl_btm))
+                        E(i) = F_direct_btm-C_pls_btm(snl_btm)+(albsfc_lcl(bnd_idx)*C_mns_btm(snl_btm))
 
                      elseif(mod(i,2)==-1) then   ! If odd and i>=3 (n=1 for i=3)
                         n=floor(i/2.0)
@@ -966,9 +979,9 @@ contains
                   DS(0) = E(0)/B(0)
 
                   do i=-1,(2*snl_lcl+1),-1
-                     X_i  = 1/(B(i)-(D(i)*AS(i+1)))
-                     AS(i) = A(i)*X_i
-                     DS(i) = (E(i)-(D(i)*DS(i+1)))*X_i
+                     X(i)  = 1/(B(i)-(D(i)*AS(i+1)))
+                     AS(i) = A(i)*X(i)
+                     DS(i) = (E(i)-(D(i)*DS(i+1)))*X(i)
                   enddo
 
                   Y(2*snl_lcl+1) = DS(2*snl_lcl+1)
@@ -978,7 +991,7 @@ contains
 
                   ! Downward direct-beam and net flux (F_net) at the base of each layer:
                   do i=snl_top,snl_btm,1
-                     F_direct(i) = mu_not*pi*flx_slrd_lcl*exp(-(tau_elm(i)+tau_star(i))/mu_not)
+                     F_direct(i) = mu_not*pi*flx_slrd_lcl(bnd_idx)*exp(-(tau_elm(i)+tau_star(i))/mu_not)
                      F_net(i)    = (Y(2*i-1)*(e1(i)-e3(i))) + (Y(2*i)*(e2(i)-e4(i))) + &
                           C_pls_btm(i) - C_mns_btm(i) - F_direct(i)
                   enddo
@@ -993,8 +1006,8 @@ contains
 
 
                   ! Bulk column albedo and surface net flux
-                  albedo    = F_sfc_pls/((mu_not*pi*flx_slrd_lcl)+flx_slri_lcl)
-                  F_sfc_net = F_sfc_pls - ((mu_not*pi*flx_slrd_lcl)+flx_slri_lcl)
+                  albedo    = F_sfc_pls/((mu_not*pi*flx_slrd_lcl(bnd_idx))+flx_slri_lcl(bnd_idx))
+                  F_sfc_net = F_sfc_pls - ((mu_not*pi*flx_slrd_lcl(bnd_idx))+flx_slri_lcl(bnd_idx))
 
                   trip = 0
                   ! Absorbed flux in each layer
@@ -1067,9 +1080,15 @@ contains
                      flg_dover = 0
 #ifndef _OPENACC
                      write(iulog,*) "SNICAR ERROR: FOUND A WORMHOLE. STUCK IN INFINITE LOOP! Called from: ", flg_snw_ice
-                     write(iulog,*) "SNICAR STATS: snw_rds(0)= ", snw_rds(0)
-                     write(iulog,*) "SNICAR STATS: L_snw(0)= ", L_snw
+                     write(iulog,*) "SNICAR STATS: snw_rds(0)= ", snw_rds(c_idx,0)
+                     write(iulog,*) "SNICAR STATS: L_snw(0)= ", L_snw(0)
                      write(iulog,*) "SNICAR STATS: h2osno= ", h2osno_lcl, " snl= ", snl_lcl
+                     write(iulog,*) "SNICAR STATS: soot1(0)= ", mss_cnc_aer_lcl(0,1)
+                     write(iulog,*) "SNICAR STATS: soot2(0)= ", mss_cnc_aer_lcl(0,2)
+                     write(iulog,*) "SNICAR STATS: dust1(0)= ", mss_cnc_aer_lcl(0,3)
+                     write(iulog,*) "SNICAR STATS: dust2(0)= ", mss_cnc_aer_lcl(0,4)
+                     write(iulog,*) "SNICAR STATS: dust3(0)= ", mss_cnc_aer_lcl(0,5)
+                     write(iulog,*) "SNICAR STATS: dust4(0)= ", mss_cnc_aer_lcl(0,6)
                      l_idx     = col_pp%landunit(c_idx)
                      write(iulog,*) "column index: ", c_idx
                      write(iulog,*) "landunit type", lun_pp%itype(l_idx)
@@ -1085,68 +1104,82 @@ contains
 
                ! Energy conservation check:
                ! Incident direct+diffuse radiation equals (absorbed+bulk_transmitted+bulk_reflected)
-               energy_sum = (mu_not*pi*flx_slrd_lcl) + flx_slri_lcl - (F_abs_sum + F_btm_net + F_sfc_pls)
-#ifndef _OPENACC
+               energy_sum = (mu_not*pi*flx_slrd_lcl(bnd_idx)) + flx_slri_lcl(bnd_idx) - (F_abs_sum + F_btm_net + F_sfc_pls)
                if (abs(energy_sum) > 0.00001_r8) then
+#ifndef _OPENACC
                     write(iulog,*) "SNICAR ERROR: Energy conservation error of : ", energy_sum
                     call endrun(decomp_index=c_idx, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
-               endif
 #endif
+               endif
 
                albout_lcl(bnd_idx) = albedo
 
                ! Check that albedo is less than 1
-#ifndef _OPENACC
                if (albout_lcl(bnd_idx) > 1.0) then
+#ifndef _OPENACC
                   write(iulog,*) "SNICAR ERROR: Albedo > 1.0 at c: ", c_idx
                   write(iulog,*) "SNICAR STATS: bnd_idx= ",bnd_idx
                   write (iulog,*) "SNICAR STATS: albout_lcl(bnd)= ",albout_lcl(bnd_idx), &
-                       " albsfc_lcl = ",albsfc_lcl
+                       " albsfc_lcl(bnd_idx)= ",albsfc_lcl(bnd_idx)
                   write (iulog,*) "SNICAR STATS: landtype= ", sfctype
                   write (iulog,*) "SNICAR STATS: h2osno= ", h2osno_lcl, " snl= ", snl_lcl
-                  write (iulog,*) "SNICAR STATS: coszen= ", coszen, " flg_slr= ", flg_slr_in
-                  write (iulog,*) "SNICAR STATS: snw_rds(-4)= ", snw_rds(-4)
-                  write (iulog,*) "SNICAR STATS: snw_rds(-3)= ", snw_rds(-3)
-                  write (iulog,*) "SNICAR STATS: snw_rds(-2)= ", snw_rds(-2)
-                  write (iulog,*) "SNICAR STATS: snw_rds(-1)= ", snw_rds(-1)
-                  write (iulog,*) "SNICAR STATS: snw_rds(0)= ", snw_rds(0)
+                  write (iulog,*) "SNICAR STATS: coszen= ", coszen(c_idx), " flg_slr= ", flg_slr_in
+
+                  write (iulog,*) "SNICAR STATS: soot(-4)= ", mss_cnc_aer_lcl(-4,1)
+                  write (iulog,*) "SNICAR STATS: soot(-3)= ", mss_cnc_aer_lcl(-3,1)
+                  write (iulog,*) "SNICAR STATS: soot(-2)= ", mss_cnc_aer_lcl(-2,1)
+                  write (iulog,*) "SNICAR STATS: soot(-1)= ", mss_cnc_aer_lcl(-1,1)
+                  write (iulog,*) "SNICAR STATS: soot(0)= ", mss_cnc_aer_lcl(0,1)
+
+                  write (iulog,*) "SNICAR STATS: L_snw(-4)= ", L_snw(-4)
+                  write (iulog,*) "SNICAR STATS: L_snw(-3)= ", L_snw(-3)
+                  write (iulog,*) "SNICAR STATS: L_snw(-2)= ", L_snw(-2)
+                  write (iulog,*) "SNICAR STATS: L_snw(-1)= ", L_snw(-1)
+                  write (iulog,*) "SNICAR STATS: L_snw(0)= ", L_snw(0)
+
+                  write (iulog,*) "SNICAR STATS: snw_rds(-4)= ", snw_rds(c_idx,-4)
+                  write (iulog,*) "SNICAR STATS: snw_rds(-3)= ", snw_rds(c_idx,-3)
+                  write (iulog,*) "SNICAR STATS: snw_rds(-2)= ", snw_rds(c_idx,-2)
+                  write (iulog,*) "SNICAR STATS: snw_rds(-1)= ", snw_rds(c_idx,-1)
+                  write (iulog,*) "SNICAR STATS: snw_rds(0)= ", snw_rds(c_idx,0)
 
                   call endrun(decomp_index=c_idx, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
-               endif
 #endif
+               endif
 
             enddo   ! loop over wvl bands
 
 
             ! Weight output NIR albedo appropriately
-            albout(1) = albout_lcl(1)
+            albout(c_idx,1) = albout_lcl(1)
             flx_sum         = 0._r8
             do bnd_idx= nir_bnd_bgn,nir_bnd_end
                flx_sum = flx_sum + flx_wgt(bnd_idx)*albout_lcl(bnd_idx)
             end do
-            albout(2) = flx_sum / sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
+            albout(c_idx,2) = flx_sum / sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
 
             ! Weight output NIR absorbed layer fluxes (flx_abs) appropriately
-            flx_abs(:,1) = flx_abs_lcl(:,1)
+            flx_abs(c_idx,:,1) = flx_abs_lcl(:,1)
             do i=snl_top,1,1
                flx_sum = 0._r8
                do bnd_idx= nir_bnd_bgn,nir_bnd_end
                   flx_sum = flx_sum + flx_wgt(bnd_idx)*flx_abs_lcl(i,bnd_idx)
                enddo
-               flx_abs(i,2) = flx_sum / sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
+               flx_abs(c_idx,i,2) = flx_sum / sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
             end do
 
-         ! If snow < minimum_snow, but > 0, and there is sun, set albedo to underlying surface albedo
-      elseif ( (coszen > 0._r8) .and. (h2osno_lcl < min_snw) .and. (h2osno_lcl > 0._r8) ) then
-            albout(1) = albsfc(1)
-            albout(2) = albsfc(2)
+            ! If snow < minimum_snow, but > 0, and there is sun, set albedo to underlying surface albedo
+         elseif ( (coszen(c_idx) > 0._r8) .and. (h2osno_lcl < min_snw) .and. (h2osno_lcl > 0._r8) ) then
+            albout(c_idx,1) = albsfc(c_idx,1)
+            albout(c_idx,2) = albsfc(c_idx,2)
 
             ! There is either zero snow, or no sun
-      else
-            albout(1) = 0._r8
-            albout(2) = 0._r8
-      endif    ! if column has snow and coszen > 0
-      !enddo    ! loop over all columns
+         else
+            albout(c_idx,1) = 0._r8
+            albout(c_idx,2) = 0._r8
+         endif    ! if column has snow and coszen > 0
+
+      enddo    ! loop over all columns
 
     end associate
 
@@ -1190,6 +1223,7 @@ contains
     !   I am aware.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varpar       , only : nlevsno
     use elm_varcon       , only : spval
     use shr_const_mod    , only : SHR_CONST_RHOICE, SHR_CONST_PI
@@ -1213,7 +1247,7 @@ contains
     integer :: rhos_idx                     ! snow aging lookup table snow density index [idx]
     real(r8) :: t_snotop                    ! temperature at upper layer boundary [K]
     real(r8) :: t_snobtm                    ! temperature at lower layer boundary [K]
-    real(r8) :: dTdz    ! snow temperature gradient (col,lyr) [K m-1]
+    real(r8) :: dTdz(bounds%begc:bounds%endc,-nlevsno:0)    ! snow temperature gradient (col,lyr) [K m-1]
     real(r8) :: bst_tau                     ! snow aging parameter retrieved from lookup table [hour]
     real(r8) :: bst_kappa                   ! snow aging parameter retrieved from lookup table [unitless]
     real(r8) :: bst_drdt0                   ! snow aging parameter retrieved from lookup table [um hr-1]
@@ -1226,9 +1260,10 @@ contains
     real(r8) :: frc_oldsnow                 ! fraction of layer mass that is old snow [frc]
     real(r8) :: frc_refrz                   ! fraction of layer mass that is re-frozen snow [frc]
     real(r8) :: frc_liq                     ! fraction of layer mass that is liquid water[frc]
+    real(r8)  :: dtime                       ! land model time step [sec]
     real(r8) :: rhos                        ! snow density [kg m-3]
     real(r8) :: h2osno_lyr                  ! liquid + solid H2O in snow layer [kg m-2]
-    real(r8) :: cdz              ! column average layer thickness [m]
+    real(r8) :: cdz(-nlevsno+1:0)           ! column average layer thickness [m]
     !--------------------------------------------------------------------------!
 
     associate(                                                      &
@@ -1255,17 +1290,20 @@ contains
          )
 
 
+      ! set timestep and step interval
+      dtime = dtime_mod
+
       ! loop over columns that have at least one snow layer
-      !$acc parallel loop independent gang worker default(present) private(c_idx,snl_top)
       do fc = 1, num_snowc
          c_idx = filter_snowc(fc)
 
+         snl_btm = 0
          snl_top = snl(c_idx) + 1
 
+         cdz(snl_top:snl_btm)=frac_sno(c_idx)*dz(c_idx,snl_top:snl_btm)
+
          ! loop over snow layers
-         !$acc loop vector independent 
-         do i=snl_top,0,1
-            cdz=frac_sno(c_idx)*dz(c_idx,i)
+         do i=snl_top,snl_btm,1
             !
             !**********  1. DRY SNOW AGING  ***********
             !
@@ -1287,17 +1325,17 @@ contains
                     / (dz(c_idx,i)+dz(c_idx,i+1))
             endif
 
-            dTdz = abs((t_snotop - t_snobtm) / cdz)
+            dTdz(c_idx,i) = abs((t_snotop - t_snobtm) / cdz(i))
 
             ! snow density
-            rhos = (h2osoi_liq(c_idx,i)+h2osoi_ice(c_idx,i)) / cdz
+            rhos = (h2osoi_liq(c_idx,i)+h2osoi_ice(c_idx,i)) / cdz(i)
 
             ! make sure rhos doesn't drop below 50 (see rhos_idx below)
             rhos=max(50._r8,rhos)
 
             ! best-fit table indecies
             T_idx    = nint((t_soisno(c_idx,i)-223) / 5) + 1
-            Tgrd_idx = nint(dTdz / 10) + 1
+            Tgrd_idx = nint(dTdz(c_idx,i) / 10) + 1
             rhos_idx = nint((rhos-50) / 50) + 1
 
             ! boundary check:
@@ -1325,6 +1363,7 @@ contains
             bst_kappa = snowage_kappa(rhos_idx,Tgrd_idx,T_idx)
             bst_drdt0 = snowage_drdt0(rhos_idx,Tgrd_idx,T_idx)
 
+
             ! change in snow effective radius, using best-fit parameters
             ! added checks suggested by mgf. --HW 10/15/2015
             dr_fresh = snw_rds(c_idx,i)-snw_rds_min
@@ -1333,15 +1372,13 @@ contains
             if (      abs(dr_fresh) < 1.0e-8_r8 ) then
                dr_fresh = 0.0_r8
             else if ( dr_fresh < 0.0_r8 ) then
-#ifndef _OPENACC
                write(iulog,*) "dr_fresh = ", dr_fresh
                call endrun( "dr_fresh < 0" )
-#endif
             end if
 
-            dr = (bst_drdt0*(bst_tau/(dr_fresh+bst_tau))**(1._r8/bst_kappa)) * (dtime_mod/3600._r8)
+            dr = (bst_drdt0*(bst_tau/(dr_fresh+bst_tau))**(1._r8/bst_kappa)) * (dtime/3600._r8)
 #else
-            dr = (bst_drdt0*(bst_tau/(dr_fresh+bst_tau))**(1/bst_kappa)) * (dtime_mod/3600)
+            dr = (bst_drdt0*(bst_tau/(dr_fresh+bst_tau))**(1/bst_kappa)) * (dtime/3600)
 #endif
             !
             !**********  2. WET SNOW AGING  ***********
@@ -1355,7 +1392,7 @@ contains
 
             !dr_wet = 1E6_r8*(dtime*(C1_liq_Brun89 + C2_liq_Brun89*(frc_liq**(3))) / (4*SHR_CONST_PI*(snw_rds(c_idx,i)/1E6)**(2)))
             !simplified, units of microns:
-            dr_wet = 1E18_r8*(dtime_mod*(C2_liq_Brun89*(frc_liq**(3))) / (4*SHR_CONST_PI*snw_rds(c_idx,i)**(2)))
+            dr_wet = 1E18_r8*(dtime*(C2_liq_Brun89*(frc_liq**(3))) / (4*SHR_CONST_PI*snw_rds(c_idx,i)**(2)))
 
             dr = dr + dr_wet
 
@@ -1366,6 +1403,8 @@ contains
             if (flg_snoage_scl) then
                dr = dr*xdrdt
             endif
+
+
             !
             !**********  4. INCREMENT EFFECTIVE RADIUS, ACCOUNTING FOR:  ***********
             !               DRY AGING
@@ -1375,13 +1414,13 @@ contains
             !
             ! new snowfall [kg/m2]
             if (do_capsnow(c_idx) .and. .not. use_extrasnowlayers) then
-               newsnow = max(0._r8, (qflx_snwcp_ice(c_idx)*dtime_mod))
+               newsnow = max(0._r8, (qflx_snwcp_ice(c_idx)*dtime))
             else
-               newsnow = max(0._r8, (qflx_snow_grnd_col(c_idx)*dtime_mod))
+               newsnow = max(0._r8, (qflx_snow_grnd_col(c_idx)*dtime))
             endif
 
             ! snow that has re-frozen [kg/m2]
-            refrzsnow = max(0._r8, (qflx_snofrz_lyr(c_idx,i)*dtime_mod))
+            refrzsnow = max(0._r8, (qflx_snofrz_lyr(c_idx,i)*dtime))
 
             ! fraction of layer mass that is re-frozen
             frc_refrz = refrzsnow / h2osno_lyr
@@ -1418,16 +1457,16 @@ contains
             ! set top layer variables for history files
             if (i == snl_top) then
                snot_top(c_idx)    = t_soisno(c_idx,i)
-               dTdz_top(c_idx)    = dTdz
+               dTdz_top(c_idx)    = dTdz(c_idx,i)
                snw_rds_top(c_idx) = snw_rds(c_idx,i)
                sno_liq_top(c_idx) = h2osoi_liq(c_idx,i) / (h2osoi_liq(c_idx,i)+h2osoi_ice(c_idx,i))
             endif
 
          enddo
       enddo
+
       ! Special case: snow on ground, but not enough to have defined a snow layer:
       !   set snw_rds to fresh snow grain size:
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_nosnowc
          c_idx = filter_nosnowc(fc)
          if (h2osno(c_idx) > 0._r8) then
@@ -1683,7 +1722,7 @@ contains
     end subroutine SnowAge_init
 
    !-----------------------------------------------------------------------
-   subroutine SNICAR_AD_RT (flg_snw_ice, fc, c_idx,  &
+   subroutine SNICAR_AD_RT (flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,  &
                          coszen, flg_slr_in, h2osno_liq, h2osno_ice, snw_rds,   &
                          mss_cnc_aer_in, albsfc, albout, flx_abs)
      !
@@ -1708,88 +1747,102 @@ contains
      ! with the same model for their solar radiative properties.
      !
      ! The inputs and outputs are the same to subroutine SNICAR_RT
-     !$acc routine seq
+     !
      ! !USES:
+      !$acc routine seq
      use elm_varpar       , only : nlevsno, numrad
+     use clm_time_manager , only : get_nstep
      use shr_const_mod    , only : SHR_CONST_PI
      !
      ! !ARGUMENTS:
      integer           , intent(in)  :: flg_snw_ice                                        ! flag: =1 when called from CLM, =2 when called from CSIM
-     integer, value    , intent(in)  :: fc
-     integer, value    , intent(in)  :: c_idx
-     real(r8),value    , intent(in)  :: coszen                          ! cosine of solar zenith angle for next time step (col) [unitless]
-     integer ,value    , intent(in)  :: flg_slr_in                                         ! flag: =1 for direct-beam incident flux,=2 for diffuse incident flux
-     real(r8)          , intent(in)  :: h2osno_liq     (-nlevsno+1: )      ! liquid water content (col,lyr) [kg/m2]
-     real(r8)          , intent(in)  :: h2osno_ice     (-nlevsno+1: )      ! ice content (col,lyr) [kg/m2]
-     integer           , intent(in)  :: snw_rds        (-nlevsno+1: )      ! snow effective radius (col,lyr) [microns, m^-6]
-     real(r8)          , intent(in)  :: mss_cnc_aer_in (-nlevsno+1: , 1: ) ! mass concentration of all aerosol species (col,lyr,aer) [kg/kg]
-     real(r8)          , intent(in)  :: albsfc         (1: )               ! albedo of surface underlying snow (col,bnd) [frc]
-     real(r8)          , intent(out) :: albout         (1: )               ! snow albedo, averaged into 2 bands (=0 if no sun or no snow) (col,bnd) [frc]
-     real(r8)          , intent(out) :: flx_abs        (-nlevsno+1: , 1: ) ! absorbed flux in each layer per unit flux incident (col, lyr, bnd)
+     type (bounds_type), intent(in)  :: bounds
+     integer           , intent(in)  :: num_nourbanc                                       ! number of columns in non-urban filter
+     integer           , intent(in)  :: filter_nourbanc(:)                                 ! column filter for non-urban points
+     real(r8)          , intent(in)  :: coszen         ( bounds%begc: )                    ! cosine of solar zenith angle for next time step (col) [unitless]
+     integer           , intent(in)  :: flg_slr_in                                         ! flag: =1 for direct-beam incident flux,=2 for diffuse incident flux
+     real(r8)          , intent(in)  :: h2osno_liq     ( bounds%begc: , -nlevsno+1: )      ! liquid water content (col,lyr) [kg/m2]
+     real(r8)          , intent(in)  :: h2osno_ice     ( bounds%begc: , -nlevsno+1: )      ! ice content (col,lyr) [kg/m2]
+     integer           , intent(in)  :: snw_rds        ( bounds%begc: , -nlevsno+1: )      ! snow effective radius (col,lyr) [microns, m^-6]
+     real(r8)          , intent(in)  :: mss_cnc_aer_in ( bounds%begc: , -nlevsno+1: , 1: ) ! mass concentration of all aerosol species (col,lyr,aer) [kg/kg]
+     real(r8)          , intent(in)  :: albsfc         ( bounds%begc: , 1: )               ! albedo of surface underlying snow (col,bnd) [frc]
+     real(r8)          , intent(out) :: albout         ( bounds%begc: , 1: )               ! snow albedo, averaged into 2 bands (=0 if no sun or no snow) (col,bnd) [frc]
+     real(r8)          , intent(out) :: flx_abs        ( bounds%begc: , -nlevsno+1: , 1: ) ! absorbed flux in each layer per unit flux incident (col, lyr, bnd)
      !
      ! !LOCAL VARIABLES:
      !
      ! variables for snow radiative transfer calculations
+
      ! Local variables representing single-column values of arrays:
      integer :: snl_lcl                            ! negative number of snow layers [nbr]
      integer :: snw_rds_lcl(-nlevsno+1:0)          ! snow effective radius [m^-6]
-     real(r8):: flx_slrd_lcl         ! direct beam incident irradiance [W/m2] (set to 1)
-     real(r8):: flx_slri_lcl         ! diffuse incident irradiance [W/m2] (set to 1)
-     !real(r8):: mss_cnc_aer_lcl(-nlevsno+1:0,1:sno_nbr_aer) ! aerosol mass concentration (lyr,aer_nbr) [kg/kg]
+     real(r8):: flx_slrd_lcl(1:numrad_snw)         ! direct beam incident irradiance [W/m2] (set to 1)
+     real(r8):: flx_slri_lcl(1:numrad_snw)         ! diffuse incident irradiance [W/m2] (set to 1)
+     real(r8):: mss_cnc_aer_lcl(-nlevsno+1:0,1:sno_nbr_aer) ! aerosol mass concentration (lyr,aer_nbr) [kg/kg]
      real(r8):: h2osno_lcl                         ! total column snow mass [kg/m2]
      real(r8):: h2osno_liq_lcl(-nlevsno+1:0)       ! liquid water mass [kg/m2]
      real(r8):: h2osno_ice_lcl(-nlevsno+1:0)       ! ice mass [kg/m2]
-     real(r8):: albsfc_lcl          ! albedo of underlying surface [frc]
-     real(r8):: ss_alb_snw_lcl (-nlevsno+1:0)       ! single-scatter albedo of ice grains (lyr) [frc]
+     real(r8):: albsfc_lcl(1:numrad_snw)           ! albedo of underlying surface [frc]
+     real(r8):: ss_alb_snw_lcl(-nlevsno+1:0)       ! single-scatter albedo of ice grains (lyr) [frc]
      real(r8):: asm_prm_snw_lcl(-nlevsno+1:0)      ! asymmetry parameter of ice grains (lyr) [frc]
      real(r8):: ext_cff_mss_snw_lcl(-nlevsno+1:0)  ! mass extinction coefficient of ice grains (lyr) [m2/kg]
      real(r8):: ss_alb_aer_lcl(sno_nbr_aer)        ! single-scatter albedo of aerosol species (aer_nbr) [frc]
      real(r8):: asm_prm_aer_lcl(sno_nbr_aer)       ! asymmetry parameter of aerosol species (aer_nbr) [frc]
      real(r8):: ext_cff_mss_aer_lcl(sno_nbr_aer)   ! mass extinction coefficient of aerosol species (aer_nbr) [m2/kg]
+
 #ifdef MODAL_AER
      !mgf++
-     real(r8) :: rds_bcint_lcl   ! effective radius of within-ice BC [nm]
-     real(r8) :: rds_bcext_lcl   ! effective radius of external BC [nm]
+     real(r8) :: rds_bcint_lcl(-nlevsno+1:0)       ! effective radius of within-ice BC [nm]
+     real(r8) :: rds_bcext_lcl(-nlevsno+1:0)       ! effective radius of external BC [nm]
      !mgf--
 #endif
+
+
      ! Other local variables
-     integer, parameter :: DELTA=1             ! flag to use Delta approximation (Joseph, 1976)
-                                               ! (1= use, 0= don't use)
-     real(r8):: flx_wgt(1:numrad_snw)          ! weights applied to spectral bands,
-                                               ! specific to direct and diffuse cases (bnd) [frc]
-     integer :: flg_nosnl                      ! flag: =1 if there is snow, but zero snow layers,
-                                               ! =0 if at least 1 snow layer [flg]
-     real(r8):: albedo                              ! temporary snow albedo [frc]
-     real(r8):: flx_sum                             ! temporary summation variable for NIR weighting
-     real(r8):: albout_lcl(numrad_snw)              ! snow albedo by band [frc]
+     integer :: DELTA                              ! flag to use Delta approximation (Joseph, 1976)
+                                                   ! (1= use, 0= don't use)
+     real(r8):: flx_wgt(1:numrad_snw)              ! weights applied to spectral bands,
+                                                   ! specific to direct and diffuse cases (bnd) [frc]
+     integer :: flg_nosnl                          ! flag: =1 if there is snow, but zero snow layers,
+                                                   ! =0 if at least 1 snow layer [flg]
+     !integer :: trip                               ! flag: =1 to redo RT calculation if result is unrealistic
+     !integer :: flg_dover                          ! defines conditions for RT redo (explained below)
+
+     real(r8):: albedo                             ! temporary snow albedo [frc]
+     real(r8):: flx_sum                            ! temporary summation variable for NIR weighting
+     real(r8):: albout_lcl(numrad_snw)             ! snow albedo by band [frc]
      real(r8):: flx_abs_lcl(-nlevsno+1:1,numrad_snw)! absorbed flux per unit incident flux at top of snowpack (lyr,bnd) [frc]
 
-     real(r8):: L_snw        ! h2o mass (liquid+solid) in snow layer (lyr) [kg/m2]
-     real(r8):: tau_snw      ! snow optical depth (lyr) [unitless]
-     real(r8):: L_aer        ! aerosol mass in snow layer (lyr,nbr_aer) [kg/m2]
-     real(r8):: tau_aer      ! aerosol optical depth (lyr,nbr_aer) [unitless]
-     real(r8):: tau_sum      ! cumulative (snow+aerosol) optical depth [unitless]
-     real(r8):: tau_elm(-nlevsno+1:0)   ! column optical depth from layer bottom to snowpack top (lyr) [unitless]
-     real(r8):: omega_sum               ! temporary summation of single-scatter albedo of all aerosols [frc]
-     real(r8):: g_sum                   ! temporary summation of asymmetry parameter of all aerosols [frc]
-
-     real(r8):: tau_i                  ! weighted optical depth of snow+aerosol layer (lyr) [unitless]
-     real(r8):: omega_i                ! weighted single-scatter albedo of snow+aerosol layer (lyr) [frc]
-     real(r8):: g_i                    ! weighted asymmetry parameter of snow+aerosol layer (lyr) [frc]
+     real(r8):: L_snw(-nlevsno+1:0)                ! h2o mass (liquid+solid) in snow layer (lyr) [kg/m2]
+     real(r8):: tau_snw(-nlevsno+1:0)              ! snow optical depth (lyr) [unitless]
+     real(r8):: L_aer(-nlevsno+1:0,sno_nbr_aer)    ! aerosol mass in snow layer (lyr,nbr_aer) [kg/m2]
+     real(r8):: tau_aer(-nlevsno+1:0,sno_nbr_aer)  ! aerosol optical depth (lyr,nbr_aer) [unitless]
+     real(r8):: tau_sum                            ! cumulative (snow+aerosol) optical depth [unitless]
+     real(r8):: tau_elm(-nlevsno+1:0)              ! column optical depth from layer bottom to snowpack top (lyr) [unitless]
+     real(r8):: omega_sum                          ! temporary summation of single-scatter albedo of all aerosols [frc]
+     real(r8):: g_sum                              ! temporary summation of asymmetry parameter of all aerosols [frc]
+
+     real(r8):: tau(-nlevsno+1:0)                  ! weighted optical depth of snow+aerosol layer (lyr) [unitless]
+     real(r8):: omega(-nlevsno+1:0)                ! weighted single-scatter albedo of snow+aerosol layer (lyr) [frc]
+     real(r8):: g(-nlevsno+1:0)                    ! weighted asymmetry parameter of snow+aerosol layer (lyr) [frc]
      real(r8):: tau_star(-nlevsno+1:0)             ! transformed (i.e. Delta-Eddington) optical depth of snow+aerosol layer
                                                    ! (lyr) [unitless]
      real(r8):: omega_star(-nlevsno+1:0)           ! transformed (i.e. Delta-Eddington) SSA of snow+aerosol layer (lyr) [frc]
      real(r8):: g_star(-nlevsno+1:0)               ! transformed (i.e. Delta-Eddington) asymmetry paramater of snow+aerosol layer
                                                    ! (lyr) [frc]
 
+     integer :: nstep                              ! current timestep [nbr] (debugging only)
+     integer :: g_idx, c_idx, l_idx                ! gridcell, column, and landunit indices [idx]
      integer :: bnd_idx                            ! spectral band index (1 <= bnd_idx <= numrad_snw) [idx]
      integer :: rds_idx                            ! snow effective radius index for retrieving
                                                    ! Mie parameters from lookup table [idx]
      integer :: snl_btm                            ! index of bottom snow layer (0) [idx]
      integer :: snl_top                            ! index of top snow layer (-4 to 0) [idx]
+     integer :: fc                                 ! column filter index
      integer :: i                                  ! layer index [idx]
      integer :: j                                  ! aerosol number index [idx]
      integer :: m                                  ! secondary layer index [idx]
+     integer :: nint_snw_rds_min                   ! nearest integer value of snw_rds_min
 
      real(r8):: F_abs(-nlevsno+1:0)                ! net absorbed radiative energy (lyr) [W/m^2]
      real(r8):: F_abs_sum                          ! total absorbed energy in column [W/m^2]
@@ -1799,90 +1852,93 @@ contains
      real(r8):: mu_not                             ! cosine of solar zenith angle (used locally) [frc]
 
      integer :: err_idx                            ! counter for number of times through error loop [nbr]
-     real(r8), parameter :: pi = SHR_CONST_PI ! 3.1415...
+     real(r8):: lat_coord                          ! gridcell latitude (debugging only)
+     real(r8):: lon_coord                          ! gridcell longitude (debugging only)
+     integer :: sfctype                            ! underlying surface type (debugging only)
+     real(r8):: pi                                 ! 3.1415...
 
      ! SNICAR_AD new variables, follow sea-ice shortwave conventions
-     real(r8) :: trndir(-nlevsno+1:1)  ! solar beam down transmission from top
-     real(r8) :: trntdr(-nlevsno+1:1)  ! total transmission to direct beam for layers above
-     real(r8) :: trndif(-nlevsno+1:1)  ! diffuse transmission to diffuse beam for layers above
-     real(r8) :: rupdir(-nlevsno+1:1)  ! reflectivity to direct radiation for layers below
-     real(r8) :: rupdif(-nlevsno+1:1)  ! reflectivity to diffuse radiation for layers below
-     real(r8) :: rdndif(-nlevsno+1:1)  ! reflectivity to diffuse radiation for layers above
-     real(r8) :: dfdir(-nlevsno+1:1)   ! down-up flux at interface due to direct beam at top surface
-     real(r8) :: dfdif(-nlevsno+1:1)   ! down-up flux at interface due to diffuse beam at top surface
-     real(r8) :: dftmp(-nlevsno+1:1)   ! temporary variable for down-up flux at interface
-     !
-     real(r8) :: rdir(-nlevsno+1:0)    ! layer reflectivity to direct radiation
-     real(r8) :: rdif_a(-nlevsno+1:0)  ! layer reflectivity to diffuse radiation from above
-     real(r8) :: rdif_b(-nlevsno+1:0)  ! layer reflectivity to diffuse radiation from below
-     real(r8) :: tdir(-nlevsno+1:0)    ! layer transmission to direct radiation (solar beam + diffuse)
-     real(r8) :: tdif_a(-nlevsno+1:0)  ! layer transmission to diffuse radiation from above
-     real(r8) :: tdif_b(-nlevsno+1:0)  ! layer transmission to diffuse radiation from below
-     real(r8) :: trnlay(-nlevsno+1:0)  ! solar beam transm for layer (direct beam only)
-
-     real(r8):: ts       ! layer delta-scaled extinction optical depth
-     real(r8):: ws       ! layer delta-scaled single scattering albedo
-     real(r8):: gs       ! layer delta-scaled asymmetry parameter
-     real(r8):: extins   ! extinction
-     real(r8):: alp      ! temporary for alpha
-     real(r8):: gam      ! temporary for agamm
-     real(r8):: amg      ! alp - gam
-     real(r8):: apg      ! alp + gam
-     real(r8):: ue       ! temporary for u
-     real(r8):: refk     ! interface multiple scattering
-     real(r8):: refkp1   ! interface multiple scattering for k+1
-     real(r8):: refkm1   ! interface multiple scattering for k-1
-     real(r8):: tdrrdir  ! direct tran times layer direct ref
-     real(r8):: tdndif   ! total down diffuse = tot tran - direct tran
-     !
-     real(r8) :: alpha  ! term in direct reflectivity and transmissivity
-     real(r8) :: agamm  ! term in direct reflectivity and transmissivity
-     real(r8) :: el     ! term in alpha,agamm,n,u
-     real(r8) :: taus   ! scaled extinction optical depth
-     real(r8) :: omgs   ! scaled single particle scattering albedo
-     real(r8) :: asys   ! scaled asymmetry parameter
-     real(r8) :: u      ! term in diffuse reflectivity and transmissivity
-     real(r8) :: n      ! term in diffuse reflectivity and transmissivity
-     real(r8) :: lm     ! temporary for el
-     real(r8) :: mu     ! cosine solar zenith for either snow or water
-     real(r8) :: ne     ! temporary for n
-     ! perpendicular and parallel relative to plane of incidence and scattering
-     real(r8) :: R1        ! perpendicular polarization reflection amplitude
-     real(r8) :: R2        ! parallel polarization reflection amplitude
-     real(r8) :: T1        ! perpendicular polarization transmission amplitude
-     real(r8) :: T2        ! parallel polarization transmission amplitude
-     real(r8) :: Rf_dir_a  ! fresnel reflection to direct radiation
-     real(r8) :: Tf_dir_a  ! fresnel transmission to direct radiation
-     real(r8) :: Rf_dif_a  ! fresnel reflection to diff radiation from above
-     real(r8) :: Rf_dif_b  ! fresnel reflection to diff radiation from below
-     real(r8) :: Tf_dif_a  ! fresnel transmission to diff radiation from above
-     real(r8) :: Tf_dif_b  ! fresnel transmission to diff radiation from below
-     !
-     real(r8) :: gwt      ! gaussian weight
-     real(r8) :: swt      ! sum of weights
-     real(r8) :: trn      ! layer transmission
-     real(r8) :: rdr      ! rdir for gaussian integration
-     real(r8) :: tdr      ! tdir for gaussian integration
-     real(r8) :: smr      ! accumulator for rdif gaussian integration
-     real(r8) :: smt      ! accumulator for tdif gaussian integration
-     real(r8) :: exp_min  ! minimum exponential value
-     !
-     integer :: ng           ! gaussian integration index
-     integer :: snl_btm_itf  ! index of bottom snow layer interfaces (1) [idx]
-     integer,parameter :: ngmax = 8    ! gaussian integration index
-     !Gaussian integration angle and coefficients for diffuse radiation
-     real(r8), parameter,dimension(8) :: difgauspt  & ! gaussian angles (radians)
-         = (/ 0.9894009_r8,  0.9445750_r8, &
-            0.8656312_r8,  0.7554044_r8, &
-            0.6178762_r8,  0.4580168_r8, &
-            0.2816036_r8,  0.0950125_r8/)
-     real(r8),parameter,dimension(8) :: difgauswt  & ! gaussian weights
-         = (/ 0.0271525_r8,  0.0622535_r8, &
-            0.0951585_r8,  0.1246290_r8, &
-            0.1495960_r8,  0.1691565_r8, &
-            0.1826034_r8,  0.1894506_r8/)
+     real(r8):: &
+        trndir(-nlevsno+1:1)  , & ! solar beam down transmission from top
+        trntdr(-nlevsno+1:1)  , & ! total transmission to direct beam for layers above
+        trndif(-nlevsno+1:1)  , & ! diffuse transmission to diffuse beam for layers above
+        rupdir(-nlevsno+1:1)  , & ! reflectivity to direct radiation for layers below
+        rupdif(-nlevsno+1:1)  , & ! reflectivity to diffuse radiation for layers below
+        rdndif(-nlevsno+1:1)  , & ! reflectivity to diffuse radiation for layers above
+        dfdir(-nlevsno+1:1)   , & ! down-up flux at interface due to direct beam at top surface
+        dfdif(-nlevsno+1:1)   , & ! down-up flux at interface due to diffuse beam at top surface
+        dftmp(-nlevsno+1:1)       ! temporary variable for down-up flux at interface
+
+     real(r8):: &
+        rdir(-nlevsno+1:0)       , & ! layer reflectivity to direct radiation
+        rdif_a(-nlevsno+1:0)     , & ! layer reflectivity to diffuse radiation from above
+        rdif_b(-nlevsno+1:0)     , & ! layer reflectivity to diffuse radiation from below
+        tdir(-nlevsno+1:0)       , & ! layer transmission to direct radiation (solar beam + diffuse)
+        tdif_a(-nlevsno+1:0)     , & ! layer transmission to diffuse radiation from above
+        tdif_b(-nlevsno+1:0)     , & ! layer transmission to diffuse radiation from below
+        trnlay(-nlevsno+1:0)         ! solar beam transm for layer (direct beam only)
+
+     real(r8):: &
+         ts       , & ! layer delta-scaled extinction optical depth
+         ws       , & ! layer delta-scaled single scattering albedo
+         gs       , & ! layer delta-scaled asymmetry parameter
+         extins   , & ! extinction
+         alp      , & ! temporary for alpha
+         gam      , & ! temporary for agamm
+         amg      , & ! alp - gam
+         apg      , & ! alp + gam
+         ue       , & ! temporary for u
+         refk     , & ! interface multiple scattering
+         refkp1   , & ! interface multiple scattering for k+1
+         refkm1   , & ! interface multiple scattering for k-1
+         tdrrdir  , & ! direct tran times layer direct ref
+         tdndif       ! total down diffuse = tot tran - direct tran
+
+     real(r8) :: &
+         alpha    , & ! term in direct reflectivity and transmissivity
+         agamm    , & ! term in direct reflectivity and transmissivity
+         el       , & ! term in alpha,agamm,n,u
+         taus     , & ! scaled extinction optical depth
+         omgs     , & ! scaled single particle scattering albedo
+         asys     , & ! scaled asymmetry parameter
+         u        , & ! term in diffuse reflectivity and transmissivity
+         n        , & ! term in diffuse reflectivity and transmissivity
+         lm       , & ! temporary for el
+         mu       , & ! cosine solar zenith for either snow or water
+         ne           ! temporary for n
 
+     ! perpendicular and parallel relative to plane of incidence and scattering
+     real(r8) :: &
+         R1       , & ! perpendicular polarization reflection amplitude
+         R2       , & ! parallel polarization reflection amplitude
+         T1       , & ! perpendicular polarization transmission amplitude
+         T2       , & ! parallel polarization transmission amplitude
+         Rf_dir_a , & ! fresnel reflection to direct radiation
+         Tf_dir_a , & ! fresnel transmission to direct radiation
+         Rf_dif_a , & ! fresnel reflection to diff radiation from above
+         Rf_dif_b , & ! fresnel reflection to diff radiation from below
+         Tf_dif_a , & ! fresnel transmission to diff radiation from above
+         Tf_dif_b     ! fresnel transmission to diff radiation from below
 
+     real(r8) :: &
+         gwt      , & ! gaussian weight
+         swt      , & ! sum of weights
+         trn      , & ! layer transmission
+         rdr      , & ! rdir for gaussian integration
+         tdr      , & ! tdir for gaussian integration
+         smr      , & ! accumulator for rdif gaussian integration
+         smt      , & ! accumulator for tdif gaussian integration
+         exp_min      ! minimum exponential value
+
+     integer :: &
+         ng             , & ! gaussian integration index
+         snl_btm_itf    , & ! index of bottom snow layer interfaces (1) [idx]
+         ngmax = 8          ! gaussian integration index
+
+     ! Gaussian integration angle and coefficients
+     real(r8) :: &
+         difgauspt(1:8)  , &
+         difgauswt(1:8)
      ! real(r8),  dimension (1:8) :: &
      !     dif_gauspt     & ! gaussian angles (radians)
      !       = (/ 0.9894009_r8,  0.9445750_r8, &
@@ -1896,7 +1952,7 @@ contains
      !            0.1826034_r8,  0.1894506_r8/)
 
      ! constants used in algorithm
-     real(r8), parameter  :: &
+     real(r8) :: &
          c0      = 0.0_r8     , &
          c1      = 1.0_r8     , &
          c3      = 3.0_r8     , &
@@ -1910,7 +1966,7 @@ contains
          argmax  = 10.0_r8       ! maximum argument of exponential
 
      ! cconstant coefficients used for SZA parameterization
-     real(r8), parameter :: &
+     real(r8) :: &
          sza_a0 =  0.085730_r8 , &
          sza_a1 = -0.630883_r8 , &
          sza_a2 =  1.303723_r8 , &
@@ -1934,6 +1990,7 @@ contains
      ! n(uu,et)         = ((uu+c1)*(uu+c1)/et ) - ((uu-c1)*(uu-c1)*et)
      ! u(w,gg,e)        = c1p5*(c1 - w*gg)/e
      ! el(w,gg)         = sqrt(c3*(c1-w)*(c1 - w*gg))
+
      !-----------------------------------------------------------------------
 #ifdef MODAL_AER
          !mgf++
@@ -1944,29 +2001,54 @@ contains
          real(r8):: tmp1                              ! temporary variable
          !mgf--
 #endif
+
      ! Enforce expected array sizes
+
      associate(&
           snl         =>   col_pp%snl           , & ! Input:  [integer (:)]  negative number of snow layers (col) [nbr]
           h2osno      =>   col_ws%h2osno        , & ! Input:  [real(r8) (:)]  snow liquid water equivalent (col) [kg/m2]
           frac_sno    =>   col_ws%frac_sno_eff    & ! Input:  [real(r8) (:)]  fraction of ground covered by snow (0 to 1)
           )
 
+       ! Define constants
+       pi = SHR_CONST_PI
+       nint_snw_rds_min = nint(snw_rds_min)
+
+       ! always use Delta approximation for snow
+       DELTA = 1
+
+       ! Get current timestep
+       nstep = get_nstep()
+
+       !Gaussian integration angle and coefficients for diffuse radiation
+       difgauspt(1:8)     & ! gaussian angles (radians)
+         = (/ 0.9894009_r8,  0.9445750_r8, &
+              0.8656312_r8,  0.7554044_r8, &
+              0.6178762_r8,  0.4580168_r8, &
+              0.2816036_r8,  0.0950125_r8/)
+       difgauswt(1:8)     & ! gaussian weights
+         = (/ 0.0271525_r8,  0.0622535_r8, &
+              0.0951585_r8,  0.1246290_r8, &
+              0.1495960_r8,  0.1691565_r8, &
+              0.1826034_r8,  0.1894506_r8/)
+
+
       ! Loop over all non-urban columns
       ! (when called from CSIM, there is only one column)
-       !do fc = 1,num_nourbanc
-       !    c_idx = filter_nourbanc(fc)
+       do fc = 1,num_nourbanc
+          c_idx = filter_nourbanc(fc)
 
           ! Zero absorbed radiative fluxes:
-          flx_abs_lcl(:,:)   = 0._r8
           do i=-nlevsno+1,1,1
-             flx_abs(i,:) = 0._r8
+             flx_abs_lcl(:,:)   = 0._r8
+             flx_abs(c_idx,i,:) = 0._r8
           enddo
 
           ! set snow/ice mass to be used for RT:
           if (flg_snw_ice == 1) then
              h2osno_lcl = h2osno(c_idx)
           else
-             h2osno_lcl = h2osno_ice(0)
+             h2osno_lcl = h2osno_ice(c_idx,0)
           endif
 
 
@@ -1974,7 +2056,7 @@ contains
           !  1) sunlight from atmosphere model
           !  2) minimum amount of snow on ground.
           !     Otherwise, set snow albedo to zero
-          if ( (coszen > 0._r8) .and. (h2osno_lcl > min_snw) ) then
+          if ((coszen(c_idx) > 0._r8) .and. (h2osno_lcl > min_snw) ) then
 
              ! Set variables specific to ELM
              if (flg_snw_ice == 1) then
@@ -1985,36 +2067,38 @@ contains
                    snl_lcl           =  -1
                    h2osno_ice_lcl(0) =  h2osno_lcl
                    h2osno_liq_lcl(0) =  0._r8
-                   snw_rds_lcl(0)    =  nint(snw_rds_min)
+                   snw_rds_lcl(0)    =  nint_snw_rds_min
                 else
                    flg_nosnl         =  0
                    snl_lcl           =  snl(c_idx)
-                   h2osno_liq_lcl(:) =  h2osno_liq(:)
-                   h2osno_ice_lcl(:) =  h2osno_ice(:)
-                   snw_rds_lcl(:)    =  snw_rds(:)
+                   h2osno_liq_lcl(:) =  h2osno_liq(c_idx,:)
+                   h2osno_ice_lcl(:) =  h2osno_ice(c_idx,:)
+                   snw_rds_lcl(:)    =  snw_rds(c_idx,:)
                 endif
 
                 snl_btm   = 0
                 snl_top   = snl_lcl+1
 
                 ! for debugging only
-                ! l_idx     = col_pp%landunit(c_idx)
-                ! g_idx     = col_pp%gridcell(c_idx)
-                ! ! sfctype   = lun_pp%itype(l_idx)
-                ! ! lat_coord = grc_pp%latdeg(g_idx)
-                ! ! lon_coord = grc_pp%londeg(g_idx)
+                l_idx     = col_pp%landunit(c_idx)
+                g_idx     = col_pp%gridcell(c_idx)
+                sfctype   = lun_pp%itype(l_idx)
+                lat_coord = grc_pp%latdeg(g_idx)
+                lon_coord = grc_pp%londeg(g_idx)
+
+
                 ! Set variables specific to CSIM
              else
                 flg_nosnl         = 0
                 snl_lcl           = -1
-                h2osno_liq_lcl(:) = h2osno_liq(:)
-                h2osno_ice_lcl(:) = h2osno_ice(:)
-                snw_rds_lcl(:)    = snw_rds(:)
+                h2osno_liq_lcl(:) = h2osno_liq(c_idx,:)
+                h2osno_ice_lcl(:) = h2osno_ice(c_idx,:)
+                snw_rds_lcl(:)    = snw_rds(c_idx,:)
                 snl_btm           = 0
                 snl_top           = 0
-                ! sfctype           = -1
-                ! lat_coord         = -90
-                ! lon_coord         = 0
+                sfctype           = -1
+                lat_coord         = -90
+                lon_coord         = 0
              endif ! end if flg_snw_ice == 1
 
 #ifdef MODAL_AER
@@ -2025,32 +2109,35 @@ contains
            ! 40nm) assumed for freshly-emitted BC in MAM.  Future
            ! implementations may prognose the BC effective radius in
            ! snow.
-           rds_bcint_lcl  =  100._r8
-           rds_bcext_lcl  =  100._r8
+           rds_bcint_lcl(:)  =  100._r8
+           rds_bcext_lcl(:)  =  100._r8
            !mgf--
 #endif
-             ! ! Set local aerosol array
-             ! do j=1,sno_nbr_aer
-             !    mss_cnc_aer_lcl(:,j) = mss_cnc_aer_in(c_idx,:,j)
-             ! enddo
 
-             ! ! Set spectral underlying surface albedos to their corresponding VIS or NIR albedos
-             ! albsfc_lcl(1)                       = albsfc(c_idx,1)
-             ! albsfc_lcl(nir_bnd_bgn:nir_bnd_end) = albsfc(c_idx,2)
+             ! Set local aerosol array
+             do j=1,sno_nbr_aer
+                mss_cnc_aer_lcl(:,j) = mss_cnc_aer_in(c_idx,:,j)
+             enddo
+
+
+             ! Set spectral underlying surface albedos to their corresponding VIS or NIR albedos
+             albsfc_lcl(1)                       = albsfc(c_idx,1)
+             albsfc_lcl(nir_bnd_bgn:nir_bnd_end) = albsfc(c_idx,2)
+
 
              ! Error check for snow grain size:
-#ifndef _OPENACC
              do i=snl_top,snl_btm,1
                 if ((snw_rds_lcl(i) < snw_rds_min_tbl) .or. (snw_rds_lcl(i) > snw_rds_max_tbl)) then
                    write (iulog,*) "SNICAR ERROR: snow grain radius of ", snw_rds_lcl(i), " out of bounds."
+                   write (iulog,*) "NSTEP= ", nstep
                    write (iulog,*) "flg_snw_ice= ", flg_snw_ice
                    write (iulog,*) "column: ", c_idx, " level: ", i, " snl(c)= ", snl_lcl
-                   !write (iulog,*) "lat= ", lat_coord, " lon= ", lon_coord
+                   write (iulog,*) "lat= ", lat_coord, " lon= ", lon_coord
                    write (iulog,*) "h2osno(c)= ", h2osno_lcl
                    call endrun(decomp_index=c_idx, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
                 endif
              enddo
-#endif
+
              ! Incident flux weighting parameters
              !  - sum of all VIS bands must equal 1
              !  - sum of all NIR bands must equal 1
@@ -2101,12 +2188,7 @@ contains
 
              exp_min = exp(-argmax)
              do bnd_idx = 1,numrad_snw
-               ! Set spectral underlying surface albedos to their corresponding VIS or NIR albedos
-               if(bnd_idx == 1) then
-                 albsfc_lcl = albsfc(1)
-               else
-                 albsfc_lcl = albsfc(2)
-               end if
+
                ! note that we can remove flg_dover since this algorithm is
                ! stable for mu_not > 0.01
 
@@ -2114,27 +2196,28 @@ contains
                ! sure mu_not is large enough for stable and meaningful radiation
                ! solution: .01 is like sun just touching horizon with its lower edge
                ! equivalent to mu0 in sea-ice shortwave model ice_shortwave.F90
-                mu_not = max(coszen, cp01)
+                mu_not = max(coszen(c_idx), cp01)
+
 
                    ! Set direct or diffuse incident irradiance to 1
                    ! (This has to be within the bnd loop because mu_not is adjusted in rare cases)
                    if (flg_slr_in == 1) then
-                      flx_slrd_lcl = 1._r8/(mu_not*pi) ! this corresponds to incident irradiance of 1.0
-                      flx_slri_lcl = 0._r8
+                      flx_slrd_lcl(bnd_idx) = 1._r8/(mu_not*pi) ! this corresponds to incident irradiance of 1.0
+                      flx_slri_lcl(bnd_idx) = 0._r8
                    else
-                      flx_slrd_lcl = 0._r8
-                      flx_slri_lcl = 1._r8
+                      flx_slrd_lcl(bnd_idx) = 0._r8
+                      flx_slri_lcl(bnd_idx) = 1._r8
                    endif
 
                    ! Pre-emptive error handling: aerosols can reap havoc on these absorptive bands.
                    ! Since extremely high soot concentrations have a negligible effect on these bands, zero them.
-                   ! if ( (numrad_snw == 5).and.((bnd_idx == 5).or.(bnd_idx == 4)) ) then
-                   !    mss_cnc_aer_lcl(:,:) = 0._r8
-                   ! endif
-                   !
-                   ! if ( (numrad_snw == 3).and.(bnd_idx == 3) ) then
-                   !    mss_cnc_aer_lcl(:,:) = 0._r8
-                   ! endif
+                   if ( (numrad_snw == 5).and.((bnd_idx == 5).or.(bnd_idx == 4)) ) then
+                      mss_cnc_aer_lcl(:,:) = 0._r8
+                   endif
+
+                   if ( (numrad_snw == 3).and.(bnd_idx == 3) ) then
+                      mss_cnc_aer_lcl(:,:) = 0._r8
+                   endif
 
                    ! Define local Mie parameters based on snow grain size and aerosol species,
                    !  retrieved from a lookup table.
@@ -2223,8 +2306,8 @@ contains
                     endif
 
                     ! valid for 25 < bc_rds < 525 nm
-                    idx_bcint_nclrds = nint(rds_bcint_lcl/50)
-                    idx_bcext_nclrds = nint(rds_bcext_lcl/50)
+                    idx_bcint_nclrds = nint(rds_bcint_lcl(i)/50)
+                    idx_bcext_nclrds = nint(rds_bcext_lcl(i)/50)
 
                     ! check bounds:
                     if (idx_bcint_icerds < idx_bcint_icerds_min) idx_bcint_icerds = idx_bcint_icerds_min
@@ -2234,6 +2317,9 @@ contains
                     if (idx_bcext_nclrds < idx_bc_nclrds_min) idx_bcext_nclrds = idx_bc_nclrds_min
                     if (idx_bcext_nclrds > idx_bc_nclrds_max) idx_bcext_nclrds = idx_bc_nclrds_max
 
+                    ! print ice index (debug):
+                    !write(iulog,*) "MGF: ice index= ", idx_bcint_icerds
+
                     ! retrieve absorption enhancement factor for within-ice BC
                     enh_fct = bcenh(bnd_idx,idx_bcint_nclrds,idx_bcint_icerds)
 
@@ -2263,55 +2349,43 @@ contains
 #endif
                     !mgf--
 
-                      L_snw   = h2osno_ice_lcl(i)+h2osno_liq_lcl(i)
-                      tau_snw = L_snw * ext_cff_mss_snw_lcl(i)
+                      L_snw(i)   = h2osno_ice_lcl(i)+h2osno_liq_lcl(i)
+                      tau_snw(i) = L_snw(i)*ext_cff_mss_snw_lcl(i)
 
                       do j=1,sno_nbr_aer
+                         L_aer(i,j)   = L_snw(i)*mss_cnc_aer_lcl(i,j)
+                         tau_aer(i,j) = L_aer(i,j)*ext_cff_mss_aer_lcl(j)
+                      enddo
 
-                        if ( (numrad_snw == 5).and.((bnd_idx == 5).or.(bnd_idx == 4)) ) then
-                            L_aer = 0._r8
-                        elseif ( (numrad_snw == 3).and.(bnd_idx == 3) ) then
-                            L_aer = 0._r8
-                        else
-                            L_aer = L_snw * mss_cnc_aer_in(i,j)
-                        end if
-
-                        tau_aer  = L_aer * ext_cff_mss_aer_lcl(j)
-                        !
-                        tau_sum    = tau_sum + tau_aer
-                        omega_sum  = omega_sum + (tau_aer * ss_alb_aer_lcl(j))
-                        g_sum      = g_sum + (tau_aer * ss_alb_aer_lcl(j) * asm_prm_aer_lcl(j))
-                     enddo
+                      tau_sum   = 0._r8
+                      omega_sum = 0._r8
+                      g_sum     = 0._r8
 
-                     tau_i    = tau_sum + tau_snw
-                     omega_i  = (1/tau_i)*(omega_sum+(ss_alb_snw_lcl(i)*tau_snw ))
-                     g_i      = (1/(tau_i*omega_i))*(g_sum+ (asm_prm_snw_lcl(i)*ss_alb_snw_lcl(i)*tau_snw))
+                      do j=1,sno_nbr_aer
+                         tau_sum    = tau_sum + tau_aer(i,j)
+                         omega_sum  = omega_sum + (tau_aer(i,j)*ss_alb_aer_lcl(j))
+                         g_sum      = g_sum + (tau_aer(i,j)*ss_alb_aer_lcl(j)*asm_prm_aer_lcl(j))
+                      enddo
 
-                     if (DELTA == 1) then
-                        g_star(i)     = g_i/(1+g_i)
-                        omega_star(i) = ((1-(g_i**2))*omega_i) / (1-(omega_i*(g_i**2)))
-                        tau_star(i)   = (1-(omega_i*(g_i**2)))*tau_i
-                     else
-                        g_star(i)     = g_i
-                        omega_star(i) = omega_i
-                        tau_star(i)   = tau_i
-                     endif
-                   enddo ! endWeighted Mie parameters of each layer i=snl_top,snl_btm,1
-
-                   ! ! DELTA transformations, if requested
-                   ! if (DELTA == 1) then
-                   !    do i=snl_top,snl_btm,1
-                   !       g_star(i)     = g(i)/(1+g(i))
-                   !       omega_star(i) = ((1-(g(i)**2))*omega(i)) / (1-(omega(i)*(g(i)**2)))
-                   !       tau_star(i)   = (1-(omega(i)*(g(i)**2)))*tau(i)
-                   !    enddo
-                   ! else
-                   !    do i=snl_top,snl_btm,1
-                   !       g_star(i)     = g(i)
-                   !       omega_star(i) = omega(i)
-                   !       tau_star(i)   = tau(i)
-                   !    enddo
-                   ! endif
+                      tau(i)    = tau_sum + tau_snw(i)
+                      omega(i)  = (1/tau(i))*(omega_sum+(ss_alb_snw_lcl(i)*tau_snw(i)))
+                      g(i)      = (1/(tau(i)*omega(i)))*(g_sum+ (asm_prm_snw_lcl(i)*ss_alb_snw_lcl(i)*tau_snw(i)))
+                   enddo ! endWeighted Mie parameters of each layer
+
+                   ! DELTA transformations, if requested
+                   if (DELTA == 1) then
+                      do i=snl_top,snl_btm,1
+                         g_star(i)     = g(i)/(1+g(i))
+                         omega_star(i) = ((1-(g(i)**2))*omega(i)) / (1-(omega(i)*(g(i)**2)))
+                         tau_star(i)   = (1-(omega(i)*(g(i)**2)))*tau(i)
+                      enddo
+                   else
+                      do i=snl_top,snl_btm,1
+                         g_star(i)     = g(i)
+                         omega_star(i) = omega(i)
+                         tau_star(i)   = tau(i)
+                      enddo
+                   endif
 
                    ! Begin radiative transfer solver
                    ! Given input vertical profiles of optical properties, evaluate the
@@ -2467,11 +2541,11 @@ contains
 
                   ! set the underlying ground albedo == albedo of near-IR
                   ! unless bnd_idx == 1, for visible
-                  rupdir(snl_btm_itf) = albsfc(2)
-                  rupdif(snl_btm_itf) = albsfc(2)
+                  rupdir(snl_btm_itf) = albsfc(c_idx,2)
+                  rupdif(snl_btm_itf) = albsfc(c_idx,2)
                   if (bnd_idx == 1) then
-                      rupdir(snl_btm_itf) = albsfc(1)
-                      rupdif(snl_btm_itf) = albsfc(1)
+                      rupdir(snl_btm_itf) = albsfc(c_idx,1)
+                      rupdif(snl_btm_itf) = albsfc(c_idx,1)
                   endif
 
                   do i=snl_btm,snl_top,-1
@@ -2551,17 +2625,22 @@ contains
                   do i=snl_top,snl_btm,1
                     F_abs(i) = dftmp(i)-dftmp(i+1)
                     flx_abs_lcl(i,bnd_idx) = F_abs(i)
-#ifndef _OPENACC
+
                     ! ERROR check: negative absorption
                     if (flx_abs_lcl(i,bnd_idx) < -0.00001) then
                       write (iulog,"(a,e13.6,a,i6,a,i6)") "SNICAR ERROR: negative absoption : ", flx_abs_lcl(i,bnd_idx), &
-                           " at timestep: ", " at column: ", c_idx
-                      write(iulog,*) "SNICAR_AD STATS: snw_rds(0)= ", snw_rds(0)
-                      write(iulog,*) "SNICAR_AD STATS: L_snw= ", L_snw
+                           " at timestep: ", nstep, " at column: ", c_idx
+                      write(iulog,*) "SNICAR_AD STATS: snw_rds(0)= ", snw_rds(c_idx,0)
+                      write(iulog,*) "SNICAR_AD STATS: L_snw(0)= ", L_snw(0)
                       write(iulog,*) "SNICAR_AD STATS: h2osno= ", h2osno_lcl, " snl= ", snl_lcl
+                      write(iulog,*) "SNICAR_AD STATS: soot1(0)= ", mss_cnc_aer_lcl(0,1)
+                      write(iulog,*) "SNICAR_AD STATS: soot2(0)= ", mss_cnc_aer_lcl(0,2)
+                      write(iulog,*) "SNICAR_AD STATS: dust1(0)= ", mss_cnc_aer_lcl(0,3)
+                      write(iulog,*) "SNICAR_AD STATS: dust2(0)= ", mss_cnc_aer_lcl(0,4)
+                      write(iulog,*) "SNICAR_AD STATS: dust3(0)= ", mss_cnc_aer_lcl(0,5)
+                      write(iulog,*) "SNICAR_AD STATS: dust4(0)= ", mss_cnc_aer_lcl(0,6)
                       call endrun(decomp_index=c_idx, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
                     endif
-#endif
                   enddo
 
                   ! absobed flux by the underlying ground
@@ -2599,16 +2678,15 @@ contains
 
                 ! Energy conservation check:
                 ! Incident direct+diffuse radiation equals (absorbed+bulk_transmitted+bulk_reflected)
-                energy_sum = (mu_not*pi*flx_slrd_lcl ) + flx_slri_lcl  - (F_abs_sum + F_btm_net + F_sfc_pls)
-#ifndef _OPENACC
+                energy_sum = (mu_not*pi*flx_slrd_lcl(bnd_idx)) + flx_slri_lcl(bnd_idx) - (F_abs_sum + F_btm_net + F_sfc_pls)
                 if (abs(energy_sum) > 0.00001_r8) then
                    write (iulog,"(a,e13.6,a,i6,a,i6)") "SNICAR ERROR: Energy conservation error of : ", energy_sum, &
-                         " at column: ", c_idx
+                        " at timestep: ", nstep, " at column: ", c_idx
                    write(iulog,*) "F_abs_sum: ",F_abs_sum
                    write(iulog,*) "F_btm_net: ",F_btm_net
                    write(iulog,*) "F_sfc_pls: ",F_sfc_pls
-                   write(iulog,*) "mu_not*pi*flx_slrd_lcl(bnd_idx): ", mu_not*pi*flx_slrd_lcl
-                   write(iulog,*) "flx_slri_lcl(bnd_idx)", flx_slri_lcl
+                   write(iulog,*) "mu_not*pi*flx_slrd_lcl(bnd_idx): ", mu_not*pi*flx_slrd_lcl(bnd_idx)
+                   write(iulog,*) "flx_slri_lcl(bnd_idx)", flx_slri_lcl(bnd_idx)
                    write(iulog,*) "bnd_idx", bnd_idx
                    write(iulog,*) "F_abs", F_abs
                    write(iulog,*) "albedo", albedo
@@ -2618,42 +2696,54 @@ contains
                 albout_lcl(bnd_idx) = albedo
                 ! Check that albedo is less than 1
                 if (albout_lcl(bnd_idx) > 1.0) then
-                   write (iulog,*) "SNICAR ERROR: Albedo > 1.0 at c: ", c_idx
+                   write (iulog,*) "SNICAR ERROR: Albedo > 1.0 at c: ", c_idx, " NSTEP= ",nstep
                    write (iulog,*) "SNICAR STATS: bnd_idx= ",bnd_idx
                    write (iulog,*) "SNICAR STATS: albout_lcl(bnd)= ",albout_lcl(bnd_idx), &
-                        " albsfc_lcl= ",albsfc_lcl
+                        " albsfc_lcl(bnd_idx)= ",albsfc_lcl(bnd_idx)
+                   write (iulog,*) "SNICAR STATS: landtype= ", sfctype
                    write (iulog,*) "SNICAR STATS: h2osno= ", h2osno_lcl, " snl= ", snl_lcl
-                   write (iulog,*) "SNICAR STATS: coszen= ", coszen, " flg_slr= ", flg_slr_in
-
-                   write (iulog,*) "SNICAR STATS: snw_rds(-4)= ", snw_rds(-4)
-                   write (iulog,*) "SNICAR STATS: snw_rds(-3)= ", snw_rds(-3)
-                   write (iulog,*) "SNICAR STATS: snw_rds(-2)= ", snw_rds(-2)
-                   write (iulog,*) "SNICAR STATS: snw_rds(-1)= ", snw_rds(-1)
-                   write (iulog,*) "SNICAR STATS: snw_rds(0)= ", snw_rds(0)
+                   write (iulog,*) "SNICAR STATS: coszen= ", coszen(c_idx), " flg_slr= ", flg_slr_in
+
+                   write (iulog,*) "SNICAR STATS: soot(-4)= ", mss_cnc_aer_lcl(-4,1)
+                   write (iulog,*) "SNICAR STATS: soot(-3)= ", mss_cnc_aer_lcl(-3,1)
+                   write (iulog,*) "SNICAR STATS: soot(-2)= ", mss_cnc_aer_lcl(-2,1)
+                   write (iulog,*) "SNICAR STATS: soot(-1)= ", mss_cnc_aer_lcl(-1,1)
+                   write (iulog,*) "SNICAR STATS: soot(0)= ", mss_cnc_aer_lcl(0,1)
+
+                   write (iulog,*) "SNICAR STATS: L_snw(-4)= ", L_snw(-4)
+                   write (iulog,*) "SNICAR STATS: L_snw(-3)= ", L_snw(-3)
+                   write (iulog,*) "SNICAR STATS: L_snw(-2)= ", L_snw(-2)
+                   write (iulog,*) "SNICAR STATS: L_snw(-1)= ", L_snw(-1)
+                   write (iulog,*) "SNICAR STATS: L_snw(0)= ", L_snw(0)
+
+                   write (iulog,*) "SNICAR STATS: snw_rds(-4)= ", snw_rds(c_idx,-4)
+                   write (iulog,*) "SNICAR STATS: snw_rds(-3)= ", snw_rds(c_idx,-3)
+                   write (iulog,*) "SNICAR STATS: snw_rds(-2)= ", snw_rds(c_idx,-2)
+                   write (iulog,*) "SNICAR STATS: snw_rds(-1)= ", snw_rds(c_idx,-1)
+                   write (iulog,*) "SNICAR STATS: snw_rds(0)= ", snw_rds(c_idx,0)
 
                    call endrun(decomp_index=c_idx, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
                 endif
-#endif
 
              enddo   ! loop over wvl bands
 
 
              ! Weight output NIR albedo appropriately
-             albout(1) = albout_lcl(1)
+             albout(c_idx,1) = albout_lcl(1)
              flx_sum         = 0._r8
              do bnd_idx= nir_bnd_bgn,nir_bnd_end
-                flx_sum = flx_sum + flx_wgt(bnd_idx) * albout_lcl(bnd_idx)
+                flx_sum = flx_sum + flx_wgt(bnd_idx)*albout_lcl(bnd_idx)
              enddo
-             albout(2) = flx_sum / sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
+             albout(c_idx,2) = flx_sum / sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
 
              ! Weight output NIR absorbed layer fluxes (flx_abs) appropriately
-             flx_abs(:,1) = flx_abs_lcl(:,1)
+             flx_abs(c_idx,:,1) = flx_abs_lcl(:,1)
              do i=snl_top,1,1
                 flx_sum = 0._r8
                 do bnd_idx= nir_bnd_bgn,nir_bnd_end
                    flx_sum = flx_sum + flx_wgt(bnd_idx)*flx_abs_lcl(i,bnd_idx)
                 enddo
-                flx_abs(i,2) = flx_sum / sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
+                flx_abs(c_idx,i,2) = flx_sum / sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
              enddo
 
              ! near-IR direct albedo/absorption adjustment for high solar zenith angles
@@ -2663,27 +2753,27 @@ contains
                 sza_c1 = sza_a0 + sza_a1 * mu_not + sza_a2 * mu_not**2
                 sza_c0 = sza_b0 + sza_b1 * mu_not + sza_b2 * mu_not**2
                 sza_factor = sza_c1 * (log10(snw_rds_lcl(snl_top) * c1) - c6) + sza_c0
-                flx_sza_adjust  = albout(2) * (sza_factor-c1) * sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
-                albout(2) = albout(2) * sza_factor
-                flx_abs(snl_top,2) = flx_abs(snl_top,2) - flx_sza_adjust
+                flx_sza_adjust  = albout(c_idx,2) * (sza_factor-c1) * sum(flx_wgt(nir_bnd_bgn:nir_bnd_end))
+                albout(c_idx,2) = albout(c_idx,2) * sza_factor
+                flx_abs(c_idx,snl_top,2) = flx_abs(c_idx,snl_top,2) - flx_sza_adjust
              endif
 
              ! If snow < minimum_snow, but > 0, and there is sun, set albedo to underlying surface albedo
-          elseif ( (coszen > 0._r8) .and. (h2osno_lcl < min_snw) .and. (h2osno_lcl > 0._r8) ) then
-             albout(1) = albsfc(1)
-             albout(2) = albsfc(2)
+          elseif ( (coszen(c_idx) > 0._r8) .and. (h2osno_lcl < min_snw) .and. (h2osno_lcl > 0._r8) ) then
+             albout(c_idx,1) = albsfc(c_idx,1)
+             albout(c_idx,2) = albsfc(c_idx,2)
 
              ! There is either zero snow, or no sun
           else
-             albout(1) = 0._r8
-             albout(2) = 0._r8
+             albout(c_idx,1) = 0._r8
+             albout(c_idx,2) = 0._r8
           endif    ! if column has snow and coszen > 0
 
-       !enddo    ! loop over all columns
+       enddo    ! loop over all columns
 
      end associate
 
    end subroutine SNICAR_AD_RT
-
+   
 
  end module SnowSnicarMod
diff --git a/components/elm/src/biogeophys/SoilFluxesMod.F90 b/components/elm/src/biogeophys/SoilFluxesMod.F90
index 55240eba43..c76d22d5c9 100644
--- a/components/elm/src/biogeophys/SoilFluxesMod.F90
+++ b/components/elm/src/biogeophys/SoilFluxesMod.F90
@@ -169,7 +169,7 @@ contains
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          j = col_pp%snl(c)+1
-         
+
          ! Calculate difference in soil temperature from last time step, for
          ! flux corrections
 
@@ -284,8 +284,8 @@ contains
                  +frac_h2osfc(c)*t_h2osfc_bef(c)**4)
 
             eflx_soil_grnd(p) = ((1._r8- frac_sno_eff(c))*sabg_soil(p) + frac_sno_eff(c)*sabg_snow(p)) + dlrad(p) &
-                 + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) &
-                 - emg(c)*sb*lw_grnd - emg(c)*sb*t_grnd0(c)**3._r8*(4._r8*tinc(c)) &
+                 + (1-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) &
+                 - emg(c)*sb*lw_grnd - emg(c)*sb*t_grnd0(c)**3*(4._r8*tinc(c)) &
                  - (eflx_sh_grnd(p)+qflx_evap_soi(p)*htvp(c))
 
             if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
@@ -422,14 +422,14 @@ contains
          j = col_pp%snl(c)+1
 
          if (.not. lun_pp%urbpoi(l)) then
-            lw_grnd=(frac_sno_eff(c)*tssbef(c,col_pp%snl(c)+1)**4._r8 &
-                 +(1._r8-frac_sno_eff(c)-frac_h2osfc(c))*tssbef(c,1)**4._r8 &
-                 +frac_h2osfc(c)*t_h2osfc_bef(c)**4._r8)
+            lw_grnd=(frac_sno_eff(c)*tssbef(c,col_pp%snl(c)+1)**4 &
+                 +(1._r8-frac_sno_eff(c)-frac_h2osfc(c))*tssbef(c,1)**4 &
+                 +frac_h2osfc(c)*t_h2osfc_bef(c)**4)
 
             eflx_lwrad_out(p) = ulrad(p) &
-                 + (1._r8-frac_veg_nosno(p))*(1._r8-emg(c))*forc_lwrad(t) &
-                 + (1._r8-frac_veg_nosno(p))*emg(c)*sb*lw_grnd &
-                 + 4._r8*emg(c)*sb*t_grnd0(c)**3._r8*tinc(c)
+                 + (1-frac_veg_nosno(p))*(1.-emg(c))*forc_lwrad(t) &
+                 + (1-frac_veg_nosno(p))*emg(c)*sb*lw_grnd &
+                 + 4._r8*emg(c)*sb*t_grnd0(c)**3*tinc(c)
 
             eflx_lwrad_net(p) = eflx_lwrad_out(p) - forc_lwrad(t)
             if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
diff --git a/components/elm/src/biogeophys/SoilHydrologyMod.F90 b/components/elm/src/biogeophys/SoilHydrologyMod.F90
index 541e25f0c9..99ec2113a2 100644
--- a/components/elm/src/biogeophys/SoilHydrologyMod.F90
+++ b/components/elm/src/biogeophys/SoilHydrologyMod.F90
@@ -9,6 +9,7 @@ module SoilHydrologyMod
   use decompMod         , only : bounds_type
   use elm_varctl        , only : iulog, use_vichydro
   use elm_varcon        , only : e_ice, denh2o, denice, rpi
+  use EnergyFluxType    , only : energyflux_type
   use SoilHydrologyType , only : soilhydrology_type
   use SoilStateType     , only : soilstate_type
   use WaterfluxType     , only : waterflux_type
@@ -43,6 +44,7 @@ contains
     ! Calculate surface runoff
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon      , only : denice, denh2o, wimp, pondmx_urban
     use column_varcon   , only : icol_roof, icol_sunwall, icol_shadewall
     use column_varcon   , only : icol_road_imperv, icol_road_perv
@@ -64,9 +66,9 @@ contains
     ! !LOCAL VARIABLES:
     integer  :: c,j,fc,g,l,i                               !indices
     integer  :: nlevbed                                    !# levels to bedrock
-    real(r8) :: xs(1:num_urbanc)                !excess soil water above urban ponding limit
-    real(r8) :: vol_ice(1:num_hydrologyc,1:nlevgrnd) !partial volume of ice lens in layer
-    real(r8) :: fff(1:num_hydrologyc)               !decay factor (m-1)
+    real(r8) :: xs(bounds%begc:bounds%endc)                !excess soil water above urban ponding limit
+    real(r8) :: vol_ice(bounds%begc:bounds%endc,1:nlevgrnd) !partial volume of ice lens in layer
+    real(r8) :: fff(bounds%begc:bounds%endc)               !decay factor (m-1)
     real(r8) :: s1                                         !variable to calculate qinmax
     real(r8) :: su                                         !variable to calculate qinmax
     real(r8) :: v                                          !variable to calculate qinmax
@@ -117,28 +119,22 @@ contains
          max_infil        =>    soilhydrology_vars%max_infil_col    , & ! Output: [real(r8) (:)   ]  maximum infiltration capacity in VIC (mm)
          i_0              =>    soilhydrology_vars%i_0_col            & ! Output: [real(r8) (:)   ]  column average soil moisture in top VIC layers (mm)
          )
-    !$acc enter data create(&
-    !$acc xs(:), &
-    !$acc vol_ice(:,:), &
-    !$acc fff(:) )
 
-      !NOTE: Need to separate out the vichydro only arrays
+      ! Get time step
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          nlevbed = nlev2bed(c)
-         !$acc loop vector independent
          do j = 1,nlevbed
 
             ! Porosity of soil, partial volume of ice and liquid, fraction of ice in each layer,
             ! fractional impermeability
 
-            vol_ice(fc,j) = min(watsat(c,j), h2osoi_ice(c,j)/(dz(c,j)*denice))
+            vol_ice(c,j) = min(watsat(c,j), h2osoi_ice(c,j)/(dz(c,j)*denice))
             if (origflag == 1) then
                icefrac(c,j) = min(1._r8,h2osoi_ice(c,j)/(h2osoi_ice(c,j)+h2osoi_liq(c,j)))
             else
-               icefrac(c,j) = min(1._r8,vol_ice(fc,j)/watsat(c,j))
+               icefrac(c,j) = min(1._r8,vol_ice(c,j)/watsat(c,j))
             endif
 
             fracice(c,j) = max(0._r8,exp(-3._r8*(1._r8-icefrac(c,j)))- exp(-3._r8))/(1.0_r8-exp(-3._r8))
@@ -146,55 +142,59 @@ contains
       end do
 
       ! Saturated fraction
-      !NOTE : assuming use_vichydro is .false. 
-      !$acc parallel loop independent gang vector default(present) 
+
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
-         fff(fc) = 0.5_r8
+         fff(c) = 0.5_r8
          if (zengdecker_2009_with_var_soil_thick) then
             nlevbed = nlev2bed(c)
-            fff(fc) = 0.5_r8 * col_pp%zi(c,nlevsoi) / min(col_pp%zi(c,nlevbed), col_pp%zi(c,nlevsoi))
+            fff(c) = 0.5_r8 * col_pp%zi(c,nlevsoi) / min(col_pp%zi(c,nlevbed), col_pp%zi(c,nlevsoi))
+         end if
+         if (use_vichydro) then
+            top_moist(c) = 0._r8
+            top_ice(c) = 0._r8
+            top_max_moist(c) = 0._r8
+            do j = 1, nlayer - 1
+               top_ice(c) = top_ice(c) + ice(c,j)
+               top_moist(c) =  top_moist(c) + moist(c,j) + ice(c,j)
+               top_max_moist(c) = top_max_moist(c) + max_moist(c,j)
+            end do
+            if(top_moist(c)> top_max_moist(c)) top_moist(c)= top_max_moist(c)
+            top_ice(c)     = max(0._r8,top_ice(c))
+            max_infil(c)   = (1._r8+b_infil(c)) * top_max_moist(c)
+            ex(c)          = b_infil(c) / (1._r8 + b_infil(c))
+            A(c)           = 1._r8 - (1._r8 - top_moist(c) / top_max_moist(c))**ex(c)
+            i_0(c)         = max_infil(c) * (1._r8 - (1._r8 - A(c))**(1._r8/b_infil(c)))
+            fsat(c)        = A(c)  !for output
+         else
+            fsat(c) = wtfact(c) * exp(-0.5_r8*fff(c)*zwt(c))
          end if
-         !if (use_vichydro) then
-         !   top_moist(c) = 0._r8
-         !   top_ice(c) = 0._r8
-         !   top_max_moist(c) = 0._r8
-         !   do j = 1, nlayer - 1
-         !      top_ice(c) = top_ice(c) + ice(c,j)
-         !      top_moist(c) =  top_moist(c) + moist(c,j) + ice(c,j)
-         !      top_max_moist(c) = top_max_moist(c) + max_moist(c,j)
-         !   end do
-         !   if(top_moist(c)> top_max_moist(c)) top_moist(c)= top_max_moist(c)
-         !   top_ice(c)     = max(0._r8,top_ice(c))
-         !   max_infil(c)   = (1._r8+b_infil(c)) * top_max_moist(c)
-         !   ex(c)          = b_infil(c) / (1._r8 + b_infil(c))
-         !   A(c)           = 1._r8 - (1._r8 - top_moist(c) / top_max_moist(c))**ex(c)
-         !   i_0(c)         = max_infil(c) * (1._r8 - (1._r8 - A(c))**(1._r8/b_infil(c)))
-         !   fsat(c)        = A(c)  !for output
-         !else
-         fsat(c) = wtfact(c) * exp(-0.5_r8*fff(fc)*zwt(c))
-         !end if
 
          ! use perched water table to determine fsat (if present)
          if ( frost_table(c) > zwt(c)) then
-            !if (use_vichydro) then
-            !   fsat(c) =  A(c)
-            !else
-            fsat(c) = wtfact(c) * exp(-0.5_r8*fff(fc)*zwt(c))
-            !end if
+            if (use_vichydro) then
+               fsat(c) =  A(c)
+            else
+               fsat(c) = wtfact(c) * exp(-0.5_r8*fff(c)*zwt(c))
+            end if
          else
             if ( frost_table(c) > zwt_perched(c)) then
-               fsat(c) = wtfact(c) * exp(-0.5_r8*fff(fc)*zwt_perched(c))!*( frost_table(c) - zwt_perched(c))/4.0
+               fsat(c) = wtfact(c) * exp(-0.5_r8*fff(c)*zwt_perched(c))!*( frost_table(c) - zwt_perched(c))/4.0
             endif
          endif
          if (origflag == 1) then
+            if (use_vichydro) then
+#ifndef _OPENACC
+               call endrun(msg="VICHYDRO is not available for origflag=1"//errmsg(__FILE__, __LINE__))
+#endif
+            else
                fcov(c) = (1._r8 - fracice(c,1)) * fsat(c) + fracice(c,1)
+            end if
          else
             fcov(c) = fsat(c)
          endif
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
 
@@ -210,7 +210,6 @@ contains
       ! Determine water in excess of ponding limit for urban roof and impervious road.
       ! Excess goes to surface runoff. No surface runoff for sunwall and shadewall.
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_urbanc
          c = filter_urbanc(fc)
          if (col_pp%itype(c) == icol_roof .or. col_pp%itype(c) == icol_road_imperv) then
@@ -219,54 +218,45 @@ contains
             if (snl(c) < 0) then
                qflx_surf(c) = max(0._r8,qflx_top_soil(c))
             else
-               xs(fc) = max(0._r8, &
+               xs(c) = max(0._r8, &
                     h2osoi_liq(c,1)/dtime + qflx_top_soil(c) - qflx_evap_grnd(c) - &
                     pondmx_urban/dtime)
-               if (xs(fc) > 0._r8) then
+               if (xs(c) > 0.) then
                   h2osoi_liq(c,1) = pondmx_urban
                else
                   h2osoi_liq(c,1) = max(0._r8,h2osoi_liq(c,1)+ &
                        (qflx_top_soil(c)-qflx_evap_grnd(c))*dtime)
                end if
-               qflx_surf(c) = xs(fc)
+               qflx_surf(c) = xs(c)
             end if
          else if (col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall) then
             qflx_surf(c) = 0._r8
          end if
          ! send flood water flux to runoff for all urban columns
          qflx_surf(c) = qflx_surf(c)  + qflx_floodc(c)
+
       end do
 
       ! remove stormflow and snow on h2osfc from qflx_top_soil
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          ! add flood water flux to qflx_top_soil
          qflx_top_soil(c) = qflx_top_soil(c) + qflx_snow_h2osfc(c) + qflx_floodc(c)
       end do
 
-    !$acc exit data delete(&
-    !$acc xs(:), &
-    !$acc vol_ice(:,:), &
-    !$acc fff(:) )
-    !!!$acc A(:), &
-    !!!$acc ex(:), &
-    !!!$acc top_moist(:), &
-    !!!$acc top_max_moist(:), &
-    !!!$acc top_ice(:))
-
     end associate
 
    end subroutine SurfaceRunoff
 
    !-----------------------------------------------------------------------
    subroutine Infiltration(bounds, num_hydrologyc, filter_hydrologyc, num_urbanc, filter_urbanc, &
-        soilhydrology_vars, soilstate_vars, dtime)
+        energyflux_vars, soilhydrology_vars, soilstate_vars, dtime)
      !
      ! !DESCRIPTION:
      ! Calculate infiltration into surface soil layer (minus the evaporation)
      !
      ! !USES:
+      !$acc routine seq
      use shr_const_mod    , only : shr_const_pi
      use elm_varpar       , only : nlayer, nlayert
      use elm_varpar       , only : nlevsoi, nlevgrnd
@@ -280,6 +270,7 @@ contains
      integer                  , intent(in)    :: filter_hydrologyc(:) ! column filter for soil points
      integer                  , intent(in)    :: num_urbanc           ! number of column urban points in column filter
      integer                  , intent(in)    :: filter_urbanc(:)     ! column filter for urban points
+     type(energyflux_type)    , intent(in)    :: energyflux_vars
      type(soilhydrology_type) , intent(inout) :: soilhydrology_vars
      type(soilstate_type)     , intent(inout) :: soilstate_vars
      real(r8), intent(in)  :: dtime
@@ -289,13 +280,13 @@ contains
      integer  :: nlevbed                                    !# levels to bedrock
      real(r8) :: s1,su,v                                    ! variable to calculate qinmax
      real(r8) :: qinmax                                     ! maximum infiltration capacity (mm/s)
-     real(r8) :: vol_ice(1:num_hydrologyc,1:nlevgrnd) ! partial volume of ice lens in layer
+     real(r8) :: vol_ice(bounds%begc:bounds%endc,1:nlevgrnd) ! partial volume of ice lens in layer
      real(r8) :: alpha_evap(bounds%begc:bounds%endc)        ! fraction of total evap from h2osfc
-     real(r8) :: qflx_evap(1:num_hydrologyc)         ! local evaporation array
-     real(r8) :: qflx_h2osfc_drain(1:num_hydrologyc) ! bottom drainage from h2osfc
-     real(r8) :: qflx_in_h2osfc(1:num_hydrologyc)    ! surface input to h2osfc
-     real(r8) :: qflx_in_soil(1:num_hydrologyc)      ! surface input to soil
-     real(r8) :: qflx_infl_excess(1:num_hydrologyc)  ! infiltration excess runoff -> h2osfc
+     real(r8) :: qflx_evap(bounds%begc:bounds%endc)         ! local evaporation array
+     real(r8) :: qflx_h2osfc_drain(bounds%begc:bounds%endc) ! bottom drainage from h2osfc
+     real(r8) :: qflx_in_h2osfc(bounds%begc:bounds%endc)    ! surface input to h2osfc
+     real(r8) :: qflx_in_soil(bounds%begc:bounds%endc)      ! surface input to soil
+     real(r8) :: qflx_infl_excess(bounds%begc:bounds%endc)  ! infiltration excess runoff -> h2osfc
      real(r8) :: frac_infclust                              ! fraction of submerged area that is connected
      real(r8) :: fsno                                       ! copy of frac_sno
      real(r8) :: k_wet                                      ! linear reservoir coefficient for h2osfc
@@ -367,34 +358,20 @@ contains
           h2osfcflag           =>    soilhydrology_vars%h2osfcflag           , & ! Input:  logical
           icefrac              =>    soilhydrology_vars%icefrac_col            & ! Output: [real(r8) (:,:) ]  fraction of ice
               )
-     !$acc enter data create(&
-     !$acc vol_ice(:,:), &
-     !$acc alpha_evap(:), &
-     !$acc qflx_evap(:), &
-     !$acc qflx_h2osfc_drain(:), &
-     !$acc qflx_in_h2osfc(:), &
-     !$acc qflx_in_soil(:), &
-     !$acc qflx_infl_excess(:), &
-     !$acc top_moist(:), &
-     !$acc top_max_moist(:), &
-     !$acc top_ice(:))
+
 
        ! Infiltration into surface soil layer (minus the evaporation)
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
           nlevbed = nlev2bed(c)
-          !$acc loop vector independent 
           do j = 1,nlevbed
              ! Porosity of soil, partial volume of ice and liquid
-             vol_ice(fc,j) = min(watsat(c,j), h2osoi_ice(c,j)/(dz(c,j)*denice))
-             eff_porosity(c,j) = max(0.01_r8,watsat(c,j)-vol_ice(fc,j))
-             icefrac(c,j) = min(1._r8,vol_ice(fc,j)/watsat(c,j))
+             vol_ice(c,j) = min(watsat(c,j), h2osoi_ice(c,j)/(dz(c,j)*denice))
+             eff_porosity(c,j) = max(0.01_r8,watsat(c,j)-vol_ice(c,j))
+             icefrac(c,j) = min(1._r8,vol_ice(c,j)/watsat(c,j))
           end do
        end do
 
-       !NOTE : Assuming use_vichydro is .false.
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
           ! partition moisture fluxes between soil and h2osfc
@@ -404,61 +381,61 @@ contains
              if (snl(c) >= 0) then
                 fsno=0._r8
                 ! if no snow layers, sublimation is removed from h2osoi_ice in drainage
-                qflx_evap(fc)=qflx_evap_grnd(c)
+                qflx_evap(c)=qflx_evap_grnd(c)
              else
                 fsno=frac_sno(c)
-                qflx_evap(fc)=qflx_ev_soil(c)
+                qflx_evap(c)=qflx_ev_soil(c)
              endif
 
              !1. partition surface inputs between soil and h2osfc
-             qflx_in_soil(fc) = (1._r8 - frac_h2osfc(c)) * (qflx_top_soil(c)  - qflx_surf(c))
-             qflx_in_h2osfc(fc) = frac_h2osfc(c) * (qflx_top_soil(c)  - qflx_surf(c))
+             qflx_in_soil(c) = (1._r8 - frac_h2osfc(c)) * (qflx_top_soil(c)  - qflx_surf(c))
+             qflx_in_h2osfc(c) = frac_h2osfc(c) * (qflx_top_soil(c)  - qflx_surf(c))
              qflx_gross_infl_soil(c) = (1._r8 - frac_h2osfc(c)) * (qflx_top_soil(c)  - qflx_surf(c))
 
              !2. remove evaporation (snow treated in SnowHydrology)
-             qflx_in_soil(fc) = qflx_in_soil(fc) - (1.0_r8 - fsno - frac_h2osfc(c))*qflx_evap(fc)
-             qflx_in_h2osfc(fc) =  qflx_in_h2osfc(fc)  - frac_h2osfc(c) * qflx_ev_h2osfc(c)
+             qflx_in_soil(c) = qflx_in_soil(c) - (1.0_r8 - fsno - frac_h2osfc(c))*qflx_evap(c)
+             qflx_in_h2osfc(c) =  qflx_in_h2osfc(c)  - frac_h2osfc(c) * qflx_ev_h2osfc(c)
 
-             if (qflx_evap(fc)>0._r8) then
-                qflx_gross_evap_soil(c) = (1.0_r8 - fsno - frac_h2osfc(c))*qflx_evap(fc)
+             if (qflx_evap(c)>0._r8) then
+                qflx_gross_evap_soil(c) = (1.0_r8 - fsno - frac_h2osfc(c))*qflx_evap(c)
              else
                 qflx_gross_evap_soil(c) = 0._r8
-                qflx_gross_infl_soil(c) = qflx_gross_infl_soil(c)-(1.0_r8 - fsno - frac_h2osfc(c))*qflx_evap(fc)
+                qflx_gross_infl_soil(c) = qflx_gross_infl_soil(c)-(1.0_r8 - fsno - frac_h2osfc(c))*qflx_evap(c)
              endif
 
              !3. determine maximum infiltration rate
-             !if (use_vichydro) then
-             !   !top_moist(c)= 0._r8
-             !   !top_ice(c)=0._r8
-             !   !top_max_moist(c)= 0._r8
-             !   !do j = 1, nlayer - 1
-             !   !   top_ice(c) = top_ice(c) + ice(c,j)
-             !   !   top_moist(c) =  top_moist(c) + moist(c,j) + ice(c,j)
-             !   !   top_max_moist(c) = top_max_moist(c) + max_moist(c,j)
-             !   !end do
-             !   !top_icefrac = min(1._r8,top_ice(c)/top_max_moist(c))
-             !   !if(qflx_in_soil(c) <= 0._r8) then
-             !   !   rsurf_vic = 0._r8
-             !   !else if(max_infil(c) <= 0._r8) then
-             !   !   rsurf_vic = qflx_in_soil(c)
-             !   !else if((i_0(c) + qflx_in_soil(c)*dtime) > max_infil(c)) then             !(Eq.(3a) Wood et al. 1992)
-             !   !   rsurf_vic = (qflx_in_soil(c)*dtime - top_max_moist(c) + top_moist(c))/dtime
-             !   !else                                                                      !(Eq.(3b) Wood et al. 1992)
-             !   !   basis = 1._r8 - (i_0(c) + qflx_in_soil(c)*dtime)/max_infil(c)
-             !   !   rsurf_vic = (qflx_in_soil(c)*dtime - top_max_moist(c) + top_moist(c)    &
-             !   !        + top_max_moist(c) * basis**(1._r8 + b_infil(c)))/dtime
-             !   !end if
-             !   !rsurf_vic = min(qflx_in_soil(c), rsurf_vic)
-             !   !qinmax = (1._r8 - fsat(c)) * 10._r8**(-e_ice*top_icefrac)*(qflx_in_soil(c) - rsurf_vic)
-             !else
-             qinmax=(1._r8 - fsat(c)) * minval(10._r8**(-e_ice*(icefrac(c,1:3)))*hksat(c,1:3))
-            !end if
-             qflx_infl_excess(fc) = max(0._r8,qflx_in_soil(fc) -  (1.0_r8 - frac_h2osfc(c))*qinmax)
+             if (use_vichydro) then
+                top_moist(c)= 0._r8
+                top_ice(c)=0._r8
+                top_max_moist(c)= 0._r8
+                do j = 1, nlayer - 1
+                   top_ice(c) = top_ice(c) + ice(c,j)
+                   top_moist(c) =  top_moist(c) + moist(c,j) + ice(c,j)
+                   top_max_moist(c) = top_max_moist(c) + max_moist(c,j)
+                end do
+                top_icefrac = min(1._r8,top_ice(c)/top_max_moist(c))
+                if(qflx_in_soil(c) <= 0._r8) then
+                   rsurf_vic = 0._r8
+                else if(max_infil(c) <= 0._r8) then
+                   rsurf_vic = qflx_in_soil(c)
+                else if((i_0(c) + qflx_in_soil(c)*dtime) > max_infil(c)) then             !(Eq.(3a) Wood et al. 1992)
+                   rsurf_vic = (qflx_in_soil(c)*dtime - top_max_moist(c) + top_moist(c))/dtime
+                else                                                                      !(Eq.(3b) Wood et al. 1992)
+                   basis = 1._r8 - (i_0(c) + qflx_in_soil(c)*dtime)/max_infil(c)
+                   rsurf_vic = (qflx_in_soil(c)*dtime - top_max_moist(c) + top_moist(c)    &
+                        + top_max_moist(c) * basis**(1._r8 + b_infil(c)))/dtime
+                end if
+                rsurf_vic = min(qflx_in_soil(c), rsurf_vic)
+                qinmax = (1._r8 - fsat(c)) * 10._r8**(-e_ice*top_icefrac)*(qflx_in_soil(c) - rsurf_vic)
+             else
+                qinmax=(1._r8 - fsat(c)) * minval(10._r8**(-e_ice*(icefrac(c,1:3)))*hksat(c,1:3))
+             end if
+             qflx_infl_excess(c) = max(0._r8,qflx_in_soil(c) -  (1.0_r8 - frac_h2osfc(c))*qinmax)
 
              !4. soil infiltration and h2osfc "run-on"
-             qflx_infl(c) = qflx_in_soil(fc) - qflx_infl_excess(fc)
-             qflx_in_h2osfc(fc) =  qflx_in_h2osfc(fc) + qflx_infl_excess(fc)
-             qflx_gross_infl_soil(c) = qflx_gross_infl_soil(c)- qflx_infl_excess(fc)
+             qflx_infl(c) = qflx_in_soil(c) - qflx_infl_excess(c)
+             qflx_in_h2osfc(c) =  qflx_in_h2osfc(c) + qflx_infl_excess(c)
+             qflx_gross_infl_soil(c) = qflx_gross_infl_soil(c)- qflx_infl_excess(c)
 
              !5. surface runoff from h2osfc
              if (h2osfcflag==1) then
@@ -488,34 +465,34 @@ contains
              if(h2osfcflag==0) then
                 qflx_h2osfc_surf(c)= 0._r8
                 ! shift infiltration excess from h2osfc input to surface runoff
-                qflx_in_h2osfc(fc) =  qflx_in_h2osfc(fc) - qflx_infl_excess(fc)
-                qflx_surf(c)= qflx_surf(c) + qflx_infl_excess(fc)
-                qflx_infl_excess(fc) = 0._r8
+                qflx_in_h2osfc(c) =  qflx_in_h2osfc(c) - qflx_infl_excess(c)
+                qflx_surf(c)= qflx_surf(c) + qflx_infl_excess(c)
+                qflx_infl_excess(c) = 0._r8
              endif
 
-             qflx_in_h2osfc(fc) =  qflx_in_h2osfc(fc) - qflx_h2osfc_surf(c)
+             qflx_in_h2osfc(c) =  qflx_in_h2osfc(c) - qflx_h2osfc_surf(c)
 
              !6. update h2osfc prior to calculating bottom drainage from h2osfc
-             h2osfc(c) = h2osfc(c) + qflx_in_h2osfc(fc) * dtime
+             h2osfc(c) = h2osfc(c) + qflx_in_h2osfc(c) * dtime
 
              !--  if all water evaporates, there will be no bottom drainage
              if (h2osfc(c) < 0.0) then
                 qflx_infl(c) = qflx_infl(c) + h2osfc(c)/dtime
                 qflx_gross_evap_soil(c) = qflx_gross_evap_soil(c) - h2osfc(c)/dtime
                 h2osfc(c) = 0.0
-                qflx_h2osfc_drain(fc)= 0._r8
+                qflx_h2osfc_drain(c)= 0._r8
              else
-                qflx_h2osfc_drain(fc)=min(frac_h2osfc(c)*qinmax,h2osfc(c)/dtime)
+                qflx_h2osfc_drain(c)=min(frac_h2osfc(c)*qinmax,h2osfc(c)/dtime)
              endif
 
              if(h2osfcflag==0) then
-                qflx_h2osfc_drain(fc)= max(0._r8,h2osfc(c)/dtime) !ensure no h2osfc
+                qflx_h2osfc_drain(c)= max(0._r8,h2osfc(c)/dtime) !ensure no h2osfc
              endif
 
              !7. remove drainage from h2osfc and add to qflx_infl
-             h2osfc(c) = h2osfc(c) - qflx_h2osfc_drain(fc) * dtime
-             qflx_infl(c) = qflx_infl(c) + qflx_h2osfc_drain(fc)
-             qflx_gross_infl_soil(c) = qflx_gross_infl_soil(c) + qflx_h2osfc_drain(fc)
+             h2osfc(c) = h2osfc(c) - qflx_h2osfc_drain(c) * dtime
+             qflx_infl(c) = qflx_infl(c) + qflx_h2osfc_drain(c)
+             qflx_gross_infl_soil(c) = qflx_gross_infl_soil(c) + qflx_h2osfc_drain(c)
           else
              ! non-vegetated landunits (i.e. urban) use original CLM4 code
              if (snl(c) >= 0) then
@@ -536,7 +513,6 @@ contains
 
        ! No infiltration for impervious urban surfaces
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_urbanc
           c = filter_urbanc(fc)
           if (col_pp%itype(c) /= icol_road_perv) then
@@ -544,21 +520,6 @@ contains
           end if
        end do
 
-
-
-
-     !$acc exit data delete(&
-     !$acc vol_ice(:,:), &
-     !$acc alpha_evap(:), &
-     !$acc qflx_evap(:), &
-     !$acc qflx_h2osfc_drain(:), &
-     !$acc qflx_in_h2osfc(:), &
-     !$acc qflx_in_soil(:), &
-     !$acc qflx_infl_excess(:), &
-     !$acc top_moist(:), &
-     !$acc top_max_moist(:), &
-     !$acc top_ice(:))
-
     end associate
 
    end subroutine Infiltration
@@ -571,6 +532,7 @@ contains
      ! Calculate watertable, considering aquifer recharge but no drainage.
      !
      ! !USES:
+      !$acc routine seq
      use elm_varcon       , only : pondmx, tfrz, watmin,denice,denh2o
      use elm_varpar       , only : nlevsoi, nlevgrnd
      use column_varcon    , only : icol_roof, icol_road_imperv
@@ -591,13 +553,20 @@ contains
      ! !LOCAL VARIABLES:
      integer  :: c,j,fc,i,l,g                            ! indices
      integer  :: nlevbed                                 ! # layers to bedrock
-     integer  :: jwt(1:num_hydrologyc)            ! index of the soil layer right above the water table (-)
+     real(r8) :: xs(bounds%begc:bounds%endc)             ! water needed to bring soil moisture to watmin (mm)
+     real(r8) :: dzmm(bounds%begc:bounds%endc,1:nlevgrnd) ! layer thickness (mm)
+     integer  :: jwt(bounds%begc:bounds%endc)            ! index of the soil layer right above the water table (-)
+     real(r8) :: rsub_bot(bounds%begc:bounds%endc)       ! subsurface runoff - bottom drainage (mm/s)
+     real(r8) :: rsub_top(bounds%begc:bounds%endc)       ! subsurface runoff - topographic control (mm/s)
+     real(r8) :: fff(bounds%begc:bounds%endc)            ! decay factor (m-1)
+     real(r8) :: xsi(bounds%begc:bounds%endc)            ! excess soil water above saturation at layer i (mm)
      real(r8) :: rous                                    ! aquifer yield (-)
      real(r8) :: wh                                      ! smpfz(jwt)-z(jwt) (mm)
      real(r8) :: ws                                      ! summation of pore space of layers below water table (mm)
      real(r8) :: s_node                                  ! soil wetness (-)
      real(r8) :: dzsum                                   ! summation of dzmm of layers below water table (mm)
      real(r8) :: icefracsum                              ! summation of icefrac*dzmm of layers below water table (-)
+     real(r8) :: fracice_rsub(bounds%begc:bounds%endc)   ! fractional impermeability of soil layers (-)
      real(r8) :: ka                                      ! hydraulic conductivity of the aquifer (mm/s)
      real(r8) :: dza                                     ! fff*(zwt-z(jwt)) (-)
      real(r8) :: available_h2osoi_liq                    ! available soil liquid water in a layer
@@ -618,7 +587,7 @@ contains
      real(r8) :: q_perch
      real(r8) :: q_perch_max
      real(r8) :: dflag=0._r8
-    real(r8) :: qcharge_temp
+	 real(r8) :: qcharge_temp
      !-----------------------------------------------------------------------
 
      associate(                                                            &
@@ -660,15 +629,19 @@ contains
           qflx_drain_perched =>    col_wf%qflx_drain_perched , & ! Output: [real(r8) (:)   ]  perched wt sub-surface runoff (mm H2O /s)
           qflx_rsub_sat      =>    col_wf%qflx_rsub_sat        & ! Output: [real(r8) (:)   ]  soil saturation excess [mm h2o/s]
           )
-     !$acc enter data create(&
-     !$acc jwt(:), &
-     !$acc qcharge_tot, &
-     !$acc qcharge_layer )
+
 
        ! Convert layer thicknesses from m to mm
 
+       do fc = 1, num_hydrologyc
+          c = filter_hydrologyc(fc)
+          nlevbed = nlev2bed(c)
+          do j = 1,nlevbed
+             dzmm(c,j) = dz(c,j)*1.e3_r8
+          end do
+       end do
+
        if (.not.use_vsfm) then
-          !$acc parallel loop independent gang vector default(present)
           do fc = 1, num_hydrologyc
              c = filter_hydrologyc(fc)
              qflx_drain(c)    = 0._r8
@@ -680,19 +653,17 @@ contains
        ! The layer index of the first unsaturated layer, i.e., the layer right above
        ! the water table
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
           nlevbed = nlev2bed(c)
-          jwt(fc) = nlevbed
+          jwt(c) = nlevbed
           ! allow jwt to equal zero when zwt is in top layer
-          !$acc loop seq
           do j = 1,nlevbed
              if(zwt(c) <= zi(c,j)) then
                 if (zengdecker_2009_with_var_soil_thick .and. zwt(c) == zi(c,nlevbed)) then
                    exit
                 else
-                   jwt(fc) = j-1
+                   jwt(c) = j-1
                    exit
                 end if
              end if
@@ -701,10 +672,9 @@ contains
 
        !============================== QCHARGE =========================================
        ! Water table changes due to qcharge
-       !$acc parallel loop independent gang vector default(present) 
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
-         nlevbed = nlev2bed(c)
+       	  nlevbed = nlev2bed(c)
 
           !scs: use analytical expression for aquifer specific yield
           rous = watsat(c,nlevbed) &
@@ -712,15 +682,15 @@ contains
           rous=max(rous,0.02_r8)
 
           !--  water table is below the soil column  --------------------------------------
-          g = col_pp%gridcell(c)
+		      g = col_pp%gridcell(c)
           l = col_pp%landunit(c)
           qcharge_temp = qcharge(c)
 
           wa(c)  = wa(c) - qflx_grnd_irrig_col(c) * dtime
           zwt(c) = zwt(c) + (qflx_grnd_irrig_col(c) * dtime)/1000._r8/rous
 
-          if(jwt(fc) == nlevbed) then
-              if (.not. (zengdecker_2009_with_var_soil_thick)) then
+          if(jwt(c) == nlevbed) then
+	           if (.not. (zengdecker_2009_with_var_soil_thick)) then
                 wa(c)  = wa(c) + qcharge(c)  * dtime
                 zwt(c) = zwt(c) - (qcharge(c)  * dtime)/1000._r8/rous
              end if
@@ -729,10 +699,10 @@ contains
              ! try to raise water table to account for qcharge
              qcharge_tot = qcharge(c) * dtime
              if(qcharge_tot > 0.) then !rising water table
-               !$acc loop seq 
-                do j = jwt(fc)+1, 1,-1
+                do j = jwt(c)+1, 1,-1
                    !scs: use analytical expression for specific yield
-                   s_y = watsat(c,j) * ( 1. -  (1.+1.e3*zwt(c)/sucsat(c,j))**(-1./bsw(c,j)))
+                   s_y = watsat(c,j) &
+                        * ( 1. -  (1.+1.e3*zwt(c)/sucsat(c,j))**(-1./bsw(c,j)))
                    s_y=max(s_y,0.02_r8)
 
                    qcharge_layer=min(qcharge_tot,(s_y*(zwt(c) - zi(c,j-1))*1.e3))
@@ -744,10 +714,10 @@ contains
                    if (qcharge_tot <= 0.) exit
                 enddo
              else ! deepening water table (negative qcharge)
-                !$acc loop seq 
-                do j = jwt(fc)+1, nlevbed
+                do j = jwt(c)+1, nlevbed
                    !scs: use analytical expression for specific yield
-                   s_y = watsat(c,j) * ( 1. -  (1.+1.e3*zwt(c)/sucsat(c,j))**(-1./bsw(c,j)))
+                   s_y = watsat(c,j) &
+                        * ( 1. -  (1.+1.e3*zwt(c)/sucsat(c,j))**(-1./bsw(c,j)))
                    s_y=max(s_y,0.02_r8)
 
                    qcharge_layer=max(qcharge_tot,-(s_y*(zi(c,j) - zwt(c))*1.e3))
@@ -766,13 +736,13 @@ contains
 
              !-- recompute jwt for following calculations  ---------------------------------
              ! allow jwt to equal zero when zwt is in top layer
-             jwt(fc) = nlevbed
+             jwt(c) = nlevbed
              do j = 1,nlevbed
                 if(zwt(c) <= zi(c,j)) then
                    if (zengdecker_2009_with_var_soil_thick .and. zwt(c) == zi(c,nlevbed)) then
                       exit
                    else
-                      jwt(fc) = j-1
+                      jwt(c) = j-1
                       exit
                    end if
                 end if
@@ -784,10 +754,9 @@ contains
 
        !==  BASEFLOW ==================================================
        ! perched water table code
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
-           nlevbed = nlev2bed(c)
+       	  nlevbed = nlev2bed(c)
 
           ! define frost table as first frozen layer with unfrozen layer above it
           if(t_soisno(c,1) > tfrz) then
@@ -796,7 +765,6 @@ contains
              k_frz=1
           endif
 
-          !$acc loop seq
           do k=2, nlevbed
              if (t_soisno(c,k-1) > tfrz .and. t_soisno(c,k) <= tfrz) then
                 k_frz=k
@@ -821,7 +789,6 @@ contains
              sat_lev=0.9
 
              k_perch=1
-             !$acc loop seq
              do k=k_frz,1,-1
                 h2osoi_vol(c,k) = h2osoi_liq(c,k)/(dz(c,k)*denh2o) &
                      + h2osoi_ice(c,k)/(dz(c,k)*denice)
@@ -851,7 +818,6 @@ contains
           endif
        end do
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
 
@@ -874,7 +840,6 @@ contains
        end do
 
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_urbanc
           c = filter_urbanc(fc)
           ! Renew the ice and liquid mass due to condensation for urban roof and impervious road
@@ -894,11 +859,6 @@ contains
 
        end do
 
-     !$acc exit data delete(&
-     !$acc jwt(:), &
-     !$acc qcharge_tot, &
-     !$acc qcharge_layer )
-
      end associate
 
    end subroutine WaterTable
@@ -911,6 +871,7 @@ contains
      ! Calculate subsurface drainage
      !
      ! !USES:
+      !$acc routine seq
      use elm_varpar       , only : nlevsoi, nlevgrnd, nlayer, nlayert
      use elm_varcon       , only : pondmx, tfrz, watmin,rpi, secspday, nlvic
      use column_varcon    , only : icol_roof, icol_road_imperv, icol_road_perv
@@ -929,16 +890,19 @@ contains
      real(r8), intent(in)  :: dtime
      !
      ! !LOCAL VARIABLES:
-     character(len=32) :: subname = 'Drainage'     ! subroutine name
-     integer  :: c,j,fc,i                          ! indices
-     integer  :: nlevbed                           ! # layers to bedrock
-     real(r8) :: xs(1:num_hydrologyc)              ! water needed to bring soil moisture to watmin (mm)
-     real(r8) :: dzmm(1:num_hydrologyc,1:nlevgrnd) ! layer thickness (mm)
-     integer  :: jwt(1:num_hydrologyc)            ! index of the soil layer right above the water table (-)
-     real(r8) :: rsub_top(1:num_hydrologyc)       ! subsurface runoff - topographic control (mm/s)
-     real(r8) :: fff(1:num_hydrologyc)            ! decay factor (m-1)
-     real(r8) :: xsi(1:num_hydrologyc)            ! excess soil water above saturation at layer i (mm)
-     real(r8) :: xs1(1:num_hydrologyc)            ! excess soil water above saturation at layer 1 (mm)
+     !character(len=32) :: subname = 'Drainage'           ! subroutine name
+     integer  :: c,j,fc,i                                ! indices
+     integer  :: nlevbed                                 ! # layers to bedrock
+     real(r8) :: xs(bounds%begc:bounds%endc)             ! water needed to bring soil moisture to watmin (mm)
+     real(r8) :: dzmm(bounds%begc:bounds%endc,1:nlevgrnd) ! layer thickness (mm)
+     integer  :: jwt(bounds%begc:bounds%endc)            ! index of the soil layer right above the water table (-)
+     real(r8) :: rsub_bot(bounds%begc:bounds%endc)       ! subsurface runoff - bottom drainage (mm/s)
+     real(r8) :: rsub_top(bounds%begc:bounds%endc)       ! subsurface runoff - topographic control (mm/s)
+     real(r8) :: fff(bounds%begc:bounds%endc)            ! decay factor (m-1)
+     real(r8) :: xsi(bounds%begc:bounds%endc)            ! excess soil water above saturation at layer i (mm)
+     real(r8) :: xsia(bounds%begc:bounds%endc)           ! available pore space at layer i (mm)
+     real(r8) :: xs1(bounds%begc:bounds%endc)            ! excess soil water above saturation at layer 1 (mm)
+     real(r8) :: smpfz(1:nlevsoi)                        ! matric potential of layer right above water table (mm)
      real(r8) :: wtsub                                   ! summation of hk*dzmm for layers below water table (mm**2/s)
      real(r8) :: rous                                    ! aquifer yield (-)
      real(r8) :: wh                                      ! smpfz(jwt)-z(jwt) (mm)
@@ -947,7 +911,7 @@ contains
      real(r8) :: s_node                                  ! soil wetness (-)
      real(r8) :: dzsum                                   ! summation of dzmm of layers below water table (mm)
      real(r8) :: icefracsum                              ! summation of icefrac*dzmm of layers below water table (-)
-     real(r8) :: fracice_rsub(1:num_hydrologyc)   ! fractional impermeability of soil layers (-)
+     real(r8) :: fracice_rsub(bounds%begc:bounds%endc)   ! fractional impermeability of soil layers (-)
      real(r8) :: ka                                      ! hydraulic conductivity of the aquifer (mm/s)
      real(r8) :: dza                                     ! fff*(zwt-z(jwt)) (-)
      real(r8) :: available_h2osoi_liq                    ! available soil liquid water in a layer
@@ -970,7 +934,7 @@ contains
      real(r8) :: q_perch
      real(r8) :: q_perch_max
      real(r8) :: vol_ice
-     real(r8) :: dsmax_tmp(1:num_hydrologyc)       ! temporary variable for ARNO subsurface runoff calculation
+     real(r8) :: dsmax_tmp(bounds%begc:bounds%endc)       ! temporary variable for ARNO subsurface runoff calculation
      real(r8) :: rsub_tmp                 ! temporary variable for ARNO subsurface runoff calculation
      real(r8) :: frac                     ! temporary variable for ARNO subsurface runoff calculation
      real(r8) :: rel_moist                ! relative moisture, temporary variable
@@ -1027,26 +991,15 @@ contains
           h2osoi_liq         =>    col_ws%h2osoi_liq        , & ! Output: [real(r8) (:,:) ] liquid water (kg/m2)
           h2osoi_ice         =>    col_ws%h2osoi_ice          & ! Output: [real(r8) (:,:) ] ice lens (kg/m2)
           )
-     !$acc enter data create(&
-     !$acc xs(:), &
-     !$acc dzmm(:,:), &
-     !$acc jwt(:), &
-     !$acc rsub_top(:), &
-     !$acc fff(:), &
-     !$acc xsi(:), &
-     !$acc xs1(:), &
-     !$acc fracice_rsub(:), &
-     !$acc dsmax_tmp(:))
+
 
        ! Convert layer thicknesses from m to mm
 
-        !$acc parallel loop independent gang vector default(present)
         do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
           nlevbed = nlev2bed(c)
-          !$acc loop seq
           do j = 1,nlevbed
-             dzmm(fc,j) = dz(c,j)*1.e3_r8
+             dzmm(c,j) = dz(c,j)*1.e3_r8
 
              vol_ice = min(watsat(c,j), h2osoi_ice(c,j)/(dz(c,j)*denice))
              icefrac(c,j) = min(1._r8,vol_ice/watsat(c,j))
@@ -1055,46 +1008,43 @@ contains
 
        ! Initial set
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
           qflx_drain(c)    = 0._r8
+          rsub_bot(c)      = 0._r8
           qflx_rsub_sat(c) = 0._r8
-          rsub_top(fc)      = 0._r8
-          fracice_rsub(fc)  = 0._r8
+          rsub_top(c)      = 0._r8
+          fracice_rsub(c)  = 0._r8
           qflx_qrgwl(c)    = 0._r8
        end do
 
        ! The layer index of the first unsaturated layer, i.e., the layer right above
        ! the water table
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
-           nlevbed = nlev2bed(c)
-          jwt(fc) = nlevbed
+       	  nlevbed = nlev2bed(c)
+          jwt(c) = nlevbed
           ! allow jwt to equal zero when zwt is in top layer
-          !$acc loop seq
           do j = 1,nlevbed
              if(zwt(c) <= zi(c,j)) then
                 if (zengdecker_2009_with_var_soil_thick .and. zwt(c) == zi(c,nlevbed)) then
                    exit
                 else
-                   jwt(fc) = j-1
+                   jwt(c) = j-1
                    exit
-           end if
+	        end if
              end if
           enddo
        end do
 
+       rous = 0.2_r8
 
        !==  BASEFLOW ==================================================
        ! perched water table code
-       !$acc parallel loop independent gang vector default(present) present(ice(:,:),moist(:,:) )  
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
-           rous = 0.2_r8
-           nlevbed = nlev2bed(c)
+       	  nlevbed = nlev2bed(c)
 
           !  specify maximum drainage rate
           q_perch_max = 1.e-5_r8 * sin(col_pp%topo_slope(c) * (rpi/180._r8))
@@ -1108,7 +1058,7 @@ contains
           else
              k_frz=1
           endif
-          !$acc loop seq 
+
           do k=2, nlevbed
              if (t_soisno(c,k-1) > tfrz .and. t_soisno(c,k) <= tfrz) then
                 k_frz=k
@@ -1130,20 +1080,19 @@ contains
              ! compute drainage from perched saturated region
              wtsub = 0._r8
              q_perch = 0._r8
-            !$acc loop seq 
-             do k = jwt(fc)+1, k_frz
+             do k = jwt(c)+1, k_frz
                 imped=10._r8**(-e_ice*(0.5_r8*(icefrac(c,k)+icefrac(c,min(nlevbed, k+1)))))
-                q_perch = q_perch + imped*hksat(c,k)*dzmm(fc,k)
-                wtsub = wtsub + dzmm(fc,k)
+                q_perch = q_perch + imped*hksat(c,k)*dzmm(c,k)
+                wtsub = wtsub + dzmm(c,k)
              end do
              if (wtsub > 0._r8) q_perch = q_perch/wtsub
 
-             qflx_drain_perched(c) = q_perch_max * q_perch * (frost_table(c) - zwt(c))
+             qflx_drain_perched(c) = q_perch_max * q_perch &
+                  *(frost_table(c) - zwt(c))
 
              ! remove drainage from perched saturated layers
              rsub_top_tot = -  qflx_drain_perched(c) * dtime
-             !$acc loop seq 
-             do k = jwt(fc)+1, k_frz
+             do k = jwt(c)+1, k_frz
                 rsub_top_layer=max(rsub_top_tot,-(h2osoi_liq(c,k)-watmin))
                 rsub_top_layer=min(rsub_top_layer,0._r8)
                 if (use_vsfm) then
@@ -1162,19 +1111,18 @@ contains
              enddo
 
              ! if rsub_top_tot is greater than available water (above frost table),
-             !   then decrease qflx_drain_perched by residual amount for water balance
+             !     then decrease qflx_drain_perched by residual amount for water balance
              qflx_drain_perched(c) = qflx_drain_perched(c) + rsub_top_tot/dtime
 
              !-- recompute jwt  ---------------------------------------------------------
              ! allow jwt to equal zero when zwt is in top layer
-             jwt(fc) = nlevbed
-             !$acc loop seq 
+             jwt(c) = nlevbed
              do j = 1,nlevbed
                 if(zwt(c) <= zi(c,j)) then
                    if (zengdecker_2009_with_var_soil_thick .and. zwt(c) == zi(c,nlevbed)) then
                       exit
                    else
-                      jwt(fc) = j-1
+                      jwt(c) = j-1
                       exit
                    end if
                 end if
@@ -1187,7 +1135,6 @@ contains
              sat_lev=0.9
 
              k_perch=1
-             !$acc loop seq 
              do k=k_frz,1,-1
                 h2osoi_vol = h2osoi_liq(c,k)/(dz(c,k)*denh2o) &
                      + h2osoi_ice(c,k)/(dz(c,k)*denice)
@@ -1216,11 +1163,10 @@ contains
                 ! compute drainage from perched saturated region
                 wtsub = 0._r8
                 q_perch = 0._r8
-                !$acc loop seq 
                 do k = k_perch, k_frz
                    imped=10._r8**(-e_ice*(0.5_r8*(icefrac(c,k)+icefrac(c,min(nlevbed, k+1)))))
-                   q_perch = q_perch + imped*hksat(c,k)*dzmm(fc,k)
-                   wtsub = wtsub + dzmm(fc,k)
+                   q_perch = q_perch + imped*hksat(c,k)*dzmm(c,k)
+                   wtsub = wtsub + dzmm(c,k)
                 end do
                 if (wtsub > 0._r8) q_perch = q_perch/wtsub
 
@@ -1232,7 +1178,6 @@ contains
 
                 ! remove drainage from perched saturated layers
                 rsub_top_tot = -  qflx_drain_perched(c) * dtime
-                !$acc loop seq 
                 do k = k_perch+1, k_frz
                    rsub_top_layer=max(rsub_top_tot,-(h2osoi_liq(c,k)-watmin))
                    rsub_top_layer=min(rsub_top_layer,0._r8)
@@ -1259,31 +1204,30 @@ contains
              endif !k_frz > k_perch
 
              !-- Topographic runoff  ----------------------------------------------------------------------
-             fff(fc)         = 1._r8/ hkdepth(c)
+             fff(c)         = 1._r8/ hkdepth(c)
              dzsum = 0._r8
              icefracsum = 0._r8
-             !$acc loop seq 
-             do j = max(jwt(fc),1), nlevbed
-                dzsum  = dzsum + dzmm(fc,j)
-                icefracsum = icefracsum + icefrac(c,j) * dzmm(fc,j)
+             do j = max(jwt(c),1), nlevbed
+                dzsum  = dzsum + dzmm(c,j)
+                icefracsum = icefracsum + icefrac(c,j) * dzmm(c,j)
              end do
              ! add ice impedance factor to baseflow
              if(origflag == 1) then
                 if (use_vichydro) then
 #ifndef _OPENACC
-                  call endrun(msg="VICHYDRO is not available for origflag=1"//errmsg(__FILE__, __LINE__))
+                   call endrun(msg="VICHYDRO is not available for origflag=1"//errmsg(__FILE__, __LINE__))
 #endif
                 else
-                   fracice_rsub(fc) = max(0._r8,exp(-3._r8*(1._r8-(icefracsum/dzsum))) &
+                   fracice_rsub(c) = max(0._r8,exp(-3._r8*(1._r8-(icefracsum/dzsum))) &
                         - exp(-3._r8))/(1.0_r8-exp(-3._r8))
-                   imped=(1._r8 - fracice_rsub(fc))
+                   imped=(1._r8 - fracice_rsub(c))
                    rsub_top_max = 5.5e-3_r8
                 end if
              else
                 if (use_vichydro) then
                    imped=10._r8**(-e_ice*min(1.0_r8,ice(c,nlayer)/max_moist(c,nlayer)))
-                   dsmax_tmp(fc) = Dsmax(c) * dtime/ secspday !mm/day->mm/dtime
-                   rsub_top_max = dsmax_tmp(fc)
+                   dsmax_tmp(c) = Dsmax(c) * dtime/ secspday !mm/day->mm/dtime
+                   rsub_top_max = dsmax_tmp(c)
                 else
                    imped=10._r8**(-e_ice*(icefracsum/dzsum))
                    rsub_top_max = min(10._r8 * sin((rpi/180.) * col_pp%topo_slope(c)), rsub_top_globalmax)
@@ -1300,18 +1244,18 @@ contains
                    frac = (rel_moist - Wsvic(c))/(1.0_r8 - Wsvic(c))
                    rsub_tmp = rsub_tmp + (rsub_top_max * (1.0_r8 - Ds(c)/Wsvic(c)) *frac**c_param(c))/dtime
                 end if
-                rsub_top(fc) = imped * rsub_tmp
+                rsub_top(c) = imped * rsub_tmp
                 ! make sure baseflow isn't negative
-                rsub_top(fc) = max(0._r8, rsub_top(fc))
+                rsub_top(c) = max(0._r8, rsub_top(c))
              else
-               if (jwt(fc) == nlevbed .and. zengdecker_2009_with_var_soil_thick) then
-                   rsub_top(fc)    = 0._r8
+	        if (jwt(c) == nlevbed .and. zengdecker_2009_with_var_soil_thick) then
+                   rsub_top(c)    = 0._r8
                 else
-                   rsub_top(fc)    = imped * rsub_top_max* exp(-fff(fc)*zwt(c))
-               end if
+                   rsub_top(c)    = imped * rsub_top_max* exp(-fff(c)*zwt(c))
+		end if
              end if
 
-             if (use_vsfm) rsub_top(fc) = 0._r8
+             if (use_vsfm) rsub_top(c) = 0._r8
 
              ! use analytical expression for aquifer specific yield
              rous = watsat(c,nlevbed) &
@@ -1319,32 +1263,32 @@ contains
              rous=max(rous,0.02_r8)
 
              !--  water table is below the soil column  --------------------------------------
-             if(jwt(fc) == nlevbed) then
-           if (zengdecker_2009_with_var_soil_thick) then
-               if (-1._r8 * smp_l(c,nlevbed) < 0.5_r8 * dzmm(fc,nlevbed)) then
-                  zwt(c) = z(c,nlevbed) - (smp_l(c,nlevbed) / 1000._r8)
-               end if
-               rsub_top(fc) = imped * rsub_top_max * exp(-fff(fc) * zwt(c))
-               rsub_top_tot = - rsub_top(fc) * dtime
-               s_y = watsat(c,nlevbed) &
-                 * ( 1. - (1.+1.e3*zwt(c)/sucsat(c,nlevbed))**(-1./bsw(c,nlevbed)))
-               s_y=max(s_y,0.02_r8)
-               rsub_top_layer=max(rsub_top_tot,-(s_y*(zi(c,nlevbed) - zwt(c))*1.e3))
-               rsub_top_layer=min(rsub_top_layer,0._r8)
-               h2osoi_liq(c,nlevbed) = h2osoi_liq(c,nlevbed) + rsub_top_layer
-               rsub_top_tot = rsub_top_tot - rsub_top_layer
-               if (rsub_top_tot >= 0._r8) then
-                  zwt(c) = zwt(c) - rsub_top_layer/s_y/1000._r8
-               else
-                  zwt(c) = zi(c,nlevbed)
-               end if
-              if (rsub_top_tot < 0.) then
-                 rsub_top(fc) = rsub_top(fc) + rsub_top_tot / dtime
+             if(jwt(c) == nlevbed) then
+	        if (zengdecker_2009_with_var_soil_thick) then
+         	   if (-1._r8 * smp_l(c,nlevbed) < 0.5_r8 * dzmm(c,nlevbed)) then
+           	      zwt(c) = z(c,nlevbed) - (smp_l(c,nlevbed) / 1000._r8)
+		   end if
+                   rsub_top(c) = imped * rsub_top_max * exp(-fff(c) * zwt(c))
+                   rsub_top_tot = - rsub_top(c) * dtime
+                   s_y = watsat(c,nlevbed) &
+                     * ( 1. - (1.+1.e3*zwt(c)/sucsat(c,nlevbed))**(-1./bsw(c,nlevbed)))
+                   s_y=max(s_y,0.02_r8)
+                   rsub_top_layer=max(rsub_top_tot,-(s_y*(zi(c,nlevbed) - zwt(c))*1.e3))
+                   rsub_top_layer=min(rsub_top_layer,0._r8)
+                   h2osoi_liq(c,nlevbed) = h2osoi_liq(c,nlevbed) + rsub_top_layer
+                   rsub_top_tot = rsub_top_tot - rsub_top_layer
+                   if (rsub_top_tot >= 0.) then
+                      zwt(c) = zwt(c) - rsub_top_layer/s_y/1000._r8
+                   else
+                      zwt(c) = zi(c,nlevbed)
+                   end if
+	           if (rsub_top_tot < 0.) then
+	              rsub_top(c) = rsub_top(c) + rsub_top_tot / dtime
                       rsub_top_tot = 0.
                    end if
                 else
-                   wa(c)  = wa(c) - rsub_top(fc) * dtime
-                   zwt(c)     = zwt(c) + (rsub_top(fc) * dtime)/1000._r8/rous
+                   wa(c)  = wa(c) - rsub_top(c) * dtime
+                   zwt(c)     = zwt(c) + (rsub_top(c) * dtime)/1000._r8/rous
                    h2osoi_liq(c,nlevsoi) = h2osoi_liq(c,nlevsoi) + max(0._r8,(wa(c)-5000._r8))
                    wa(c)  = min(wa(c), 5000._r8)
                 end if
@@ -1352,30 +1296,28 @@ contains
                 !-- water table within soil layers 1-9  -------------------------------------
                 !============================== RSUB_TOP =========================================
                 !--  Now remove water via rsub_top
-                rsub_top_tot = - rsub_top(fc) * dtime
+                rsub_top_tot = - rsub_top(c) * dtime
                 !should never be positive... but include for completeness
                 if(rsub_top_tot > 0.) then !rising water table
 #ifndef _OPENACC
-                  call endrun(msg="RSUB_TOP IS POSITIVE in Drainage!"//errmsg(__FILE__, __LINE__))
+                   call endrun(msg="RSUB_TOP IS POSITIVE in Drainage!"//errmsg(__FILE__, __LINE__))
 #endif
                 else ! deepening water table
                    if (use_vichydro) then
                       wtsub_vic = 0._r8
-                      !$acc loop seq 
                       do j = (nlvic(1)+nlvic(2)+1), nlevbed
-                         wtsub_vic = wtsub_vic + hk_l(c,j)*dzmm(fc,j)
+                         wtsub_vic = wtsub_vic + hk_l(c,j)*dzmm(c,j)
                       end do
-                     !$acc loop seq 
+
                       do j = (nlvic(1)+nlvic(2)+1), nlevbed
-                         rsub_top_layer=max(rsub_top_tot, rsub_top_tot*hk_l(c,j)*dzmm(fc,j)/wtsub_vic)
+                         rsub_top_layer=max(rsub_top_tot, rsub_top_tot*hk_l(c,j)*dzmm(c,j)/wtsub_vic)
                          rsub_top_layer=min(rsub_top_layer,0._r8)
                          if (use_vsfm) rsub_top_layer = 0._r8
                          h2osoi_liq(c,j) = h2osoi_liq(c,j) + rsub_top_layer
                          rsub_top_tot = rsub_top_tot - rsub_top_layer
                       end do
                    else
-                     !$acc loop seq 
-                      do j = jwt(fc)+1, nlevbed
+                      do j = jwt(c)+1, nlevbed
                          ! use analytical expression for specific yield
                          s_y = watsat(c,j) &
                               * ( 1. - (1.+1.e3*zwt(c)/sucsat(c,j))**(-1./bsw(c,j)))
@@ -1401,7 +1343,7 @@ contains
                    !--  remove residual rsub_top  ---------------------------------------------
                    if (zengdecker_2009_with_var_soil_thick) then
                       if (rsub_top_tot < 0.) then
-                         rsub_top(fc) = rsub_top(fc) + rsub_top_tot / dtime
+                         rsub_top(c) = rsub_top(c) + rsub_top_tot / dtime
                          rsub_top_tot = 0._r8
                       end if
                    else
@@ -1412,14 +1354,13 @@ contains
 
                 !-- recompute jwt  ---------------------------------------------------------
                 ! allow jwt to equal zero when zwt is in top layer
-                jwt(fc) = nlevbed
-                !$acc loop seq 
+                jwt(c) = nlevbed
                 do j = 1,nlevbed
                    if(zwt(c) <= zi(c,j)) then
                       if (zengdecker_2009_with_var_soil_thick .and. zwt(c) == zi(c,nlevbed)) then
                          exit
                       else
-                         jwt(fc) = j-1
+                         jwt(c) = j-1
                          exit
                       end if
                    end if
@@ -1436,124 +1377,119 @@ contains
        !  excessive water above saturation added to the above unsaturated layer like a bucket
        !  if column fully saturated, excess water goes to runoff
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
-           nlevbed = nlev2bed(c)
-          !$acc loop seq
+      	  nlevbed = nlev2bed(c)
           do j = nlevbed,2,-1
-             xsi(fc)            = max(h2osoi_liq(c,j)-eff_porosity(c,j)*dzmm(fc,j),0._r8)
+             xsi(c)            = max(h2osoi_liq(c,j)-eff_porosity(c,j)*dzmm(c,j),0._r8)
              if (use_vsfm) then
-                xsi(fc) = 0._r8
+                xsi(c) = 0._r8
              else
-                h2osoi_liq(c,j)   = min(eff_porosity(c,j)*dzmm(fc,j), h2osoi_liq(c,j))
-                h2osoi_liq(c,j-1) = h2osoi_liq(c,j-1) + xsi(fc)
+                h2osoi_liq(c,j)   = min(eff_porosity(c,j)*dzmm(c,j), h2osoi_liq(c,j))
+                h2osoi_liq(c,j-1) = h2osoi_liq(c,j-1) + xsi(c)
              endif
           end do
        end do
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
 
           !scs: watmin addition to fix water balance errors
-          xs1(fc)  = max(max(h2osoi_liq(c,1)-watmin,0._r8)- &
-               max(0._r8,(pondmx+watsat(c,1)*dzmm(fc,1)-h2osoi_ice(c,1)-watmin)),0._r8)
-          if (use_vsfm) xs1(fc) = 0._r8
-          h2osoi_liq(c,1) = h2osoi_liq(c,1) - xs1(fc)
+          xs1(c)          = max(max(h2osoi_liq(c,1)-watmin,0._r8)- &
+               max(0._r8,(pondmx+watsat(c,1)*dzmm(c,1)-h2osoi_ice(c,1)-watmin)),0._r8)
+          if (use_vsfm) xs1(c) = 0._r8
+          h2osoi_liq(c,1) = h2osoi_liq(c,1) - xs1(c)
 
           if (lun_pp%urbpoi(col_pp%landunit(c))) then
-             qflx_rsub_sat(c)     = xs1(fc) / dtime
+             qflx_rsub_sat(c)     = xs1(c) / dtime
           else
              if(h2osfcflag == 1) then
                 ! send this water up to h2osfc rather than sending to drainage
-                h2osfc(c) = h2osfc(c) + xs1(fc)
+                h2osfc(c) = h2osfc(c) + xs1(c)
                 qflx_rsub_sat(c)     = 0._r8
              else
                 ! use original code to send water to drainage (non-h2osfc case)
-                qflx_rsub_sat(c)     = xs1(fc) / dtime
+                qflx_rsub_sat(c)     = xs1(c) / dtime
              endif
           endif
 
           if (use_vsfm) qflx_rsub_sat(c) = 0._r8
 
           ! add in ice check
-          xs1(fc)          = max(max(h2osoi_ice(c,1),0._r8)-max(0._r8,(pondmx+watsat(c,1)*dzmm(fc,1)-h2osoi_liq(c,1))),0._r8)
-          h2osoi_ice(c,1) = min(max(0._r8,pondmx+watsat(c,1)*dzmm(fc,1)-h2osoi_liq(c,1)), h2osoi_ice(c,1))
-          qflx_snwcp_ice(c) = qflx_snwcp_ice(c) + xs1(fc) / dtime
+          xs1(c)          = max(max(h2osoi_ice(c,1),0._r8)-max(0._r8,(pondmx+watsat(c,1)*dzmm(c,1)-h2osoi_liq(c,1))),0._r8)
+          h2osoi_ice(c,1) = min(max(0._r8,pondmx+watsat(c,1)*dzmm(c,1)-h2osoi_liq(c,1)), h2osoi_ice(c,1))
+          qflx_snwcp_ice(c) = qflx_snwcp_ice(c) + xs1(c) / dtime
        end do
 
        ! Limit h2osoi_liq to be greater than or equal to watmin.
        ! Get water needed to bring h2osoi_liq equal watmin from lower layer.
        ! If insufficient water in soil layers, get from aquifer water
-       !$acc parallel loop independent gang vector default(present) 
+
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
-           nlevbed = nlev2bed(c)
-           !$acc loop seq 
-           do j = 1, nlevbed-1
+       	  nlevbed = nlev2bed(c)
+       	  do j = 1, nlevbed-1
              if (h2osoi_liq(c,j) < watmin) then
-                xs(fc) = watmin - h2osoi_liq(c,j)
+                xs(c) = watmin - h2osoi_liq(c,j)
                 ! deepen water table if water is passed from below zwt layer
-                if(j == jwt(fc)) then
-                   zwt(c) = zwt(c) + xs(fc)/eff_porosity(c,j)/1000._r8
+                if(j == jwt(c)) then
+                   zwt(c) = zwt(c) + xs(c)/eff_porosity(c,j)/1000._r8
                 endif
              else
-                xs(fc) = 0._r8
+                xs(c) = 0._r8
              end if
-             h2osoi_liq(c,j  ) = h2osoi_liq(c,j  ) + xs(fc)
-             h2osoi_liq(c,j+1) = h2osoi_liq(c,j+1) - xs(fc)
+             h2osoi_liq(c,j  ) = h2osoi_liq(c,j  ) + xs(c)
+             h2osoi_liq(c,j+1) = h2osoi_liq(c,j+1) - xs(c)
           end do
        end do
 
        ! Get water for bottom layer from layers above if possible
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
-           nlevbed = nlev2bed(c)
-           j = nlevbed
+       	  nlevbed = nlev2bed(c)
+       	  j = nlevbed
           if (h2osoi_liq(c,j) < watmin) then
-             xs(fc) = watmin-h2osoi_liq(c,j)
-             !$acc loop seq 
+             xs(c) = watmin-h2osoi_liq(c,j)
              searchforwater: do i = nlevbed-1, 1, -1
-                available_h2osoi_liq = max(h2osoi_liq(c,i)-watmin-xs(fc),0._r8)
-                if (available_h2osoi_liq >= xs(fc)) then
-                   h2osoi_liq(c,j) = h2osoi_liq(c,j) + xs(fc)
-                   h2osoi_liq(c,i) = h2osoi_liq(c,i) - xs(fc)
-                   xs(fc) = 0._r8
+                available_h2osoi_liq = max(h2osoi_liq(c,i)-watmin-xs(c),0._r8)
+                if (available_h2osoi_liq >= xs(c)) then
+                   h2osoi_liq(c,j) = h2osoi_liq(c,j) + xs(c)
+                   h2osoi_liq(c,i) = h2osoi_liq(c,i) - xs(c)
+                   xs(c) = 0._r8
                    exit searchforwater
                 else
                    h2osoi_liq(c,j) = h2osoi_liq(c,j) + available_h2osoi_liq
                    h2osoi_liq(c,i) = h2osoi_liq(c,i) - available_h2osoi_liq
-                   xs(fc) = xs(fc) - available_h2osoi_liq
+                   xs(c) = xs(c) - available_h2osoi_liq
                 end if
              end do searchforwater
           else
-             xs(fc) = 0._r8
+             xs(c) = 0._r8
           end if
           ! Needed in case there is no water to be found
-          h2osoi_liq(c,j) = h2osoi_liq(c,j) + xs(fc)
+          h2osoi_liq(c,j) = h2osoi_liq(c,j) + xs(c)
           ! Instead of removing water from aquifer where it eventually
           ! shows up as excess drainage to the ocean, take it back out of
           ! drainage
-          rsub_top(fc) = rsub_top(fc) - xs(fc)/dtime
+          rsub_top(c) = rsub_top(c) - xs(c)/dtime
+
        end do
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
-            
+
           ! Sub-surface runoff and drainage
-          qflx_drain(c) = qflx_rsub_sat(c) + rsub_top(fc)
+
+          qflx_drain(c) = qflx_rsub_sat(c) + rsub_top(c)
 
           ! Set imbalance for snow capping
+
           qflx_qrgwl(c) = qflx_snwcp_liq(c)
 
        end do
 
        ! No drainage for urban columns (except for pervious road as computed above)
 
-       !$acc parallel loop independent gang vector default(present)
        do fc = 1, num_urbanc
           c = filter_urbanc(fc)
           if (col_pp%itype(c) /= icol_road_perv) then
@@ -1563,17 +1499,6 @@ contains
           end if
        end do
 
-     !$acc exit data delete(&
-     !$acc xs(:), &
-     !$acc dzmm(:,:), &
-     !$acc jwt(:), &
-     !$acc rsub_top(:), &
-     !$acc fff(:), &
-     !$acc xsi(:), &
-     !$acc xs1(:), &
-     !$acc fracice_rsub(:), &
-     !$acc dsmax_tmp(:))
-
      end associate
 
    end subroutine Drainage
@@ -1586,7 +1511,7 @@ contains
      ! Calculate subsurface drainage
      !
      ! !USES:
-      !$acc routine seq 
+      !$acc routine seq
      use elm_varpar       , only : nlevsoi, nlevgrnd, nlayer, nlayert
      use elm_varcon       , only : pondmx, tfrz, watmin,rpi, secspday, nlvic
      use column_varcon    , only : icol_roof, icol_road_imperv, icol_road_perv
@@ -1754,7 +1679,7 @@ contains
        ! perched water table code
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
-         
+
           !  specify maximum drainage rate
           q_perch_max = 1.e-5_r8 * sin(col_pp%topo_slope(c) * (rpi/180._r8))
 
@@ -1920,9 +1845,9 @@ contains
              ! add ice impedance factor to baseflow
              if(origflag == 1) then
                 if (use_vichydro) then
-                  #ifndef _OPENACC
-                  call endrun(msg="VICHYDRO is not available for origflag=1"//errmsg(__FILE__, __LINE__))
-                  #endif
+#ifndef _OPENACC
+                   call endrun(msg="VICHYDRO is not available for origflag=1"//errmsg(__FILE__, __LINE__))
+#endif
                 else
                    fracice_rsub(c) = max(0._r8,exp(-3._r8*(1._r8-(icefracsum/dzsum))) &
                         - exp(-3._r8))/(1.0_r8-exp(-3._r8))
@@ -1954,7 +1879,6 @@ contains
                 ! make sure baseflow isn't negative
                 rsub_top(c) = max(0._r8, rsub_top(c))
              else
-                 
                 rsub_top(c)    = imped * rsub_top_max* exp(-fff(c)*zwt(c))
              end if
           endif
@@ -2003,7 +1927,7 @@ contains
      ! mapping from VIC to CLM layers, M.Huang
      !
      ! !USES:
-      !$acc routine seq 
+      !$acc routine seq
      use elm_varcon  , only : denh2o, denice, watmin
      use elm_varpar  , only : nlevsoi, nlayer, nlayert, nlevgrnd
      use decompMod   , only : bounds_type
diff --git a/components/elm/src/biogeophys/SoilMoistStressMod.F90 b/components/elm/src/biogeophys/SoilMoistStressMod.F90
index 3443fe22a2..f9c3ed870e 100644
--- a/components/elm/src/biogeophys/SoilMoistStressMod.F90
+++ b/components/elm/src/biogeophys/SoilMoistStressMod.F90
@@ -26,13 +26,14 @@ module SoilMoistStressMod
   public :: calc_volumetric_h2oliq
   public :: set_perchroot_opt
   public :: init_root_moist_stress
-  private :: normalize_test
   !
   ! !PRIVATE DATA MEMBERS:
   integer ::   root_moist_stress_method
   integer, parameter :: moist_stress_clm_default  = 0  !default method for calculating root moisture stress
   logical,  private :: perchroot     = .false.  ! true => btran is based only on unfrozen soil levels
   logical,  private :: perchroot_alt = .false.  ! true => btran is based on active layer (defined over two years);
+  !$acc declare create(root_moist_stress_method)
+  !$acc declare copyin(moist_stress_clm_default)
   !$acc declare create(perchroot)
   !$acc declare create(perchroot_alt)
 
@@ -40,53 +41,6 @@ module SoilMoistStressMod
 
 contains
 
-subroutine normalize_test( lbj2, ubj2, numf, filter, arr2d_inout)
-   !DESCRIPTIONS
-   !do normalization with filter for the input array along dimension 2
-   !
-   !USES
-   use shr_kind_mod, only: r8 => shr_kind_r8
-   implicit none
-
-   integer,  intent(in) :: lbj2         !right bound of dim 1
-   integer,  intent(in) :: ubj2         !right bound of dim 2
-   integer,  intent(in) :: numf         !filter size
-   integer,  intent(in) :: filter(:)    !filter
-   real(r8), intent(inout) :: arr2d_inout(: , : )   !input 2d array
-
-   !local variables
-   integer  :: sz1, sz2     !array size
-   integer  :: j2           !indices
-   integer  :: f, p         !indices
-   real(r8) :: arr_sum(numf), sum1
-
-   !$acc enter data create(arr_sum(1:numf))
-   !$acc parallel loop independent gang worker default(present) private(sum1)
-   do f = 1, numf
-     sum1 = 0._r8
-     !$acc loop vector reduction(+:sum1)
-     do j2 = lbj2, ubj2
-         !obtain the total
-         sum1=sum1+arr2d_inout(f,j2)
-     enddo
-     arr_sum(f) = sum1
-   enddo
-
-     !normalize with the total if arr_sum is non-zero
-   !$acc parallel loop independent gang default(present)
-   do j2 = lbj2, ubj2
-     !$acc loop vector independent
-     do f = 1, numf
-      !I found I have to ensure >0._r8 because of some unknown reason, jyt May 23, 2014
-      !I will test this later with arr_sum(p)/=0._r8
-      if(arr_sum(f)>0._r8 .or. arr_sum(f)<0._r8)then
-         arr2d_inout(f,j2) = arr2d_inout(f,j2)/arr_sum(f)
-      endif
-     enddo
-   enddo
-   !$acc exit data delete(arr_sum(:))
-end subroutine normalize_test
-
   !--------------------------------------------------------------------------------
   subroutine init_root_moist_stress()
     !
@@ -96,6 +50,7 @@ end subroutine normalize_test
     implicit none
 
     root_moist_stress_method = moist_stress_clm_default
+    !$acc update device(root_moist_stress_method)
   end subroutine init_root_moist_stress
 
   !--------------------------------------------------------------------------------
@@ -126,10 +81,10 @@ end subroutine normalize_test
     ! compute the effective soil porosity
     !
     ! !USES
+      !$acc routine seq
     use shr_kind_mod   , only : r8 => shr_kind_r8
     use decompMod      , only : bounds_type
     use ColumnType     , only : col_pp
-    use VegetationType , only : veg_pp
     !
     ! !ARGUMENTS:
     implicit none
@@ -143,24 +98,23 @@ end subroutine normalize_test
     real(r8)          , intent(inout) :: eff_por( bounds%begc: ,1: )     ! effective porosity
     !
     ! !LOCAL VARIABLES:
-    integer :: c, j, fp,p      !indices
+    integer :: c, j, fc                                             !indices
     real(r8):: vol_ice    !volumetric ice
     !------------------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
     !main calculation loop
     !it assumes the soil layers start from 1
-    !$acc parallel loop independent gang default(present)
     do j = 1, ubj
-      !$acc loop vector independent private(p,c,vol_ice)
-       do fp = 1, numf
-          p = filter(fp)
-          c = veg_pp%column(p)
+       do fc = 1, numf
+          c = filter(fc)
           !compute the volumetric ice content
           vol_ice=min(watsat(c,j), h2osoi_ice(c,j)/(denice*col_pp%dz(c,j)))
           !compute the maximum soil space to fill liquid water and air
           eff_por(c,j) = watsat(c,j) - vol_ice
        enddo
     enddo
-
   end subroutine calc_effective_soilporosity
 
   !--------------------------------------------------------------------------------
@@ -194,6 +148,7 @@ end subroutine normalize_test
 
     ubj = 0
 
+    ! Enforce expected array sizes
     !main calculation loop
 
     !it assumes snow layer ends at 0
@@ -213,7 +168,7 @@ end subroutine normalize_test
   end subroutine calc_effective_snowporosity
 
   !--------------------------------------------------------------------------------
-  subroutine calc_volumetric_h2oliq(bounds, lbj, ubj, numf, filter,&
+  subroutine calc_volumetric_h2oliq(bounds, jtop, lbj, ubj, numf, filter,&
        eff_porosity, h2osoi_liq, denh2o, vol_liq)
     !
     ! !DESCRIPTIONS
@@ -221,14 +176,15 @@ end subroutine normalize_test
     !
     !
     ! !USES
+      !$acc routine seq
     use shr_kind_mod   , only : r8 => shr_kind_r8
     use decompMod      , only : bounds_type
     use ColumnType     , only : col_pp
-    use VegetationType  , only : veg_pp
     !
     ! !ARGUMENTS:
     implicit none
     type(bounds_type) , intent(in)    :: bounds                             ! bounds
+    integer           , intent(in)    :: jtop( bounds%begc: )               ! top level for each column [col]
     integer           , intent(in)    :: lbj, ubj                           ! lbinning and ubing level indices
     integer           , intent(in)    :: numf                               ! filter dimension
     integer           , intent(in)    :: filter(:)                          ! filter
@@ -238,17 +194,16 @@ end subroutine normalize_test
     real(r8)          , intent(inout) :: vol_liq(bounds%begc: , lbj: )      ! volumetric liquid water content
     !
     ! !LOCAL VARIABLES:
-    integer :: p, c, j, fp ! indices
-    integer, parameter :: jtop = 1
+    integer :: c, j, fc  ! indices
     !------------------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
     !main calculation loop
-    !$acc parallel loop independent gang default(present)
     do j = lbj, ubj
-      !$acc loop vector independent private(p,c)
-       do fp = 1, numf
-          p = filter(fp)
-          c = veg_pp%column(p)
-          if(j>=jtop)then
+       do fc = 1, numf
+          c = filter(fc)
+          if(j>=jtop(c))then
              !volume of liquid is no greater than effective void space
              vol_liq(c,j) = min(eff_porosity(c,j), h2osoi_liq(c,j)/(col_pp%dz(c,j)*denh2o))
           endif
@@ -265,6 +220,7 @@ end subroutine normalize_test
     ! normalize root fraction for total unfrozen depth
     !
     ! !USES
+      !$acc routine seq
     use shr_kind_mod    , only: r8 => shr_kind_r8
     use elm_varcon      , only : tfrz      !temperature where water freezes [K], this is taken as constant at the moment
     use decompMod       , only : bounds_type
@@ -272,7 +228,7 @@ end subroutine normalize_test
     use EnergyFluxType  , only : energyflux_type
     use SoilStateType   , only : soilstate_type
     use SimpleMathMod   , only : array_normalization
-    use VegetationType  , only : veg_pp
+    use VegetationType       , only : veg_pp
     !
     ! !ARGUMENTS:
     implicit none
@@ -282,15 +238,16 @@ end subroutine normalize_test
     integer                , intent(in)    :: filterp(:)                                 !filter
     type(canopystate_type) , intent(in)    :: canopystate_vars
     type(soilstate_type)   , intent(in)    :: soilstate_vars
-    real(r8)               , intent(inout) :: rootfr_unf(:,:) !normalized root fraction in unfrozen layers
+    real(r8)               , intent(inout) :: rootfr_unf(bounds%begp:bounds%endp, 1:ubj) !normalized root fraction in unfrozen layers
     !
     ! !LOCAL VARIABLES:
+    !real(r8) :: rootsum(bounds%begp:bounds%endp)
     integer :: p, c, j, f  !indices
-    real(r8) :: arr_sum(fn), sum1
     !------------------------------------------------------------------------------
 
-    associate(     &
-         rootfr               => soilstate_vars%rootfr_patch , & ! Input:  [real(r8)  (:,:) ]  fraction of roots in each soil layer
+    associate(                                                               &
+         rootfr               => soilstate_vars%rootfr_patch               , & ! Input:  [real(r8)  (:,:) ]  fraction of roots in each soil layer
+
          t_soisno             => col_es%t_soisno             , & ! Input:  [real(r8) (:,:) ]  soil temperature (Kelvin)  (-nlevsno+1:nlevgrnd)
 
          altmax_lastyear_indx => canopystate_vars%altmax_lastyear_indx_col , & ! Input:  [real(r8) (:)   ]  prior year maximum annual depth of thaw
@@ -305,85 +262,58 @@ end subroutine normalize_test
       ! to zero within similar coding style. Jinyun Tang, May 23, 2014.
 
       ! Define rootfraction for unfrozen soil only
-      ! if (perchroot .or. perchroot_alt) then
+      if (perchroot .or. perchroot_alt) then
          if (perchroot_alt) then
             ! use total active layer (defined ass max thaw depth for current and prior year)
-            !$acc parallel loop independent gang default(present)
             do j = 1, ubj
-               !$acc loop vector independent private(p,c)
                do f = 1, fn
                   p = filterp(f)
                   c = veg_pp%column(p)
 
                   if ( j <= max(altmax_lastyear_indx(c), altmax_indx(c), 1) )then
-                     rootfr_unf(f,j) = rootfr(p,j)
+                     rootfr_unf(p,j) = rootfr(p,j)
                   else
-                     rootfr_unf(f,j) = 0._r8
+                     rootfr_unf(p,j) = 0._r8
                   end if
                end do
             end do
          else
             ! use instantaneous temperature
-            !$acc parallel loop independent gang default(present)
             do j = 1, ubj
-               !$acc loop vector independent private(p,c)
                do f = 1, fn
                   p = filterp(f)
                   c = veg_pp%column(p)
                   if (t_soisno(c,j) >= tfrz) then
-                     rootfr_unf(f,j) = rootfr(p,j)
+                     rootfr_unf(p,j) = rootfr(p,j)
                   else
-                     rootfr_unf(f,j) = 0._r8
+                     rootfr_unf(p,j) = 0._r8
                   end if
                end do
             end do
 
          end if ! perchroot_alt
-      ! end if ! perchroot
+      end if ! perchroot
 
       !normalize the root fraction for each pft
-      ! call normalize_test( 1, ubj, &
-      !      fn, filterp, rootfr_unf(:, :))
-      ! !!!
-      !$acc enter data create(arr_sum(1:fn))
-      !$acc parallel loop independent gang worker default(present) private(sum1)
-      do f = 1, fn
-        sum1 = 0._r8
-        !$acc loop vector reduction(+:sum1)
-        do j = 1, ubj
-            !obtain the total
-            sum1=sum1+rootfr_unf(f,j)
-        enddo
-        arr_sum(f) = sum1
-      enddo
-
-        !normalize with the total if arr_sum is non-zero
-      !$acc parallel loop independent gang default(present)
-      do j = 1, ubj
-        !$acc loop vector independent
-        do f = 1, fn
-         !I found I have to ensure >0._r8 because of some unknown reason, jyt May 23, 2014
-         !I will test this later with arr_sum(p)/=0._r8
-         if(arr_sum(f)>0._r8 .or. arr_sum(f)<0._r8)then
-            rootfr_unf(f,j) = rootfr_unf(f,j)/arr_sum(f)
-         endif
-        enddo
-      enddo
-      !$acc exit data delete(arr_sum(:))
+      call array_normalization(bounds%begp, bounds%endp, 1, ubj, &
+           fn, filterp, rootfr_unf(bounds%begp:bounds%endp, 1:ubj))
+
     end associate
 
   end subroutine normalize_unfrozen_rootfr
 
   !--------------------------------------------------------------------------------
-  subroutine calc_root_moist_stress_clm45default( &
-                        nlevgrnd, fn, filterp, rootfr_unf, &
-                        soilstate_vars, energyflux_vars)
+  subroutine calc_root_moist_stress_clm45default(bounds, &
+       nlevgrnd, fn, filterp, rootfr_unf, &
+       soilstate_vars, energyflux_vars)
     !
     ! DESCRIPTIONS
     ! compute the root water stress using the default clm45 approach
     !
     ! USES
+      !$acc routine seq
     use shr_kind_mod         , only : r8 => shr_kind_r8
+    use decompMod            , only : bounds_type
     use elm_varcon           , only : tfrz      !temperature where water freezes [K], this is taken as constant at the moment
     use VegetationPropertiesType     , only : veg_vp
     use SoilStateType        , only : soilstate_type
@@ -393,17 +323,18 @@ end subroutine normalize_test
     !
     ! !ARGUMENTS:
     implicit none
+    type(bounds_type)      , intent(in)    :: bounds                         !bounds
     integer                , intent(in)    :: nlevgrnd                       !number of vertical layers
     integer                , intent(in)    :: fn                             !number of filters
     integer                , intent(in)    :: filterp(:)                     !filter array
-    real(r8)               , intent(in)    :: rootfr_unf(: , : )
+    real(r8)               , intent(in)    :: rootfr_unf(bounds%begp: , 1: )
     type(energyflux_type)  , intent(inout) :: energyflux_vars
     type(soilstate_type)   , intent(inout) :: soilstate_vars
     !
     ! !LOCAL VARIABLES:
     real(r8), parameter :: btran0 = 0.0_r8  ! initial value
     real(r8) :: smp_node, s_node  !temporary variables
-    real(r8) :: smp_node_lf,sum1, sum2      !temporary variable
+    real(r8) :: smp_node_lf       !temporary variable
     integer :: p, f, j, c, l      !indices
     !------------------------------------------------------------------------------
 
@@ -429,10 +360,7 @@ end subroutine normalize_test
          h2osoi_vol    => col_ws%h2osoi_vol    , & ! Input:  [real(r8) (:,:) ]  volumetric soil water (0<=h2osoi_vol<=watsat) [m3/m3]
          h2osoi_liqvol => col_ws%h2osoi_liqvol   & ! Output: [real(r8) (:,:) ]  liquid volumetric moisture, will be used for BeTR
          )
-
-      !$acc parallel loop independent gang default(present)
       do j = 1,nlevgrnd
-         !$acc loop vector independent private(p,c,l,s_node,smp_node )
          do f = 1, fn
             p = filterp(f)
             c = veg_pp%column(p)
@@ -455,56 +383,30 @@ end subroutine normalize_test
                if (.not. (perchroot .or. perchroot_alt) ) then
                   rootr(p,j) = rootfr(p,j)*rresis(p,j)
                else
-                  rootr(p,j) = rootfr_unf(f,j)*rresis(p,j)
+                  rootr(p,j) = rootfr_unf(p,j)*rresis(p,j)
                end if
-            endif
 
-         end do
-      end do
+               !it is possible to further separate out a btran function, but I will leave it for the moment, jyt
+               if( .not. use_hydrstress ) then
+                 btran(p)    = btran(p) + max(rootr(p,j),0._r8)
+               endif
 
-      !calculate btran and btran2
-      if(.not. use_hydrstress) then
-         !$acc parallel loop independent gang worker default(present) private(p,c,sum1)
-         do f = 1, fn
-            p = filterp(f)
-            c = veg_pp%column(p)
-            sum1 = btran(p)
-               !$acc loop reduction(+:sum1) private(s_node,smp_node_lf)
-               do j = 1, nlevgrnd
-                  if (.not. (h2osoi_liqvol(c,j) .le. 0._r8 .or. t_soisno(c,j) .le. tfrz + tc_stress)) then
-                     sum1 = sum1 + max(rootr(p,j),0._r8)
-                  end if
-               end do
-               btran(p) = sum1
+               !smp_node_lf = max(smpsc(veg_pp%itype(p)), -sucsat(c,j)*(h2osoi_vol(c,j)/watsat(c,j))**(-bsw(c,j)))
+               s_node = h2osoi_vol(c,j)/watsat(c,j)
+
+               !call soil_water_retention_curve%soil_suction(sucsat(c,j), s_node, bsw(c,j), smp_node_lf)
+               smp_node_lf = -sucsat(c,j)*s_node**( -bsw(c,j) )
+
+               !smp_node_lf =  -sucsat(c,j)*(h2osoi_vol(c,j)/watsat(c,j))**(-bsw(c,j))
+               smp_node_lf = max(smpsc(veg_pp%itype(p)), smp_node_lf)
+               btran2(p)   = btran2(p) +rootfr(p,j)*min((smp_node_lf - smpsc(veg_pp%itype(p))) / &
+                    (smpso(veg_pp%itype(p)) - smpsc(veg_pp%itype(p))), 1._r8)
+            endif
          end do
-      end if
-
-      !$acc parallel loop independent gang worker default(present) private(p,c,sum2)
-      do f = 1, fn
-         p = filterp(f)
-         c = veg_pp%column(p)
-         sum2 = btran2(p)
-            !$acc loop reduction(+:sum2) private(s_node,smp_node_lf)
-            do j = 1,nlevgrnd
-               if (.not. (h2osoi_liqvol(c,j) .le. 0._r8 .or. t_soisno(c,j) .le. tfrz + tc_stress)) then
-                  !smp_node_lf = max(smpsc(veg_pp%itype(p)), -sucsat(c,j)*(h2osoi_vol(c,j)/watsat(c,j))**(-bsw(c,j)))
-                  s_node = h2osoi_vol(c,j)/watsat(c,j)
-                  !call soil_water_retention_curve%soil_suction(sucsat(c,j), s_node, bsw(c,j), smp_node_lf)
-                  smp_node_lf = -sucsat(c,j)*s_node**( -bsw(c,j) )
-                  !smp_node_lf =  -sucsat(c,j)*(h2osoi_vol(c,j)/watsat(c,j))**(-bsw(c,j))
-                  smp_node_lf = max(smpsc(veg_pp%itype(p)), smp_node_lf)
-                  sum2  = sum2 +rootfr(p,j)*min((smp_node_lf - smpsc(veg_pp%itype(p))) / &
-                           (smpso(veg_pp%itype(p)) - smpsc(veg_pp%itype(p))), 1._r8)
-               end if
-            end do
-            btran2(p) = sum2
       end do
-      !$acc wait
 
       ! Normalize root resistances to get layer contribution to ET
-      !$acc parallel loop independent gang default(present)
       do j = 1,nlevgrnd
-         !$acc loop vector independent private(p)
          do f = 1, fn
             p = filterp(f)
             if (btran(p) > btran0) then
@@ -514,7 +416,6 @@ end subroutine normalize_test
             end if
          end do
       end do
-
     end associate
 
   end subroutine calc_root_moist_stress_clm45default
@@ -527,6 +428,7 @@ end subroutine normalize_test
     ! compute the root water stress using different approaches
     !
     ! USES
+      !$acc routine seq
     use shr_kind_mod    , only : r8 => shr_kind_r8
     use elm_varcon      , only : tfrz      !temperature where water freezes [K], this is taken as constant at the moment
     use decompMod       , only : bounds_type
@@ -545,14 +447,13 @@ end subroutine normalize_test
     type(soilstate_type)   , intent(inout) :: soilstate_vars
     !
     ! !LOCAL VARIABLES:
-    integer :: p, f, j, c, l                ! indices
-    real(r8) :: smp_node, s_node            ! temporary variables
-    real(r8) :: rootfr_unf(1:fn,1:nlevgrnd) ! Rootfraction defined for unfrozen layers only.
+    integer :: p, f, j, c, l                                   ! indices
+    real(r8) :: smp_node, s_node                               ! temporary variables
+    real(r8) :: rootfr_unf(bounds%begp:bounds%endp,1:nlevgrnd) ! Rootfraction defined for unfrozen layers only.
     !------------------------------------------------------------------------------
 
     !define normalized rootfraction for unfrozen soil
-    rootfr_unf(1:fn,1:nlevgrnd) = 0._r8
-    !$acc enter data copyin(rootfr_unf(1:fn,1:nlevgrnd))
+    rootfr_unf(bounds%begp:bounds%endp,1:nlevgrnd) = 0._r8
 
     call normalize_unfrozen_rootfr(bounds,  &
          ubj = nlevgrnd,                    &
@@ -560,7 +461,7 @@ end subroutine normalize_test
          filterp = filterp,                 &
          canopystate_vars=canopystate_vars, &
          soilstate_vars=soilstate_vars,     &
-         rootfr_unf=rootfr_unf(1:fn,1:nlevgrnd))
+         rootfr_unf=rootfr_unf(bounds%begp:bounds%endp,1:nlevgrnd))
 
     !suppose h2osoi_liq, eff_porosity are already computed somewhere else
 
@@ -568,17 +469,16 @@ end subroutine normalize_test
        !add other methods later
     case (moist_stress_clm_default)
 
-       call calc_root_moist_stress_clm45default( &
+       call calc_root_moist_stress_clm45default(bounds, &
             nlevgrnd = nlevgrnd,                        &
             fn = fn,                                    &
             filterp = filterp,                          &
             energyflux_vars=energyflux_vars,            &
             soilstate_vars=soilstate_vars,              &
-            rootfr_unf=rootfr_unf(1:fn,1:nlevgrnd))
+            rootfr_unf=rootfr_unf(bounds%begp:bounds%endp,1:nlevgrnd))
 
     case default
     end select
-    !$acc exit data delete(rootfr_unf(:,:))
 
   end subroutine calc_root_moist_stress
 
diff --git a/components/elm/src/biogeophys/SoilStateType.F90 b/components/elm/src/biogeophys/SoilStateType.F90
index 478623f365..9b06b4a8f4 100644
--- a/components/elm/src/biogeophys/SoilStateType.F90
+++ b/components/elm/src/biogeophys/SoilStateType.F90
@@ -923,6 +923,106 @@ contains
     end if
   end subroutine Restart
 
+
+  !------------------------------------------------------------------------
+#ifdef USE_PETSC_LIB
+  subroutine InitColdGhost(this, bounds_proc)
+    !
+    ! !DESCRIPTION:
+    ! Assign soil properties for ghost/halo columns
+    !
+    ! !USES:
+    use domainLateralMod       , only : ExchangeColumnLevelGhostData
+    use shr_infnan_mod         , only : shr_infnan_isnan
+    use shr_infnan_mod         , only : isnan => shr_infnan_isnan
+    use landunit_varcon        , only : max_lunit
+    !
+    implicit none
+    !
+    ! !ARGUMENTS:
+    class(soilstate_type)            :: this
+    type(bounds_type), intent(in)    :: bounds_proc
+    !
+    integer             :: c,j                     ! indices
+    integer             :: nvals_col               ! number of values per subgrid category
+    integer             :: beg_idx, end_idx        ! begin/end index for accessing values in data_send/data_recv
+    real(r8) , parameter:: FILL_VALUE = -999999.d0 ! temporary
+    real(r8) , pointer  :: data_send_col(:)        ! data sent by local mpi rank
+    real(r8) , pointer  :: data_recv_col(:)        ! data received by local mpi rank
+
+    ! Number of values per soil column
+    nvals_col = 4*nlevgrnd ! (watsat + hksat + bsw + sucsat) * nlevgrnd
+
+    ! Allocate value
+    allocate(data_send_col((bounds_proc%endc     - bounds_proc%begc     + 1)*nvals_col))
+    allocate(data_recv_col((bounds_proc%endc_all - bounds_proc%begc_all + 1)*nvals_col))
+
+    ! Assemble the data to send
+    do c = bounds_proc%begc, bounds_proc%endc
+
+       beg_idx = (c - bounds_proc%begc)*nvals_col
+
+       do j = 1, nlevgrnd
+
+          beg_idx = beg_idx + 1
+          if (.not. isnan(this%watsat_col(c,j)) .and. this%watsat_col(c,j) /= spval) then
+             data_send_col(beg_idx) = this%watsat_col(c,j)
+          else
+             data_send_col(beg_idx) = FILL_VALUE
+          endif
+
+          beg_idx = beg_idx + 1
+          if (.not. isnan(this%hksat_col(c,j)) .and. this%hksat_col(c,j) /= spval) then
+             data_send_col(beg_idx) = this%hksat_col(c,j)
+          else
+             data_send_col(beg_idx) = FILL_VALUE
+          endif
+
+          beg_idx = beg_idx + 1
+          if (.not. isnan(this%bsw_col(c,j)) .and. this%bsw_col(c,j) /= spval) then
+             data_send_col(beg_idx) = this%bsw_col(c,j)
+          else
+             data_send_col(beg_idx) = FILL_VALUE
+          endif
+
+          beg_idx = beg_idx + 1
+          if (.not. isnan(this%sucsat_col(c,j)) .and. this%sucsat_col(c,j) /= spval) then
+             data_send_col(beg_idx) = this%sucsat_col(c,j)
+          else
+             data_send_col(beg_idx) = FILL_VALUE
+          endif
+       enddo
+    enddo
+
+    ! Send the data
+    call ExchangeColumnLevelGhostData(bounds_proc, nvals_col, data_send_col, data_recv_col)
+
+    ! Assign data corresponding to ghost/halo soil columns
+    do c = bounds_proc%endc + 1, bounds_proc%endc_all
+       beg_idx = (c - bounds_proc%begc)*nvals_col
+       do j = 1, nlevgrnd
+          beg_idx = beg_idx + 1
+          this%watsat_col(c,j) = data_recv_col(beg_idx)
+
+          beg_idx = beg_idx + 1
+          this%hksat_col(c,j) = data_recv_col(beg_idx)
+
+          beg_idx = beg_idx + 1
+          this%bsw_col(c,j) = data_recv_col(beg_idx)
+
+          beg_idx = beg_idx + 1
+          this%sucsat_col(c,j) = data_recv_col(beg_idx)
+       enddo
+    enddo
+
+    ! Free up memory
+    deallocate(data_send_col)
+    deallocate(data_recv_col)
+
+  end subroutine InitColdGhost
+
+#else
+
   !------------------------------------------------------------------------
   subroutine InitColdGhost(this, bounds_proc)
     !
@@ -942,6 +1042,8 @@ contains
          'PETSc, but the code was compiled without -DUSE_PETSC_LIB')
 
   end subroutine InitColdGhost
+
+#endif
   !------------------------------------------------------------------------
 
 
diff --git a/components/elm/src/biogeophys/SoilTemperatureMod.F90 b/components/elm/src/biogeophys/SoilTemperatureMod.F90
index a944ad23b4..be181750ac 100644
--- a/components/elm/src/biogeophys/SoilTemperatureMod.F90
+++ b/components/elm/src/biogeophys/SoilTemperatureMod.F90
@@ -31,7 +31,6 @@ module SoilTemperatureMod
   use perfMod_GPU
   use ExternalModelConstants   , only : EM_ID_PTM
   use ExternalModelConstants   , only : EM_PTM_TBASED_SOLVE_STAGE
-  use column_varcon   , only : icol_roof, icol_sunwall, icol_shadewall, icol_road_perv, icol_road_imperv
   use ExternalModelInterfaceMod, only : EMI_Driver
 
   !! Needed beacuse EMI is still using them as arguments
@@ -39,12 +38,6 @@ module SoilTemperatureMod
   use TemperatureType   , only : temperature_type
   use WaterfluxType     , only : waterflux_type
   use elm_instMod , only : waterflux_vars, waterstate_vars, temperature_vars
-  
-   #ifdef _OPENACC 
-     #define gpuflag 1 
-   #else 
-     #define gpuflag 0
-   #endif 
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -87,14 +80,15 @@ module SoilTemperatureMod
   public :: SetRHSVec_SnowUrbanNonRoad          ! Sets up the RHS vector corresponding to snow layers for Urban columns that are sunwall, shadewall, and roof columns
   public :: SetRHSVec_SnowUrbanRoad             ! Sets up the RHS vector corresponding to snow layers for Urban columns that are pervious, and impervious columns
   public :: SetRHSVec_SnowNonUrban              ! Sets up the RHS vector corresponding to snow layers for Non-Urban columns
-  !public :: SetRHSVec_StandingSurfaceWater      ! Sets up the RHS vector corresponding to standing water layers for Urban+Non-Urban columns
+  public :: SetRHSVec_StandingSurfaceWater      ! Sets up the RHS vector corresponding to standing water layers for Urban+Non-Urban columns
   public :: SetRHSVec_Soil                      ! Sets up the RHS vector corresponding to soil layers for Urban+Non-Urban columns
   public :: SetRHSVec_SoilUrban                 ! Sets up the RHS vector corresponding to soil layers for Urban columns
   public :: SetRHSVec_SoilUrbanNonRoad          ! Sets up the RHS vector corresponding to soil layers for Urban columns that are pervious, and impervious columns
   public :: SetRHSVec_SoilUrbanRoad             ! Sets up the RHS vector corresponding to soil layers for Urban columns that are pervious, and impervious columns
   public :: SetRHSVec_SoilNonUrban              ! Sets up the RHS vector corresponding to soil layers for Non-Urban columns
-  !public :: SetRHSVec_Soil_StandingSurfaceWater ! Adds contribution from standing water in the RHS vector corresponding to soil layers
+  public :: SetRHSVec_Soil_StandingSurfaceWater ! Adds contribution from standing water in the RHS vector corresponding to soil layers
   public :: SetMatrix                           ! Sets up the matrix for the numerical solution of temperature for snow/standing-water/soil
+  public :: AssembleMatrixFromSubmatrices       ! Assemble the full matrix from submatrices.
   public :: SetMatrix_Snow                      ! Set up the matrix entries corresponding to snow layers for Urban+Non-Urban columns
   public :: SetMatrix_SnowUrban                 ! Set up the matrix entries corresponding to snow layers for Urban column
   public :: SetMatrix_SnowUrbanNonRoad          ! Set up the matrix entries corresponding to snow layers for Urban column that are sunwall, shadewall, and roof columns
@@ -103,6 +97,7 @@ module SoilTemperatureMod
   public :: SetMatrix_Snow_Soil                 ! Set up the matrix entries corresponding to snow-soil interaction
   public :: SetMatrix_Snow_SoilUrban            ! Set up the matrix entries corresponding to snow-soil interaction for Urban column
   public :: SetMatrix_Snow_SoilUrbanNonRoad     ! Set up the matrix entries corresponding to snow-soil interaction for Urban column that are sunwall, shadewall, and roof columns
+  public :: SetMatrix_Snow_SoilUrbanRoad        ! Set up the matrix entries corresponding to snow-soil interaction for Urban column that are pervious, and impervious columns
   public :: SetMatrix_Snow_SoilNonUrban         ! Set up the matrix entries corresponding to snow-soil interaction for Non-Urban column
   public :: SetMatrix_Soil                      ! Set up the matrix entries corresponding to soil layers for Urban+Non-Urban columns
   public :: SetMatrix_SoilUrban                 ! Set up the matrix entries corresponding to soil layers for Urban column
@@ -111,6 +106,8 @@ module SoilTemperatureMod
   public :: SetMatrix_SoilNonUrban              ! Set up the matrix entries corresponding to soil layers for Non-Urban column
   public :: SetMatrix_Soil_Snow                 ! Set up the matrix entries corresponding to soil-snow interction for Urban+Non-Urban columns
   public :: SetMatrix_Soil_SnowUrban            ! Set up the matrix entries corresponding to soil-snow interction for Urban column
+  public :: SetMatrix_Soil_SnowUrbanNonRoad     ! Set up the matrix entries corresponding to soil-snow interction for Urban column that are sunwall, shadewall, and roof columns
+  public :: SetMatrix_Soil_SnowUrbanRoad        ! Set up the matrix entries corresponding to soil-snow interction for Urban column that are pervious, and impervious columns
   public :: SetMatrix_Soil_SnowNonUrban         ! Set up the matrix entries corresponding to soil-snow interction for Non-Urban column
   public :: SetMatrix_StandingSurfaceWater      ! Set up the matrix entries corresponding to standing surface water
   public :: SetMatrix_StandingSurfaceWater_Soil ! Set up the matrix entries corresponding to standing surface water-soil interaction
@@ -126,6 +123,9 @@ module SoilTemperatureMod
   integer            :: thermal_model = default_thermal_model
   real(r8), private, parameter :: thin_sfclayer = 1.0e-6_r8   ! Threshold for thin surface layer
   !-----------------------------------------------------------------------
+  !$acc declare copyin(default_thermal_model)
+  !$acc declare copyin(petsc_thermal_model  )
+  !$acc declare create(thermal_model)
 contains
 
   !-----------------------------------------------------------------------
@@ -142,13 +142,14 @@ contains
     else
        thermal_model = petsc_thermal_model
     endif
+    !$acc update device(thermal_model)
 
   end subroutine init_soil_temperature
 
   !-----------------------------------------------------------------------
   subroutine SoilTemperature(bounds, num_urbanl, filter_urbanl, num_nolakec, filter_nolakec, &
-       urbanparams_vars, canopystate_vars, &
-       solarabs_vars, soilstate_vars )
+       atm2lnd_vars, urbanparams_vars, canopystate_vars, &
+       solarabs_vars, soilstate_vars, energyflux_vars )
     !
     ! !DESCRIPTION:
     ! Snow and soil temperatures including phase change
@@ -170,12 +171,14 @@ contains
     !   results in a tridiagonal system equation.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varpar               , only : nlevsno, nlevgrnd, nlevurb
     use elm_varctl               , only : iulog
     use elm_varcon               , only : cnfac, cpice, cpliq, denh2o
     use landunit_varcon          , only : istice, istice_mec, istsoil, istcrop
     use column_varcon            , only : icol_roof, icol_sunwall, icol_shadewall, icol_road_perv, icol_road_imperv
     use landunit_varcon          , only : istwet, istice, istice_mec, istsoil, istcrop
+    use BandDiagonalMod          , only : BandDiagonal
 
     !
     ! !ARGUMENTS:
@@ -184,10 +187,12 @@ contains
     integer                , intent(in)    :: filter_nolakec(:)                  ! column filter for non-lake points
     integer                , intent(in)    :: num_urbanl                         ! number of urban landunits in clump
     integer                , intent(in)    :: filter_urbanl(:)                   ! urban landunit filter
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(urbanparams_type) , intent(in)    :: urbanparams_vars
     type(canopystate_type) , intent(in)    :: canopystate_vars
     type(soilstate_type)   , intent(inout) :: soilstate_vars
     type(solarabs_type)    , intent(inout) :: solarabs_vars
+    type(energyflux_type)  , intent(inout) :: energyflux_vars
     real(r8) :: dtime                                                       ! land model time step (sec)
 
     !
@@ -195,7 +200,8 @@ contains
     integer  :: j,c,l,g,pi                                                  ! indices
     integer  :: fc                                                          ! lake filtered column indices
     integer  :: fl                                                          ! urban filtered landunit indices
-    real(r8) :: cv (1:num_nolakec,-nlevsno+1:nlevgrnd)            ! heat capacity [J/(m2 K)]
+    integer  :: jtop(bounds%begc:bounds%endc)                               ! top level at each column
+    real(r8) :: cv (bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)            ! heat capacity [J/(m2 K)]
     real(r8) :: tk (bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)            ! thermal conductivity [W/(m K)]
     real(r8) :: fn (bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)            ! heat diffusion through the layer interface [W/m2]
     real(r8) :: fn1(bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)            ! heat diffusion through the layer interface [W/m2]
@@ -206,6 +212,7 @@ contains
     real(r8) :: hs_top(bounds%begc:bounds%endc)                             ! net energy flux into surface layer (col) [W/m2]
     logical  :: cool_on(bounds%begl:bounds%endl)                            ! is urban air conditioning on?
     logical  :: heat_on(bounds%begl:bounds%endl)                            ! is urban heating on?
+    real(r8) :: fn_h2osfc(bounds%begc:bounds%endc)                          ! heat diffusion through standing-water/soil interface [W/m2]
     real(r8) :: dz_h2osfc(bounds%begc:bounds%endc)                          ! height of standing surface water [m]
     real(r8) :: tvector_nourbanc(bounds%begc:bounds%endc,-nlevsno:nlevgrnd) ! initial temperature solution for non-urban columns [Kelvin]
     real(r8) :: tvector_urbanc(bounds%begc:bounds%endc,-nlevsno:nlevgrnd)   ! initial temperature solution for urban columns [Kelvin]
@@ -218,14 +225,11 @@ contains
     integer  :: num_nolakec_and_nourbanc
     integer  :: num_nolakec_and_urbanc
     integer  :: num_filter_lun
-    integer :: fnlu, fnlnu 
-    integer :: fidx1, fidx2 
-    integer :: filter_nolakec_and_nourbanc(1:num_nolakec)
-    integer :: filter_nolakec_and_urbanc(1:num_nolakec)
+    integer, allocatable :: filter_nolakec_and_nourbanc(:)
+    integer, allocatable :: filter_nolakec_and_urbanc(:)
     integer, allocatable :: filter_lun(:)
     logical  :: urban_column
     logical  :: update_temperature
-    real(r8) :: sum1, sum2 
     !-----------------------------------------------------------------------
 
     associate(                                                                   &
@@ -292,20 +296,10 @@ contains
 
       ! Get step size
 
-      dtime = dtime_mod 
+      dtime = dtime_mod !get_step_size()
 
-      !$acc enter data create(cool_on(:), &
-      !$acc    heat_on(:), jbot(:), &
-      !$acc    fn(:,:), &
-      !$acc    fn1(:,:),&
-      !$acc    hs_top(:),dz_h2osfc(:), &
-      !$acc    dhsdT(:), hs_soil(:),&
-      !$acc    hs_top_snow(:),&
-      !$acc    hs_h2osfc(:),&
-      !$acc    sabg_lyr_col(:,:) , &
-      !$acc    tk(:,:), cv(:,:) )
-
-      !$acc parallel loop independent gang vector default(present) 
+      ! Restrict internal building temperature to between min and max
+      ! and determine if heating or air conditioning is on
       do fl = 1,num_urbanl
          l = filter_urbanl(fl)
          if (lun_pp%urbpoi(l)) then
@@ -325,9 +319,10 @@ contains
 
       ! set up compact matrix for band diagonal solver, requires additional
       !     sub/super diagonals (1 each), and one additional row for t_h2osfc
-      !$acc parallel loop independent gang vector default(present)
+      jtop = -9999
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
+         jtop(c) = snl(c)
          ! compute jbot
          if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
               .or. col_pp%itype(c) == icol_roof) ) then
@@ -341,44 +336,42 @@ contains
       ! Setup two new filters:
       ! - filter_nolakec_and_nourbanc: No Lakes + No Urban columns
       ! - filter_nolakec_and_urbanc  : No Lakes + Urban columns
-      ! 
-      filter_nolakec_and_nourbanc (:) = 0
-      filter_nolakec_and_urbanc   (:) = 0
-      !$acc enter data copyin(filter_nolakec_and_nourbanc(1:num_nolakec),&
-      !$acc    filter_nolakec_and_urbanc(1:num_nolakec) )
-      
+      !
+      num_nolakec_and_nourbanc = 0
+      num_nolakec_and_urbanc   = 0
+      do fc = 1,num_nolakec
+         c = filter_nolakec(fc)
+         l = col_pp%landunit(c)
+         if (lun_pp%urbpoi(l)) then
+            num_nolakec_and_urbanc = num_nolakec_and_urbanc + 1
+         else
+            num_nolakec_and_nourbanc = num_nolakec_and_nourbanc + 1
+         endif
+      enddo
+
+      allocate(filter_nolakec_and_nourbanc(num_nolakec_and_nourbanc))
+      allocate(filter_nolakec_and_urbanc(  num_nolakec_and_urbanc  ))
+
       num_nolakec_and_nourbanc = 0
       num_nolakec_and_urbanc   = 0
-      fnlu = 0 
-      fnlnu = 0 
-      !$acc parallel loop independent gang vector default(present) private(fidx1,fidx2,c,l) copy(fnlu,fnlnu) &
-      !$acc present(filter_nolakec_and_nourbanc(:), filter_nolakec_and_urbanc(:)) num_gangs(1) vector_length(1)  
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          l = col_pp%landunit(c)
          if (lun_pp%urbpoi(l)) then
-            !$acc atomic capture 
-            fnlu = fnlu + 1
-            fidx1 = fnlu
-            !$acc end atomic 
-            filter_nolakec_and_urbanc(fidx1) = c
+            num_nolakec_and_urbanc = num_nolakec_and_urbanc + 1
+            filter_nolakec_and_urbanc(num_nolakec_and_urbanc) = c
          else
-            !$acc atomic capture
-            fnlnu = fnlnu + 1
-            fidx2 = fnlnu
-            !$acc end atomic 
-            filter_nolakec_and_nourbanc(fidx2) = c
+            num_nolakec_and_nourbanc = num_nolakec_and_nourbanc + 1
+            filter_nolakec_and_nourbanc(num_nolakec_and_nourbanc) = c
          endif
       end do
-      num_nolakec_and_urbanc = fnlu 
-      num_nolakec_and_nourbanc = fnlnu
 
       num_filter_lun = bounds%endl - bounds%begl + 1
       allocate(filter_lun(num_filter_lun))
-
       do fc = 1, num_filter_lun
          filter_lun(fc) = bounds%begl + fc - 1
       enddo
+
       !------------------------------------------------------
       ! Compute ground surface and soil temperatures
       !------------------------------------------------------
@@ -386,10 +379,9 @@ contains
       ! Thermal conductivity and Heat capacity
 
       tk_h2osfc(begc:endc) = spval
-      !$acc enter data copyin(tk_h2osfc(:) )  
       call SoilThermProp(bounds, num_nolakec, filter_nolakec, &
            tk(begc:endc, :), &
-           cv(1:, :), &
+           cv(begc:endc, :), &
            tk_h2osfc(begc:endc), &
            urbanparams_vars, soilstate_vars)
 
@@ -404,41 +396,38 @@ contains
            hs_top( begc:endc ),                                               &
            dhsdT( begc:endc ),                                                &
            sabg_lyr_col( begc:endc, -nlevsno+1: ),                            &
-           urbanparams_vars, canopystate_vars, &
-           solarabs_vars)
+           atm2lnd_vars, urbanparams_vars, canopystate_vars, &
+           solarabs_vars, energyflux_vars)
 
       ! Determine heat diffusion through the layer interface and factor used in computing
       ! banded diagonal matrix and set up vector r and vectors a, b, c that define banded
       ! diagonal matrix and solve system
 
       call ComputeHeatDiffFluxAndFactor(bounds, num_nolakec, filter_nolakec, &
-           dtime_mod,                                                            &
+           dtime,                                                            &
            tk( begc:endc, -nlevsno+1: ),                                     &
-           cv( 1:, -nlevsno+1: ),                                     &
+           cv( begc:endc, -nlevsno+1: ),                                     &
            fn( begc:endc, -nlevsno+1: ),                                     &
-           fact( begc:endc, -nlevsno+1: ) )
+           fact( begc:endc, -nlevsno+1: ),                                   &
+           energyflux_vars)
 
       ! compute thermal properties of h2osfc
 
-      !$acc parallel loop independent gang vector default(present) 
       do fc = 1,num_nolakec
-        c = filter_nolakec(fc)
-        if ( (h2osfc(c) > thin_sfclayer) .and. (frac_h2osfc(c) > thin_sfclayer) ) then
-          c_h2osfc(c)  = max(thin_sfclayer, cpliq*h2osfc(c)/frac_h2osfc(c)  )
-          dz_h2osfc(c) = max(thin_sfclayer, 1.0e-3*h2osfc(c)/frac_h2osfc(c) )
-        else
-          c_h2osfc(c)  = thin_sfclayer
-          dz_h2osfc(c) = thin_sfclayer
-        endif
+         c = filter_nolakec(fc)
+         if ( (h2osfc(c) > thin_sfclayer) .and. (frac_h2osfc(c) > thin_sfclayer) ) then
+            c_h2osfc(c)  = max(thin_sfclayer, cpliq*h2osfc(c)/frac_h2osfc(c)  )
+            dz_h2osfc(c) = max(thin_sfclayer, 1.0e-3*h2osfc(c)/frac_h2osfc(c) )
+         else
+            c_h2osfc(c)  = thin_sfclayer
+            dz_h2osfc(c) = thin_sfclayer
+         endif
       enddo
-      
-      
+
       ! initialize initial temperature vector
+
       tvector_nourbanc(begc:endc, :) = spval
       tvector_urbanc(  begc:endc, :) = spval
-      !$acc enter data copyin(tvector_nourbanc(:,:), tvector_urbanc(:,:))
-
-      !$acc parallel loop independent gang vector default(present) 
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          do j = snl(c)+1, 0
@@ -454,9 +443,11 @@ contains
          tvector_urbanc(c,1:nlevgrnd)   = t_soisno(c,1:nlevgrnd)
       enddo
 
+
       !
       ! Solve temperature for non-lake + non-urban columns
       !
+
       update_temperature = .true.
       select case(thermal_model)
       case (default_thermal_model)
@@ -465,7 +456,7 @@ contains
          call SolveTemperature(bounds,                &
               num_nolakec_and_nourbanc,               &
               filter_nolakec_and_nourbanc,            &
-              dtime_mod,                                  &
+              dtime,                                  &
               hs_h2osfc( begc:endc ),                 &
               hs_top_snow( begc:endc ),               &
               hs_soil( begc:endc ),                   &
@@ -478,7 +469,7 @@ contains
               fn( begc:endc, -nlevsno+1: ),           &
               c_h2osfc( begc:endc ),                  &
               dz_h2osfc( begc:endc ),                 &
-              snl( begc:endc ),                      &
+              jtop( begc:endc ),                      &
               jbot( begc:endc ),                      &
               urban_column,                           &
               tvector_nourbanc( begc:endc, -nlevsno: ))
@@ -493,18 +484,20 @@ contains
              dhsdT( begc:endc ),                    &
              hs_soil( begc:endc ),                  &
              hs_top_snow( begc:endc ),              &
-             hs_h2osfc( begc:endc )                &
+             hs_h2osfc( begc:endc ),                &
+             energyflux_vars                        &
              )
 
         call EMI_Driver(EM_ID_PTM,                                      &
              EM_PTM_TBASED_SOLVE_STAGE,                                 &
-              dt = dtime_mod,                               &
+              dt = dtime,                               &
               clump_rank  = bounds%clump_index,                          &
               num_nolakec_and_nourbanc = num_nolakec_and_nourbanc,       &
               filter_nolakec_and_nourbanc = filter_nolakec_and_nourbanc, &
               num_filter_lun = num_filter_lun,                           &
               filter_lun = filter_lun,                                   &
               waterstate_vars = waterstate_vars,                         &
+              energyflux_vars = energyflux_vars,                         &
               temperature_vars = temperature_vars)
 #endif
       end select
@@ -512,12 +505,12 @@ contains
       !
       ! Solve temperature for lake + urban column
       !
-      !$acc enter data copyin(update_temperature) 
+
       urban_column = .true.
       call SolveTemperature(bounds,                &
            num_nolakec_and_urbanc,                 &
            filter_nolakec_and_urbanc,              &
-           dtime_mod,                                  &
+           dtime,                                  &
            hs_h2osfc( begc:endc ),                 &
            hs_top_snow( begc:endc ),               &
            hs_soil( begc:endc ),                   &
@@ -530,26 +523,22 @@ contains
            fn( begc:endc, -nlevsno+1: ),           &
            c_h2osfc( begc:endc ),                  &
            dz_h2osfc( begc:endc ),                 &
-           snl( begc:endc ),                      &
+           jtop( begc:endc ),                      &
            jbot( begc:endc ),                      &
            urban_column,                           &
            tvector_urbanc( begc:endc, -nlevsno: ))
 
       ! return temperatures to original array
-      !$acc parallel loop independent gang vector default(present) 
+
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          l = col_pp%landunit(c)
 
          if (lun_pp%urbpoi(l)) then
-           !$acc loop seq 
             do j = snl(c)+1, 0
                t_soisno(c,j)       = tvector_urbanc(c,j-1)        !snow layers
             end do
-            !$acc loop seq  
-            do j = 1, nlevgrnd
-              t_soisno(c,j) = tvector_urbanc(c,j) !soil layers
-            end do 
+            t_soisno(c,1:nlevgrnd) = tvector_urbanc(c,1:nlevgrnd) !soil layers
 
             if (frac_h2osfc(c) == 0._r8) then
                t_h2osfc(c)         = t_soisno(c,1)
@@ -560,14 +549,10 @@ contains
          else
 
             if (update_temperature) then
-               !$acc loop seq  
                do j = snl(c)+1, 0
                   t_soisno(c,j)       = tvector_nourbanc(c,j-1)        !snow layers
                end do
-               !$acc loop seq 
-               do j = 1, nlevgrnd 
-                 t_soisno(c,j) = tvector_nourbanc(c,j) !soil layers
-               end do 
+               t_soisno(c,1:nlevgrnd) = tvector_nourbanc(c,1:nlevgrnd) !soil layers
 
                if (frac_h2osfc(c) == 0._r8) then
                   t_h2osfc(c)         = t_soisno(c,1)
@@ -575,11 +560,13 @@ contains
                   t_h2osfc(c)         = tvector_nourbanc(c,0)          !surface water
                endif
             endif
+
          endif
+
       enddo
 
       ! Melting or Freezing
-      !$acc parallel loop independent gang vector collapse(2) default(present) 
+
       do j = -nlevsno+1,nlevgrnd
          do fc = 1,num_nolakec
             c = filter_nolakec(fc)
@@ -611,7 +598,6 @@ contains
          end do
       end do
 
-      !$acc parallel loop independent gang vector default(present) present(fn1(:,:),fn(:,:)) 
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          l = col_pp%landunit(c)
@@ -635,18 +621,18 @@ contains
       end do
 
       ! compute phase change of h2osfc
-      !$acc parallel loop independent gang vector default(present) 
+
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
-         xmf_h2osfc(c) = 0._r8
+         xmf_h2osfc(c) = 0.
       end do
+
       call PhaseChangeH2osfc (bounds, num_nolakec, filter_nolakec, &
-           dhsdT(bounds%begc:bounds%endc), dtime_mod )
+           dhsdT(bounds%begc:bounds%endc), energyflux_vars,dtime )
 
       call Phasechange_beta (bounds, num_nolakec, filter_nolakec, &
-           dhsdT(bounds%begc:bounds%endc), soilstate_vars, dtime_mod)
+           dhsdT(bounds%begc:bounds%endc), soilstate_vars, energyflux_vars, dtime)
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          ! this expression will (should) work whether there is snow or not
@@ -671,7 +657,6 @@ contains
 
       ! Initialize soil heat content
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          l = col_pp%landunit(c)
@@ -683,8 +668,7 @@ contains
       end do
 
       ! Calculate soil heat content and soil plus snow heat content
-      !NOTE:  Split into reduction loop 
-      !$acc parallel loop independent gang vector collapse(2) default(present) 
+
       do j = -nlevsno+1,nlevgrnd
          do fc = 1,num_nolakec
             c = filter_nolakec(fc)
@@ -694,48 +678,33 @@ contains
                eflx_fgr12(c) = -cnfac*fn(c,1) - (1._r8-cnfac)*fn1(c,1)
             end if
             if (j > 0 .and. j < nlevgrnd .and. (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop)) then
-                eflx_fgr(c,j) = -cnfac*fn(c,j) - (1._r8-cnfac)*fn1(c,j)
+               eflx_fgr(c,j) = -cnfac*fn(c,j) - (1._r8-cnfac)*fn1(c,j)
             else if (j == nlevgrnd .and. (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop)) then
                eflx_fgr(c,j) = 0._r8
             end if
-         end do
-      end do
 
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2)  
-      do fc = 1,num_nolakec
-         c = filter_nolakec(fc)
-         l = col_pp%landunit(c)
-         sum1 = 0.0_r8 ; sum2 = 0.0_r8 
-         if (.not. lun_pp%urbpoi(l)) then
-            !$acc loop vector reduction(+:sum1,sum2) 
-            do j = -nlevsno+1,nlevgrnd
+            if (.not. lun_pp%urbpoi(l)) then
                if (j >= snl(c)+1) then
-                  sum1 = sum1 + cv(fc,j)*t_soisno(c,j) / 1.e6_r8
+                  hc_soisno(c) = hc_soisno(c) + cv(c,j)*t_soisno(c,j) / 1.e6_r8
                endif
                if (j >= 1) then
-                  sum2 = sum2 + cv(fc,j)*t_soisno(c,j) / 1.e6_r8
+                  hc_soi(c) = hc_soi(c) + cv(c,j)*t_soisno(c,j) / 1.e6_r8
                end if
-            end do
-            hc_soisno(c) = hc_soisno(c) + sum1
-            hc_soi(c)    = hc_soi(c) + sum2 
-         end if
+            end if
+         end do
       end do
-      ! Free up memory
-      !$acc exit data delete(cool_on(:),heat_on(:), jbot(:), &
-      !$acc    filter_nolakec_and_nourbanc(:), filter_nolakec_and_urbanc(:), &
-      !$acc    tk(:,:), cv(:,:), tk_h2osfc(:), &
-      !$acc    tvector_nourbanc(:,:), tvector_urbanc(:,:), fn(:,:), fn1(:,:), hs_top(:),dz_h2osfc(:), &
-      !$acc    dhsdT(:), hs_soil(:), hs_top_snow(:), hs_h2osfc(:),sabg_lyr_col(:,:), &
-      !$acc    update_temperature)
-  
+
 
       ! Free up memory
+      deallocate(filter_nolakec_and_nourbanc)
+      deallocate(filter_nolakec_and_urbanc  )
       deallocate(filter_lun                 )
 
     end associate
 
   end subroutine SoilTemperature
 
+
   !-----------------------------------------------------------------------
 
   subroutine SolveTemperature(bounds, num_filter, filter, dtime, &
@@ -747,6 +716,7 @@ contains
     !  Assembles and solves the banded penta-diagonal system of equations
     !
     ! !USES:
+      !$acc routine seq
     use elm_varpar       , only : nlevsno, nlevgrnd, nlevurb
     use elm_varctl       , only : iulog
     use elm_varcon       , only : cnfac, cpice, cpliq, denh2o
@@ -776,10 +746,10 @@ contains
     integer                , intent(in)  :: jtop(bounds%begc: )                        ! top level at each column
     integer                , intent(in)  :: jbot(bounds%begc: )                        ! bottom level at each column
     logical                , intent(in)  :: urban_column                               ! Is true if solving temperature for urban column, otherwise false
-    real(r8)               , intent(inout) :: tvector( bounds%begc: , -nlevsno: )        ! Numerical solution of temperature
+    real(r8)               , intent(out) :: tvector( bounds%begc: , -nlevsno: )        ! Numerical solution of temperature
     !
     ! !LOCAL VARIABLES:
-    integer            :: c, fc, j, l
+    integer            :: c, fc, j
     integer, parameter :: nband=5
     real(r8)           :: bmatrix(bounds%begc:bounds%endc,nband,-nlevsno:nlevgrnd) ! banded matrix for numerical solution of temperature
     real(r8)           :: rvector(bounds%begc:bounds%endc,-nlevsno:nlevgrnd)       ! RHS vector for numerical solution of temperature
@@ -793,22 +763,6 @@ contains
          )
 
       ! Enforce expected array sizes
-      !$acc enter data create(rvector(:,:), bmatrix(:,:,:) )
-      !$acc parallel loop independent collapse(2) gang vector default(present)  
-      do j=-nlevsno, nlevgrnd 
-        do c = begc, endc 
-           rvector(c,j) = spval 
-        end do 
-      end do
-   
-      !$acc parallel loop independent default(present) collapse(3)  
-      do j = -nlevsno,nlevgrnd
-         do l = 1,nband 
-            do c = begc, endc 
-               bmatrix(c,l,j) = 0._r8 
-            end do 
-         end do 
-      end do 
 
     call SetRHSVec(bounds, num_filter, filter,   &
          dtime,                                  &
@@ -846,261 +800,260 @@ contains
     event = 'SoilTempBandDiag'
     call t_start_lnd(event)
     call BandDiagonal(bounds, -nlevsno, nlevgrnd, jtop(begc:endc), jbot(begc:endc), &
-         num_filter, filter, bmatrix(begc:endc, :, :), &
+         num_filter, filter, nband, bmatrix(begc:endc, :, :), &
          rvector(begc:endc, :), tvector(begc:endc, :))
     call t_stop_lnd(event)
-    
-    !$acc exit data delete(rvector(:,:), bmatrix(:,:,:) )
 
   end associate
 
   end subroutine SolveTemperature
 
-!-----------------------------------------------------------------------
-subroutine SoilThermProp (bounds,  num_nolakec, filter_nolakec, &
-   tk, cv, tk_h2osfc, &
-   urbanparams_vars, soilstate_vars)
-
-!
-! !DESCRIPTION:
-! Calculation of thermal conductivities and heat capacities of
-! snow/soil layers
-! (1) The volumetric heat capacity is calculated as a linear combination
-!     in terms of the volumetric fraction of the constituent phases.
-!
-! (2) The thermal conductivity of soil is computed from the algorithm of
-!     Johansen (as reported by Farouki 1981), and of snow is from the
-!     formulation used in SNTHERM (Jordan 1991).
-! The thermal conductivities at the interfaces between two neighboring
-! layers (j, j+1) are derived from an assumption that the flux across
-! the interface is equal to that from the node j to the interface and the
-! flux from the interface to the node j+1.
-!
-! !USES:
-use elm_varpar      , only : nlevsno, nlevgrnd, nlevurb, nlevsoi
-use elm_varcon      , only : denh2o, denice, tfrz, tkwat, tkice, tkair, cpice,  cpliq, thk_bedrock
-use landunit_varcon , only : istice, istice_mec, istwet
-use column_varcon   , only : icol_roof, icol_sunwall, icol_shadewall, icol_road_perv, icol_road_imperv
-use elm_varctl      , only : iulog
-!
-! !ARGUMENTS:
-type(bounds_type)      , intent(in)    :: bounds
-integer                , intent(in)    :: num_nolakec                      ! number of column non-lake points in column filter
-integer                , intent(in)    :: filter_nolakec(:)                ! column filter for non-lake points
-real(r8)               , intent(inout)   :: cv( 1: , -nlevsno+1: ) ! heat capacity [J/(m2 K)                              ] [col, lev]
-real(r8)               , intent(inout)   :: tk( bounds%begc: , -nlevsno+1: ) ! thermal conductivity at the layer interface [W/(m K) ] [col, lev]
-real(r8)               , intent(inout)   :: tk_h2osfc( bounds%begc: )        ! thermal conductivity of h2osfc [W/(m K)              ] [col]
-type(urbanparams_type) , intent(in)    :: urbanparams_vars
-type(soilstate_type)   , intent(inout) :: soilstate_vars
-!
-! !LOCAL VARIABLES:
-integer  :: l,c,j                     ! indices
-integer  :: nlevbed                   ! # levels to bedrock
-integer  :: fc                        ! lake filtered column indices
-real(r8) :: dksat                     ! thermal conductivity for saturated soil (j/(k s m))
-real(r8) :: dke                       ! kersten number
-real(r8) :: fl                        ! volume fraction of liquid or unfrozen water to total water
-real(r8) :: satw                      ! relative total water content of soil.
-real(r8) :: zh2osfc
-character(len=64) :: event
-!-----------------------------------------------------------------------
-event = 'SoilThermProp'
-call t_start_lnd( event )
-
-associate(                                                 &
-     snl          =>    col_pp%snl                       , & ! Input:  [integer  (:)   ]  number of snow layers
-     dz           =>    col_pp%dz                        , & ! Input:  [real(r8) (:,:) ]  layer depth (m)
-     zi           =>    col_pp%zi                        , & ! Input:  [real(r8) (:,:) ]  interface level below a "z" level (m)
-     z            =>    col_pp%z                         , & ! Input:  [real(r8) (:,:) ]  layer thickness (m)
-     nlev2bed     =>    col_pp%nlevbed                      , & ! Input:  [integer  (:)   ]  number of layers to bedrock
-
-     nlev_improad =>    urbanparams_vars%nlev_improad    , & ! Input:  [integer  (:)   ]  number of impervious road layers
-     tk_wall      =>    urbanparams_vars%tk_wall         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban wall
-     tk_roof      =>    urbanparams_vars%tk_roof         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban roof
-     tk_improad   =>    urbanparams_vars%tk_improad      , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban impervious road
-     cv_wall      =>    urbanparams_vars%cv_wall         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban wall
-     cv_roof      =>    urbanparams_vars%cv_roof         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban roof
-     cv_improad   =>    urbanparams_vars%cv_improad      , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban impervious road
-
-     t_soisno     =>    col_es%t_soisno    , & ! Input:  [real(r8) (:,:) ]  soil temperature (Kelvin)
-
-     frac_sno     =>    col_ws%frac_sno_eff , & ! Input:  [real(r8) (:)   ]  fractional snow covered area
-     h2osfc       =>    col_ws%h2osfc            , & ! Input:  [real(r8) (:)   ]  surface (mm H2O)
-     h2osno       =>    col_ws%h2osno            , & ! Input:  [real(r8) (:)   ]  snow water (mm H2O)
-     h2osoi_liq   =>    col_ws%h2osoi_liq   , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2)
-     h2osoi_ice   =>    col_ws%h2osoi_ice   , & ! Input:  [real(r8) (:,:) ]  ice lens (kg/m2)
-     bw           =>    col_ws%bw        , & ! Output: [real(r8) (:,:) ]  partial density of water in the snow pack (ice + liquid) [kg/m3]
-
-     tkmg         =>    soilstate_vars%tkmg_col          , & ! Input:  [real(r8) (:,:) ]  thermal conductivity, soil minerals  [W/m-K]
-     tkdry        =>    soilstate_vars%tkdry_col         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity, dry soil (W/m/Kelvin)
-     csol         =>    soilstate_vars%csol_col          , & ! Input:  [real(r8) (:,:) ]  heat capacity, soil solids (J/m**3/Kelvin)
-     watsat       =>    soilstate_vars%watsat_col        , & ! Input:  [real(r8) (:,:) ]  volumetric soil water at saturation (porosity)
-     tksatu       =>    soilstate_vars%tksatu_col        , & ! Input:  [real(r8) (:,:) ]  thermal conductivity, saturated soil [W/m-K]
-     thk          =>    soilstate_vars%thk_col             & ! Output: [real(r8) (:,:) ]  thermal conductivity of each layer  [W/m-K]
-     )
-
-  ! Thermal conductivity of soil from Farouki (1981)
-  ! Urban values are from Masson et al. 2002, Evaluation of the Town Energy Balance (TEB)
-  ! scheme with direct measurements from dry districts in two cities, J. Appl. Meteorol.,
-  ! 41, 1011-1026.
-
-  !$acc parallel loop gang independent default(present) 
-  do j = -nlevsno+1,nlevgrnd
-     !$acc loop vector independent 
-     do fc = 1, num_nolakec
-        c = filter_nolakec(fc)
-        nlevbed = nlev2bed(c)
-
-        ! Only examine levels from 1->nlevgrnd
-        if (j >= 1) then
-           l = col_pp%landunit(c)
-           if ((col_pp%itype(c) == icol_sunwall .OR. col_pp%itype(c) == icol_shadewall) .and. j <= nlevurb) then
-              thk(c,j) = tk_wall(l,j)
-           else if (col_pp%itype(c) == icol_roof .and. j <= nlevurb) then
-              thk(c,j) = tk_roof(l,j)
-           else if (col_pp%itype(c) == icol_road_imperv .and. j >= 1 .and. j <= nlev_improad(l)) then
-              thk(c,j) = tk_improad(l,j)
-           else if (lun_pp%itype(l) /= istwet .AND. lun_pp%itype(l) /= istice .AND. lun_pp%itype(l) /= istice_mec &
-                .AND. col_pp%itype(c) /= icol_sunwall .AND. col_pp%itype(c) /= icol_shadewall .AND. &
-                col_pp%itype(c) /= icol_roof) then
-
-              satw = (h2osoi_liq(c,j)/denh2o + h2osoi_ice(c,j)/denice)/(dz(c,j)*watsat(c,j))
-              satw = min(1._r8, satw)
-              if (satw > .1e-6_r8) then
-                 if (t_soisno(c,j) >= tfrz) then       ! Unfrozen soil
-                    dke = max(0._r8, log10(satw) + 1.0_r8)
-                 else                               ! Frozen soil
-                    dke = satw
-                 end if
-                 fl = (h2osoi_liq(c,j)/(denh2o*dz(c,j))) / (h2osoi_liq(c,j)/(denh2o*dz(c,j)) + &
-                      h2osoi_ice(c,j)/(denice*dz(c,j)))
-                 dksat = tkmg(c,j)*tkwat**(fl*watsat(c,j))*tkice**((1._r8-fl)*watsat(c,j))
-                 thk(c,j) = dke*dksat + (1._r8-dke)*tkdry(c,j)
-              else
-                 thk(c,j) = tkdry(c,j)
-              endif
-              if (j > nlevbed) thk(c,j) = thk_bedrock
-           else if (lun_pp%itype(l) == istice .OR. lun_pp%itype(l) == istice_mec) then
-              thk(c,j) = tkwat
-              if (t_soisno(c,j) < tfrz) thk(c,j) = tkice
-           else if (lun_pp%itype(l) == istwet) then
-              if (j > nlevbed) then
-                 thk(c,j) = thk_bedrock
-              else
-                 thk(c,j) = tkwat
-                 if (t_soisno(c,j) < tfrz) thk(c,j) = tkice
-              endif
-           endif
-        endif
-
-        ! Thermal conductivity of snow, which from Jordan (1991) pp. 18
-        ! Only examine levels from snl(c)+1 -> 0 where snl(c) < 1
-        if (snl(c)+1 < 1 .AND. (j >= snl(c)+1) .AND. (j <= 0)) then
-           bw(c,j) = (h2osoi_ice(c,j)+h2osoi_liq(c,j))/(frac_sno(c)*dz(c,j))
-           thk(c,j) = tkair + (7.75e-5_r8 *bw(c,j) + 1.105e-6_r8*bw(c,j)*bw(c,j))*(tkice-tkair)
-        end if
-     end do
-  end do
-
-  ! Thermal conductivity at the layer interface
-  !$acc parallel loop independent gang vector collapse(2) default(present) 
-  do j = -nlevsno+1,nlevgrnd
-     do fc = 1,num_nolakec
-        c = filter_nolakec(fc)
-        if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
-             .or. col_pp%itype(c) == icol_roof) .and. j <= nlevurb) then
-           if (j >= snl(c)+1 .AND. j <= nlevurb-1) then
-              tk(c,j) = thk(c,j)*thk(c,j+1)*(z(c,j+1)-z(c,j)) &
-                   /(thk(c,j)*(z(c,j+1)-zi(c,j))+thk(c,j+1)*(zi(c,j)-z(c,j)))
-           else if (j == nlevurb) then
-
-              ! For urban sunwall, shadewall, and roof columns, there is a non-zero heat flux across
-              ! the bottom "soil" layer and the equations are derived assuming a prescribed internal
-              ! building temperature. (See Oleson urban notes of 6/18/03).
-              tk(c,j) = thk(c,j)
-           end if
-        else if (col_pp%itype(c) /= icol_sunwall .and. col_pp%itype(c) /= icol_shadewall &
-             .and. col_pp%itype(c) /= icol_roof) then
-           if (j >= snl(c)+1 .AND. j <= nlevgrnd-1) then
-              tk(c,j) = thk(c,j)*thk(c,j+1)*(z(c,j+1)-z(c,j)) &
-                   /(thk(c,j)*(z(c,j+1)-zi(c,j))+thk(c,j+1)*(zi(c,j)-z(c,j)))
-           else if (j == nlevgrnd) then
-              tk(c,j) = 0._r8
-           end if
-        end if
-     end do
-  end do
-
-  ! calculate thermal conductivity of h2osfc
-  !$acc parallel loop independent gang vector default(present)  private(c,zh2osfc)
-  do fc = 1, num_nolakec
-     c = filter_nolakec(fc)
-     zh2osfc=1.0e-3*(0.5*h2osfc(c)) !convert to [m] from [mm]
-     tk_h2osfc(c)= tkwat*thk(c,1)*(z(c,1)+zh2osfc) &
-          /(tkwat*z(c,1)+thk(c,1)*zh2osfc)
-  enddo
-
-  ! Soil heat capacity, from de Vires (1963)
-  ! Urban values are from Masson et al. 2002, Evaluation of the Town Energy Balance (TEB)
-  ! scheme with direct measurements from dry districts in two cities, J. Appl. Meteorol.,
-  ! 41, 1011-1026.
-  !$acc parallel loop gang vector collapse(2) independent default(present)
-  do j = 1, nlevgrnd
-     do fc = 1,num_nolakec
-        c = filter_nolakec(fc)
-        l = col_pp%landunit(c)
-        nlevbed = nlev2bed(c)
-        if ((col_pp%itype(c) == icol_sunwall .OR. col_pp%itype(c) == icol_shadewall) .and. j <= nlevurb) then
-           cv(fc,j) = cv_wall(l,j) * dz(c,j)
-        else if (col_pp%itype(c) == icol_roof .and. j <= nlevurb) then
-           cv(fc,j) = cv_roof(l,j) * dz(c,j)
-        else if (col_pp%itype(c) == icol_road_imperv .and. j >= 1 .and. j <= nlev_improad(l)) then
-           cv(fc,j) = cv_improad(l,j) * dz(c,j)
-        else if (lun_pp%itype(l) /= istwet .AND. lun_pp%itype(l) /= istice .AND. lun_pp%itype(l) /= istice_mec &
-             .AND. col_pp%itype(c) /= icol_sunwall .AND. col_pp%itype(c) /= icol_shadewall .AND. &
-             col_pp%itype(c) /= icol_roof) then
-           cv(fc,j) = csol(c,j)*(1._r8-watsat(c,j))*dz(c,j) + (h2osoi_ice(c,j)*cpice + h2osoi_liq(c,j)*cpliq)
-        else if (lun_pp%itype(l) == istwet) then
-           cv(fc,j) = (h2osoi_ice(c,j)*cpice + h2osoi_liq(c,j)*cpliq)
-           if (j > nlevbed) cv(fc,j) = csol(c,j)*dz(c,j)
-        else if (lun_pp%itype(l) == istice .OR. lun_pp%itype(l) == istice_mec) then
-           cv(fc,j) = (h2osoi_ice(c,j)*cpice + h2osoi_liq(c,j)*cpliq)
-        endif
-        if (j == 1) then
-           if (snl(c)+1 == 1 .AND. h2osno(c) > 0._r8) then
-              cv(fc,j) = cv(fc,j) + cpice*h2osno(c)
-           end if
-        end if
-     enddo
-  end do
-
-  ! Snow heat capacity
-  !$acc parallel loop independent gang vector collapse(2) default(present) 
-  do j = -nlevsno+1,0
-     do fc = 1,num_nolakec
-        c = filter_nolakec(fc)
-        if (snl(c)+1 < 1 .and. j >= snl(c)+1) then
-           if (frac_sno(c) > 0._r8) then
-              cv(fc,j) = max(thin_sfclayer, (cpliq*h2osoi_liq(c,j) + cpice*h2osoi_ice(c,j))/frac_sno(c))
-           else
-              cv(fc,j) = thin_sfclayer
-           end if
-        end if
-     end do
-  end do
-  call t_stop_lnd( event )
-
-end associate
-
-end subroutine SoilThermProp
+  !-----------------------------------------------------------------------
+  subroutine SoilThermProp (bounds,  num_nolakec, filter_nolakec, &
+       tk, cv, tk_h2osfc, &
+       urbanparams_vars, soilstate_vars)
+
+    !
+    ! !DESCRIPTION:
+    ! Calculation of thermal conductivities and heat capacities of
+    ! snow/soil layers
+    ! (1) The volumetric heat capacity is calculated as a linear combination
+    !     in terms of the volumetric fraction of the constituent phases.
+    !
+    ! (2) The thermal conductivity of soil is computed from the algorithm of
+    !     Johansen (as reported by Farouki 1981), and of snow is from the
+    !     formulation used in SNTHERM (Jordan 1991).
+    ! The thermal conductivities at the interfaces between two neighboring
+    ! layers (j, j+1) are derived from an assumption that the flux across
+    ! the interface is equal to that from the node j to the interface and the
+    ! flux from the interface to the node j+1.
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varpar      , only : nlevsno, nlevgrnd, nlevurb, nlevsoi
+    use elm_varcon      , only : denh2o, denice, tfrz, tkwat, tkice, tkair, cpice,  cpliq, thk_bedrock
+    use landunit_varcon , only : istice, istice_mec, istwet
+    use column_varcon   , only : icol_roof, icol_sunwall, icol_shadewall, icol_road_perv, icol_road_imperv
+    use elm_varctl      , only : iulog
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)      , intent(in)    :: bounds
+    integer                , intent(in)    :: num_nolakec                      ! number of column non-lake points in column filter
+    integer                , intent(in)    :: filter_nolakec(:)                ! column filter for non-lake points
+    real(r8)               , intent(out)   :: cv( bounds%begc: , -nlevsno+1: ) ! heat capacity [J/(m2 K)                              ] [col, lev]
+    real(r8)               , intent(out)   :: tk( bounds%begc: , -nlevsno+1: ) ! thermal conductivity at the layer interface [W/(m K) ] [col, lev]
+    real(r8)               , intent(out)   :: tk_h2osfc( bounds%begc: )        ! thermal conductivity of h2osfc [W/(m K)              ] [col]
+    type(urbanparams_type) , intent(in)    :: urbanparams_vars
+    type(soilstate_type)   , intent(inout) :: soilstate_vars
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: l,c,j                     ! indices
+    integer  :: nlevbed                   ! # levels to bedrock
+    integer  :: fc                        ! lake filtered column indices
+    real(r8) :: dksat                     ! thermal conductivity for saturated soil (j/(k s m))
+    real(r8) :: dke                       ! kersten number
+    real(r8) :: fl                        ! volume fraction of liquid or unfrozen water to total water
+    real(r8) :: satw                      ! relative total water content of soil.
+    real(r8) :: zh2osfc
+    character(len=64) :: event
+    !-----------------------------------------------------------------------
+    event = 'SoilThermProp'
+    call t_start_lnd( event )
+
+    associate(                                                 &
+         snl          =>    col_pp%snl                       , & ! Input:  [integer  (:)   ]  number of snow layers
+         dz           =>    col_pp%dz                        , & ! Input:  [real(r8) (:,:) ]  layer depth (m)
+         zi           =>    col_pp%zi                        , & ! Input:  [real(r8) (:,:) ]  interface level below a "z" level (m)
+         z            =>    col_pp%z                         , & ! Input:  [real(r8) (:,:) ]  layer thickness (m)
+         nlev2bed     =>    col_pp%nlevbed                      , & ! Input:  [integer  (:)   ]  number of layers to bedrock
+
+         nlev_improad =>    urbanparams_vars%nlev_improad    , & ! Input:  [integer  (:)   ]  number of impervious road layers
+         tk_wall      =>    urbanparams_vars%tk_wall         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban wall
+         tk_roof      =>    urbanparams_vars%tk_roof         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban roof
+         tk_improad   =>    urbanparams_vars%tk_improad      , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban impervious road
+         cv_wall      =>    urbanparams_vars%cv_wall         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban wall
+         cv_roof      =>    urbanparams_vars%cv_roof         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban roof
+         cv_improad   =>    urbanparams_vars%cv_improad      , & ! Input:  [real(r8) (:,:) ]  thermal conductivity of urban impervious road
+
+         t_soisno     =>    col_es%t_soisno    , & ! Input:  [real(r8) (:,:) ]  soil temperature (Kelvin)
+
+         frac_sno     =>    col_ws%frac_sno_eff , & ! Input:  [real(r8) (:)   ]  fractional snow covered area
+         h2osfc       =>    col_ws%h2osfc            , & ! Input:  [real(r8) (:)   ]  surface (mm H2O)
+         h2osno       =>    col_ws%h2osno            , & ! Input:  [real(r8) (:)   ]  snow water (mm H2O)
+         h2osoi_liq   =>    col_ws%h2osoi_liq   , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2)
+         h2osoi_ice   =>    col_ws%h2osoi_ice   , & ! Input:  [real(r8) (:,:) ]  ice lens (kg/m2)
+         bw           =>    col_ws%bw        , & ! Output: [real(r8) (:,:) ]  partial density of water in the snow pack (ice + liquid) [kg/m3]
+
+         tkmg         =>    soilstate_vars%tkmg_col          , & ! Input:  [real(r8) (:,:) ]  thermal conductivity, soil minerals  [W/m-K]
+         tkdry        =>    soilstate_vars%tkdry_col         , & ! Input:  [real(r8) (:,:) ]  thermal conductivity, dry soil (W/m/Kelvin)
+         csol         =>    soilstate_vars%csol_col          , & ! Input:  [real(r8) (:,:) ]  heat capacity, soil solids (J/m**3/Kelvin)
+         watsat       =>    soilstate_vars%watsat_col        , & ! Input:  [real(r8) (:,:) ]  volumetric soil water at saturation (porosity)
+         tksatu       =>    soilstate_vars%tksatu_col        , & ! Input:  [real(r8) (:,:) ]  thermal conductivity, saturated soil [W/m-K]
+         thk          =>    soilstate_vars%thk_col             & ! Output: [real(r8) (:,:) ]  thermal conductivity of each layer  [W/m-K]
+         )
+
+      ! Thermal conductivity of soil from Farouki (1981)
+      ! Urban values are from Masson et al. 2002, Evaluation of the Town Energy Balance (TEB)
+      ! scheme with direct measurements from dry districts in two cities, J. Appl. Meteorol.,
+      ! 41, 1011-1026.
+
+      do j = -nlevsno+1,nlevgrnd
+         do fc = 1, num_nolakec
+            c = filter_nolakec(fc)
+            nlevbed = nlev2bed(c)
+
+            ! Only examine levels from 1->nlevgrnd
+            if (j >= 1) then
+               l = col_pp%landunit(c)
+               if ((col_pp%itype(c) == icol_sunwall .OR. col_pp%itype(c) == icol_shadewall) .and. j <= nlevurb) then
+                  thk(c,j) = tk_wall(l,j)
+               else if (col_pp%itype(c) == icol_roof .and. j <= nlevurb) then
+                  thk(c,j) = tk_roof(l,j)
+               else if (col_pp%itype(c) == icol_road_imperv .and. j >= 1 .and. j <= nlev_improad(l)) then
+                  thk(c,j) = tk_improad(l,j)
+               else if (lun_pp%itype(l) /= istwet .AND. lun_pp%itype(l) /= istice .AND. lun_pp%itype(l) /= istice_mec &
+                    .AND. col_pp%itype(c) /= icol_sunwall .AND. col_pp%itype(c) /= icol_shadewall .AND. &
+                    col_pp%itype(c) /= icol_roof) then
+
+                  satw = (h2osoi_liq(c,j)/denh2o + h2osoi_ice(c,j)/denice)/(dz(c,j)*watsat(c,j))
+                  satw = min(1._r8, satw)
+                  if (satw > .1e-6_r8) then
+                     if (t_soisno(c,j) >= tfrz) then       ! Unfrozen soil
+                        dke = max(0._r8, log10(satw) + 1.0_r8)
+                     else                               ! Frozen soil
+                        dke = satw
+                     end if
+                     fl = (h2osoi_liq(c,j)/(denh2o*dz(c,j))) / (h2osoi_liq(c,j)/(denh2o*dz(c,j)) + &
+                          h2osoi_ice(c,j)/(denice*dz(c,j)))
+                     dksat = tkmg(c,j)*tkwat**(fl*watsat(c,j))*tkice**((1._r8-fl)*watsat(c,j))
+                     thk(c,j) = dke*dksat + (1._r8-dke)*tkdry(c,j)
+                  else
+                     thk(c,j) = tkdry(c,j)
+                  endif
+                  if (j > nlevbed) thk(c,j) = thk_bedrock
+               else if (lun_pp%itype(l) == istice .OR. lun_pp%itype(l) == istice_mec) then
+                  thk(c,j) = tkwat
+                  if (t_soisno(c,j) < tfrz) thk(c,j) = tkice
+               else if (lun_pp%itype(l) == istwet) then
+                  if (j > nlevbed) then
+                     thk(c,j) = thk_bedrock
+                  else
+                     thk(c,j) = tkwat
+                     if (t_soisno(c,j) < tfrz) thk(c,j) = tkice
+                  endif
+               endif
+            endif
+
+            ! Thermal conductivity of snow, which from Jordan (1991) pp. 18
+            ! Only examine levels from snl(c)+1 -> 0 where snl(c) < 1
+            if (snl(c)+1 < 1 .AND. (j >= snl(c)+1) .AND. (j <= 0)) then
+               bw(c,j) = (h2osoi_ice(c,j)+h2osoi_liq(c,j))/(frac_sno(c)*dz(c,j))
+               thk(c,j) = tkair + (7.75e-5_r8 *bw(c,j) + 1.105e-6_r8*bw(c,j)*bw(c,j))*(tkice-tkair)
+            end if
+
+         end do
+      end do
+
+      ! Thermal conductivity at the layer interface
+
+      do j = -nlevsno+1,nlevgrnd
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
+                 .or. col_pp%itype(c) == icol_roof) .and. j <= nlevurb) then
+               if (j >= snl(c)+1 .AND. j <= nlevurb-1) then
+                  tk(c,j) = thk(c,j)*thk(c,j+1)*(z(c,j+1)-z(c,j)) &
+                       /(thk(c,j)*(z(c,j+1)-zi(c,j))+thk(c,j+1)*(zi(c,j)-z(c,j)))
+               else if (j == nlevurb) then
+
+                  ! For urban sunwall, shadewall, and roof columns, there is a non-zero heat flux across
+                  ! the bottom "soil" layer and the equations are derived assuming a prescribed internal
+                  ! building temperature. (See Oleson urban notes of 6/18/03).
+                  tk(c,j) = thk(c,j)
+               end if
+            else if (col_pp%itype(c) /= icol_sunwall .and. col_pp%itype(c) /= icol_shadewall &
+                 .and. col_pp%itype(c) /= icol_roof) then
+               if (j >= snl(c)+1 .AND. j <= nlevgrnd-1) then
+                  tk(c,j) = thk(c,j)*thk(c,j+1)*(z(c,j+1)-z(c,j)) &
+                       /(thk(c,j)*(z(c,j+1)-zi(c,j))+thk(c,j+1)*(zi(c,j)-z(c,j)))
+               else if (j == nlevgrnd) then
+                  tk(c,j) = 0._r8
+               end if
+            end if
+         end do
+      end do
+
+      ! calculate thermal conductivity of h2osfc
+      do fc = 1, num_nolakec
+         c = filter_nolakec(fc)
+         zh2osfc=1.0e-3*(0.5*h2osfc(c)) !convert to [m] from [mm]
+         tk_h2osfc(c)= tkwat*thk(c,1)*(z(c,1)+zh2osfc) &
+              /(tkwat*z(c,1)+thk(c,1)*zh2osfc)
+      enddo
+
+      ! Soil heat capacity, from de Vires (1963)
+      ! Urban values are from Masson et al. 2002, Evaluation of the Town Energy Balance (TEB)
+      ! scheme with direct measurements from dry districts in two cities, J. Appl. Meteorol.,
+      ! 41, 1011-1026.
+
+      do j = 1, nlevgrnd
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            l = col_pp%landunit(c)
+            nlevbed = nlev2bed(c)
+            if ((col_pp%itype(c) == icol_sunwall .OR. col_pp%itype(c) == icol_shadewall) .and. j <= nlevurb) then
+               cv(c,j) = cv_wall(l,j) * dz(c,j)
+            else if (col_pp%itype(c) == icol_roof .and. j <= nlevurb) then
+               cv(c,j) = cv_roof(l,j) * dz(c,j)
+            else if (col_pp%itype(c) == icol_road_imperv .and. j >= 1 .and. j <= nlev_improad(l)) then
+               cv(c,j) = cv_improad(l,j) * dz(c,j)
+            else if (lun_pp%itype(l) /= istwet .AND. lun_pp%itype(l) /= istice .AND. lun_pp%itype(l) /= istice_mec &
+                 .AND. col_pp%itype(c) /= icol_sunwall .AND. col_pp%itype(c) /= icol_shadewall .AND. &
+                 col_pp%itype(c) /= icol_roof) then
+               cv(c,j) = csol(c,j)*(1._r8-watsat(c,j))*dz(c,j) + (h2osoi_ice(c,j)*cpice + h2osoi_liq(c,j)*cpliq)
+            else if (lun_pp%itype(l) == istwet) then
+               cv(c,j) = (h2osoi_ice(c,j)*cpice + h2osoi_liq(c,j)*cpliq)
+               if (j > nlevbed) cv(c,j) = csol(c,j)*dz(c,j)
+            else if (lun_pp%itype(l) == istice .OR. lun_pp%itype(l) == istice_mec) then
+               cv(c,j) = (h2osoi_ice(c,j)*cpice + h2osoi_liq(c,j)*cpliq)
+            endif
+            if (j == 1) then
+               if (snl(c)+1 == 1 .AND. h2osno(c) > 0._r8) then
+                  cv(c,j) = cv(c,j) + cpice*h2osno(c)
+               end if
+            end if
+         enddo
+      end do
+
+      ! Snow heat capacity
+
+      do j = -nlevsno+1,0
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            if (snl(c)+1 < 1 .and. j >= snl(c)+1) then
+               if (frac_sno(c) > 0._r8) then
+                  cv(c,j) = max(thin_sfclayer, (cpliq*h2osoi_liq(c,j) + cpice*h2osoi_ice(c,j))/frac_sno(c))
+               else
+                  cv(c,j) = thin_sfclayer
+               end if
+            end if
+         end do
+      end do
+      call t_stop_lnd( event )
+
+    end associate
+
+  end subroutine SoilThermProp
+
   !-----------------------------------------------------------------------
   subroutine PhaseChangeH2osfc (bounds, num_nolakec, filter_nolakec, &
-       dhsdT, dtime)
+       dhsdT, energyflux_vars, dtime)
     !
     ! !DESCRIPTION:
     ! Only freezing is considered.  When water freezes, move ice to bottom snow layer.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon       , only : tfrz, hfus, grav, denice, cnfac, cpice, cpliq
     use elm_varpar       , only : nlevsno, nlevgrnd
     use elm_varctl       , only : iulog
@@ -1110,17 +1063,18 @@ end subroutine SoilThermProp
     integer                , intent(in)    :: num_nolakec                          ! number of column non-lake points in column filter
     integer                , intent(in)    :: filter_nolakec(:)                    ! column filter for non-lake points
     real(r8)               , intent(in)    :: dhsdT ( bounds%begc: )               ! temperature derivative of "hs" [col               ]
+    type(energyflux_type)  , intent(inout) :: energyflux_vars
     real(r8), intent(in) :: dtime                       !land model time step (sec)
 
     !
     ! !LOCAL VARIABLES:
-    integer  :: j,c,g      !do loop index
-    integer  :: fc         !lake filtered column indices
-    real(r8) :: temp1      !temporary variables [kg/m2                    ]
-    real(r8) :: hm         !energy residual [W/m2                         ]
-    real(r8) :: xm         !melting or freezing within a time step [kg/m2 ]
-    real(r8) :: tinc       !t(n+1)-t(n) (K)
-    real(r8) :: smp        !frozen water potential (mm)
+    integer  :: j,c,g                       !do loop index
+    integer  :: fc                          !lake filtered column indices
+    real(r8) :: temp1                       !temporary variables [kg/m2                    ]
+    real(r8) :: hm(bounds%begc:bounds%endc) !energy residual [W/m2                         ]
+    real(r8) :: xm(bounds%begc:bounds%endc) !melting or freezing within a time step [kg/m2 ]
+    real(r8) :: tinc                        !t(n+1)-t(n) (K)
+    real(r8) :: smp                         !frozen water potential (mm)
     real(r8) :: rho_avg
     real(r8) :: z_avg
     real(r8) :: c1
@@ -1156,27 +1110,33 @@ end subroutine SoilThermProp
 
       ! Get step size
 
-      ! Freezing identification
-      !$acc parallel loop independent gang vector default(present)
+      ! Initialization
+
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
-         
+
          xmf_h2osfc(c)              = 0._r8
-         hm                         = 0._r8
-         xm                         = 0._r8
+         hm(c)                      = 0._r8
+         xm(c)                      = 0._r8
          qflx_h2osfc_to_ice(c)      = 0._r8
          eflx_h2osfc_to_snow_col(c) = 0._r8
+      end do
+
+      ! Freezing identification
+      do fc = 1,num_nolakec
+         c = filter_nolakec(fc)
+
          ! If liquid exists below melt point, freeze some to ice.
          if ( frac_h2osfc(c) > 0._r8 .AND. t_h2osfc(c) <= tfrz) then
             tinc = tfrz - t_h2osfc(c)
             t_h2osfc(c) = tfrz
 
             ! energy absorbed beyond freezing temperature
-            hm = frac_h2osfc(c)*(dhsdT(c)*tinc - tinc*c_h2osfc(c)/dtime)
+            hm(c) = frac_h2osfc(c)*(dhsdT(c)*tinc - tinc*c_h2osfc(c)/dtime)
 
             ! mass of water converted from liquid to ice
-            xm = hm*dtime/hfus
-            temp1 = h2osfc(c) + xm
+            xm(c) = hm(c)*dtime/hfus
+            temp1 = h2osfc(c) + xm(c)
 
             z_avg=frac_sno(c)*snow_depth(c)
             if (z_avg > 0._r8) then
@@ -1189,16 +1149,16 @@ end subroutine SoilThermProp
             if(temp1 >= 0._r8) then ! add some frozen water to snow column
 
                ! add ice to snow column
-               h2osno(c) = h2osno(c) - xm
-               int_snow(c) = int_snow(c) - xm
+               h2osno(c) = h2osno(c) - xm(c)
+               int_snow(c) = int_snow(c) - xm(c)
 
-               if(snl(c) < 0) h2osoi_ice(c,0) = h2osoi_ice(c,0) - xm
+               if(snl(c) < 0) h2osoi_ice(c,0) = h2osoi_ice(c,0) - xm(c)
 
                ! remove ice from h2osfc
-               h2osfc(c) = h2osfc(c) + xm
+               h2osfc(c) = h2osfc(c) + xm(c)
 
-               xmf_h2osfc(c) = hm
-               qflx_h2osfc_to_ice(c) = -xm/dtime
+               xmf_h2osfc(c) = hm(c)
+               qflx_h2osfc_to_ice(c) = -xm(c)/dtime
 
                ! update snow depth
                if (frac_sno(c) > 0 .and. snl(c) < 0) then
@@ -1219,7 +1179,7 @@ end subroutine SoilThermProp
                      c1=frac_sno(c)/fact(c,0)*dtime
                   end if
                   if ( frac_h2osfc(c) /= 0.0_r8 )then
-                     c2=(-cpliq*xm - frac_h2osfc(c)*dhsdT(c)*dtime)
+                     c2=(-cpliq*xm(c) - frac_h2osfc(c)*dhsdT(c)*dtime)
                   else
                      c2=0.0_r8
                   end if
@@ -1248,7 +1208,7 @@ end subroutine SoilThermProp
                ! cool frozen h2osfc layer with extra heat
                t_h2osfc(c) = t_h2osfc(c) - temp1*hfus/(dtime*dhsdT(c) - c_h2osfc(c))
 
-               xmf_h2osfc(c) = (hm - frac_h2osfc(c)*temp1*hfus/dtime)
+               xmf_h2osfc(c) = (hm(c) - frac_h2osfc(c)*temp1*hfus/dtime)
 
                ! next, determine equilibrium temperature of combined ice/snow layer
                if (snl(c) == 0) then
@@ -1290,7 +1250,7 @@ end subroutine SoilThermProp
                endif
 
             endif
-         endif          
+         endif
       enddo
       call t_stop_lnd( event )
 
@@ -1298,415 +1258,402 @@ end subroutine SoilThermProp
 
   end subroutine PhaseChangeH2osfc
 
-
-!-----------------------------------------------------------------------
+  !-----------------------------------------------------------------------
   subroutine Phasechange_beta (bounds, num_nolakec, filter_nolakec, dhsdT, &
-   soilstate_vars, dtime)
-!
-! !DESCRIPTION:
-! Calculation of the phase change within snow and soil layers:
-! (1) Check the conditions for which the phase change may take place,
-!     i.e., the layer temperature is great than the freezing point
-!     and the ice mass is not equal to zero (i.e. melting),
-!     or the layer temperature is less than the freezing point
-!     and the liquid water mass is greater than the allowable supercooled
-!     liquid water calculated from freezing point depression (i.e. freezing).
-! (2) Assess the rate of phase change from the energy excess (or deficit)
-!     after setting the layer temperature to freezing point.
-! (3) Re-adjust the ice and liquid mass, and the layer temperature
-!
-! !USES:
-use elm_varpar       , only : nlevsno, nlevgrnd,nlevurb
-use elm_varctl       , only : iulog
-use elm_varcon       , only : tfrz, hfus, grav
-use column_varcon    , only : icol_roof, icol_sunwall, icol_shadewall, icol_road_perv
-use landunit_varcon  , only : istsoil, istcrop, istice_mec
-!
-! !ARGUMENTS:
-type(bounds_type)      , intent(in)    :: bounds
-integer                , intent(in)    :: num_nolakec             ! number of column non-lake points in column filter
-integer                , intent(in)    :: filter_nolakec(:)       ! column filter for non-lake points
-real(r8)               , intent(in)    :: dhsdT ( bounds%begc: )  ! temperature derivative of "hs" [col]
-type(soilstate_type)   , intent(in)    :: soilstate_vars
-real(r8), intent(in) :: dtime            !land model time step (sec)
-
-!
-! !LOCAL VARIABLES:
-integer  :: j,c,g,l                            !do loop index
-integer  :: fc                                 !lake filtered column indices
-real(r8) :: heatr                              !energy residual or loss after melting or freezing
-real(r8) :: temp1                              !temporary variables [kg/m2]
-real(r8) :: hm     !energy residual [W/m2]
-real(r8) :: xm     !melting or freezing within a time step [kg/m2]
-real(r8) :: wmass0 !initial mass of ice and liquid (kg/m2)
-real(r8) :: wice0  !initial mass of ice (kg/m2)
-real(r8) :: supercool(num_nolakec,nlevgrnd)    !supercooled water in soil (kg/m2)
-real(r8) :: propor                             !proportionality constant (-)
-real(r8) :: tinc(num_nolakec,-nlevsno+1:nlevgrnd)  !t(n+1)-t(n) (K)
-real(r8) :: smp                                !frozen water potential (mm)
-real(r8) :: sum1,sum2 
-character(len=64) :: event 
-!-----------------------------------------------------------------------
-event = 'PhaseChangebeta'
-call t_start_lnd( event )
-
-associate(                                                        &
-     snl              =>    col_pp%snl                             , & ! Input:  [integer  (:)   ] number of snow layers
-     dz               =>    col_pp%dz                              , & ! Input:  [real(r8) (:,:) ] layer thickness (m)
-
-     bsw              =>    soilstate_vars%bsw_col              , & ! Input:  [real(r8) (:,:) ] Clapp and Hornberger "b"
-     sucsat           =>    soilstate_vars%sucsat_col           , & ! Input:  [real(r8) (:,:) ] minimum soil suction (mm)
-     watsat           =>    soilstate_vars%watsat_col           , & ! Input:  [real(r8) (:,:) ] volumetric soil water at saturation (porosity)
-
-     frac_sno_eff     =>    col_ws%frac_sno_eff    , & ! Input:  [real(r8) (:)   ] eff. fraction of ground covered by snow (0 to 1)
-     frac_sno         =>    col_ws%frac_sno        , & ! Input:  [real(r8) (:)   ] fraction of ground covered by snow (0 to 1)
-     frac_h2osfc      =>    col_ws%frac_h2osfc     , & ! Input:  [real(r8) (:)   ] fraction of ground covered by surface water (0 to 1)
-     snow_depth       =>    col_ws%snow_depth      , & ! Input:  [real(r8) (:)   ] snow height (m)
-     h2osno           =>    col_ws%h2osno          , & ! Output: [real(r8) (:)   ] snow water (mm H2O)
-     h2osoi_liq       =>    col_ws%h2osoi_liq      , & ! Output: [real(r8) (:,:) ] liquid water (kg/m2) (new)
-     h2osoi_ice       =>    col_ws%h2osoi_ice      , & ! Output: [real(r8) (:,:) ] ice lens (kg/m2) (new)
-
-     qflx_snow_melt   =>    col_wf%qflx_snow_melt   , & ! Output: [real(r8) (:)   ] net snow melt
-     qflx_snofrz_lyr  =>    col_wf%qflx_snofrz_lyr  , & ! Output: [real(r8) (:,:) ] snow freezing rate (positive definite) (col,lyr) [kg m-2 s-1]
-     qflx_snofrz_col  =>    col_wf%qflx_snofrz      , & ! Output: [real(r8) (:)   ] column-integrated snow freezing rate (positive definite) [kg m-2 s-1]
-     qflx_glcice      =>    col_wf%qflx_glcice      , & ! Output: [real(r8) (:)   ] flux of new glacier ice (mm H2O/s) [+ = ice grows]
-     qflx_glcice_melt =>    col_wf%qflx_glcice_melt , & ! Output: [real(r8) (:)   ] ice melt (positive definite) (mm H2O/s)
-     qflx_snomelt     =>    col_wf%qflx_snomelt     , & ! Output: [real(r8) (:)   ] snow melt (mm H2O /s)
-
-     eflx_snomelt     =>    col_ef%eflx_snomelt    , & ! Output: [real(r8) (:)   ] snow melt heat flux (W/m**2)
-     eflx_snomelt_r   =>    col_ef%eflx_snomelt_r  , & ! Output: [real(r8) (:)   ] rural snow melt heat flux (W/m**2)
-     eflx_snomelt_u   =>    col_ef%eflx_snomelt_u  , & ! Output: [real(r8) (:)   ] urban snow melt heat flux (W/m**2)
-
-     xmf              =>    col_ef%xmf            , &
-     fact             =>    col_es%fact           , &
-
-     imelt            =>    col_ef%imelt          , & ! Output: [integer  (:,:) ] flag for melting (=1), freezing (=2), Not=0 (new)
-     t_soisno         =>    col_es%t_soisno         & ! Output: [real(r8) (:,:) ] soil temperature (Kelvin)
-     )
-
-  ! Initialization
-  !$acc enter data create(supercool(:,:), tinc(:,:),sum1,sum2) 
-
-  !$acc parallel loop independent gang vector default(present) present(xmf(:))  
-  do fc = 1,num_nolakec
-     c = filter_nolakec(fc)
-     l = col_pp%landunit(c)
-
-     qflx_snomelt(c) = 0._r8
-     xmf(c) = 0._r8
-     qflx_snofrz_col(c) = 0._r8
-     qflx_glcice_melt(c) = 0._r8
-     qflx_snow_melt(c) = 0._r8
-  end do
-  
-  !$acc parallel loop independent gang vector collapse(2) default(present) 
-  do j = -nlevsno+1,nlevgrnd       ! all layers
-     do fc = 1,num_nolakec
-        c = filter_nolakec(fc)
-        if (j >= snl(c)+1) then
-           imelt(c,j) = 0
-        endif   ! end of snow layer if-block
-     end do   ! end of column-loop
-  enddo   ! end of level-loop
-
-  !--  snow layers  ---------------------------------------------------
-  !$acc parallel loop independent collapse(2) gang vector default(present) 
-  do j = -nlevsno+1,0
-     do fc = 1,num_nolakec
-        c = filter_nolakec(fc)
-        qflx_snofrz_lyr(c,j) = 0._r8
-
-        if (j >= snl(c)+1) then
-           ! Melting identification
-           ! If ice exists above melt point, melt some to liquid.
-           if (h2osoi_ice(c,j) > 0._r8 .AND. t_soisno(c,j) > tfrz) then
-              imelt(c,j) = 1
-              !                tinc(c,j) = t_soisno(c,j) - tfrz
-              tinc(fc,j) = tfrz - t_soisno(c,j)
-              t_soisno(c,j) = tfrz
-           endif
-
-           ! Freezing identification
-           ! If liquid exists below melt point, freeze some to ice.
-           if (h2osoi_liq(c,j) > 0._r8 .AND. t_soisno(c,j) < tfrz) then
-              imelt(c,j) = 2
-              !                tinc(c,j) = t_soisno(c,j) - tfrz
-              tinc(fc,j) = tfrz - t_soisno(c,j)
-              t_soisno(c,j) = tfrz
-           endif
-        endif   ! end of snow layer if-block
-     end do   ! end of column-loop
-  enddo   ! end of level-loop
-
-  !-- soil layers   ---------------------------------------------------
-  !$acc parallel loop independent gang vector collapse(2) default(present) 
-  do j = 1,nlevgrnd
-     do fc = 1,num_nolakec
-        c = filter_nolakec(fc)
-        l = col_pp%landunit(c)
-        supercool(fc,j) = 0.0_r8
-        ! add in urban condition if-block
-        if ((col_pp%itype(c) /= icol_sunwall .and. col_pp%itype(c) /= icol_shadewall &
-             .and. col_pp%itype(c) /= icol_roof) .or. ( j <= nlevurb)) then
-
-           if (h2osoi_ice(c,j) > 0. .AND. t_soisno(c,j) > tfrz) then
-              imelt(c,j) = 1
-              !             tinc(c,j) = t_soisno(c,j) - tfrz
-              tinc(fc,j) = tfrz - t_soisno(c,j)
-              t_soisno(c,j) = tfrz
-           endif
-
-           ! from Zhao (1997) and Koren (1999)
-           supercool(fc,j) = 0.0_r8
-           if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop .or. col_pp%itype(c) == icol_road_perv) then
-              if(t_soisno(c,j) < tfrz) then
-                 smp = hfus*(tfrz-t_soisno(c,j))/(grav*t_soisno(c,j)) * 1000._r8  !(mm)
-                 supercool(fc,j) = watsat(c,j)*(smp/sucsat(c,j))**(-1._r8/bsw(c,j))
-                 supercool(fc,j) = supercool(fc,j)*dz(c,j)*1000._r8       ! (mm)
-              endif
-           endif
-
-           if (h2osoi_liq(c,j) > supercool(fc,j) .AND. t_soisno(c,j) < tfrz) then
-              imelt(c,j) = 2
-              !             tinc(c,j) = t_soisno(c,j) - tfrz
-              tinc(fc,j) = tfrz - t_soisno(c,j)
-              t_soisno(c,j) = tfrz
-           endif
-
-           ! If snow exists, but its thickness is less than the critical value (0.01 m)
-           if (snl(c)+1 == 1 .AND. h2osno(c) > 0._r8 .AND. j == 1) then
-              if (t_soisno(c,j) > tfrz) then
-                 imelt(c,j) = 1
-                 !                tincc,j) = t_soisno(c,j) - tfrz
-                 tinc(fc,j) = tfrz - t_soisno(c,j)
-                 t_soisno(c,j) = tfrz
-              endif
-           endif
-
-        endif
-
-     end do
-  enddo
-  
-  !$acc parallel loop independent gang worker default(present)  present(tinc(:,:), xmf(:) ) private(sum1,sum2)  
-  do fc = 1,num_nolakec
-    c = filter_nolakec(fc)
-    sum1 = 0._r8 
-    sum2 = 0._r8 
-    !$acc loop vector reduction(+:sum1, sum2) 
-    do j = -nlevsno+1,nlevgrnd       ! all layers
-        hm = 0.0_r8 
-        xm = 0.0_r8
-        wmass0 = h2osoi_ice(c,j) + h2osoi_liq(c,j)
-        wice0  = h2osoi_ice(c,j)
-        if ((col_pp%itype(c) /= icol_sunwall .and. col_pp%itype(c) /= icol_shadewall &
-             .and. col_pp%itype(c) /= icol_roof) .or. ( j <= nlevurb)) then
-
-           if (j >= snl(c)+1) then
-
-              ! Calculate the energy surplus and loss for melting and freezing
-              if (imelt(c,j) > 0) then
-
-                 ! added unique cases for this calculation,
-                 ! to account for absorbed solar radiation in each layer
-                 !==================================================================
-                 if (j == snl(c)+1) then ! top layer
-                    if(j > 0) then
-                       hm = dhsdT(c)*tinc(fc,j) - tinc(fc,j)/fact(c,j)
-                    else
-                       hm = frac_sno_eff(c)*(dhsdT(c)*tinc(fc,j) - tinc(fc,j)/fact(c,j))
-                    endif
-
-                    if ( j==1 .and. frac_h2osfc(c) /= 0.0_r8 ) then
-                       hm = hm - frac_h2osfc(c)*(dhsdT(c)*tinc(fc,j))
-                    end if
-                 else if (j == 1) then
-                    hm = (1.0_r8 - frac_sno_eff(c) - frac_h2osfc(c)) &
-                         *dhsdT(c)*tinc(fc,j) - tinc(fc,j)/fact(c,j)
-                 else ! non-interfacial snow/soil layers
-                    if(j < 1) then
-                       hm = - frac_sno_eff(c)*(tinc(fc,j)/fact(c,j))
-                    else
-                       hm = - tinc(fc,j)/fact(c,j)
-                    endif
-                 endif
-              endif
-              ! These two errors were checked carefully (Y. Dai).  They result from the
-              ! computed error of "Tridiagonal-Matrix" in subroutine "thermal".
-              if (imelt(c,j) == 1 .AND. hm < 0._r8) then
-                 hm = 0._r8
-                 imelt(c,j) = 0
-              endif
-              if (imelt(c,j) == 2 .AND. hm > 0._r8) then
-                 hm = 0._r8
-                 imelt(c,j) = 0
-              endif
-
-              ! The rate of melting and freezing
-              if (imelt(c,j) > 0 .and. abs(hm) > 0._r8) then
-                 xm = hm * dtime/hfus       ! kg/m2
-
-                 ! If snow exists, but its thickness is less than the critical value
-                 ! (1 cm). Note: more work is needed to determine how to tune the
-                 ! snow depth for this case
-                 if (j == 1) then
-                    if (snl(c)+1 == 1 .AND. h2osno(c) > 0._r8 .AND. xm > 0._r8) then
-                       temp1 = h2osno(c)                           ! kg/m2
-                       h2osno(c) = max(0._r8,temp1-xm)
-                       propor = h2osno(c)/temp1
-                       snow_depth(c) = propor * snow_depth(c)
-                       heatr = hm - hfus*(temp1-h2osno(c))/dtime   ! W/m2
-                       if (heatr > 0._r8) then
-                          xm = heatr*dtime/hfus                    ! kg/m2
-                          hm = heatr                               ! W/m2
-                       else
-                          xm = 0._r8
-                          hm = 0._r8
-                       endif
-                       qflx_snomelt(c) = max(0._r8,(temp1-h2osno(c)))/dtime   ! kg/(m2 s)
-                       xmf(c) = hfus*qflx_snomelt(c)
-                       qflx_snow_melt(c) = qflx_snomelt(c)
-                    endif
-                 endif
-                 heatr = 0._r8
-                 if (xm > 0._r8) then
-                    h2osoi_ice(c,j) = max(0._r8, wice0-xm)
-                    heatr = hm - hfus*(wice0-h2osoi_ice(c,j))/dtime
-                 else if (xm < 0._r8) then
-                    if (j <= 0) then
-                       h2osoi_ice(c,j) = min(wmass0, wice0-xm)  ! snow
-                    else
-                       if (wmass0 < supercool(fc,j)) then
-                          h2osoi_ice(c,j) = 0._r8
-                       else
-                          h2osoi_ice(c,j) = min(wmass0 - supercool(fc,j),wice0 - xm)
-                       endif
-                    endif
-                    heatr = hm - hfus*(wice0 - h2osoi_ice(c,j))/dtime
-                 endif
-
-                 h2osoi_liq(c,j) = max(0._r8,wmass0 - h2osoi_ice(c,j))
-
-                 if (abs(heatr) > 0._r8) then
-                    if (j == snl(c)+1) then
-
-                       if(j==1) then
-                          t_soisno(c,j) = t_soisno(c,j) + fact(c,j)*heatr &
-                               /(1._r8-(1.0_r8 - frac_h2osfc(c))*fact(c,j)*dhsdT(c))
-                       else
-                          t_soisno(c,j) = t_soisno(c,j) + (fact(c,j)/frac_sno_eff(c))*heatr &
-                               /(1._r8-fact(c,j)*dhsdT(c))
-                       endif
-
-                    else if (j == 1) then
-
-                       t_soisno(c,j) = t_soisno(c,j) + fact(c,j)*heatr &
-                            /(1._r8-(1.0_r8 - frac_sno_eff(c) - frac_h2osfc(c))*fact(c,j)*dhsdT(c))
-                    else
-                       if(j > 0) then
-                          t_soisno(c,j) = t_soisno(c,j) + fact(c,j)*heatr
-                       else
-                          if(frac_sno_eff(c) > 0._r8) t_soisno(c,j) = t_soisno(c,j) + (fact(c,j)/frac_sno_eff(c))*heatr
-                       endif
-                    endif
-
-                    if (j <= 0) then    ! snow
-                       if (h2osoi_liq(c,j)*h2osoi_ice(c,j)>0._r8) t_soisno(c,j) = tfrz
-                    end if
-                 endif  ! end of heatr > 0 if-block
-
-                 !NOTE is this a bug or just redundant ?
-                 ! if (j >= 1) then
-                 !    xmf(c) = xmf(c) + hfus*(wice0 - h2osoi_ice(c,j))/dtime
-                 ! else
-                 !    xmf(c) = xmf(c) + hfus*(wice0 - h2osoi_ice(c,j))/dtime
-                 ! endif
-                 
-                 !xmf(c) = xmf(c) + hfus*(wice0 - h2osoi_ice(c,j))/dtime
-                 sum1 = sum1 +  hfus*(wice0 - h2osoi_ice(c,j))/dtime
-                 if (imelt(c,j) == 1 .AND. j < 1) then
-                   ! qflx_snomelt(c) = qflx_snomelt(c) + max(0._r8,(wice0 - h2osoi_ice(c,j)))/dtime
-                   sum2 = sum2 + max(0._r8,(wice0 - h2osoi_ice(c,j)))/dtime
-                 endif
-
-                 ! layer freezing mass flux (positive):
-                 if (imelt(c,j) == 2 .AND. j < 1) then
-                    qflx_snofrz_lyr(c,j) = max(0._r8,(h2osoi_ice(c,j)-wice0 ))/dtime
-                 endif
-              endif
-           endif   ! end of snow layer if-block
-        endif
-     end do   ! end of level-loop
-     xmf(c) = xmf(c) + sum1 
-     qflx_snomelt(c) = qflx_snomelt(c) + sum2
-  enddo   ! end of col-loop
-  
-  ! For glacier_mec columns, compute negative ice flux from melted ice.
-  ! Note that qflx_glcice can also include a positive component from excess snow,
-  ! as computed in HydrologyDrainageMod.F90.
-  !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-  do fc = 1,num_nolakec
-     c = filter_nolakec(fc)
-     l = col_pp%landunit(c)
-     sum1 = 0.0_r8 
-     sum2 = 0.0_r8
-     !$acc loop vector reduction(+:sum1,sum2)
-     do j = -nlevsno+1,nlevgrnd       ! all layers
-        if (lun_pp%itype(l)==istice_mec) then
-           if (j>=1 .and. h2osoi_liq(c,j) > 0._r8) then   ! ice layer with meltwater
-              ! melting corresponds to a negative ice flux
-              sum1 = sum1 + h2osoi_liq(c,j)/dtime
-              sum2 = sum2 - h2osoi_liq(c,j)/dtime
-
-              ! convert layer back to pure ice by "borrowing" ice from below the column
-              h2osoi_ice(c,j) = h2osoi_ice(c,j) + h2osoi_liq(c,j)
-              h2osoi_liq(c,j) = 0._r8
-
-           endif  ! liquid water is present
-        endif     ! istice_mec
-     enddo   ! end of level-loop
-     qflx_glcice_melt(c) = qflx_glcice_melt(c) + sum1
-     qflx_glcice(c) = qflx_glcice(c) + sum2 
-  end do   ! end of column-loop
-
-  ! Needed for history file output
-
-  !$acc parallel loop independent gang vector default(present) 
-  do fc = 1,num_nolakec
-     c = filter_nolakec(fc)
-     eflx_snomelt(c) = qflx_snomelt(c) * hfus
-     l = col_pp%landunit(c)
-     if (lun_pp%urbpoi(l)) then
-        eflx_snomelt_u(c) = eflx_snomelt(c)
-     else if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-        eflx_snomelt_r(c) = eflx_snomelt(c)
-     end if
-  end do
-
-  call t_stop_lnd( event )
-  !$acc parallel loop independent gang worker default(present) private(sum1) 
-  do fc = 1,num_nolakec   
-     c = filter_nolakec(fc)
-     sum1 = 0.0_r8 
-     !$acc loop vector reduction(+:sum1)
-     do j = -nlevsno+1,0
-        sum1 = sum1 + qflx_snofrz_lyr(c,j)
-     end do
-     qflx_snofrz_col(c) = qflx_snofrz_col(c) + sum1 
-  end do
-
-  !$acc exit data delete(supercool(:,:), tinc(:,:), sum1,sum2 ) 
-
-end associate
-
-end subroutine Phasechange_beta
+       soilstate_vars, energyflux_vars, dtime)
+    !
+    ! !DESCRIPTION:
+    ! Calculation of the phase change within snow and soil layers:
+    ! (1) Check the conditions for which the phase change may take place,
+    !     i.e., the layer temperature is great than the freezing point
+    !     and the ice mass is not equal to zero (i.e. melting),
+    !     or the layer temperature is less than the freezing point
+    !     and the liquid water mass is greater than the allowable supercooled
+    !     liquid water calculated from freezing point depression (i.e. freezing).
+    ! (2) Assess the rate of phase change from the energy excess (or deficit)
+    !     after setting the layer temperature to freezing point.
+    ! (3) Re-adjust the ice and liquid mass, and the layer temperature
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varpar       , only : nlevsno, nlevgrnd,nlevurb
+    use elm_varctl       , only : iulog
+    use elm_varcon       , only : tfrz, hfus, grav
+    use column_varcon    , only : icol_roof, icol_sunwall, icol_shadewall, icol_road_perv
+    use landunit_varcon  , only : istsoil, istcrop, istice_mec
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)      , intent(in)    :: bounds
+    integer                , intent(in)    :: num_nolakec             ! number of column non-lake points in column filter
+    integer                , intent(in)    :: filter_nolakec(:)       ! column filter for non-lake points
+    real(r8)               , intent(in)    :: dhsdT ( bounds%begc: )  ! temperature derivative of "hs" [col]
+    type(soilstate_type)   , intent(in)    :: soilstate_vars
+    type(energyflux_type)  , intent(inout) :: energyflux_vars
+    real(r8), intent(in) :: dtime            !land model time step (sec)
+
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,g,l                            !do loop index
+    integer  :: fc                                 !lake filtered column indices
+    real(r8) :: heatr                              !energy residual or loss after melting or freezing
+    real(r8) :: temp1                              !temporary variables [kg/m2]
+    real(r8) :: hm(bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)    !energy residual [W/m2]
+    real(r8) :: xm(bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)    !melting or freezing within a time step [kg/m2]
+    real(r8) :: wmass0(bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)!initial mass of ice and liquid (kg/m2)
+    real(r8) :: wice0 (bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)!initial mass of ice (kg/m2)
+    real(r8) :: wliq0 (bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)!initial mass of liquid (kg/m2)
+    real(r8) :: supercool(bounds%begc:bounds%endc,nlevgrnd)        !supercooled water in soil (kg/m2)
+    real(r8) :: propor                             !proportionality constant (-)
+    real(r8) :: tinc(bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)  !t(n+1)-t(n) (K)
+    real(r8) :: smp                                !frozen water potential (mm)
+    
+    character(len=64) :: event 
+    !-----------------------------------------------------------------------
+    event = 'PhaseChangebeta'
+    call t_start_lnd( event )
+
+    associate(                                                        &
+         snl              =>    col_pp%snl                             , & ! Input:  [integer  (:)   ] number of snow layers
+         dz               =>    col_pp%dz                              , & ! Input:  [real(r8) (:,:) ] layer thickness (m)
+
+         bsw              =>    soilstate_vars%bsw_col              , & ! Input:  [real(r8) (:,:) ] Clapp and Hornberger "b"
+         sucsat           =>    soilstate_vars%sucsat_col           , & ! Input:  [real(r8) (:,:) ] minimum soil suction (mm)
+         watsat           =>    soilstate_vars%watsat_col           , & ! Input:  [real(r8) (:,:) ] volumetric soil water at saturation (porosity)
+
+         frac_sno_eff     =>    col_ws%frac_sno_eff    , & ! Input:  [real(r8) (:)   ] eff. fraction of ground covered by snow (0 to 1)
+         frac_sno         =>    col_ws%frac_sno        , & ! Input:  [real(r8) (:)   ] fraction of ground covered by snow (0 to 1)
+         frac_h2osfc      =>    col_ws%frac_h2osfc     , & ! Input:  [real(r8) (:)   ] fraction of ground covered by surface water (0 to 1)
+         snow_depth       =>    col_ws%snow_depth      , & ! Input:  [real(r8) (:)   ] snow height (m)
+         h2osno           =>    col_ws%h2osno          , & ! Output: [real(r8) (:)   ] snow water (mm H2O)
+         h2osoi_liq       =>    col_ws%h2osoi_liq      , & ! Output: [real(r8) (:,:) ] liquid water (kg/m2) (new)
+         h2osoi_ice       =>    col_ws%h2osoi_ice      , & ! Output: [real(r8) (:,:) ] ice lens (kg/m2) (new)
+
+         qflx_snow_melt   =>    col_wf%qflx_snow_melt   , & ! Output: [real(r8) (:)   ] net snow melt
+         qflx_snofrz_lyr  =>    col_wf%qflx_snofrz_lyr  , & ! Output: [real(r8) (:,:) ] snow freezing rate (positive definite) (col,lyr) [kg m-2 s-1]
+         qflx_snofrz_col  =>    col_wf%qflx_snofrz      , & ! Output: [real(r8) (:)   ] column-integrated snow freezing rate (positive definite) [kg m-2 s-1]
+         qflx_glcice      =>    col_wf%qflx_glcice      , & ! Output: [real(r8) (:)   ] flux of new glacier ice (mm H2O/s) [+ = ice grows]
+         qflx_glcice_melt =>    col_wf%qflx_glcice_melt , & ! Output: [real(r8) (:)   ] ice melt (positive definite) (mm H2O/s)
+         qflx_snomelt     =>    col_wf%qflx_snomelt     , & ! Output: [real(r8) (:)   ] snow melt (mm H2O /s)
+
+         eflx_snomelt     =>    col_ef%eflx_snomelt    , & ! Output: [real(r8) (:)   ] snow melt heat flux (W/m**2)
+         eflx_snomelt_r   =>    col_ef%eflx_snomelt_r  , & ! Output: [real(r8) (:)   ] rural snow melt heat flux (W/m**2)
+         eflx_snomelt_u   =>    col_ef%eflx_snomelt_u  , & ! Output: [real(r8) (:)   ] urban snow melt heat flux (W/m**2)
+
+         xmf              =>    col_ef%xmf            , &
+         fact             =>    col_es%fact                         , &
+
+         imelt            =>    col_ef%imelt          , & ! Output: [integer  (:,:) ] flag for melting (=1), freezing (=2), Not=0 (new)
+         t_soisno         =>    col_es%t_soisno         & ! Output: [real(r8) (:,:) ] soil temperature (Kelvin)
+         )
+
+      ! Initialization
+
+      do fc = 1,num_nolakec
+         c = filter_nolakec(fc)
+         l = col_pp%landunit(c)
+
+         qflx_snomelt(c) = 0._r8
+         xmf(c) = 0._r8
+         qflx_snofrz_lyr(c,-nlevsno+1:0) = 0._r8
+         qflx_snofrz_col(c) = 0._r8
+         qflx_glcice_melt(c) = 0._r8
+         qflx_snow_melt(c) = 0._r8
+      end do
+
+      do j = -nlevsno+1,nlevgrnd       ! all layers
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            if (j >= snl(c)+1) then
+
+               ! Initialization
+               imelt(c,j) = 0
+               hm(c,j) = 0._r8
+               xm(c,j) = 0._r8
+               wice0(c,j) = h2osoi_ice(c,j)
+               wliq0(c,j) = h2osoi_liq(c,j)
+               wmass0(c,j) = h2osoi_ice(c,j) + h2osoi_liq(c,j)
+            endif   ! end of snow layer if-block
+         end do   ! end of column-loop
+      enddo   ! end of level-loop
+
+      !--  snow layers  ---------------------------------------------------
+      do j = -nlevsno+1,0
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            if (j >= snl(c)+1) then
+
+               ! Melting identification
+               ! If ice exists above melt point, melt some to liquid.
+               if (h2osoi_ice(c,j) > 0._r8 .AND. t_soisno(c,j) > tfrz) then
+                  imelt(c,j) = 1
+                  !                tinc(c,j) = t_soisno(c,j) - tfrz
+                  tinc(c,j) = tfrz - t_soisno(c,j)
+                  t_soisno(c,j) = tfrz
+               endif
+
+               ! Freezing identification
+               ! If liquid exists below melt point, freeze some to ice.
+               if (h2osoi_liq(c,j) > 0._r8 .AND. t_soisno(c,j) < tfrz) then
+                  imelt(c,j) = 2
+                  !                tinc(c,j) = t_soisno(c,j) - tfrz
+                  tinc(c,j) = tfrz - t_soisno(c,j)
+                  t_soisno(c,j) = tfrz
+               endif
+            endif   ! end of snow layer if-block
+         end do   ! end of column-loop
+      enddo   ! end of level-loop
+
+      !-- soil layers   ---------------------------------------------------
+      do j = 1,nlevgrnd
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            l = col_pp%landunit(c)
+            supercool(c,j) = 0.0_r8
+            ! add in urban condition if-block
+            if ((col_pp%itype(c) /= icol_sunwall .and. col_pp%itype(c) /= icol_shadewall &
+                 .and. col_pp%itype(c) /= icol_roof) .or. ( j <= nlevurb)) then
+
+
+
+               if (h2osoi_ice(c,j) > 0. .AND. t_soisno(c,j) > tfrz) then
+                  imelt(c,j) = 1
+                  !             tinc(c,j) = t_soisno(c,j) - tfrz
+                  tinc(c,j) = tfrz - t_soisno(c,j)
+                  t_soisno(c,j) = tfrz
+               endif
+
+               ! from Zhao (1997) and Koren (1999)
+               supercool(c,j) = 0.0_r8
+               if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop .or. col_pp%itype(c) == icol_road_perv) then
+                  if(t_soisno(c,j) < tfrz) then
+                     smp = hfus*(tfrz-t_soisno(c,j))/(grav*t_soisno(c,j)) * 1000._r8  !(mm)
+                     supercool(c,j) = watsat(c,j)*(smp/sucsat(c,j))**(-1._r8/bsw(c,j))
+                     supercool(c,j) = supercool(c,j)*dz(c,j)*1000._r8       ! (mm)
+                  endif
+               endif
+
+               if (h2osoi_liq(c,j) > supercool(c,j) .AND. t_soisno(c,j) < tfrz) then
+                  imelt(c,j) = 2
+                  !             tinc(c,j) = t_soisno(c,j) - tfrz
+                  tinc(c,j) = tfrz - t_soisno(c,j)
+                  t_soisno(c,j) = tfrz
+               endif
+
+               ! If snow exists, but its thickness is less than the critical value (0.01 m)
+               if (snl(c)+1 == 1 .AND. h2osno(c) > 0._r8 .AND. j == 1) then
+                  if (t_soisno(c,j) > tfrz) then
+                     imelt(c,j) = 1
+                     !                tincc,j) = t_soisno(c,j) - tfrz
+                     tinc(c,j) = tfrz - t_soisno(c,j)
+                     t_soisno(c,j) = tfrz
+                  endif
+               endif
+
+            endif
+
+         end do
+      enddo
+
+
+      do j = -nlevsno+1,nlevgrnd       ! all layers
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
 
+            if ((col_pp%itype(c) /= icol_sunwall .and. col_pp%itype(c) /= icol_shadewall &
+                 .and. col_pp%itype(c) /= icol_roof) .or. ( j <= nlevurb)) then
+
+               if (j >= snl(c)+1) then
+
+                  ! Calculate the energy surplus and loss for melting and freezing
+                  if (imelt(c,j) > 0) then
+
+                     ! added unique cases for this calculation,
+                     ! to account for absorbed solar radiation in each layer
+
+                     !==================================================================
+                     if (j == snl(c)+1) then ! top layer
+                        if(j > 0) then
+                           hm(c,j) = dhsdT(c)*tinc(c,j) - tinc(c,j)/fact(c,j)
+                        else
+                           hm(c,j) = frac_sno_eff(c)*(dhsdT(c)*tinc(c,j) - tinc(c,j)/fact(c,j))
+                        endif
+
+                        if ( j==1 .and. frac_h2osfc(c) /= 0.0_r8 ) then
+                           hm(c,j) = hm(c,j) - frac_h2osfc(c)*(dhsdT(c)*tinc(c,j))
+                        end if
+                     else if (j == 1) then
+                        hm(c,j) = (1.0_r8 - frac_sno_eff(c) - frac_h2osfc(c)) &
+                             *dhsdT(c)*tinc(c,j) - tinc(c,j)/fact(c,j)
+                     else ! non-interfacial snow/soil layers
+                        if(j < 1) then
+                           hm(c,j) = - frac_sno_eff(c)*(tinc(c,j)/fact(c,j))
+                        else
+                           hm(c,j) = - tinc(c,j)/fact(c,j)
+                        endif
+                     endif
+                  endif
+
+                  ! These two errors were checked carefully (Y. Dai).  They result from the
+                  ! computed error of "Tridiagonal-Matrix" in subroutine "thermal".
+                  if (imelt(c,j) == 1 .AND. hm(c,j) < 0._r8) then
+                     hm(c,j) = 0._r8
+                     imelt(c,j) = 0
+                  endif
+                  if (imelt(c,j) == 2 .AND. hm(c,j) > 0._r8) then
+                     hm(c,j) = 0._r8
+                     imelt(c,j) = 0
+                  endif
+
+                  ! The rate of melting and freezing
+
+                  if (imelt(c,j) > 0 .and. abs(hm(c,j)) > 0._r8) then
+                     xm(c,j) = hm(c,j)*dtime/hfus                           ! kg/m2
+
+                     ! If snow exists, but its thickness is less than the critical value
+                     ! (1 cm). Note: more work is needed to determine how to tune the
+                     ! snow depth for this case
+                     if (j == 1) then
+                        if (snl(c)+1 == 1 .AND. h2osno(c) > 0._r8 .AND. xm(c,j) > 0._r8) then
+                           temp1 = h2osno(c)                           ! kg/m2
+                           h2osno(c) = max(0._r8,temp1-xm(c,j))
+                           propor = h2osno(c)/temp1
+                           snow_depth(c) = propor * snow_depth(c)
+                           heatr = hm(c,j) - hfus*(temp1-h2osno(c))/dtime   ! W/m2
+                           if (heatr > 0._r8) then
+                              xm(c,j) = heatr*dtime/hfus                    ! kg/m2
+                              hm(c,j) = heatr                               ! W/m2
+                           else
+                              xm(c,j) = 0._r8
+                              hm(c,j) = 0._r8
+                           endif
+                           qflx_snomelt(c) = max(0._r8,(temp1-h2osno(c)))/dtime   ! kg/(m2 s)
+                           xmf(c) = hfus*qflx_snomelt(c)
+                           qflx_snow_melt(c) = qflx_snomelt(c)
+                        endif
+                     endif
+
+                     heatr = 0._r8
+                     if (xm(c,j) > 0._r8) then
+                        h2osoi_ice(c,j) = max(0._r8, wice0(c,j)-xm(c,j))
+                        heatr = hm(c,j) - hfus*(wice0(c,j)-h2osoi_ice(c,j))/dtime
+                     else if (xm(c,j) < 0._r8) then
+                        if (j <= 0) then
+                           h2osoi_ice(c,j) = min(wmass0(c,j), wice0(c,j)-xm(c,j))  ! snow
+                        else
+                           if (wmass0(c,j) < supercool(c,j)) then
+                              h2osoi_ice(c,j) = 0._r8
+                           else
+                              h2osoi_ice(c,j) = min(wmass0(c,j) - supercool(c,j),wice0(c,j)-xm(c,j))
+                           endif
+                        endif
+                        heatr = hm(c,j) - hfus*(wice0(c,j)-h2osoi_ice(c,j))/dtime
+                     endif
+
+                     h2osoi_liq(c,j) = max(0._r8,wmass0(c,j)-h2osoi_ice(c,j))
+
+                     if (abs(heatr) > 0._r8) then
+                        if (j == snl(c)+1) then
+
+                           if(j==1) then
+                              t_soisno(c,j) = t_soisno(c,j) + fact(c,j)*heatr &
+                                   /(1._r8-(1.0_r8 - frac_h2osfc(c))*fact(c,j)*dhsdT(c))
+                           else
+                              t_soisno(c,j) = t_soisno(c,j) + (fact(c,j)/frac_sno_eff(c))*heatr &
+                                   /(1._r8-fact(c,j)*dhsdT(c))
+                           endif
+
+                        else if (j == 1) then
+
+                           t_soisno(c,j) = t_soisno(c,j) + fact(c,j)*heatr &
+                                /(1._r8-(1.0_r8 - frac_sno_eff(c) - frac_h2osfc(c))*fact(c,j)*dhsdT(c))
+                        else
+                           if(j > 0) then
+                              t_soisno(c,j) = t_soisno(c,j) + fact(c,j)*heatr
+                           else
+                              if(frac_sno_eff(c) > 0._r8) t_soisno(c,j) = t_soisno(c,j) + (fact(c,j)/frac_sno_eff(c))*heatr
+                           endif
+                        endif
+
+                        if (j <= 0) then    ! snow
+                           if (h2osoi_liq(c,j)*h2osoi_ice(c,j)>0._r8) t_soisno(c,j) = tfrz
+                        end if
+                     endif  ! end of heatr > 0 if-block
+
+                     if (j >= 1) then
+                        xmf(c) = xmf(c) + hfus*(wice0(c,j)-h2osoi_ice(c,j))/dtime
+                     else
+                        xmf(c) = xmf(c) + hfus*(wice0(c,j)-h2osoi_ice(c,j))/dtime
+                     endif
+
+                     if (imelt(c,j) == 1 .AND. j < 1) then
+                        qflx_snomelt(c) = qflx_snomelt(c) + max(0._r8,(wice0(c,j)-h2osoi_ice(c,j)))/dtime
+
+
+                     endif
+
+                     ! layer freezing mass flux (positive):
+                     if (imelt(c,j) == 2 .AND. j < 1) then
+                        qflx_snofrz_lyr(c,j) = max(0._r8,(h2osoi_ice(c,j)-wice0(c,j)))/dtime
+                     endif
+
+                  endif
+
+               endif   ! end of snow layer if-block
+
+            endif
+
+            ! For glacier_mec columns, compute negative ice flux from melted ice.
+            ! Note that qflx_glcice can also include a positive component from excess snow,
+            ! as computed in HydrologyDrainageMod.F90.
+
+            l = col_pp%landunit(c)
+            if (lun_pp%itype(l)==istice_mec) then
+
+               if (j>=1 .and. h2osoi_liq(c,j) > 0._r8) then   ! ice layer with meltwater
+                  ! melting corresponds to a negative ice flux
+                  qflx_glcice_melt(c) = qflx_glcice_melt(c) + h2osoi_liq(c,j)/dtime
+                  qflx_glcice(c) = qflx_glcice(c) - h2osoi_liq(c,j)/dtime
+
+                  ! convert layer back to pure ice by "borrowing" ice from below the column
+                  h2osoi_ice(c,j) = h2osoi_ice(c,j) + h2osoi_liq(c,j)
+                  h2osoi_liq(c,j) = 0._r8
+
+               endif  ! liquid water is present
+            endif     ! istice_mec
+
+         end do   ! end of column-loop
+      enddo   ! end of level-loop
+
+      ! Needed for history file output
+
+      do fc = 1,num_nolakec
+         c = filter_nolakec(fc)
+         eflx_snomelt(c) = qflx_snomelt(c) * hfus
+         l = col_pp%landunit(c)
+         if (lun_pp%urbpoi(l)) then
+            eflx_snomelt_u(c) = eflx_snomelt(c)
+         else if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
+            eflx_snomelt_r(c) = eflx_snomelt(c)
+         end if
+      end do
+
+      call t_stop_lnd( event )
+      do j = -nlevsno+1,0
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            qflx_snofrz_col(c) = qflx_snofrz_col(c) + qflx_snofrz_lyr(c,j)
+         end do
+      end do
+
+    end associate
+
+  end subroutine Phasechange_beta
 
   !-----------------------------------------------------------------------
   subroutine ComputeGroundHeatFluxAndDeriv(bounds, num_nolakec, filter_nolakec, &
        hs_h2osfc, hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, &
-       urbanparams_vars, canopystate_vars,  &
-       solarabs_vars)
+       atm2lnd_vars, urbanparams_vars, canopystate_vars,  &
+       solarabs_vars, energyflux_vars)
     !
     ! !DESCRIPTION:
     ! Computes ground heat flux on:
@@ -1717,6 +1664,7 @@ end subroutine Phasechange_beta
     ! Additionally, derivative of ground heat flux w.r.t to temeprature
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : sb, hvap
     use column_varcon  , only : icol_road_perv, icol_road_imperv
     use elm_varpar     , only : nlevsno, max_patch_per_col
@@ -1726,31 +1674,32 @@ end subroutine Phasechange_beta
     type(bounds_type)      , intent(in)    :: bounds                                    ! bounds
     integer                , intent(in)    :: num_nolakec                               ! number of column non-lake points in column filter
     integer                , intent(in)    :: filter_nolakec( : )                       ! column filter for non-lake points
-    real(r8)               , intent(inout)   :: hs_h2osfc( bounds%begc: )                 ! heat flux on standing water [W/m2]
-    real(r8)               , intent(inout)   :: hs_top_snow( bounds%begc: )               ! heat flux on top snow layer [W/m2]
-    real(r8)               , intent(inout)   :: hs_soil( bounds%begc: )                   ! heat flux on soil [W/m2]
-    real(r8)               , intent(inout)   :: hs_top (bounds%begc: )                    ! net energy flux into surface layer (col) [W/m2]
-    real(r8)               , intent(inout)   :: dhsdT( bounds%begc: )                     ! temperature derivative of "hs" [col]
-    real(r8)               , intent(inout)   :: sabg_lyr_col( bounds%begc:, -nlevsno+1: ) ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8)               , intent(out)   :: hs_h2osfc( bounds%begc: )                 ! heat flux on standing water [W/m2]
+    real(r8)               , intent(out)   :: hs_top_snow( bounds%begc: )               ! heat flux on top snow layer [W/m2]
+    real(r8)               , intent(out)   :: hs_soil( bounds%begc: )                   ! heat flux on soil [W/m2]
+    real(r8)               , intent(out)   :: hs_top (bounds%begc: )                    ! net energy flux into surface layer (col) [W/m2]
+    real(r8)               , intent(out)   :: dhsdT( bounds%begc: )                     ! temperature derivative of "hs" [col]
+    real(r8)               , intent(out)   :: sabg_lyr_col( bounds%begc:, -nlevsno+1: ) ! absorbed solar radiation (col,lyr) [W/m2]
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(urbanparams_type) , intent(in)    :: urbanparams_vars
     type(canopystate_type) , intent(in)    :: canopystate_vars
     type(solarabs_type)    , intent(inout) :: solarabs_vars
+    type(energyflux_type)  , intent(inout) :: energyflux_vars
     !
     ! !LOCAL VARIABLES:
     integer  :: j,c,p,l,t,g,pi                                         ! indices
     integer  :: fc                                                     ! lake filtered column indices
-    real(r8) :: lwrad_emit(num_nolakec)             ! emitted longwave radiation
-    real(r8) :: dlwrad_emit(num_nolakec)            ! time derivative of emitted longwave radiation
-    integer  :: lyr_top                             ! index of top layer of snowpack (-4 to 0) [idx]
-    real(r8) :: eflx_gnet_top                       ! net energy flux into surface layer, pft-level [W/m2]
-    real(r8) :: lwrad_emit_snow(num_nolakec)        !
-    real(r8) :: lwrad_emit_soil(num_nolakec)        !
-    real(r8) :: lwrad_emit_h2osfc(num_nolakec)      !
-    real(r8) :: eflx_gnet_snow                      !
-    real(r8) :: eflx_gnet_soil                      !
-    real(r8) :: eflx_gnet_h2osfc                    !
-    real(r8) :: sum1,sum2,sum3                      !
-    integer  :: begc, endc 
+    real(r8) :: hs(bounds%begc:bounds%endc)                            ! net energy flux into the surface (w/m2)
+    real(r8) :: lwrad_emit(bounds%begc:bounds%endc)                    ! emitted longwave radiation
+    real(r8) :: dlwrad_emit(bounds%begc:bounds%endc)                   ! time derivative of emitted longwave radiation
+    integer  :: lyr_top                                                ! index of top layer of snowpack (-4 to 0) [idx]
+    real(r8) :: eflx_gnet_top                                          ! net energy flux into surface layer, pft-level [W/m2]
+    real(r8) :: lwrad_emit_snow(bounds%begc:bounds%endc)               !
+    real(r8) :: lwrad_emit_soil(bounds%begc:bounds%endc)               !
+    real(r8) :: lwrad_emit_h2osfc(bounds%begc:bounds%endc)             !
+    real(r8) :: eflx_gnet_snow                                         !
+    real(r8) :: eflx_gnet_soil                                         !
+    real(r8) :: eflx_gnet_h2osfc                                       !
     !-----------------------------------------------------------------------
 
     ! Enforce expected array sizes
@@ -1798,105 +1747,94 @@ end subroutine Phasechange_beta
          sabg_soil               => solarabs_vars%sabg_soil_patch           , & ! Input:  [real(r8) (:)   ]  solar radiation absorbed by soil (W/m**2)
          sabg_snow               => solarabs_vars%sabg_snow_patch           , & ! Input:  [real(r8) (:)   ]  solar radiation absorbed by snow (W/m**2)
          sabg_chk                => solarabs_vars%sabg_chk_patch            , & ! Output: [real(r8) (:)   ]  sum of soil/snow using current fsno, for balance check
-         sabg_lyr                => solarabs_vars%sabg_lyr_patch             & ! Output: [real(r8) (:,:) ]  absorbed solar radiation (pft,lyr) [W/m2]
+         sabg_lyr                => solarabs_vars%sabg_lyr_patch            , & ! Output: [real(r8) (:,:) ]  absorbed solar radiation (pft,lyr) [W/m2]
+
+         begc                    => bounds%begc                             , & ! Input:  [integer        ] beginning column index
+         endc                    => bounds%endc                               & ! Input:  [integer        ] ending column index
          )
 
       ! Net ground heat flux into the surface and its temperature derivative
       ! Added a pfts loop here to get the average of hs and dhsdT over
       ! all PFTs on the column. Precalculate the terms that do not depend on PFT.
-   
-       !$acc enter data create(lwrad_emit_snow(:), lwrad_emit_soil(:), &
-      !$acc      lwrad_emit_h2osfc(:), lwrad_emit(:), dlwrad_emit(:) )
-      begc = bounds%begc
-      endc = bounds%endc    
-      !$acc parallel loop independent gang vector default(present) 
-      do fc = 1, num_nolakec
+
+      do fc = 1,num_nolakec
          c = filter_nolakec(fc)
-         lwrad_emit(fc)  =    emg(c) * sb * t_grnd(c)**4
-         dlwrad_emit(fc) = 4._r8*emg(c) * sb * t_grnd(c)**3
+         lwrad_emit(c)  =    emg(c) * sb * t_grnd(c)**4
+         dlwrad_emit(c) = 4._r8*emg(c) * sb * t_grnd(c)**3
 
          ! fractionate lwrad_emit; balanced in CanopyFluxes & Biogeophysics2
-         lwrad_emit_snow(fc)    =  emg(c) * sb * t_soisno(c,snl(c)+1)**4
-         lwrad_emit_h2osfc(fc)  =  emg(c) * sb * t_h2osfc(c)**4
-         lwrad_emit_soil(fc)    =  emg(c) * sb * t_soisno(c,1)**4
+         lwrad_emit_snow(c)    =    emg(c) * sb * t_soisno(c,snl(c)+1)**4
+         lwrad_emit_soil(c)    =    emg(c) * sb * t_soisno(c,1)**4
+         lwrad_emit_h2osfc(c)  =    emg(c) * sb * t_h2osfc(c)**4
       end do
 
-      ! hs_soil(begc:endc)   = 0._r8
-      ! hs_h2osfc(begc:endc) = 0._r8
-      ! dhsdT(begc:endc)     = 0._r8
-      !$acc parallel loop independent gang default(present) private(sum1,sum2,sum3)
-      do fc = 1,num_nolakec
-         c = filter_nolakec(fc)
-         hs_soil(c)   = 0._r8
-         hs_h2osfc(c) = 0._r8
-         dhsdT(c)     = 0._r8
-         sum1 = 0.0_r8; 
-         sum2 = 0.0_r8; 
-         sum3 = 0.0_r8; 
-         !$acc loop vector independent reduction(+:sum1,sum2,sum3)
-         do p = col_pp%pfti(c), col_pp%pftf(c)
-            !
-            l = veg_pp%landunit(p)
-            t = veg_pp%topounit(p)
-            g = veg_pp%gridcell(p)
-            
-            if (veg_pp%active(p)) then
-               if (.not. lun_pp%urbpoi(l)) then
-                  eflx_gnet(p) = sabg(p) + dlrad(p) &
-                        + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) - lwrad_emit(fc) &
-                        - (eflx_sh_grnd(p)+qflx_evap_soi(p)*htvp(c))
-                  ! save sabg for balancecheck, in case frac_sno is set to zero later
-                  sabg_chk(p) = frac_sno_eff(c) * sabg_snow(p) + (1._r8 - frac_sno_eff(c) ) * sabg_soil(p)
-
-                  eflx_gnet_snow = sabg_snow(p) + dlrad(p) &
-                       + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) - lwrad_emit_snow(fc) &
-                       - (eflx_sh_snow(p)+qflx_ev_snow(p)*htvp(c))
-
-                  eflx_gnet_soil = sabg_soil(p) + dlrad(p) &
-                        + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) - lwrad_emit_soil(fc) &
-                        - (eflx_sh_soil(p)+qflx_ev_soil(p)*htvp(c))
-
-                  eflx_gnet_h2osfc = sabg_soil(p) + dlrad(p) &
-                        + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) - lwrad_emit_h2osfc(fc) &
-                        - (eflx_sh_h2osfc(p)+qflx_ev_h2osfc(p)*htvp(c))
-               else
-                  ! For urban columns we use the net longwave radiation (eflx_lwrad_net) because of
-                  ! interactions between urban columns.
-
-                  ! All wasteheat and traffic flux goes into canyon floor
-                  if (col_pp%itype(c) == icol_road_perv .or. col_pp%itype(c) == icol_road_imperv) then
-                     eflx_wasteheat_patch(p) = eflx_wasteheat(l)/(1._r8-lun_pp%wtlunit_roof(l))
-                     eflx_heat_from_ac_patch(p) = eflx_heat_from_ac(l)/(1._r8-lun_pp%wtlunit_roof(l))
-                     eflx_traffic_patch(p) = eflx_traffic(l)/(1._r8-lun_pp%wtlunit_roof(l))
+      hs_soil(begc:endc)   = 0._r8
+      hs_h2osfc(begc:endc) = 0._r8
+      hs(begc:endc)        = 0._r8
+      dhsdT(begc:endc)     = 0._r8
+      do pi = 1,max_patch_per_col
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            if ( pi <= col_pp%npfts(c) ) then
+               p = col_pp%pfti(c) + pi - 1
+               l = veg_pp%landunit(p)
+               t = veg_pp%topounit(p)
+               g = veg_pp%gridcell(p)
+
+               if (veg_pp%active(p)) then
+                  if (.not. lun_pp%urbpoi(l)) then
+                     eflx_gnet(p) = sabg(p) + dlrad(p) &
+                          + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) - lwrad_emit(c) &
+                          - (eflx_sh_grnd(p)+qflx_evap_soi(p)*htvp(c))
+                     ! save sabg for balancecheck, in case frac_sno is set to zero later
+                     sabg_chk(p) = frac_sno_eff(c) * sabg_snow(p) + (1._r8 - frac_sno_eff(c) ) * sabg_soil(p)
+
+                     eflx_gnet_snow = sabg_snow(p) + dlrad(p) &
+                          + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) - lwrad_emit_snow(c) &
+                          - (eflx_sh_snow(p)+qflx_ev_snow(p)*htvp(c))
+
+                     eflx_gnet_soil = sabg_soil(p) + dlrad(p) &
+                          + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) - lwrad_emit_soil(c) &
+                          - (eflx_sh_soil(p)+qflx_ev_soil(p)*htvp(c))
+
+                     eflx_gnet_h2osfc = sabg_soil(p) + dlrad(p) &
+                          + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) - lwrad_emit_h2osfc(c) &
+                          - (eflx_sh_h2osfc(p)+qflx_ev_h2osfc(p)*htvp(c))
                   else
-                     eflx_wasteheat_patch(p) = 0._r8
-                     eflx_heat_from_ac_patch(p) = 0._r8
-                     eflx_traffic_patch(p) = 0._r8
+                     ! For urban columns we use the net longwave radiation (eflx_lwrad_net) because of
+                     ! interactions between urban columns.
+
+                     ! All wasteheat and traffic flux goes into canyon floor
+                     if (col_pp%itype(c) == icol_road_perv .or. col_pp%itype(c) == icol_road_imperv) then
+                        eflx_wasteheat_patch(p) = eflx_wasteheat(l)/(1._r8-lun_pp%wtlunit_roof(l))
+                        eflx_heat_from_ac_patch(p) = eflx_heat_from_ac(l)/(1._r8-lun_pp%wtlunit_roof(l))
+                        eflx_traffic_patch(p) = eflx_traffic(l)/(1._r8-lun_pp%wtlunit_roof(l))
+                     else
+                        eflx_wasteheat_patch(p) = 0._r8
+                        eflx_heat_from_ac_patch(p) = 0._r8
+                        eflx_traffic_patch(p) = 0._r8
+                     end if
+                     ! Include transpiration term because needed for previous road
+                     ! and include wasteheat and traffic flux
+                     eflx_gnet(p) = sabg(p) + dlrad(p)  &
+                          - eflx_lwrad_net(p) &
+                          - (eflx_sh_grnd(p) + qflx_evap_soi(p)*htvp(c) + qflx_tran_veg(p)*hvap) &
+                          + eflx_wasteheat_patch(p) + eflx_heat_from_ac_patch(p) + eflx_traffic_patch(p)
+                     eflx_anthro(p)   = eflx_wasteheat_patch(p) + eflx_traffic_patch(p)
+                     eflx_gnet_snow   = eflx_gnet(p)
+                     eflx_gnet_soil   = eflx_gnet(p)
+                     eflx_gnet_h2osfc = eflx_gnet(p)
                   end if
-                  ! Include transpiration term because needed for previous road
-                  ! and include wasteheat and traffic flux
-                  eflx_gnet(p) = sabg(p) + dlrad(p)  &
-                        - eflx_lwrad_net(p) &
-                        - (eflx_sh_grnd(p) + qflx_evap_soi(p)*htvp(c) + qflx_tran_veg(p)*hvap) &
-                        + eflx_wasteheat_patch(p) + eflx_heat_from_ac_patch(p) + eflx_traffic_patch(p)
-                  eflx_anthro(p)   = eflx_wasteheat_patch(p) + eflx_traffic_patch(p)
-                  eflx_gnet_snow   = eflx_gnet(p)
-                  eflx_gnet_soil   = eflx_gnet(p)
-                  eflx_gnet_h2osfc = eflx_gnet(p)
-               end if
-               dgnetdT(p) = - cgrnd(p) - dlwrad_emit(fc)
-               sum1 = sum1 + dgnetdT(p) * veg_pp%wtcol(p)
-               
-               ! separate surface fluxes for soil/snow
-               sum2 = sum2 + eflx_gnet_soil * veg_pp%wtcol(p)
-               sum3 = sum3 + eflx_gnet_h2osfc * veg_pp%wtcol(p)
+                  dgnetdT(p) = - cgrnd(p) - dlwrad_emit(c)
+                  hs(c) = hs(c) + eflx_gnet(p) * veg_pp%wtcol(p)
+                  dhsdT(c) = dhsdT(c) + dgnetdT(p) * veg_pp%wtcol(p)
+                  ! separate surface fluxes for soil/snow
+                  hs_soil(c) = hs_soil(c) + eflx_gnet_soil * veg_pp%wtcol(p)
+                  hs_h2osfc(c) = hs_h2osfc(c) + eflx_gnet_h2osfc * veg_pp%wtcol(p)
 
+               end if
             end if
          end do
-         !!!
-         dhsdT(c)     = sum1; 
-         hs_soil(c)   = sum2; 
-         hs_h2osfc(c) = sum3;
       end do
 
       ! Additional calculations with SNICAR:
@@ -1907,182 +1845,150 @@ end subroutine Phasechange_beta
       ! where S is absorbed radiation, and T is temperature. Now,
       ! assume delS/delT is zero, then it is OK to just add S
       ! to each layer
-      
+
       ! Initialize:
-      ! hs_top(begc:endc)                    = 0._r8
-      ! hs_top_snow(begc:endc)               = 0._r8
+      sabg_lyr_col(begc:endc,-nlevsno+1:1) = 0._r8
+      hs_top(begc:endc)                    = 0._r8
+      hs_top_snow(begc:endc)               = 0._r8
 
-       !$acc parallel loop independent gang default(present) private(sum1,sum2)
-      do fc = 1,num_nolakec
-         c = filter_nolakec(fc)
-         lyr_top = snl(c) + 1
-         !
-         sum1 = 0.0_r8; sum2 = 0.0_r8;
-         !$acc loop vector independent reduction(+:sum1,sum2)
-         do p = col_pp%pfti(c), col_pp%pftf(c)
-            if (veg_pp%active(p)) then
-               g = veg_pp%gridcell(p)
-               t = veg_pp%topounit(p)
-               l = veg_pp%landunit(p)
-               if (.not. lun_pp%urbpoi(l)) then
-                  eflx_gnet_top = sabg_lyr(p,lyr_top) + dlrad(p) + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) &
-                        - lwrad_emit(fc) - (eflx_sh_grnd(p)+qflx_evap_soi(p)*htvp(c))
+      do pi = 1,max_patch_per_col
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            lyr_top = snl(c) + 1
+            if ( pi <= col_pp%npfts(c) ) then
+               p = col_pp%pfti(c) + pi - 1
+               if (veg_pp%active(p)) then
+                  g = veg_pp%gridcell(p)
+                  t = veg_pp%topounit(p)
+                  l = veg_pp%landunit(p)
+                  if (.not. lun_pp%urbpoi(l)) then
 
-                  sum1 = sum1 + eflx_gnet_top*veg_pp%wtcol(p)
+                     eflx_gnet_top = sabg_lyr(p,lyr_top) + dlrad(p) + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) &
+                          - lwrad_emit(c) - (eflx_sh_grnd(p)+qflx_evap_soi(p)*htvp(c))
 
-                  eflx_gnet_snow = sabg_lyr(p,lyr_top) + dlrad(p) + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) &
-                        - lwrad_emit_snow(fc) - (eflx_sh_snow(p)+qflx_ev_snow(p)*htvp(c))
+                     hs_top(c) = hs_top(c) + eflx_gnet_top*veg_pp%wtcol(p)
 
-                  eflx_gnet_soil = sabg_lyr(p,lyr_top) + dlrad(p) + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) &
-                        - lwrad_emit_soil(fc) - (eflx_sh_soil(p)+qflx_ev_soil(p)*htvp(c))
+                     eflx_gnet_snow = sabg_lyr(p,lyr_top) + dlrad(p) + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) &
+                          - lwrad_emit_snow(c) - (eflx_sh_snow(p)+qflx_ev_snow(p)*htvp(c))
 
-                  sum2 = sum2 + eflx_gnet_snow*veg_pp%wtcol(p)
-                  
-               else
-                  !
-                  sum1 = sum1 + eflx_gnet(p) * veg_pp%wtcol(p)
-                  sum2 = sum2 + eflx_gnet(p) * veg_pp%wtcol(p)
+                     eflx_gnet_soil = sabg_lyr(p,lyr_top) + dlrad(p) + (1._r8-frac_veg_nosno(p))*emg(c)*forc_lwrad(t) &
+                          - lwrad_emit_soil(c) - (eflx_sh_soil(p)+qflx_ev_soil(p)*htvp(c))
+
+                     hs_top_snow(c) = hs_top_snow(c) + eflx_gnet_snow*veg_pp%wtcol(p)
+
+                     do j = lyr_top,1,1
+                        sabg_lyr_col(c,j) = sabg_lyr_col(c,j) + sabg_lyr(p,j) * veg_pp%wtcol(p)
+                     enddo
+                  else
+
+                     hs_top(c)      = hs_top(c) + eflx_gnet(p)*veg_pp%wtcol(p)
+                     hs_top_snow(c) = hs_top_snow(c) + eflx_gnet(p)*veg_pp%wtcol(p)
+                     sabg_lyr_col(c,lyr_top) = sabg_lyr_col(c,lyr_top) + sabg(p) * veg_pp%wtcol(p)
+
+                  endif
                endif
+
             endif
          enddo
-         hs_top(c) = sum1 
-         hs_top_snow(c) = sum2 
       enddo
 
-      ! sabg_lyr_col(begc:endc,-nlevsno+1:1) = 0._r8
-      !$acc parallel loop independent gang worker default(present) private(sum3) collapse(2) 
-      do j = -nlevsno,1,1
-        do fc = 1,num_nolakec
-          c = filter_nolakec(fc)
-          l = col_pp%landunit(c) 
-          lyr_top = snl(c) + 1
-          if(j < lyr_top) cycle 
-          sum3 = 0._r8 
-          if(.not. lun_pp%urbpoi(l)) then 
-            !$acc loop vector reduction(+:sum3)
-             do p = col_pp%pfti(c), col_pp%pftf(c)
-               if(veg_pp%active(p)) then
-                 sum3 = sum3 + sabg_lyr(p,j) * veg_pp%wtcol(p)
-               end if
-             enddo
-            sabg_lyr_col(c,j) = sum3 
-          end if
-        end do  
-      end do
-      
-      !$acc parallel loop independent gang worker default(present) 
-      do fc = 1,num_nolakec
-        c = filter_nolakec(fc)
-        l = col_pp%landunit(c) 
-        lyr_top = snl(c) + 1
-        sum3 = 0._r8 
-        if(lun_pp%urbpoi(l)) then 
-          !$acc loop vector independent reduction(+:sum3)
-          do p = col_pp%pfti(c), col_pp%pftf(c)
-             if (veg_pp%active(p)) then
-                sum3 = sum3 + sabg(p) * veg_pp%wtcol(p)
-             end if
-          end do
-          sabg_lyr_col(c,lyr_top) = sum3
-        end if 
-      end do 
-     !$acc exit data delete(lwrad_emit_snow(:), lwrad_emit_soil(:), &
-     !$acc      lwrad_emit_h2osfc(:), lwrad_emit(:), dlwrad_emit(:) )
     end associate
 
   end subroutine ComputeGroundHeatFluxAndDeriv
 
   !-----------------------------------------------------------------------
   subroutine ComputeHeatDiffFluxAndFactor(bounds, num_nolakec, filter_nolakec, dtime, &
-   tk, cv, fn, fact )
-!
-! !DESCRIPTION:
-! Computes:
-! (1) Heat diffusion at the interface of layers.
-! (2) Factor used in computing tridiagonal matrix
-!
-! !USES:
-use elm_varcon     , only : capr, cnfac
-use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
-use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
-!
-! !ARGUMENTS:
-implicit none
-type(bounds_type)      , intent(in)  :: bounds                             ! bounds
-integer                , intent(in)  :: num_nolakec                        ! number of column non-lake points in column filter
-integer                , intent(in)  :: filter_nolakec(:)                  ! column filter for non-lake points
-real(r8)               , intent(in)  :: dtime                              ! land model time step (sec)
-real(r8)               , intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )     ! thermal conductivity [W/(m K)]
-real(r8)               , intent(in)  :: cv  (1: ,-nlevsno+1: )             ! heat capacity [J/(m2 K)]
-real(r8)               , intent(inout) :: fn  (bounds%begc:, -nlevsno+1: )   ! heat diffusion through the layer interface [W/m2]
-real(r8)               , intent(inout) :: fact(bounds%begc:, -nlevsno+1: )   ! used in computing tridiagonal matrix [col, lev]
-!
-! LOCAL VARIABLES:
-integer  :: j,c,l    ! indices
-integer  :: fc       ! lake filtered column indices
-real(r8) :: dzm      ! used in computing tridiagonal matrix
-!-----------------------------------------------------------------------
-! Enforce expected array sizes     
-!-----------------------------------------------------------------------
-associate(&
-     zi         => col_pp%zi         , & ! Input: [real(r8) (:,:) ] interface level below a "z" level (m)
-     dz         => col_pp%dz         , & ! Input: [real(r8) (:,:) ] layer depth (m)
-     z          => col_pp%z          , & ! Input: [real(r8) (:,:) ] layer thickness (m)
-     t_building => lun_es%t_building , & ! Input: [real(r8) (:)   ] internal building temperature (K)
-     t_soisno   => col_es%t_soisno   , & ! Input: [real(r8) (:,:) ] soil temperature (Kelvin)
-     eflx_bot   => col_ef%eflx_bot     & ! Input: [real(r8) (:)   ] heat flux from beneath column (W/m**2) [+ = upward]
-     )
-
-  ! Determine heat diffusion through the layer interface and factor used in computing
-  ! tridiagonal matrix and set up vector r and vectors a, b, c that define tridiagonal
-  ! matrix and solve system
-  
-  !$acc parallel loop independent gang default(present) 
-  do j = -nlevsno+1,nlevgrnd
-     !$acc loop vector independent 
-     do fc = 1,num_nolakec
-        c = filter_nolakec(fc)
-        l = col_pp%landunit(c)
-        if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
-             .or. col_pp%itype(c) == icol_roof) .and. j <= nlevurb) then
-           if (j >= col_pp%snl(c)+1) then
-              if (j == col_pp%snl(c)+1) then
-                 fact(c,j) = dtime/cv(fc,j)
-                 fn(c,j) = tk(c,j)*(t_soisno(c,j+1)-t_soisno(c,j))/(z(c,j+1)-z(c,j))
-              else if (j <= nlevurb-1) then
-                 fact(c,j) = dtime/cv(fc,j)
-                 fn(c,j) = tk(c,j)*(t_soisno(c,j+1)-t_soisno(c,j))/(z(c,j+1)-z(c,j))
-                 dzm     = (z(c,j)-z(c,j-1))
-              else if (j == nlevurb) then
-                 fact(c,j) = dtime/cv(fc,j)
-                 ! For urban sunwall, shadewall, and roof columns, there is a non-zero heat flux across
-                 ! the bottom "soil" layer and the equations are derived assuming a prescribed internal
-                 ! building temperature. (See Oleson urban notes of 6/18/03).
-                 fn(c,j) = tk(c,j) * (t_building(l) - cnfac*t_soisno(c,j))/(zi(c,j) - z(c,j))
-              end if
-           end if
-        else if (col_pp%itype(c) /= icol_sunwall .and. col_pp%itype(c) /= icol_shadewall &
-             .and. col_pp%itype(c) /= icol_roof) then
-           if (j >= col_pp%snl(c)+1) then
-              if (j == col_pp%snl(c)+1) then
-                 fact(c,j) = dtime/cv(fc,j) * dz(c,j) / (0.5_r8*(z(c,j)-zi(c,j-1)+capr*(z(c,j+1)-zi(c,j-1))))
-                 fn(c,j) = tk(c,j)*(t_soisno(c,j+1)-t_soisno(c,j))/(z(c,j+1)-z(c,j))
-              else if (j <= nlevgrnd-1) then
-                 fact(c,j) = dtime/cv(fc,j)
-                 fn(c,j) = tk(c,j)*(t_soisno(c,j+1)-t_soisno(c,j))/(z(c,j+1)-z(c,j))
-                 dzm     = (z(c,j)-z(c,j-1))
-              else if (j == nlevgrnd) then
-                 fact(c,j) = dtime/cv(fc,j)
-                 fn(c,j) = eflx_bot(c)
-              end if
-           end if
-        end if
-     end do
-  end do
-
-end associate
-
-end subroutine ComputeHeatDiffFluxAndFactor
+       tk, cv, fn, fact, &
+       energyflux_vars)
+    !
+    ! !DESCRIPTION:
+    ! Computes:
+    ! (1) Heat diffusion at the interface of layers.
+    ! (2) Factor used in computing tridiagonal matrix
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : capr, cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type)      , intent(in)  :: bounds                             ! bounds
+    integer                , intent(in)  :: num_nolakec                        ! number of column non-lake points in column filter
+    integer                , intent(in)  :: filter_nolakec(:)                  ! column filter for non-lake points
+    real(r8)               , intent(in)  :: dtime                              ! land model time step (sec)
+    real(r8)               , intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )     ! thermal conductivity [W/(m K)]
+    real(r8)               , intent(in)  :: cv (bounds%begc: ,-nlevsno+1: )    ! heat capacity [J/(m2 K)]
+    real(r8)               , intent(out) :: fn (bounds%begc: ,-nlevsno+1: )    ! heat diffusion through the layer interface [W/m2]
+    real(r8)               , intent(out) :: fact( bounds%begc: , -nlevsno+1: ) ! used in computing tridiagonal matrix [col, lev]
+    type(energyflux_type)  , intent(in)  :: energyflux_vars
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,l                                           ! indices
+    integer  :: fc                                              ! lake filtered column indices
+    real(r8) :: dzm                                             ! used in computing tridiagonal matrix
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(&
+         zi         => col_pp%zi                          , & ! Input: [real(r8) (:,:) ] interface level below a "z" level (m)
+         dz         => col_pp%dz                          , & ! Input: [real(r8) (:,:) ] layer depth (m)
+         z          => col_pp%z                           , & ! Input: [real(r8) (:,:) ] layer thickness (m)
+         t_building => lun_es%t_building , & ! Input: [real(r8) (:)   ] internal building temperature (K)
+         t_soisno   => col_es%t_soisno   , & ! Input: [real(r8) (:,:) ] soil temperature (Kelvin)
+         eflx_bot   => col_ef%eflx_bot      & ! Input: [real(r8) (:)   ] heat flux from beneath column (W/m**2) [+ = upward]
+         )
+
+      ! Determine heat diffusion through the layer interface and factor used in computing
+      ! tridiagonal matrix and set up vector r and vectors a, b, c that define tridiagonal
+      ! matrix and solve system
+
+      do j = -nlevsno+1,nlevgrnd
+         do fc = 1,num_nolakec
+            c = filter_nolakec(fc)
+            l = col_pp%landunit(c)
+            if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
+                 .or. col_pp%itype(c) == icol_roof) .and. j <= nlevurb) then
+               if (j >= col_pp%snl(c)+1) then
+                  if (j == col_pp%snl(c)+1) then
+                     fact(c,j) = dtime/cv(c,j)
+                     fn(c,j) = tk(c,j)*(t_soisno(c,j+1)-t_soisno(c,j))/(z(c,j+1)-z(c,j))
+                  else if (j <= nlevurb-1) then
+                     fact(c,j) = dtime/cv(c,j)
+                     fn(c,j) = tk(c,j)*(t_soisno(c,j+1)-t_soisno(c,j))/(z(c,j+1)-z(c,j))
+                     dzm     = (z(c,j)-z(c,j-1))
+                  else if (j == nlevurb) then
+                     fact(c,j) = dtime/cv(c,j)
+                     ! For urban sunwall, shadewall, and roof columns, there is a non-zero heat flux across
+                     ! the bottom "soil" layer and the equations are derived assuming a prescribed internal
+                     ! building temperature. (See Oleson urban notes of 6/18/03).
+                     fn(c,j) = tk(c,j) * (t_building(l) - cnfac*t_soisno(c,j))/(zi(c,j) - z(c,j))
+                  end if
+               end if
+            else if (col_pp%itype(c) /= icol_sunwall .and. col_pp%itype(c) /= icol_shadewall &
+                 .and. col_pp%itype(c) /= icol_roof) then
+               if (j >= col_pp%snl(c)+1) then
+                  if (j == col_pp%snl(c)+1) then
+                     fact(c,j) = dtime/cv(c,j) * dz(c,j) / (0.5_r8*(z(c,j)-zi(c,j-1)+capr*(z(c,j+1)-zi(c,j-1))))
+                     fn(c,j) = tk(c,j)*(t_soisno(c,j+1)-t_soisno(c,j))/(z(c,j+1)-z(c,j))
+                  else if (j <= nlevgrnd-1) then
+                     fact(c,j) = dtime/cv(c,j)
+                     fn(c,j) = tk(c,j)*(t_soisno(c,j+1)-t_soisno(c,j))/(z(c,j+1)-z(c,j))
+                     dzm     = (z(c,j)-z(c,j-1))
+                  else if (j == nlevgrnd) then
+                     fact(c,j) = dtime/cv(c,j)
+                     fn(c,j) = eflx_bot(c)
+                  end if
+               end if
+            end if
+         end do
+      end do
+
+    end associate
+
+  end subroutine ComputeHeatDiffFluxAndFactor
 
   !-----------------------------------------------------------------------
   subroutine SetRHSVec(bounds, num_filter, filter, dtime, &
@@ -2104,6 +2010,7 @@ end subroutine ComputeHeatDiffFluxAndFactor
     !           !===========|
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon      , only : cnfac, cpliq
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -2126,14 +2033,17 @@ end subroutine ComputeHeatDiffFluxAndFactor
     real(r8) , intent(in)  :: fn( bounds%begc: , -nlevsno+1: )           ! heat diffusion through the layer interface [W/m2]
     real(r8) , intent(in)  :: c_h2osfc( bounds%begc: )                   ! heat capacity of surface water [col]
     real(r8) , intent(in)  :: dz_h2osfc( bounds%begc: )                  ! Thickness of standing water [m]
-    real(r8) , intent(inout) :: rvector( bounds%begc: , -nlevsno: )        ! RHS vector used in numerical solution of temperature
-    logical  , intent(in)  :: urban_column                 ! Is true if solving temperature for urban column, otherwise false
+    real(r8) , intent(out) :: rvector( bounds%begc: , -nlevsno: )        ! RHS vector used in numerical solution of temperature
+    logical                , intent(in)  :: urban_column                 ! Is true if solving temperature for urban column, otherwise false
     !
     ! !LOCAL VARIABLES:
-    integer  :: j,c                     ! indices
-    integer  :: fc                      ! lake filtered column indices
-    real(r8) :: fn_h2osfc!(1:num_filter) ! heat diffusion through standing-water/soil interface [W/m2]
-    real(r8) :: dzm                     ! used in computing tridiagonal matrix
+    integer  :: j,c                                                     ! indices
+    integer  :: fc                                                      ! lake filtered column indices
+    real(r8) :: rt (bounds%begc:bounds%endc,-nlevsno+1:nlevgrnd)        ! "r" vector for tridiagonal solution
+    real(r8) :: fn_h2osfc(bounds%begc:bounds%endc)                      ! heat diffusion through standing-water/soil interface [W/m2]
+    real(r8) :: rt_snow(bounds%begc:bounds%endc,-nlevsno:-1)            ! RHS vector corresponding to snow layers
+    real(r8) :: rt_ssw(bounds%begc:bounds%endc,1)                       ! RHS vector corresponding to standing surface water
+    real(r8) :: rt_soil(bounds%begc:bounds%endc,1:nlevgrnd)             ! RHS vector corresponding to soil layer
     !-----------------------------------------------------------------------
 
     ! Enforce expected array sizes
@@ -2147,6 +2057,8 @@ end subroutine ComputeHeatDiffFluxAndFactor
          endc         => bounds%endc                        & ! Input: [integer ] ending column index
          )
 
+      ! Initialize
+      rvector(begc:endc, :) = spval
 
       call SetRHSVec_Snow(bounds, num_filter, filter, &
            hs_top_snow( begc:endc ),                           &
@@ -2158,52 +2070,44 @@ end subroutine ComputeHeatDiffFluxAndFactor
            t_soisno ( begc:endc, -nlevsno+1: ),                &
            t_h2osfc ( begc:endc ),                             &
            urban_column,                                       &
-           rvector( begc:endc, -nlevsno:))
-
-      ! ! Set entries in RHS vector for surface water layer
-      ! call SetRHSVec_StandingSurfaceWater(bounds, num_filter, filter, &
-      !      dtime,                                                              &
-      !      hs_h2osfc( begc:endc ),                                             &
-      !      dhsdT( begc:endc ),                                                 &
-      !      tk_h2osfc( begc:endc ),                                             &
-      !      c_h2osfc( begc:endc ),                                              &
-      !      dz_h2osfc( begc:endc ),                                             &
-      !      t_soisno ( begc:endc, -nlevsno+1: ),                                &
-      !      t_h2osfc ( begc:endc),                                              &
-      !      rvector( begc:endc, 0))
-
-
-       ! Set entries in RHS vector for soil layers
-       call SetRHSVec_Soil(bounds, num_filter, filter, &
-            hs_top_snow( begc:endc ),                           &
-            hs_soil( begc:endc ),                               &
-            hs_top( begc:endc ),                                &
-            dhsdT( begc:endc ),                                 &
-            sabg_lyr_col (begc:endc, -nlevsno+1: ),             &
-            fact( begc:endc, -nlevsno+1: ),                     &
-            fn( begc:endc, -nlevsno+1: ),                       &
-            c_h2osfc( begc:endc ),                              &
-            frac_h2osfc ( begc:endc),                           &
-            frac_sno_eff( begc:endc),                           &
-            t_soisno ( begc:endc, -nlevsno+1: ),                &
-            urban_column,                                       &
-            rvector( begc:endc, 1:nlevgrnd ))
-
-      !$acc parallel loop independent gang vector default(present)
-      do fc = 1,num_filter
-         c = filter(fc)
+           rt_snow( begc:endc, -nlevsno:))
 
-         ! surface water layer has two coefficients
-         dzm=(0.5*dz_h2osfc(c)+col_pp%z(c,1))
+      ! Set entries in RHS vector for surface water layer
+      call SetRHSVec_StandingSurfaceWater(bounds, num_filter, filter, &
+           dtime,                                                              &
+           hs_h2osfc( begc:endc ),                                             &
+           dhsdT( begc:endc ),                                                 &
+           tk_h2osfc( begc:endc ),                                             &
+           c_h2osfc( begc:endc ),                                              &
+           dz_h2osfc( begc:endc ),                                             &
+           fn_h2osfc( begc:endc ),                                             &
+           t_soisno ( begc:endc, -nlevsno+1: ),                                &
+           t_h2osfc ( begc:endc),                                              &
+           rt_ssw( begc:endc, 1:1))
 
-         fn_h2osfc = tk_h2osfc(c)*(t_soisno(c,1)-t_h2osfc(c))/dzm
-         rvector(c,0)= t_h2osfc(c) +  (dtime/c_h2osfc(c)) &
-              *( hs_h2osfc(c) - dhsdT(c)*t_h2osfc(c) + cnfac*fn_h2osfc )!rhs for h2osfc
-         if ( frac_h2osfc(c) /= 0.0_r8 )then
-            rvector(c,1) = rvector(c,1) &
-                 -frac_h2osfc(c)*fact(c,1)*((hs_soil(c) - dhsdT(c)*t_soisno(c,1)) &
-                 +cnfac*fn_h2osfc )
-         end if
+      ! Set entries in RHS vector for soil layers
+      call SetRHSVec_Soil(bounds, num_filter, filter, &
+           hs_top_snow( begc:endc ),                           &
+           hs_soil( begc:endc ),                               &
+           hs_top( begc:endc ),                                &
+           dhsdT( begc:endc ),                                 &
+           sabg_lyr_col (begc:endc, -nlevsno+1: ),             &
+           fact( begc:endc, -nlevsno+1: ),                     &
+           fn( begc:endc, -nlevsno+1: ),                       &
+           fn_h2osfc( begc:endc ),                             &
+           c_h2osfc( begc:endc ),                              &
+           frac_h2osfc ( begc:endc),                           &
+           frac_sno_eff( begc:endc),                           &
+           t_soisno ( begc:endc, -nlevsno+1: ),                &
+           urban_column,                                       &
+           rt_soil( begc:endc, 1: ))
+
+      ! Combine the RHS vector
+      do fc = 1,num_filter
+         c = filter(fc)
+         rvector(c, -nlevsno:-1) = rt_snow(c, -nlevsno:-1)
+         rvector(c, 0         )  = rt_ssw(c, 1          )
+         rvector(c, 1:nlevgrnd)  = rt_soil(c, 1:nlevgrnd )
       end do
 
     end associate
@@ -2212,66 +2116,70 @@ end subroutine ComputeHeatDiffFluxAndFactor
 
   !-----------------------------------------------------------------------
   subroutine SetRHSVec_Snow(bounds, num_filter, filter, &
-   hs_top_snow, hs_top, dhsdT, sabg_lyr_col, &
-   fact, fn, t_soisno, t_h2osfc, urban_column, rt)
-!
-! !DESCRIPTION:
-! Sets up RHS vector corresponding to snow layers.
-!
-! !USES:
-use elm_varpar     , only : nlevsno, nlevgrnd
-!
-! !ARGUMENTS:
-implicit none
-type(bounds_type), intent(in) :: bounds                             ! bounds
-integer , intent(in)  :: num_filter                                 ! number of column the in filter
-integer , intent(in)  :: filter(:)                                  ! column filter
-real(r8), intent(in)  :: hs_top_snow( bounds%begc: )                ! heat flux on top snow layer [W/m2]
-real(r8), intent(in)  :: hs_top( bounds%begc: )                     ! net energy flux into surface layer (col) [W/m2]
-real(r8), intent(in)  :: dhsdT( bounds%begc: )                      ! temperature derivative of "hs" [col]
-real(r8), intent(in)  :: sabg_lyr_col( bounds%begc: , -nlevsno+1: ) ! absorbed solar radiation (col,lyr) [W/m2]
-real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )         ! used in computing tridiagonal matrix [col, lev]
-real(r8), intent(in)  :: fn (bounds%begc: , -nlevsno+1: )           ! heat diffusion through the layer interface [W/m2]
-real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)        ! soil temperature (Kelvin)
-real(r8), intent(in)  :: t_h2osfc(bounds%begc:)                     ! surface water temperature (Kelvin)
-logical , intent(in)  :: urban_column                               ! Is true if solving temperature for urban column, otherwise false
-real(r8), intent(inout) :: rt(bounds%begc: , -nlevsno: )              ! rhs vector entries
-!-----------------------------------------------------------------------
-
-! Enforce expected array sizes
-
-associate(                    &
-     begc =>    bounds%begc , & ! Input:  [integer ] beginning column index
-     endc =>    bounds%endc   & ! Input:  [integer ] ending column index
-     )
-
-  if (urban_column) then
-     call SetRHSVec_SnowUrban(bounds, num_filter, filter, &
-          hs_top_snow( begc:endc ),                                &
-          hs_top( begc:endc ),                                     &
-          dhsdT( begc:endc ),                                      &
-          sabg_lyr_col (begc:endc, -nlevsno+1: ),                  &
-          fact( begc:endc, -nlevsno+1: ),                          &
-          fn( begc:endc, -nlevsno+1: ),                            &
-          t_soisno ( begc:endc, -nlevsno+1: ),                     &
-          t_h2osfc ( begc:endc ),                                  &
-          rt( begc:endc, -nlevsno:))
-
-  else
-     call SetRHSVec_SnowNonUrban(bounds, num_filter, filter, &
-          hs_top_snow( begc:endc ),                                   &
-          hs_top( begc:endc ),                                        &
-          dhsdT( begc:endc ),                                         &
-          sabg_lyr_col (begc:endc, -nlevsno+1: ),                     &
-          fact( begc:endc, -nlevsno+1: ),                             &
-          fn( begc:endc, -nlevsno+1: ),                               &
-          t_soisno ( begc:endc, -nlevsno+1: ),                        &
-          rt( begc:endc, -nlevsno:))
-  endif
-
-end associate
-
-end subroutine SetRHSVec_Snow
+       hs_top_snow, hs_top, dhsdT, sabg_lyr_col, &
+       fact, fn, t_soisno, t_h2osfc, urban_column, rt)
+    !
+    ! !DESCRIPTION:
+    ! Sets up RHS vector corresponding to snow layers.
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varpar     , only : nlevsno, nlevgrnd
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                             ! bounds
+    integer , intent(in)  :: num_filter                                 ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                  ! column filter
+    real(r8), intent(in)  :: hs_top_snow( bounds%begc: )                ! heat flux on top snow layer [W/m2]
+    real(r8), intent(in)  :: hs_top( bounds%begc: )                     ! net energy flux into surface layer (col) [W/m2]
+    real(r8), intent(in)  :: dhsdT( bounds%begc: )                      ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: sabg_lyr_col( bounds%begc: , -nlevsno+1: ) ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )         ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: fn (bounds%begc: , -nlevsno+1: )           ! heat diffusion through the layer interface [W/m2]
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)        ! soil temperature (Kelvin)
+    real(r8), intent(in)  :: t_h2osfc(bounds%begc:)                     ! surface water temperature (Kelvin)
+    logical , intent(in)  :: urban_column                               ! Is true if solving temperature for urban column, otherwise false
+    real(r8), intent(out) :: rt(bounds%begc: , -nlevsno: )              ! rhs vector entries
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(                    &
+         begc =>    bounds%begc , & ! Input:  [integer ] beginning column index
+         endc =>    bounds%endc   & ! Input:  [integer ] ending column index
+         )
+
+      ! Initialize
+      rt(begc:endc, : ) = spval
+
+      if (urban_column) then
+         call SetRHSVec_SnowUrban(bounds, num_filter, filter, &
+              hs_top_snow( begc:endc ),                                &
+              hs_top( begc:endc ),                                     &
+              dhsdT( begc:endc ),                                      &
+              sabg_lyr_col (begc:endc, -nlevsno+1: ),                  &
+              fact( begc:endc, -nlevsno+1: ),                          &
+              fn( begc:endc, -nlevsno+1: ),                            &
+              t_soisno ( begc:endc, -nlevsno+1: ),                     &
+              t_h2osfc ( begc:endc ),                                  &
+              rt( begc:endc, -nlevsno:))
+
+      else
+         call SetRHSVec_SnowNonUrban(bounds, num_filter, filter, &
+              hs_top_snow( begc:endc ),                                   &
+              hs_top( begc:endc ),                                        &
+              dhsdT( begc:endc ),                                         &
+              sabg_lyr_col (begc:endc, -nlevsno+1: ),                     &
+              fact( begc:endc, -nlevsno+1: ),                             &
+              fn( begc:endc, -nlevsno+1: ),                               &
+              t_soisno ( begc:endc, -nlevsno+1: ),                        &
+              rt( begc:endc, -nlevsno:))
+      endif
+
+    end associate
+
+  end subroutine SetRHSVec_Snow
 
   !-----------------------------------------------------------------------
   subroutine SetRHSVec_SnowUrban(bounds, num_filter, filter, &
@@ -2282,6 +2190,7 @@ end subroutine SetRHSVec_Snow
     ! Sets up RHS vector corresponding to snow layers for urban columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd
@@ -2348,6 +2257,7 @@ end subroutine SetRHSVec_Snow
     ! Sets up RHS vector corresponding to snow layers for urban sunwall/shadewall/roof columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon      , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd
@@ -2371,6 +2281,8 @@ end subroutine SetRHSVec_Snow
     integer  :: fc                                                      ! lake filtered column indices
     real(r8) :: dzm                                                     ! used in computing tridiagonal matrix
     real(r8) :: dzp                                                     ! used in computing tridiagonal matrix
+    real(r8) :: rt_snow_urban(bounds%begc:bounds%endc,-nlevsno:-1)      ! rhs vector entries for urban columns
+    real(r8) :: rt_snow_nonurban(bounds%begc:bounds%endc,-nlevsno:-1)   ! rhs vector entries for non-urban columns
     !-----------------------------------------------------------------------
 
     ! Enforce expected array sizes
@@ -2382,9 +2294,7 @@ end subroutine SetRHSVec_Snow
       !
       ! urban columns ------------------------------------------------------------------
       !
-      !$acc parallel loop independent gang default(present) 
       do j = -nlevsno+1,0
-         !$acc loop vector independent 
          do fc = 1,num_filter
             c = filter(fc)
             l = col_pp%landunit(c)
@@ -2410,74 +2320,535 @@ end subroutine SetRHSVec_Snow
 
     end associate
 
-  end subroutine SetRHSVec_SnowUrbanNonRoad
+  end subroutine SetRHSVec_SnowUrbanNonRoad
+
+  !-----------------------------------------------------------------------
+  subroutine SetRHSVec_SnowUrbanRoad(bounds, num_filter, filter, &
+       hs_top_snow, hs_top, dhsdT, sabg_lyr_col, &
+       fact, fn, t_soisno, t_h2osfc, rt)
+    !
+    ! !DESCRIPTION:
+    ! Sets up RHS vector corresponding to snow layers for urban road
+    ! (impervious + pervious) columns
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : cnfac
+    use column_varcon  , only : icol_road_perv, icol_road_imperv
+    use elm_varpar     , only : nlevsno, nlevgrnd
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                             ! bounds
+    integer , intent(in)  :: num_filter                                 ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                  ! column filter
+    real(r8), intent(in)  :: hs_top_snow( bounds%begc: )                ! heat flux on top snow layer [W/m2]
+    real(r8), intent(in)  :: hs_top( bounds%begc: )                     ! net energy flux into surface layer (col) [W/m2]
+    real(r8), intent(in)  :: dhsdT( bounds%begc: )                      ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: sabg_lyr_col( bounds%begc: , -nlevsno+1: ) ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )         ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: fn (bounds%begc: , -nlevsno+1: )           ! heat diffusion through the layer interface [W/m2]
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)        ! soil temperature (Kelvin)
+    real(r8), intent(in)  :: t_h2osfc(bounds%begc: )                    ! surface water temperature (Kelvin)
+    real(r8), intent(inout) :: rt(bounds%begc: , -nlevsno: )            ! rhs vector entries
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,l                                                   ! indices
+    integer  :: fc                                                      ! lake filtered column indices
+    real(r8) :: dzm                                                     ! used in computing tridiagonal matrix
+    real(r8) :: dzp                                                     ! used in computing tridiagonal matrix
+    real(r8) :: rt_snow_urban(bounds%begc:bounds%endc,-nlevsno:-1)      !
+    real(r8) :: rt_snow_nonurban(bounds%begc:bounds%endc,-nlevsno:-1)   !
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(         &
+         z  => col_pp%z   & ! Input: [real(r8) (:,:) ]  layer thickness (m)
+         )
+
+      !
+      ! urban road columns -------------------------------------------------------------
+      !
+      do j = -nlevsno+1,0
+         do fc = 1,num_filter
+            c = filter(fc)
+            l = col_pp%landunit(c)
+            if (lun_pp%urbpoi(l)) then
+               if (col_pp%itype(c) == icol_road_imperv .or. col_pp%itype(c) == icol_road_perv) then
+                  if (j >= col_pp%snl(c)+1) then
+                     if (j == col_pp%snl(c)+1) then
+                        dzp     = z(c,j+1)-z(c,j)
+                        rt(c,j-1) = t_soisno(c,j) +  fact(c,j)*( hs_top_snow(c) &
+                             - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
+                     else
+                        dzm     = (z(c,j)-z(c,j-1))
+                        dzp     = (z(c,j+1)-z(c,j))
+
+                        rt(c,j-1) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
+                        rt(c,j-1) = rt(c,j-1) + fact(c,j)*sabg_lyr_col(c,j)
+
+                     end if
+                  end if
+               end if
+            end if
+         enddo
+      end do
+
+    end associate
+
+  end subroutine SetRHSVec_SnowUrbanRoad
+
+  !-----------------------------------------------------------------------
+  subroutine SetRHSVec_SnowNonUrban(bounds, num_filter, filter, &
+       hs_top_snow, hs_top, dhsdT, sabg_lyr_col, &
+       fact, fn, t_soisno, rt)
+
+    !
+    ! !DESCRIPTION:
+    ! Sets up RHS vector corresponding to snow layers for non-urban columns
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                             ! bounds
+    integer , intent(in)  :: num_filter                                 ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                  ! column filter
+    real(r8), intent(in)  :: hs_top_snow( bounds%begc: )                ! heat flux on top snow layer [W/m2]
+    real(r8), intent(in)  :: hs_top( bounds%begc: )                     ! net energy flux into surface layer (col) [W/m2]
+    real(r8), intent(in)  :: dhsdT( bounds%begc: )                      ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: sabg_lyr_col( bounds%begc: , -nlevsno+1: ) ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )         ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: fn (bounds%begc: , -nlevsno+1: )           ! heat diffusion through the layer interface [W/m2]
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)        ! soil temperature (Kelvin)
+    real(r8), intent(inout) :: rt(bounds%begc: , -nlevsno: )            ! rhs vector entries
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,l                                                   ! indices
+    integer  :: fc                                                      ! lake filtered column indices
+    real(r8) :: dzm                                                     ! used in computing tridiagonal matrix
+    real(r8) :: dzp                                                     ! used in computing tridiagonal matrix
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(       &
+         z => col_pp%z  & ! Input: [real(r8) (:,:) ]  layer thickness (m)
+         )
+
+      !
+      ! non-urban columns --------------------------------------------------------------
+      !
+      do j = -nlevsno+1,0
+         do fc = 1,num_filter
+            c = filter(fc)
+            l = col_pp%landunit(c)
+            if (.not. lun_pp%urbpoi(l)) then
+               if (j >= col_pp%snl(c)+1) then
+                  if (j == col_pp%snl(c)+1) then
+                     dzp     = z(c,j+1)-z(c,j)
+                     rt(c,j-1) = t_soisno(c,j) +  fact(c,j)*( hs_top_snow(c) &
+                          - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
+
+                  else
+                     dzm     = (z(c,j)-z(c,j-1))
+                     dzp     = (z(c,j+1)-z(c,j))
+
+                     rt(c,j-1) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
+                     rt(c,j-1) = rt(c,j-1) + fact(c,j)*sabg_lyr_col(c,j)
+
+                  end if
+               end if
+            end if
+         enddo
+      end do
+
+    end associate
+
+  end subroutine SetRHSVec_SnowNonUrban
+
+  !-----------------------------------------------------------------------
+  subroutine SetRHSVec_StandingSurfaceWater(bounds, num_filter, filter, dtime, &
+       hs_h2osfc, dhsdT, tk_h2osfc, c_h2osfc, dz_h2osfc, fn_h2osfc, &
+       t_soisno, t_h2osfc, rt)
+    !
+    ! !DESCRIPTION:
+    ! Sets up RHS vector corresponding to standing surface water
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                      ! bounds
+    integer , intent(in)  :: num_filter                          ! number of column the in filter
+    integer , intent(in)  :: filter(:)                           ! column filter
+    real(r8), intent(in)  :: dtime                               ! land model time step (sec)
+    real(r8), intent(in)  :: hs_h2osfc(bounds%begc: )            !
+    real(r8), intent(in)  :: dhsdT(bounds%begc: )                ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: tk_h2osfc(bounds%begc: )            !
+    real(r8), intent(in)  :: c_h2osfc( bounds%begc: )            ! heat capacity of surface water [col]
+    real(r8), intent(in)  :: dz_h2osfc(bounds%begc: )            ! Thickness of standing water [m]
+    real(r8), intent(out) :: fn_h2osfc (bounds%begc: )           ! heat diffusion through standing-water/soil interface [W/m2]
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:) ! soil temperature (Kelvin)
+    real(r8), intent(in)  :: t_h2osfc(bounds%begc:)              ! surface water temperature temperature (Kelvin)
+    real(r8), intent(out) :: rt(bounds%begc:bounds%endc, 1:1 )   ! rhs vector entries
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c                                             ! indices
+    integer  :: fc                                              ! lake filtered column indices
+    real(r8) :: dzm                                             ! used in computing tridiagonal matrix
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    ! Initialize
+    rt(bounds%begc:bounds%endc, : ) = spval
+
+    !
+    ! surface water ------------------------------------------------------------------
+    !
+    do fc = 1,num_filter
+       c = filter(fc)
+
+       ! surface water layer has two coefficients
+       dzm=(0.5*dz_h2osfc(c)+col_pp%z(c,1))
+
+       fn_h2osfc(c)=tk_h2osfc(c)*(t_soisno(c,1)-t_h2osfc(c))/dzm
+       rt(c,1)= t_h2osfc(c) +  (dtime/c_h2osfc(c)) &
+            *( hs_h2osfc(c) - dhsdT(c)*t_h2osfc(c) + cnfac*fn_h2osfc(c) )!rhs for h2osfc
+
+    enddo
+
+  end subroutine SetRHSVec_StandingSurfaceWater
+
+  !-----------------------------------------------------------------------
+  subroutine SetRHSVec_Soil(bounds, num_filter, filter, &
+       hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, fn_h2osfc, c_h2osfc, &
+       frac_h2osfc, frac_sno_eff, t_soisno, urban_column, rt)
+    !
+    ! !DESCRIPTION:
+    ! Sets up RHS vector corresponding to soil layers
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                                     ! bounds
+    integer , intent(in)  :: num_filter                                         ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                          ! column filter
+    real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
+    real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
+    real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
+    real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
+    real(r8), intent(in)  :: fn_h2osfc (bounds%begc: )                          ! heat diffusion through standing-water/soil interface [W/m2]
+    real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
+    real(r8), intent(in)  :: frac_h2osfc(bounds%begc: )                         ! fractional area with surface water greater than zero
+    real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                        ! fraction of ground covered by snow (0 to 1)
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
+    logical , intent(in)  :: urban_column                                       ! Is true if solving temperature for urban column, otherwise false
+    real(r8), intent(out) :: rt(bounds%begc: ,1: )                              ! rhs vector entries
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(&
+         begc     => bounds%begc  , & ! Input:  [integer ] beginning column index
+         endc     => bounds%endc    & ! Input:  [integer ] ending column index
+         )
+
+      ! Initialize
+      rt(begc:endc, : ) = spval
+
+      if (urban_column) then
+         call SetRHSVec_SoilUrban(bounds, num_filter, filter, &
+              hs_top_snow( begc:endc ),                                &
+              hs_soil( begc:endc ),                                    &
+              hs_top( begc:endc ),                                     &
+              dhsdT( begc:endc ),                                      &
+              sabg_lyr_col (begc:endc, -nlevsno+1: ),                  &
+              fact( begc:endc, -nlevsno+1: ),                          &
+              fn( begc:endc, -nlevsno+1: ),                            &
+              fn_h2osfc( begc:endc ),                                  &
+              c_h2osfc( begc:endc ),                                   &
+              frac_sno_eff( begc:endc ),                               &
+              t_soisno( begc:endc, -nlevsno+1: ),                      &
+              rt( begc:endc, 1: ))
+      else
+         call SetRHSVec_SoilNonUrban(bounds, num_filter, filter, &
+              hs_top_snow( begc:endc ),                                   &
+              hs_soil( begc:endc ),                                       &
+              hs_top( begc:endc ),                                        &
+              dhsdT( begc:endc ),                                         &
+              sabg_lyr_col (begc:endc, -nlevsno+1: ),                     &
+              fact( begc:endc, -nlevsno+1: ),                             &
+              fn( begc:endc, -nlevsno+1: ),                               &
+              fn_h2osfc( begc:endc ),                                     &
+              c_h2osfc( begc:endc ),                                      &
+              frac_sno_eff(begc:endc),                                    &
+              t_soisno( begc:endc, -nlevsno+1: ),                         &
+              rt( begc:endc, 1: ))
+      endif
+
+      call SetRHSVec_Soil_StandingSurfaceWater(bounds, num_filter, filter, &
+           hs_top_snow( begc:endc ),                                                &
+           hs_soil( begc:endc ),                                                    &
+           hs_top( begc:endc ),                                                     &
+           dhsdT( begc:endc ),                                                      &
+           sabg_lyr_col (begc:endc, -nlevsno+1: ),                                  &
+           fact( begc:endc, -nlevsno+1: ),                                          &
+           fn( begc:endc, -nlevsno+1: ),                                            &
+           fn_h2osfc( begc:endc ),                                                  &
+           c_h2osfc( begc:endc ),                                                   &
+           frac_h2osfc(begc:endc),                                                  &
+           t_soisno( begc:endc, -nlevsno+1: ),                                      &
+           rt( begc:endc, 1: ))
+
+    end associate
+
+  end subroutine SetRHSVec_Soil
+
+  !-----------------------------------------------------------------------
+  subroutine SetRHSVec_SoilUrban(bounds, num_filter, filter, &
+       hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, fn_h2osfc, c_h2osfc, &
+       frac_sno_eff, t_soisno, rt)
+    !
+    ! !DESCRIPTION:
+    ! Sets up RHS vector corresponding to soil layers for urban columns
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                                     ! bounds
+    integer , intent(in)  :: num_filter                                         ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                          ! column filter
+    real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
+    real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
+    real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
+    real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
+    real(r8), intent(in)  :: fn_h2osfc (bounds%begc: )                          ! heat diffusion through standing-water/soil interface [W/m2]
+    real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
+    real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                        ! fraction of ground covered by snow (0 to 1)
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
+    real(r8), intent(inout) :: rt(bounds%begc: ,1: )                            ! rhs vector entries
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,l                                                           ! indices
+    integer  :: fc                                                              ! lake filtered column indices
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(                                      &
+         begc =>    bounds%begc                   , & ! Input:  [integer ] beginning column index
+         endc =>    bounds%endc                     & ! Input:  [integer ] ending column index
+         )
+
+      call SetRHSVec_SoilUrbanNonRoad(bounds, num_filter, filter, &
+           hs_top_snow( begc:endc ),                                       &
+           hs_soil( begc:endc ),                                           &
+           hs_top( begc:endc ),                                            &
+           dhsdT( begc:endc ),                                             &
+           sabg_lyr_col (begc:endc, -nlevsno+1: ),                         &
+           fact( begc:endc, -nlevsno+1: ),                                 &
+           fn( begc:endc, -nlevsno+1: ),                                   &
+           fn_h2osfc( begc:endc ),                                         &
+           c_h2osfc( begc:endc ),                                          &
+           t_soisno( begc:endc, -nlevsno+1: ),                             &
+           rt( begc:endc, 1: ))
+
+      call SetRHSVec_SoilUrbanRoad(bounds, num_filter, filter, &
+           hs_top_snow( begc:endc ),                                    &
+           hs_soil( begc:endc ),                                        &
+           hs_top( begc:endc ),                                         &
+           dhsdT( begc:endc ),                                          &
+           sabg_lyr_col (begc:endc, -nlevsno+1: ),                      &
+           fact( begc:endc, -nlevsno+1: ),                              &
+           fn( begc:endc, -nlevsno+1: ),                                &
+           fn_h2osfc( begc:endc ),                                      &
+           c_h2osfc( begc:endc ),                                       &
+           frac_sno_eff( begc:endc ),                                   &
+           t_soisno( begc:endc, -nlevsno+1: ),                          &
+           rt( begc:endc, 1: ))
+
+    end associate
+
+  end subroutine SetRHSVec_SoilUrban
+
+  !-----------------------------------------------------------------------
+  subroutine SetRHSVec_SoilUrbanNonRoad(bounds, num_filter, filter, &
+       hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, fn_h2osfc, c_h2osfc, &
+       t_soisno, rt)
+    !
+    ! !DESCRIPTION:
+    ! Sets up RHS vector corresponding to soil layers for urban sunwall/shadewall/roof columns
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon      , only : cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                                     ! bounds
+    integer , intent(in)  :: num_filter                                         ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                          ! column filter
+    real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
+    real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
+    real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
+    real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
+    real(r8), intent(in)  :: fn_h2osfc (bounds%begc: )                          ! heat diffusion through standing-water/soil interface [W/m2]
+    real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
+    real(r8), intent(inout) :: rt(bounds%begc: ,1: )                            ! rhs vector entries
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,l                                                           ! indices
+    integer  :: fc                                                              ! lake filtered column indices
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(                                      &
+         z        => col_pp%z                          & ! Input: [real(r8) (:,:) ]  layer thickness (m)
+         )
+
+      !
+      ! urban columns ------------------------------------------------------------------
+      !
+      do j = 1,nlevurb
+         do fc = 1,num_filter
+            c = filter(fc)
+            l = col_pp%landunit(c)
+            if (lun_pp%urbpoi(l)) then
+               if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
+                    .or. col_pp%itype(c) == icol_roof)) then
+                  if (j >= col_pp%snl(c)+1) then
+                     if (j == col_pp%snl(c)+1) then
+                        ! changed hs to hs_top
+                        rt(c,j) = t_soisno(c,j) +  fact(c,j)*( hs_top(c) - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
+                     else if (j <= nlevurb-1) then
+                        ! if this is a snow layer or the top soil layer,
+                        ! add absorbed solar flux to factor 'rt'
+                        if (j == 1) then
+                           rt(c,j) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
+                           rt(c,j) = rt(c,j) + (fact(c,j)*sabg_lyr_col(c,j))
+                        else
+                           rt(c,j) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
+                        endif
+
+                     else if (j == nlevurb) then
+                        ! For urban sunwall, shadewall, and roof columns, there is a non-zero heat flux across
+                        ! the bottom "soil" layer and the equations are derived assuming a prescribed internal
+                        ! building temperature. (See Oleson urban notes of 6/18/03).
+                        rt(c,j) = t_soisno(c,j) + fact(c,j)*( fn(c,j) - cnfac*fn(c,j-1) )
+                     end if
+                  end if
+               end if
+            end if
+         enddo
+      end do
+
+    end associate
+
+  end subroutine SetRHSVec_SoilUrbanNonRoad
 
   !-----------------------------------------------------------------------
-  subroutine SetRHSVec_SnowUrbanRoad(bounds, num_filter, filter, &
-       hs_top_snow, hs_top, dhsdT, sabg_lyr_col, &
-       fact, fn, t_soisno, t_h2osfc, rt)
+  subroutine SetRHSVec_SoilUrbanRoad(bounds, num_filter, filter, &
+       hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, fn_h2osfc, c_h2osfc, &
+       frac_sno_eff, t_soisno, rt)
     !
     ! !DESCRIPTION:
-    ! Sets up RHS vector corresponding to snow layers for urban road
+    ! Sets up RHS vector corresponding to soil layers for urban road
     ! (impervious + pervious) columns
     !
     ! !USES:
-    use elm_varcon     , only : cnfac
+      !$acc routine seq
+    use elm_varcon      , only : cnfac
     use column_varcon  , only : icol_road_perv, icol_road_imperv
-    use elm_varpar     , only : nlevsno, nlevgrnd
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
     !
     ! !ARGUMENTS:
     implicit none
-    type(bounds_type), intent(in) :: bounds                             ! bounds
-    integer , intent(in)  :: num_filter                                 ! number of column the in filter
-    integer , intent(in)  :: filter(:)                                  ! column filter
-    real(r8), intent(in)  :: hs_top_snow( bounds%begc: )                ! heat flux on top snow layer [W/m2]
-    real(r8), intent(in)  :: hs_top( bounds%begc: )                     ! net energy flux into surface layer (col) [W/m2]
-    real(r8), intent(in)  :: dhsdT( bounds%begc: )                      ! temperature derivative of "hs" [col]
-    real(r8), intent(in)  :: sabg_lyr_col( bounds%begc: , -nlevsno+1: ) ! absorbed solar radiation (col,lyr) [W/m2]
-    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )         ! used in computing tridiagonal matrix [col, lev]
-    real(r8), intent(in)  :: fn (bounds%begc: , -nlevsno+1: )           ! heat diffusion through the layer interface [W/m2]
-    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)        ! soil temperature (Kelvin)
-    real(r8), intent(in)  :: t_h2osfc(bounds%begc: )                    ! surface water temperature (Kelvin)
-    real(r8), intent(inout) :: rt(bounds%begc: , -nlevsno: )            ! rhs vector entries
+    type(bounds_type), intent(in) :: bounds                                     ! bounds
+    integer , intent(in)  :: num_filter                                         ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                          ! column filter
+    real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
+    real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
+    real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
+    real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
+    real(r8), intent(in)  :: fn_h2osfc (bounds%begc: )                          ! heat diffusion through standing-water/soil interface [W/m2]
+    real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
+    real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                        ! fraction of ground covered by snow (0 to 1)
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
+    real(r8), intent(inout) :: rt(bounds%begc: ,1: )                            ! rhs vector entries
     !
     ! !LOCAL VARIABLES:
-    integer  :: j,c,l                                                   ! indices
-    integer  :: fc                                                      ! lake filtered column indices
-    real(r8) :: dzm                                                     ! used in computing tridiagonal matrix
-    real(r8) :: dzp                                                     ! used in computing tridiagonal matrix
+    integer  :: j,c,l                                                           ! indices
+    integer  :: fc                                                              ! lake filtered column indices
     !-----------------------------------------------------------------------
 
     ! Enforce expected array sizes
 
-    associate(         &
-         z  => col_pp%z   & ! Input: [real(r8) (:,:) ]  layer thickness (m)
+    associate(                                              &
+         z            => col_pp%z                              & ! Input: [real(r8) (:,:) ]  layer thickness (m)
          )
 
       !
       ! urban road columns -------------------------------------------------------------
       !
-      !$acc parallel loop independent gang default(present)
-      do j = -nlevsno+1,0
-         !$acc loop vector independent 
+      do j = 1,nlevgrnd
          do fc = 1,num_filter
             c = filter(fc)
             l = col_pp%landunit(c)
             if (lun_pp%urbpoi(l)) then
                if (col_pp%itype(c) == icol_road_imperv .or. col_pp%itype(c) == icol_road_perv) then
-                  if (j >= col_pp%snl(c)+1) then
-                     if (j == col_pp%snl(c)+1) then
-                        dzp     = z(c,j+1)-z(c,j)
-                        rt(c,j-1) = t_soisno(c,j) +  fact(c,j)*( hs_top_snow(c) &
-                             - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
-                     else
-                        dzm     = (z(c,j)-z(c,j-1))
-                        dzp     = (z(c,j+1)-z(c,j))
+                  if (j == col_pp%snl(c)+1) then
+                     rt(c,j) = t_soisno(c,j) +  fact(c,j)*( hs_top_snow(c) &
+                          - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
+                  else if (j == 1) then
+                     ! this is the snow/soil interface layer
+                     rt(c,j) = t_soisno(c,j) + fact(c,j) &
+                          *((1._r8-frac_sno_eff(c))*(hs_soil(c) - dhsdT(c)*t_soisno(c,j)) &
+                          + cnfac*(fn(c,j) - frac_sno_eff(c) * fn(c,j-1)))
 
-                        rt(c,j-1) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
-                        rt(c,j-1) = rt(c,j-1) + fact(c,j)*sabg_lyr_col(c,j)
+                     rt(c,j) = rt(c,j) +  frac_sno_eff(c)*fact(c,j)*sabg_lyr_col(c,j)
 
-                     end if
+                  else if (j <= nlevgrnd-1) then
+                     rt(c,j) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
+
+                  else if (j == nlevgrnd) then
+                     rt(c,j) = t_soisno(c,j) - cnfac*fact(c,j)*fn(c,j-1) + fact(c,j)*fn(c,j)
                   end if
                end if
             end if
@@ -2486,72 +2857,75 @@ end subroutine SetRHSVec_Snow
 
     end associate
 
-  end subroutine SetRHSVec_SnowUrbanRoad
+  end subroutine SetRHSVec_SoilUrbanRoad
 
   !-----------------------------------------------------------------------
-  subroutine SetRHSVec_SnowNonUrban(bounds, num_filter, filter, &
-       hs_top_snow, hs_top, dhsdT, sabg_lyr_col, &
-       fact, fn, t_soisno, rt)
-
+  subroutine SetRHSVec_SoilNonUrban(bounds, num_filter, filter, &
+       hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, fn_h2osfc, c_h2osfc, &
+       frac_sno_eff, t_soisno, rt)
     !
     ! !DESCRIPTION:
-    ! Sets up RHS vector corresponding to snow layers for non-urban columns
+    ! Sets up RHS vector corresponding to soil layers.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
-    use elm_varpar     , only : nlevsno, nlevgrnd
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
     !
     ! !ARGUMENTS:
     implicit none
-    type(bounds_type), intent(in) :: bounds                             ! bounds
-    integer , intent(in)  :: num_filter                                 ! number of column the in filter
-    integer , intent(in)  :: filter(:)                                  ! column filter
-    real(r8), intent(in)  :: hs_top_snow( bounds%begc: )                ! heat flux on top snow layer [W/m2]
-    real(r8), intent(in)  :: hs_top( bounds%begc: )                     ! net energy flux into surface layer (col) [W/m2]
-    real(r8), intent(in)  :: dhsdT( bounds%begc: )                      ! temperature derivative of "hs" [col]
-    real(r8), intent(in)  :: sabg_lyr_col( bounds%begc: , -nlevsno+1: ) ! absorbed solar radiation (col,lyr) [W/m2]
-    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )         ! used in computing tridiagonal matrix [col, lev]
-    real(r8), intent(in)  :: fn (bounds%begc: , -nlevsno+1: )           ! heat diffusion through the layer interface [W/m2]
-    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)        ! soil temperature (Kelvin)
-    real(r8), intent(inout) :: rt(bounds%begc: , -nlevsno: )            ! rhs vector entries
+    type(bounds_type), intent(in) :: bounds                                     ! bounds
+    integer , intent(in)  :: num_filter                                         ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                          ! column filter
+    real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
+    real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
+    real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
+    real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
+    real(r8), intent(in)  :: fn_h2osfc (bounds%begc: )                          ! heat diffusion through standing-water/soil interface [W/m2]
+    real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
+    real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                        ! fractional area with surface water greater than zero
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
+    real(r8), intent(inout) :: rt(bounds%begc: ,1: )                            ! rhs vector entries
     !
     ! !LOCAL VARIABLES:
-    integer  :: j,c,l                                                   ! indices
-    integer  :: fc                                                      ! lake filtered column indices
-    real(r8) :: dzm                                                     ! used in computing tridiagonal matrix
-    real(r8) :: dzp                                                     ! used in computing tridiagonal matrix
+    integer  :: j,c,l                                                           ! indices
+    integer  :: fc                                                              ! lake filtered column indices
     !-----------------------------------------------------------------------
 
     ! Enforce expected array sizes
 
     associate(       &
-         z => col_pp%z  & ! Input: [real(r8) (:,:) ]  layer thickness (m)
+         z  => col_pp%z & ! Input:  [real(r8) (:,:)]  layer thickness (m)
          )
 
       !
       ! non-urban columns --------------------------------------------------------------
       !
-      !$acc parallel loop independent gang vector default(present) collapse(2) 
-      do j = -nlevsno+1,0
+      do j = 1,nlevgrnd
          do fc = 1,num_filter
             c = filter(fc)
             l = col_pp%landunit(c)
             if (.not. lun_pp%urbpoi(l)) then
-               if (j >= col_pp%snl(c)+1) then
-                  if (j == col_pp%snl(c)+1) then
-                     dzp     = z(c,j+1)-z(c,j)
-                     rt(c,j-1) = t_soisno(c,j) +  fact(c,j)*( hs_top_snow(c) &
-                          - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
+               if (j == col_pp%snl(c)+1) then
+                  rt(c,j) = t_soisno(c,j) +  fact(c,j)*( hs_top_snow(c) &
+                       - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
+               else if (j == 1) then
+                  ! this is the snow/soil interface layer
+                  rt(c,j) = t_soisno(c,j) + fact(c,j) &
+                       *((1._r8-frac_sno_eff(c))*(hs_soil(c) - dhsdT(c)*t_soisno(c,j)) &
+                       + cnfac*(fn(c,j) - frac_sno_eff(c) * fn(c,j-1)))
 
-                  else
-                     dzm     = (z(c,j)-z(c,j-1))
-                     dzp     = (z(c,j+1)-z(c,j))
-                      
-                     rt(c,j-1) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
-                     rt(c,j-1) = rt(c,j-1) + fact(c,j)*sabg_lyr_col(c,j)
+                  rt(c,j) = rt(c,j) +  frac_sno_eff(c)*fact(c,j)*sabg_lyr_col(c,j)
 
-                  end if
+               else if (j <= nlevgrnd-1) then
+                  rt(c,j) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
+
+               else if (j == nlevgrnd) then
+                  rt(c,j) = t_soisno(c,j) - cnfac*fact(c,j)*fn(c,j-1) + fact(c,j)*fn(c,j)
                end if
             end if
          enddo
@@ -2559,400 +2933,60 @@ end subroutine SetRHSVec_Snow
 
     end associate
 
-  end subroutine SetRHSVec_SnowNonUrban
-
+  end subroutine SetRHSVec_SoilNonUrban
 
   !-----------------------------------------------------------------------
-  subroutine SetRHSVec_Soil(bounds, num_filter, filter, &
-   hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, c_h2osfc, &
-   frac_h2osfc, frac_sno_eff, t_soisno, urban_column, rt)
-!
-! !DESCRIPTION:
-! Sets up RHS vector corresponding to soil layers
-!
-! !USES:
-use elm_varcon     , only : cnfac
-use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
-use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
-!
-! !ARGUMENTS:
-implicit none
-type(bounds_type), intent(in) :: bounds                                     ! bounds
-integer , intent(in)  :: num_filter                                         ! number of column the in filter
-integer , intent(in)  :: filter(:)                                          ! column filter
-real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
-real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
-real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
-real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
-real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
-real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
-real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
-real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
-real(r8), intent(in)  :: frac_h2osfc(bounds%begc: )                         ! fractional area with surface water greater than zero
-real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                        ! fraction of ground covered by snow (0 to 1)
-real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
-logical , intent(in)  :: urban_column                                       ! Is true if solving temperature for urban column, otherwise false
-real(r8), intent(inout) :: rt(bounds%begc: ,1: )                              ! rhs vector entries
-!-----------------------------------------------------------------------
-
-! Enforce expected array sizes
-
-associate(&
-     begc     => bounds%begc  , & ! Input:  [integer ] beginning column index
-     endc     => bounds%endc    & ! Input:  [integer ] ending column index
-     )
-
-  if (urban_column) then
-     call SetRHSVec_SoilUrban(bounds, num_filter, filter, &
-          hs_top_snow( begc:endc ),                                &
-          hs_soil( begc:endc ),                                    &
-          hs_top( begc:endc ),                                     &
-          dhsdT( begc:endc ),                                      &
-          sabg_lyr_col (begc:endc, -nlevsno+1: ),                  &
-          fact( begc:endc, -nlevsno+1: ),                          &
-          fn( begc:endc, -nlevsno+1: ),                            &
-          c_h2osfc( begc:endc ),                                   &
-          frac_sno_eff( begc:endc ),                               &
-          t_soisno( begc:endc, -nlevsno+1: ),                      &
-          rt( begc:endc, 1: ))
-  else
-     call SetRHSVec_SoilNonUrban(bounds, num_filter, filter, &
-          hs_top_snow( begc:endc ),                                   &
-          hs_soil( begc:endc ),                                       &
-          hs_top( begc:endc ),                                        &
-          dhsdT( begc:endc ),                                         &
-          sabg_lyr_col (begc:endc, -nlevsno+1: ),                     &
-          fact( begc:endc, -nlevsno+1: ),                             &
-          fn( begc:endc, -nlevsno+1: ),                               &
-          c_h2osfc( begc:endc ),                                      &
-          frac_sno_eff(begc:endc),                                    &
-          t_soisno( begc:endc, -nlevsno+1: ),                         &
-          rt( begc:endc, 1: ))
-  endif
-
- ! call SetRHSVec_Soil_StandingSurfaceWater(bounds, num_filter, filter, &
- !      hs_top_snow( begc:endc ),                                       &
- !      hs_soil( begc:endc ),                                           &
- !      hs_top( begc:endc ),                                            &
- !      dhsdT( begc:endc ),                                             &
- !      sabg_lyr_col (begc:endc, -nlevsno+1: ),                         &
- !      fact( begc:endc, -nlevsno+1: ),                                 &
- !      fn( begc:endc, -nlevsno+1: ),                                   &
- !      fn_h2osfc( 1:num_filter ),                                      &
- !      c_h2osfc( begc:endc ),                                          &
- !      frac_h2osfc(begc:endc),                                         &
- !      t_soisno( begc:endc, -nlevsno+1: ),                             &
- !      rt( begc:endc, 1: ))
-
-end associate
-
-end subroutine SetRHSVec_Soil
-
-!-----------------------------------------------------------------------
-subroutine SetRHSVec_SoilUrban(bounds, num_filter, filter, &
-   hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, c_h2osfc, &
-   frac_sno_eff, t_soisno, rt)
-!
-! !DESCRIPTION:
-! Sets up RHS vector corresponding to soil layers for urban columns
-!
-! !USES:
-use elm_varcon     , only : cnfac
-use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
-use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
-!
-! !ARGUMENTS:
-implicit none
-type(bounds_type), intent(in) :: bounds                                     ! bounds
-integer , intent(in)  :: num_filter                                         ! number of column the in filter
-integer , intent(in)  :: filter(:)                                          ! column filter
-real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
-real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
-real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
-real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
-real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
-real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
-real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
-real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
-real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                        ! fraction of ground covered by snow (0 to 1)
-real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
-real(r8), intent(inout) :: rt(bounds%begc: ,1: )                            ! rhs vector entries
-!
-! !LOCAL VARIABLES:
-integer  :: j,c,l                                                           ! indices
-integer  :: fc                                                              ! lake filtered column indices
-!-----------------------------------------------------------------------
-
-! Enforce expected array sizes
-
-associate(                                      &
-     begc =>    bounds%begc                   , & ! Input:  [integer ] beginning column index
-     endc =>    bounds%endc                     & ! Input:  [integer ] ending column index
-     )
-
-  call SetRHSVec_SoilUrbanNonRoad(bounds, num_filter, filter, &
-       hs_top_snow( begc:endc ),                                       &
-       hs_soil( begc:endc ),                                           &
-       hs_top( begc:endc ),                                            &
-       dhsdT( begc:endc ),                                             &
-       sabg_lyr_col (begc:endc, -nlevsno+1: ),                         &
-       fact( begc:endc, -nlevsno+1: ),                                 &
-       fn( begc:endc, -nlevsno+1: ),                                   &
-       c_h2osfc( begc:endc ),                                          &
-       t_soisno( begc:endc, -nlevsno+1: ),                             &
-       rt( begc:endc, 1: ))
-
-  call SetRHSVec_SoilUrbanRoad(bounds, num_filter, filter, &
-       hs_top_snow( begc:endc ),                                    &
-       hs_soil( begc:endc ),                                        &
-       hs_top( begc:endc ),                                         &
-       dhsdT( begc:endc ),                                          &
-       sabg_lyr_col (begc:endc, -nlevsno+1: ),                      &
-       fact( begc:endc, -nlevsno+1: ),                              &
-       fn( begc:endc, -nlevsno+1: ),                                &
-       c_h2osfc( begc:endc ),                                       &
-       frac_sno_eff( begc:endc ),                                   &
-       t_soisno( begc:endc, -nlevsno+1: ),                          &
-       rt( begc:endc, 1: ))
-
-end associate
-
-end subroutine SetRHSVec_SoilUrban
-
-!-----------------------------------------------------------------------
-subroutine SetRHSVec_SoilUrbanNonRoad(bounds, num_filter, filter, &
-   hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, c_h2osfc, &
-   t_soisno, rt)
-!
-! !DESCRIPTION:
-! Sets up RHS vector corresponding to soil layers for urban sunwall/shadewall/roof columns
-!
-! !USES:
-use elm_varcon     , only : cnfac
-use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
-use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
-!
-! !ARGUMENTS:
-implicit none
-type(bounds_type), intent(in) :: bounds                                     ! bounds
-integer , intent(in)  :: num_filter                                         ! number of column the in filter
-integer , intent(in)  :: filter(:)                                          ! column filter
-real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
-real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
-real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
-real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
-real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
-real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
-real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
-real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
-real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
-real(r8), intent(inout) :: rt(bounds%begc: ,1: )                            ! rhs vector entries
-!
-! !LOCAL VARIABLES:
-integer  :: j,c,l                                                           ! indices
-integer  :: fc                                                              ! lake filtered column indices
-!-----------------------------------------------------------------------
-! Enforce expected array sizes
-
-associate(                                      &
-     z        => col_pp%z                          & ! Input: [real(r8) (:,:) ]  layer thickness (m)
-     )
+  subroutine SetRHSVec_Soil_StandingSurfaceWater(bounds, num_filter, filter, &
+       hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, fn_h2osfc, c_h2osfc, &
+       frac_h2osfc, t_soisno, rt)
+    !
+    ! !DESCRIPTION:
+    ! Sets up RHS vector corresponding to soil layers.
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                                     ! bounds
+    integer , intent(in)  :: num_filter                                         ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                          ! column filter
+    real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
+    real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
+    real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
+    real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
+    real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
+    real(r8), intent(in)  :: fn_h2osfc (bounds%begc: )                          ! heat diffusion through standing-water/soil interface [W/m2]
+    real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
+    real(r8), intent(in)  :: frac_h2osfc(bounds%begc: )                         ! fractional area with surface water greater than zero
+    real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
+    real(r8), intent(inout) :: rt(bounds%begc: ,1: )                            ! rhs vector entries
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,l                                                           ! indices
+    integer  :: fc                                                              ! lake filtered column indices
+    !-----------------------------------------------------------------------
 
-  !
-  ! urban columns ------------------------------------------------------------------
-  !
-  !$acc parallel loop independent gang default(present) 
-  do j = 1,nlevurb
-     !$acc loop vector independent 
-     do fc = 1,num_filter
-        c = filter(fc)
-        l = col_pp%landunit(c)
-        if (lun_pp%urbpoi(l)) then
-           if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
-                .or. col_pp%itype(c) == icol_roof)) then
-              if (j >= col_pp%snl(c)+1) then
-                 if (j == col_pp%snl(c)+1) then
-                    ! changed hs to hs_top
-                    rt(c,j) = t_soisno(c,j) +  fact(c,j)*( hs_top(c) - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
-                 else if (j <= nlevurb-1) then
-                    ! if this is a snow layer or the top soil layer,
-                    ! add absorbed solar flux to factor 'rt'
-                    if (j == 1) then
-                       rt(c,j) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
-                       rt(c,j) = rt(c,j) + (fact(c,j)*sabg_lyr_col(c,j))
-                    else
-                       rt(c,j) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
-                    endif
-
-                 else if (j == nlevurb) then
-                    ! For urban sunwall, shadewall, and roof columns, there is a non-zero heat flux across
-                    ! the bottom "soil" layer and the equations are derived assuming a prescribed internal
-                    ! building temperature. (See Oleson urban notes of 6/18/03).
-                    rt(c,j) = t_soisno(c,j) + fact(c,j)*( fn(c,j) - cnfac*fn(c,j-1) )
-                 end if
-              end if
-           end if
-        end if
-     enddo
-  end do
-
-end associate
-
-end subroutine SetRHSVec_SoilUrbanNonRoad
-
-!-----------------------------------------------------------------------
-subroutine SetRHSVec_SoilUrbanRoad(bounds, num_filter, filter, &
-   hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, c_h2osfc, &
-   frac_sno_eff, t_soisno, rt)
-!
-! !DESCRIPTION:
-! Sets up RHS vector corresponding to soil layers for urban road
-! (impervious + pervious) columns
-!
-! !USES:
-use elm_varcon      , only : cnfac
-use column_varcon  , only : icol_road_perv, icol_road_imperv
-use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
-!
-! !ARGUMENTS:
-implicit none
-type(bounds_type), intent(in) :: bounds                                     ! bounds
-integer , intent(in)  :: num_filter                                         ! number of column the in filter
-integer , intent(in)  :: filter(:)                                          ! column filter
-real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
-real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
-real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
-real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
-real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
-real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
-real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
-real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
-real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                        ! fraction of ground covered by snow (0 to 1)
-real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
-real(r8), intent(inout) :: rt(bounds%begc: ,1: )                            ! rhs vector entries
-!
-! !LOCAL VARIABLES:
-integer  :: j,c,l                                                           ! indices
-integer  :: fc                                                              ! lake filtered column indices
-!-----------------------------------------------------------------------
-! Enforce expected array sizes
-
-associate(                      &
-     z            => col_pp%z   & ! Input: [real(r8) (:,:) ]  layer thickness (m)
-     )
+    ! Enforce expected array sizes
 
-  !
-  ! urban road columns -------------------------------------------------------------
-  !
-  !$acc parallel loop independent gang default(present) 
-  do j = 1,nlevgrnd
-     !$acc loop vector independent 
-     do fc = 1,num_filter
-        c = filter(fc)
-        l = col_pp%landunit(c)
-        if (lun_pp%urbpoi(l)) then
-           if (col_pp%itype(c) == icol_road_imperv .or. col_pp%itype(c) == icol_road_perv) then
-              if (j == col_pp%snl(c)+1) then
-                 rt(c,j) = t_soisno(c,j) +  fact(c,j)*( hs_top_snow(c) &
-                      - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
-              else if (j == 1) then
-                 ! this is the snow/soil interface layer
-                 rt(c,j) = t_soisno(c,j) + fact(c,j) &
-                      *((1._r8-frac_sno_eff(c))*(hs_soil(c) - dhsdT(c)*t_soisno(c,j)) &
-                      + cnfac*(fn(c,j) - frac_sno_eff(c) * fn(c,j-1)))
-
-                 rt(c,j) = rt(c,j) +  frac_sno_eff(c)*fact(c,j)*sabg_lyr_col(c,j)
-
-              else if (j <= nlevgrnd-1) then
-                 rt(c,j) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
-
-              else if (j == nlevgrnd) then
-                 rt(c,j) = t_soisno(c,j) - cnfac*fact(c,j)*fn(c,j-1) + fact(c,j)*fn(c,j)
-              end if
-           end if
-        end if
-     enddo
-  end do
-
-end associate
-
-end subroutine SetRHSVec_SoilUrbanRoad
-
-!-----------------------------------------------------------------------
-subroutine SetRHSVec_SoilNonUrban(bounds, num_filter, filter, &
-   hs_top_snow, hs_soil, hs_top, dhsdT, sabg_lyr_col, fact, fn, c_h2osfc, &
-   frac_sno_eff, t_soisno, rt)
-!
-! !DESCRIPTION:
-! Sets up RHS vector corresponding to soil layers.
-!
-! !USES:
-use elm_varcon     , only : cnfac
-use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
-use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
-!
-! !ARGUMENTS:
-implicit none
-type(bounds_type), intent(in) :: bounds                                     ! bounds
-integer , intent(in)  :: num_filter                                         ! number of column the in filter
-integer , intent(in)  :: filter(:)                                          ! column filter
-real(r8), intent(in)  :: hs_top_snow(bounds%begc: )                         ! heat flux on top snow layer [W/m2]
-real(r8), intent(in)  :: hs_soil(bounds%begc: )                             ! heat flux on soil [W/m2]
-real(r8), intent(in)  :: hs_top(bounds%begc: )                              ! net energy flux into surface layer (col) [W/m2]
-real(r8), intent(in)  :: dhsdT(bounds%begc: )                               ! temperature derivative of "hs" [col]
-real(r8), intent(in)  :: sabg_lyr_col(bounds%begc:, -nlevsno+1: )           ! absorbed solar radiation (col,lyr) [W/m2]
-real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                 ! used in computing tridiagonal matrix [col, lev]
-real(r8), intent(in)  :: fn (bounds%begc: ,-nlevsno+1: )                    ! heat diffusion through the layer interface [W/m2]
-real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                           ! heat capacity of surface water [col]
-real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                        ! fractional area with surface water greater than zero
-real(r8), intent(in)  :: t_soisno(bounds%begc:, -nlevsno+1:)                ! soil temperature (Kelvin)
-real(r8), intent(inout) :: rt(bounds%begc: ,1: )                            ! rhs vector entries
-!
-! !LOCAL VARIABLES:
-integer  :: j,c,l                                                           ! indices
-integer  :: fc                                                              ! lake filtered column indices
-!-----------------------------------------------------------------------
-
-! Enforce expected array sizes
-
-associate(       &
-     z  => col_pp%z & ! Input:  [real(r8) (:,:)]  layer thickness (m)
-     )
+    !
+    ! surface water  -----------------------------------------------------------------
+    !
+    do fc = 1,num_filter
+       c = filter(fc)
+       if ( frac_h2osfc(c) /= 0.0_r8 )then
+          rt(c,1)=rt(c,1) &
+               -frac_h2osfc(c)*fact(c,1)*((hs_soil(c) - dhsdT(c)*t_soisno(c,1)) &
+               +cnfac*fn_h2osfc(c))
+       end if
+    end do
 
-  !
-  ! non-urban columns --------------------------------------------------------------
-  !
-  !$acc parallel loop independent gang default(present) 
-  do j = 1,nlevgrnd
-     !$acc loop vector independent 
-     do fc = 1,num_filter
-        c = filter(fc)
-        l = col_pp%landunit(c)
-        if (.not. lun_pp%urbpoi(l)) then
-           if (j == col_pp%snl(c)+1) then
-              rt(c,j) = t_soisno(c,j) +  fact(c,j)*( hs_top_snow(c) &
-                   - dhsdT(c)*t_soisno(c,j) + cnfac*fn(c,j) )
-           else if (j == 1) then
-              ! this is the snow/soil interface layer
-              rt(c,j) = t_soisno(c,j) + fact(c,j) &
-                   *((1._r8-frac_sno_eff(c))*(hs_soil(c) - dhsdT(c)*t_soisno(c,j)) &
-                   + cnfac*(fn(c,j) - frac_sno_eff(c) * fn(c,j-1)))
-
-              rt(c,j) = rt(c,j) +  frac_sno_eff(c)*fact(c,j)*sabg_lyr_col(c,j)
-
-           else if (j <= nlevgrnd-1) then
-              rt(c,j) = t_soisno(c,j) + cnfac*fact(c,j)*( fn(c,j) - fn(c,j-1) )
-
-           else if (j == nlevgrnd) then
-              rt(c,j) = t_soisno(c,j) - cnfac*fact(c,j)*fn(c,j-1) + fact(c,j)*fn(c,j)
-           end if
-        end if
-     enddo
-  end do
-
-end associate
-
-end subroutine SetRHSVec_SoilNonUrban
+  end subroutine SetRHSVec_Soil_StandingSurfaceWater
 
   !-----------------------------------------------------------------------
   subroutine SetMatrix(bounds, num_filter, filter, dtime, nband, &
@@ -2975,6 +3009,7 @@ end subroutine SetRHSVec_SoilNonUrban
     !
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -2992,7 +3027,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )                ! used in computing tridiagonal matrix [col, lev]
     real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                          ! heat capacity of surface water [col]
     real(r8), intent(in)  :: dz_h2osfc(bounds%begc: )                          ! Thickness of standing water [m]
-    real(r8), intent(inout) :: bmatrix(bounds%begc: , 1:,-nlevsno: )             ! matrix for numerical solution of temperature
+    real(r8), intent(out) :: bmatrix(bounds%begc: , 1:,-nlevsno: )             ! matrix for numerical solution of temperature
     logical, intent(in)    :: urban_column                                     ! Is true if solving temperature for urban column, otherwise false
     !
     ! !LOCAL VARIABLES:
@@ -3030,13 +3065,13 @@ end subroutine SetRHSVec_SoilNonUrban
            fact( begc:endc, -nlevsno+1: ),                            &
            frac_sno_eff(begc:endc),                                   &
            urban_column,                                              &
-           bmatrix( begc:endc, 1:, -nlevsno: ))
+           bmatrix_snow( begc:endc, 1:, -nlevsno: ))
 
       call SetMatrix_Snow_Soil(bounds, num_filter, filter, nband, &
            tk( begc:endc, -nlevsno+1: ),                                   &
            fact( begc:endc, -nlevsno+1: ),                                 &
            urban_column,                                                   &
-           bmatrix( begc:endc, 1:, -1: ))
+           bmatrix_snow_soil( begc:endc, 1:, -1: ))
 
       call SetMatrix_Soil(bounds, num_filter, filter, nband, &
            dhsdT( begc:endc ),                                        &
@@ -3047,14 +3082,14 @@ end subroutine SetRHSVec_SoilNonUrban
            frac_h2osfc(begc:endc),                                    &
            frac_sno_eff(begc:endc),                                   &
            urban_column,                                              &
-           bmatrix( begc:endc, 1:, 1: ))
+           bmatrix_soil( begc:endc, 1:, 1: ))
 
       call SetMatrix_Soil_Snow(bounds, num_filter, filter, nband, &
            tk( begc:endc, -nlevsno+1: ),                                   &
            fact( begc:endc, -nlevsno+1: ),                                 &
            frac_sno_eff(begc:endc),                                        &
            urban_column,                                                   &
-           bmatrix( begc:endc, 1:, 1: ))
+           bmatrix_soil_snow( begc:endc, 1:, 1: ))
 
       call SetMatrix_StandingSurfaceWater(bounds, num_filter, filter, dtime, nband, &
            dhsdT( begc:endc ),                                                               &
@@ -3063,7 +3098,7 @@ end subroutine SetRHSVec_SoilNonUrban
            fact( begc:endc, -nlevsno+1: ),                                                   &
            c_h2osfc( begc:endc ),                                                            &
            dz_h2osfc( begc:endc ),                                                           &
-           bmatrix( begc:endc, 1:, 0: ))
+           bmatrix_ssw( begc:endc, 1:, 0: ))
 
       call SetMatrix_StandingSurfaceWater_Soil(bounds, num_filter, filter, dtime, nband, &
            tk( begc:endc, -nlevsno+1: ),                                                          &
@@ -3071,19 +3106,140 @@ end subroutine SetRHSVec_SoilNonUrban
            fact( begc:endc, -nlevsno+1: ),                                                        &
            c_h2osfc( begc:endc ),                                                                 &
            dz_h2osfc( begc:endc ),                                                                &
-           bmatrix( begc:endc, 1:, 0: ))
+           bmatrix_ssw_soil( begc:endc, 1:, 0: ))
 
       call SetMatrix_Soil_StandingSurfaceWater(bounds, num_filter, filter, nband, &
            tk_h2osfc( begc:endc ),                                                         &
            fact( begc:endc, -nlevsno+1: ),                                                 &
            dz_h2osfc( begc:endc ),                                                         &
            frac_h2osfc(begc:endc),                                                         &
-           bmatrix( begc:endc, 1:, 1: ))
+           bmatrix_soil_ssw( begc:endc, 1:, 1: ))
+
+      call AssembleMatrixFromSubmatrices(bounds, num_filter, filter, nband, &
+           bmatrix_snow( begc:endc, 1:, -nlevsno: ),                                 &
+           bmatrix_ssw( begc:endc, 1:, 0: ),                                         &
+           bmatrix_soil( begc:endc, 1:, 1: ),                                        &
+           bmatrix_snow_soil( begc:endc, 1:, -1: ),                                  &
+           bmatrix_ssw_soil( begc:endc, 1:, 0: ),                                    &
+           bmatrix_soil_snow( begc:endc, 1:, 1: ),                                   &
+           bmatrix_soil_ssw( begc:endc, 1:, 1: ),                                    &
+           bmatrix( begc:endc, 1:, -nlevsno: ))
+
 
     end associate
 
   end subroutine SetMatrix
 
+  !-----------------------------------------------------------------------
+  subroutine AssembleMatrixFromSubmatrices(bounds, num_filter, filter, nband, &
+       bmatrix_snow, bmatrix_ssw, bmatrix_soil, bmatrix_snow_soil, &
+       bmatrix_ssw_soil, bmatrix_soil_snow, bmatrix_soil_ssw, bmatrix)
+
+    !
+    ! !DESCRIPTION:
+    ! Assemble the full matrix from submatrices.
+    !
+    ! Non-zero pattern of bmatrix:
+    !
+    !        SNOW-LAYERS
+    !            |
+    !            |  STANDING-SURFACE-WATER
+    !            |         |
+    !            |         |              SOIL-LAYERS
+    !            |         |                  |
+    !            v         v                  v
+    !
+    !      -5 -4 -3 -2 -1| 0| 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
+    !      ==============================================================
+    !  -5 | x  x         |  |                                            |
+    !  -4 | x  x  x      |  |                                            |
+    !  -3 |    x  x  x   |  |                                            |
+    !  -2 |       x  x  x|  |                                            |
+    !  -1 |          x  x|  | x                                          |
+    !      ==============================================================
+    !   0 |              | x| x                                          |
+    !      ==============================================================
+    !   1 |             x| x| x  x                                       |
+    !   2 |              |  | x  x  x                                    |
+    !   3 |              |  |    x  x  x                                 |
+    !   4 |              |  |       x  x  x                              |
+    !   5 |              |  |          x  x  x                           |
+    !   6 |              |  |             x  x  x                        |
+    !   7 |              |  |                x  x  x                     |
+    !   8 |              |  |                   x  x  x                  |
+    !   9 |              |  |                      x  x  x               |
+    !  10 |              |  |                         x  x  x            |
+    !  11 |              |  |                            x  x  x         |
+    !  12 |              |  |                               x  x  x      |
+    !  13 |              |  |                                  x  x  x   |
+    !  14 |              |  |                                     x  x  x|
+    !  15 |              |  |                                        x  x|
+    !      ==============================================================
+    !
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon      , only : cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                                                 ! bounds
+    integer , intent(in)  :: num_filter                                                     ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                                      ! column filter
+    integer , intent(in)  :: nband                                                          ! number of bands of the tridigonal matrix
+    real(r8), intent(in)  :: bmatrix_snow(bounds%begc:bounds%endc,nband,-nlevsno:-1      )  ! block-diagonal matrix for snow layers
+    real(r8), intent(in)  :: bmatrix_ssw(bounds%begc:bounds%endc,nband,       0:0       )   ! block-diagonal matrix for standing surface water
+    real(r8), intent(in)  :: bmatrix_soil(bounds%begc:bounds%endc,nband,       1:nlevgrnd)  ! block-diagonal matrix for soil layers
+    real(r8), intent(in)  :: bmatrix_snow_soil(bounds%begc:bounds%endc,nband,-1:-1)         ! off-diagonal matrix for snow-soil interaction
+    real(r8), intent(in)  :: bmatrix_ssw_soil(bounds%begc:bounds%endc,nband, 0:0 )          ! off-diagonal matrix for standing surface water-soil interaction
+    real(r8), intent(in)  :: bmatrix_soil_snow(bounds%begc:bounds%endc,nband, 1:1 )         ! off-diagonal matrix for soil-snow interaction
+    real(r8), intent(in)  :: bmatrix_soil_ssw(bounds%begc:bounds%endc,nband, 1:1 )          ! off-diagonal matrix for soil-standing surface water interaction
+    real(r8), intent(out) :: bmatrix(bounds%begc: , 1:,-nlevsno: )                          ! full matrix used in numerical solution of temperature
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c                                                                         ! indices
+    integer  :: fc                                                                          ! lake filtered column indices
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    ! Assemble the full matrix
+
+    bmatrix(bounds%begc:bounds%endc, :, :) = 0.0_r8
+    do fc = 1,num_filter
+       c = filter(fc)
+
+       ! Snow
+	   bmatrix(c,2:3,-nlevsno) = bmatrix_snow(c,2:3,-nlevsno)
+       bmatrix(c,2:4,-nlevsno+1:-2) = bmatrix_snow(c,2:4,-nlevsno+1:-2)
+       bmatrix(c,3:4,-1   ) = bmatrix_snow(c,3:4,-1   )
+
+       ! Snow-Soil
+       bmatrix(c,1,-1) = bmatrix_snow_soil(c,1,-1)
+
+       ! StandingSurfaceWater
+       bmatrix(c,3,0) = bmatrix_ssw(c,3,0)
+
+       ! StandingSurfaceWater-Soil
+       bmatrix(c,2,0) = bmatrix_ssw_soil(c,2,0)
+
+       ! Soil
+       bmatrix(c,2:3,1           )  = bmatrix_soil(c,2:3,1           )
+       bmatrix(c,2:4,2:nlevgrnd-1)  = bmatrix_soil(c,2:4,2:nlevgrnd-1)
+       bmatrix(c,3:4,nlevgrnd    )  = bmatrix_soil(c,3:4,nlevgrnd    )
+
+       ! Soil-Snow
+       bmatrix(c,5,1)  = bmatrix_soil_snow(c,5,1)
+
+       ! Soil-StandingSurfaceWater
+       bmatrix(c,4,1)  = bmatrix_soil_ssw(c,4,1)
+
+    end do
+
+  end subroutine AssembleMatrixFromSubmatrices
+
   !-----------------------------------------------------------------------
   subroutine SetMatrix_Snow(bounds, num_filter, filter, nband, &
        dhsdT, tk, fact, frac_sno_eff, urban_column, bmatrix_snow)
@@ -3092,6 +3248,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Setup the matrix entries corresponding to internal snow layers
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3107,7 +3264,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )           ! used in computing tridiagonal matrix [col, lev]
     real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                  ! fraction of ground covered by snow (0 to 1)
     logical , intent(in)  :: urban_column                                 ! Is true if solving temperature for urban column, otherwise false
-    real(r8), intent(inout) :: bmatrix_snow(bounds%begc: , 1:, -nlevsno: )  ! matrix enteries
+    real(r8), intent(out) :: bmatrix_snow(bounds%begc: , 1:, -nlevsno: )  ! matrix enteries
     !-----------------------------------------------------------------------
 
     ! Enforce expected array sizes
@@ -3118,6 +3275,8 @@ end subroutine SetRHSVec_SoilNonUrban
          )
 
       ! Initialize
+      bmatrix_snow(begc:endc, :, :) = 0.0_r8
+
       if (urban_column) then
          call SetMatrix_SnowUrban(bounds, num_filter, filter, nband, &
               dhsdT( begc:endc ),                                             &
@@ -3146,6 +3305,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! urban soil columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3160,77 +3320,31 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )                 ! thermal conductivity [W/(m K)]
     real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )             ! used in computing tridiagonal matrix [col, lev]
     real(r8), intent(inout) :: bmatrix_snow(bounds%begc: , 1:, -nlevsno: )  ! matrix enteries
-
-    integer  :: j,l,c,fc   ! indices
-    real(r8) :: dzm        ! used in computing tridiagonal matrix
-    real(r8) :: dzp        ! used in computing tridiagonal matrix
-
     !-----------------------------------------------------------------------
+
     ! Enforce expected array sizes
-    !
+
     associate(&
-         begc =>    bounds%begc  , & ! Input:  [integer ] beginning column index
-         endc =>    bounds%endc  , & ! Input:  [integer ] ending column index
-         z  => col_pp%z            & ! Input:  [real(r8) (:,:)]  layer thickness (m)
+         begc =>    bounds%begc                   , & ! Input:  [integer ] beginning column index
+         endc =>    bounds%endc                     & ! Input:  [integer ] ending column index
          )
 
-      !$acc parallel loop independent gang default(present)
-      do j = -nlevsno+1,0 
-         !$acc loop vector independent 
-         do fc=1,num_filter 
-            c = filter(fc) 
-            l = col_pp%landunit(c)
-            if (lun_pp%urbpoi(l)) then
-               if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
-                    .or. col_pp%itype(c) == icol_roof)) then
-                  if (j >= col_pp%snl(c)+1) then
-                     if (j == col_pp%snl(c)+1) then
-                        dzp     = z(c,j+1)-z(c,j)
-                        bmatrix_snow(c,4,j-1) = 0._r8
-                        bmatrix_snow(c,3,j-1) = 1._r8+(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp-fact(c,j)*dhsdT(c)
-                        if ( j /= 0) then
-                           bmatrix_snow(c,2,j-1) =  -(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp
-                        end if
-                     else if (j <= nlevurb-1) then
-                        dzm     = (z(c,j)-z(c,j-1))
-                        dzp     = (z(c,j+1)-z(c,j))
-                        bmatrix_snow(c,4,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j-1)/dzm
-                        bmatrix_snow(c,3,j-1) = 1._r8+ (1._r8-cnfac)*fact(c,j)*(tk(c,j)/dzp + tk(c,j-1)/dzm)
-                        if (j /= 0) then
-                           bmatrix_snow(c,2,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j)/dzp
-                        end if
-                     end if
-                  end if
-               end if
-               if (col_pp%itype(c) == icol_road_imperv .or. col_pp%itype(c) == icol_road_perv) then
-                  if (j >= col_pp%snl(c)+1) then
-                     if (j == col_pp%snl(c)+1) then
-                        dzp     = z(c,j+1)-z(c,j)
-                        bmatrix_snow(c,4,j-1) = 0._r8
-                        bmatrix_snow(c,3,j-1) = 1._r8+(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp-fact(c,j)*dhsdT(c)
-                        if ( j /= 0) then
-                           bmatrix_snow(c,2,j-1) =  -(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp
-                        end if
-                     else if (j <= nlevgrnd-1) then
-                        dzm     = (z(c,j)-z(c,j-1))
-                        dzp     = (z(c,j+1)-z(c,j))
-                        bmatrix_snow(c,4,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j-1)/dzm
-                        bmatrix_snow(c,3,j-1) = 1._r8+ (1._r8-cnfac)*fact(c,j)*(tk(c,j)/dzp + tk(c,j-1)/dzm)
-                        if ( j /= 0) then
-                           bmatrix_snow(c,2,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j)/dzp
-                        end if
-                     end if
-                  end if
-               end if
+      call SetMatrix_SnowUrbanNonRoad(bounds, num_filter, filter, nband, &
+           dhsdT( begc:endc ),                                                    &
+           tk( begc:endc, -nlevsno+1: ),                                          &
+           fact( begc:endc, -nlevsno+1: ),                                        &
+           bmatrix_snow( begc:endc, 1:, -nlevsno: ))
 
-            end if
-         end do 
-      end do 
+      call SetMatrix_SnowUrbanRoad(bounds, num_filter, filter, nband, &
+           dhsdT( begc:endc ),                                                 &
+           tk( begc:endc, -nlevsno+1: ),                                       &
+           fact( begc:endc, -nlevsno+1: ),                                     &
+           bmatrix_snow( begc:endc, 1:, -nlevsno: ))
 
     end associate
 
   end subroutine SetMatrix_SnowUrban
-  
+
   !-----------------------------------------------------------------------
   subroutine SetMatrix_SnowUrbanNonRoad(bounds, num_filter, filter, nband, &
        dhsdT, tk, fact, bmatrix_snow)
@@ -3241,6 +3355,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! urban sunwall/shadewall/roof columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3316,6 +3431,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! urban road (impervious + pervious) columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_road_perv, icol_road_imperv
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3389,6 +3505,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Setup the matrix entries corresponding to internal snow layers for non-urban columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3420,7 +3537,6 @@ end subroutine SetRHSVec_SoilNonUrban
       !
       ! non-urban landunits ------------------------------------------------------------
       !
-      !$acc parallel loop independent gang vector collapse(2) default(present)
       do j = -nlevsno+1,0
          do fc = 1,num_filter
             c = filter(fc)
@@ -3461,6 +3577,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Setup the matrix entries corresponding to snow-soil interaction
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3473,7 +3590,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )               ! thermal conductivity [W/(m K)]
     real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )           ! used in computing tridiagonal matrix [col, lev]
     logical , intent(in)  :: urban_column                                 ! Is true if solving temperature for urban column, otherwise false
-    real(r8), intent(inout) :: bmatrix_snow_soil(bounds%begc: , 1:,-1: )    ! matrix enteries
+    real(r8), intent(out) :: bmatrix_snow_soil(bounds%begc: , 1:,-1: )    ! matrix enteries
     !-----------------------------------------------------------------------
 
     ! Enforce expected array sizes
@@ -3484,6 +3601,8 @@ end subroutine SetRHSVec_SoilNonUrban
          )
 
       ! Initialize
+      bmatrix_snow_soil(begc:endc, :, :) = 0.0_r8
+
       if (urban_column) then
          call SetMatrix_Snow_SoilUrban(bounds, num_filter, filter, nband, &
               tk( begc:endc, -nlevsno+1: ),                                        &
@@ -3498,16 +3617,63 @@ end subroutine SetRHSVec_SoilNonUrban
 
     end associate
 
-  end subroutine SetMatrix_Snow_Soil
+  end subroutine SetMatrix_Snow_Soil
+
+  !-----------------------------------------------------------------------
+  subroutine SetMatrix_Snow_SoilUrban(bounds, num_filter, filter, nband, &
+       tk, fact, bmatrix_snow_soil)
+    !
+    ! !DESCRIPTION:
+    ! Setup the matrix entries corresponding to snow-soil interaction for urban columns
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                               ! bounds
+    integer , intent(in)  :: num_filter                                   ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                    ! column filter
+    integer , intent(in)  :: nband                                        ! number of bands of the tridigonal matrix
+    real(r8), intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )               ! thermal conductivity [W/(m K)]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )           ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(inout) :: bmatrix_snow_soil(bounds%begc: , 1:,-1: )  ! matrix enteries
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(&
+         begc => bounds%begc                   , & ! Input:  [integer ] beginning column index
+         endc => bounds%endc                     & ! Input:  [integer ] ending column index
+         )
+
+      call SetMatrix_Snow_SoilUrbanNonRoad(bounds, num_filter, filter, nband, &
+           tk( begc:endc, -nlevsno+1: ),                                               &
+           fact( begc:endc, -nlevsno+1: ),                                             &
+           bmatrix_snow_soil( begc:endc, 1:, -1: ))
+
+      call SetMatrix_Snow_SoilUrbanRoad(bounds, num_filter, filter, nband, &
+           tk( begc:endc, -nlevsno+1: ),                                            &
+           fact( begc:endc, -nlevsno+1: ),                                          &
+           bmatrix_snow_soil( begc:endc, 1:, -1: ))
+
+    end associate
+
+  end subroutine SetMatrix_Snow_SoilUrban
 
   !-----------------------------------------------------------------------
-  subroutine SetMatrix_Snow_SoilUrban(bounds, num_filter, filter, nband, &
+  subroutine SetMatrix_Snow_SoilUrbanNonRoad(bounds, num_filter, filter, nband, &
        tk, fact, bmatrix_snow_soil)
     !
     ! !DESCRIPTION:
-    ! Setup the matrix entries corresponding to snow-soil interaction for urban columns
+    ! Setup the matrix entries corresponding to snow-soil interaction for
+    ! urban sunwall/shadewall/roof columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3521,67 +3687,60 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )               ! thermal conductivity [W/(m K)]
     real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )           ! used in computing tridiagonal matrix [col, lev]
     real(r8), intent(inout) :: bmatrix_snow_soil(bounds%begc: , 1:,-1: )  ! matrix enteries
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,l                                                     ! indices
+    integer  :: fc                                                        ! lake filtered column indices
+    real(r8) :: dzm                                                       ! used in computing tridiagonal matrix
+    real(r8) :: dzp                                                       ! used in computing tridiagonal matrix
     !-----------------------------------------------------------------------
-    integer, parameter :: j = 0 
-    integer :: fc ,c ,l 
-    real(r8) :: dzm                     ! used in computing tridiagonal matrix
-    real(r8) :: dzp                     ! used in computing tridiagonal matrix
-    
+
+    ! Enforce expected array sizes
 
     associate(&
-         begc => bounds%begc                   , & ! Input:  [integer ] beginning column index
-         endc => bounds%endc                   , & ! Input:  [integer ] ending column index
          z  => col_pp%z  & ! Input:  [real(r8) (:,:)]  layer thickness (m)
          )
-
-      !$acc parallel loop independent gang vector default(present) 
-      do fc = 1,num_filter
-         c = filter(fc)
-         l = col_pp%landunit(c)
-         if (lun_pp%urbpoi(l)) then
-            if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
-                  .or. col_pp%itype(c) == icol_roof)) then
-               if (j >= col_pp%snl(c)+1) then
-                  if (j == col_pp%snl(c)+1) then
-                     dzp     = z(c,j+1)-z(c,j)
-                     bmatrix_snow_soil(c,1,j-1) =  -(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp
-                  else if (j <= nlevurb-1) then
-                     dzm     = (z(c,j)-z(c,j-1))
-                     dzp     = (z(c,j+1)-z(c,j))
-                     bmatrix_snow_soil(c,1,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j)/dzp
-                  end if
-               end if
-            end if
-            if (col_pp%itype(c) == icol_road_imperv .or. col_pp%itype(c) == icol_road_perv) then
-               if (j >= col_pp%snl(c)+1) then
-                  if (j == col_pp%snl(c)+1) then
-                     dzp     = z(c,j+1)-z(c,j)
-                     bmatrix_snow_soil(c,1,j-1) =  -(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp
-                  else if (j <= nlevgrnd-1) then
-                     dzm     = (z(c,j)-z(c,j-1))
-                     dzp     = (z(c,j+1)-z(c,j))
-                     bmatrix_snow_soil(c,1,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j)/dzp
+      !
+      ! urban non-road columns ---------------------------------------------------------
+      !
+      do j = 0,0
+         do fc = 1,num_filter
+            c = filter(fc)
+            l = col_pp%landunit(c)
+            if (lun_pp%urbpoi(l)) then
+               if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
+                    .or. col_pp%itype(c) == icol_roof)) then
+                  if (j >= col_pp%snl(c)+1) then
+                     if (j == col_pp%snl(c)+1) then
+                        dzp     = z(c,j+1)-z(c,j)
+                        bmatrix_snow_soil(c,1,j-1) =  -(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp
+                     else if (j <= nlevurb-1) then
+                        dzm     = (z(c,j)-z(c,j-1))
+                        dzp     = (z(c,j+1)-z(c,j))
+                        bmatrix_snow_soil(c,1,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j)/dzp
+                     end if
                   end if
                end if
             end if
-         end if
-      enddo
+         enddo
+      end do
 
     end associate
 
-  end subroutine SetMatrix_Snow_SoilUrban
+  end subroutine SetMatrix_Snow_SoilUrbanNonRoad
 
   !-----------------------------------------------------------------------
-  subroutine SetMatrix_Snow_SoilUrbanNonRoad(bounds, num_filter, filter, nband, &
+  subroutine SetMatrix_Snow_SoilUrbanRoad(bounds, num_filter, filter, nband, &
        tk, fact, bmatrix_snow_soil)
     !
     ! !DESCRIPTION:
     ! Setup the matrix entries corresponding to snow-soil interaction for
-    ! urban sunwall/shadewall/roof columns
+    ! urban road (impervious + pervious) columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
-    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use column_varcon  , only : icol_road_perv, icol_road_imperv
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
     !
     ! !ARGUMENTS:
@@ -3606,21 +3765,21 @@ end subroutine SetRHSVec_SoilNonUrban
     associate(&
          z  => col_pp%z  & ! Input:  [real(r8) (:,:)]  layer thickness (m)
          )
+
       !
-      ! urban non-road columns ---------------------------------------------------------
+      ! urban road columns -------------------------------------------------------------
       !
       do j = 0,0
          do fc = 1,num_filter
             c = filter(fc)
             l = col_pp%landunit(c)
             if (lun_pp%urbpoi(l)) then
-               if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
-                    .or. col_pp%itype(c) == icol_roof)) then
+               if (col_pp%itype(c) == icol_road_imperv .or. col_pp%itype(c) == icol_road_perv) then
                   if (j >= col_pp%snl(c)+1) then
                      if (j == col_pp%snl(c)+1) then
                         dzp     = z(c,j+1)-z(c,j)
                         bmatrix_snow_soil(c,1,j-1) =  -(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp
-                     else if (j <= nlevurb-1) then
+                     else if (j <= nlevgrnd-1) then
                         dzm     = (z(c,j)-z(c,j-1))
                         dzp     = (z(c,j+1)-z(c,j))
                         bmatrix_snow_soil(c,1,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j)/dzp
@@ -3633,8 +3792,7 @@ end subroutine SetRHSVec_SoilNonUrban
 
     end associate
 
-  end subroutine SetMatrix_Snow_SoilUrbanNonRoad
-
+  end subroutine SetMatrix_Snow_SoilUrbanRoad
 
   !-----------------------------------------------------------------------
   subroutine SetMatrix_Snow_SoilNonUrban(bounds, num_filter, filter, nband, &
@@ -3645,6 +3803,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! non-urban columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3660,8 +3819,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(inout) :: bmatrix_snow_soil(bounds%begc: , 1:,-1: )  ! matrix enteries
     !
     ! !LOCAL VARIABLES:
-    integer  :: c,l                                                     ! indices
-    integer, parameter :: j = 0
+    integer  :: j,c,l                                                     ! indices
     integer  :: fc                                                        ! lake filtered column indices
     real(r8) :: dzm                                                       ! used in computing tridiagonal matrix
     real(r8) :: dzp                                                       ! used in computing tridiagonal matrix
@@ -3676,27 +3834,29 @@ end subroutine SetRHSVec_SoilNonUrban
       !
       ! non-urban columns --------------------------------------------------------------
       !
-      !$acc parallel loop independent gang vector default(present)
-      do fc = 1,num_filter
-         c = filter(fc)
-         l = col_pp%landunit(c)
-         if (.not. lun_pp%urbpoi(l)) then
-            if (j >= col_pp%snl(c)+1) then
-               if (j == col_pp%snl(c)+1) then
-                  dzp     = z(c,j+1)-z(c,j)
-                  bmatrix_snow_soil(c,1,j-1) =  -(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp
-               else if (j <= nlevgrnd-1) then
-                  dzm     = (z(c,j)-z(c,j-1))
-                  dzp     = (z(c,j+1)-z(c,j))
-                  bmatrix_snow_soil(c,1,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j)/dzp
+      do j = 0,0
+         do fc = 1,num_filter
+            c = filter(fc)
+            l = col_pp%landunit(c)
+            if (.not. lun_pp%urbpoi(l)) then
+               if (j >= col_pp%snl(c)+1) then
+                  if (j == col_pp%snl(c)+1) then
+                     dzp     = z(c,j+1)-z(c,j)
+                     bmatrix_snow_soil(c,1,j-1) =  -(1._r8-cnfac)*fact(c,j)*tk(c,j)/dzp
+                  else if (j <= nlevgrnd-1) then
+                     dzm     = (z(c,j)-z(c,j-1))
+                     dzp     = (z(c,j+1)-z(c,j))
+                     bmatrix_snow_soil(c,1,j-1) =   - (1._r8-cnfac)*fact(c,j)* tk(c,j)/dzp
+                  end if
                end if
             end if
-         end if
-      enddo
+         enddo
+      end do
 
     end associate
 
   end subroutine SetMatrix_Snow_SoilNonUrban
+
   !-----------------------------------------------------------------------
   subroutine SetMatrix_Soil(bounds, num_filter, filter, nband, &
        dhsdT, tk, tk_h2osfc, dz_h2osfc, fact, frac_h2osfc, frac_sno_eff,  urban_column, &
@@ -3706,6 +3866,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Setup the matrix entries corresponding to internal soil layers.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3724,7 +3885,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: frac_h2osfc(bounds%begc: )           ! fractional area with surface water greater than zero
     real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )          ! fraction of ground covered by snow (0 to 1)
     logical , intent(in)  :: urban_column                         ! Is true if solving temperature for urban column, otherwise false
-    real(r8), intent(inout) :: bmatrix_soil(bounds%begc: , 1:, 1: ) ! matrix enteries
+    real(r8), intent(out) :: bmatrix_soil(bounds%begc: , 1:, 1: ) ! matrix enteries
                                                                   !
     ! !LOCAL VARIABLES:
     integer  :: j,c,l                                              ! indices
@@ -3741,7 +3902,7 @@ end subroutine SetRHSVec_SoilNonUrban
          )
 
       ! Initialize
-      ! bmatrix_soil(begc:endc, :, :) = 0.0_r8
+      bmatrix_soil(begc:endc, :, :) = 0.0_r8
 
       if (urban_column) then
          call SetMatrix_SoilUrban(bounds, num_filter, filter, nband, &
@@ -3767,7 +3928,6 @@ end subroutine SetRHSVec_SoilNonUrban
 
       ! the solution will be organized as (snow:h2osfc:soil) to minimize
       !     bandwidth; this requires a 5-element band instead of 3
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1,num_filter
          c = filter(fc)
 
@@ -3795,6 +3955,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! urban columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3842,7 +4003,6 @@ end subroutine SetRHSVec_SoilNonUrban
 
   end subroutine SetMatrix_SoilUrban
 
-
   !-----------------------------------------------------------------------
   subroutine SetMatrix_SoilUrbanNonRoad(bounds, num_filter, filter, nband, &
        dhsdT, tk, tk_h2osfc, dz_h2osfc, fact, bmatrix_soil)
@@ -3852,6 +4012,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! urban sunwall/shadewall/roof columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3886,7 +4047,6 @@ end subroutine SetRHSVec_SoilNonUrban
       !
       ! urban non-road columns ---------------------------------------------------------
       !
-      !$acc parallel loop independent gang vector collapse(2) default(present)
       do j = 1,nlevurb
          do fc = 1,num_filter
             c = filter(fc)
@@ -3939,6 +4099,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! urban road (impervious + pervious) columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_road_perv, icol_road_imperv
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -3972,7 +4133,7 @@ end subroutine SetRHSVec_SoilNonUrban
 
       !
       ! urban road columns -------------------------------------------------------------
-      !$acc parallel loop independent gang vector collapse(2) default(present) 
+      !
       do j = 1,nlevgrnd
          do fc = 1,num_filter
             c = filter(fc)
@@ -4029,6 +4190,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Setup the matrix entries corresponding to internal soil layers.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -4062,7 +4224,7 @@ end subroutine SetRHSVec_SoilNonUrban
 
       !
       ! non-urban columns --------------------------------------------------------------
-      !$acc parallel loop independent gang vector collapse(2) default(present) 
+      !
       do j = 1,nlevgrnd
          do fc = 1,num_filter
             c = filter(fc)
@@ -4118,6 +4280,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Setup the matrix entries corresponding to soil-snow interaction
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -4132,7 +4295,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )        ! used in computing tridiagonal matrix [col, lev]
     real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )               ! fraction of ground covered by snow (0 to 1)
     logical , intent(in)  :: urban_column                              ! Is true if solving temperature for urban column, otherwise false
-    real(r8), intent(inout) :: bmatrix_soil_snow(bounds%begc: , 1: ,1: ) ! matrix enteries
+    real(r8), intent(out) :: bmatrix_soil_snow(bounds%begc: , 1: ,1: ) ! matrix enteries
     !------------------------------------------------------------------------------
 
     ! Enforce expected array sizes
@@ -4143,7 +4306,7 @@ end subroutine SetRHSVec_SoilNonUrban
          )
 
       ! Initialize
-      ! bmatrix_soil_snow(begc:endc, :, :) = 0.0_r8
+      bmatrix_soil_snow(begc:endc, :, :) = 0.0_r8
 
       if (urban_column) then
          call SetMatrix_Soil_SnowUrban(bounds, num_filter, filter, nband, &
@@ -4172,40 +4335,90 @@ end subroutine SetRHSVec_SoilNonUrban
     ! urban columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
     !
     ! !ARGUMENTS:
     implicit none
-    type(bounds_type), intent(in) :: bounds                       ! bounds
-    integer , intent(in)  :: num_filter                           ! number of column the in filter
-    integer , intent(in)  :: filter(:)                            ! column filter
-    integer , intent(in)  :: nband                                ! number of bands of the tridigonal matrix
-    real(r8), intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )       ! thermal conductivity [W/(m K)]
-    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )   ! used in computing tridiagonal matrix [col, lev]
+    type(bounds_type), intent(in) :: bounds                               ! bounds
+    integer , intent(in)  :: num_filter                                   ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                    ! column filter
+    integer , intent(in)  :: nband                                        ! number of bands of the tridigonal matrix
+    real(r8), intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )               ! thermal conductivity [W/(m K)]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )           ! used in computing tridiagonal matrix [col, lev]
     real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )          ! fraction of ground covered by snow (0 to 1)
     real(r8), intent(inout) :: bmatrix_soil_snow(bounds%begc: , 1: ,1: )  ! matrix enteries
     !-----------------------------------------------------------------------
-    ! !LOCAL VARIABLES:
-    integer  :: c,l                ! indices
-    integer  :: fc                 ! lake filtered column indices
-    real(r8) :: dzm                ! used in computing tridiagonal matrix
-    real(r8) :: dzp                ! used in computing tridiagonal matrix
-    integer, parameter :: j=1 
-    
+
+    ! Enforce expected array sizes
+
     associate(&
-         begc => bounds%begc , & ! Input:  [integer ] beginning column index
-         endc => bounds%endc , & ! Input:  [integer ] ending column index
-         z => col_pp%z         & ! Input:  [real(r8) (:,:)]  layer thickness (m)
+         begc =>    bounds%begc , & ! Input:  [integer ] beginning column index
+         endc =>    bounds%endc   & ! Input:  [integer ] ending column index
+         )
+
+      call SetMatrix_Soil_SnowUrbanNonRoad(bounds, num_filter, filter, nband, &
+           tk( begc:endc, -nlevsno+1: ),                                               &
+           fact( begc:endc, -nlevsno+1: ),                                             &
+           bmatrix_soil_snow( begc:endc, 1:, 1: ))
+
+      call SetMatrix_Soil_SnowUrbanRoad(bounds, num_filter, filter, nband, &
+           tk( begc:endc, -nlevsno+1: ),                                            &
+           fact( begc:endc, -nlevsno+1: ),                                          &
+           frac_sno_eff(begc:endc),                                                 &
+           bmatrix_soil_snow( begc:endc, 1:, 1: ))
+
+    end associate
+
+  end subroutine SetMatrix_Soil_SnowUrban
+
+  !-----------------------------------------------------------------------
+  subroutine SetMatrix_Soil_SnowUrbanNonRoad(bounds, num_filter, filter, nband, &
+       tk, fact, bmatrix_soil_snow)
+    !
+    ! !DESCRIPTION:
+    ! Setup the matrix entries corresponding to soil-snow interaction for
+    ! urban sunwall/shadewall/roof columns
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : cnfac
+    use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                               ! bounds
+    integer , intent(in)  :: num_filter                                   ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                    ! column filter
+    integer , intent(in)  :: nband                                        ! number of bands of the tridigonal matrix
+    real(r8), intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )               ! thermal conductivity [W/(m K)]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )           ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(inout) :: bmatrix_soil_snow(bounds%begc: , 1: ,1: )  ! matrix enteries
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,l                                                     ! indices
+    integer  :: fc                                                        ! lake filtered column indices
+    real(r8) :: dzm                                                       ! used in computing tridiagonal matrix
+    real(r8) :: dzp                                                       ! used in computing tridiagonal matrix
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(           &
+         z  => col_pp%z     & ! Input:  [real(r8) (:,:)]  layer thickness (m)
          )
-         !$acc parallel loop independent gang vector default(present)
+      !
+      !
+      do j = 1,1
          do fc = 1,num_filter
             c = filter(fc)
             l = col_pp%landunit(c)
             if (lun_pp%urbpoi(l)) then
                if ((col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall &
-                     .or. col_pp%itype(c) == icol_roof)) then
+                    .or. col_pp%itype(c) == icol_roof)) then
                   if (j >= col_pp%snl(c)+1) then
                      if (j == col_pp%snl(c)+1) then
                         dzp     = z(c,j+1)-z(c,j)
@@ -4217,6 +4430,60 @@ end subroutine SetRHSVec_SoilNonUrban
                      end if
                   end if
                end if
+            end if
+         enddo
+      end do
+
+    end associate
+
+  end subroutine SetMatrix_Soil_SnowUrbanNonRoad
+
+  !-----------------------------------------------------------------------
+  subroutine SetMatrix_Soil_SnowUrbanRoad(bounds, num_filter, filter, nband, &
+       tk, fact, frac_sno_eff, bmatrix_soil_snow)
+    !
+    ! !DESCRIPTION:
+    ! Setup the matrix entries corresponding to soil-snow interaction for
+    ! urban road (impervious + pervious) columns
+    !
+    ! !USES:
+      !$acc routine seq
+    use elm_varcon     , only : cnfac
+    use column_varcon  , only : icol_road_imperv, icol_road_perv
+    use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
+    !
+    ! !ARGUMENTS:
+    implicit none
+    type(bounds_type), intent(in) :: bounds                               ! bounds
+    integer , intent(in)  :: num_filter                                   ! number of column the in filter
+    integer , intent(in)  :: filter(:)                                    ! column filter
+    integer , intent(in)  :: nband                                        ! number of bands of the tridigonal matrix
+    real(r8), intent(in)  :: tk(bounds%begc: ,-nlevsno+1: )               ! thermal conductivity [W/(m K)]
+    real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )           ! used in computing tridiagonal matrix [col, lev]
+    real(r8), intent(in)  :: frac_sno_eff(bounds%begc: )                  ! fraction of ground covered by snow (0 to 1)
+    real(r8), intent(inout) :: bmatrix_soil_snow(bounds%begc: , 1: ,1: )  ! matrix enteries
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: j,c,l                                                     ! indices
+    integer  :: fc                                                        ! lake filtered column indices
+    real(r8) :: dzm                                                       ! used in computing tridiagonal matrix
+    real(r8) :: dzp                                                       ! used in computing tridiagonal matrix
+    !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
+    associate(&
+         z => col_pp%z & ! Input:  [real(r8) (:,:)]  layer thickness (m)
+         )
+
+      !
+      ! urban road columns -------------------------------------------------------------
+      !
+      do j = 1,1
+         do fc = 1,num_filter
+            c = filter(fc)
+            l = col_pp%landunit(c)
+            if (lun_pp%urbpoi(l)) then
                if (col_pp%itype(c) == icol_road_imperv .or. col_pp%itype(c) == icol_road_perv) then
                   if (j >= col_pp%snl(c)+1) then
                      if (j == col_pp%snl(c)+1) then
@@ -4226,19 +4493,20 @@ end subroutine SetRHSVec_SoilNonUrban
                         ! this is the snow/soil interface layer
                         dzm     = (z(c,j)-z(c,j-1))
                         dzp     = (z(c,j+1)-z(c,j))
-   
+
                         bmatrix_soil_snow(c,5,j) =   - frac_sno_eff(c) * (1._r8-cnfac) * fact(c,j) &
-                              * tk(c,j-1)/dzm
+                             * tk(c,j-1)/dzm
                      end if
                   end if
                end if
-
             end if
-         enddo
+         end do
+      end do
+
     end associate
 
-  end subroutine SetMatrix_Soil_SnowUrban
- 
+  end subroutine SetMatrix_Soil_SnowUrbanRoad
+
   !-----------------------------------------------------------------------
   subroutine SetMatrix_Soil_SnowNonUrban(bounds, num_filter, filter, nband, &
        tk, fact, frac_sno_eff, bmatrix_soil_snow)
@@ -4248,6 +4516,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! non urban columns
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd, nlevurb
@@ -4264,9 +4533,8 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(inout) :: bmatrix_soil_snow(bounds%begc: , 1: ,1: )  ! matrix enteries
     !
     ! !LOCAL VARIABLES:
-    integer  :: c,l                                                       ! indices
+    integer  :: j,c,l                                                     ! indices
     integer  :: fc                                                        ! lake filtered column indices
-    integer, parameter :: j = 1 
     real(r8) :: dzm                                                       ! used in computing tridiagonal matrix
     real(r8) :: dzp                                                       ! used in computing tridiagonal matrix
     !-----------------------------------------------------------------------
@@ -4280,24 +4548,26 @@ end subroutine SetRHSVec_SoilNonUrban
       !
       ! non-urban columns --------------------------------------------------------------
       !
-      !$acc parallel loop independent gang vector default(present)
-      do fc = 1,num_filter
-         c = filter(fc)
-         l = col_pp%landunit(c)
-         if (.not. lun_pp%urbpoi(l)) then
-            if (j >= col_pp%snl(c)+1) then
-               if (j == col_pp%snl(c)+1) then
-                  dzp     = z(c,j+1)-z(c,j)
-                  bmatrix_soil_snow(c,5,j) = 0._r8
-               else if (j == 1) then
-                  ! this is the snow/soil interface layer
-                  dzm     = (z(c,j)-z(c,j-1))
-                  dzp     = (z(c,j+1)-z(c,j))
-                  bmatrix_soil_snow(c,5,j) =  -frac_sno_eff(c) * (1._r8-cnfac) * fact(c,j) &
-                       * tk(c,j-1)/dzm
+      do j = 1,1
+         do fc = 1,num_filter
+            c = filter(fc)
+            l = col_pp%landunit(c)
+            if (.not. lun_pp%urbpoi(l)) then
+               if (j >= col_pp%snl(c)+1) then
+                  if (j == col_pp%snl(c)+1) then
+                     dzp     = z(c,j+1)-z(c,j)
+                     bmatrix_soil_snow(c,5,j) = 0._r8
+                  else if (j == 1) then
+                     ! this is the snow/soil interface layer
+                     dzm     = (z(c,j)-z(c,j-1))
+                     dzp     = (z(c,j+1)-z(c,j))
+
+                     bmatrix_soil_snow(c,5,j) =  -frac_sno_eff(c) * (1._r8-cnfac) * fact(c,j) &
+                          * tk(c,j-1)/dzm
+                  end if
                end if
             end if
-         end if
+         end do
       end do
 
     end associate
@@ -4312,6 +4582,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Setup the matrix entries corresponding to internal standing water layer
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd
@@ -4329,7 +4600,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )    ! used in computing tridiagonal matrix [col, lev]
     real(r8), intent(in)  :: c_h2osfc( bounds%begc: )              ! heat capacity of surface water [col]
     real(r8), intent(in)  :: dz_h2osfc(bounds%begc: )              ! Thickness of standing water [m]
-    real(r8), intent(inout) :: bmatrix_ssw(bounds%begc: , 1:, 0: )   ! matrix enteries
+    real(r8), intent(out) :: bmatrix_ssw(bounds%begc: , 1:, 0: )   ! matrix enteries
     !
     ! !LOCAL VARIABLES:
     integer  :: c                                                  ! indices
@@ -4340,9 +4611,8 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Enforce expected array sizes
 
     ! Initialize
-   !  bmatrix_ssw(bounds%begc:bounds%endc, :, :) = 0.0_r8
+    bmatrix_ssw(bounds%begc:bounds%endc, :, :) = 0.0_r8
 
-    !$acc parallel loop independent gang vector default(present)
     do fc = 1,num_filter
        c = filter(fc)
 
@@ -4364,6 +4634,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Setup the matrix entries corresponding to standing surface water-soil layer interaction
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd
@@ -4380,7 +4651,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )         ! used in computing tridiagonal matrix [col, lev]
     real(r8), intent(in)  :: c_h2osfc( bounds%begc: )                   ! heat capacity of surface water [col]
     real(r8), intent(in)  :: dz_h2osfc(bounds%begc: )                   ! Thickness of standing water [m]
-    real(r8), intent(inout) :: bmatrix_ssw_soil(bounds%begc: , 1: ,0: )   ! matrix enteries
+    real(r8), intent(out) :: bmatrix_ssw_soil(bounds%begc: , 1: ,0: )   ! matrix enteries
     !
     ! !LOCAL VARIABLES:
     integer  :: c                                                       ! indices
@@ -4390,7 +4661,9 @@ end subroutine SetRHSVec_SoilNonUrban
 
     ! Enforce expected array sizes
 
-    !$acc parallel loop independent gang vector default(present)
+    ! Initialize
+    bmatrix_ssw_soil(bounds%begc:bounds%endc, :, :) = 0.0_r8
+
     do fc = 1,num_filter
        c = filter(fc)
 
@@ -4411,6 +4684,7 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Setup the matrix entries corresponding to soil layer-standing surface water interaction
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon     , only : cnfac
     use column_varcon  , only : icol_roof, icol_sunwall, icol_shadewall
     use elm_varpar     , only : nlevsno, nlevgrnd
@@ -4425,7 +4699,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8), intent(in)  :: fact( bounds%begc: , -nlevsno+1: )         ! used in computing tridiagonal matrix [col, lev]
     real(r8), intent(in)  :: dz_h2osfc(bounds%begc: )                   ! Thickness of standing water [m]
     real(r8), intent(in)  :: frac_h2osfc(bounds%begc: )                 ! fractional area with surface water greater than zero
-    real(r8), intent(inout) :: bmatrix_soil_ssw(bounds%begc: , 1:, 1: )   ! matrix enteries
+    real(r8), intent(out) :: bmatrix_soil_ssw(bounds%begc: , 1:, 1: )   ! matrix enteries
     !
     ! !LOCAL VARIABLES:
     integer  :: c                                                       ! indices
@@ -4436,9 +4710,8 @@ end subroutine SetRHSVec_SoilNonUrban
     ! Enforce expected array sizes
 
     ! Initialize
-   !  bmatrix_soil_ssw(bounds%begc:bounds%endc, :, :) = 0.0_r8
+    bmatrix_soil_ssw(bounds%begc:bounds%endc, :, :) = 0.0_r8
 
-    !$acc parallel loop independent gang vector default(present)
     do fc = 1,num_filter
        c = filter(fc)
 
@@ -4456,7 +4729,8 @@ end subroutine SetRHSVec_SoilNonUrban
 
   !-----------------------------------------------------------------------
   subroutine Prepare_Data_for_EM_PTM_Driver(bounds, num_filter, filter, &
-       sabg_lyr, dhsdT, hs_soil, hs_top_snow, hs_h2osfc)
+       sabg_lyr, dhsdT, hs_soil, hs_top_snow, hs_h2osfc, &
+       energyflux_vars)
     !
     ! !DESCRIPTION:
     ! Prepare data needed for the external model, PETSc-based Thermal
@@ -4478,6 +4752,7 @@ end subroutine SetRHSVec_SoilNonUrban
     real(r8)               , intent(in)    :: hs_soil(bounds%begc:bounds%endc)                   ! heat flux on soil [W/m2]
     real(r8)               , intent(in)    :: hs_top_snow(bounds%begc:bounds%endc)               ! heat flux on top snow layer [W/m2]
     real(r8)               , intent(in)    :: hs_h2osfc(bounds%begc:bounds%endc)                 ! heat flux on standing water [W/m2]
+    type(energyflux_type)  , intent(inout) :: energyflux_vars
     !
     ! !LOCAL VARIABLES:
     integer                                :: c, j
diff --git a/components/elm/src/biogeophys/SoilWaterMovementMod.F90 b/components/elm/src/biogeophys/SoilWaterMovementMod.F90
index 35c5f6330f..d5ea09e809 100644
--- a/components/elm/src/biogeophys/SoilWaterMovementMod.F90
+++ b/components/elm/src/biogeophys/SoilWaterMovementMod.F90
@@ -1,4 +1,4 @@
- module SoilWaterMovementMod
+module SoilWaterMovementMod
 
   !-----------------------------------------------------------------------
   ! DESCRIPTION
@@ -47,33 +47,35 @@ contains
 
   !-----------------------------------------------------------------------
   subroutine init_soilwater_movement()
-   !
-   !DESCRIPTION
-   !specify method for doing soil&root water interactions
-   !
-   use elm_varctl, only : use_vsfm, use_var_soil_thick, use_hydrstress
-   use spmdMod,    only : mpicom, MPI_LOGICAL
-   use shr_sys_mod,only : shr_sys_abort
-   ! !ARGUMENTS:
-   implicit none
-   integer :: ier ! error status
-   !------------------------------------------------------------------------------
-   soilroot_water_method = zengdecker_2009
-   zengdecker_2009_with_var_soil_thick = .false.
-
-   ! GB-FIX-ME: The call to control_spmd() [in subroutine control_init()] before
-   !            call to init_hydrology() would avoid the mpi broadcast
-   call mpi_bcast (use_vsfm, 1, MPI_LOGICAL, 0, mpicom, ier)
-   if (use_vsfm) soilroot_water_method = vsfm
-   call mpi_bcast (use_var_soil_thick, 1, MPI_LOGICAL, 0, mpicom, ier)
-
-   if (use_var_soil_thick .and. soilroot_water_method .eq. zengdecker_2009) then
-      zengdecker_2009_with_var_soil_thick = .true.
-   end if
-
-   if (use_var_soil_thick .and. soilroot_water_method .ne. zengdecker_2009) then
-      call shr_sys_abort('ERROR: use_var_soil_thick not supported with anything but zengdecker_2009 at this time.')
-   end if
+    !
+    !DESCRIPTION
+    !specify method for doing soil&root water interactions
+    !
+    use elm_varctl, only : use_vsfm, use_var_soil_thick, use_hydrstress
+    use spmdMod,    only : mpicom, MPI_LOGICAL
+    use shr_sys_mod,only : shr_sys_abort
+    ! !ARGUMENTS:
+    implicit none
+    integer :: ier ! error status
+    !------------------------------------------------------------------------------
+    soilroot_water_method = zengdecker_2009
+    zengdecker_2009_with_var_soil_thick = .false.
+
+    ! GB-FIX-ME: The call to control_spmd() [in subroutine control_init()] before
+    !            call to init_hydrology() would avoid the mpi broadcast
+
+    call mpi_bcast (use_vsfm, 1, MPI_LOGICAL, 0, mpicom, ier)
+    if (use_vsfm) soilroot_water_method = vsfm
+
+    call mpi_bcast (use_var_soil_thick, 1, MPI_LOGICAL, 0, mpicom, ier)
+    if (use_var_soil_thick .and. soilroot_water_method .eq. zengdecker_2009) then
+       zengdecker_2009_with_var_soil_thick = .true.
+    end if
+
+    if (use_var_soil_thick .and. soilroot_water_method .ne. zengdecker_2009) then
+       call shr_sys_abort('ERROR: use_var_soil_thick not supported with anything but zengdecker_2009 at this time.')
+    end if
+
   end subroutine init_soilwater_movement
 
   !-----------------------------------------------------------------------
@@ -84,6 +86,7 @@ contains
     ! select one subroutine to do the soil and root water coupling
     !
     !USES
+      !$acc routine seq
     use elm_varctl                 , only : use_betr
     use elm_varctl                 , only : use_var_soil_thick
     use shr_kind_mod               , only : r8 => shr_kind_r8
@@ -107,7 +110,7 @@ contains
     !
     ! !LOCAL VARIABLES:
     !character(len=32)                        :: subname = 'SoilWater'       ! subroutine name
-    real(r8)                                 :: xs(1:num_hydrologyc) !excess soil water above urban ponding limit
+    real(r8)                                 :: xs(bounds%begc:bounds%endc) !excess soil water above urban ponding limit
     integer                                  :: nlevbed                     ! number of layers to bedrock
 
     integer  :: fc, c, j
@@ -123,8 +126,6 @@ contains
       h2osoi_vol         =>    col_ws%h2osoi_vol        , & ! Output: [real(r8) (:,:) ] liquid water (kg/m2)
       h2osoi_liq         =>    col_ws%h2osoi_liq          & ! Output: [real(r8) (:,:) ] liquid water (kg/m2)
     )
-    !$acc enter data create(&
-    !$acc xs(:))
 
     select case(soilroot_water_method)
 
@@ -135,6 +136,7 @@ contains
 
     case (vsfm)
 #ifdef USE_PETSC_LIB
+#ifndef _OPENACC
        call Prepare_Data_for_EM_VSFM_Driver(bounds, num_hydrologyc, filter_hydrologyc, &
             soilhydrology_vars, soilstate_vars, &
             waterflux_vars, waterstate_vars, temperature_vars)
@@ -146,62 +148,55 @@ contains
             soilhydrology_vars=soilhydrology_vars, soilstate_vars=soilstate_vars, &
             waterflux_vars=waterflux_vars, waterstate_vars=waterstate_vars, &
             temperature_vars=temperature_vars)
+#endif
 #endif
     case default
-
-      call endrun('SoilWater' // ':: a SoilWater implementation must be specified!')
+#ifndef _OPENACC
+       call endrun('SoilWater' // ':: a SoilWater implementation must be specified!')
+#endif
     end select
 
     if(use_betr)then
     !a work around of the negative liquid water embarrassment, which is
     !critical for a meaningufl tracer transport in betr. Jinyun Tang, Jan 14, 2015
 
-    !$acc parallel loop independent gang vector default(present)
     do fc = 1, num_hydrologyc
        c = filter_hydrologyc(fc)
        nlevbed = nlev2bed(c)
-       !$acc loop seq
        do j = 1, nlevbed-1
           if (h2osoi_liq(c,j) < 0._r8) then
-             xs(fc) = watmin - h2osoi_liq(c,j)
+             xs(c) = watmin - h2osoi_liq(c,j)
           else
-             xs(fc) = 0._r8
+             xs(c) = 0._r8
           end if
-          h2osoi_liq(c,j  ) = h2osoi_liq(c,j  ) + xs(fc)
-          h2osoi_liq(c,j+1) = h2osoi_liq(c,j+1) - xs(fc)
+          h2osoi_liq(c,j  ) = h2osoi_liq(c,j  ) + xs(c)
+          h2osoi_liq(c,j+1) = h2osoi_liq(c,j+1) - xs(c)
        end do
     end do
 
-    !$acc parallel loop independent gang vector default(present)
     do fc = 1, num_hydrologyc
        c = filter_hydrologyc(fc)
        j = nlev2bed(c)
        if (h2osoi_liq(c,j) < watmin) then
-          xs(fc) = watmin-h2osoi_liq(c,j)
+          xs(c) = watmin-h2osoi_liq(c,j)
         else
-          xs(fc) = 0._r8
+          xs(c) = 0._r8
        end if
-       h2osoi_liq(c,j) = h2osoi_liq(c,j) + xs(fc)
-       wa(c) = wa(c) - xs(fc)
+       h2osoi_liq(c,j) = h2osoi_liq(c,j) + xs(c)
+       wa(c) = wa(c) - xs(c)
     end do
 
     !update volumetric soil moisture for bgc calculation
-    !$acc parallel loop independent gang vector default(present)
     do fc = 1, num_hydrologyc
        c = filter_hydrologyc(fc)
        nlevbed = nlev2bed(c)
-       !$acc loop seq
        do j = 1, nlevbed
           h2osoi_vol(c,j) = h2osoi_liq(c,j)/(dz(c,j)*denh2o) &
                             + h2osoi_ice(c,j)/(dz(c,j)*denice)
        enddo
     enddo
     endif
-
-    !$acc exit data delete(&
-    !$acc xs(:))
-
-    end associate
+  end associate
 
   end subroutine SoilWater
 
@@ -210,7 +205,7 @@ contains
        num_urbanc, filter_urbanc, soilhydrology_vars, soilstate_vars, dtime)
     !
     ! !DESCRIPTION:
-    ! Soil Hydrology
+    ! Soil hydrology
     ! Soil moisture is predicted from a 10-layer model (as with soil
     ! temperature), in which the vertical soil moisture transport is governed
     ! by infiltration, runoff, gradient diffusion, gravity, and root
@@ -272,6 +267,7 @@ contains
     ! r_j = a_j [d wat_j-1] + b_j [d wat_j] + c_j [d wat_j+1]
     !
     ! !USES:
+      !$acc routine seq
     use elm_varctl           , only : use_var_soil_thick
     use shr_kind_mod         , only : r8 => shr_kind_r8
     use shr_const_mod        , only : SHR_CONST_TKFRZ, SHR_CONST_LATICE, SHR_CONST_G
@@ -279,8 +275,9 @@ contains
     use elm_varcon           , only : wimp,grav,hfus,tfrz
     use elm_varcon           , only : e_ice,denh2o, denice
     use elm_varpar           , only : nlevsoi, max_patch_per_col, nlevgrnd
+    use clm_time_manager     , only : get_step_size
     use column_varcon        , only : icol_roof, icol_road_imperv
-    ! use TridiagonalMod       , only : Tridiagonal_filter
+    use TridiagonalMod       , only : Tridiagonal
     use SoilStateType        , only : soilstate_type
     use SoilHydrologyType    , only : soilhydrology_type
     use VegetationType       , only : veg_pp
@@ -301,54 +298,53 @@ contains
     ! !LOCAL VARIABLES:
     integer  :: p,c,fc,j                                     ! do loop indices
     integer  :: nlevbed                                      ! number of layers to bedrock
-    integer, parameter  :: jtop = 1               ! top level at each column
-    ! integer  :: jbot(bounds%begc:bounds%endc)                ! bottom level at each column
+    integer  :: jtop(bounds%begc:bounds%endc)                ! top level at each column
+    integer  :: jbot(bounds%begc:bounds%endc)                ! bottom level at each column
     real(r8) :: delta_z_zwt
-    real(r8) :: hk(1:num_hydrologyc,1:nlevgrnd)        ! hydraulic conductivity [mm h2o/s]
-    real(r8) :: dhkdw(1:num_hydrologyc,1:nlevgrnd)     ! d(hk)/d(vol_liq)
-    real(r8) :: amx(1:num_hydrologyc,1:nlevgrnd+1)     ! "a" left off diagonal of tridiagonal matrix
-    real(r8) :: bmx(1:num_hydrologyc,1:nlevgrnd+1)     ! "b" diagonal column for tridiagonal matrix
-    real(r8) :: cmx(1:num_hydrologyc,1:nlevgrnd+1)     ! "c" right off diagonal tridiagonal matrix
-    real(r8) :: rmx(1:num_hydrologyc,1:nlevgrnd+1)     ! "r" forcing term of tridiagonal matrix
-    real(r8) :: zmm(1:num_hydrologyc,1:nlevgrnd+1)     ! layer depth [mm]
-    real(r8) :: dzmm(1:num_hydrologyc,1:nlevgrnd+1)    ! layer thickness [mm]
-    real(r8) :: den                                           ! used in calculating qin, qout
-    real(r8) :: dqidw0(1:num_hydrologyc,1:nlevgrnd+1)  ! d(qin)/d(vol_liq(i-1))
-    real(r8) :: dqidw1(1:num_hydrologyc,1:nlevgrnd+1)  ! d(qin)/d(vol_liq(i))
-    real(r8) :: dqodw1(1:num_hydrologyc,1:nlevgrnd+1)  ! d(qout)/d(vol_liq(i))
-    real(r8) :: dqodw2(1:num_hydrologyc,1:nlevgrnd+1)  ! d(qout)/d(vol_liq(i+1))
-    real(r8) :: dsmpdw(1:num_hydrologyc,1:nlevgrnd+1)  ! d(smp)/d(vol_liq)
-    real(r8) :: num                                           ! used in calculating qin, qout
-    real(r8) :: qin(1:num_hydrologyc,1:nlevgrnd+1)     ! flux of water into soil layer [mm h2o/s]
-    real(r8) :: qout(1:num_hydrologyc,1:nlevgrnd+1)    ! flux of water out of soil layer [mm h2o/s]
-    real(r8) :: s_node                                        ! soil wetness
-    real(r8) :: s1                                            ! "s" at interface of layer
-    real(r8) :: s2                                            ! k*s**(2b+2)
-    real(r8) :: smp(1:num_hydrologyc,1:nlevgrnd)       ! soil matrix potential [mm]
-    real(r8) :: sdamp                                         ! extrapolates soiwat dependence of evaporation
-    integer  :: pi                                            ! pft index
-    integer  :: jwt(1:num_hydrologyc)                  ! index of the soil layer right above the water table (-)
+    real(r8) :: hk(bounds%begc:bounds%endc,1:nlevgrnd)        ! hydraulic conductivity [mm h2o/s]
+    real(r8) :: dhkdw(bounds%begc:bounds%endc,1:nlevgrnd)     ! d(hk)/d(vol_liq)
+    real(r8) :: amx(bounds%begc:bounds%endc,1:nlevgrnd+1)     ! "a" left off diagonal of tridiagonal matrix
+    real(r8) :: bmx(bounds%begc:bounds%endc,1:nlevgrnd+1)     ! "b" diagonal column for tridiagonal matrix
+    real(r8) :: cmx(bounds%begc:bounds%endc,1:nlevgrnd+1)     ! "c" right off diagonal tridiagonal matrix
+    real(r8) :: rmx(bounds%begc:bounds%endc,1:nlevgrnd+1)     ! "r" forcing term of tridiagonal matrix
+    real(r8) :: zmm(bounds%begc:bounds%endc,1:nlevgrnd+1)     ! layer depth [mm]
+    real(r8) :: dzmm(bounds%begc:bounds%endc,1:nlevgrnd+1)    ! layer thickness [mm]
+    real(r8) :: den                                          ! used in calculating qin, qout
+    real(r8) :: dqidw0(bounds%begc:bounds%endc,1:nlevgrnd+1)  ! d(qin)/d(vol_liq(i-1))
+    real(r8) :: dqidw1(bounds%begc:bounds%endc,1:nlevgrnd+1)  ! d(qin)/d(vol_liq(i))
+    real(r8) :: dqodw1(bounds%begc:bounds%endc,1:nlevgrnd+1)  ! d(qout)/d(vol_liq(i))
+    real(r8) :: dqodw2(bounds%begc:bounds%endc,1:nlevgrnd+1)  ! d(qout)/d(vol_liq(i+1))
+    real(r8) :: dsmpdw(bounds%begc:bounds%endc,1:nlevgrnd+1)  ! d(smp)/d(vol_liq)
+    real(r8) :: num                                          ! used in calculating qin, qout
+    real(r8) :: qin(bounds%begc:bounds%endc,1:nlevgrnd+1)     ! flux of water into soil layer [mm h2o/s]
+    real(r8) :: qout(bounds%begc:bounds%endc,1:nlevgrnd+1)    ! flux of water out of soil layer [mm h2o/s]
+    real(r8) :: s_node                                       ! soil wetness
+    real(r8) :: s1                                           ! "s" at interface of layer
+    real(r8) :: s2                                           ! k*s**(2b+2)
+    real(r8) :: smp(bounds%begc:bounds%endc,1:nlevgrnd)       ! soil matrix potential [mm]
+    real(r8) :: sdamp                                        ! extrapolates soiwat dependence of evaporation
+    integer  :: pi                                           ! pft index
+    real(r8) :: temp(bounds%begc:bounds%endc)                ! accumulator for rootr weighting
+    integer  :: jwt(bounds%begc:bounds%endc)                 ! index of the soil layer right above the water table (-)
     real(r8) :: smp1,dsmpdw1,wh,wh_zwt,ka
-    real(r8) :: dwat2(1:num_hydrologyc,1:nlevgrnd+1)
+    real(r8) :: dwat2(bounds%begc:bounds%endc,1:nlevgrnd+1)
     real(r8) :: dzq                                          ! used in calculating qin, qout (difference in equilbirium matric potential)
-    real(r8) :: zimm(1:num_hydrologyc,0:nlevgrnd)     ! layer interface depth [mm]
-    real(r8) :: zq(1:num_hydrologyc,1:nlevgrnd+1)     ! equilibrium matric potential for each layer [mm]
-    real(r8) :: vol_eq(1:num_hydrologyc,1:nlevgrnd+1) ! equilibrium volumetric water content
+    real(r8) :: zimm(bounds%begc:bounds%endc,0:nlevgrnd)      ! layer interface depth [mm]
+    real(r8) :: zq(bounds%begc:bounds%endc,1:nlevgrnd+1)      ! equilibrium matric potential for each layer [mm]
+    real(r8) :: vol_eq(bounds%begc:bounds%endc,1:nlevgrnd+1)  ! equilibrium volumetric water content
     real(r8) :: tempi                                        ! temp variable for calculating vol_eq
     real(r8) :: temp0                                        ! temp variable for calculating vol_eq
     real(r8) :: voleq1                                       ! temp variable for calculating vol_eq
-    real(r8) :: zwtmm(1:num_hydrologyc)               ! water table depth [mm]
-    real(r8) :: imped(1:num_hydrologyc,1:nlevgrnd)  
-    real(r8) :: vol_ice(1:num_hydrologyc,1:nlevgrnd)
+    real(r8) :: zwtmm(bounds%begc:bounds%endc)               ! water table depth [mm]
+    real(r8) :: imped(bounds%begc:bounds%endc,1:nlevgrnd)
+    real(r8) :: vol_ice(bounds%begc:bounds%endc,1:nlevgrnd)
     real(r8) :: z_mid
-    real(r8) :: vwc_zwt(1:num_hydrologyc)
-    real(r8) :: vwc_liq(1:num_hydrologyc,1:nlevgrnd+1) ! liquid volumetric water content
-   !  real(r8) :: smp_grad(bounds%begc:bounds%endc,1:nlevgrnd+1)
+    real(r8) :: vwc_zwt(bounds%begc:bounds%endc)
+    real(r8) :: vwc_liq(bounds%begc:bounds%endc,1:nlevgrnd+1) ! liquid volumetric water content
+    real(r8) :: smp_grad(bounds%begc:bounds%endc,1:nlevgrnd+1)
     real(r8) :: dsmpds                                       !temporary variable
     real(r8) :: dhkds                                        !temporary variable
     real(r8) :: hktmp                                        !temporary variable
-    real(r8) :: sum1 
-    real(r8) :: gam(1:nlevsoi+1),bet
     !-----------------------------------------------------------------------
 
     associate(&
@@ -383,88 +379,52 @@ contains
          qflx_rootsoi_col  =>    col_wf%qflx_rootsoi    , & ! Input: [real(r8) (:,:) ]  vegetation/soil water exchange (mm H2O/s) (+ = to atm)
          t_soisno          =>    col_es%t_soisno        & ! Input:  [real(r8) (:,:) ]  soil temperature (Kelvin)
          )
-    !$acc enter data create(&
-    !$acc hk(:,:), &
-    !$acc dhkdw(:,:), &
-    !$acc amx(:,:), &
-    !$acc bmx(:,:), &
-    !$acc cmx(:,:), &
-    !$acc rmx(:,:), &
-    !$acc zmm(:,:), &
-    !$acc dzmm(:,:), &
-    !$acc dqidw0(:,:), &
-    !$acc dqidw1(:,:), &
-    !$acc dqodw1(:,:), &
-    !$acc dqodw2(:,:), &
-    !$acc dsmpdw(:,:), &
-    !$acc qin(:,:), &
-    !$acc qout(:,:), &
-    !$acc smp(:,:), &
-    !$acc jwt(:), &
-    !$acc dwat2(:,:), &
-    !$acc zimm(:,:), &
-    !$acc zq(:,:), &
-    !$acc vol_eq(:,:), &
-    !$acc zwtmm(:), &
-    !$acc imped(:,:), &
-    !$acc vol_ice(:,:), &
-    !$acc vwc_zwt(:), &
-    !$acc vwc_liq(:,:), &
-    !$acc gam(:), &
-    !$acc nlevbed, &
-    !$acc s_node, &
-    !$acc s1, &
-    !$acc smp1, &
-    !$acc sum1)
-
-      
+
+
       ! Because the depths in this routine are in mm, use local
       ! variable arrays instead of pointers
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
         c = filter_hydrologyc(fc)
         nlevbed = nlev2bed(c)
-        !$acc loop seq
         do j = 1, nlevbed
-            zmm(fc,j) = z(c,j)*1.e3_r8
-            dzmm(fc,j) = dz(c,j)*1.e3_r8
-            zimm(fc,j) = zi(c,j)*1.e3_r8
+            zmm(c,j) = z(c,j)*1.e3_r8
+            dzmm(c,j) = dz(c,j)*1.e3_r8
+            zimm(c,j) = zi(c,j)*1.e3_r8
 
             ! calculate icefrac up here
-            vol_ice(fc,j) = min(watsat(c,j), h2osoi_ice(c,j)/(dz(c,j)*denice))
-            icefrac(c,j) = min(1._r8,vol_ice(fc,j)/watsat(c,j))
-            vwc_liq(fc,j) = max(h2osoi_liq(c,j),1.0e-6_r8)/(dz(c,j)*denh2o)
+            vol_ice(c,j) = min(watsat(c,j), h2osoi_ice(c,j)/(dz(c,j)*denice))
+            icefrac(c,j) = min(1._r8,vol_ice(c,j)/watsat(c,j))
+            vwc_liq(c,j) = max(h2osoi_liq(c,j),1.0e-6_r8)/(dz(c,j)*denh2o)
          end do
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
-         zimm(fc,0) = 0.0_r8
-         zwtmm(fc)  = zwt(c)*1.e3_r8
+         zimm(c,0) = 0.0_r8
+         zwtmm(c)  = zwt(c)*1.e3_r8
       end do
 
-      ! compute jwt index
+
+
+      !compute jwt index
       ! The layer index of the first unsaturated layer, i.e., the layer right above
       ! the water table
-      !$acc parallel loop independent gang worker default(present) present(zwt(:),zi(:,:),vwc_liq(:,:),&
-      !$acc  h2osoi_vol(:,:),watsat(:,:),sucsat(:,:),bsw(:,:))
+
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          nlevbed = nlev2bed(c)
-         jwt(fc) = nlevbed
+         jwt(c) = nlevbed
          ! allow jwt to equal zero when zwt is in top layer
-         !$acc loop vector independent 
          do j = 1,nlevbed
             if (use_var_soil_thick) then
                if (zwt(c) <= zi(c,j) .and. zwt(c) < zi(c,nlevbed)) then
-                  jwt(fc) = j-1
+                  jwt(c) = j-1
                   exit
                end if
             else
                if (zwt(c) <= zi(c,j)) then
-                  jwt(fc) = j-1
+                  jwt(c) = j-1
                   exit
                end if
             end if
@@ -472,18 +432,17 @@ contains
 
          ! compute vwc at water table depth (mainly for case when t < tfrz)
          !     this will only be used when zwt is below the soil column
-         vwc_zwt(fc) = watsat(c,nlevbed)
-         if(t_soisno(c,jwt(fc)+1) < tfrz) then
-            vwc_zwt(fc) = vwc_liq(fc,nlevbed)
-            !$acc loop seq  
+         vwc_zwt(c) = watsat(c,nlevbed)
+         if(t_soisno(c,jwt(c)+1) < tfrz) then
+            vwc_zwt(c) = vwc_liq(c,nlevbed)
             do j = nlevbed,nlevgrnd
                if(zwt(c) <= zi(c,j)) then
                   smp1 = hfus*(tfrz-t_soisno(c,j))/(grav*t_soisno(c,j)) * 1000._r8  !(mm)
                   !smp1 = max(0._r8,smp1)
                   smp1 = max(sucsat(c,nlevsoi),smp1)
-                  vwc_zwt(fc) = watsat(c,nlevsoi)*(smp1/sucsat(c,nlevbed))**(-1._r8/bsw(c,nlevsoi))
+                  vwc_zwt(c) = watsat(c,nlevsoi)*(smp1/sucsat(c,nlevbed))**(-1._r8/bsw(c,nlevsoi))
                   ! for temperatures close to tfrz, limit vwc to total water content
-                  vwc_zwt(fc) = min(vwc_zwt(fc), 0.5*(watsat(c,nlevbed) + h2osoi_vol(c,nlevbed)) )
+                  vwc_zwt(c) = min(vwc_zwt(c), 0.5*(watsat(c,nlevbed) + h2osoi_vol(c,nlevbed)) )
                   exit
                endif
             enddo
@@ -492,64 +451,59 @@ contains
 
       ! calculate the equilibrium water content based on the water table depth
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          nlevbed = nlev2bed(c)
-         !$acc loop seq
          do j = 1, nlevbed
-            if ((zwtmm(fc) <= zimm(fc,j-1))) then
-               vol_eq(fc,j) = watsat(c,j)
+            if ((zwtmm(c) <= zimm(c,j-1))) then
+               vol_eq(c,j) = watsat(c,j)
 
                ! use the weighted average from the saturated part (depth > wtd) and the equilibrium solution for the
                ! rest of the layer, the equilibrium solution is based on Clapp-Hornberg parameterization
                ! and no extension to full range swrc is needed
 
-            else if ((zwtmm(fc) .lt. zimm(fc,j)) .and. (zwtmm(fc) .gt. zimm(fc,j-1))) then
+            else if ((zwtmm(c) .lt. zimm(c,j)) .and. (zwtmm(c) .gt. zimm(c,j-1))) then
                tempi = 1.0_r8
-               temp0 = (((sucsat(c,j)+zwtmm(fc)-zimm(fc,j-1))/sucsat(c,j)))**(1._r8-1._r8/bsw(c,j))
-               voleq1 = -sucsat(c,j)*watsat(c,j)/(1._r8-1._r8/bsw(c,j))/(zwtmm(fc)-zimm(fc,j-1))*(tempi-temp0)
-               vol_eq(fc,j) = (voleq1*(zwtmm(fc)-zimm(fc,j-1)) + watsat(c,j)*(zimm(fc,j)-zwtmm(fc)))/(zimm(fc,j)-zimm(fc,j-1))
-               vol_eq(fc,j) = min(watsat(c,j),vol_eq(fc,j))
-               vol_eq(fc,j) = max(vol_eq(fc,j),0.0_r8)
+               temp0 = (((sucsat(c,j)+zwtmm(c)-zimm(c,j-1))/sucsat(c,j)))**(1._r8-1._r8/bsw(c,j))
+               voleq1 = -sucsat(c,j)*watsat(c,j)/(1._r8-1._r8/bsw(c,j))/(zwtmm(c)-zimm(c,j-1))*(tempi-temp0)
+               vol_eq(c,j) = (voleq1*(zwtmm(c)-zimm(c,j-1)) + watsat(c,j)*(zimm(c,j)-zwtmm(c)))/(zimm(c,j)-zimm(c,j-1))
+               vol_eq(c,j) = min(watsat(c,j),vol_eq(c,j))
+               vol_eq(c,j) = max(vol_eq(c,j),0.0_r8)
             else
-               tempi = (((sucsat(c,j)+zwtmm(fc)-zimm(fc,j))/sucsat(c,j)))**(1._r8-1._r8/bsw(c,j))
-               temp0 = (((sucsat(c,j)+zwtmm(fc)-zimm(fc,j-1))/sucsat(c,j)))**(1._r8-1._r8/bsw(c,j))
-               vol_eq(fc,j) = -sucsat(c,j)*watsat(c,j)/(1._r8-1._r8/bsw(c,j))/(zimm(fc,j)-zimm(fc,j-1))*(tempi-temp0)
-               vol_eq(fc,j) = max(vol_eq(fc,j),0.0_r8)
-               vol_eq(fc,j) = min(watsat(c,j),vol_eq(fc,j))
+               tempi = (((sucsat(c,j)+zwtmm(c)-zimm(c,j))/sucsat(c,j)))**(1._r8-1._r8/bsw(c,j))
+               temp0 = (((sucsat(c,j)+zwtmm(c)-zimm(c,j-1))/sucsat(c,j)))**(1._r8-1._r8/bsw(c,j))
+               vol_eq(c,j) = -sucsat(c,j)*watsat(c,j)/(1._r8-1._r8/bsw(c,j))/(zimm(c,j)-zimm(c,j-1))*(tempi-temp0)
+               vol_eq(c,j) = max(vol_eq(c,j),0.0_r8)
+               vol_eq(c,j) = min(watsat(c,j),vol_eq(c,j))
             endif
-            zq(fc,j) = -sucsat(c,j)*(max(vol_eq(fc,j)/watsat(c,j),0.01_r8))**(-bsw(c,j))
-            zq(fc,j) = max(smpmin(c), zq(fc,j))
+            zq(c,j) = -sucsat(c,j)*(max(vol_eq(c,j)/watsat(c,j),0.01_r8))**(-bsw(c,j))
+            zq(c,j) = max(smpmin(c), zq(c,j))
          end do
       end do
 
       ! If water table is below soil column calculate zq for the 11th layer
-      !$acc parallel loop independent gang vector default(present)
       do fc=1, num_hydrologyc
          c = filter_hydrologyc(fc)
          j = nlev2bed(c)
-         if(jwt(fc) == nlevbed) then
+         if(jwt(c) == nlevbed) then
             tempi = 1._r8
-            temp0 = (((sucsat(c,j)+zwtmm(fc)-zimm(fc,j))/sucsat(c,j)))**(1._r8-1._r8/bsw(c,j))
-            delta_z_zwt = zwtmm(fc) - zimm(fc,j)
+            temp0 = (((sucsat(c,j)+zwtmm(c)-zimm(c,j))/sucsat(c,j)))**(1._r8-1._r8/bsw(c,j))
+            delta_z_zwt = zwtmm(c) - zimm(c,j)
             if(delta_z_zwt == 0._r8) delta_z_zwt = 1._r8
-            vol_eq(fc,j+1) = -sucsat(c,j)*watsat(c,j)/(1._r8-1._r8/bsw(c,j))/(delta_z_zwt)*(tempi-temp0)
-            vol_eq(fc,j+1) = max(vol_eq(fc,j+1),0.0_r8)
-            vol_eq(fc,j+1) = min(watsat(c,j),vol_eq(fc,j+1))
-            zq(fc,j+1) = -sucsat(c,j)*(max(vol_eq(fc,j+1)/watsat(c,j),0.01_r8))**(-bsw(c,j))
-            zq(fc,j+1) = max(smpmin(c), zq(fc,j+1))
+            vol_eq(c,j+1) = -sucsat(c,j)*watsat(c,j)/(1._r8-1._r8/bsw(c,j))/(delta_z_zwt)*(tempi-temp0)
+            vol_eq(c,j+1) = max(vol_eq(c,j+1),0.0_r8)
+            vol_eq(c,j+1) = min(watsat(c,j),vol_eq(c,j+1))
+            zq(c,j+1) = -sucsat(c,j)*(max(vol_eq(c,j+1)/watsat(c,j),0.01_r8))**(-bsw(c,j))
+            zq(c,j+1) = max(smpmin(c), zq(c,j+1))
          end if
       end do
 
       ! Hydraulic conductivity and soil matric potential and their derivatives
 
       sdamp = 0._r8
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          nlevbed = nlev2bed(c)
-         !$acc loop vector independent 
          do j = 1, nlevbed
             ! compute hydraulic conductivity based on liquid water content only
 
@@ -557,7 +511,7 @@ contains
                s1 = 0.5_r8*(h2osoi_vol(c,j) + h2osoi_vol(c,min(nlevsoi, j+1))) / &
                     (0.5_r8*(watsat(c,j)+watsat(c,min(nlevsoi, j+1))))
             else
-               s1 = 0.5_r8*(vwc_liq(fc,j) + vwc_liq(fc,min(nlevsoi, j+1))) / &
+               s1 = 0.5_r8*(vwc_liq(c,j) + vwc_liq(c,min(nlevsoi, j+1))) / &
                     (0.5_r8*(watsat(c,j)+watsat(c,min(nlevsoi, j+1))))
             endif
             s1 = min(1._r8, s1)
@@ -565,12 +519,12 @@ contains
 
             ! replace fracice with impedance factor, as in zhao 97,99
             if (origflag == 1) then
-               imped(fc,j)=(1._r8-0.5_r8*(fracice(c,j)+fracice(c,min(nlevsoi, j+1))))
+               imped(c,j)=(1._r8-0.5_r8*(fracice(c,j)+fracice(c,min(nlevsoi, j+1))))
             else
-               imped(fc,j)=10._r8**(-e_ice*(0.5_r8*(icefrac(c,j)+icefrac(c,min(nlevsoi, j+1)))))
+               imped(c,j)=10._r8**(-e_ice*(0.5_r8*(icefrac(c,j)+icefrac(c,min(nlevsoi, j+1)))))
             endif
-            hk(fc,j) = imped(fc,j)*s1*s2
-            dhkdw(fc,j) = imped(fc,j)*(2._r8*bsw(c,j)+3._r8)*s2* &
+            hk(c,j) = imped(c,j)*s1*s2
+            dhkdw(c,j) = imped(c,j)*(2._r8*bsw(c,j)+3._r8)*s2* &
                  (1._r8/(watsat(c,j)+watsat(c,min(nlevsoi, j+1))))
 
             !compute un-restricted hydraulic conductivity
@@ -582,43 +536,43 @@ contains
             !hk(c,j) = imped(c,j)*hk(c,j)
             !dhkdw(c,j) = imped(c,j) * dhkds * (1._r8/(watsat(c,j)+watsat(c,min(nlevsoi, j+1))))
 
+
             ! compute matric potential and derivative based on liquid water content only
             if (origflag == 1) then
                s_node = max(h2osoi_vol(c,j)/watsat(c,j), 0.01_r8)
             else
-               s_node = max(vwc_liq(fc,j)/watsat(c,j), 0.01_r8)
+               s_node = max(vwc_liq(c,j)/watsat(c,j), 0.01_r8)
             endif
             s_node = min(1.0_r8, s_node)
 
             !call soil_water_retention_curve%soil_suction(sucsat(c,j), s_node, bsw(c,j), smp(c,j), dsmpds)
 
-            smp(fc,j) = -sucsat(c,j)*s_node**(-bsw(c,j))
-            smp(fc,j) = max(smpmin(c), smp(fc,j))
+            smp(c,j) = -sucsat(c,j)*s_node**(-bsw(c,j))
+            smp(c,j) = max(smpmin(c), smp(c,j))
             !do not turn on the line below, which will cause bit to bit error, jyt, 2014 Mar 6
             !dsmpdw(c,j) = dsmpds/watsat(c,j)
 
             if (origflag == 1) then
-               dsmpdw(fc,j) = -bsw(c,j)*smp(fc,j)/(s_node*watsat(c,j))
+               dsmpdw(c,j) = -bsw(c,j)*smp(c,j)/(s_node*watsat(c,j))
             else
-               dsmpdw(fc,j) = -bsw(c,j)*smp(fc,j)/vwc_liq(fc,j)
+               dsmpdw(c,j) = -bsw(c,j)*smp(c,j)/vwc_liq(c,j)
             endif
 
-            smp_l(c,j) = smp(fc,j)
-            hk_l(c,j) = hk(fc,j)
+            smp_l(c,j) = smp(c,j)
+            hk_l(c,j) = hk(c,j)
 
          end do
       end do
 
       ! aquifer (11th) layer
-      !$acc parallel loop independent gang vector default(present) present(zmm(:,:),dzmm(:,:))
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          nlevbed = nlev2bed(c)
-         zmm(fc,nlevbed+1) = 0.5*(1.e3_r8*zwt(c) + zmm(fc,nlevbed))
-         if(jwt(fc) < nlevbed) then
-            dzmm(fc,nlevbed+1) = dzmm(fc,nlevbed)
+         zmm(c,nlevbed+1) = 0.5*(1.e3_r8*zwt(c) + zmm(c,nlevbed))
+         if(jwt(c) < nlevbed) then
+            dzmm(c,nlevbed+1) = dzmm(c,nlevbed)
          else
-            dzmm(fc,nlevbed+1) = (1.e3_r8*zwt(c) - zmm(fc,nlevbed))
+            dzmm(c,nlevbed+1) = (1.e3_r8*zwt(c) - zmm(c,nlevbed))
          end if
       end do
 
@@ -627,82 +581,78 @@ contains
       ! Node j=1 (top)
 
       j = 1
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
-         qin(fc,j)    = qflx_infl(c)
-         den    = (zmm(fc,j+1)-zmm(fc,j))
-         dzq    = (zq(fc,j+1)-zq(fc,j))
-         num    = (smp(fc,j+1)-smp(fc,j)) - dzq
-         qout(fc,j)   = -hk(fc,j)*num/den
-         dqodw1(fc,j) = -(-hk(fc,j)*dsmpdw(fc,j)   + num*dhkdw(fc,j))/den
-         dqodw2(fc,j) = -( hk(fc,j)*dsmpdw(fc,j+1) + num*dhkdw(fc,j))/den
-         rmx(fc,j) =  qin(fc,j) - qout(fc,j) - qflx_rootsoi_col(c,j)
-         amx(fc,j) =  0._r8
-         bmx(fc,j) =  dzmm(fc,j)*(sdamp+1._r8/dtime) + dqodw1(fc,j)
-         cmx(fc,j) =  dqodw2(fc,j)
+         qin(c,j)    = qflx_infl(c)
+         den    = (zmm(c,j+1)-zmm(c,j))
+         dzq    = (zq(c,j+1)-zq(c,j))
+         num    = (smp(c,j+1)-smp(c,j)) - dzq
+         qout(c,j)   = -hk(c,j)*num/den
+         dqodw1(c,j) = -(-hk(c,j)*dsmpdw(c,j)   + num*dhkdw(c,j))/den
+         dqodw2(c,j) = -( hk(c,j)*dsmpdw(c,j+1) + num*dhkdw(c,j))/den
+         rmx(c,j) =  qin(c,j) - qout(c,j) - qflx_rootsoi_col(c,j)
+         amx(c,j) =  0._r8
+         bmx(c,j) =  dzmm(c,j)*(sdamp+1._r8/dtime) + dqodw1(c,j)
+         cmx(c,j) =  dqodw2(c,j)
       end do
 
       ! Nodes j=2 to j=nlevsoi-1
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          nlevbed = nlev2bed(c)
-         !$acc loop seq
          do j = 2, nlevbed - 1
-            den    = (zmm(fc,j) - zmm(fc,j-1))
-            dzq    = (zq(fc,j)-zq(fc,j-1))
-            num    = (smp(fc,j)-smp(fc,j-1)) - dzq
-            qin(fc,j)    = -hk(fc,j-1)*num/den
-            dqidw0(fc,j) = -(-hk(fc,j-1)*dsmpdw(fc,j-1) + num*dhkdw(fc,j-1))/den
-            dqidw1(fc,j) = -( hk(fc,j-1)*dsmpdw(fc,j)   + num*dhkdw(fc,j-1))/den
-            den    = (zmm(fc,j+1)-zmm(fc,j))
-            dzq    = (zq(fc,j+1)-zq(fc,j))
-            num    = (smp(fc,j+1)-smp(fc,j)) - dzq
-            qout(fc,j)   = -hk(fc,j)*num/den
-            dqodw1(fc,j) = -(-hk(fc,j)*dsmpdw(fc,j)   + num*dhkdw(fc,j))/den
-            dqodw2(fc,j) = -( hk(fc,j)*dsmpdw(fc,j+1) + num*dhkdw(fc,j))/den
-            rmx(fc,j)    =  qin(fc,j) - qout(fc,j) -  qflx_rootsoi_col(c,j)
-            amx(fc,j)    = -dqidw0(fc,j)
-            bmx(fc,j)    =  dzmm(fc,j)/dtime - dqidw1(fc,j) + dqodw1(fc,j)
-            cmx(fc,j)    =  dqodw2(fc,j)
+            den    = (zmm(c,j) - zmm(c,j-1))
+            dzq    = (zq(c,j)-zq(c,j-1))
+            num    = (smp(c,j)-smp(c,j-1)) - dzq
+            qin(c,j)    = -hk(c,j-1)*num/den
+            dqidw0(c,j) = -(-hk(c,j-1)*dsmpdw(c,j-1) + num*dhkdw(c,j-1))/den
+            dqidw1(c,j) = -( hk(c,j-1)*dsmpdw(c,j)   + num*dhkdw(c,j-1))/den
+            den    = (zmm(c,j+1)-zmm(c,j))
+            dzq    = (zq(c,j+1)-zq(c,j))
+            num    = (smp(c,j+1)-smp(c,j)) - dzq
+            qout(c,j)   = -hk(c,j)*num/den
+            dqodw1(c,j) = -(-hk(c,j)*dsmpdw(c,j)   + num*dhkdw(c,j))/den
+            dqodw2(c,j) = -( hk(c,j)*dsmpdw(c,j+1) + num*dhkdw(c,j))/den
+            rmx(c,j)    =  qin(c,j) - qout(c,j) -  qflx_rootsoi_col(c,j)
+            amx(c,j)    = -dqidw0(c,j)
+            bmx(c,j)    =  dzmm(c,j)/dtime - dqidw1(c,j) + dqodw1(c,j)
+            cmx(c,j)    =  dqodw2(c,j)
          end do
       end do
 
       ! Node j=nlevsoi (bottom)
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          nlevbed = nlev2bed(c)
          j = nlevbed
-         if(j > jwt(fc)) then !water table is in soil column
-            den    = (zmm(fc,j) - zmm(fc,j-1))
-            dzq    = (zq(fc,j)-zq(fc,j-1))
-            num    = (smp(fc,j)-smp(fc,j-1)) - dzq
-            qin(fc,j)    = -hk(fc,j-1)*num/den
-            dqidw0(fc,j) = -(-hk(fc,j-1)*dsmpdw(fc,j-1) + num*dhkdw(fc,j-1))/den
-            dqidw1(fc,j) = -( hk(fc,j-1)*dsmpdw(fc,j)   + num*dhkdw(fc,j-1))/den
-            qout(fc,j)   =  0._r8
-            dqodw1(fc,j) =  0._r8
-            rmx(fc,j)    =  qin(fc,j) - qout(fc,j) - qflx_rootsoi_col(c,j)
-            amx(fc,j)    = -dqidw0(fc,j)
-            bmx(fc,j)    =  dzmm(fc,j)/dtime - dqidw1(fc,j) + dqodw1(fc,j)
-            cmx(fc,j)    =  0._r8
+         if(j > jwt(c)) then !water table is in soil column
+            den    = (zmm(c,j) - zmm(c,j-1))
+            dzq    = (zq(c,j)-zq(c,j-1))
+            num    = (smp(c,j)-smp(c,j-1)) - dzq
+            qin(c,j)    = -hk(c,j-1)*num/den
+            dqidw0(c,j) = -(-hk(c,j-1)*dsmpdw(c,j-1) + num*dhkdw(c,j-1))/den
+            dqidw1(c,j) = -( hk(c,j-1)*dsmpdw(c,j)   + num*dhkdw(c,j-1))/den
+            qout(c,j)   =  0._r8
+            dqodw1(c,j) =  0._r8
+            rmx(c,j)    =  qin(c,j) - qout(c,j) - qflx_rootsoi_col(c,j)
+            amx(c,j)    = -dqidw0(c,j)
+            bmx(c,j)    =  dzmm(c,j)/dtime - dqidw1(c,j) + dqodw1(c,j)
+            cmx(c,j)    =  0._r8
 
             ! next set up aquifer layer; hydrologically inactive
-            rmx(fc,j+1) = 0._r8
-            amx(fc,j+1) = 0._r8
-            bmx(fc,j+1) = dzmm(fc,j+1)/dtime
-            cmx(fc,j+1) = 0._r8
+            rmx(c,j+1) = 0._r8
+            amx(c,j+1) = 0._r8
+            bmx(c,j+1) = dzmm(c,j+1)/dtime
+            cmx(c,j+1) = 0._r8
          else ! water table is below soil column
 
             ! compute aquifer soil moisture as average of layer 10 and saturation
             if(origflag == 1) then
                s_node = max(0.5*(1.0_r8+h2osoi_vol(c,j)/watsat(c,j)), 0.01_r8)
             else
-               s_node = max(0.5*((vwc_zwt(fc)+vwc_liq(fc,j))/watsat(c,j)), 0.01_r8)
+               s_node = max(0.5*((vwc_zwt(c)+vwc_liq(c,j))/watsat(c,j)), 0.01_r8)
             endif
             s_node = min(1.0_r8, s_node)
 
@@ -716,132 +666,103 @@ contains
             dsmpdw1 = -bsw(c,j)*smp1/(s_node*watsat(c,j))
 
             ! first set up bottom layer of soil column
-            den    = (zmm(fc,j) - zmm(fc,j-1))
-            dzq    = (zq(fc,j)-zq(fc,j-1))
-            num    = (smp(fc,j)-smp(fc,j-1)) - dzq
-            qin(fc,j)    = -hk(fc,j-1)*num/den
-            dqidw0(fc,j) = -(-hk(fc,j-1)*dsmpdw(fc,j-1) + num*dhkdw(fc,j-1))/den
-            dqidw1(fc,j) = -( hk(fc,j-1)*dsmpdw(fc,j)   + num*dhkdw(fc,j-1))/den
-            den    = (zmm(fc,j+1)-zmm(fc,j))
-            dzq    = (zq(fc,j+1)-zq(fc,j))
-            num    = (smp1-smp(fc,j)) - dzq
+            den    = (zmm(c,j) - zmm(c,j-1))
+            dzq    = (zq(c,j)-zq(c,j-1))
+            num    = (smp(c,j)-smp(c,j-1)) - dzq
+            qin(c,j)    = -hk(c,j-1)*num/den
+            dqidw0(c,j) = -(-hk(c,j-1)*dsmpdw(c,j-1) + num*dhkdw(c,j-1))/den
+            dqidw1(c,j) = -( hk(c,j-1)*dsmpdw(c,j)   + num*dhkdw(c,j-1))/den
+            den    = (zmm(c,j+1)-zmm(c,j))
+            dzq    = (zq(c,j+1)-zq(c,j))
+            num    = (smp1-smp(c,j)) - dzq
             if (use_var_soil_thick) then
-               qout(fc,j) = 0._r8
-               dqodw1(fc,j) = 0._r8
-               dqodw2(fc,j) = 0._r8
+               qout(c,j) = 0._r8
+               dqodw1(c,j) = 0._r8
+               dqodw2(c,j) = 0._r8
             else
-               qout(fc,j)   = -hk(fc,j)*num/den
-               dqodw1(fc,j) = -(-hk(fc,j)*dsmpdw(fc,j)   + num*dhkdw(fc,j))/den
-               dqodw2(fc,j) = -( hk(fc,j)*dsmpdw1 + num*dhkdw(fc,j))/den
+               qout(c,j)   = -hk(c,j)*num/den
+               dqodw1(c,j) = -(-hk(c,j)*dsmpdw(c,j)   + num*dhkdw(c,j))/den
+               dqodw2(c,j) = -( hk(c,j)*dsmpdw1 + num*dhkdw(c,j))/den
             end if
 
-            rmx(fc,j) =  qin(fc,j) - qout(fc,j) - qflx_rootsoi_col(c,j)
-            amx(fc,j) = -dqidw0(fc,j)
-            bmx(fc,j) =  dzmm(fc,j)/dtime - dqidw1(fc,j) + dqodw1(fc,j)
-            cmx(fc,j) =  dqodw2(fc,j)
+            rmx(c,j) =  qin(c,j) - qout(c,j) - qflx_rootsoi_col(c,j)
+            amx(c,j) = -dqidw0(c,j)
+            bmx(c,j) =  dzmm(c,j)/dtime - dqidw1(c,j) + dqodw1(c,j)
+            cmx(c,j) =  dqodw2(c,j)
 
             ! next set up aquifer layer; den/num unchanged, qin=qout
-            qin(fc,j+1)    = qout(fc,j)
-            dqidw0(fc,j+1) = -(-hk(fc,j)*dsmpdw(fc,j) + num*dhkdw(fc,j))/den
-            dqidw1(fc,j+1) = -( hk(fc,j)*dsmpdw1   + num*dhkdw(fc,j))/den
-            qout(fc,j+1)   =  0._r8  ! zero-flow bottom boundary condition
-            dqodw1(fc,j+1) =  0._r8  ! zero-flow bottom boundary condition
+            qin(c,j+1)    = qout(c,j)
+            dqidw0(c,j+1) = -(-hk(c,j)*dsmpdw(c,j) + num*dhkdw(c,j))/den
+            dqidw1(c,j+1) = -( hk(c,j)*dsmpdw1   + num*dhkdw(c,j))/den
+            qout(c,j+1)   =  0._r8  ! zero-flow bottom boundary condition
+            dqodw1(c,j+1) =  0._r8  ! zero-flow bottom boundary condition
             if (use_var_soil_thick) then
-               rmx(fc,j+1) = 0._r8
-               amx(fc,j+1) = 0._r8
-               bmx(fc,j+1) = dzmm(fc,j+1)/dtime
-               cmx(fc,j+1) = 0._r8
+               rmx(c,j+1) = 0._r8
+               amx(c,j+1) = 0._r8
+               bmx(c,j+1) = dzmm(c,j+1)/dtime
+               cmx(c,j+1) = 0._r8
             else
-               rmx(fc,j+1) =  qin(fc,j+1) - qout(fc,j+1)
-               amx(fc,j+1) = -dqidw0(fc,j+1)
-               bmx(fc,j+1) =  dzmm(fc,j+1)/dtime - dqidw1(fc,j+1) + dqodw1(fc,j+1)
-               cmx(fc,j+1) =  0._r8
+               rmx(c,j+1) =  qin(c,j+1) - qout(c,j+1)
+               amx(c,j+1) = -dqidw0(c,j+1)
+               bmx(c,j+1) =  dzmm(c,j+1)/dtime - dqidw1(c,j+1) + dqodw1(c,j+1)
+               cmx(c,j+1) =  0._r8
             end if
          endif
       end do
 
       ! Solve for dwat
+
+      jtop(bounds%begc : bounds%endc) = 1
       ! Determination of how many layers (nlev2bed) to do for the tridiagonal
       ! at each column
       if (use_var_soil_thick) then
-        !  !$acc parallel loop independent gang vector default(present)
-        !  do fc = 1,num_hydrologyc
-        !     c = filter_hydrologyc(fc)
-        !     jbot(c) = nlev2bed(c)
-        !  end do
-        !  call Tridiagonal(bounds, 1, nlevgrnd+1, &
-        !       jtop(bounds%begc:bounds%endc),     &
-        !       jbot(bounds%begc:bounds%endc),     &
-        !       num_hydrologyc, filter_hydrologyc, &
-        !       amx(bounds%begc:bounds%endc, :),   &
-        !       bmx(bounds%begc:bounds%endc, :),   &
-        !       cmx(bounds%begc:bounds%endc, :),   &
-        !       rmx(bounds%begc:bounds%endc, :),   &
-        !       dwat2(bounds%begc:bounds%endc, :) )
+      	 do fc = 1,num_hydrologyc
+            c = filter_hydrologyc(fc)
+            jbot(c) = nlev2bed(c)
+      	 end do
+         call Tridiagonal(bounds, 1, nlevgrnd+1, &
+              jtop(bounds%begc:bounds%endc),     &
+              jbot(bounds%begc:bounds%endc),     &
+              num_hydrologyc, filter_hydrologyc, &
+              amx(bounds%begc:bounds%endc, :),   &
+              bmx(bounds%begc:bounds%endc, :),   &
+              cmx(bounds%begc:bounds%endc, :),   &
+              rmx(bounds%begc:bounds%endc, :),   &
+              dwat2(bounds%begc:bounds%endc, :) )
       else
-         ! call Tridiagonal_filter(1, nlevsoi+1, &
-         !      jtop, num_hydrologyc, filter_hydrologyc, &
-         !      amx(1:num_hydrologyc, :), &
-         !      bmx(1:num_hydrologyc, :), &
-         !      cmx(1:num_hydrologyc, :), &
-         !      rmx(1:num_hydrologyc, :), &
-         !      dwat2(1:num_hydrologyc, :) )
-
-         !$acc parallel loop independent gang vector default(present) create(gam(:)) private(bet,gam(:))
-         do fc = 1,num_hydrologyc
-            bet = bmx(fc,jtop)
-
-            !$acc loop seq 
-            do j = 1, nlevsoi+1
-               if (j >= jtop) then
-                  if (j == jtop) then
-                     dwat2(fc,j) = rmx(fc,j) / bet
-                  else
-                     gam(j) = cmx(fc,j-1) / bet
-                     bet = bmx(fc,j) - amx(fc,j) * gam(j)
-                     dwat2(fc,j) = (rmx(fc,j) - amx(fc,j)*dwat2(fc,j-1)) / bet
-                  end if
-               end if
-            end do
-   
-            !$acc loop seq 
-            do j = nlevsoi,1,-1
-              if (j >= jtop) then
-               dwat2(fc,j) = dwat2(fc,j) - gam(j+1) * dwat2(fc,j+1)
-              end if
-            end do
-         end do 
+         call Tridiagonal(bounds, 1, nlevsoi+1, &
+              jtop(bounds%begc:bounds%endc), &
+              num_hydrologyc, filter_hydrologyc, &
+              amx(bounds%begc:bounds%endc, :), &
+              bmx(bounds%begc:bounds%endc, :), &
+              cmx(bounds%begc:bounds%endc, :), &
+              rmx(bounds%begc:bounds%endc, :), &
+              dwat2(bounds%begc:bounds%endc, :) )
       end if
 
       ! Renew the mass of liquid water
       ! also compute qcharge from dwat in aquifer layer
       ! update in drainage for case jwt < nlevsoi
-      !$acc parallel loop independent gang worker default(present)
+
       do fc = 1,num_hydrologyc
          c = filter_hydrologyc(fc)
          nlevbed = nlev2bed(c)
-         !$acc loop vector independent 
          do j = 1, nlevbed
-            h2osoi_liq(c,j) = h2osoi_liq(c,j) + dwat2(fc,j)*dzmm(fc,j)
+            h2osoi_liq(c,j) = h2osoi_liq(c,j) + dwat2(c,j)*dzmm(c,j)
          end do
-      end do 
-      
-      ! calculate qcharge for case jwt < nlevsoi
-      if (use_var_soil_thick) then
-         !$acc parallel loop independent gang vector default(present)
-         do fc = 1,num_hydrologyc
-            c = filter_hydrologyc(fc)
 
-            if (jwt(fc) < nlevbed) then
+         ! calculate qcharge for case jwt < nlevsoi
+         if (use_var_soil_thick) then
+            if (jwt(c) < nlevbed) then
                wh_zwt = 0._r8   !since wh_zwt = -sucsat - zq_zwt, where zq_zwt = -sucsat
 
                ! Recharge rate qcharge to groundwater (positive to aquifer)
-               s_node = max(h2osoi_vol(c,jwt(fc)+1)/watsat(c,jwt(fc)+1), 0.01_r8)
+               s_node = max(h2osoi_vol(c,jwt(c)+1)/watsat(c,jwt(c)+1), 0.01_r8)
                s1 = min(1._r8, s_node)
 
                !scs: this is the expression for unsaturated hk
-               ka = imped(fc,jwt(fc)+1)*hksat(c,jwt(fc)+1) &
-                 *s1**(2._r8*bsw(c,jwt(fc)+1)+3._r8)
+               ka = imped(c,jwt(c)+1)*hksat(c,jwt(c)+1) &
+                 *s1**(2._r8*bsw(c,jwt(c)+1)+3._r8)
 
                !compute unsaturated hk, this shall be tested later, because it
                !is not bit for bit
@@ -849,16 +770,16 @@ contains
                !apply ice impedance
                !ka = imped(c,jwt(c)+1) * ka
                ! Recharge rate qcharge to groundwater (positive to aquifer)
-               smp1 = max(smpmin(c), smp(fc,max(1,jwt(fc))))
-               wh      = smp1 - zq(fc,max(1,jwt(fc)))
+               smp1 = max(smpmin(c), smp(c,max(1,jwt(c))))
+               wh      = smp1 - zq(c,max(1,jwt(c)))
 
                !scs: original formulation
-               if (jwt(fc) == 0) then
+               if (jwt(c) == 0) then
                   qcharge(c) = -ka * (wh_zwt-wh)  /((zwt(c)+1.e-3)*1000._r8)
                else
                   !             qcharge(c) = -ka * (wh_zwt-wh)/((zwt(c)-z(c,jwt(c)))*1000._r8)
                   !scs: 1/2, assuming flux is at zwt interface, saturation deeper than zwt
-                  qcharge(c) = -ka * (wh_zwt-wh)/((zwt(c)-z(c,jwt(fc)))*1000._r8*2.0)
+                  qcharge(c) = -ka * (wh_zwt-wh)/((zwt(c)-z(c,jwt(c)))*1000._r8*2.0)
                endif
 
                ! To limit qcharge  (for the first several timesteps)
@@ -868,23 +789,17 @@ contains
                ! if water table is below soil column, compute qcharge from dwat2(11)
                qcharge(c) = 0._r8
             endif
-         end do 
-
-      else !use_var_soil_thick
-         !$acc parallel loop independent gang vector default(present) &
-         !$acc  present(imped(:,:),hksat(:,:),h2osoi_vol(:,:),watsat(:,:),smp(:,:),zq(:,:),z(:,:),bsw(:,:))
-         do fc = 1,num_hydrologyc
-            c = filter_hydrologyc(fc)
-            if (jwt(fc) < nlevbed) then
+          else
+            if (jwt(c) < nlevbed) then
                wh_zwt = 0._r8   !since wh_zwt = -sucsat - zq_zwt, where zq_zwt = -sucsat
 
                ! Recharge rate qcharge to groundwater (positive to aquifer)
-               s_node = max(h2osoi_vol(c,jwt(fc)+1)/watsat(c,jwt(fc)+1), 0.01_r8)
+               s_node = max(h2osoi_vol(c,jwt(c)+1)/watsat(c,jwt(c)+1), 0.01_r8)
                s1 = min(1._r8, s_node)
 
                !scs: this is the expression for unsaturated hk
-               ka = imped(fc,jwt(fc)+1)*hksat(c,jwt(fc)+1) &
-                 *s1**(2._r8*bsw(c,jwt(fc)+1)+3._r8)
+               ka = imped(c,jwt(c)+1)*hksat(c,jwt(c)+1) &
+                 *s1**(2._r8*bsw(c,jwt(c)+1)+3._r8)
 
                !compute unsaturated hk, this shall be tested later, because it
                !is not bit for bit
@@ -892,16 +807,16 @@ contains
                !apply ice impedance
                !ka = imped(c,jwt(c)+1) * ka
                ! Recharge rate qcharge to groundwater (positive to aquifer)
-               smp1 = max(smpmin(c), smp(fc,max(1,jwt(fc))))
-               wh      = smp1 - zq(fc,max(1,jwt(fc)))
+               smp1 = max(smpmin(c), smp(c,max(1,jwt(c))))
+               wh      = smp1 - zq(c,max(1,jwt(c)))
 
                !scs: original formulation
-               if (jwt(fc) == 0) then
+               if (jwt(c) == 0) then
                   qcharge(c) = -ka * (wh_zwt-wh)  /((zwt(c)+1.e-3)*1000._r8)
                else
                   !             qcharge(c) = -ka * (wh_zwt-wh)/((zwt(c)-z(c,jwt(c)))*1000._r8)
                   !scs: 1/2, assuming flux is at zwt interface, saturation deeper than zwt
-                  qcharge(c) = -ka * (wh_zwt-wh)/((zwt(c)-z(c,jwt(fc)))*1000._r8*2.0)
+                  qcharge(c) = -ka * (wh_zwt-wh)/((zwt(c)-z(c,jwt(c)))*1000._r8*2.0)
                endif
 
                ! To limit qcharge  (for the first several timesteps)
@@ -909,62 +824,25 @@ contains
                qcharge(c) = min( 10.0_r8/dtime,qcharge(c))
             else
             ! if water table is below soil column, compute qcharge from dwat2(11)
-               qcharge(c) = dwat2(fc,nlevsoi+1)*dzmm(fc,nlevsoi+1)/dtime
+               qcharge(c) = dwat2(c,nlevsoi+1)*dzmm(c,nlevsoi+1)/dtime
             endif
-         end do
-      endif !use_var_soil_thick
+         endif
+      end do
 
       ! compute the water deficit and reset negative liquid water content
       !  Jinyun Tang
-      !$acc parallel loop independent gang worker default(present) private(sum1) 
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          nlevbed = nlev2bed(c)
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1)
+         qflx_deficit(c) = 0._r8
          do j = 1, nlevbed
             if(h2osoi_liq(c,j)<0._r8)then
-               sum1 = sum1 - h2osoi_liq(c,j)
+               qflx_deficit(c) = qflx_deficit(c) - h2osoi_liq(c,j)
             endif
          enddo
-         qflx_deficit(c) = sum1 
-      enddo    
-   
-    !$acc exit data delete(&
-    !$acc hk(:,:), &
-    !$acc dhkdw(:,:), &
-    !$acc amx(:,:), &
-    !$acc bmx(:,:), &
-    !$acc cmx(:,:), &
-    !$acc rmx(:,:), &
-    !$acc zmm(:,:), &
-    !$acc dzmm(:,:), &
-    !$acc dqidw0(:,:), &
-    !$acc dqidw1(:,:), &
-    !$acc dqodw1(:,:), &
-    !$acc dqodw2(:,:), &
-    !$acc dsmpdw(:,:), &
-    !$acc qin(:,:), &
-    !$acc qout(:,:), &
-    !$acc smp(:,:), &
-    !$acc jwt(:), &
-    !$acc dwat2(:,:), &
-    !$acc zimm(:,:), &
-    !$acc zq(:,:), &
-    !$acc vol_eq(:,:), &
-    !$acc zwtmm(:), &
-    !$acc imped(:,:), &
-    !$acc vol_ice(:,:), &
-    !$acc vwc_zwt(:), &
-    !$acc vwc_liq(:,:), &
-    !$acc gam(:), &
-    !$acc nlevbed, &
-    !$acc s_node, &
-    !$acc s1, &
-    !$acc smp1, &
-    !$acc sum1)
-
-   end associate
+      enddo
+
+    end associate
 
   end subroutine soilwater_zengdecker2009
 
@@ -1167,7 +1045,7 @@ contains
    ! ====================================================================================
 
    subroutine Compute_EffecRootFrac_And_VertTranSink(bounds, num_hydrologyc, &
-         filter_hydrologyc, soilstate_inst, canopystate_inst)
+         filter_hydrologyc, soilstate_inst, canopystate_inst, energyflux_inst)
 
       ! ---------------------------------------------------------------------------------
       ! This is a wrapper for calculating the effective root fraction and soil
@@ -1188,8 +1066,11 @@ contains
       !
       !
       ! ---------------------------------------------------------------------------------
+
+      !$acc routine seq
       use SoilStateType       , only : soilstate_type
       use CanopyStateType     , only : canopystate_type
+      use EnergyFluxType      , only : energyflux_type
       use ColumnType          , only : col_pp
       use LandunitType        , only : lun_pp
       use decompMod           , only : bounds_type
@@ -1202,77 +1083,65 @@ contains
       integer                 , intent(in)    :: filter_hydrologyc(num_hydrologyc) ! column filter for soil points
       type(soilstate_type)    , intent(inout) :: soilstate_inst
       type(canopystate_type)  , intent(in)    :: canopystate_inst
+      type(energyflux_type)   , intent(in)    :: energyflux_inst
 
       ! Local Variables
-      integer  :: filterc(1:num_hydrologyc)           !column filter
+      integer  :: filterc(bounds%endc-bounds%begc+1)           !column filter
       integer  :: num_filterc
       integer  :: num_filterc_tot
       integer  :: fc
       integer  :: c
-      integer  :: l, fperv, fimperv
-
-
-      !$acc enter data create(&
-      !$acc filterc(:), fperv, fimperv)
+      integer  :: l
 
       num_filterc_tot = 0
+
       ! 1) pervious roads
       num_filterc = 0
-      !$acc parallel loop independent gang vector present(filterc(:)) private(c,fperv) copy(num_filterc)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          if (col_pp%itype(c) == icol_road_perv) then
-            !$acc atomic capture 
             num_filterc = num_filterc + 1
-            fperv = num_filterc
-            !$acc end atomic 
-            filterc(fperv) = c
+            filterc(num_filterc) = c
          end if
       end do
       num_filterc_tot = num_filterc_tot+num_filterc
-      
       call Compute_EffecRootFrac_And_VertTranSink_Default(bounds, &
-               num_filterc, filterc, soilstate_inst )
-      
+               num_filterc,filterc, soilstate_inst )
+
+
       num_filterc = 0
-      !$acc parallel loop independent gang vector default(present) present(filterc(:)) private(c,l,fimperv) copy(num_filterc)
       do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          l = col_pp%landunit(c)
          if ( (col_pp%itype(c) /= icol_road_perv) ) then
-            !$acc atomic capture 
             num_filterc = num_filterc + 1
-            fimperv = num_filterc
-            !$acc end atomic
-            filterc(fimperv) = c
+            filterc(num_filterc) = c
          end if
       end do
       num_filterc_tot = num_filterc_tot+num_filterc
-
       if(use_hydrstress) then
          call Compute_EffecRootFrac_And_VertTranSink_HydStress(bounds, &
                num_filterc, filterc,  soilstate_inst, &
-               canopystate_inst)
+               canopystate_inst, energyflux_inst)
       else
          call Compute_EffecRootFrac_And_VertTranSink_Default(bounds, &
-            num_filterc,filterc, soilstate_inst)
+               num_filterc,filterc, soilstate_inst)
       end if
 
       if (num_hydrologyc /= num_filterc_tot) then
-          write(*,*) 'The total number of columns flagged to root water uptake'
-          write(*,*) 'did not match the total number calculated'
-          write(*,*) 'This is likely a problem with the interpretation of column/lu filters.'
+          write(iulog,*) 'The total number of columns flagged to root water uptake'
+          write(iulog,*) 'did not match the total number calculated'
+          write(iulog,*) 'This is likely a problem with the interpretation of column/lu filters.'
           call endrun(msg=errMsg(__FILE__, __LINE__))
-          stop 
       end if
 
-      !$acc exit data delete(&
-      !$acc filterc(:), fperv, fimperv)
 
+      return
    end subroutine Compute_EffecRootFrac_And_VertTranSink
 
    subroutine Compute_EffecRootFrac_And_VertTranSink_Default(bounds, num_filterc, &
          filterc, soilstate_vars)
+
     !
     ! Generic routine to apply transpiration as a sink condition that
     ! is vertically distributed over the soil column. Should be
@@ -1280,6 +1149,7 @@ contains
     ! hydraulics.
     !
     !USES:
+      !$acc routine seq
     use decompMod        , only : bounds_type
     use shr_kind_mod     , only : r8 => shr_kind_r8
     use elm_varpar       , only : nlevsoi, max_patch_per_col
@@ -1290,16 +1160,14 @@ contains
     ! !ARGUMENTS:
     type(bounds_type)    , intent(in)    :: bounds                          ! bounds
     integer              , intent(in)    :: num_filterc                     ! number of column soil points in column filter
-    integer              , intent(in)    :: filterc(1:num_filterc)            ! column filter for soil points
+    integer              , intent(in)    :: filterc(num_filterc)            ! column filter for soil points
     type(soilstate_type) , intent(inout) :: soilstate_vars
     !
     ! !LOCAL VARIABLES:
     integer  :: p,c,fc,j                                              ! do loop indices
     integer  :: pi                                                    ! patch index
     integer  :: nlevbed                                               ! number of layers to bedrock
-    real(r8) :: temp(1:num_filterc)                         ! accumulator for rootr weighting
-    real(r8) :: sum1, sum2
-    integer :: nlevbed_max
+    real(r8) :: temp(bounds%begc:bounds%endc)                         ! accumulator for rootr weighting
     associate(&
           nlev2bed            =>    col_pp%nlevbed                     , & ! Input:  [integer  (:)   ]  number of layers to bedrock
           qflx_rootsoi_col    => col_wf%qflx_rootsoi    , & ! Output: [real(r8) (:,:) ]
@@ -1314,10 +1182,6 @@ contains
           rootr_col           => soilstate_vars%rootr_col             & ! Output: [real(r8) (:,:) ]
                                                                         ! effective fraction of roots in each soil layer
           )
-      
-   !$acc enter data create(&
-   !$acc temp(:), &
-   !$acc sum1)
 
       ! First step is to calculate the column-level effective rooting
       ! fraction in each soil layer. This is done outside the usual
@@ -1325,90 +1189,84 @@ contains
       ! weighted average of the PATCH level rootr arrays. Instead, the
       ! weighting depends on both the per-unit-area transpiration
       ! of the PATCH and the PATCHEs area relative to all PATCHES.
-      nlevbed_max = maxval(nlev2bed)
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1)
-      do j = 1,nlevbed_max
+
+      temp(bounds%begc : bounds%endc) = 0._r8
+
+      do fc = 1, num_filterc
+         c = filterc(fc)
+         nlevbed = nlev2bed(c)
+         do j = 1, nlevbed
+            rootr_col(c,j) = 0._r8
+         end do
+      end do
+
+      do pi = 1,max_patch_per_col
          do fc = 1, num_filterc
             c = filterc(fc)
             nlevbed = nlev2bed(c)
-
-            if(j > nlev2bed(c)) cycle 
-            sum1 = 0._r8; 
-            !$acc loop vector reduction(+:sum1)
-            do p = col_pp%pfti(c), col_pp%pftf(c) 
-               if (veg_pp%active(p)) then
-                  sum1 = sum1 + rootr_patch(p,j) * qflx_tran_veg_patch(p) * veg_pp%wtcol(p)
-                  qflx_rootsoi_frac_patch(p,j) = rootr_patch(p,j) * qflx_tran_veg_patch(p) * veg_pp%wtcol(p)
+            do j = 1,nlevbed
+               if (pi <= col_pp%npfts(c)) then
+                  p = col_pp%pfti(c) + pi - 1
+                  if (veg_pp%active(p)) then
+                     rootr_col(c,j) = rootr_col(c,j) + rootr_patch(p,j) * &
+                          qflx_tran_veg_patch(p) * veg_pp%wtcol(p)
+                     qflx_rootsoi_frac_patch(p,j) = rootr_patch(p,j) * qflx_tran_veg_patch(p) * veg_pp%wtcol(p)
+                  end if
                end if
-            end do 
-            rootr_col(c,j) = sum1  
+            end do
          end do
-      end do
-
-      !$acc parallel loop independent gang worker default(present) private(sum1)
-      do fc = 1, num_filterc
-         c = filterc(fc)
-         sum1 = 0._r8;
-         !$acc loop vector reduction(+:sum1)
-         do p = col_pp%pfti(c), col_pp%pftf(c)
-            if (veg_pp%active(p)) then
-               sum1 = sum1 + qflx_tran_veg_patch(p) * veg_pp%wtcol(p)
+         do fc = 1, num_filterc
+            c = filterc(fc)
+            if (pi <= col_pp%npfts(c)) then
+               p = col_pp%pfti(c) + pi - 1
+               if (veg_pp%active(p)) then
+                  temp(c) = temp(c) + qflx_tran_veg_patch(p) * veg_pp%wtcol(p)
+               end if
             end if
-         end do 
-         temp(fc) = sum1 
+         end do
       end do
 
-      !$acc parallel loop independent gang vector default(present)
       do fc = 1, num_filterc
          c = filterc(fc)
          nlevbed = nlev2bed(c)
-         !$acc loop seq
          do j = 1, nlevbed
-            if (temp(fc) /= 0._r8) then
-               rootr_col(c,j) = rootr_col(c,j)/temp(fc)
+            if (temp(c) /= 0._r8) then
+               rootr_col(c,j) = rootr_col(c,j)/temp(c)
             end if
             qflx_rootsoi_col(c,j) = rootr_col(c,j)*qflx_tran_veg_col(c)
 
          end do
       end do
-      
-      !$acc parallel loop independent gang worker collapse(2) default(present)
-      do j = 1,nlevsoi
-         do fc = 1, num_filterc
-            c = filterc(fc)
-            if(rootr_col(c,j)==0._r8)then
-               !$acc loop vector independent
-               do p = col_pp%pfti(c), col_pp%pftf(c)
+
+      do pi = 1,max_patch_per_col
+         do j = 1,nlevsoi
+            do fc = 1, num_filterc
+               c = filterc(fc)
+               if (pi <= col_pp%npfts(c)) then
+                  p = col_pp%pfti(c) + pi - 1
                   if (veg_pp%active(p)) then
+                    if(rootr_col(c,j)==0._r8)then
                       qflx_rootsoi_frac_patch(p,j) = 0._r8
+                    else
+                      qflx_rootsoi_frac_patch(p,j) = qflx_rootsoi_frac_patch(p,j)/(temp(c)*rootr_col(c,j))
+                    endif
                   end if
-               end do 
-            else
-               !$acc loop vector independent 
-               do p = col_pp%pfti(c), col_pp%pftf(c)
-                  if (veg_pp%active(p)) then
-                     qflx_rootsoi_frac_patch(p,j) = qflx_rootsoi_frac_patch(p,j)*(1._r8/(temp(fc)*rootr_col(c,j)))
-                  end if
-               end do 
-            end if 
+               end if
+            end do
          end do
-      end do
-      
-    !$acc exit data delete(&
-    !$acc temp(:), &
-    !$acc sum1)
-
-   end associate
-
+       enddo
+    end associate
+    return
  end subroutine Compute_EffecRootFrac_And_VertTranSink_Default
 
    ! ==================================================================================
 
    subroutine Compute_EffecRootFrac_And_VertTranSink_HydStress( bounds, &
            num_filterc, filterc,  soilstate_vars, &
-           canopystate_vars)
+           canopystate_vars, energyflux_vars)
         !
         !USES:
+      !$acc routine seq
         use decompMod        , only : bounds_type
         use elm_varpar       , only : nlevsoi
         use elm_varpar       , only : max_patch_per_col
@@ -1419,6 +1277,8 @@ contains
         use elm_varctl       , only : iulog
         use PhotosynthesisMod, only : plc, params_inst
         use column_varcon    , only : icol_road_perv
+        use shr_infnan_mod   , only : isnan => shr_infnan_isnan
+        use EnergyFluxType   , only : energyflux_type
         use shr_kind_mod     , only : r8 => shr_kind_r8
         !
         ! !ARGUMENTS:
@@ -1427,6 +1287,7 @@ contains
         integer              , intent(in)    :: filterc(:)      ! column filter for soil points
         type(soilstate_type) , intent(inout) :: soilstate_vars
         type(canopystate_type) , intent(in)  :: canopystate_vars
+        type(energyflux_type), intent(in)    :: energyflux_vars
         !
         ! !LOCAL VARIABLES:
         integer  :: p,c,fc,j                                              ! do loop indices
@@ -1495,6 +1356,8 @@ contains
           end do
 
         end associate
+
+        return
      end subroutine Compute_EffecRootFrac_And_VertTranSink_HydStress
 
 
diff --git a/components/elm/src/biogeophys/SurfaceAlbedoMod.F90 b/components/elm/src/biogeophys/SurfaceAlbedoMod.F90
index 9adcac6740..6c90b49bed 100644
--- a/components/elm/src/biogeophys/SurfaceAlbedoMod.F90
+++ b/components/elm/src/biogeophys/SurfaceAlbedoMod.F90
@@ -12,7 +12,7 @@ module SurfaceAlbedoMod
   use abortutils        , only : endrun
   use decompMod         , only : bounds_type
   use landunit_varcon   , only : istsoil, istcrop, istdlak
-  use elm_varcon        , only : grlnd, namep
+  use elm_varcon        , only : grlnd, namep, namet
   use elm_varpar        , only : numrad, nlevcan, nlevsno, nlevcan
   use elm_varctl        , only : fsurdat, iulog, subgridflag, use_snicar_frc, use_fates, use_snicar_ad
   use VegetationPropertiesType    , only : veg_vp
@@ -30,7 +30,9 @@ module SurfaceAlbedoMod
 
   use SurfaceAlbedoType , only : lake_melt_icealb, alblak, alblakwi
   use SurfaceAlbedoType , only : albice, albsat, albdry, isoicol
-  !#fates_py use elm_instMod , only : alm_fates
+  use elm_instMod , only : alm_fates
+  use topounit_varcon   , only : max_topounits  
+  use TopounitType      , only : top_pp
   !
   implicit none
   save
@@ -47,9 +49,6 @@ module SurfaceAlbedoMod
   real(r8), parameter :: calb = 95.6_r8
   !$acc declare copyin(calb)
 
-
-  !-----------------------------------------------------------------------
-
 contains
 
 
@@ -88,9 +87,9 @@ contains
     ! only computed over active points.
     !
     ! !USES:
-    !$acc routine seq
-    use elm_varctl         , only : subgridflag, use_snicar_frc, use_fates, use_snicar_ad
-    use shr_orb_mod_elm
+      !$acc routine seq
+    use elm_varctl         , only : iulog, subgridflag, use_snicar_frc, use_fates, use_snicar_ad
+    use shr_orb_mod
 
     !
     ! !ARGUMENTS:
@@ -111,8 +110,8 @@ contains
     type(surfalb_type)     , intent(inout) :: surfalb_vars
     !
     ! !LOCAL VARIABLES:
-    integer  :: i                          ! index for layers [idx]
-    integer  :: aer                        ! index for sno_nbr_aer
+    integer  :: i                                                                         ! index for layers [idx]
+    integer  :: aer                                                                       ! index for sno_nbr_aer
     real(r8) :: extkn                      ! nitrogen allocation coefficient
     integer  :: fp,fc,g,c,p,iv             ! indices
     integer  :: ib                         ! band index
@@ -122,44 +121,44 @@ contains
     real(r8) :: dincmax_sum                ! cumulative sum of maximum lai+sai increment for canopy layer
     real(r8) :: laisum                     ! sum of canopy layer lai for error check
     real(r8) :: saisum                     ! sum of canopy layer sai for error check
-    integer  :: flg_slr                                     ! flag for SNICAR (=1 if direct, =2 if diffuse)
-    integer  :: flg_snw_ice                                 ! flag for SNICAR (=1 when called from ELM, =2 when called from sea-ice)
-    integer  :: num_vegsol                                  ! number of vegetated patches where coszen>0
-    integer  :: num_novegsol                                ! number of vegetated patches where coszen>0
-    integer  :: filter_vegsol   (bounds%endp-bounds%begp+1) ! patch filter where vegetated and coszen>0
-    integer  :: filter_novegsol (bounds%endp-bounds%begp+1) ! patch filter where vegetated and coszen>0
-    real(r8) :: wl              (bounds%begp:bounds%endp)   ! fraction of LAI+SAI that is LAI
-    real(r8) :: ws              (bounds%begp:bounds%endp)   ! fraction of LAI+SAI that is SAI
+    integer  :: flg_slr                                                                   ! flag for SNICAR (=1 if direct, =2 if diffuse)
+    integer  :: flg_snw_ice                                                               ! flag for SNICAR (=1 when called from ELM, =2 when called from sea-ice)
+    integer  :: num_vegsol                                                                ! number of vegetated patches where coszen>0
+    integer  :: num_novegsol                                                              ! number of vegetated patches where coszen>0
+    integer  :: filter_vegsol   (bounds%endp-bounds%begp+1)                               ! patch filter where vegetated and coszen>0
+    integer  :: filter_novegsol (bounds%endp-bounds%begp+1)                               ! patch filter where vegetated and coszen>0
+    real(r8) :: wl              (bounds%begp:bounds%endp)                                 ! fraction of LAI+SAI that is LAI
+    real(r8) :: ws              (bounds%begp:bounds%endp)                                 ! fraction of LAI+SAI that is SAI
     real(r8) :: blai(bounds%begp:bounds%endp)              ! lai buried by snow: tlai - elai
     real(r8) :: bsai(bounds%begp:bounds%endp)              ! sai buried by snow: tsai - esai
-    real(r8) :: coszen_gcell    (bounds%begg:bounds%endg)  ! cosine solar zenith angle for next time step (grc)
-    real(r8) :: coszen_patch    (bounds%begp:bounds%endp)  ! cosine solar zenith angle for next time step (pft)
+    real(r8) :: coszen_gcell    (bounds%begg:bounds%endg)                                 ! cosine solar zenith angle for next time step (grc)
+    real(r8) :: coszen_patch    (bounds%begp:bounds%endp)                                 ! cosine solar zenith angle for next time step (pft)
     real(r8) :: rho(bounds%begp:bounds%endp,numrad)        ! leaf/stem refl weighted by fraction LAI and SAI
     real(r8) :: tau(bounds%begp:bounds%endp,numrad)        ! leaf/stem tran weighted by fraction LAI and SAI
-    real(r8) :: albsfc(numrad)                          ! albedo of surface underneath snow (col,bnd)
+    real(r8) :: albsfc          (bounds%begc:bounds%endc,numrad)                          ! albedo of surface underneath snow (col,bnd)
     real(r8) :: albsnd(bounds%begc:bounds%endc,numrad)     ! snow albedo (direct)
     real(r8) :: albsni(bounds%begc:bounds%endc,numrad)     ! snow albedo (diffuse)
-    real(r8) :: albsnd_pur      (numrad)                          ! direct pure snow albedo (radiative forcing)
-    real(r8) :: albsni_pur      (numrad)                          ! diffuse pure snow albedo (radiative forcing)
-    real(r8) :: albsnd_bc       (numrad)                          ! direct snow albedo without BC (radiative forcing)
-    real(r8) :: albsni_bc       (numrad)                          ! diffuse snow albedo without BC (radiative forcing)
-    real(r8) :: albsnd_oc       (numrad)                          ! direct snow albedo without OC (radiative forcing)
-    real(r8) :: albsni_oc       (numrad)                          ! diffuse snow albedo without OC (radiative forcing)
-    real(r8) :: albsnd_dst      (numrad)                          ! direct snow albedo without dust (radiative forcing)
-    real(r8) :: albsni_dst      (numrad)                          ! diffuse snow albedo without dust (radiative forcing)
-    real(r8) :: flx_absd_snw    (-nlevsno+1:1,numrad)             ! flux absorption factor for just snow (direct) [frc]
-    real(r8) :: flx_absi_snw    (-nlevsno+1:1,numrad)             ! flux absorption factor for just snow (diffuse) [frc]
-    real(r8) :: foo_snw         (-nlevsno+1:1,numrad)             ! dummy array for forcing calls
-    real(r8) :: h2osno_liq      (-nlevsno+1:0)                    ! liquid snow content (col,lyr) [kg m-2]
-    real(r8) :: h2osno_ice      (-nlevsno+1:0)                    ! ice content in snow (col,lyr) [kg m-2]
-    integer  :: snw_rds_in      (-nlevsno+1:0)                    ! snow grain size sent to SNICAR (col,lyr) [microns]
-    real(r8) :: mss_cnc_aer_in_frc_pur (-nlevsno+1:0,sno_nbr_aer) ! mass concentration of aerosol species for forcing calculation (zero) (col,lyr,aer) [kg kg-1]
-    real(r8) :: mss_cnc_aer_in_frc_bc  (-nlevsno+1:0,sno_nbr_aer) ! mass concentration of aerosol species for BC forcing (col,lyr,aer) [kg kg-1]
-    real(r8) :: mss_cnc_aer_in_frc_oc  (-nlevsno+1:0,sno_nbr_aer) ! mass concentration of aerosol species for OC forcing (col,lyr,aer) [kg kg-1]
-    real(r8) :: mss_cnc_aer_in_frc_dst (-nlevsno+1:0,sno_nbr_aer) ! mass concentration of aerosol species for dust forcing (col,lyr,aer) [kg kg-1]
-    real(r8) :: mss_cnc_aer_in_fdb     (-nlevsno+1:0,sno_nbr_aer) ! mass concentration of all aerosol species for feedback calculation (col,lyr,aer) [kg kg-1]
-    real(r8), parameter :: mpe = 1.e-06_r8     ! prevents overflow for division by zero
-    integer , parameter :: nband =numrad       ! number of solar radiation waveband classes
+    real(r8) :: albsnd_pur      (bounds%begc:bounds%endc,numrad)                          ! direct pure snow albedo (radiative forcing)
+    real(r8) :: albsni_pur      (bounds%begc:bounds%endc,numrad)                          ! diffuse pure snow albedo (radiative forcing)
+    real(r8) :: albsnd_bc       (bounds%begc:bounds%endc,numrad)                          ! direct snow albedo without BC (radiative forcing)
+    real(r8) :: albsni_bc       (bounds%begc:bounds%endc,numrad)                          ! diffuse snow albedo without BC (radiative forcing)
+    real(r8) :: albsnd_oc       (bounds%begc:bounds%endc,numrad)                          ! direct snow albedo without OC (radiative forcing)
+    real(r8) :: albsni_oc       (bounds%begc:bounds%endc,numrad)                          ! diffuse snow albedo without OC (radiative forcing)
+    real(r8) :: albsnd_dst      (bounds%begc:bounds%endc,numrad)                          ! direct snow albedo without dust (radiative forcing)
+    real(r8) :: albsni_dst      (bounds%begc:bounds%endc,numrad)                          ! diffuse snow albedo without dust (radiative forcing)
+    real(r8) :: flx_absd_snw    (bounds%begc:bounds%endc,-nlevsno+1:1,numrad)             ! flux absorption factor for just snow (direct) [frc]
+    real(r8) :: flx_absi_snw    (bounds%begc:bounds%endc,-nlevsno+1:1,numrad)             ! flux absorption factor for just snow (diffuse) [frc]
+    real(r8) :: foo_snw         (bounds%begc:bounds%endc,-nlevsno+1:1,numrad)             ! dummy array for forcing calls
+    real(r8) :: h2osno_liq      (bounds%begc:bounds%endc,-nlevsno+1:0)                    ! liquid snow content (col,lyr) [kg m-2]
+    real(r8) :: h2osno_ice      (bounds%begc:bounds%endc,-nlevsno+1:0)                    ! ice content in snow (col,lyr) [kg m-2]
+    integer  :: snw_rds_in      (bounds%begc:bounds%endc,-nlevsno+1:0)                    ! snow grain size sent to SNICAR (col,lyr) [microns]
+    real(r8) :: mss_cnc_aer_in_frc_pur (bounds%begc:bounds%endc,-nlevsno+1:0,sno_nbr_aer) ! mass concentration of aerosol species for forcing calculation (zero) (col,lyr,aer) [kg kg-1]
+    real(r8) :: mss_cnc_aer_in_frc_bc  (bounds%begc:bounds%endc,-nlevsno+1:0,sno_nbr_aer) ! mass concentration of aerosol species for BC forcing (col,lyr,aer) [kg kg-1]
+    real(r8) :: mss_cnc_aer_in_frc_oc  (bounds%begc:bounds%endc,-nlevsno+1:0,sno_nbr_aer) ! mass concentration of aerosol species for OC forcing (col,lyr,aer) [kg kg-1]
+    real(r8) :: mss_cnc_aer_in_frc_dst (bounds%begc:bounds%endc,-nlevsno+1:0,sno_nbr_aer) ! mass concentration of aerosol species for dust forcing (col,lyr,aer) [kg kg-1]
+    real(r8) :: mss_cnc_aer_in_fdb     (bounds%begc:bounds%endc,-nlevsno+1:0,sno_nbr_aer) ! mass concentration of all aerosol species for feedback calculation (col,lyr,aer) [kg kg-1]
+    real(r8), parameter :: mpe = 1.e-06_r8                                                ! prevents overflow for division by zero
+    integer , parameter :: nband =numrad                                                  ! number of solar radiation waveband classes
   !-----------------------------------------------------------------------
 
    associate(&
@@ -286,6 +285,7 @@ contains
           ftii(p,ib) = 0._r8
 
        end do
+
     end do  ! end of numrad loop
 
     ! SoilAlbedo called before SNICAR_RT/SNICAR_AD_RT
@@ -302,220 +302,354 @@ contains
 
        call SoilAlbedo(bounds, &
             num_nourbanc, filter_nourbanc, &
-            coszen_col(bounds%begc:bounds%endc), &
-            albsnd(bounds%begc:bounds%endc, :), &
+         coszen_col(bounds%begc:bounds%endc), &
+         albsnd(bounds%begc:bounds%endc, :), &
             albsni(bounds%begc:bounds%endc, :), &
             lakestate_vars, surfalb_vars)
 
     ! set variables to pass to SNICAR.
 
     flg_snw_ice = 1   ! calling from ELM, not CSIM
-    do fc = 1,num_nourbanc
-
-      c = filter_nourbanc(fc)
-      if(coszen_col(c) < 0._r8) cycle
-      albsfc(:)     = albsoi(c,:)
-      h2osno_liq(:) = h2osoi_liq(c,-nlevsno+1:0)
-      h2osno_ice(:) = h2osoi_ice(c,-nlevsno+1:0)
-      snw_rds_in(:) = nint(snw_rds(c,:))
+    do c=bounds%begc,bounds%endc
+       albsfc(c,:)     = albsoi(c,:)
+       h2osno_liq(c,:) = h2osoi_liq(c,-nlevsno+1:0)
+       h2osno_ice(c,:) = h2osoi_ice(c,-nlevsno+1:0)
+       snw_rds_in(c,:) = nint(snw_rds(c,:))
+    end do
 
-      ! zero aerosol input arrays
-      do aer = 1, sno_nbr_aer
+    ! zero aerosol input arrays
+    do aer = 1, sno_nbr_aer
        do i = -nlevsno+1, 0
-         mss_cnc_aer_in_frc_pur(i,aer) = 0._r8
-         mss_cnc_aer_in_frc_bc(i,aer)  = 0._r8
-         mss_cnc_aer_in_frc_oc(i,aer)  = 0._r8
-         mss_cnc_aer_in_frc_dst(i,aer) = 0._r8
-         mss_cnc_aer_in_fdb(i,aer)     = 0._r8
+          do c = bounds%begc, bounds%endc
+             mss_cnc_aer_in_frc_pur(c,i,aer) = 0._r8
+             mss_cnc_aer_in_frc_bc(c,i,aer)  = 0._r8
+             mss_cnc_aer_in_frc_oc(c,i,aer)  = 0._r8
+             mss_cnc_aer_in_frc_dst(c,i,aer) = 0._r8
+             mss_cnc_aer_in_fdb(c,i,aer)     = 0._r8
+          end do
        end do
-      end do
-
-      ! Set aerosol input arrays
-      ! feedback input arrays have been zeroed
-      ! set soot and dust aerosol concentrations:
-      if (DO_SNO_AER) then
-         mss_cnc_aer_in_fdb(:,1) = mss_cnc_bcphi(c,:)
-         mss_cnc_aer_in_fdb(:,2) = mss_cnc_bcpho(c,:)
-
-         ! DO_SNO_OC is set in SNICAR_varpar. Default case is to ignore OC concentrations because:
-         !  1) Knowledge of their optical properties is primitive
-         !  2) When 'water-soluble' OPAC optical properties are applied to OC in snow,
-         !     it has a negligible darkening effect.
-         if (DO_SNO_OC) then
-            mss_cnc_aer_in_fdb(:,3) = mss_cnc_ocphi(c,:)
-            mss_cnc_aer_in_fdb(:,4) = mss_cnc_ocpho(c,:)
-         endif
-
-         mss_cnc_aer_in_fdb(:,5) = mss_cnc_dst1(c,:)
-         mss_cnc_aer_in_fdb(:,6) = mss_cnc_dst2(c,:)
-         mss_cnc_aer_in_fdb(:,7) = mss_cnc_dst3(c,:)
-         mss_cnc_aer_in_fdb(:,8) = mss_cnc_dst4(c,:)
-      endif
-
-      ! If radiative forcing is being calculated, first estimate clean-snow albedo
-      if (use_snicar_frc) then
-         ! 1. BC input array:
-         !  set dust and (optionally) OC concentrations, so BC_FRC=[(BC+OC+dust)-(OC+dust)]
-         mss_cnc_aer_in_frc_bc(:,5) = mss_cnc_dst1(c,:)
-         mss_cnc_aer_in_frc_bc(:,6) = mss_cnc_dst2(c,:)
-         mss_cnc_aer_in_frc_bc(:,7) = mss_cnc_dst3(c,:)
-         mss_cnc_aer_in_frc_bc(:,8) = mss_cnc_dst4(c,:)
-         if (DO_SNO_OC) then
-           mss_cnc_aer_in_frc_bc(:,3) = mss_cnc_ocphi(c,:)
-           mss_cnc_aer_in_frc_bc(:,4) = mss_cnc_ocpho(c,:)
-        endif
+    end do
+
+    ! Set aerosol input arrays
+    ! feedback input arrays have been zeroed
+    ! set soot and dust aerosol concentrations:
+    if (DO_SNO_AER) then
+       mss_cnc_aer_in_fdb(bounds%begc:bounds%endc,:,1) = mss_cnc_bcphi(bounds%begc:bounds%endc,:)
+       mss_cnc_aer_in_fdb(bounds%begc:bounds%endc,:,2) = mss_cnc_bcpho(bounds%begc:bounds%endc,:)
+
+       ! DO_SNO_OC is set in SNICAR_varpar. Default case is to ignore OC concentrations because:
+       !  1) Knowledge of their optical properties is primitive
+       !  2) When 'water-soluble' OPAC optical properties are applied to OC in snow,
+       !     it has a negligible darkening effect.
+       if (DO_SNO_OC) then
+          mss_cnc_aer_in_fdb(bounds%begc:bounds%endc,:,3) = mss_cnc_ocphi(bounds%begc:bounds%endc,:)
+          mss_cnc_aer_in_fdb(bounds%begc:bounds%endc,:,4) = mss_cnc_ocpho(bounds%begc:bounds%endc,:)
+       endif
 
+       mss_cnc_aer_in_fdb(bounds%begc:bounds%endc,:,5) = mss_cnc_dst1(bounds%begc:bounds%endc,:)
+       mss_cnc_aer_in_fdb(bounds%begc:bounds%endc,:,6) = mss_cnc_dst2(bounds%begc:bounds%endc,:)
+       mss_cnc_aer_in_fdb(bounds%begc:bounds%endc,:,7) = mss_cnc_dst3(bounds%begc:bounds%endc,:)
+       mss_cnc_aer_in_fdb(bounds%begc:bounds%endc,:,8) = mss_cnc_dst4(bounds%begc:bounds%endc,:)
+    endif
+
+    ! If radiative forcing is being calculated, first estimate clean-snow albedo
+
+    if (use_snicar_frc) then
+       ! 1. BC input array:
+       !  set dust and (optionally) OC concentrations, so BC_FRC=[(BC+OC+dust)-(OC+dust)]
+       mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc,:,5) = mss_cnc_dst1(bounds%begc:bounds%endc,:)
+       mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc,:,6) = mss_cnc_dst2(bounds%begc:bounds%endc,:)
+       mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc,:,7) = mss_cnc_dst3(bounds%begc:bounds%endc,:)
+       mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc,:,8) = mss_cnc_dst4(bounds%begc:bounds%endc,:)
+       if (DO_SNO_OC) then
+          mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc,:,3) = mss_cnc_ocphi(bounds%begc:bounds%endc,:)
+          mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc,:,4) = mss_cnc_ocpho(bounds%begc:bounds%endc,:)
+       endif
 
        ! BC FORCING CALCULATIONS
           flg_slr = 1; ! direct-beam
-          call SNICAR_AD_RT(flg_snw_ice, fc, c,    &
-                           coszen_col(c), &
-                           flg_slr, &
-                           h2osno_liq(:), &
-                           h2osno_ice(:), &
-                           snw_rds_in(:), &
-                           mss_cnc_aer_in_frc_bc( :, :), &
-                           albsfc( :), &
-                           albsnd_bc( :), &
-                           foo_snw(:, :) )
+          if (use_snicar_ad) then
+              call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                                coszen_col(bounds%begc:bounds%endc), &
+                                flg_slr, &
+                                h2osno_liq(bounds%begc:bounds%endc, :), &
+                                h2osno_ice(bounds%begc:bounds%endc, :), &
+                                snw_rds_in(bounds%begc:bounds%endc, :), &
+                                mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc, :, :), &
+                                albsfc(bounds%begc:bounds%endc, :), &
+                                albsnd_bc(bounds%begc:bounds%endc, :), &
+                                foo_snw(bounds%begc:bounds%endc, :, :) )
+          else
+                call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
+                             flg_slr, &
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsnd_bc(bounds%begc:bounds%endc, :), &
+                             foo_snw(bounds%begc:bounds%endc, :, :) )
 
+          endif ! end if use_snicar_ad
 
           flg_slr = 2; ! diffuse
-              call SNICAR_AD_RT(flg_snw_ice, fc, c, &
-                            coszen_col(c), &
-                            flg_slr, &
-                            h2osno_liq(:), &
-                            h2osno_ice(:), &
-                            snw_rds_in(:), &
-                            mss_cnc_aer_in_frc_bc(:, :), &
-                            albsfc( :), &
-                            albsni_bc(:), &
-                            foo_snw(:, :) )
-
-          ! 2. OC input array:
-          !  set BC and dust concentrations, so OC_FRC=[(BC+OC+dust)-(BC+dust)]
-          if (DO_SNO_OC) then
-             mss_cnc_aer_in_frc_oc(:,1) = mss_cnc_bcphi(c,:)
-             mss_cnc_aer_in_frc_oc(:,2) = mss_cnc_bcpho(c,:)
-             mss_cnc_aer_in_frc_oc(:,5) = mss_cnc_dst1(c,:)
-             mss_cnc_aer_in_frc_oc(:,6) = mss_cnc_dst2(c,:)
-             mss_cnc_aer_in_frc_oc(:,7) = mss_cnc_dst3(c,:)
-             mss_cnc_aer_in_frc_oc(:,8) = mss_cnc_dst4(c,:)
-
-            ! OC FORCING CALCULATIONS
-            flg_slr = 1; ! direct-beam
-            call SNICAR_AD_RT(flg_snw_ice, fc, c,    &
-                             coszen_col(c), &
+          if (use_snicar_ad) then
+              call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                                coszen_col(bounds%begc:bounds%endc), &
+                                flg_slr, &
+                                h2osno_liq(bounds%begc:bounds%endc, :), &
+                                h2osno_ice(bounds%begc:bounds%endc, :), &
+                                snw_rds_in(bounds%begc:bounds%endc, :), &
+                                mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc, :, :), &
+                                albsfc(bounds%begc:bounds%endc, :), &
+                                albsni_bc(bounds%begc:bounds%endc, :), &
+                                foo_snw(bounds%begc:bounds%endc, :, :) )
+          else
+              call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
                              flg_slr, &
-                             h2osno_liq(:), &
-                             h2osno_ice(:), &
-                             snw_rds_in(:), &
-                             mss_cnc_aer_in_frc_oc( :, :), &
-                             albsfc( :), &
-                             albsnd_oc( :), &
-                             foo_snw(:, :) )
-
-             flg_slr = 2; ! diffuse
-             call SNICAR_AD_RT(flg_snw_ice, fc,c,    &
-                            coszen_col(c), &
-                            flg_slr, &
-                            h2osno_liq( :), &
-                            h2osno_ice( :), &
-                            snw_rds_in( :), &
-                            mss_cnc_aer_in_frc_oc( :, :), &
-                            albsfc( :), &
-                            albsni_oc(:), &
-                            foo_snw(:, :) )
-          endif
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_frc_bc(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsni_bc(bounds%begc:bounds%endc, :), &
+                             foo_snw(bounds%begc:bounds%endc, :, :) )
+          endif ! end if use_snicar_ad
+
+       ! 2. OC input array:
+       !  set BC and dust concentrations, so OC_FRC=[(BC+OC+dust)-(BC+dust)]
+       if (DO_SNO_OC) then
+          mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc,:,1) = mss_cnc_bcphi(bounds%begc:bounds%endc,:)
+          mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc,:,2) = mss_cnc_bcpho(bounds%begc:bounds%endc,:)
+          mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc,:,5) = mss_cnc_dst1(bounds%begc:bounds%endc,:)
+          mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc,:,6) = mss_cnc_dst2(bounds%begc:bounds%endc,:)
+          mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc,:,7) = mss_cnc_dst3(bounds%begc:bounds%endc,:)
+          mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc,:,8) = mss_cnc_dst4(bounds%begc:bounds%endc,:)
+
+       ! OC FORCING CALCULATIONS
+          flg_slr = 1; ! direct-beam
+          if (use_snicar_ad) then
+              call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                                coszen_col(bounds%begc:bounds%endc), &
+                                flg_slr, &
+                                h2osno_liq(bounds%begc:bounds%endc, :), &
+                                h2osno_ice(bounds%begc:bounds%endc, :), &
+                                snw_rds_in(bounds%begc:bounds%endc, :), &
+                                mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc, :, :), &
+                                albsfc(bounds%begc:bounds%endc, :), &
+                                albsnd_oc(bounds%begc:bounds%endc, :), &
+                                foo_snw(bounds%begc:bounds%endc, :, :) )
+          else
+              call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
+                             flg_slr, &
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsnd_oc(bounds%begc:bounds%endc, :), &
+                             foo_snw(bounds%begc:bounds%endc, :, :) )
+          endif ! end if use_snicar_ad
+
+          flg_slr = 2; ! diffuse
+          if (use_snicar_ad) then
+              call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                                coszen_col(bounds%begc:bounds%endc), &
+                                flg_slr, &
+                                h2osno_liq(bounds%begc:bounds%endc, :), &
+                                h2osno_ice(bounds%begc:bounds%endc, :), &
+                                snw_rds_in(bounds%begc:bounds%endc, :), &
+                                mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc, :, :), &
+                                albsfc(bounds%begc:bounds%endc, :), &
+                                albsni_oc(bounds%begc:bounds%endc, :), &
+                                foo_snw(bounds%begc:bounds%endc, :, :) )
+          else
+              call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
+                             flg_slr, &
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_frc_oc(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsni_oc(bounds%begc:bounds%endc, :), &
+                             foo_snw(bounds%begc:bounds%endc, :, :) )
+          endif ! end if use_snicar_ad
+       endif
 
        ! 3. DUST input array:
        ! set BC and OC concentrations, so DST_FRC=[(BC+OC+dust)-(BC+OC)]
-       mss_cnc_aer_in_frc_dst(:,1) = mss_cnc_bcphi(c,:)
-       mss_cnc_aer_in_frc_dst(:,2) = mss_cnc_bcpho(c,:)
+       mss_cnc_aer_in_frc_dst(bounds%begc:bounds%endc,:,1) = mss_cnc_bcphi(bounds%begc:bounds%endc,:)
+       mss_cnc_aer_in_frc_dst(bounds%begc:bounds%endc,:,2) = mss_cnc_bcpho(bounds%begc:bounds%endc,:)
        if (DO_SNO_OC) then
-          mss_cnc_aer_in_frc_dst(:,3) = mss_cnc_ocphi(c,:)
-          mss_cnc_aer_in_frc_dst(:,4) = mss_cnc_ocpho(c,:)
+          mss_cnc_aer_in_frc_dst(bounds%begc:bounds%endc,:,3) = mss_cnc_ocphi(bounds%begc:bounds%endc,:)
+          mss_cnc_aer_in_frc_dst(bounds%begc:bounds%endc,:,4) = mss_cnc_ocpho(bounds%begc:bounds%endc,:)
        endif
 
        ! DUST FORCING CALCULATIONS
-       flg_slr = 1; ! direct-beam
-       call SNICAR_AD_RT(flg_snw_ice,fc, c,   &
-                             coszen_col(c), &
+          flg_slr = 1; ! direct-beam
+          if (use_snicar_ad) then
+              call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                                coszen_col(bounds%begc:bounds%endc), &
+                                flg_slr, &
+                                h2osno_liq(bounds%begc:bounds%endc, :), &
+                                h2osno_ice(bounds%begc:bounds%endc, :), &
+                                snw_rds_in(bounds%begc:bounds%endc, :), &
+                                mss_cnc_aer_in_frc_dst(bounds%begc:bounds%endc, :, :), &
+                                albsfc(bounds%begc:bounds%endc, :), &
+                                albsnd_dst(bounds%begc:bounds%endc, :), &
+                                foo_snw(bounds%begc:bounds%endc, :, :) )
+          else
+              call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
                              flg_slr, &
-                             h2osno_liq( :), &
-                             h2osno_ice( :), &
-                             snw_rds_in( :), &
-                             mss_cnc_aer_in_frc_dst( :, :), &
-                             albsfc( :), &
-                             albsnd_dst(:), &
-                             foo_snw(:, :) )
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_frc_dst(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsnd_dst(bounds%begc:bounds%endc, :), &
+                             foo_snw(bounds%begc:bounds%endc, :, :) )
+          endif ! end if use_snicar_ad
 
-       flg_slr = 2; ! diffuse
-       call SNICAR_AD_RT(flg_snw_ice,fc, c,    &
-                            coszen_col(c), &
-                            flg_slr, &
-                            h2osno_liq( :), &
-                            h2osno_ice( :), &
-                            snw_rds_in( :), &
-                            mss_cnc_aer_in_frc_dst( :, :), &
-                            albsfc( :), &
-                            albsni_dst(:), &
-                            foo_snw(:, :)  )
+          flg_slr = 2; ! diffuse
+          if (use_snicar_ad) then
+              call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                                coszen_col(bounds%begc:bounds%endc), &
+                                flg_slr, &
+                                h2osno_liq(bounds%begc:bounds%endc, :), &
+                                h2osno_ice(bounds%begc:bounds%endc, :), &
+                                snw_rds_in(bounds%begc:bounds%endc, :), &
+                                mss_cnc_aer_in_frc_dst(bounds%begc:bounds%endc, :, :), &
+                                albsfc(bounds%begc:bounds%endc, :), &
+                                albsni_dst(bounds%begc:bounds%endc, :), &
+                                foo_snw(bounds%begc:bounds%endc, :, :) )
+          else
+              call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
+                             flg_slr, &
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_frc_dst(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsni_dst(bounds%begc:bounds%endc, :), &
+                             foo_snw(bounds%begc:bounds%endc, :, :)  )
+          endif ! end if use_snicar_ad
 
        ! 4. ALL AEROSOL FORCING CALCULATION
        ! (pure snow albedo)
-       flg_slr = 1; ! direct-beam
-       call SNICAR_AD_RT(flg_snw_ice,fc, c,    &
-                            coszen_col(c), &
-                            flg_slr, &
-                            h2osno_liq( :), &
-                            h2osno_ice( :), &
-                            snw_rds_in( :), &
-                            mss_cnc_aer_in_frc_pur( :, :), &
-                            albsfc(:), &
-                            albsnd_pur(:), &
-                            foo_snw(:, :) )
+          flg_slr = 1; ! direct-beam
+          if (use_snicar_ad) then
+              call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                                coszen_col(bounds%begc:bounds%endc), &
+                                flg_slr, &
+                                h2osno_liq(bounds%begc:bounds%endc, :), &
+                                h2osno_ice(bounds%begc:bounds%endc, :), &
+                                snw_rds_in(bounds%begc:bounds%endc, :), &
+                                mss_cnc_aer_in_frc_pur(bounds%begc:bounds%endc, :, :), &
+                                albsfc(bounds%begc:bounds%endc, :), &
+                                albsnd_pur(bounds%begc:bounds%endc, :), &
+                                foo_snw(bounds%begc:bounds%endc, :, :) )
+          else
+              call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
+                             flg_slr, &
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_frc_pur(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsnd_pur(bounds%begc:bounds%endc, :), &
+                             foo_snw(bounds%begc:bounds%endc, :, :) )
+          endif ! end if use_snicar_ad
+
+          flg_slr = 2; ! diffuse
+          if (use_snicar_ad) then
+              call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                                coszen_col(bounds%begc:bounds%endc), &
+                                flg_slr, &
+                                h2osno_liq(bounds%begc:bounds%endc, :), &
+                                h2osno_ice(bounds%begc:bounds%endc, :), &
+                                snw_rds_in(bounds%begc:bounds%endc, :), &
+                                mss_cnc_aer_in_frc_pur(bounds%begc:bounds%endc, :, :), &
+                                albsfc(bounds%begc:bounds%endc, :), &
+                                albsni_pur(bounds%begc:bounds%endc, :), &
+                                foo_snw(bounds%begc:bounds%endc, :, :) )
+          else
+              call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
+                             flg_slr, &
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_frc_pur(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsni_pur(bounds%begc:bounds%endc, :), &
+                             foo_snw(bounds%begc:bounds%endc, :, :) )
+          endif ! end if use_snicar_ad
+    end if !end if use_snicar_frc
 
-       flg_slr = 2; ! diffuse
-       call SNICAR_AD_RT(flg_snw_ice,fc, c, &
-                            coszen_col(c), &
-                            flg_slr, &
-                            h2osno_liq( :), &
-                            h2osno_ice( :), &
-                            snw_rds_in( :), &
-                            mss_cnc_aer_in_frc_pur( :, :), &
-                            albsfc( :), &
-                            albsni_pur(:), &
-                            foo_snw(:, :) )
-      end if !end if use_snicar_frc
 
     ! CLIMATE FEEDBACK CALCULATIONS, ALL AEROSOLS:
-    flg_slr = 1; ! direct-beam
-    call SNICAR_AD_RT(flg_snw_ice,fc, c,    &
-                         coszen_col(c), &
-                         flg_slr, &
-                         h2osno_liq(:), &
-                         h2osno_ice(:), &
-                         snw_rds_in(:), &
-                         mss_cnc_aer_in_fdb( :, :), &
-                         albsfc(:), &
-                         albsnd(c,:), &
-                         flx_absd_snw(:, :) )
-
-     flg_slr = 2; ! diffuse
-     call SNICAR_AD_RT(flg_snw_ice, fc, c,    &
-                             coszen_col(c), &
+       flg_slr = 1; ! direct-beam
+       if (use_snicar_ad) then
+           call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
+                             flg_slr, &
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_fdb(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsnd(bounds%begc:bounds%endc, :), &
+                             flx_absd_snw(bounds%begc:bounds%endc, :, :) )
+       else
+            call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                           coszen_col(bounds%begc:bounds%endc), &
+                           flg_slr, &
+                           h2osno_liq(bounds%begc:bounds%endc, :), &
+                           h2osno_ice(bounds%begc:bounds%endc, :), &
+                           snw_rds_in(bounds%begc:bounds%endc, :), &
+                           mss_cnc_aer_in_fdb(bounds%begc:bounds%endc, :, :), &
+                           albsfc(bounds%begc:bounds%endc, :), &
+                           albsnd(bounds%begc:bounds%endc, :), &
+                           flx_absd_snw(bounds%begc:bounds%endc, :, :) )
+       endif ! end if use_snicar_ad
+
+       flg_slr = 2; ! diffuse
+       if (use_snicar_ad) then
+           call SNICAR_AD_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                             coszen_col(bounds%begc:bounds%endc), &
                              flg_slr, &
-                             h2osno_liq( :), &
-                             h2osno_ice( :), &
-                             snw_rds_in( :), &
-                             mss_cnc_aer_in_fdb( :, :), &
-                             albsfc( :), &
-                             albsni(c, :), &
-                             flx_absi_snw( :, :) )
+                             h2osno_liq(bounds%begc:bounds%endc, :), &
+                             h2osno_ice(bounds%begc:bounds%endc, :), &
+                             snw_rds_in(bounds%begc:bounds%endc, :), &
+                             mss_cnc_aer_in_fdb(bounds%begc:bounds%endc, :, :), &
+                             albsfc(bounds%begc:bounds%endc, :), &
+                             albsni(bounds%begc:bounds%endc, :), &
+                             flx_absi_snw(bounds%begc:bounds%endc, :, :) )
+       else
+            call SNICAR_RT(flg_snw_ice, bounds, num_nourbanc, filter_nourbanc,    &
+                           coszen_col(bounds%begc:bounds%endc), &
+                           flg_slr, &
+                           h2osno_liq(bounds%begc:bounds%endc, :), &
+                           h2osno_ice(bounds%begc:bounds%endc, :), &
+                           snw_rds_in(bounds%begc:bounds%endc, :), &
+                           mss_cnc_aer_in_fdb(bounds%begc:bounds%endc, :, :), &
+                           albsfc(bounds%begc:bounds%endc, :), &
+                           albsni(bounds%begc:bounds%endc, :), &
+                           flx_absi_snw(bounds%begc:bounds%endc, :, :) )
+       endif ! end if use_snicar_ad
 
     ! ground albedos and snow-fraction weighting of snow absorption factors
     do ib = 1, nband
+       do fc = 1,num_nourbanc
+          c = filter_nourbanc(fc)
+             if (coszen_col(c) > 0._r8) then
              ! ground albedo was originally computed in SoilAlbedo, but is now computed here
              ! because the order of SoilAlbedo and SNICAR_RT/SNICAR_AD_RT was switched for SNICAR/SNICAR_AD_RT.
              albgrd(c,ib) = albsod(c,ib)*(1._r8-frac_sno(c)) + albsnd(c,ib)*frac_sno(c)
@@ -524,57 +658,58 @@ contains
              ! albedos for radiative forcing calculations:
              if (use_snicar_frc) then
                 ! BC forcing albedo
-                albgrd_bc(c,ib) = albsod(c,ib)*(1.-frac_sno(c)) + albsnd_bc(ib)*frac_sno(c)
-                albgri_bc(c,ib) = albsoi(c,ib)*(1.-frac_sno(c)) + albsni_bc(ib)*frac_sno(c)
+                albgrd_bc(c,ib) = albsod(c,ib)*(1.-frac_sno(c)) + albsnd_bc(c,ib)*frac_sno(c)
+                albgri_bc(c,ib) = albsoi(c,ib)*(1.-frac_sno(c)) + albsni_bc(c,ib)*frac_sno(c)
 
                 if (DO_SNO_OC) then
                    ! OC forcing albedo
-                   albgrd_oc(c,ib) = albsod(c,ib)*(1.-frac_sno(c)) + albsnd_oc(ib)*frac_sno(c)
-                   albgri_oc(c,ib) = albsoi(c,ib)*(1.-frac_sno(c)) + albsni_oc(ib)*frac_sno(c)
+                   albgrd_oc(c,ib) = albsod(c,ib)*(1.-frac_sno(c)) + albsnd_oc(c,ib)*frac_sno(c)
+                   albgri_oc(c,ib) = albsoi(c,ib)*(1.-frac_sno(c)) + albsni_oc(c,ib)*frac_sno(c)
                 endif
 
                 ! dust forcing albedo
-                albgrd_dst(c,ib) = albsod(c,ib)*(1.-frac_sno(c)) + albsnd_dst(ib)*frac_sno(c)
-                albgri_dst(c,ib) = albsoi(c,ib)*(1.-frac_sno(c)) + albsni_dst(ib)*frac_sno(c)
+                albgrd_dst(c,ib) = albsod(c,ib)*(1.-frac_sno(c)) + albsnd_dst(c,ib)*frac_sno(c)
+                albgri_dst(c,ib) = albsoi(c,ib)*(1.-frac_sno(c)) + albsni_dst(c,ib)*frac_sno(c)
 
                 ! pure snow albedo for all-aerosol radiative forcing
-                albgrd_pur(c,ib) = albsod(c,ib)*(1.-frac_sno(c)) + albsnd_pur(ib)*frac_sno(c)
-                albgri_pur(c,ib) = albsoi(c,ib)*(1.-frac_sno(c)) + albsni_pur(ib)*frac_sno(c)
+                albgrd_pur(c,ib) = albsod(c,ib)*(1.-frac_sno(c)) + albsnd_pur(c,ib)*frac_sno(c)
+                albgri_pur(c,ib) = albsoi(c,ib)*(1.-frac_sno(c)) + albsni_pur(c,ib)*frac_sno(c)
              end if
 
              ! also in this loop (but optionally in a different loop for vectorized code)
              !  weight snow layer radiative absorption factors based on snow fraction and soil albedo
              !  (NEEDED FOR ENERGY CONSERVATION)
              do i = -nlevsno+1,1,1
-                if (subgridflag == 0 .or. lun_pp%itype(col_pp%landunit(c)) == istdlak) then
-                   if (ib == 1) then
-                      flx_absdv(c,i) = flx_absd_snw(i,ib)*frac_sno(c) + &
-                        ((1.-frac_sno(c))*(1-albsod(c,ib))*(flx_absd_snw(i,ib)/(1.-albsnd(c,ib))))
-                      flx_absiv(c,i) = flx_absi_snw(i,ib)*frac_sno(c) + &
-                        ((1.-frac_sno(c))*(1-albsoi(c,ib))*(flx_absi_snw(i,ib)/(1.-albsni(c,ib))))
-                   elseif (ib == 2) then
-                      flx_absdn(c,i) = flx_absd_snw(i,ib)*frac_sno(c) + &
-                        ((1.-frac_sno(c))*(1-albsod(c,ib))*(flx_absd_snw(i,ib)/(1.-albsnd(c,ib))))
-                      !
-                      flx_absin(c,i) = flx_absi_snw(i,ib)*frac_sno(c) + &
-                        ((1.-frac_sno(c))*(1-albsoi(c,ib))*(flx_absi_snw(i,ib)/(1.-albsni(c,ib))))
-                   endif
-                else
-                   if (ib == 1) then
-                      flx_absdv(c,i) = flx_absd_snw(i,ib)*(1.-albsnd(c,ib))
-                      flx_absiv(c,i) = flx_absi_snw(i,ib)*(1.-albsni(c,ib))
-                   elseif (ib == 2) then
-                      flx_absdn(c,i) = flx_absd_snw(i,ib)*(1.-albsnd(c,ib))
-                      flx_absin(c,i) = flx_absi_snw(i,ib)*(1.-albsni(c,ib))
-                   endif
+              if (subgridflag == 0 .or. lun_pp%itype(col_pp%landunit(c)) == istdlak) then
+                if (ib == 1) then
+                   flx_absdv(c,i) = flx_absd_snw(c,i,ib)*frac_sno(c) + &
+                        ((1.-frac_sno(c))*(1-albsod(c,ib))*(flx_absd_snw(c,i,ib)/(1.-albsnd(c,ib))))
+                   flx_absiv(c,i) = flx_absi_snw(c,i,ib)*frac_sno(c) + &
+                        ((1.-frac_sno(c))*(1-albsoi(c,ib))*(flx_absi_snw(c,i,ib)/(1.-albsni(c,ib))))
+                elseif (ib == 2) then
+                   flx_absdn(c,i) = flx_absd_snw(c,i,ib)*frac_sno(c) + &
+                        ((1.-frac_sno(c))*(1-albsod(c,ib))*(flx_absd_snw(c,i,ib)/(1.-albsnd(c,ib))))
+                   flx_absin(c,i) = flx_absi_snw(c,i,ib)*frac_sno(c) + &
+                        ((1.-frac_sno(c))*(1-albsoi(c,ib))*(flx_absi_snw(c,i,ib)/(1.-albsni(c,ib))))
+                endif
+             else
+                if (ib == 1) then
+                   flx_absdv(c,i) = flx_absd_snw(c,i,ib)*(1.-albsnd(c,ib))
+                   flx_absiv(c,i) = flx_absi_snw(c,i,ib)*(1.-albsni(c,ib))
+                elseif (ib == 2) then
+                   flx_absdn(c,i) = flx_absd_snw(c,i,ib)*(1.-albsnd(c,ib))
+                   flx_absin(c,i) = flx_absi_snw(c,i,ib)*(1.-albsni(c,ib))
                 endif
-            enddo
+             endif
+             enddo
+          endif
        enddo
-    enddo !! end column loop
+    enddo
+
+       ! For diagnostics, set snow albedo to spval over non-snow non-urban points
+       ! so that it is not averaged in history buffer (OPTIONAL)
+       ! TODO - this is set to 0 not spval - seems wrong since it will be averaged in
 
-    ! For diagnostics, set snow albedo to spval over non-snow non-urban points
-    ! so that it is not averaged in history buffer (OPTIONAL)
-    ! TODO - this is set to 0 not spval - seems wrong since it will be averaged in
     do ib = 1, nband
        do fc = 1,num_nourbanc
           c = filter_nourbanc(fc)
@@ -589,6 +724,7 @@ contains
     enddo
 
     ! Create solar-vegetated filter for the following calculations
+
     num_vegsol = 0
     num_novegsol = 0
     do fp = 1,num_nourbanp
@@ -607,7 +743,8 @@ contains
     end do
 
     ! Weight reflectance/transmittance by lai and sai
-    ! Only perform on vegetated patches where coszen > 0
+       ! Only perform on vegetated patches where coszen > 0
+
     do fp = 1,num_vegsol
        p = filter_vegsol(fp)
        wl(p) = elai(p) / max( elai(p)+esai(p), mpe )
@@ -649,6 +786,7 @@ contains
     dincmax = 0.25_r8
     do fp = 1,num_nourbanp
        p = filter_nourbanp(fp)
+
        if (nlevcan == 1) then
           nrad(p) = 1
           ncan(p) = 1
@@ -688,21 +826,23 @@ contains
        end if
 
        ! Error check: make sure cumulative of increments does not exceed total
+
        laisum = 0._r8
        saisum = 0._r8
        do iv = 1, nrad(p)
           laisum = laisum + tlai_z(p,iv)
           saisum = saisum + tsai_z(p,iv)
        end do
-#ifndef _OPENACC
        if (abs(laisum-elai(p)) > 1.e-06_r8 .or. abs(saisum-esai(p)) > 1.e-06_r8) then
+#ifndef _OPENACC
           write (iulog,*) 'multi-layer canopy error 01 in SurfaceAlbedo: ',&
                nrad(p),elai(p),laisum,esai(p),saisum
           call endrun(decomp_index=p, elmlevel=namep, msg=errmsg(__FILE__, __LINE__))
-       end if
 #endif
+       end if
 
        ! Repeat to find canopy layers buried by snow
+
        if (nlevcan > 1) then
           blai(p) = tlai(p) - elai(p)
           bsai(p) = tsai(p) - esai(p)
@@ -735,13 +875,13 @@ contains
              laisum = laisum + tlai_z(p,iv)
              saisum = saisum + tsai_z(p,iv)
           end do
-#ifndef _OPENACC
           if (abs(laisum-tlai(p)) > 1.e-06_r8 .or. abs(saisum-tsai(p)) > 1.e-06_r8) then
+#ifndef _OPENACC
              write (iulog,*) 'multi-layer canopy error 02 in SurfaceAlbedo: ',nrad(p),ncan(p)
              write (iulog,*) tlai(p),elai(p),blai(p),laisum,tsai(p),esai(p),bsai(p),saisum
              call endrun(decomp_index=p, elmlevel=namep, msg=errmsg(__FILE__, __LINE__))
-          end if
 #endif
+          end if
        end if
 
     end do
@@ -787,13 +927,13 @@ contains
 
     ! Calculate surface albedos and fluxes
     ! Only perform on vegetated pfts where coszen > 0
-!     if(use_fates)then
-! #ifndef _OPENACC
-!        call alm_fates%wrap_canopy_radiation(bounds, &
-!             num_vegsol, filter_vegsol, &
-!             coszen_patch(bounds%begp:bounds%endp), surfalb_vars)
-! #endif
-!     else
+    if(use_fates)then
+#ifndef _OPENACC
+       call alm_fates%wrap_canopy_radiation(bounds, &
+            num_vegsol, filter_vegsol, &
+            coszen_patch(bounds%begp:bounds%endp), surfalb_vars)
+#endif
+    else
 
       call TwoStream (bounds, filter_vegsol, num_vegsol, &
                coszen_patch(bounds%begp:bounds%endp), &
@@ -801,12 +941,12 @@ contains
                tau(bounds%begp:bounds%endp, :), &
                canopystate_vars, surfalb_vars)
 
-    ! endif
+    endif
 
        ! Determine values for non-vegetated patches where coszen > 0
 
-      do ib = 1,numrad
-        do fp = 1,num_novegsol
+    do ib = 1,numrad
+       do fp = 1,num_novegsol
           p = filter_novegsol(fp)
           c = veg_pp%column(p)
           fabd(p,ib) = 0._r8
@@ -820,8 +960,8 @@ contains
           ftii(p,ib) = 1._r8
           albd(p,ib) = albgrd(c,ib)
           albi(p,ib) = albgri(c,ib)
-        end do
-      end do
+       end do
+    end do
 
      end associate
 
@@ -842,6 +982,7 @@ contains
     use elm_varcon      , only : tfrz
     use landunit_varcon, only : istice, istice_mec, istdlak
     use LakeCon         , only : lakepuddling
+    use domainMod       , only : ldomain
     !
     ! !ARGUMENTS:
      type(bounds_type)      , intent(in)    :: bounds
@@ -857,7 +998,7 @@ contains
      !
     integer, parameter :: nband =numrad ! number of solar radiation waveband classes
     integer  :: fc            ! non-urban filter column index
-    integer  :: c,l           ! indices
+    integer  :: c,l,t,g,gi,pi,mi           ! indices
     integer  :: ib            ! waveband number (1=vis, 2=nir)
     real(r8) :: inc           ! soil water correction factor for soil albedo
     integer  :: soilcol       ! soilcolor
@@ -886,10 +1027,14 @@ contains
     do ib = 1, nband
        do fc = 1,num_nourbanc
           c = filter_nourbanc(fc)
+          g = col_pp%gridcell(c)
+          t = col_pp%topounit(c)
+          gi = grc_pp%gindex(g)
+          mi = ldomain%mask(g)
+          pi = ldomain%pftm(g)
           if (coszen(c) > 0._r8) then
              l = col_pp%landunit(c)
-
-             if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop)  then ! soil
+             if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop .and. top_pp%active(t))  then ! soil
                 inc    = max(0.11_r8-0.40_r8*h2osoi_vol(c,1), 0._r8)
                 soilcol = isoicol(c)
                 ! changed from local variable to elm_type:
@@ -897,15 +1042,15 @@ contains
                 !albsoi = albsod
                 albsod(c,ib) = min(albsat(soilcol,ib)+inc, albdry(soilcol,ib))
                 albsoi(c,ib) = albsod(c,ib)
-             else if (lun_pp%itype(l) == istice .or. lun_pp%itype(l) == istice_mec)  then  ! land ice
-                ! changed from local variable to elm_type:
+             else if (lun_pp%itype(l) == istice .or. lun_pp%itype(l) == istice_mec .and. top_pp%active(t))  then  ! land ice
+                ! changed from local variable to clm_type:
                 !albsod = albice(ib)
                 !albsoi = albsod
                 albsod(c,ib) = albice(ib)
                 albsoi(c,ib) = albsod(c,ib)
              ! unfrozen lake, wetland
              else if (t_grnd(c) > tfrz .or. (lakepuddling .and. lun_pp%itype(l) == istdlak .and. t_grnd(c) == tfrz .and. &
-                      lake_icefrac(c,1) < 1._r8 .and. lake_icefrac(c,2) > 0._r8) ) then
+                      lake_icefrac(c,1) < 1._r8 .and. lake_icefrac(c,2) > 0._r8)  .and. top_pp%active(t)) then
 
                 albsod(c,ib) = 0.05_r8/(max(0.001_r8,coszen(c)) + 0.15_r8)
                 ! This expression is apparently from BATS according to Yongjiu Dai.
@@ -928,7 +1073,7 @@ contains
                 ! Tenatively I'm restricting this to lakes because I haven't tested it for wetlands. But if anything
                 ! the albedo should be lower when melting over frozen ground than a solid frozen lake.
                 !
-                if (lun_pp%itype(l) == istdlak .and. .not. lakepuddling .and. snl(c) == 0) then
+                if (lun_pp%itype(l) == istdlak .and. .not. lakepuddling .and. snl(c) == 0  .and. top_pp%active(t)) then
                     ! Need to reference snow layers here because t_grnd could be over snow or ice
                                       ! but we really want the ice surface temperature with no snow
                    sicefr = 1._r8 - exp(-calb * (tfrz - t_grnd(c))/tfrz)
diff --git a/components/elm/src/biogeophys/SurfaceAlbedoType.F90 b/components/elm/src/biogeophys/SurfaceAlbedoType.F90
index be5585e8f7..66e787d59d 100644
--- a/components/elm/src/biogeophys/SurfaceAlbedoType.F90
+++ b/components/elm/src/biogeophys/SurfaceAlbedoType.F90
@@ -132,7 +132,6 @@ contains
     use spmdMod    , only : masterproc
     use topounit_varcon, only : max_topounits
     use GridcellType , only : grc_pp
-    use shr_sys_mod ,  only : shr_sys_flush 
     !
     ! !ARGUMENTS:
     type(bounds_type), intent(in) :: bounds
@@ -144,7 +143,7 @@ contains
     character(len=256) :: locfn        ! local filename
     integer            :: ier          ! error status
     logical            :: readvar
-    integer  ,pointer  :: soic2d (:)   ! read in - soil color
+    integer  ,pointer  :: soic2d (:,:)   ! read in - soil color
     !---------------------------------------------------------------------
 
     ! Allocate module variable for soil color
@@ -153,19 +152,14 @@ contains
 
     ! Determine soil color and number of soil color classes
     ! if number of soil color classes is not on input dataset set it to 8
-    write(iulog, *) "DEBUG: SurfAlb::getfil", fsurdat 
-    call shr_sys_flush(iulog) 
+
     call getfil (fsurdat, locfn, 0)
-    write(iulog, *) "DEBUG: SurfAlb::getfil", locfn 
-    call shr_sys_flush(iulog) 
     call ncd_pio_openfile (ncid, locfn, 0)
 
-    !call ncd_io(ncid=ncid, varname='mxsoil_color', flag='read', data=mxsoil_color, readvar=readvar)
-    !if ( .not. readvar ) mxsoil_color = 8
-    mxsoil_color = 20
+    call ncd_io(ncid=ncid, varname='mxsoil_color', flag='read', data=mxsoil_color, readvar=readvar)
+    if ( .not. readvar ) mxsoil_color = 8
 
-    !allocate(soic2d(bounds%begg:bounds%endg,max_topounits))
-    allocate(soic2d(bounds%begg:bounds%endg) ) 
+    allocate(soic2d(bounds%begg:bounds%endg,max_topounits))
     call ncd_io(ncid=ncid, varname='SOIL_COLOR', flag='read', data=soic2d, dim1name=grlnd, readvar=readvar)
     if (.not. readvar) then
        call endrun(msg=' ERROR: SOIL_COLOR NOT on surfdata file'//errMsg(__FILE__, __LINE__))
@@ -175,15 +169,12 @@ contains
        t = col_pp%topounit(c)
        topi = grc_pp%topi(g)
        ti = t - topi + 1
-       !isoicol(c) = soic2d(g,ti)
-       isoicol(c) = soic2d(g) 
+       isoicol(c) = soic2d(g,ti)
        
     end do
     deallocate(soic2d)
 
     call ncd_pio_closefile(ncid)
-    write(iulog, *) "DEBUG: SurfAlb::albsat"
-    call shr_sys_flush(iulog) 
 
     ! Determine saturated and dry soil albedos for n color classes and
     ! numrad wavebands (1=vis, 2=nir)
@@ -197,8 +188,6 @@ contains
     if (masterproc) then
        write(iulog,*) 'Attempting to read soil colo data .....'
     end if
-    write(iulog, *) "DEBUG: SurfAlb::Assinments"
-    call shr_sys_flush(iulog) 
 
     if (mxsoil_color == 8) then
        albsat(1:8,1) = (/0.12_r8,0.11_r8,0.10_r8,0.09_r8,0.08_r8,0.07_r8,0.06_r8,0.05_r8/)
@@ -220,13 +209,9 @@ contains
     end if
 
     ! Set alblakwi
-    write(iulog, *) "DEBUG: SurfAlb::alblakwi"
-    call shr_sys_flush(iulog) 
     alblakwi(:) = lake_melt_icealb(:)
 
   !$acc enter data copyin(albsat,albdry,isoicol,alblakwi )
-  write(iulog, *) "DEBUG: SurfAlb::END"
-    call shr_sys_flush(iulog) 
   end subroutine SurfaceAlbedoInitTimeConst
 
   !------------------------------------------------------------------------
diff --git a/components/elm/src/biogeophys/SurfaceRadiationMod.F90 b/components/elm/src/biogeophys/SurfaceRadiationMod.F90
index 117edcf027..47fe244c53 100644
--- a/components/elm/src/biogeophys/SurfaceRadiationMod.F90
+++ b/components/elm/src/biogeophys/SurfaceRadiationMod.F90
@@ -11,6 +11,7 @@ module SurfaceRadiationMod
   use abortutils        , only : endrun
   use decompMod         , only : bounds_type
   use elm_varcon        , only : namec, spval, ispval
+  use atm2lndType       , only : atm2lnd_type
   use CanopyStateType   , only : canopystate_type
   use SurfaceAlbedoType , only : surfalb_type
   use SolarAbsorbedType , only : solarabs_type
@@ -295,13 +296,15 @@ contains
     ! !LOCAL VARIABLES:
     integer :: p,l
     !-----------------------------------------------------------------------
-    
+
+    ! nothing for now
+
   end subroutine InitCold
 
   !------------------------------------------------------------------------------
   subroutine SurfaceRadiation(bounds, num_nourbanp, filter_nourbanp, &
        num_urbanp, filter_urbanp, num_urbanc, filter_urbanc, &
-       canopystate_vars, surfalb_vars, &
+       atm2lnd_vars, canopystate_vars, surfalb_vars, &
        solarabs_vars, surfrad_vars)
      !
      ! !DESCRIPTION:
@@ -321,6 +324,7 @@ contains
      ! Output variables are parsun,parsha,sabv,sabg,fsa,fsr,ndvi
      !
      ! !USES:
+      !$acc routine seq
      use elm_varpar       , only : numrad, nlevsno
      use elm_varcon       , only : spval, degpsec, isecspday
      use landunit_varcon  , only : istsoil, istcrop
@@ -335,10 +339,13 @@ contains
      integer                , intent(in)    :: filter_urbanp(:)   ! patch filter for non-urban points
      integer                , intent(in)    :: num_urbanc         ! number of urban columns in clump
      integer                , intent(in)    :: filter_urbanc(:)   ! urban column filter
+     type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
      type(surfalb_type)     , intent(in)    :: surfalb_vars
      type(canopystate_type) , intent(inout) :: canopystate_vars
      type(solarabs_type)    , intent(inout) :: solarabs_vars
      type(surfrad_type)     , intent(inout) :: surfrad_vars
+     real(r8)                    :: dtime
+     integer   ::  secs
      !
      ! !LOCAL VARIABLES:
      integer , parameter :: nband = numrad           ! number of solar radiation waveband classes
@@ -355,10 +362,10 @@ contains
      integer  :: i                                   ! layer index [idx]
      real(r8) :: rnir                                ! reflected solar radiation [nir] (W/m**2)
      real(r8) :: rvis                                ! reflected solar radiation [vis] (W/m**2)
-     real(r8) :: trd(1:num_nourbanp,numrad) ! transmitted solar radiation: direct (W/m**2)
-     real(r8) :: tri(1:num_nourbanp,numrad) ! transmitted solar radiation: diffuse (W/m**2)
-     real(r8) :: cad !(1:num_nourbanp,numrad) ! direct beam absorbed by canopy (W/m**2)
-     real(r8) :: cai !(1:num_nourbanp,numrad) ! diffuse radiation absorbed by canopy (W/m**2)
+     real(r8) :: trd(bounds%begp:bounds%endp,numrad) ! transmitted solar radiation: direct (W/m**2)
+     real(r8) :: tri(bounds%begp:bounds%endp,numrad) ! transmitted solar radiation: diffuse (W/m**2)
+     real(r8) :: cad(bounds%begp:bounds%endp,numrad) ! direct beam absorbed by canopy (W/m**2)
+     real(r8) :: cai(bounds%begp:bounds%endp,numrad) ! diffuse radiation absorbed by canopy (W/m**2)
      integer  :: local_secp1                         ! seconds into current date in local time
      integer  :: year,month,day                      ! calendar info for current time step
      real(r8) :: sabg_snl_sum                        ! temporary, absorbed energy in all active snow layers [W/m2]
@@ -366,14 +373,13 @@ contains
      real(r8) :: absrad_bc                           ! temp: absorbed solar radiation without BC [W/m2]
      real(r8) :: absrad_oc                           ! temp: absorbed solar radiation without OC [W/m2]
      real(r8) :: absrad_dst                          ! temp: absorbed solar radiation without dust [W/m2]
-     real(r8) :: sabg_pur(1:num_nourbanp)   ! solar radiation absorbed by ground with pure snow [W/m2]
-     real(r8) :: sabg_bc(1:num_nourbanp)    ! solar radiation absorbed by ground without BC [W/m2]
-     real(r8) :: sabg_oc(1:num_nourbanp)    ! solar radiation absorbed by ground without OC [W/m2]
-     real(r8) :: sabg_dst(1:num_nourbanp)   ! solar radiation absorbed by ground without dust [W/m2]
-     real(r8) :: parveg(1:num_nourbanp)     ! absorbed par by vegetation (W/m**2)
+     real(r8) :: sabg_pur(bounds%begp:bounds%endp)   ! solar radiation absorbed by ground with pure snow [W/m2]
+     real(r8) :: sabg_bc(bounds%begp:bounds%endp)    ! solar radiation absorbed by ground without BC [W/m2]
+     real(r8) :: sabg_oc(bounds%begp:bounds%endp)    ! solar radiation absorbed by ground without OC [W/m2]
+     real(r8) :: sabg_dst(bounds%begp:bounds%endp)   ! solar radiation absorbed by ground without dust [W/m2]
+     real(r8) :: parveg(bounds%begp:bounds%endp)     ! absorbed par by vegetation (W/m**2)
      !
      integer, parameter :: noonsec   = isecspday / 2 ! seconds at local noon
-     real(r8) :: sum1 ,sum2, sum3, sum4, sum5 
      !
      !------------------------------------------------------------------------------
 
@@ -466,264 +472,192 @@ contains
           fsds_sno_vi     =>    surfrad_vars%fsds_sno_vi_patch    , & ! Output: [real(r8) (:)   ] incident visible, diffuse radiation on snow (for history files) (pft) [W/m2]
           fsds_sno_ni     =>    surfrad_vars%fsds_sno_ni_patch      & ! Output: [real(r8) (:)   ] incident near-IR, diffuse radiation on snow (for history files) (pft) [W/m2]
           )
-     
-          !$acc enter data create(&
-         !$acc trd(:,:), &
-         !$acc tri(:,:), &
-         !$acc sabg_pur(:), &
-         !$acc sabg_bc(:), &
-         !$acc sabg_oc(:), &
-         !$acc sabg_dst(:), &
-         !$acc parveg(:), &
-         !$acc ib, &
-         !$acc local_secp1, &
-         !$acc sabg_snl_sum, &
-         !$acc sum1, &
-         !$acc sum2, &
-         !$acc sum3, &
-         !$acc sum4)
 
+          dtime = dtime_mod
+          secs = secs_curr 
        ! Initialize fluxes
-       !$acc parallel loop independent gang vector default(present)
        do fp = 1,num_nourbanp
           p = filter_nourbanp(fp)
-         !  l = veg_pp%landunit(p)
-
-
-         !  sabg_soil(p)  = 0._r8
-         !  sabg_snow(p)  = 0._r8
-         !  sabg(p)       = 0._r8
-         !  sabv(p)       = 0._r8
-         !  fsa(p)        = 0._r8
-         !  if (lun_pp%itype(l)==istsoil .or. lun_pp%itype(l)==istcrop) then
-         !     fsa_r(p) = 0._r8
-         !  end if
+          l = veg_pp%landunit(p)
+          sabg_soil(p)  = 0._r8
+          sabg_snow(p)  = 0._r8
+          sabg(p)       = 0._r8
+          sabv(p)       = 0._r8
+          fsa(p)        = 0._r8
+        if (lun_pp%itype(l)==istsoil .or. lun_pp%itype(l)==istcrop) then
+           fsa_r(p) = 0._r8
+        end if
           sabg_lyr(p,:) = 0._r8
+          sabg_pur(p)   = 0._r8
+          sabg_bc(p)    = 0._r8
+          sabg_oc(p)    = 0._r8
+          sabg_dst(p)   = 0._r8
 
-         !  sabg_pur(fp)   = 0._r8
-         !  sabg_bc(fp)    = 0._r8
-         !  sabg_oc(fp)    = 0._r8
-         !  sabg_dst(fp)   = 0._r8
        end do
 
        ! zero-out fsun for the urban patches
        ! the non-urban patches were set prior to this call
        ! and split into ed and non-ed specific functions
-       !$acc parallel loop independent gang vector default(present)
        do fp = 1,num_urbanp
           p = filter_urbanp(fp)
           fsun(p) = 0._r8
        end do
 
        ! Loop over nband wavebands
-       !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3)
-       do fp = 1,num_nourbanp
-         p = filter_nourbanp(fp)
-         l = veg_pp%landunit(p)
-         t = veg_pp%topounit(p)
-         sum1 = 0._r8; sum2 = 0._r8; sum3 = 0._r8 
-         !$acc loop vector reduction(+:sum1,sum2,sum3)
-         do ib = 1, nband
-             ! Absorbed by canopys
-             cad = forc_solad(t,ib)*fabd(p,ib)
-             cai = forc_solai(t,ib)*fabi(p,ib)
-             sum1 = sum1 + cad + cai
-             sum2 = sum2  + cad + cai
+       do ib = 1, nband
+          do fp = 1,num_nourbanp
+             p = filter_nourbanp(fp)
+             c = veg_pp%column(p)
+             l = veg_pp%landunit(p)
+             t = veg_pp%topounit(p)
+             g = veg_pp%gridcell(p)
+
+             ! Absorbed by canopy
+
+             cad(p,ib) = forc_solad(t,ib)*fabd(p,ib)
+             cai(p,ib) = forc_solai(t,ib)*fabi(p,ib)
+             sabv(p) = sabv(p) + cad(p,ib) + cai(p,ib)
+             fsa(p)  = fsa(p)  + cad(p,ib) + cai(p,ib)
              if (ib == 1) then
-                parveg(fp) = cad + cai
+                parveg(p) = cad(p,ib) + cai(p,ib)
              end if
              if (lun_pp%itype(l)==istsoil .or. lun_pp%itype(l)==istcrop) then
-                sum3  = sum3  + cad + cai
+                fsa_r(p)  = fsa_r(p)  + cad(p,ib) + cai(p,ib)
              end if
-         end do
-         sabv(p) = sum1
-         fsa(p)  = sum2 
-         if (lun_pp%itype(l)==istsoil .or. lun_pp%itype(l)==istcrop) then
-            fsa_r(p)= sum3
-         end if  
-      end do  !
-      
-      !$acc parallel loop independent gang vector collapse(2) default(present)
-      do ib = 1, nband
-         do fp = 1,num_nourbanp
-            p = filter_nourbanp(fp)
-            t = veg_pp%topounit(p)
+
              ! Transmitted = solar fluxes incident on ground
-             trd(fp,ib) = forc_solad(t,ib)*ftdd(p,ib)
-             tri(fp,ib) = forc_solad(t,ib)*ftid(p,ib) + forc_solai(t,ib)*ftii(p,ib)
-         end do 
-      end do 
-
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3, sum4)
-      do fp = 1,num_nourbanp
-         p = filter_nourbanp(fp)
-         t = veg_pp%topounit(p)
-         c = veg_pp%column(p)
-         l = veg_pp%landunit(p)
-
-         sum1 = 0._r8; sum2 = 0._r8; sum3 = 0._r8; sum4 = 0._r8;
-
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4) private(absrad)
-         do ib = 1, nband
+
+             trd(p,ib) = forc_solad(t,ib)*ftdd(p,ib)
+             tri(p,ib) = forc_solad(t,ib)*ftid(p,ib) + forc_solai(t,ib)*ftii(p,ib)
              ! Solar radiation absorbed by ground surface
              ! calculate absorbed solar by soil/snow separately
-             absrad  = trd(fp,ib)*(1._r8-albsod(c,ib)) + tri(fp,ib)*(1._r8-albsoi(c,ib))
-             sum1 = sum1  + absrad
-
-             absrad  = trd(fp,ib)*(1._r8-albsnd_hst(c,ib)) + tri(fp,ib)*(1._r8-albsni_hst(c,ib))
-             sum2 = sum2 + absrad
-
-             absrad  = trd(fp,ib)*(1._r8-albgrd(c,ib)) + tri(fp,ib)*(1._r8-albgri(c,ib))
-
-             sum3 = sum3 + absrad
-            !  sum4 = sum4  + absrad
-            if (lun_pp%itype(l)==istsoil .or. lun_pp%itype(l)==istcrop) then
-               sum4 = sum4 + absrad
-            end if
-
-         end do
-         sabg_soil(p) = sum1 
-         sabg_snow(p) = sum2 
-         sabg(p)      = sum3
-         fsa(p)   = fsa(p) + sum3
-         fsa_r(p) = fsa_r(p) + sum4 
-
-         !NOTE: check sooner to save on the reduction?
-         if (snl(c) == 0) then
-            sabg_snow(p) = sabg(p)
-            sabg_soil(p) = sabg(p)
-         endif
-         ! if no subgrid fluxes, make sure to set both components equal to weighted average
-         if (subgridflag == 0 .or. lun_pp%itype(l) == istdlak) then
-            sabg_snow(p) = sabg(p)
-            sabg_soil(p) = sabg(p)
-         endif
-      end do
-
-      if (use_snicar_frc) then
-         !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3,sum4)
-         do fp = 1,num_nourbanp
-            p = filter_nourbanp(fp)
-            c = veg_pp%column(p)
-
-            sum1 = 0._r8; sum2 = 0._r8; sum3 = 0._r8; sum4 = 0._r8;
-            !$acc loop vector reduction(+:sum1,sum2,sum3,sum4) private(absrad)
-            do ib = 1, nband
+             absrad  = trd(p,ib)*(1._r8-albsod(c,ib)) + tri(p,ib)*(1._r8-albsoi(c,ib))
+             sabg_soil(p) = sabg_soil(p) + absrad
+             absrad  = trd(p,ib)*(1._r8-albsnd_hst(c,ib)) + tri(p,ib)*(1._r8-albsni_hst(c,ib))
+             sabg_snow(p) = sabg_snow(p) + absrad
+             absrad  = trd(p,ib)*(1._r8-albgrd(c,ib)) + tri(p,ib)*(1._r8-albgri(c,ib))
+             sabg(p) = sabg(p) + absrad
+             fsa(p)  = fsa(p)  + absrad
+             if (lun_pp%itype(l)==istsoil .or. lun_pp%itype(l)==istcrop) then
+                fsa_r(p)  = fsa_r(p)  + absrad
+             end if
+             if (snl(c) == 0) then
+                sabg_snow(p) = sabg(p)
+                sabg_soil(p) = sabg(p)
+             endif
+             ! if no subgrid fluxes, make sure to set both components equal to weighted average
+             if (subgridflag == 0 .or. lun_pp%itype(l) == istdlak) then
+                sabg_snow(p) = sabg(p)
+                sabg_soil(p) = sabg(p)
+             endif
+
+             if (use_snicar_frc) then
                 ! Solar radiation absorbed by ground surface without BC
-                absrad_bc = trd(fp,ib)*(1._r8-albgrd_bc(c,ib)) + tri(fp,ib)*(1._r8-albgri_bc(c,ib))
-                sum1 = sum1 + absrad_bc
+                absrad_bc = trd(p,ib)*(1._r8-albgrd_bc(c,ib)) + tri(p,ib)*(1._r8-albgri_bc(c,ib))
+                sabg_bc(p) = sabg_bc(p) + absrad_bc
 
                 ! Solar radiation absorbed by ground surface without OC
-                absrad_oc = trd(fp,ib)*(1._r8-albgrd_oc(c,ib)) + tri(fp,ib)*(1._r8-albgri_oc(c,ib))
-                sum2 = sum2 + absrad_oc
+                absrad_oc = trd(p,ib)*(1._r8-albgrd_oc(c,ib)) + tri(p,ib)*(1._r8-albgri_oc(c,ib))
+                sabg_oc(p) = sabg_oc(p) + absrad_oc
 
                 ! Solar radiation absorbed by ground surface without dust
-                absrad_dst = trd(fp,ib)*(1._r8-albgrd_dst(c,ib)) + tri(fp,ib)*(1._r8-albgri_dst(c,ib))
-                sum3 = sum3 + absrad_dst
+                absrad_dst = trd(p,ib)*(1._r8-albgrd_dst(c,ib)) + tri(p,ib)*(1._r8-albgri_dst(c,ib))
+                sabg_dst(p) = sabg_dst(p) + absrad_dst
 
                 ! Solar radiation absorbed by ground surface without any aerosols
-                absrad_pur = trd(fp,ib)*(1._r8-albgrd_pur(c,ib)) + tri(fp,ib)*(1._r8-albgri_pur(c,ib))
-                sum4 = sum4 + absrad_pur
-            end do 
-            sabg_bc(fp) = sum1
-            sabg_oc(fp) = sum2 
-            sabg_dst(fp) = sum3
-            sabg_pur(fp) = sum4  
+                absrad_pur = trd(p,ib)*(1._r8-albgrd_pur(c,ib)) + tri(p,ib)*(1._r8-albgri_pur(c,ib))
+                sabg_pur(p) = sabg_pur(p) + absrad_pur
+             end if
 
-         end do 
-      end if
+          end do ! end of pft loop
+       end do ! end nbands loop
 
        !   compute absorbed flux in each snow layer and top soil layer,
        !   based on flux factors computed in the radiative transfer portion of SNICAR.
-      !$acc parallel loop independent gang worker default(present) private(sabg_snl_sum,sum1)
-      do fp = 1,num_nourbanp
-         p = filter_nourbanp(fp)
-         c = veg_pp%column(p)
-         l = veg_pp%landunit(p)
-         !
-         sabg_snl_sum = 0._r8
-         sum1 = 0._r8
-         !sub_surf_abs_SW(c) = 0._r8
-
-         ! CASE1: No snow layers: all energy is absorbed in top soil layer
-         if (snl(c) == 0) then
-            sabg_lyr(p,:) = 0._r8
-            sabg_lyr(p,1) = sabg(p)
-            sabg_snl_sum  = sabg_lyr(p,1)
-            ! CASE 2: Snow layers present: absorbed radiation is scaled according to
-            ! flux factors computed by SNICAR
-            sub_surf_abs_SW(c) = 0._r8
-         else
-            !$acc loop vector reduction(+:sabg_snl_sum,sum1)
-            do i = -nlevsno+1,1,1
-               sabg_lyr(p,i) = flx_absdv(c,i)*trd(fp,1) + flx_absdn(c,i)*trd(fp,2) + &
-                    flx_absiv(c,i)*tri(fp,1) + flx_absin(c,i)*tri(fp,2)
-               ! summed radiation in active snow layers:
-               if (i >= snl(c)+1) then
-                  sabg_snl_sum = sabg_snl_sum + sabg_lyr(p,i)
-               endif
-               if (i > snl(c)+1) then ! if snow layer is below surface snow layer
-                  !accumulate subsurface flux as a diagnostic for history file
-                  sum1 = sum1 + sabg_lyr(p,i)
-               endif
-            enddo
-            sub_surf_abs_SW(c) = sum1 
-
-            ! Divide absorbed by total, to get % absorbed in subsurface
-            if (sabg_snl_sum /= 0._r8) then
-               sub_surf_abs_SW(c) = sub_surf_abs_SW(c)/sabg_snl_sum
-            else
-               sub_surf_abs_SW(c) = 0._r8
-            endif
-
-            ! Error handling: The situation below can occur when solar radiation is
-            ! NOT computed every timestep.
-            ! When the number of snow layers has changed in between computations of the
-            ! absorbed solar energy in each layer, we must redistribute the absorbed energy
-            ! to avoid physically unrealistic conditions. The assumptions made below are
-            ! somewhat arbitrary, but this situation does not arise very frequently.
-            ! This error handling is implemented to accomodate any value of the
-            ! radiation frequency.
-            ! change condition to match sabg_snow isntead of sabg
-            if (abs(sabg_snl_sum-sabg_snow(p)) > 0.00001_r8) then
-               if (snl(c) == 0) then
-                  sabg_lyr(p,-nlevsno+1:0) = 0._r8
-                  sabg_lyr(p,1) = sabg(p)
-               elseif (snl(c) == -1) then
-                  sabg_lyr(p,-nlevsno+1:-1) = 0._r8
-                  sabg_lyr(p,0) = sabg_snow(p)*0.6_r8
-                  sabg_lyr(p,1) = sabg_snow(p)*0.4_r8
-               else
-                  sabg_lyr(p,:) = 0._r8
-                  sabg_lyr(p,snl(c)+1) = sabg_snow(p)*0.75_r8
-                  sabg_lyr(p,snl(c)+2) = sabg_snow(p)*0.25_r8
-               endif
-            endif
-
-            ! If shallow snow depth, all solar radiation absorbed in top or top two snow layers
-            ! to prevent unrealistic timestep soil warming
-            if (subgridflag == 0 .or. lun_pp%itype(l) == istdlak) then
-               if (snow_depth(c) < 0.10_r8) then
-                  if (snl(c) == 0) then
-                     sabg_lyr(p,-nlevsno+1:0) = 0._r8
-                     sabg_lyr(p,1) = sabg(p)
-                  elseif (snl(c) == -1) then
-                     sabg_lyr(p,-nlevsno+1:-1) = 0._r8
-                     sabg_lyr(p,0) = sabg(p)
-                     sabg_lyr(p,1) = 0._r8
-                  else
-                     sabg_lyr(p,:) = 0._r8
-                     sabg_lyr(p,snl(c)+1) = sabg(p)*0.75_r8
-                     sabg_lyr(p,snl(c)+2) = sabg(p)*0.25_r8
-                  endif
-               endif
-            endif
-
-         endif
+       do fp = 1,num_nourbanp
+          p = filter_nourbanp(fp)
+          c = veg_pp%column(p)
+          l = veg_pp%landunit(p)
+          sabg_snl_sum = 0._r8
+
+          sub_surf_abs_SW(c) = 0._r8
+
+          ! CASE1: No snow layers: all energy is absorbed in top soil layer
+          if (snl(c) == 0) then
+             sabg_lyr(p,:) = 0._r8
+             sabg_lyr(p,1) = sabg(p)
+             sabg_snl_sum  = sabg_lyr(p,1)
+
+             ! CASE 2: Snow layers present: absorbed radiation is scaled according to
+             ! flux factors computed by SNICAR
+          else
+             do i = -nlevsno+1,1,1
+                sabg_lyr(p,i) = flx_absdv(c,i)*trd(p,1) + flx_absdn(c,i)*trd(p,2) + &
+                     flx_absiv(c,i)*tri(p,1) + flx_absin(c,i)*tri(p,2)
+                ! summed radiation in active snow layers:
+                if (i >= snl(c)+1) then
+                   sabg_snl_sum = sabg_snl_sum + sabg_lyr(p,i)
+                endif
+                if (i > snl(c)+1) then ! if snow layer is below surface snow layer
+                   !accumulate subsurface flux as a diagnostic for history file
+                   sub_surf_abs_SW(c) = sub_surf_abs_SW(c) + sabg_lyr(p,i)
+                endif
+             enddo
+
+             ! Divide absorbed by total, to get % absorbed in subsurface
+             if (sabg_snl_sum /= 0._r8) then
+                sub_surf_abs_SW(c) = sub_surf_abs_SW(c)/sabg_snl_sum
+             else
+                sub_surf_abs_SW(c) = 0._r8
+             endif
+
+             ! Error handling: The situation below can occur when solar radiation is
+             ! NOT computed every timestep.
+             ! When the number of snow layers has changed in between computations of the
+             ! absorbed solar energy in each layer, we must redistribute the absorbed energy
+             ! to avoid physically unrealistic conditions. The assumptions made below are
+             ! somewhat arbitrary, but this situation does not arise very frequently.
+             ! This error handling is implemented to accomodate any value of the
+             ! radiation frequency.
+             ! change condition to match sabg_snow isntead of sabg
+             if (abs(sabg_snl_sum-sabg_snow(p)) > 0.00001_r8) then
+                if (snl(c) == 0) then
+                   sabg_lyr(p,-nlevsno+1:0) = 0._r8
+                   sabg_lyr(p,1) = sabg(p)
+                elseif (snl(c) == -1) then
+                   sabg_lyr(p,-nlevsno+1:-1) = 0._r8
+                   sabg_lyr(p,0) = sabg_snow(p)*0.6_r8
+                   sabg_lyr(p,1) = sabg_snow(p)*0.4_r8
+                else
+                   sabg_lyr(p,:) = 0._r8
+                   sabg_lyr(p,snl(c)+1) = sabg_snow(p)*0.75_r8
+                   sabg_lyr(p,snl(c)+2) = sabg_snow(p)*0.25_r8
+                endif
+             endif
+
+             ! If shallow snow depth, all solar radiation absorbed in top or top two snow layers
+             ! to prevent unrealistic timestep soil warming
+             if (subgridflag == 0 .or. lun_pp%itype(l) == istdlak) then
+                if (snow_depth(c) < 0.10_r8) then
+                   if (snl(c) == 0) then
+                      sabg_lyr(p,-nlevsno+1:0) = 0._r8
+                      sabg_lyr(p,1) = sabg(p)
+                   elseif (snl(c) == -1) then
+                      sabg_lyr(p,-nlevsno+1:-1) = 0._r8
+                      sabg_lyr(p,0) = sabg(p)
+                      sabg_lyr(p,1) = 0._r8
+                   else
+                      sabg_lyr(p,:) = 0._r8
+                      sabg_lyr(p,snl(c)+1) = sabg(p)*0.75_r8
+                      sabg_lyr(p,snl(c)+2) = sabg(p)*0.25_r8
+                   endif
+                endif
+             endif
+          endif
 
           ! This situation should not happen:
           if (abs(sum(sabg_lyr(p,:))-sabg_snow(p)) > 0.00001_r8) then
-            #ifndef _OPENACC
+#ifndef _OPENACC
              write(iulog,*)"SNICAR ERROR: Absorbed ground radiation not equal to summed snow layer radiation"
              write(iulog,*)"Diff        = ",sum(sabg_lyr(p,:))-sabg_snow(p)
              write(iulog,*)"sabg_snow(p)= ",sabg_snow(p)
@@ -740,7 +674,7 @@ contains
              write(iulog,*)"albgrd_nir  = ",albgrd(c,2)
              write(iulog,*)"coszen      = ",coszen(c)
              call endrun(decomp_index=c, elmlevel=namec, msg=errmsg(__FILE__, __LINE__))
-            #endif
+#endif
           endif
 
           ! Diagnostic: shortwave penetrating ground (e.g. top layer)
@@ -749,21 +683,22 @@ contains
           end if
 
           if (use_snicar_frc) then
+
              ! BC aerosol forcing (pft-level):
-             sfc_frc_bc(p) = sabg(p) - sabg_bc(fp)
+             sfc_frc_bc(p) = sabg(p) - sabg_bc(p)
 
              ! OC aerosol forcing (pft-level):
              if (DO_SNO_OC) then
-                sfc_frc_oc(p) = sabg(p) - sabg_oc(fp)
+                sfc_frc_oc(p) = sabg(p) - sabg_oc(p)
              else
                 sfc_frc_oc(p) = 0._r8
              endif
 
              ! dust aerosol forcing (pft-level):
-             sfc_frc_dst(p) = sabg(p) - sabg_dst(fp)
+             sfc_frc_dst(p) = sabg(p) - sabg_dst(p)
 
              ! all-aerosol forcing (pft-level):
-             sfc_frc_aer(p) = sabg(p) - sabg_pur(fp)
+             sfc_frc_aer(p) = sabg(p) - sabg_pur(p)
 
              ! forcings averaged only over snow:
              if (frac_sno(c) > 0._r8) then
@@ -778,10 +713,9 @@ contains
                 sfc_frc_aer_sno(p) = spval
              endif
           end if
-      enddo
+       enddo
 
        ! Radiation diagnostics
-      !$acc parallel loop independent gang vector default(present) 
        do fp = 1,num_nourbanp
           p = filter_nourbanp(fp)
           t = veg_pp%topounit(p)
@@ -802,7 +736,7 @@ contains
           fsr_vis_i(p)  = albi(p,1)*forc_solai(t,1)
           fsr_nir_i(p)  = albi(p,2)*forc_solai(t,2)
 
-          local_secp1 = secs_curr + nint((grc_pp%londeg(g)/degpsec)/dtime_mod)*dtime_mod
+          local_secp1 = secs + nint((grc_pp%londeg(g)/degpsec)/dtime)*dtime
           local_secp1 = mod(local_secp1,isecspday)
           if (local_secp1 == isecspday/2) then
              fsds_vis_d_ln(p) = forc_solad(t,1)
@@ -810,7 +744,7 @@ contains
              fsr_vis_d_ln(p) = albd(p,1)*forc_solad(t,1)
              fsr_nir_d_ln(p) = albd(p,2)*forc_solad(t,2)
              fsds_vis_i_ln(p) = forc_solai(t,1)
-             parveg_ln(p)     = parveg(fp)
+             parveg_ln(p)     = parveg(p)
           else
              fsds_vis_d_ln(p) = spval
              fsds_nir_d_ln(p) = spval
@@ -845,14 +779,12 @@ contains
              fsr_sno_ni(p) = spval
           endif
        end do
-
-       !$acc parallel loop independent gang vector default(present) 
        do fp = 1,num_urbanp
           p = filter_urbanp(fp)
           t = veg_pp%topounit(p)
           g = veg_pp%gridcell(p)
 
-          local_secp1 = secs_curr + nint((grc_pp%londeg(g)/degpsec)/dtime_mod)*dtime_mod
+          local_secp1 = secs + nint((grc_pp%londeg(g)/degpsec)/dtime)*dtime
           local_secp1 = mod(local_secp1,isecspday)
 
         if(elai(p)==0.0_r8.and.fabd(p,1)>0._r8)then
@@ -899,22 +831,6 @@ contains
           fsr(p) = fsr_vis_d(p) + fsr_nir_d(p) + fsr_vis_i(p) + fsr_nir_i(p)
        end do
 
-     !$acc exit data delete(&
-     !$acc trd(:,:), &
-     !$acc tri(:,:), &
-     !$acc sabg_pur(:), &
-     !$acc sabg_bc(:), &
-     !$acc sabg_oc(:), &
-     !$acc sabg_dst(:), &
-     !$acc parveg(:), &
-     !$acc ib, &
-     !$acc local_secp1, &
-     !$acc sabg_snl_sum, &
-     !$acc sum1, &
-     !$acc sum2, &
-     !$acc sum3, &
-     !$acc sum4)
-
      end associate
 
    end subroutine SurfaceRadiation
@@ -922,7 +838,7 @@ contains
 !------------------------------------------------------------------------------
 
    subroutine CanopySunShadeFractions(num_nourbanp, filter_nourbanp,  &
-                                      surfalb_vars,     &
+                                      atm2lnd_vars, surfalb_vars,     &
                                       canopystate_vars, solarabs_vars)
 
       ! ------------------------------------------------------------------------------------
@@ -943,11 +859,14 @@ contains
       ! variables also needs to be augmented in that routine as well.
       ! ------------------------------------------------------------------------------------
 
+      !$acc routine seq
       implicit none
 
       ! Arguments (in)
+
       integer, intent(in)                   :: num_nourbanp       ! size of the nonurban filter
       integer, intent(in)                   :: filter_nourbanp(:)    ! patch filter for non-urban points
+      type(atm2lnd_type), intent(in)        :: atm2lnd_vars
       type(surfalb_type), intent(in)        :: surfalb_vars
 
       ! Arguments (inout)
@@ -961,7 +880,6 @@ contains
       integer           :: g                          ! gridcell index
       integer           :: iv                         ! canopy layer index
       integer,parameter :: ipar = 1                   ! The band index for PAR
-      real(r8) :: sum1, sum2 
 
       associate(   &
             tlai_z      => surfalb_vars%tlai_z_patch,     & ! tlai increment for canopy layer
@@ -980,30 +898,33 @@ contains
             laisha      => canopystate_vars%laisha_patch, & ! shaded  leaf area
             laisun_z    => canopystate_vars%laisun_z_patch, & ! sunlit leaf area for canopy layer
             laisha_z    => canopystate_vars%laisha_z_patch, & ! shaded leaf area for canopy layer
-            fsun        => canopystate_vars%fsun_patch  )       ! sunlit fraction of canopy
+            fsun        => canopystate_vars%fsun_patch)       ! sunlit fraction of canopy
 
-         !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-         do fp = 1,num_nourbanp
+        do fp = 1,num_nourbanp
 
            p = filter_nourbanp(fp)
            t = veg_pp%topounit(p)
 
+           do iv = 1, nrad(p)
+              parsun_z(p,iv) = 0._r8
+              parsha_z(p,iv) = 0._r8
+              laisun_z(p,iv) = 0._r8
+              laisha_z(p,iv) = 0._r8
+           end do
+
            ! Loop over patches to calculate laisun_z and laisha_z for each layer.
            ! Derive canopy laisun, laisha, and fsun from layer sums.
            ! If sun/shade big leaf code, nrad=1 and fsun_z(p,1) and tlai_z(p,1) from
            ! SurfaceAlbedo is canopy integrated so that layer value equals canopy value.
 
-           sum1 = 0._r8
-           sum2 = 0._r8
-           !$acc loop vector reduction(+:sum1,sum2)
+           laisun(p) = 0._r8
+           laisha(p) = 0._r8
            do iv = 1, nrad(p)
               laisun_z(p,iv) = tlai_z(p,iv) * fsun_z(p,iv)
               laisha_z(p,iv) = tlai_z(p,iv) * (1._r8 - fsun_z(p,iv))
-              sum1 = sum1 + laisun_z(p,iv)
-              sum2 = sum2 + laisha_z(p,iv)
+              laisun(p) = laisun(p) + laisun_z(p,iv)
+              laisha(p) = laisha(p) + laisha_z(p,iv)
            end do
-           laisun(p) = sum1
-           laisha(p) = sum2
            if (elai(p) > 0._r8) then
               fsun(p) = laisun(p) / elai(p)
            else
@@ -1015,16 +936,17 @@ contains
            ! are canopy integrated so that layer values equal big leaf values.
 
            g = veg_pp%gridcell(p)
-           !$acc loop vector independent
+
            do iv = 1, nrad(p)
               parsun_z(p,iv) = forc_solad(t,ipar)*fabd_sun_z(p,iv) + forc_solai(t,ipar)*fabi_sun_z(p,iv)
               parsha_z(p,iv) = forc_solad(t,ipar)*fabd_sha_z(p,iv) + forc_solai(t,ipar)*fabi_sha_z(p,iv)
            end do
 
         end do ! end of fp = 1,num_nourbanp loop
-
       end associate
 
+      return
+
    end subroutine CanopySunShadeFractions
 
 end module SurfaceRadiationMod
diff --git a/components/elm/src/biogeophys/SurfaceResistanceMod.F90 b/components/elm/src/biogeophys/SurfaceResistanceMod.F90
index ff5a78ca09..b4217890fc 100644
--- a/components/elm/src/biogeophys/SurfaceResistanceMod.F90
+++ b/components/elm/src/biogeophys/SurfaceResistanceMod.F90
@@ -55,6 +55,7 @@ contains
      ! DESCRIPTIONS
      ! compute the stress factor for soil evaporation calculation
      !
+      !$acc routine seq
      use shr_kind_mod  , only : r8 => shr_kind_r8
      use shr_const_mod , only : SHR_CONST_PI
      use decompMod     , only : bounds_type
@@ -67,11 +68,12 @@ contains
      integer               , intent(in)    :: num_nolakec
      integer               , intent(in)    :: filter_nolakec(:)
      type(soilstate_type)  , intent(inout) :: soilstate_vars
-     character(len=32) :: subname = 'calc_soilevap_stress'  ! subroutine name
-     associate(  &
+
+     !character(len=32) :: subname = 'calc_soilevap_stress'  ! subroutine name
+     associate(                &
           soilbeta =>  soilstate_vars%soilbeta_col  & ! Output: [real(r8) (:)] factor that reduces ground evaporation
           )
-       
+
        !select the right method and do the calculation
        select case (soil_stress_method)
 
@@ -80,7 +82,9 @@ contains
                soilstate_vars, soilbeta(bounds%begc:bounds%endc))
 
        case default
+#ifndef _OPENACC
           call endrun('calc_soilevap_stress' //':: a soilevap stress function must be specified!')
+#endif
        end select
 
      end associate
@@ -95,6 +99,7 @@ contains
      ! compute the lee-pielke beta factor to scal actual soil evaporation from potential evaporation
      !
      ! USES
+      !$acc routine seq
      use shr_kind_mod    , only : r8 => shr_kind_r8
      use shr_const_mod   , only : SHR_CONST_PI
      use decompMod       , only : bounds_type
@@ -114,41 +119,41 @@ contains
      real(r8)              , intent(inout) :: soilbeta(bounds%begc:bounds%endc)
 
      !local variables
-     real(r8) :: fac, fac_fc, wx  ! temporary variables
-     integer  :: c, l, fc         ! indices
-     
-     associate(  &
-         watsat      =>  soilstate_vars%watsat_col , & ! Input: [real(r8) (:,:)] volumetric soil water at saturation (porosity)
-         watfc       =>  soilstate_vars%watfc_col  , & ! Input: [real(r8) (:,:)] volumetric soil water at field capacity
-         watmin      =>  soilstate_vars%watmin_col , & ! Input: [real(r8) (:,:)] min volumetric soil water
-         sucmin      =>  soilstate_vars%sucmin_col , & ! Input: [real(r8) (:,:)] min volumetric soil water
-         soilp_col   =>  col_ws%soilp              , & ! Input: [real(r8) (:,:)] soil water pressure (Pa)
-
-         h2osoi_ice  =>  col_ws%h2osoi_ice , & ! Input: [real(r8) (:,:)] ice lens (kg/m2)
-         h2osoi_liq  =>  col_ws%h2osoi_liq , & ! Input: [real(r8) (:,:)] liquid water (kg/m2)
-         frac_sno    =>  col_ws%frac_sno   , & ! Input: [real(r8) (:)] fraction of ground covered by snow (0 to 1)
-         frac_h2osfc =>  col_ws%frac_h2osfc  & ! Input: [real(r8) (:)] fraction of ground covered by surface water (0 to 1)
-         )
-
-       !$acc parallel loop independent gang vector default(present)
+     real(r8) :: fac, fac_fc, wx      !temporary variables
+     integer  :: c, l, fc     !indices
+
+
+     associate(                                              &
+          watsat      =>    soilstate_vars%watsat_col      , & ! Input:  [real(r8) (:,:)] volumetric soil water at saturation (porosity)
+          watfc       =>    soilstate_vars%watfc_col       , & ! Input:  [real(r8) (:,:)] volumetric soil water at field capacity
+          watmin      =>    soilstate_vars%watmin_col      , & ! Input:  [real(r8) (:,:)] min volumetric soil water
+          sucmin      =>    soilstate_vars%sucmin_col      , & ! Input:  [real(r8) (:,:)] min volumetric soil water
+          soilp_col   =>    col_ws%soilp      , & ! Input:  [real(r8) (:,:)] soil water pressure (Pa)
+
+          h2osoi_ice  =>    col_ws%h2osoi_ice , & ! Input:  [real(r8) (:,:)] ice lens (kg/m2)
+          h2osoi_liq  =>    col_ws%h2osoi_liq , & ! Input:  [real(r8) (:,:)] liquid water (kg/m2)
+          frac_sno    =>    col_ws%frac_sno   , & ! Input:  [real(r8) (:)] fraction of ground covered by snow (0 to 1)
+          frac_h2osfc =>    col_ws%frac_h2osfc  & ! Input:  [real(r8) (:)]  fraction of ground covered by surface water (0 to 1)
+          )
+
        do fc = 1,num_nolakec
           c = filter_nolakec(fc)
           l = col_pp%landunit(c)
           if (lun_pp%itype(l)/=istwet .AND. lun_pp%itype(l)/=istice  &
                .AND. lun_pp%itype(l)/=istice_mec) then
              if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-                wx   = (h2osoi_liq(c,1)/denh2o + h2osoi_ice(c,1)/denice)/col_pp%dz(c,1)
+                wx   = (h2osoi_liq(c,1)/denh2o+h2osoi_ice(c,1)/denice)/col_pp%dz(c,1)
                 fac  = min(1._r8, wx/watsat(c,1))
                 fac  = max( fac, 0.01_r8 )
-                ! Lee and Pielke 1992 beta, added by K.Sakaguchi
-                if (wx < watfc(c,1) ) then  ! when water content of ths top layer is less than that at F.C.
-                   fac_fc  = min(1._r8, wx/watfc(c,1)) ! eqn5.66 but divided by theta at field capacity
+                !! Lee and Pielke 1992 beta, added by K.Sakaguchi
+                if (wx < watfc(c,1) ) then  !when water content of ths top layer is less than that at F.C.
+                   fac_fc  = min(1._r8, wx/watfc(c,1))  !eqn5.66 but divided by theta at field capacity
                    fac_fc  = max( fac_fc, 0.01_r8 )
                    ! modify soil beta by snow cover. soilbeta for snow surface is one
                    soilbeta(c) = (1._r8-frac_sno(c)-frac_h2osfc(c)) &
                         *0.25_r8*(1._r8 - cos(SHR_CONST_PI*fac_fc))**2._r8 &
-                        + frac_sno(c) + frac_h2osfc(c)
-                else   ! when water content of ths top layer is more than that at F.C.
+                        + frac_sno(c)+ frac_h2osfc(c)
+                else   !when water content of ths top layer is more than that at F.C.
                    soilbeta(c) = 1._r8
                 end if
                 if ( use_vsfm ) then
@@ -166,10 +171,10 @@ contains
                    if (wx < watfc(c,1) ) then  !when water content of ths top layer is less than that at F.C.
                       if (wx >= watmin(c,1) .and. soilp_col(c,1) >= sucmin(c,1) ) then
                          fac_fc  = min(1._r8, wx/watfc(c,1))  !eqn5.66 but divided by theta at field capacity
-                         fac_fc  = max(fac_fc, 0.01_r8)
+                         fac_fc  = max( fac_fc, 0.01_r8 )
                          ! modify soil beta by snow cover. soilbeta for snow surface is one
                          soilbeta(c) = (1._r8-frac_sno(c)-frac_h2osfc(c)) &
-                              *0.25_r8*(1._r8-cos(SHR_CONST_PI*fac_fc))**2._r8 &
+                              *0.25_r8*(1._r8 - cos(SHR_CONST_PI*fac_fc))**2._r8 &
                               + frac_sno(c)+ frac_h2osfc(c)
                       else
                          soilbeta(c) = 0._r8
diff --git a/components/elm/src/biogeophys/TotalWaterAndHeatMod.F90 b/components/elm/src/biogeophys/TotalWaterAndHeatMod.F90
index a82cac647c..f222dca037 100644
--- a/components/elm/src/biogeophys/TotalWaterAndHeatMod.F90
+++ b/components/elm/src/biogeophys/TotalWaterAndHeatMod.F90
@@ -5,13 +5,13 @@ module TotalWaterAndHeatMod
   ! Routines for computing total column water and heat contents
   !
   ! !USES:
-  #include "shr_assert.h"
+#include "shr_assert.h"
   use shr_kind_mod       , only : r8 => shr_kind_r8
   use shr_log_mod        , only : errMsg => shr_log_errMsg
   use decompMod          , only : bounds_type
   use elm_varcon         , only : cpice, cpliq, denh2o, tfrz, hfus, aquifer_water_baseline
   use elm_varpar         , only : nlevgrnd, nlevsoi, nlevurb, nlevlak
-  use subgridAveMod      , only : p2c_1d_parallel, unity
+  use subgridAveMod      , only : p2c
   use SoilHydrologyType  , only : soilhydrology_type
   use UrbanParamsType    , only : urbanparams_type
   use SoilStateType      , only : soilstate_type
@@ -24,7 +24,6 @@ module TotalWaterAndHeatMod
   use ColumnDataType     , only : col_es, col_ws
   use VegetationType     , only : veg_pp
   use VegetationDataType , only : veg_ws
-  use elm_varctl    , only : iulog 
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -96,7 +95,7 @@ contains
     integer                  , intent(in)    :: num_nolakec                ! number of column non-lake points in column filter
     integer                  , intent(in)    :: filter_nolakec(:)          ! column filter for non-lake points
     type(soilhydrology_type) , intent(in)    :: soilhydrology_inst
-    real(r8)                 , intent(inout) :: water_mass(bounds%begc:) ! computed water mass (kg m-2)
+    real(r8)                 , intent(inout) :: water_mass( bounds%begc: ) ! computed water mass (kg m-2)
     !
     ! !LOCAL VARIABLES:
     real(r8) :: liquid_mass(bounds%begc:bounds%endc)  ! kg m-2
@@ -105,8 +104,7 @@ contains
 
     character(len=*), parameter :: subname = 'ComputeWaterMassNonLake'
     !-----------------------------------------------------------------------
-   
-    !$acc enter data copyin(liquid_mass(:), ice_mass(:))
+
 
     call ComputeLiqIceMassNonLake( &
          bounds = bounds, &
@@ -115,16 +113,12 @@ contains
          soilhydrology_inst = soilhydrology_inst, &
          liquid_mass = liquid_mass(bounds%begc:bounds%endc), &
          ice_mass = ice_mass(bounds%begc:bounds%endc))
-    
-    !$acc parallel loop independent gang vector default(present)
+
     do fc = 1, num_nolakec
        c = filter_nolakec(fc)
        water_mass(c) = liquid_mass(c) + ice_mass(c)
     end do
 
-    !$acc enter data copyin(liquid_mass(:), ice_mass(:))
-
-
   end subroutine ComputeWaterMassNonLake
 
   !-----------------------------------------------------------------------
@@ -149,6 +143,7 @@ contains
     character(len=*), parameter :: subname = 'ComputeWaterMassLake'
     !-----------------------------------------------------------------------
 
+
     call ComputeLiqIceMassLake( &
          bounds = bounds, &
          num_lakec = num_lakec, &
@@ -176,6 +171,7 @@ contains
     ! to ComputeHeatNonLake
     !
     ! !ARGUMENTS:
+      !$acc routine seq
     type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_nolakec                 ! number of column non-lake points in column filter
     integer                  , intent(in)    :: filter_nolakec(:)           ! column filter for non-lake points
@@ -186,10 +182,11 @@ contains
     ! !LOCAL VARIABLES:
     integer  :: c, j, fc, l, p                  ! indices
     logical  :: has_h2o  ! whether this point potentially has water to add
+    real(r8) :: h2ocan_col(bounds%begc:bounds%endc)  ! canopy water (mm H2O)
+    real(r8) :: snocan_col(bounds%begc:bounds%endc)  ! canopy snow water (mm H2O)
     real(r8) :: liqcan                               ! canopy liquid water (mm H2O)
 
     character(len=*), parameter :: subname = 'ComputeLiqIceMassNonLake'
-    real(r8) :: sum1, sum2 
     !-----------------------------------------------------------------------
 
 
@@ -199,29 +196,32 @@ contains
          h2osfc       =>    col_ws%h2osfc     , & ! Input:  [real(r8) (:)   ]  surface water (mm)
          h2osno       =>    col_ws%h2osno     , & ! Input:  [real(r8) (:)   ]  snow water (mm H2O)
          h2ocan_patch =>    veg_ws%h2ocan   , & ! Input:  [real(r8) (:)   ]  canopy water (mm H2O)
+!         snocan_patch =>    waterstate_inst%snocan_patch   , & ! Input:  [real(r8) (:)   ]  canopy snow water (mm H2O)
          h2osoi_ice   =>    col_ws%h2osoi_ice , & ! Input:  [real(r8) (:,:) ]  ice lens (kg/m2)
          h2osoi_liq   =>    col_ws%h2osoi_liq , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2)
-         total_plant_stored_h2o => col_ws%total_plant_stored_h2o, & ! Input:  [real(r8) (:,:) ] plant internal stored water (mm H2O)
-         wa           =>    soilhydrology_inst%wa_col        &      ! Input:  [real(r8) (:)   ] water in the unconfined aquifer (mm)
+         total_plant_stored_h2o => col_ws%total_plant_stored_h2o, &
+                                                               ! Input:  [real(r8) (:,:) ] plant internal stored water (mm H2O)
+         wa           =>    soilhydrology_inst%wa_col        & ! Input:  [real(r8) (:)   ] water in the unconfined aquifer (mm)
          )
-    !$acc enter data create(&
-    !$acc sum1, &
-    !$acc sum2)
+
     do fc = 1, num_nolakec
        c = filter_nolakec(fc)
        liquid_mass(c) = 0._r8
        ice_mass(c) = 0._r8
-     end do
+    end do
 
-    ! call p2c_1d_filter_parallel(bounds, num_nolakec, filter_nolakec, &
-    !     h2ocan_patch(bounds%begp:bounds%endp), &
-    !     h2ocan_col(bounds%begc:bounds%endc))
-   
+    call p2c(bounds, num_nolakec, filter_nolakec, &
+         h2ocan_patch(bounds%begp:bounds%endp), &
+         h2ocan_col(bounds%begc:bounds%endc))
+
+    !call p2c(bounds, num_nolakec, filter_nolakec, &
+    !     snocan_patch(bounds%begp:bounds%endp), &
+    !     snocan_col(bounds%begc:bounds%endc))
+    snocan_col(:) = 0._r8
 
-    !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2)
     do fc = 1, num_nolakec
        c = filter_nolakec(fc)
-       
+
        ! waterstate_inst%snocan_patch and waterstate_inst%liqcan_patch are only set if
        ! we're using snow-on-veg; otherwise they are 0. However, we can rely on
        ! h2ocan_patch being set in all cases, so we can always determine the liquid mass
@@ -233,85 +233,67 @@ contains
        ! non-changing, and is set to 0 for a trivial solution.
 
        if (snl(c) < 0) then
-         sum1 = 0._r8 
-         sum2 = 0._r8 
-         
-         ! Loop over snow layers
-         !$acc loop vector reduction(+:sum1,sum2) 
+          ! Loop over snow layers
           do j = snl(c)+1,0
-             sum1 = sum1 + h2osoi_liq(c,j)
-             sum2 = sum2 + h2osoi_ice(c,j)
+             liquid_mass(c) = liquid_mass(c) + h2osoi_liq(c,j)
+             ice_mass(c) = ice_mass(c) + h2osoi_ice(c,j)
           end do
-
-          liquid_mass(c) = sum1
-          ice_mass(c)    = sum2 
        else if (h2osno(c) /= 0._r8) then
           ! No explicit snow layers, but there may still be some ice in h2osno (there is
           ! no liquid water in this case)
-          ice_mass(c) = h2osno(c)
+          ice_mass(c) = ice_mass(c) + h2osno(c)
        end if
 
     end do
 
     ! Soil water content
-    !$acc parallel loop gang worker independent default(present) private(sum1,sum2)
-    do fc = 1, num_nolakec
-      c = filter_nolakec(fc)
-      if (col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall .or. &
-          col_pp%itype(c) == icol_roof .or. col_pp%itype(c) == icol_road_imperv) then
-         has_h2o = .false.
-      else
-         sum1 = 0._r8; sum2 = 0._r8 
-         !$acc loop vector reduction(+:sum1,sum2) 
-         do j = 1, nlevgrnd
-            !has_h2o = .true.
-            sum1 = sum1 + h2osoi_liq(c,j)
-            sum2 = sum2 + h2osoi_ice(c,j)
-         end do
-         liquid_mass(c) = liquid_mass(c) + sum1
-         ice_mass(c) = ice_mass(c) + sum2 
-      end if
+    do j = 1, nlevgrnd
+       do fc = 1, num_nolakec
+          c = filter_nolakec(fc)
+          if (col_pp%itype(c) == icol_sunwall .or. col_pp%itype(c) == icol_shadewall .or. &
+              col_pp%itype(c) == icol_roof .or. col_pp%itype(c) == icol_road_imperv) then
+             has_h2o = .false.
+          else
+             has_h2o = .true.
+          end if
+
+          if (has_h2o) then
+             liquid_mass(c) = liquid_mass(c) + h2osoi_liq(c,j)
+             ice_mass(c) = ice_mass(c) + h2osoi_ice(c,j)
+         end if
+       end do
     end do
 
-    !$acc parallel loop independent gang vector default(present) 
     do fc = 1, num_nolakec
        c = filter_nolakec(fc)
        l = col_pp%landunit(c)
        if ( (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop          )  &
-            .or. (lun_pp%itype(l) == istwet     )  &
-            .or. (lun_pp%itype(l) == istice     )  &
-            .or. (lun_pp%itype(l) == istice_mec )  &
-            .or. (lun_pp%urbpoi(l)  .and. col_pp%itype(c) == icol_road_perv  )) then
-         
+            .or. (lun_pp%itype(l) == istwet                                   )  &
+            .or. (lun_pp%itype(l) == istice                                   )  &
+            .or. (lun_pp%itype(l) == istice_mec                               )  &
+            .or. (lun_pp%urbpoi(l)          .and. col_pp%itype(c) == icol_road_perv  )) then
           liquid_mass(c) = liquid_mass(c) + wa(c)
        end if
-       ice_mass(c)    = ice_mass(c) !+ snocan_col(c)
-
-    end do 
-    
-    !$acc parallel loop gang worker independent default(present) private(sum1)
-    do fc = 1, num_nolakec
-      c = filter_nolakec(fc)
-      l = col_pp%landunit(c)
+       l = col_pp%landunit(c)
 
        if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then   ! note: soil specified at LU level
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1)
           do p = col_pp%pfti(c),col_pp%pftf(c) ! loop over patches
              if (veg_pp%active(p)) then
-               sum1 = sum1 + h2ocan_patch(p) * veg_pp%wtcol(p)
-             end if
+                liquid_mass(c) = liquid_mass(c) + h2ocan_patch(p) * veg_pp%wtcol(p)
+            end if
           end do
-          liquid_mass(c) = liquid_mass(c) + sum1 
        end if
        !liqcan = h2ocan_col(c) - snocan_col(c)
        !liquid_mass(c) = liquid_mass(c) + liqcan + total_plant_stored_h2o(c)
-       
-    end do
-    !$acc exit data delete(&
-    !$acc sum1, &
-    !$acc sum2)
+       ice_mass(c)    = ice_mass(c) + snocan_col(c)
 
+       if (col_pp%itype(c) == icol_roof .or. col_pp%itype(c) == icol_sunwall &
+            .or. col_pp%itype(c) == icol_shadewall .or. col_pp%itype(c) == icol_road_imperv) then
+          ! Nothing more to add in this case
+       else
+          !liquid_mass(c) = liquid_mass(c) +  h2osfc(c)
+       end if
+    end do
   end associate
 
   end subroutine ComputeLiqIceMassNonLake
@@ -327,6 +309,7 @@ contains
     ! to ComputeHeatLake
     !
     ! !ARGUMENTS:
+      !$acc routine seq
     type(bounds_type)     , intent(in)    :: bounds
     integer               , intent(in)    :: num_lakec                   ! number of column lake points in column filter
     integer               , intent(in)    :: filter_lakec(:)             ! column filter for lake points
@@ -336,80 +319,59 @@ contains
     !
     ! !LOCAL VARIABLES:
     integer :: c, j, fc                  ! indices
-    real(r8) :: sum1, sum2 
+
     character(len=*), parameter :: subname = 'ComputeLiqIceMassLake'
     !-----------------------------------------------------------------------
 
 
     associate( &
-         snl          =>    col_pp%snl        , & ! Input:  [integer  (:)   ]  negative number of snow layers
+         snl          =>    col_pp%snl                        , & ! Input:  [integer  (:)   ]  negative number of snow layers
+
          h2osno       =>    col_ws%h2osno     , & ! Input:  [real(r8) (:)   ]  snow water (mm H2O)
          h2osoi_ice   =>    col_ws%h2osoi_ice , & ! Input:  [real(r8) (:,:) ]  ice lens (kg/m2)
          h2osoi_liq   =>    col_ws%h2osoi_liq   & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2)
          )
-    !$acc enter data create(sum1, sum2)
-    
-    !$acc parallel loop independent gang vector default(present) 
-    do fc =1, num_lakec 
-      c = filter_lakec(fc)  
-      liquid_mass(c) = 0._r8 
-      ice_mass(c) = 0._r8 
-    end do 
-    
+
+    do fc = 1, num_lakec
+       c = filter_lakec(fc)
+       liquid_mass(c) = 0._r8
+       ice_mass(c) = 0._r8
+    end do
+
     ! Snow water content
-    !$acc parallel loop gang worker independent default(present) private(sum1,sum2)
     do fc = 1, num_lakec
        c = filter_lakec(fc)
-       sum1 = 0._r8 
-       sum2 = 0._r8
        if (snl(c) < 0) then
           ! Loop over snow layers
-          !$acc loop vector reduction(+:sum1,sum2)
           do j = snl(c)+1,0
-             sum1 = sum1 + h2osoi_liq(c,j)
-             sum2 = sum2 + h2osoi_ice(c,j)
+             liquid_mass(c) = liquid_mass(c) + h2osoi_liq(c,j)
+             ice_mass(c) = ice_mass(c) + h2osoi_ice(c,j)
           end do
        else if (h2osno(c) /= 0._r8) then
           ! No explicit snow layers, but there may still be some ice in h2osno (there is
           ! no liquid water in this case)
-          ice_mass(c) =  h2osno(c)
+          ice_mass(c) = ice_mass(c) + h2osno(c)
        end if
-       liquid_mass(c) =  sum1
-       ice_mass(c) = sum2 
     end do
 
     ! Soil water content of the soil under the lake
-    !$acc parallel loop independent gang worker default(present) private(sum1, sum2)
-    do fc = 1, num_lakec
-      c = filter_lakec(fc)
-      sum1 = 0._r8
-      sum2 = 0._r8 
-      !$acc loop vector reduction(+:sum1,sum2)
-      do j = 1, nlevgrnd
-          sum1 = sum1 + h2osoi_liq(c,j)
-          sum2 = sum2 + h2osoi_ice(c,j)
+    do j = 1, nlevgrnd
+       do fc = 1, num_lakec
+          c = filter_lakec(fc)
+          liquid_mass(c) = liquid_mass(c) + h2osoi_liq(c,j)
+          ice_mass(c) = ice_mass(c) + h2osoi_ice(c,j)
        end do
-       liquid_mass(c) = liquid_mass(c) + sum1
-       ice_mass(c)    = ice_mass(c) + sum2
     end do
 
-    !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
     do fc = 1, num_lakec
        c = filter_lakec(fc)
-       sum1 = 0._r8
-       sum2 = 0._r8 
-       !$acc loop vector reduction(+:sum1,sum2)
        do j = 1,nlevlak
-          sum1 = sum1 + (1 - lakestate_vars%lake_icefrac_col(c,j)) * col_pp%dz_lake(c,j) * denh2o
-          sum2 = sum2  +     lakestate_vars%lake_icefrac_col(c,j)  * col_pp%dz_lake(c,j) * denh2o
+          liquid_mass(c) = liquid_mass(c) + (1 - lakestate_vars%lake_icefrac_col(c,j)) * col_pp%dz_lake(c,j) * denh2o
+          ice_mass(c)    = ice_mass(c)    +      lakestate_vars%lake_icefrac_col(c,j)  * col_pp%dz_lake(c,j) * denh2o
           ! lake layers do not change thickness when freezing, so denh2o should be used
           ! (thermal properties are appropriately adjusted; see LakeTemperatureMod)
        end do
-       liquid_mass(c) = liquid_mass(c) + sum1
-       ice_mass(c)    = ice_mass(c)   + sum2
     end do
-    !$acc exit data delete(sum1, sum2)
-    
   end associate
 
   end subroutine ComputeLiqIceMassLake
@@ -431,7 +393,7 @@ contains
     ! generally be accompanied by similar changes to ComputeLiqIceMassNonLake
     !
     ! !ARGUMENTS:
-      
+      !$acc routine seq
     type(bounds_type)        , intent(in)  :: bounds
     integer                  , intent(in)  :: num_nolakec
     integer                  , intent(in)  :: filter_nolakec(:)
@@ -450,15 +412,16 @@ contains
     logical  :: has_h2o  ! whether this point potentially has water to add
 
     real(r8) :: h2ocan_col(bounds%begc:bounds%endc)  ! canopy water (mm H2O)
+    real(r8) :: snocan_col(bounds%begc:bounds%endc)  ! canopy snow water (mm H2O)
     real(r8) :: liqcan        ! canopy liquid water (mm H2O)
 
-    real(r8) :: heat_dry_mass(num_nolakec) ! sum of heat content: dry mass [J/m^2]
-    real(r8) :: heat_ice(num_nolakec)      ! sum of heat content: ice [J/m^2]
-    real(r8) :: latent_heat_liquid(num_nolakec) ! sum of latent heat content of liquid water [J/m^2]
-    
-    real(r8) :: sum_heat,sum_cv,sum_latent, sum_hice, sum_dry
-    
+    real(r8) :: heat_dry_mass(bounds%begc:bounds%endc) ! sum of heat content: dry mass [J/m^2]
+    real(r8) :: heat_ice(bounds%begc:bounds%endc)      ! sum of heat content: ice [J/m^2]
+    real(r8) :: latent_heat_liquid(bounds%begc:bounds%endc) ! sum of latent heat content of liquid water [J/m^2]
+
+    !character(len=*), parameter :: subname = 'ComputeHeatNonLake'
     !-----------------------------------------------------------------------
+
     associate( &
          snl          => col_pp%snl, & ! number of snow layers
          dz           => col_pp%dz, &  ! layer depth (m)
@@ -475,31 +438,34 @@ contains
          h2osno       => col_ws%h2osno, & ! snow water (mm H2O)
          h2osfc       => col_ws%h2osfc, & ! surface water (mm H2O)
          h2ocan_patch => veg_ws%h2ocan, & ! canopy water (mm H2O)
+!         snocan_patch => waterstate_inst%snocan_patch, & ! canopy snow water (mm H2O)
          total_plant_stored_h2o_col => col_ws%total_plant_stored_h2o, & ! Input: [real(r8) (:)   ]  water mass in plant tissues (kg m-2)
          wa           => soilhydrology_inst%wa_col & ! water in the unconfined aquifer (mm)
          )
-    !$acc enter data create(&
-    !$acc h2ocan_col(:), &
-    !$acc heat_dry_mass(:), &
-    !$acc heat_ice(:), &
-    !$acc latent_heat_liquid(:), &
-    !$acc sum_hice, &
-    !$acc sum_dry)
-
-    call p2c_1d_parallel(bounds, &
-         parr = h2ocan_patch(bounds%begp:bounds%endp), &
-         carr = h2ocan_col(bounds%begc:bounds%endc), &
-         p2c_scale_type = unity, para=.true.)
 
-    !$acc parallel loop independent gang vector default(present) 
     do fc = 1, num_nolakec
        c = filter_nolakec(fc)
 
-       heat_ice(fc) = 0._r8 
        heat_liquid(c) = 0._r8
        cv_liquid(c) = 0._r8
-       heat_dry_mass(fc) = 0._r8
-       latent_heat_liquid(fc) = 0._r8
+       heat_dry_mass(c) = 0._r8
+       heat_ice(c) = 0._r8
+       latent_heat_liquid(c) = 0._r8
+    end do
+
+    call p2c(bounds, &
+         parr = h2ocan_patch(bounds%begp:bounds%endp), &
+         carr = h2ocan_col(bounds%begc:bounds%endc), &
+         p2c_scale_type = 0)
+
+    !call p2c(bounds, &
+    !     parr = snocan_patch(bounds%begp:bounds%endp), &
+    !     carr = snocan_col(bounds%begc:bounds%endc), &
+    !     p2c_scale_type = 'unity')
+    snocan_col(bounds%begc:bounds%endc) = 0._r8
+
+    do fc = 1, num_nolakec
+       c = filter_nolakec(fc)
 
        !--- canopy water ---
        !
@@ -527,61 +493,35 @@ contains
        ! we are not accounting for or conserving the flux of energy between the two
        ! pools.  The energy in the plant water should "bring with it" the internal
        ! energy of the soil-to-root water flux.
-      
-       ! NOTE: Why multiply by 0._r8?
-       liqcan = (h2ocan_col(fc) + total_plant_stored_h2o_col(c))*0._r8
+
+       liqcan = (h2ocan_col(c) - snocan_col(c) + total_plant_stored_h2o_col(c))*0._r8
        call AccumulateLiquidWaterHeat( &
             temp = heat_base_temp, &
             h2o = liqcan, &
             cv_liquid = cv_liquid(c), &
             heat_liquid = heat_liquid(c), &
-            latent_heat_liquid = latent_heat_liquid(fc))
-         
-    end do 
+            latent_heat_liquid = latent_heat_liquid(c))
 
-    !$acc parallel loop independent gang worker default(present) private(sum_heat,sum_cv,sum_latent,sum_hice)
-    do fc = 1, num_nolakec
-      c = filter_nolakec(fc)
        !--- snow ---
        if ( snl(c) < 0 ) then
           ! Loop over snow layers
-         sum_heat = 0._r8
-         sum_cv = 0._r8 
-         sum_latent = 0._r8
-         sum_hice = 0._r8
-
-         !$acc loop vector reduction(+:sum_heat,sum_cv,sum_latent,sum_hice)
           do j = snl(c)+1,0
              call AccumulateLiquidWaterHeat( &
                   temp = t_soisno(c,j), &
                   h2o = h2osoi_liq(c,j), &
-                  cv_liquid = sum_cv, &
-                  heat_liquid = sum_heat, &
-                  latent_heat_liquid = sum_latent)
-            
-             sum_hice = sum_hice + &
+                  cv_liquid = cv_liquid(c), &
+                  heat_liquid = heat_liquid(c), &
+                  latent_heat_liquid = latent_heat_liquid(c))
+             heat_ice(c) = heat_ice(c) + &
                   TempToHeat(t_soisno(c,j), (h2osoi_ice(c,j)*cpice))
           end do
-
-          cv_liquid(c) = cv_liquid(c) + sum_cv 
-          heat_liquid(c) = heat_liquid(c) + sum_heat 
-          latent_heat_liquid(fc) = latent_heat_liquid(fc) + sum_latent 
-          heat_ice(fc) = sum_hice
-
-      else if (h2osno(c) /= 0._r8) then
+       else if (h2osno(c) /= 0._r8) then
           ! No explicit snow layers, but there may still be some ice in h2osno (there is
           ! no liquid water in this case)
-         !  j = 1
-          heat_ice(fc) = heat_ice(fc) + &
-               TempToHeat(t_soisno(c,1), (h2osno(c)*cpice))
-      end if
-
-    end do
-      
-    
-    !$acc parallel loop independent gang vector default(present) 
-   do fc = 1, num_nolakec
-       c = filter_nolakec(fc)
+          j = 1
+          heat_ice(c) = heat_ice(c) + &
+               TempToHeat(t_soisno(c,j), (h2osno(c)*cpice))
+       end if
 
        if (col_pp%hydrologically_active(c)) then
           ! NOTE(wjs, 2017-03-23) Water in the unconfined aquifer currently doesn't have
@@ -599,7 +539,7 @@ contains
                h2o = (wa(c) - aquifer_water_baseline), &
                cv_liquid = cv_liquid(c), &
                heat_liquid = heat_liquid(c), &
-               latent_heat_liquid = latent_heat_liquid(fc))
+               latent_heat_liquid = latent_heat_liquid(c))
        end if
 
        if (col_pp%itype(c) == icol_roof .or. col_pp%itype(c) == icol_sunwall &
@@ -612,37 +552,30 @@ contains
                h2o = h2osfc(c), &
                cv_liquid = cv_liquid(c), &
                heat_liquid = heat_liquid(c), &
-               latent_heat_liquid = latent_heat_liquid(fc))
+               latent_heat_liquid = latent_heat_liquid(c))
        end if
 
     end do
 
 
     !--- below ground (soil & soil water) and related urban columns
-    !$acc parallel loop independent gang worker default(present) private(c,l,sum_heat,sum_cv,sum_latent,sum_hice,sum_dry) & 
-    !$acc  present(heat_dry_mass(:),cv_liquid(:), heat_liquid(:), latent_heat_liquid(:), heat_ice(:) ) 
-    do fc = 1, num_nolakec
-      c = filter_nolakec(fc)
-      l = col_pp%landunit(c)
-      sum_heat = 0._r8
-      sum_cv = 0._r8 
-      sum_latent = 0._r8
-      sum_hice = 0._r8
-      sum_dry = 0._r8
-      
-      !$acc loop vector reduction(+:sum_heat,sum_cv,sum_latent,sum_hice,sum_dry) private(has_h2o)
-      do j = 1, nlevgrnd
-          
+    do j = 1, nlevgrnd
+       do fc = 1, num_nolakec
+          c = filter_nolakec(fc)
+          l = col_pp%landunit(c)
+
           if (col_pp%itype(c)==icol_sunwall .or. col_pp%itype(c)==icol_shadewall) then
              has_h2o = .false.
              if (j <= nlevurb) then
-                sum_dry = sum_dry + TempToHeat(t_soisno(c,j), (cv_wall(l,j) * dz(c,j)) )
+                heat_dry_mass(c) = heat_dry_mass(c) + &
+                     TempToHeat(t_soisno(c,j), (cv_wall(l,j) * dz(c,j)))
              end if
 
           else if (col_pp%itype(c) == icol_roof) then
              if (j <= nlevurb) then
                 has_h2o = .true.
-                sum_dry = sum_dry + TempToHeat(t_soisno(c,j), (cv_roof(l,j) * dz(c,j)))
+                heat_dry_mass(c) = heat_dry_mass(c) + &
+                     TempToHeat(t_soisno(c,j), (cv_roof(l,j) * dz(c,j)))
              else
                 has_h2o = .false.
              end if
@@ -651,13 +584,12 @@ contains
              has_h2o = .true.
 
              if (col_pp%itype(c) == icol_road_imperv .and. j <= nlev_improad(l)) then
-
-                sum_dry = sum_dry + TempToHeat(t_soisno(c,j),(cv_improad(l,j) * dz(c,j)))
-
+                heat_dry_mass(c) = heat_dry_mass(c) + &
+                     TempToHeat(t_soisno(c,j),(cv_improad(l,j) * dz(c,j)))
              else if (lun_pp%itype(l) /= istwet .and. lun_pp%itype(l) /= istice .and. lun_pp%itype(l) /= istice_mec) then
                 ! Note that this also includes impervious roads below nlev_improad (where
                 ! we have soil)
-                sum_dry = sum_dry + &
+                heat_dry_mass(c) = heat_dry_mass(c) + &
                      TempToHeat( t_soisno(c,j), (csol(c,j)*(1-watsat(c,j))*dz(c,j)))
              end if
           end if
@@ -666,36 +598,20 @@ contains
              call AccumulateLiquidWaterHeat( &
                   temp = t_soisno(c,j), &
                   h2o = h2osoi_liq(c,j), &
-                  cv_liquid = sum_cv, &
-                  heat_liquid = sum_heat, &
-                  latent_heat_liquid = sum_latent)
-            
-            sum_hice = sum_hice +  &
+                  cv_liquid = cv_liquid(c), &
+                  heat_liquid = heat_liquid(c), &
+                  latent_heat_liquid = latent_heat_liquid(c))
+             heat_ice(c) = heat_ice(c) + &
                   TempToHeat(t_soisno(c,j), (h2osoi_ice(c,j)*cpice))
           end if
        end do
-
-       heat_dry_mass(fc) = sum_dry 
-       cv_liquid(c) = cv_liquid(c) + sum_cv 
-       heat_liquid(c) = heat_liquid(c) + sum_heat
-       latent_heat_liquid(fc) = latent_heat_liquid(fc) + sum_latent
-       heat_ice(fc) = heat_ice(fc) + sum_hice 
     end do
 
-    !$acc parallel loop independent gang vector default(present)
     do fc = 1, num_nolakec
        c = filter_nolakec(fc)
-       heat(c) = heat_dry_mass(fc) + heat_ice(fc) + heat_liquid(c) + latent_heat_liquid(fc)
+       heat(c) = heat_dry_mass(c) + heat_ice(c) + heat_liquid(c) + latent_heat_liquid(c)
     end do
 
-    !$acc exit data delete(&
-    !$acc h2ocan_col(:), &
-    !$acc heat_dry_mass(:), &
-    !$acc heat_ice(:), &
-    !$acc latent_heat_liquid(:), &
-    !$acc sum_hice, &
-    !$acc sum_dry)
-
     end associate
 
   end subroutine ComputeHeatNonLake
@@ -717,7 +633,7 @@ contains
     ! generally be accompanied by similar changes to ComputeLiqIceMassLake
     !
     ! !ARGUMENTS:
-      
+      !$acc routine seq
     type(bounds_type)        , intent(in)  :: bounds
     integer                  , intent(in)  :: num_lakec
     integer                  , intent(in)  :: filter_lakec(:)
@@ -731,15 +647,17 @@ contains
     integer :: fc
     integer :: c,j
 
-    real(r8) :: heat_dry_mass(1:num_lakec) ! sum of heat content: dry mass [J/m^2]
-    real(r8) :: heat_ice(1:num_lakec)      ! sum of heat content: ice [J/m^2]
-    real(r8) :: latent_heat_liquid(1:num_lakec) ! sum of latent heat content of liquid water [J/m^2]
-    
-    real(r8) :: sum_heat,sum_cv,sum_latent, sum_hice, sum_dry
+    real(r8) :: heat_dry_mass(bounds%begc:bounds%endc) ! sum of heat content: dry mass [J/m^2]
+    real(r8) :: heat_ice(bounds%begc:bounds%endc)      ! sum of heat content: ice [J/m^2]
+    real(r8) :: latent_heat_liquid(bounds%begc:bounds%endc) ! sum of latent heat content of liquid water [J/m^2]
 
     !character(len=*), parameter :: subname = 'ComputeHeatLake'
     !-----------------------------------------------------------------------
-    
+
+    !SHR_ASSERT_ALL((ubound(heat) == (/bounds%endc/)), errMsg(sourcefile, __LINE__))
+    !SHR_ASSERT_ALL((ubound(heat_liquid) == (/bounds%endc/)), errMsg(sourcefile, __LINE__))
+    !SHR_ASSERT_ALL((ubound(cv_liquid) == (/bounds%endc/)), errMsg(sourcefile, __LINE__))
+
     associate( &
          snl          => col_pp%snl, & ! number of snow layers
          dz           => col_pp%dz, &  ! layer depth (m)
@@ -750,111 +668,66 @@ contains
          h2osoi_ice   => col_ws%h2osoi_ice, & ! frozen water (kg/m2)
          h2osno       => col_ws%h2osno & ! snow water (mm H2O)
          )
-    !$acc enter data create(&
-    !$acc heat_dry_mass(:), &
-    !$acc heat_ice(:), &
-    !$acc latent_heat_liquid(:), &
-    !$acc sum_hice, &
-    !$acc sum_dry)
-
 
-    !$acc parallel loop independent gang vector default(present)
     do fc = 1, num_lakec
        c = filter_lakec(fc)
 
        heat_liquid(c) = 0._r8
        cv_liquid(c) = 0._r8
-
-       heat_dry_mass(fc) = 0._r8
-       heat_ice(fc) = 0._r8
-       latent_heat_liquid(fc) = 0._r8
+       heat_dry_mass(c) = 0._r8
+       heat_ice(c) = 0._r8
+       latent_heat_liquid(c) = 0._r8
     end do
 
     ! Snow heat content
-    !$acc parallel loop independent gang worker default(present) private(sum_heat,sum_cv,sum_latent,sum_hice)
     do fc = 1, num_lakec
        c = filter_lakec(fc)
-       sum_heat = 0._r8
-       sum_cv = 0._r8 
-       sum_latent = 0._r8
-       sum_hice = 0._r8
        if ( snl(c) < 0 ) then
-         ! Loop over snow layers
-         !$acc loop vector reduction(+:sum_heat,sum_cv,sum_latent, sum_hice)
+          ! Loop over snow layers
           do j = snl(c)+1,0
              call AccumulateLiquidWaterHeat( &
                   temp = t_soisno(c,j), &
                   h2o = h2osoi_liq(c,j), &
-                  cv_liquid = sum_cv, &
-                  heat_liquid = sum_heat, &
-                  latent_heat_liquid = sum_latent)
-             
-             sum_hice = sum_hice + &
+                  cv_liquid = cv_liquid(c), &
+                  heat_liquid = heat_liquid(c), &
+                  latent_heat_liquid = latent_heat_liquid(c))
+             heat_ice(c) = heat_ice(c) + &
                   TempToHeat(t_soisno(c,j), (h2osoi_ice(c,j)*cpice))
           end do
-          
-         !  else if (h2osno(c) /= 0._r8) then
-         !     ! TODO(wjs, 2017-03-16) (Copying this note from old code... I'm not positive
-         !     ! it's still true.) The heat capacity (not latent heat) of snow without snow
-         !     ! layers is currently ignored in LakeTemperature, so it should be ignored here.
-         !     ! Eventually we should consider this.
+       else if (h2osno(c) /= 0._r8) then
+          ! TODO(wjs, 2017-03-16) (Copying this note from old code... I'm not positive
+          ! it's still true.) The heat capacity (not latent heat) of snow without snow
+          ! layers is currently ignored in LakeTemperature, so it should be ignored here.
+          ! Eventually we should consider this.
        end if
-       cv_liquid(c) = sum_cv 
-       heat_liquid(c) = sum_heat
-       latent_heat_liquid(fc) = sum_latent 
-       heat_ice(fc) = sum_hice 
     end do
 
     ! Soil water content of the soil under the lake
-    !$acc parallel loop independent gang worker default(present) private(sum_heat,sum_cv,sum_latent,sum_hice,sum_dry)
-    do fc = 1, num_lakec
-      c = filter_lakec(fc)
-      sum_heat = 0._r8
-      sum_cv = 0._r8 
-      sum_latent = 0._r8
-      sum_hice = 0._r8
-      sum_dry = 0._r8
-
-      !$acc loop vector reduction(+:sum_heat,sum_cv,sum_latent, sum_hice,sum_dry)
-      do j = 1,nlevgrnd
-
-         sum_dry = sum_dry + TempToHeat( t_soisno(c,j), (csol(c,j)*(1-watsat(c,j))*dz(c,j)))
+    do j = 1,nlevgrnd
+       do fc = 1, num_lakec
+          c = filter_lakec(fc)
 
-         call AccumulateLiquidWaterHeat( &
+          heat_dry_mass(c) = heat_dry_mass(c) + &
+               TempToHeat( t_soisno(c,j), (csol(c,j)*(1-watsat(c,j))*dz(c,j)))
+          call AccumulateLiquidWaterHeat( &
                temp = t_soisno(c,j), &
                h2o = h2osoi_liq(c,j), &
-               cv_liquid = sum_cv, &
-               heat_liquid = sum_heat, &
-               latent_heat_liquid = sum_latent)
-
-         sum_hice = sum_hice  + &
+               cv_liquid = cv_liquid(c), &
+               heat_liquid = heat_liquid(c), &
+               latent_heat_liquid = latent_heat_liquid(c))
+          heat_ice(c) = heat_ice(c) + &
                TempToHeat(t_soisno(c,j), (h2osoi_ice(c,j)*cpice))
        end do
-       heat_dry_mass(fc) = sum_dry 
-       
-       cv_liquid(c) = cv_liquid(c) + sum_cv 
-       heat_liquid(c) = heat_liquid(c) + sum_heat
-       latent_heat_liquid(fc) = latent_heat_liquid(fc) + sum_latent 
-       heat_ice(fc) = heat_ice(fc) + sum_hice
-
     end do
 
     ! TODO(wjs, 2017-03-11) Include heat content of water in lakes, once we include
     ! lake water as an explicit water state (https://github.com/NCAR/CLM/issues/2)
 
-    !$acc parallel loop independent gang vector default(present)
     do fc = 1, num_lakec
        c = filter_lakec(fc)
-       heat(c) = heat_dry_mass(fc) + heat_ice(fc) + heat_liquid(c) + latent_heat_liquid(fc)
+       heat(c) = heat_dry_mass(c) + heat_ice(c) + heat_liquid(c) + latent_heat_liquid(c)
     end do
 
-    !$acc exit data delete(&
-    !$acc heat_dry_mass(:), &
-    !$acc heat_ice(:), &
-    !$acc latent_heat_liquid(:), &
-    !$acc sum_hice, &
-    !$acc sum_dry)
-
     end associate
 
   end subroutine ComputeHeatLake
@@ -960,8 +833,8 @@ contains
     ! a given temperature, using a base temperature of heat_base_temp.
     !
     ! !USES:
-    !$acc routine seq 
-    ! !ARGUMENTS: 
+    !
+    ! !ARGUMENTS:
     real(r8) :: heat  ! function result
     real(r8), intent(in) :: temp  ! temperature [K]
     real(r8), intent(in) :: h2o   ! water mass [kg/m^2]
@@ -992,8 +865,7 @@ contains
     ! count for liquid water, for a single column
     !
     ! !ARGUMENTS:
-      
-      !$acc routine seq 
+      !$acc routine seq
     real(r8), intent(in) :: temp  ! temperature [K]
     real(r8), intent(in) :: h2o   ! water mass [kg/m^2]
 
diff --git a/components/elm/src/biogeophys/TridiagonalMod.F90 b/components/elm/src/biogeophys/TridiagonalMod.F90
index 9512e6277f..d4c493ac5a 100644
--- a/components/elm/src/biogeophys/TridiagonalMod.F90
+++ b/components/elm/src/biogeophys/TridiagonalMod.F90
@@ -10,7 +10,6 @@ module TridiagonalMod
   !
   ! !PUBLIC MEMBER FUNCTIONS:
   public :: Tridiagonal
-  public :: Tridiagonal_filter
   public :: trisim
   interface Tridiagonal
     module procedure Tridiagonal_sr
@@ -101,69 +100,6 @@ contains
 
   end subroutine Tridiagonal_sr
 
-  subroutine Tridiagonal_filter (lbj, ubj, jtop, numf, filter, a, b, c, r, u)
-    ! !DESCRIPTION:
-    ! Tridiagonal matrix solution
-    ! A x = r
-    ! where x and r are vectors
-    ! !USES:
-    use shr_kind_mod   , only: r8 => shr_kind_r8
-    !
-    ! !ARGUMENTS:
-    implicit none
-    integer           , intent(in)    :: lbj, ubj              ! lbinning and ubing level indices
-    integer           , intent(in)    :: jtop                  ! top level for each column [col]
-    integer           , intent(in)    :: numf                  ! filter dimension
-    integer           , intent(in)    :: filter(:)             ! filter
-    real(r8)          , intent(in)    :: a( 1:numf , lbj:ubj)  ! "a" left off diagonal of tridiagonal matrix [col , j]
-    real(r8)          , intent(in)    :: b( 1:numf , lbj:ubj)  ! "b" diagonal column for  tridiagonal matrix [col , j]
-    real(r8)          , intent(in)    :: c( 1:numf , lbj:ubj)  ! "c" right off diagonal   tridiagonal matrix [col , j]
-    real(r8)          , intent(in)    :: r( 1:numf , lbj:ubj)  ! "r" forcing term of      tridiagonal matrix [col , j]
-    real(r8)          , intent(inout) :: u( 1:numf , lbj:ubj)  ! solution      [col , j]
-    !==========================================================!
-    integer                           :: j,ci            ! indices
-    real(r8)                          :: gam(lbj:ubj)    ! temporary
-    real(r8)                          :: bet             ! temporary
-    !-----------------------------------------------------------------------
-    ! Solve the matrix
-    !-----------------------------------------------------------------------
-    
-
-    !$acc enter data create(&
-    !$acc gam(:))
-
-   !$acc parallel loop independent gang vector default(present) &
-   !$acc present(a(:,:),b(:,:),c(:,:),r(:,:),u(:,:)) private(bet,gam(:)) 
-   do ci = 1,numf
-      bet = b(ci,jtop)
-
-      !$acc loop seq 
-      do j = lbj, ubj
-         if (j >= jtop) then
-            if (j == jtop) then
-               u(ci,j) = r(ci,j) / bet
-            else
-               gam(j) = c(ci,j-1) / bet
-               bet = b(ci,j) - a(ci,j) * gam(j)
-               u(ci,j) = (r(ci,j) - a(ci,j)*u(ci,j-1)) / bet
-            end if
-         end if
-      end do
-   
-      !$acc loop seq 
-      do j = ubj-1,lbj,-1
-        if (j >= jtop) then
-          u(ci,j) = u(ci,j) - gam(j+1) * u(ci,j+1)
-        end if
-      end do
-
-   end do 
-
-    !$acc exit data delete(&
-    !$acc gam(:))
-
-   end subroutine Tridiagonal_filter
-
   !-----------------------------------------------------------------------
   subroutine Tridiagonal_mr (bounds, lbj, ubj, jtop, numf, filter, ntrcs, a, b, c, r, u, is_col_active)
     !$acc routine seq
@@ -253,6 +189,7 @@ contains
 
 !----------------
   subroutine Trisim(bounds, lbj, ubj, numf, filter, a1,b1,c1,d1,e1,a2,b2,c2,d2,e2,w1, w2)
+     !$acc routine seq
      !DESCRIPTIONS
      ! This subroutine solves two coupled tridiagonal equations
      ! A1*W1(J-1)+B1*W1(j)+C1*W1(J+1) = D1*W2(j) + E1 AND
@@ -406,11 +343,11 @@ contains
     integer           , intent(in)    :: jbot( bounds%begc: bounds%endc)          ! top level for each column [col]
     integer           , intent(in)    :: numf                                     ! filter dimension
     integer           , intent(in)    :: filter(:)                                ! filter
-    real(r8)          , intent(in)    :: a( 1:numf , lbj:ubj)    ! "a" left off diagonal of tridiagonal matrix [col , j]
-    real(r8)          , intent(in)    :: b( 1:numf , lbj:ubj)    ! "b" diagonal column for tridiagonal matrix [col  , j]
-    real(r8)          , intent(in)    :: c( 1:numf , lbj:ubj)    ! "c" right off diagonal tridiagonal matrix [col   , j]
-    real(r8)          , intent(in)    :: r( 1:numf , lbj:ubj)    ! "r" forcing term of tridiagonal matrix [col      , j]
-    real(r8)          , intent(inout) :: u( 1:numf , lbj:ubj)    ! solution [col                                    , j]
+    real(r8)          , intent(in)    :: a( bounds%begc:bounds%endc , lbj:ubj)    ! "a" left off diagonal of tridiagonal matrix [col , j]
+    real(r8)          , intent(in)    :: b( bounds%begc:bounds%endc , lbj:ubj)    ! "b" diagonal column for tridiagonal matrix [col  , j]
+    real(r8)          , intent(in)    :: c( bounds%begc:bounds%endc , lbj:ubj)    ! "c" right off diagonal tridiagonal matrix [col   , j]
+    real(r8)          , intent(in)    :: r( bounds%begc:bounds%endc , lbj:ubj)    ! "r" forcing term of tridiagonal matrix [col      , j]
+    real(r8)          , intent(inout) :: u( bounds%begc:bounds%endc , lbj:ubj)    ! solution [col                                    , j]
                                                                                   !
     integer                           :: j,ci,fc                                  ! indices
     logical, optional, intent(in)     :: is_col_active(bounds%begc:bounds%endc)   !
@@ -432,7 +369,7 @@ contains
     do fc = 1,numf
         ci = filter(fc)
         if(l_is_col_active(ci))then
-            bet(ci) = b(fc,jtop(ci))
+            bet(ci) = b(ci,jtop(ci))
         endif
     end do
 
@@ -442,11 +379,11 @@ contains
            if(l_is_col_active(ci))then
              if (j >= jtop(ci) .and. j <= jbot(ci)) then
                if (j == jtop(ci)) then
-                 u(fc,j) = r(fc,j) / bet(ci)
+                 u(ci,j) = r(ci,j) / bet(ci)
                else
-                 gam(ci,j) = c(fc,j-1) / bet(ci)
-                 bet(ci) = b(fc,j) - a(fc,j) * gam(ci,j)
-                 u(fc,j) = (r(fc,j) - a(fc,j)*u(fc,j-1)) / bet(ci)
+                 gam(ci,j) = c(ci,j-1) / bet(ci)
+                 bet(ci) = b(ci,j) - a(ci,j) * gam(ci,j)
+                 u(ci,j) = (r(ci,j) - a(ci,j)*u(ci,j-1)) / bet(ci)
                end if
              end if
            endif
@@ -458,7 +395,7 @@ contains
            ci = filter(fc)
            if(l_is_col_active(ci))then
              if (j >= jtop(ci) .and. j <= jbot(ci)-1) then
-               u(fc,j) = u(fc,j) - gam(ci,j+1) * u(fc,j+1)
+               u(ci,j) = u(ci,j) - gam(ci,j+1) * u(ci,j+1)
              end if
            endif
         end do
diff --git a/components/elm/src/biogeophys/UrbanAlbedoMod.F90 b/components/elm/src/biogeophys/UrbanAlbedoMod.F90
index df0d186f4d..00da663d09 100644
--- a/components/elm/src/biogeophys/UrbanAlbedoMod.F90
+++ b/components/elm/src/biogeophys/UrbanAlbedoMod.F90
@@ -1,20 +1,27 @@
 module UrbanAlbedoMod
-  !-----------------------------------------------------------------------
-  ! !DESCRIPTION:
+
+#include "shr_assert.h"
+
+  !----------------------------------------------------------------------- 
+  ! !DESCRIPTION: 
   ! Calculate solar and longwave radiation, and turbulent fluxes for urban landunit
   !
   ! !USES:
   use shr_kind_mod      , only : r8 => shr_kind_r8
+  use shr_sys_mod       , only : shr_sys_flush 
+  use shr_log_mod       , only : errMsg => shr_log_errMsg
+  use decompMod         , only : bounds_type
   use elm_varpar        , only : numrad
   use elm_varcon        , only : isecspday, degpsec, namel
   use elm_varctl        , only : iulog
+  use abortutils        , only : endrun  
   use UrbanParamsType   , only : urbanparams_type
   use SolarAbsorbedType , only : solarabs_type
   use SurfaceAlbedoType , only : surfalb_type
-  use LandunitType      , only : lun_pp
+  use LandunitType      , only : lun_pp                
   use ColumnType        , only : col_pp
-  use ColumnDataType    , only : col_ws
-  use VegetationType    , only : veg_pp
+  use ColumnDataType    , only : col_ws  
+  use VegetationType    , only : veg_pp                
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -22,23 +29,23 @@ module UrbanAlbedoMod
   private
   !
   ! !PUBLIC MEMBER FUNCTIONS:
-  public :: UrbanAlbedo       ! Urban physics - albedos
+  public :: UrbanAlbedo       ! Urban physics - albedos  
   !
   ! PRIVATE MEMBER FUNCTIONS
   private :: SnowAlbedo       ! Snow albedos
-  private :: incident_direct  ! Direct beam solar rad incident on walls and road in urban canyon
+  private :: incident_direct  ! Direct beam solar rad incident on walls and road in urban canyon 
   private :: incident_diffuse ! Diffuse solar rad incident on walls and road in urban canyon
-  private :: net_solar        ! Solar radiation absorbed by road and both walls in urban canyon
+  private :: net_solar        ! Solar radiation absorbed by road and both walls in urban canyon 
   !-----------------------------------------------------------------------
 
 contains
 
   !-----------------------------------------------------------------------
-  subroutine UrbanAlbedo (num_urbanl, filter_urbanl, &
+  subroutine UrbanAlbedo (bounds, num_urbanl, filter_urbanl, &
        num_urbanc, filter_urbanc, num_urbanp, filter_urbanp, &
-       urbanparams_vars, solarabs_vars, surfalb_vars)
+       urbanparams_vars, solarabs_vars, surfalb_vars) 
     !
-    ! !DESCRIPTION:
+    ! !DESCRIPTION: 
     ! Determine urban landunit component albedos
     !
     ! Note that this is called with the "inactive_and_active" version of the filters, because
@@ -47,13 +54,13 @@ contains
     ! only computed over active points.
     !
     ! !USES:
-    !$acc routine seq
+    use shr_orb_mod   , only : shr_orb_decl, shr_orb_cosz
     use elm_varcon    , only : sb
     use column_varcon , only : icol_roof, icol_sunwall, icol_shadewall
     use column_varcon , only : icol_road_perv, icol_road_imperv
     !
     ! !ARGUMENTS:
-    !type(bounds_type)      , intent(in)    :: bounds
+    type(bounds_type)      , intent(in)    :: bounds  
     integer                , intent(in)    :: num_urbanl       ! number of urban landunits in clump
     integer                , intent(in)    :: filter_urbanl(:) ! urban landunit filter
     integer                , intent(in)    :: num_urbanc       ! number of urban columns in clump
@@ -65,60 +72,60 @@ contains
     type(surfalb_type)     , intent(inout) :: surfalb_vars
     !
     ! !LOCAL VARIABLES:
-    integer  :: fl,fp,fc,g,l,p,c,ib                          ! indices
-    integer  :: ic                                           ! 0=unit incoming direct; 1=unit incoming diffuse
-    integer  :: num_solar                                    ! counter
-    real(r8) :: coszen              ! cosine solar zenith angle for next time step (landunit)
-    real(r8) :: zen                 ! solar zenith angle (radians)
-    real(r8) :: sdir                ! direct beam solar radiation on horizontal surface
-    real(r8) :: sdif                ! diffuse solar radiation on horizontal surface
-    real(r8) :: sdir_road           ! direct beam solar radiation incident on road
-    real(r8) :: sdif_road           ! diffuse solar radiation incident on road
-    real(r8) :: sdir_sunwall        ! direct beam solar radiation (per unit wall area) incident on sunlit wall per unit incident flux
-    real(r8) :: sdif_sunwall        ! diffuse solar radiation (per unit wall area) incident on sunlit wall per unit incident flux
-    real(r8) :: sdir_shadewall      ! direct beam solar radiation (per unit wall area) incident on shaded wall per unit incident flux
-    real(r8) :: sdif_shadewall      ! diffuse solar radiation (per unit wall area) incident on shaded wall per unit incident flux
-    real(r8) :: albsnd_roof         ! snow albedo for roof (direct)
-    real(r8) :: albsni_roof         ! snow albedo for roof (diffuse)
-    real(r8) :: albsnd_improad      ! snow albedo for impervious road (direct)
-    real(r8) :: albsni_improad      ! snow albedo for impervious road (diffuse)
-    real(r8) :: albsnd_perroad      ! snow albedo for pervious road (direct)
-    real(r8) :: albsni_perroad      ! snow albedo for pervious road (diffuse)
-    real(r8) :: alb_roof_dir_s      ! direct roof albedo with snow effects
-    real(r8) :: alb_roof_dif_s      ! diffuse roof albedo with snow effects
-    real(r8) :: alb_improad_dir_s   ! direct impervious road albedo with snow effects
-    real(r8) :: alb_perroad_dir_s   ! direct pervious road albedo with snow effects
-    real(r8) :: alb_improad_dif_s   ! diffuse impervious road albedo with snow effects
-    real(r8) :: alb_perroad_dif_s   ! diffuse pervious road albedo with snow effects
-    real(r8) :: sref_roof_dir      ! direct  solar reflected by roof per unit ground area per unit incident flux
-    real(r8) :: sref_roof_dif      ! diffuse solar reflected by roof per unit ground area per unit incident flux
-    real(r8) :: sref_sunwall_dir   ! direct  solar reflected by sunwall per unit wall area per unit incident flux
-    real(r8) :: sref_sunwall_dif   ! diffuse solar reflected by sunwall per unit wall area per unit incident flux
-    real(r8) :: sref_shadewall_dir ! direct  solar reflected by shadewall per unit wall area per unit incident flux
-    real(r8) :: sref_shadewall_dif ! diffuse solar reflected by shadewall per unit wall area per unit incident flux
-    real(r8) :: sref_improad_dir   ! direct  solar reflected by impervious road per unit ground area per unit incident flux
-    real(r8) :: sref_improad_dif   ! diffuse solar reflected by impervious road per unit ground area per unit incident flux
-    real(r8) :: sref_perroad_dir   ! direct  solar reflected by pervious road per unit ground area per unit incident flux
-    real(r8) :: sref_perroad_dif   ! diffuse solar reflected by pervious road per unit ground area per unit incident flux
+    integer  :: fl,fp,fc,g,l,p,c,ib                                  ! indices
+    integer  :: ic                                                   ! 0=unit incoming direct; 1=unit incoming diffuse
+    integer  :: num_solar                                            ! counter
+    real(r8) :: coszen             (bounds%begl:bounds%endl)         ! cosine solar zenith angle for next time step (landunit)
+    real(r8) :: zen                (bounds%begl:bounds%endl)         ! solar zenith angle (radians)
+    real(r8) :: sdir               (bounds%begl:bounds%endl, numrad) ! direct beam solar radiation on horizontal surface
+    real(r8) :: sdif               (bounds%begl:bounds%endl, numrad) ! diffuse solar radiation on horizontal surface
+    real(r8) :: sdir_road          (bounds%begl:bounds%endl, numrad) ! direct beam solar radiation incident on road
+    real(r8) :: sdif_road          (bounds%begl:bounds%endl, numrad) ! diffuse solar radiation incident on road
+    real(r8) :: sdir_sunwall       (bounds%begl:bounds%endl, numrad) ! direct beam solar radiation (per unit wall area) incident on sunlit wall per unit incident flux
+    real(r8) :: sdif_sunwall       (bounds%begl:bounds%endl, numrad) ! diffuse solar radiation (per unit wall area) incident on sunlit wall per unit incident flux
+    real(r8) :: sdir_shadewall     (bounds%begl:bounds%endl, numrad) ! direct beam solar radiation (per unit wall area) incident on shaded wall per unit incident flux
+    real(r8) :: sdif_shadewall     (bounds%begl:bounds%endl, numrad) ! diffuse solar radiation (per unit wall area) incident on shaded wall per unit incident flux
+    real(r8) :: albsnd_roof        (bounds%begl:bounds%endl, numrad) ! snow albedo for roof (direct)
+    real(r8) :: albsni_roof        (bounds%begl:bounds%endl, numrad) ! snow albedo for roof (diffuse)
+    real(r8) :: albsnd_improad     (bounds%begl:bounds%endl, numrad) ! snow albedo for impervious road (direct)
+    real(r8) :: albsni_improad     (bounds%begl:bounds%endl, numrad) ! snow albedo for impervious road (diffuse)
+    real(r8) :: albsnd_perroad     (bounds%begl:bounds%endl, numrad) ! snow albedo for pervious road (direct)
+    real(r8) :: albsni_perroad     (bounds%begl:bounds%endl, numrad) ! snow albedo for pervious road (diffuse)
+    real(r8) :: alb_roof_dir_s     (bounds%begl:bounds%endl, numrad) ! direct roof albedo with snow effects
+    real(r8) :: alb_roof_dif_s     (bounds%begl:bounds%endl, numrad) ! diffuse roof albedo with snow effects
+    real(r8) :: alb_improad_dir_s  (bounds%begl:bounds%endl, numrad) ! direct impervious road albedo with snow effects
+    real(r8) :: alb_perroad_dir_s  (bounds%begl:bounds%endl, numrad) ! direct pervious road albedo with snow effects
+    real(r8) :: alb_improad_dif_s  (bounds%begl:bounds%endl, numrad) ! diffuse impervious road albedo with snow effects
+    real(r8) :: alb_perroad_dif_s  (bounds%begl:bounds%endl, numrad) ! diffuse pervious road albedo with snow effects
+    real(r8) :: sref_roof_dir      (bounds%begl:bounds%endl, numrad) ! direct  solar reflected by roof per unit ground area per unit incident flux   
+    real(r8) :: sref_roof_dif      (bounds%begl:bounds%endl, numrad) ! diffuse solar reflected by roof per unit ground area per unit incident flux   
+    real(r8) :: sref_sunwall_dir   (bounds%begl:bounds%endl, numrad) ! direct  solar reflected by sunwall per unit wall area per unit incident flux  
+    real(r8) :: sref_sunwall_dif   (bounds%begl:bounds%endl, numrad) ! diffuse solar reflected by sunwall per unit wall area per unit incident flux  
+    real(r8) :: sref_shadewall_dir (bounds%begl:bounds%endl, numrad) ! direct  solar reflected by shadewall per unit wall area per unit incident flux  
+    real(r8) :: sref_shadewall_dif (bounds%begl:bounds%endl, numrad) ! diffuse solar reflected by shadewall per unit wall area per unit incident flux  
+    real(r8) :: sref_improad_dir   (bounds%begl:bounds%endl, numrad) ! direct  solar reflected by impervious road per unit ground area per unit incident flux   
+    real(r8) :: sref_improad_dif   (bounds%begl:bounds%endl, numrad) ! diffuse solar reflected by impervious road per unit ground area per unit incident flux   
+    real(r8) :: sref_perroad_dir   (bounds%begl:bounds%endl, numrad) ! direct  solar reflected by pervious road per unit ground area per unit incident flux   
+    real(r8) :: sref_perroad_dif   (bounds%begl:bounds%endl, numrad) ! diffuse solar reflected by pervious road per unit ground area per unit incident flux   
     !-----------------------------------------------------------------------
 
-    associate(                                           &
-         ctype              => col_pp%itype            , & ! Input:  [integer (:)    ]  column type
-         coli               => lun_pp%coli             , & ! Input:  [integer (:)    ]  beginning column index for landunit
-         canyon_hwr         => lun_pp%canyon_hwr       , & ! Input:  [real(r8) (:)   ]  ratio of building height to street width
-         wtroad_perv        => lun_pp%wtroad_perv      , & ! Input:  [real(r8) (:)   ]  weight of pervious road wrt total road
-
-         frac_sno           => col_ws%frac_sno         , & ! Input:  [real(r8) (:)   ]  fraction of ground covered by snow (0 to 1)
-
-         alb_roof_dir       => urbanparams_vars%alb_roof_dir        , & ! Output: [real(r8) (:,:) ]  direct roof albedo
-         alb_roof_dif       => urbanparams_vars%alb_roof_dif        , & ! Output: [real(r8) (:,:) ]  diffuse roof albedo
-         alb_improad_dir    => urbanparams_vars%alb_improad_dir     , & ! Output: [real(r8) (:,:) ]  direct impervious road albedo
-         alb_improad_dif    => urbanparams_vars%alb_improad_dif     , & ! Output: [real(r8) (:,:) ]  diffuse imprevious road albedo
-         alb_perroad_dir    => urbanparams_vars%alb_perroad_dir     , & ! Output: [real(r8) (:,:) ]  direct pervious road albedo
-         alb_perroad_dif    => urbanparams_vars%alb_perroad_dif     , & ! Output: [real(r8) (:,:) ]  diffuse pervious road albedo
-         alb_wall_dir       => urbanparams_vars%alb_wall_dir        , & ! Output: [real(r8) (:,:) ]  direct wall albedo
-         alb_wall_dif       => urbanparams_vars%alb_wall_dif        , & ! Output: [real(r8) (:,:) ]  diffuse wall albedo
-
+    associate(                                                        &
+         ctype              => col_pp%itype                            , & ! Input:  [integer (:)    ]  column type                                        
+         coli               => lun_pp%coli                             , & ! Input:  [integer (:)    ]  beginning column index for landunit                
+         canyon_hwr         => lun_pp%canyon_hwr                       , & ! Input:  [real(r8) (:)   ]  ratio of building height to street width          
+         wtroad_perv        => lun_pp%wtroad_perv                      , & ! Input:  [real(r8) (:)   ]  weight of pervious road wrt total road            
+         
+         frac_sno           => col_ws%frac_sno         , & ! Input:  [real(r8) (:)   ]  fraction of ground covered by snow (0 to 1)       
+         
+         alb_roof_dir       => urbanparams_vars%alb_roof_dir        , & ! Output: [real(r8) (:,:) ]  direct roof albedo                              
+         alb_roof_dif       => urbanparams_vars%alb_roof_dif        , & ! Output: [real(r8) (:,:) ]  diffuse roof albedo                             
+         alb_improad_dir    => urbanparams_vars%alb_improad_dir     , & ! Output: [real(r8) (:,:) ]  direct impervious road albedo                   
+         alb_improad_dif    => urbanparams_vars%alb_improad_dif     , & ! Output: [real(r8) (:,:) ]  diffuse imprevious road albedo                  
+         alb_perroad_dir    => urbanparams_vars%alb_perroad_dir     , & ! Output: [real(r8) (:,:) ]  direct pervious road albedo                     
+         alb_perroad_dif    => urbanparams_vars%alb_perroad_dif     , & ! Output: [real(r8) (:,:) ]  diffuse pervious road albedo                    
+         alb_wall_dir       => urbanparams_vars%alb_wall_dir        , & ! Output: [real(r8) (:,:) ]  direct wall albedo                              
+         alb_wall_dif       => urbanparams_vars%alb_wall_dif        , & ! Output: [real(r8) (:,:) ]  diffuse wall albedo                             
+        
          sabs_roof_dir      => solarabs_vars%sabs_roof_dir_lun      , & ! Output: [real(r8) (:,:) ]  direct  solar absorbed  by roof per unit ground area per unit incident flux
          sabs_roof_dif      => solarabs_vars%sabs_roof_dif_lun      , & ! Output: [real(r8) (:,:) ]  diffuse solar absorbed  by roof per unit ground area per unit incident flux
          sabs_sunwall_dir   => solarabs_vars%sabs_sunwall_dir_lun   , & ! Output: [real(r8) (:,:) ]  direct  solar absorbed  by sunwall per unit wall area per unit incident flux
@@ -129,7 +136,7 @@ contains
          sabs_improad_dif   => solarabs_vars%sabs_improad_dif_lun   , & ! Output: [real(r8) (:,:) ]  diffuse solar absorbed  by impervious road per unit ground area per unit incident flux
          sabs_perroad_dir   => solarabs_vars%sabs_perroad_dir_lun   , & ! Output: [real(r8) (:,:) ]  direct  solar absorbed  by pervious road per unit ground area per unit incident flux
          sabs_perroad_dif   => solarabs_vars%sabs_perroad_dif_lun   , & ! Output: [real(r8) (:,:) ]  diffuse solar absorbed  by pervious road per unit ground area per unit incident flux
-
+         
          fabd               => surfalb_vars%fabd_patch              , & ! Output:  [real(r8) (:,:) ]  flux absorbed by canopy per unit direct flux
          fabd_sun           => surfalb_vars%fabd_sun_patch          , & ! Output:  [real(r8) (:,:) ]  flux absorbed by sunlit canopy per unit direct flux
          fabd_sha           => surfalb_vars%fabd_sha_patch          , & ! Output:  [real(r8) (:,:) ]  flux absorbed by shaded canopy per unit direct flux
@@ -139,27 +146,29 @@ contains
          ftdd               => surfalb_vars%ftdd_patch              , & ! Output:  [real(r8) (:,:) ]  down direct flux below canopy per unit direct flux
          ftid               => surfalb_vars%ftid_patch              , & ! Output:  [real(r8) (:,:) ]  down diffuse flux below canopy per unit direct flux
          ftii               => surfalb_vars%ftii_patch              , & ! Output:  [real(r8) (:,:) ]  down diffuse flux below canopy per unit diffuse flux
-         albgrd             => surfalb_vars%albgrd_col              , & ! Output: [real(r8) (:,:) ]  urban col ground albedo (direct)
+         albgrd             => surfalb_vars%albgrd_col              , & ! Output: [real(r8) (:,:) ]  urban col ground albedo (direct) 
          albgri             => surfalb_vars%albgri_col              , & ! Output: [real(r8) (:,:) ]  urban col ground albedo (diffuse)
-         albd               => surfalb_vars%albd_patch              , & ! Output  [real(r8) (:,:) ]  urban pft surface albedo (direct)
-         albi               => surfalb_vars%albi_patch           & ! Output: [real(r8) (:,:) ]  urban pft surface albedo (diffuse)
-
+         albd               => surfalb_vars%albd_patch              , & ! Output  [real(r8) (:,:) ]  urban pft surface albedo (direct)                         
+         albi               => surfalb_vars%albi_patch              , & ! Output: [real(r8) (:,:) ]  urban pft surface albedo (diffuse)                        
+         
+         begl               => bounds%begl                          , &
+         endl               => bounds%endl                            &
          )
 
       ! ----------------------------------------------------------------------------
-      ! Solar declination and cosine solar zenith angle and zenith angle for
+      ! Solar declination and cosine solar zenith angle and zenith angle for 
       ! next time step
       ! ----------------------------------------------------------------------------
-
-      ! do fl = 1,num_urbanl
-      !    l = filter_urbanl(fl)
-      !    g = lun_pp%gridcell(l)
-      !    coszen(l) = surfalb_vars%coszen_col(coli(l)) ! Assumes coszen for each column are the same
-      !    zen(l)    = acos(coszen(l))
-      ! end do
+      
+      do fl = 1,num_urbanl
+         l = filter_urbanl(fl)
+         g = lun_pp%gridcell(l)
+         coszen(l) = surfalb_vars%coszen_col(coli(l))  ! Assumes coszen for each column are the same
+         zen(l)    = acos(coszen(l))
+      end do
 
        ! Initialize output because solar radiation only done if coszen > 0
-       ! output is all global variables
+
       do ib = 1, numrad
          do fc = 1,num_urbanc
             c = filter_urbanc(fc)
@@ -167,21 +176,19 @@ contains
             albgri(c,ib) = 0._r8
          end do
 
-         do fp = 1,num_urbanp
+         do fp = 1,num_urbanp  
             p = filter_urbanp(fp)
             l = veg_pp%landunit(p)
             c = veg_pp%column(p)
-            coszen = surfalb_vars%coszen_col(coli(l))
 
             ! Initialize direct and diffuse albedo such that if the Sun is below
             ! the horizon, p2g scaling returns an albedo of 1.0.
-
             if (col_pp%itype(c) == icol_sunwall) then
-               albd(p,ib) = 1._r8 / (3.0_r8 * canyon_hwr(l))
-               albi(p,ib) = 1._r8 / (3.0_r8 * canyon_hwr(l))
+               albd(p,ib) = 1._r8 / (3.0_r8 * lun_pp%canyon_hwr(l))
+               albi(p,ib) = 1._r8 / (3.0_r8 * lun_pp%canyon_hwr(l))
             else if (col_pp%itype(c) == icol_shadewall) then
-               albd(p,ib) = 1._r8 / (3.0_r8 * canyon_hwr(l))
-               albi(p,ib) = 1._r8 / (3.0_r8 * canyon_hwr(l))
+               albd(p,ib) = 1._r8 / (3.0_r8 * lun_pp%canyon_hwr(l))
+               albi(p,ib) = 1._r8 / (3.0_r8 * lun_pp%canyon_hwr(l))
             else if (col_pp%itype(c) == icol_road_perv .or. col_pp%itype(c) == icol_road_imperv) then
                albd(p,ib) = 1._r8 / (3.0_r8)
                albi(p,ib) = 1._r8 / (3.0_r8)
@@ -196,13 +203,13 @@ contains
             fabi(p,ib)     = 0._r8
             fabi_sun(p,ib) = 0._r8
             fabi_sha(p,ib) = 0._r8
-            if (coszen > 0._r8) then
+            if (coszen(l) > 0._r8) then
                ftdd(p,ib)  = 1._r8
             else
                ftdd(p,ib)  = 0._r8
             end if
             ftid(p,ib)     = 0._r8
-            if (coszen > 0._r8) then
+            if (coszen(l) > 0._r8) then
                ftii(p,ib)  = 1._r8
             else
                ftii(p,ib)  = 0._r8
@@ -213,16 +220,16 @@ contains
       ! ----------------------------------------------------------------------------
       ! Urban Code
       ! ----------------------------------------------------------------------------
+
       num_solar = 0
       do fl = 1,num_urbanl
          l = filter_urbanl(fl)
-         if (surfalb_vars%coszen_col(coli(l)) > 0._r8) num_solar = num_solar + 1
+         if (coszen(l) > 0._r8) num_solar = num_solar + 1
       end do
 
       do ib = 1,numrad
          do fl = 1,num_urbanl
             l = filter_urbanl(fl)
-
             sabs_roof_dir(l,ib)      = 0._r8
             sabs_roof_dif(l,ib)      = 0._r8
             sabs_sunwall_dir(l,ib)   = 0._r8
@@ -233,13 +240,34 @@ contains
             sabs_improad_dif(l,ib)   = 0._r8
             sabs_perroad_dir(l,ib)   = 0._r8
             sabs_perroad_dif(l,ib)   = 0._r8
-
-
+            sref_roof_dir(l,ib)      = 1._r8
+            sref_roof_dif(l,ib)      = 1._r8
+            sref_sunwall_dir(l,ib)   = 1._r8
+            sref_sunwall_dif(l,ib)   = 1._r8
+            sref_shadewall_dir(l,ib) = 1._r8
+            sref_shadewall_dif(l,ib) = 1._r8
+            sref_improad_dir(l,ib)   = 1._r8
+            sref_improad_dif(l,ib)   = 1._r8
+            sref_perroad_dir(l,ib)   = 1._r8
+            sref_perroad_dif(l,ib)   = 1._r8
+
+            ! Initialize direct and diffuse albedos such that if the Sun is below
+            ! the horizon, p2g scaling returns an albedo of 1.0.
+            sref_sunwall_dir(l,ib)   = 1._r8 / (3.0_r8 * lun_pp%canyon_hwr(l))
+            sref_sunwall_dif(l,ib)   = 1._r8 / (3.0_r8 * lun_pp%canyon_hwr(l))
+            sref_shadewall_dir(l,ib) = 1._r8 / (3.0_r8 * lun_pp%canyon_hwr(l))
+            sref_shadewall_dif(l,ib) = 1._r8 / (3.0_r8 * lun_pp%canyon_hwr(l))
+            sref_improad_dir(l,ib)   = 1._r8 / (3.0_r8)
+            sref_improad_dif(l,ib)   = 1._r8 / (3.0_r8)
+            sref_perroad_dir(l,ib)   = 1._r8 / (3.0_r8)
+            sref_perroad_dif(l,ib)   = 1._r8 / (3.0_r8)
+            sref_roof_dir(l,ib)      = 1._r8
+            sref_roof_dif(l,ib)      = 1._r8
          end do
       end do
 
       ! ----------------------------------------------------------------------------
-      ! Only do the rest if all coszen are positive
+      ! Only do the rest if all coszen are positive 
       ! ----------------------------------------------------------------------------
 
       if (num_solar > 0)then
@@ -249,166 +277,151 @@ contains
          do ib = 1,numrad
             do fl = 1,num_urbanl
                l = filter_urbanl(fl)
-               coszen = surfalb_vars%coszen_col(coli(l)) ! Assumes coszen for each column are the same
-               zen    = acos(coszen)
-               sdir = 1._r8
-               sdif = 1._r8
-
-               ! Initialize direct and diffuse albedos such that if the Sun is below
-               ! the horizon, p2g scaling returns an albedo of 1.0.
-
-               sref_sunwall_dir   = 1._r8 / (3.0_r8 * canyon_hwr(l))
-               sref_sunwall_dif   = 1._r8 / (3.0_r8 * canyon_hwr(l))
-               sref_shadewall_dir = 1._r8 / (3.0_r8 * canyon_hwr(l))
-               sref_shadewall_dif = 1._r8 / (3.0_r8 * canyon_hwr(l))
-               sref_improad_dir   = 1._r8 / (3.0_r8)
-               sref_improad_dif   = 1._r8 / (3.0_r8)
-               sref_perroad_dir   = 1._r8 / (3.0_r8)
-               sref_perroad_dif   = 1._r8 / (3.0_r8)
-               sref_roof_dir      = 1._r8
-               sref_roof_dif      = 1._r8
-
-               ! Incident direct beam radiation for
-               ! (a) roof and (b) road and both walls in urban canyon
-
-               !if (coszen > 0._r8) then
-               !if (num_urbanl > 0) then !!NOTE: Urban albedo is only called if num_urbanl >0??
-                  ! Incident direct beam radiation for
-                  ! (a) roof and (b) road and both walls in urban canyon
-
-                  call incident_direct ( &
-                       canyon_hwr(l), &
-                       coszen    , &
-                       zen       , &
-                       sdir         , &
-                       sdir_road    , &
-                       sdir_sunwall , &
-                       sdir_shadewall  )
-
-                 ! Incident diffuse radiation for
-                 ! (a) roof and (b) road and both walls in urban canyon.
-                 call incident_diffuse (  l, &
-                      canyon_hwr(l)  , &
-                      sdif           , &
-                      sdif_road      , &
-                      sdif_sunwall   , &
-                      sdif_shadewall , &
-                      urbanparams_vars)
-
-                ! Get snow albedos for roof and impervious and pervious road
-                  ic = 0
-                  !NOTE: Get rid of SnowAlbedo routine and merge
-                  !! with below?
-                  call SnowAlbedo(l, ib,&
-                      coszen, &
-                      ic, &
-                      albsnd_roof    , &
-                      albsnd_improad , &
-                      albsnd_perroad  )
-
-                  ic = 1
-                  call SnowAlbedo( l,ib, &
-                      coszen      , &
-                      ic             , &
-                      albsni_roof    , &
-                      albsni_improad , &
-                      albsni_perroad  )
-
-               !end if
-
-               ! Combine snow-free and snow albedos
-               do c = lun_pp%coli(l), lun_pp%colf(l)
-                 if (ctype(c) == icol_roof) then
-                    alb_roof_dir_s = alb_roof_dir(l,ib)*(1._r8-frac_sno(c))  &
-                         + albsnd_roof * frac_sno(c)
-                    alb_roof_dif_s = alb_roof_dif(l,ib)*(1._r8-frac_sno(c))  &
-                         + albsni_roof * frac_sno(c)
-
-                 else if (ctype(c) == icol_road_imperv) then
-                    alb_improad_dir_s = alb_improad_dir(l,ib)*(1._r8-frac_sno(c))  &
-                         + albsnd_improad * frac_sno(c)
-                    alb_improad_dif_s = alb_improad_dif(l,ib)*(1._r8-frac_sno(c))  &
-                         + albsni_improad * frac_sno(c)
-
-                 else if (ctype(c) == icol_road_perv) then
-                    alb_perroad_dir_s = alb_perroad_dir(l,ib)*(1._r8-frac_sno(c))  &
-                         + albsnd_perroad * frac_sno(c)
-                    alb_perroad_dif_s = alb_perroad_dif(l,ib)*(1._r8-frac_sno(c))  &
-                         + albsni_perroad * frac_sno(c)
-                 end if
-               end do !end of column loop
-
-
-               ! Reflected and absorbed solar radiation per unit incident radiation
-               ! for road and both walls in urban canyon allowing for multiple reflection
-               ! Reflected and absorbed solar radiation per unit incident radiation for roof
-
-               !if (num_urbanl > 0) then
-                  call net_solar (l, ib, &
-                       coszen             , &
-                       canyon_hwr         (l), &
-                       wtroad_perv        (l), &
-                       sdir                  , &
-                       sdif                  , &
-                       alb_improad_dir_s  , &
-                       alb_perroad_dir_s  , &
-                       alb_wall_dir       (l, ib), &
-                       alb_roof_dir_s     , &
-                       alb_improad_dif_s  , &
-                       alb_perroad_dif_s  , &
-                       alb_wall_dif       (l, ib), &
-                       alb_roof_dif_s     , &
-                       sdir_road          , &
-                       sdir_sunwall       , &
-                       sdir_shadewall     , &
-                       sdif_road          , &
-                       sdif_sunwall       , &
-                       sdif_shadewall     , &
-                       sref_improad_dir   , &
-                       sref_perroad_dir   , &
-                       sref_sunwall_dir   , &
-                       sref_shadewall_dir , &
-                       sref_roof_dir      , &
-                       sref_improad_dif   , &
-                       sref_perroad_dif   , &
-                       sref_sunwall_dif   , &
-                       sref_shadewall_dif , &
-                       sref_roof_dif      , &
-                       urbanparams_vars, solarabs_vars)
-               !end if
-
-               do c = lun_pp%coli(l), lun_pp%colf(l)
-                  if (ctype(c) == icol_roof) then
-                     albgrd(c,ib) = sref_roof_dir
-                     albgri(c,ib) = sref_roof_dif
-                  else if (ctype(c) == icol_sunwall) then
-                     albgrd(c,ib) = sref_sunwall_dir
-                     albgri(c,ib) = sref_sunwall_dif
-                  else if (ctype(c) == icol_shadewall) then
-                     albgrd(c,ib) = sref_shadewall_dir
-                     albgri(c,ib) = sref_shadewall_dif
-                  else if (ctype(c) == icol_road_perv) then
-                     albgrd(c,ib) = sref_perroad_dir
-                     albgri(c,ib) = sref_perroad_dif
-                  else if (ctype(c) == icol_road_imperv) then
-                     albgrd(c,ib) = sref_improad_dir
-                     albgri(c,ib) = sref_improad_dif
-                  endif
-               end do
-            end do !loop over fl
-         end do !loop over radiation band
+               sdir(l,ib) = 1._r8
+               sdif(l,ib) = 1._r8
+            end do
+         end do
 
+         ! Incident direct beam radiation for 
+         ! (a) roof and (b) road and both walls in urban canyon
+
+         if (num_urbanl > 0) then
+            call incident_direct (bounds, &
+                 num_urbanl, filter_urbanl, &
+                 canyon_hwr(begl:endl), &
+                 coszen(begl:endl), &
+                 zen(begl:endl), &
+                 sdir(begl:endl, :), &
+                 sdir_road(begl:endl, :), &
+                 sdir_sunwall(begl:endl, :), &
+                 sdir_shadewall(begl:endl, :))
+         end if
 
+         ! Incident diffuse radiation for 
+         ! (a) roof and (b) road and both walls in urban canyon.
+
+         if (num_urbanl > 0) then
+            call incident_diffuse (bounds, &
+                 num_urbanl, filter_urbanl, &
+                 canyon_hwr(begl:endl), &
+                 sdif(begl:endl, :), &
+                 sdif_road(begl:endl, :), &
+                 sdif_sunwall(begl:endl, :), &
+                 sdif_shadewall(begl:endl, :), &
+                 urbanparams_vars)
+         end if
 
+         ! Get snow albedos for roof and impervious and pervious road
+         if (num_urbanl > 0) then
+            ic = 0
+            call SnowAlbedo(bounds, &
+                 num_urbanc, filter_urbanc, &
+                 coszen(begl:endl), &
+                 ic, &
+                 albsnd_roof(begl:endl, :), &
+                 albsnd_improad(begl:endl, :), &
+                 albsnd_perroad(begl:endl, :) )
+
+            ic = 1
+            call SnowAlbedo(bounds, &
+                 num_urbanc, filter_urbanc, &
+                 coszen(begl:endl), &
+                 ic, &
+                 albsni_roof(begl:endl, :), &
+                 albsni_improad(begl:endl, :), &
+                 albsni_perroad(begl:endl, :) )
+         end if
+
+         ! Combine snow-free and snow albedos
+         do ib = 1,numrad
+            do fc = 1,num_urbanc
+               c = filter_urbanc(fc)
+               l = col_pp%landunit(c)
+               if (ctype(c) == icol_roof) then    
+                  alb_roof_dir_s(l,ib) = alb_roof_dir(l,ib)*(1._r8-frac_sno(c))  &
+                       + albsnd_roof(l,ib)*frac_sno(c)
+                  alb_roof_dif_s(l,ib) = alb_roof_dif(l,ib)*(1._r8-frac_sno(c))  &
+                       + albsni_roof(l,ib)*frac_sno(c)
+               else if (ctype(c) == icol_road_imperv) then    
+                  alb_improad_dir_s(l,ib) = alb_improad_dir(l,ib)*(1._r8-frac_sno(c))  &
+                       + albsnd_improad(l,ib)*frac_sno(c)
+                  alb_improad_dif_s(l,ib) = alb_improad_dif(l,ib)*(1._r8-frac_sno(c))  &
+                       + albsni_improad(l,ib)*frac_sno(c)
+               else if (ctype(c) == icol_road_perv) then    
+                  alb_perroad_dir_s(l,ib) = alb_perroad_dir(l,ib)*(1._r8-frac_sno(c))  &
+                       + albsnd_perroad(l,ib)*frac_sno(c)
+                  alb_perroad_dif_s(l,ib) = alb_perroad_dif(l,ib)*(1._r8-frac_sno(c))  &
+                       + albsni_perroad(l,ib)*frac_sno(c)
+               end if
+            end do
+         end do
+
+         ! Reflected and absorbed solar radiation per unit incident radiation 
+         ! for road and both walls in urban canyon allowing for multiple reflection
+         ! Reflected and absorbed solar radiation per unit incident radiation for roof
+
+         if (num_urbanl > 0) then
+            call net_solar (bounds, &
+                 num_urbanl, filter_urbanl, &
+                 coszen             (begl:endl), &
+                 canyon_hwr         (begl:endl), &
+                 wtroad_perv        (begl:endl), &
+                 sdir               (begl:endl, :), &
+                 sdif               (begl:endl, :), &
+                 alb_improad_dir_s  (begl:endl, :), &
+                 alb_perroad_dir_s  (begl:endl, :), &
+                 alb_wall_dir       (begl:endl, :), &
+                 alb_roof_dir_s     (begl:endl, :), &
+                 alb_improad_dif_s  (begl:endl, :), &
+                 alb_perroad_dif_s  (begl:endl, :), &
+                 alb_wall_dif       (begl:endl, :), &
+                 alb_roof_dif_s     (begl:endl, :), &
+                 sdir_road          (begl:endl, :), &
+                 sdir_sunwall       (begl:endl, :), &
+                 sdir_shadewall     (begl:endl, :),  &
+                 sdif_road          (begl:endl, :), &
+                 sdif_sunwall       (begl:endl, :), &
+                 sdif_shadewall     (begl:endl, :),  &
+                 sref_improad_dir   (begl:endl, :), &
+                 sref_perroad_dir   (begl:endl, :), &
+                 sref_sunwall_dir   (begl:endl, :), &
+                 sref_shadewall_dir (begl:endl, :), &
+                 sref_roof_dir      (begl:endl, :), &
+                 sref_improad_dif   (begl:endl, :), &
+                 sref_perroad_dif   (begl:endl, :), &
+                 sref_sunwall_dif   (begl:endl, :), &
+                 sref_shadewall_dif (begl:endl, :), &
+                 sref_roof_dif      (begl:endl, :), &
+                 urbanparams_vars, solarabs_vars)
+         end if
 
          ! ----------------------------------------------------------------------------
-         ! Map urban output to surfalb_vars components
+         ! Map urban output to surfalb_vars components 
          ! ----------------------------------------------------------------------------
 
          !  Set albgrd and albgri (ground albedos) and albd and albi (surface albedos)
 
          do ib = 1,numrad
-
+            do fc = 1,num_urbanc
+               c = filter_urbanc(fc)
+               l = col_pp%landunit(c)
+               if (ctype(c) == icol_roof) then    
+                  albgrd(c,ib) = sref_roof_dir(l,ib) 
+                  albgri(c,ib) = sref_roof_dif(l,ib) 
+               else if (ctype(c) == icol_sunwall) then   
+                  albgrd(c,ib) = sref_sunwall_dir(l,ib)
+                  albgri(c,ib) = sref_sunwall_dif(l,ib)
+               else if (ctype(c) == icol_shadewall) then 
+                  albgrd(c,ib) = sref_shadewall_dir(l,ib)
+                  albgri(c,ib) = sref_shadewall_dif(l,ib)
+               else if (ctype(c) == icol_road_perv) then
+                  albgrd(c,ib) = sref_perroad_dir(l,ib)
+                  albgri(c,ib) = sref_perroad_dif(l,ib)
+               else if (ctype(c) == icol_road_imperv) then
+                  albgrd(c,ib) = sref_improad_dir(l,ib)
+                  albgri(c,ib) = sref_improad_dif(l,ib)
+               endif
+            end do
             do fp = 1,num_urbanp
                p = filter_urbanp(fp)
                c = veg_pp%column(p)
@@ -423,62 +436,68 @@ contains
   end subroutine UrbanAlbedo
 
   !-----------------------------------------------------------------------
-  subroutine SnowAlbedo (l , ib, coszen, ind , &
+  subroutine SnowAlbedo (bounds          , &
+       num_urbanc, filter_urbanc, coszen, ind , &
        albsn_roof, albsn_improad, albsn_perroad )
     !
     ! !DESCRIPTION:
     ! Determine urban snow albedos
-    ! ! !USES:
-    !$acc routine seq
+    !
+    ! !USES:
     use column_varcon, only : icol_roof, icol_road_perv, icol_road_imperv
     !
     ! !ARGUMENTS:
-    integer , value, intent(in) :: l, ib     ! landunit index
-    real(r8), value, intent(in) :: coszen    ! cosine solar zenith angle [landunit]
-    integer , value, intent(in) :: ind       ! 0=direct beam, 1=diffuse radiation
-    real(r8),  intent(out):: albsn_roof      ! roof snow albedo by waveband [landunit, numrad]
-    real(r8),  intent(out):: albsn_improad   ! impervious road snow albedo by waveband [landunit, numrad]
-    real(r8),  intent(out):: albsn_perroad   ! pervious road snow albedo by waveband [landunit, numrad]
+    type(bounds_type), intent(in) :: bounds                     
+    integer , intent(in) :: num_urbanc                          ! number of urban columns in clump
+    integer , intent(in) :: filter_urbanc(:)                    ! urban column filter
+    integer , intent(in) :: ind                                 ! 0=direct beam, 1=diffuse radiation
+    real(r8), intent(in) :: coszen        ( bounds%begl: )      ! cosine solar zenith angle [landunit]
+    real(r8), intent(out):: albsn_roof    ( bounds%begl: , 1: ) ! roof snow albedo by waveband [landunit, numrad]
+    real(r8), intent(out):: albsn_improad ( bounds%begl: , 1: ) ! impervious road snow albedo by waveband [landunit, numrad]
+    real(r8), intent(out):: albsn_perroad ( bounds%begl: , 1: ) ! pervious road snow albedo by waveband [landunit, numrad]
     !
     ! !LOCAL VARIABLES:
-    integer  :: fc,c ! indices
-    integer  :: itype
+    integer  :: fc,c,l              ! indices
     !
-    ! These values are derived from Marshall (1989) assuming soot content of 1.5e-5
+    ! These values are derived from Marshall (1989) assuming soot content of 1.5e-5 
     ! (three times what LSM uses globally). Note that snow age effects are ignored here.
     real(r8), parameter :: snal0 = 0.66_r8 ! vis albedo of urban snow
     real(r8), parameter :: snal1 = 0.56_r8 ! nir albedo of urban snow
-    real(r8) :: snal
     !-----------------------------------------------------------------------
 
     ! this code assumes that numrad = 2 , with the following
     ! index values: 1 = visible, 2 = NIR
-    if (ib == 1) then
-      snal = snal0
-    else
-      snal = snal1
-    end if
-    associate(   &
-         h2osno =>  col_ws%h2osno & ! Input:  [real(r8) (:) ]  snow water (mm H2O)
-         )
 
-      do c = lun_pp%coli(l), lun_pp%colf(l)
+    ! Enforce expected array sizes
 
-         if (coszen > 0._r8 .and. h2osno(c) > 0._r8) then
+    associate(                            & 
+         h2osno =>  col_ws%h2osno & ! Input:  [real(r8) (:) ]  snow water (mm H2O)                               
+         )
+      
+      do fc = 1,num_urbanc
+         c = filter_urbanc(fc)
+         l = col_pp%landunit(c)
+         if (coszen(l) > 0._r8 .and. h2osno(c) > 0._r8) then
             if (col_pp%itype(c) == icol_roof) then
-                 albsn_roof = snal
+               albsn_roof(l,1) = snal0
+               albsn_roof(l,2) = snal1
             else if (col_pp%itype(c) == icol_road_imperv) then
-                albsn_improad = snal
+               albsn_improad(l,1) = snal0
+               albsn_improad(l,2) = snal1
             else if (col_pp%itype(c) == icol_road_perv) then
-                albsn_perroad = snal
+               albsn_perroad(l,1) = snal0
+               albsn_perroad(l,2) = snal1
             end if
          else
             if (col_pp%itype(c) == icol_roof) then
-               albsn_roof = 0._r8
+               albsn_roof(l,1) = 0._r8
+               albsn_roof(l,2) = 0._r8
             else if (col_pp%itype(c) == icol_road_imperv) then
-               albsn_improad = 0._r8
+               albsn_improad(l,1) = 0._r8
+               albsn_improad(l,2) = 0._r8
             else if (col_pp%itype(c) == icol_road_perv) then
-               albsn_perroad = 0._r8
+               albsn_perroad(l,1) = 0._r8
+               albsn_perroad(l,2) = 0._r8
             end if
          end if
       end do
@@ -488,10 +507,11 @@ contains
   end subroutine SnowAlbedo
 
   !-----------------------------------------------------------------------
-  subroutine incident_direct ( canyon_hwr, coszen, zen , &
+  subroutine incident_direct (bounds                      ,                    &
+       num_urbanl, filter_urbanl, canyon_hwr, coszen, zen ,                    &
        sdir, sdir_road, sdir_sunwall, sdir_shadewall)
     !
-    ! !DESCRIPTION:
+    ! !DESCRIPTION: 
     ! Direct beam solar radiation incident on walls and road in urban canyon
     !
     !                           Sun
@@ -514,7 +534,7 @@ contains
     ! Conservation check: Total incoming direct beam (sdir) = sdir_road + (sdir_shadewall + sdir_sunwall)*canyon_hwr
     ! Multiplication by canyon_hwr scales wall fluxes (per unit wall area) to per unit ground area
     !
-    ! Source: Masson, V. (2000) A physically-based scheme for the urban energy budget in
+    ! Source: Masson, V. (2000) A physically-based scheme for the urban energy budget in 
     ! atmospheric models. Boundary-Layer Meteorology 94:357-397
     !
     ! This analytical solution from Masson (2000) agrees with the numerical solution to
@@ -522,186 +542,203 @@ contains
     ! and all solar zenith angles from 1 to 90 deg by 1
     !
     ! !USES:
-      !$acc routine seq
     use elm_varcon, only : rpi
     !
     ! !ARGUMENTS:
-    !type(bounds_type), intent(in) :: bounds
-    !integer , intent(in)  :: num_urbanl                          ! number of urban landunits
-    !integer , intent(in)  :: filter_urbanl(:)                    ! urban landunit filter
-    real(r8),value, intent(in)  :: canyon_hwr     ! ratio of building height to street width [landunit]
-    real(r8),value, intent(in)  :: coszen         ! cosine solar zenith angle [landunit]
-    real(r8),value, intent(in)  :: zen            ! solar zenith angle (radians) [landunit]
-    real(r8),value, intent(in)  :: sdir           ! direct beam solar radiation incident on horizontal surface [landunit, numrad]
-    real(r8), intent(out) :: sdir_road      ! direct beam solar radiation incident on road per unit incident flux [landunit, numrad]
-    real(r8), intent(out) :: sdir_sunwall   ! direct beam solar radiation (per unit wall area) incident on sunlit wall per unit incident flux [landunit, numrad]
-    real(r8), intent(out) :: sdir_shadewall ! direct beam solar radiation (per unit wall area) incident on shaded wall per unit incident flux [landunit, numrad]
+    type(bounds_type), intent(in) :: bounds                      
+    integer , intent(in)  :: num_urbanl                          ! number of urban landunits
+    integer , intent(in)  :: filter_urbanl(:)                    ! urban landunit filter
+    real(r8), intent(in)  :: canyon_hwr( bounds%begl: )          ! ratio of building height to street width [landunit]
+    real(r8), intent(in)  :: coszen( bounds%begl: )              ! cosine solar zenith angle [landunit]
+    real(r8), intent(in)  :: zen( bounds%begl: )                 ! solar zenith angle (radians) [landunit]
+    real(r8), intent(in)  :: sdir( bounds%begl: , 1: )           ! direct beam solar radiation incident on horizontal surface [landunit, numrad]
+    real(r8), intent(out) :: sdir_road( bounds%begl: , 1: )      ! direct beam solar radiation incident on road per unit incident flux [landunit, numrad]
+    real(r8), intent(out) :: sdir_sunwall( bounds%begl: , 1: )   ! direct beam solar radiation (per unit wall area) incident on sunlit wall per unit incident flux [landunit, numrad]
+    real(r8), intent(out) :: sdir_shadewall( bounds%begl: , 1: ) ! direct beam solar radiation (per unit wall area) incident on shaded wall per unit incident flux [landunit, numrad]
     !
     ! !LOCAL VARIABLES:
-    !integer  :: fl,l,i,ib                   ! indices
-    logical, parameter  :: numchk = .false. ! true => perform numerical check of analytical solution
-    real(r8) :: theta0                      ! critical canyon orientation for which road is no longer illuminated
-    real(r8) :: tanzen                      ! tan(zenith angle)
-    real(r8) :: swall_projected             ! direct beam solar radiation (per unit ground area) incident on wall
-    real(r8) :: err1                        ! energy conservation error
-    real(r8) :: err2                        ! energy conservation error
-    real(r8) :: err3                        ! energy conservation error
-    real(r8) :: sumr                        ! sum of sroad for each orientation (0 <= theta <= pi/2)
-    real(r8) :: sumw                        ! sum of swall for each orientation (0 <= theta <= pi/2)
-    real(r8) :: num                         ! number of orientations
-    real(r8) :: theta                       ! canyon orientation relative to sun (0 <= theta <= pi/2)
-    real(r8) :: zen0                        ! critical solar zenith angle for which sun begins to illuminate road
+    integer  :: fl,l,i,ib                       ! indices
+    logical  :: numchk = .false.                ! true => perform numerical check of analytical solution
+    real(r8) :: theta0(bounds%begl:bounds%endl) ! critical canyon orientation for which road is no longer illuminated
+    real(r8) :: tanzen(bounds%begl:bounds%endl) ! tan(zenith angle)
+    real(r8) :: swall_projected                 ! direct beam solar radiation (per unit ground area) incident on wall
+    real(r8) :: err1(bounds%begl:bounds%endl)   ! energy conservation error
+    real(r8) :: err2(bounds%begl:bounds%endl)   ! energy conservation error
+    real(r8) :: err3(bounds%begl:bounds%endl)   ! energy conservation error
+    real(r8) :: sumr                            ! sum of sroad for each orientation (0 <= theta <= pi/2)
+    real(r8) :: sumw                            ! sum of swall for each orientation (0 <= theta <= pi/2)
+    real(r8) :: num                             ! number of orientations
+    real(r8) :: theta                           ! canyon orientation relative to sun (0 <= theta <= pi/2)
+    real(r8) :: zen0                            ! critical solar zenith angle for which sun begins to illuminate road
     !-----------------------------------------------------------------------
 
-    ! Enforce expected array sizes
-    !
-    ! do fl = 1,num_urbanl
-    !    l = filter_urbanl(fl)
-    !    if (coszen(l) > 0._r8) then
-    !       theta0(l) = asin(min( (1._r8/(canyon_hwr(l)*tan(max(zen(l),0.000001_r8)))), 1._r8 ))
-    !       tanzen(l) = tan(zen(l))
-    !    end if
-    ! end do
-
-          !l = filter_urbanl(fl)
-      if (coszen > 0._r8) then
-
-         theta0 = asin(min( (1._r8/(canyon_hwr*tan(max(zen,0.000001_r8)))), 1._r8 ))
-         tanzen = tan(zen)
-         sdir_shadewall = 0._r8
-
-         ! incident solar radiation on wall and road integrated over all canyon orientations (0 <= theta <= pi/2)
-
-         sdir_road = sdir *                                    &
-              (2._r8*theta0/rpi - 2./rpi*canyon_hwr*tanzen*(1._r8-cos(theta0)))
-         sdir_sunwall = 2._r8 * sdir * ((1._r8/canyon_hwr)* &
-              (0.5_r8-theta0/rpi) + (1._r8/rpi)*tanzen*(1._r8-cos(theta0)))
-
-         ! conservation check for road and wall. need to use wall fluxes converted to ground area
-
-         swall_projected = ( sdir_shadewall + sdir_sunwall ) * canyon_hwr
-         err1 = sdir - (sdir_road + swall_projected)
-      else
-         sdir_road    = 0._r8
-         sdir_sunwall = 0._r8
-         sdir_shadewall  = 0._r8
-      endif
-
-       ! do fl = 1,num_urbanl
-       !    l = filter_urbanl(fl)
-       !    if (coszen(l) > 0._r8) then
-       !       if (abs(err1(l)) > 0.001_r8) then
-       !          !#py write (iulog,*) 'urban direct beam solar radiation balance error',err1(l)
-       !          !#py write (iulog,*) 'clm model is stopping'
-       !          !#py !#py call endrun(decomp_index=l, clmlevel=namel, msg=errmsg(__FILE__, __LINE__))
-       !       endif
-       !    endif
-       ! end do
+
+    do fl = 1,num_urbanl
+       l = filter_urbanl(fl)
+       if (coszen(l) > 0._r8) then
+          theta0(l) = asin(min( (1._r8/(canyon_hwr(l)*tan(max(zen(l),0.000001_r8)))), 1._r8 ))
+          tanzen(l) = tan(zen(l))
+       end if
+    end do
+
+    do ib = 1,numrad
+
+       do fl = 1,num_urbanl
+          l = filter_urbanl(fl)
+          if (coszen(l) > 0._r8) then
+             sdir_shadewall(l,ib) = 0._r8
+
+             ! incident solar radiation on wall and road integrated over all canyon orientations (0 <= theta <= pi/2)
+
+             sdir_road(l,ib) = sdir(l,ib) *                                    &
+                  (2._r8*theta0(l)/rpi - 2./rpi*canyon_hwr(l)*tanzen(l)*(1._r8-cos(theta0(l))))
+             sdir_sunwall(l,ib) = 2._r8 * sdir(l,ib) * ((1._r8/canyon_hwr(l))* &
+                  (0.5_r8-theta0(l)/rpi) + (1._r8/rpi)*tanzen(l)*(1._r8-cos(theta0(l))))
+
+             ! conservation check for road and wall. need to use wall fluxes converted to ground area
+
+             swall_projected = (sdir_shadewall(l,ib) + sdir_sunwall(l,ib)) * canyon_hwr(l)
+             err1(l) = sdir(l,ib) - (sdir_road(l,ib) + swall_projected)
+          else
+             sdir_road(l,ib) = 0._r8
+             sdir_sunwall(l,ib) = 0._r8
+             sdir_shadewall(l,ib) = 0._r8
+          endif
+       end do
+
+       do fl = 1,num_urbanl
+          l = filter_urbanl(fl)
+          if (coszen(l) > 0._r8) then
+             if (abs(err1(l)) > 0.001_r8) then
+                write (iulog,*) 'urban direct beam solar radiation balance error',err1(l)
+                write (iulog,*) 'elm model is stopping'
+                call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
+             endif
+          endif
+       end do
 
        ! numerical check of analytical solution
        ! sum sroad and swall over all canyon orientations (0 <= theta <= pi/2)
 
-       ! if (numchk) then
-       !    do fl = 1,num_urbanl
-       !       l = filter_urbanl(fl)
-       !       if (coszen(l) > 0._r8) then
-       !          sumr = 0._r8
-       !          sumw = 0._r8
-       !          num  = 0._r8
-       !          do i = 1, 9000
-       !             theta = i/100._r8 * rpi/180._r8
-       !             zen0 = atan(1._r8/(canyon_hwr(l)*sin(theta)))
-       !             if (zen(l) >= zen0) then
-       !                sumr = sumr + 0._r8
-       !                sumw = sumw + sdir(l,ib) / canyon_hwr(l)
-       !             else
-       !                sumr = sumr + sdir(l,ib) * (1._r8-canyon_hwr(l)*sin(theta)*tanzen(l))
-       !                sumw = sumw + sdir(l,ib) * sin(theta)*tanzen(l)
-       !             end if
-       !             num = num + 1._r8
-       !          end do
-       !          err2 = sumr/num - sdir_road(l,ib)
-       !          err3 = sumw/num - sdir_sunwall(l,ib)
-       !       endif
-       !    end do
-          ! do fl = 1,num_urbanl
-          !    l = filter_urbanl(fl)
-          !    if (coszen(l) > 0._r8) then
-          !       if (abs(err2(l)) > 0.0006_r8 ) then
-          !          !#py write (iulog,*) 'urban road incident direct beam solar radiation error',err2(l)
-          !          !#py write (iulog,*) 'clm model is stopping'
-          !          !#py !#py call endrun(decomp_index=l, clmlevel=namel, msg=errmsg(__FILE__, __LINE__))
-          !       endif
-          !       if (abs(err3(l)) > 0.0006_r8 ) then
-          !          !#py write (iulog,*) 'urban wall incident direct beam solar radiation error',err3(l)
-          !          !#py write (iulog,*) 'clm model is stopping'
-          !          !#py !#py call endrun(decomp_index=l, clmlevel=namel, msg=errmsg(__FILE__, __LINE__))
-          !       end if
-          !    end if
-          ! end do
-       ! end if
+       if (numchk) then
+          do fl = 1,num_urbanl
+             l = filter_urbanl(fl)
+             if (coszen(l) > 0._r8) then
+                sumr = 0._r8
+                sumw = 0._r8
+                num  = 0._r8
+                do i = 1, 9000
+                   theta = i/100._r8 * rpi/180._r8
+                   zen0 = atan(1._r8/(canyon_hwr(l)*sin(theta)))
+                   if (zen(l) >= zen0) then 
+                      sumr = sumr + 0._r8
+                      sumw = sumw + sdir(l,ib) / canyon_hwr(l)
+                   else
+                      sumr = sumr + sdir(l,ib) * (1._r8-canyon_hwr(l)*sin(theta)*tanzen(l))
+                      sumw = sumw + sdir(l,ib) * sin(theta)*tanzen(l)
+                   end if
+                   num = num + 1._r8
+                end do
+                err2(l) = sumr/num - sdir_road(l,ib)
+                err3(l) = sumw/num - sdir_sunwall(l,ib)
+             endif
+          end do
+          do fl = 1,num_urbanl
+             l = filter_urbanl(fl)
+             if (coszen(l) > 0._r8) then
+                if (abs(err2(l)) > 0.0006_r8 ) then
+                   write (iulog,*) 'urban road incident direct beam solar radiation error',err2(l)
+                   write (iulog,*) 'elm model is stopping'
+                   call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
+                endif
+                if (abs(err3(l)) > 0.0006_r8 ) then
+                   write (iulog,*) 'urban wall incident direct beam solar radiation error',err3(l)
+                   write (iulog,*) 'elm model is stopping'
+                   call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
+                end if
+             end if
+          end do
+       end if
+
+    end do
 
   end subroutine incident_direct
 
   !-----------------------------------------------------------------------
-  subroutine incident_diffuse (l, canyon_hwr, &
+  subroutine incident_diffuse (bounds, &
+       num_urbanl, filter_urbanl, canyon_hwr, &
        sdif, sdif_road, sdif_sunwall, sdif_shadewall, &
        urbanparams_vars)
     !
-    ! !DESCRIPTION:
+    ! !DESCRIPTION: 
     ! Diffuse solar radiation incident on walls and road in urban canyon
-    ! Conservation check: Total incoming diffuse
+    ! Conservation check: Total incoming diffuse 
     ! (sdif) = sdif_road + (sdif_shadewall + sdif_sunwall)*canyon_hwr
     ! Multiplication by canyon_hwr scales wall fluxes (per unit wall area) to per unit ground area
     !
     ! !ARGUMENTS:
-    !$acc routine seq
-    integer  , value      , intent(in)  :: l
-    real(r8) , value      , intent(in)  :: canyon_hwr        ! ratio of building height to street width [landunit]
-    real(r8) , value      , intent(in)  :: sdif              ! diffuse solar radiation incident on horizontal surface [landunit, numrad]
-    real(r8)              , intent(out) :: sdif_road         ! diffuse solar radiation incident on road [landunit, numrad]
-    real(r8)              , intent(out) :: sdif_sunwall      ! diffuse solar radiation (per unit wall area) incident on sunlit wall [landunit, numrad]
-    real(r8)              , intent(out) :: sdif_shadewall    ! diffuse solar radiation (per unit wall area) incident on shaded wall [landunit, numrad]
+    type(bounds_type)     , intent(in)  :: bounds                      
+    integer               , intent(in)  :: num_urbanl                           ! number of urban landunits
+    integer               , intent(in)  :: filter_urbanl(:)                     ! urban landunit filter
+    real(r8)              , intent(in)  :: canyon_hwr     ( bounds%begl: )      ! ratio of building height to street width [landunit]
+    real(r8)              , intent(in)  :: sdif           ( bounds%begl: , 1: ) ! diffuse solar radiation incident on horizontal surface [landunit, numrad]
+    real(r8)              , intent(out) :: sdif_road      ( bounds%begl: , 1: ) ! diffuse solar radiation incident on road [landunit, numrad]
+    real(r8)              , intent(out) :: sdif_sunwall   ( bounds%begl: , 1: ) ! diffuse solar radiation (per unit wall area) incident on sunlit wall [landunit, numrad]
+    real(r8)              , intent(out) :: sdif_shadewall ( bounds%begl: , 1: ) ! diffuse solar radiation (per unit wall area) incident on shaded wall [landunit, numrad]
     type(urbanparams_type), intent(in)  :: urbanparams_vars
     !
     ! !LOCAL VARIABLES:
-    integer  :: fl, ib       ! indices
-    real(r8) :: err             ! energy conservation error (W/m**2)
+    integer  :: l, fl, ib       ! indices      
+    real(r8) :: err(bounds%begl:bounds%endl)    ! energy conservation error (W/m**2)
     real(r8) :: swall_projected ! diffuse solar radiation (per unit ground area) incident on wall (W/m**2)
     !-----------------------------------------------------------------------
 
     ! Enforce expected array sizes
-    associate(                            &
-         vf_sr =>    urbanparams_vars%vf_sr , & ! Input:  [real(r8) (:) ]  view factor of sky for road
-         vf_sw =>    urbanparams_vars%vf_sw   & ! Input:  [real(r8) (:) ]  view factor of sky for one wall
+    SHR_ASSERT_ALL((ubound(canyon_hwr)     == (/bounds%endl/)),         errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(sdif)           == (/bounds%endl, numrad/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(sdif_road)      == (/bounds%endl, numrad/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(sdif_sunwall)   == (/bounds%endl, numrad/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(sdif_shadewall) == (/bounds%endl, numrad/)), errMsg(__FILE__, __LINE__))
+
+    associate(                            & 
+         vf_sr =>    urbanparams_vars%vf_sr , & ! Input:  [real(r8) (:) ]  view factor of sky for road                       
+         vf_sw =>    urbanparams_vars%vf_sw   & ! Input:  [real(r8) (:) ]  view factor of sky for one wall                   
          )
 
+      do ib = 1, numrad
+         
          ! diffuse solar and conservation check. need to convert wall fluxes to ground area
+         
+         do fl = 1,num_urbanl
+            l = filter_urbanl(fl)
+            sdif_road(l,ib)      = sdif(l,ib) * vf_sr(l)
+            sdif_sunwall(l,ib)   = sdif(l,ib) * vf_sw(l) 
+            sdif_shadewall(l,ib) = sdif(l,ib) * vf_sw(l) 
 
-         sdif_road       = sdif * vf_sr(l)
-         sdif_sunwall    = sdif * vf_sw(l)
-         sdif_shadewall  = sdif * vf_sw(l)
-
-         swall_projected = (sdif_shadewall  + sdif_sunwall ) * canyon_hwr
-         err = sdif - (sdif_road + swall_projected)
+            swall_projected = (sdif_shadewall(l,ib) + sdif_sunwall(l,ib)) * canyon_hwr(l)
+            err(l) = sdif(l,ib) - (sdif_road(l,ib) + swall_projected)
+         end do
 
          ! error check
 
-         ! do fl = 1, num_urbanl
-         !    l = filter_urbanl(fl)
-         !    if (abs(err(l)) > 0.001_r8) then
-         !       !#py write (iulog,*) 'urban diffuse solar radiation balance error',err(l)
-         !       !#py write (iulog,*) 'clm model is stopping'
-         !       !#py !#py call endrun(decomp_index=l, clmlevel=namel, msg=errmsg(__FILE__, __LINE__))
-         !    endif
-         ! end do
+         do fl = 1, num_urbanl
+            l = filter_urbanl(fl)
+            if (abs(err(l)) > 0.001_r8) then
+               write (iulog,*) 'urban diffuse solar radiation balance error',err(l) 
+               write (iulog,*) 'elm model is stopping'
+               call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
+            endif
+         end do
+
+      end do
 
     end associate
 
   end subroutine incident_diffuse
 
   !-----------------------------------------------------------------------
-  subroutine net_solar (l, ib, coszen, canyon_hwr, wtroad_perv, sdir, sdif                  , &
+  subroutine net_solar (bounds                                                                 , &
+       num_urbanl, filter_urbanl, coszen, canyon_hwr, wtroad_perv, sdir, sdif                  , &
        alb_improad_dir, alb_perroad_dir, alb_wall_dir, alb_roof_dir                            , &
        alb_improad_dif, alb_perroad_dif, alb_wall_dif, alb_roof_dif                            , &
        sdir_road, sdir_sunwall, sdir_shadewall,                                                  &
@@ -710,116 +747,116 @@ contains
        sref_improad_dif, sref_perroad_dif, sref_sunwall_dif, sref_shadewall_dif, sref_roof_dif , &
        urbanparams_vars, solarabs_vars)
     !
-    ! !DESCRIPTION:
-    ! Solar radiation absorbed by road and both walls in urban canyon allowing
+    ! !DESCRIPTION: 
+    ! Solar radiation absorbed by road and both walls in urban canyon allowing 
     ! for multiple reflection.
     !
     ! !ARGUMENTS:
-      !$acc routine seq
-    !type (bounds_type), intent(in) :: bounds
-    !integer , intent(in)    :: num_urbanl                               ! number of urban landunits
-    !integer , intent(in)    :: filter_urbanl(:)                         ! urban landunit filter
-    integer , value, intent(in) :: l, ib
-    real(r8),value, intent(in)  :: coszen              ! cosine solar zenith angle [landunit]
-    real(r8),value, intent(in)  :: canyon_hwr          ! ratio of building height to street width [landunit]
-    real(r8),value, intent(in)  :: wtroad_perv         ! weight of pervious road wrt total road [landunit]
-    real(r8),value, intent(in)  :: sdir                ! direct beam solar radiation incident on horizontal surface [landunit, numrad]
-    real(r8),value, intent(in)  :: sdif                ! diffuse solar radiation on horizontal surface [landunit, numrad]
-    real(r8),value, intent(in)  :: alb_improad_dir     ! direct impervious road albedo [landunit, numrad]
-    real(r8),value, intent(in)  :: alb_perroad_dir     ! direct pervious road albedo [landunit, numrad]
-    real(r8),value, intent(in)  :: alb_wall_dir        ! direct  wall albedo [landunit, numrad]
-    real(r8),value, intent(in)  :: alb_roof_dir        ! direct  roof albedo [landunit, numrad]
-    real(r8),value, intent(in)  :: alb_improad_dif     ! diffuse impervious road albedo [landunit, numrad]
-    real(r8),value, intent(in)  :: alb_perroad_dif     ! diffuse pervious road albedo [landunit, numrad]
-    real(r8),value, intent(in)  :: alb_wall_dif        ! diffuse wall albedo [landunit, numrad]
-    real(r8),value, intent(in)  :: alb_roof_dif        ! diffuse roof albedo [landunit, numrad]
-    real(r8),value, intent(in)  :: sdir_road           ! direct beam solar radiation incident on road per unit incident flux [landunit, numrad]
-    real(r8),value, intent(in)  :: sdir_sunwall        ! direct beam solar radiation (per unit wall area) incident on sunlit wall per unit incident flux [landunit, numrad]
-    real(r8),value, intent(in)  :: sdir_shadewall      ! direct beam solar radiation (per unit wall area) incident on shaded wall per unit incident flux [landunit, numrad]
-    real(r8),value, intent(in)  :: sdif_road           ! diffuse solar radiation incident on road per unit incident flux [landunit, numrad]
-    real(r8),value, intent(in)  :: sdif_sunwall        ! diffuse solar radiation (per unit wall area) incident on sunlit wall per unit incident flux [landunit, numrad]
-    real(r8),value, intent(in)  :: sdif_shadewall      ! diffuse solar radiation (per unit wall area) incident on shaded wall per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_improad_dir    ! direct  solar rad reflected by impervious road (per unit ground area) per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_perroad_dir    ! direct  solar rad reflected by pervious road (per unit ground area) per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_improad_dif    ! diffuse solar rad reflected by impervious road (per unit ground area) per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_perroad_dif    ! diffuse solar rad reflected by pervious road (per unit ground area) per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_sunwall_dir    ! direct solar  rad reflected by sunwall (per unit wall area) per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_sunwall_dif    ! diffuse solar rad reflected by sunwall (per unit wall area) per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_shadewall_dir  ! direct solar  rad reflected by shadewall (per unit wall area) per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_shadewall_dif  ! diffuse solar rad reflected by shadewall (per unit wall area) per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_roof_dir       ! direct  solar rad reflected by roof (per unit ground area) per unit incident flux [landunit, numrad]
-    real(r8), intent(inout) :: sref_roof_dif       ! diffuse solar rad reflected by roof (per unit ground area)  per unit incident flux [landunit, numrad]
+    type (bounds_type), intent(in) :: bounds                            
+    integer , intent(in)    :: num_urbanl                               ! number of urban landunits
+    integer , intent(in)    :: filter_urbanl(:)                         ! urban landunit filter
+    real(r8), intent(in)    :: coszen             ( bounds%begl: )      ! cosine solar zenith angle [landunit]
+    real(r8), intent(in)    :: canyon_hwr         ( bounds%begl: )      ! ratio of building height to street width [landunit]
+    real(r8), intent(in)    :: wtroad_perv        ( bounds%begl: )      ! weight of pervious road wrt total road [landunit]
+    real(r8), intent(in)    :: sdir               ( bounds%begl: , 1: ) ! direct beam solar radiation incident on horizontal surface [landunit, numrad]
+    real(r8), intent(in)    :: sdif               ( bounds%begl: , 1: ) ! diffuse solar radiation on horizontal surface [landunit, numrad]
+    real(r8), intent(in)    :: alb_improad_dir    ( bounds%begl: , 1: ) ! direct impervious road albedo [landunit, numrad]
+    real(r8), intent(in)    :: alb_perroad_dir    ( bounds%begl: , 1: ) ! direct pervious road albedo [landunit, numrad]
+    real(r8), intent(in)    :: alb_wall_dir       ( bounds%begl: , 1: ) ! direct  wall albedo [landunit, numrad]
+    real(r8), intent(in)    :: alb_roof_dir       ( bounds%begl: , 1: ) ! direct  roof albedo [landunit, numrad]
+    real(r8), intent(in)    :: alb_improad_dif    ( bounds%begl: , 1: ) ! diffuse impervious road albedo [landunit, numrad]
+    real(r8), intent(in)    :: alb_perroad_dif    ( bounds%begl: , 1: ) ! diffuse pervious road albedo [landunit, numrad]
+    real(r8), intent(in)    :: alb_wall_dif       ( bounds%begl: , 1: ) ! diffuse wall albedo [landunit, numrad]
+    real(r8), intent(in)    :: alb_roof_dif       ( bounds%begl: , 1: ) ! diffuse roof albedo [landunit, numrad]
+    real(r8), intent(in)    :: sdir_road          ( bounds%begl: , 1: ) ! direct beam solar radiation incident on road per unit incident flux [landunit, numrad]
+    real(r8), intent(in)    :: sdir_sunwall       ( bounds%begl: , 1: ) ! direct beam solar radiation (per unit wall area) incident on sunlit wall per unit incident flux [landunit, numrad]
+    real(r8), intent(in)    :: sdir_shadewall     ( bounds%begl: , 1: ) ! direct beam solar radiation (per unit wall area) incident on shaded wall per unit incident flux [landunit, numrad]
+    real(r8), intent(in)    :: sdif_road          ( bounds%begl: , 1: ) ! diffuse solar radiation incident on road per unit incident flux [landunit, numrad]
+    real(r8), intent(in)    :: sdif_sunwall       ( bounds%begl: , 1: ) ! diffuse solar radiation (per unit wall area) incident on sunlit wall per unit incident flux [landunit, numrad]
+    real(r8), intent(in)    :: sdif_shadewall     ( bounds%begl: , 1: ) ! diffuse solar radiation (per unit wall area) incident on shaded wall per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_improad_dir   ( bounds%begl: , 1: ) ! direct  solar rad reflected by impervious road (per unit ground area) per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_perroad_dir   ( bounds%begl: , 1: ) ! direct  solar rad reflected by pervious road (per unit ground area) per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_improad_dif   ( bounds%begl: , 1: ) ! diffuse solar rad reflected by impervious road (per unit ground area) per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_perroad_dif   ( bounds%begl: , 1: ) ! diffuse solar rad reflected by pervious road (per unit ground area) per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_sunwall_dir   ( bounds%begl: , 1: ) ! direct solar  rad reflected by sunwall (per unit wall area) per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_sunwall_dif   ( bounds%begl: , 1: ) ! diffuse solar rad reflected by sunwall (per unit wall area) per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_shadewall_dir ( bounds%begl: , 1: ) ! direct solar  rad reflected by shadewall (per unit wall area) per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_shadewall_dif ( bounds%begl: , 1: ) ! diffuse solar rad reflected by shadewall (per unit wall area) per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_roof_dir      ( bounds%begl: , 1: ) ! direct  solar rad reflected by roof (per unit ground area) per unit incident flux [landunit, numrad]
+    real(r8), intent(inout) :: sref_roof_dif      ( bounds%begl: , 1: ) ! diffuse solar rad reflected by roof (per unit ground area)  per unit incident flux [landunit, numrad]
     type(urbanparams_type), intent(in)    :: urbanparams_vars
     type(solarabs_type)   , intent(inout) :: solarabs_vars
     !
     ! !LOCAL VARIABLES
-    real(r8) :: wtroad_imperv         ! weight of impervious road wrt total road
-    real(r8) :: sabs_canyon_dir         ! direct solar rad absorbed by canyon per unit incident flux
-    real(r8) :: sabs_canyon_dif         ! diffuse solar rad absorbed by canyon per unit incident flux
-    real(r8) :: sref_canyon_dir         ! direct solar reflected by canyon per unit incident flux
-    real(r8) :: sref_canyon_dif         ! diffuse solar reflected by canyon per unit incident flux
-
-    real(r8) :: improad_a_dir           ! absorbed direct solar for impervious road after "n" reflections per unit incident flux
-    real(r8) :: improad_a_dif           ! absorbed diffuse solar for impervious road after "n" reflections per unit incident flux
-    real(r8) :: improad_r_dir           ! reflected direct solar for impervious road after "n" reflections per unit incident flux
-    real(r8) :: improad_r_dif           ! reflected diffuse solar for impervious road after "n" reflections per unit incident flux
-    real(r8) :: improad_r_sky_dir       ! improad_r_dir to sky per unit incident flux
-    real(r8) :: improad_r_sunwall_dir   ! improad_r_dir to sunlit wall per unit incident flux
-    real(r8) :: improad_r_shadewall_dir ! improad_r_dir to shaded wall per unit incident flux
-    real(r8) :: improad_r_sky_dif       ! improad_r_dif to sky per unit incident flux
-    real(r8) :: improad_r_sunwall_dif   ! improad_r_dif to sunlit wall per unit incident flux
-    real(r8) :: improad_r_shadewall_dif ! improad_r_dif to shaded wall per unit incident flux
-
-    real(r8) :: perroad_a_dir           ! absorbed direct solar for pervious road after "n" reflections per unit incident flux
-    real(r8) :: perroad_a_dif           ! absorbed diffuse solar for pervious road after "n" reflections per unit incident flux
-    real(r8) :: perroad_r_dir           ! reflected direct solar for pervious road after "n" reflections per unit incident flux
-    real(r8) :: perroad_r_dif           ! reflected diffuse solar for pervious road after "n" reflections per unit incident flux
-    real(r8) :: perroad_r_sky_dir       ! perroad_r_dir to sky per unit incident flux
-    real(r8) :: perroad_r_sunwall_dir   ! perroad_r_dir to sunlit wall per unit incident flux
-    real(r8) :: perroad_r_shadewall_dir ! perroad_r_dir to shaded wall per unit incident flux
-    real(r8) :: perroad_r_sky_dif       ! perroad_r_dif to sky per unit incident flux
-    real(r8) :: perroad_r_sunwall_dif   ! perroad_r_dif to sunlit wall per unit incident flux
-    real(r8) :: perroad_r_shadewall_dif ! perroad_r_dif to shaded wall per unit incident flux
-
-    real(r8) :: road_a_dir              ! absorbed direct solar for total road after "n" reflections per unit incident flux
-    real(r8) :: road_a_dif              ! absorbed diffuse solar for total road after "n" reflections per unit incident flux
-    real(r8) :: road_r_dir              ! reflected direct solar for total road after "n" reflections per unit incident flux
-    real(r8) :: road_r_dif              ! reflected diffuse solar for total road after "n" reflections per unit incident flux
-    real(r8) :: road_r_sky_dir          ! road_r_dir to sky per unit incident flux
-    real(r8) :: road_r_sunwall_dir      ! road_r_dir to sunlit wall per unit incident flux
-    real(r8) :: road_r_shadewall_dir    ! road_r_dir to shaded wall per unit incident flux
-    real(r8) :: road_r_sky_dif          ! road_r_dif to sky per unit incident flux
-    real(r8) :: road_r_sunwall_dif      ! road_r_dif to sunlit wall per unit incident flux
-    real(r8) :: road_r_shadewall_dif    ! road_r_dif to shaded wall per unit incident flux
-
-    real(r8) :: sunwall_a_dir           ! absorbed direct solar for sunlit wall (per unit wall area) after "n" reflections per unit incident flux
-    real(r8) :: sunwall_a_dif           ! absorbed diffuse solar for sunlit wall (per unit wall area) after "n" reflections per unit incident flux
-    real(r8) :: sunwall_r_dir           ! reflected direct solar for sunlit wall (per unit wall area) after "n" reflections per unit incident flux
-    real(r8) :: sunwall_r_dif           ! reflected diffuse solar for sunlit wall (per unit wall area) after "n" reflections per unit incident flux
-    real(r8) :: sunwall_r_sky_dir       ! sunwall_r_dir to sky per unit incident flux
-    real(r8) :: sunwall_r_road_dir      ! sunwall_r_dir to road per unit incident flux
-    real(r8) :: sunwall_r_shadewall_dir ! sunwall_r_dir to opposing (shaded) wall per unit incident flux
-    real(r8) :: sunwall_r_sky_dif       ! sunwall_r_dif to sky per unit incident flux
-    real(r8) :: sunwall_r_road_dif      ! sunwall_r_dif to road per unit incident flux
-    real(r8) :: sunwall_r_shadewall_dif ! sunwall_r_dif to opposing (shaded) wall per unit incident flux
-
-    real(r8) :: shadewall_a_dir         ! absorbed direct solar for shaded wall (per unit wall area) after "n" reflections per unit incident flux
-    real(r8) :: shadewall_a_dif         ! absorbed diffuse solar for shaded wall (per unit wall area) after "n" reflections per unit incident flux
-    real(r8) :: shadewall_r_dir         ! reflected direct solar for shaded wall (per unit wall area) after "n" reflections per unit incident flux
-    real(r8) :: shadewall_r_dif         ! reflected diffuse solar for shaded wall (per unit wall area) after "n" reflections per unit incident flux
-    real(r8) :: shadewall_r_sky_dir     ! shadewall_r_dir to sky per unit incident flux
-    real(r8) :: shadewall_r_road_dir    ! shadewall_r_dir to road per unit incident flux
-    real(r8) :: shadewall_r_sunwall_dir ! shadewall_r_dir to opposing (sunlit) wall per unit incident flux
-    real(r8) :: shadewall_r_sky_dif     ! shadewall_r_dif to sky per unit incident flux
-    real(r8) :: shadewall_r_road_dif    ! shadewall_r_dif to road per unit incident flux
-    real(r8) :: shadewall_r_sunwall_dif ! shadewall_r_dif to opposing (sunlit) wall per unit incident flux
-
-    real(r8) :: canyon_alb_dir          ! direct canyon albedo
-    real(r8) :: canyon_alb_dif          ! diffuse canyon albedo
-
-    real(r8) :: stot                ! sum of radiative terms
-    real(r8) :: stot_dir            ! sum of direct radiative terms
-    real(r8) :: stot_dif            ! sum of diffuse radiative terms
+    real(r8) :: wtroad_imperv(bounds%begl:bounds%endl)           ! weight of impervious road wrt total road
+    real(r8) :: sabs_canyon_dir(bounds%begl:bounds%endl)         ! direct solar rad absorbed by canyon per unit incident flux
+    real(r8) :: sabs_canyon_dif(bounds%begl:bounds%endl)         ! diffuse solar rad absorbed by canyon per unit incident flux
+    real(r8) :: sref_canyon_dir(bounds%begl:bounds%endl)         ! direct solar reflected by canyon per unit incident flux 
+    real(r8) :: sref_canyon_dif(bounds%begl:bounds%endl)         ! diffuse solar reflected by canyon per unit incident flux
+
+    real(r8) :: improad_a_dir(bounds%begl:bounds%endl)           ! absorbed direct solar for impervious road after "n" reflections per unit incident flux
+    real(r8) :: improad_a_dif(bounds%begl:bounds%endl)           ! absorbed diffuse solar for impervious road after "n" reflections per unit incident flux
+    real(r8) :: improad_r_dir(bounds%begl:bounds%endl)           ! reflected direct solar for impervious road after "n" reflections per unit incident flux
+    real(r8) :: improad_r_dif(bounds%begl:bounds%endl)           ! reflected diffuse solar for impervious road after "n" reflections per unit incident flux
+    real(r8) :: improad_r_sky_dir(bounds%begl:bounds%endl)       ! improad_r_dir to sky per unit incident flux
+    real(r8) :: improad_r_sunwall_dir(bounds%begl:bounds%endl)   ! improad_r_dir to sunlit wall per unit incident flux
+    real(r8) :: improad_r_shadewall_dir(bounds%begl:bounds%endl) ! improad_r_dir to shaded wall per unit incident flux
+    real(r8) :: improad_r_sky_dif(bounds%begl:bounds%endl)       ! improad_r_dif to sky per unit incident flux
+    real(r8) :: improad_r_sunwall_dif(bounds%begl:bounds%endl)   ! improad_r_dif to sunlit wall per unit incident flux
+    real(r8) :: improad_r_shadewall_dif(bounds%begl:bounds%endl) ! improad_r_dif to shaded wall per unit incident flux
+
+    real(r8) :: perroad_a_dir(bounds%begl:bounds%endl)           ! absorbed direct solar for pervious road after "n" reflections per unit incident flux
+    real(r8) :: perroad_a_dif(bounds%begl:bounds%endl)           ! absorbed diffuse solar for pervious road after "n" reflections per unit incident flux
+    real(r8) :: perroad_r_dir(bounds%begl:bounds%endl)           ! reflected direct solar for pervious road after "n" reflections per unit incident flux
+    real(r8) :: perroad_r_dif(bounds%begl:bounds%endl)           ! reflected diffuse solar for pervious road after "n" reflections per unit incident flux
+    real(r8) :: perroad_r_sky_dir(bounds%begl:bounds%endl)       ! perroad_r_dir to sky per unit incident flux 
+    real(r8) :: perroad_r_sunwall_dir(bounds%begl:bounds%endl)   ! perroad_r_dir to sunlit wall per unit incident flux
+    real(r8) :: perroad_r_shadewall_dir(bounds%begl:bounds%endl) ! perroad_r_dir to shaded wall per unit incident flux
+    real(r8) :: perroad_r_sky_dif(bounds%begl:bounds%endl)       ! perroad_r_dif to sky per unit incident flux
+    real(r8) :: perroad_r_sunwall_dif(bounds%begl:bounds%endl)   ! perroad_r_dif to sunlit wall per unit incident flux
+    real(r8) :: perroad_r_shadewall_dif(bounds%begl:bounds%endl) ! perroad_r_dif to shaded wall per unit incident flux
+
+    real(r8) :: road_a_dir(bounds%begl:bounds%endl)              ! absorbed direct solar for total road after "n" reflections per unit incident flux
+    real(r8) :: road_a_dif(bounds%begl:bounds%endl)              ! absorbed diffuse solar for total road after "n" reflections per unit incident flux
+    real(r8) :: road_r_dir(bounds%begl:bounds%endl)              ! reflected direct solar for total road after "n" reflections per unit incident flux
+    real(r8) :: road_r_dif(bounds%begl:bounds%endl)              ! reflected diffuse solar for total road after "n" reflections per unit incident flux
+    real(r8) :: road_r_sky_dir(bounds%begl:bounds%endl)          ! road_r_dir to sky per unit incident flux
+    real(r8) :: road_r_sunwall_dir(bounds%begl:bounds%endl)      ! road_r_dir to sunlit wall per unit incident flux
+    real(r8) :: road_r_shadewall_dir(bounds%begl:bounds%endl)    ! road_r_dir to shaded wall per unit incident flux
+    real(r8) :: road_r_sky_dif(bounds%begl:bounds%endl)          ! road_r_dif to sky per unit incident flux
+    real(r8) :: road_r_sunwall_dif(bounds%begl:bounds%endl)      ! road_r_dif to sunlit wall per unit incident flux
+    real(r8) :: road_r_shadewall_dif(bounds%begl:bounds%endl)    ! road_r_dif to shaded wall per unit incident flux
+
+    real(r8) :: sunwall_a_dir(bounds%begl:bounds%endl)           ! absorbed direct solar for sunlit wall (per unit wall area) after "n" reflections per unit incident flux
+    real(r8) :: sunwall_a_dif(bounds%begl:bounds%endl)           ! absorbed diffuse solar for sunlit wall (per unit wall area) after "n" reflections per unit incident flux
+    real(r8) :: sunwall_r_dir(bounds%begl:bounds%endl)           ! reflected direct solar for sunlit wall (per unit wall area) after "n" reflections per unit incident flux
+    real(r8) :: sunwall_r_dif(bounds%begl:bounds%endl)           ! reflected diffuse solar for sunlit wall (per unit wall area) after "n" reflections per unit incident flux
+    real(r8) :: sunwall_r_sky_dir(bounds%begl:bounds%endl)       ! sunwall_r_dir to sky per unit incident flux
+    real(r8) :: sunwall_r_road_dir(bounds%begl:bounds%endl)      ! sunwall_r_dir to road per unit incident flux
+    real(r8) :: sunwall_r_shadewall_dir(bounds%begl:bounds%endl) ! sunwall_r_dir to opposing (shaded) wall per unit incident flux
+    real(r8) :: sunwall_r_sky_dif(bounds%begl:bounds%endl)       ! sunwall_r_dif to sky per unit incident flux
+    real(r8) :: sunwall_r_road_dif(bounds%begl:bounds%endl)      ! sunwall_r_dif to road per unit incident flux
+    real(r8) :: sunwall_r_shadewall_dif(bounds%begl:bounds%endl) ! sunwall_r_dif to opposing (shaded) wall per unit incident flux
+
+    real(r8) :: shadewall_a_dir(bounds%begl:bounds%endl)         ! absorbed direct solar for shaded wall (per unit wall area) after "n" reflections per unit incident flux
+    real(r8) :: shadewall_a_dif(bounds%begl:bounds%endl)         ! absorbed diffuse solar for shaded wall (per unit wall area) after "n" reflections per unit incident flux
+    real(r8) :: shadewall_r_dir(bounds%begl:bounds%endl)         ! reflected direct solar for shaded wall (per unit wall area) after "n" reflections per unit incident flux
+    real(r8) :: shadewall_r_dif(bounds%begl:bounds%endl)         ! reflected diffuse solar for shaded wall (per unit wall area) after "n" reflections per unit incident flux
+    real(r8) :: shadewall_r_sky_dir(bounds%begl:bounds%endl)     ! shadewall_r_dir to sky per unit incident flux
+    real(r8) :: shadewall_r_road_dir(bounds%begl:bounds%endl)    ! shadewall_r_dir to road per unit incident flux
+    real(r8) :: shadewall_r_sunwall_dir(bounds%begl:bounds%endl) ! shadewall_r_dir to opposing (sunlit) wall per unit incident flux
+    real(r8) :: shadewall_r_sky_dif(bounds%begl:bounds%endl)     ! shadewall_r_dif to sky per unit incident flux
+    real(r8) :: shadewall_r_road_dif(bounds%begl:bounds%endl)    ! shadewall_r_dif to road per unit incident flux
+    real(r8) :: shadewall_r_sunwall_dif(bounds%begl:bounds%endl) ! shadewall_r_dif to opposing (sunlit) wall per unit incident flux
+
+    real(r8) :: canyon_alb_dir(bounds%begl:bounds%endl)          ! direct canyon albedo
+    real(r8) :: canyon_alb_dif(bounds%begl:bounds%endl)          ! diffuse canyon albedo
+
+    real(r8) :: stot(bounds%begl:bounds%endl)                    ! sum of radiative terms
+    real(r8) :: stot_dir(bounds%begl:bounds%endl)                ! sum of direct radiative terms
+    real(r8) :: stot_dif(bounds%begl:bounds%endl)                ! sum of diffuse radiative terms
+
+    integer  :: l,fl,ib                          ! indices
     integer  :: iter_dir,iter_dif                ! iteration counter
     real(r8) :: crit                             ! convergence criterion
     real(r8) :: err                              ! energy conservation error
@@ -830,14 +867,13 @@ contains
     real(r8), parameter :: errcrit  = .00001_r8  ! error criteria
     !-----------------------------------------------------------------------
 
-    ! Enforce expected array sizes
 
-    associate(                                                           &
-         vf_sr              =>    urbanparams_vars%vf_sr               , & ! Input:  [real(r8) (:)   ]  view factor of sky for road
-         vf_wr              =>    urbanparams_vars%vf_wr               , & ! Input:  [real(r8) (:)   ]  view factor of one wall for road
-         vf_sw              =>    urbanparams_vars%vf_sw               , & ! Input:  [real(r8) (:)   ]  view factor of sky for one wall
-         vf_rw              =>    urbanparams_vars%vf_rw               , & ! Input:  [real(r8) (:)   ]  view factor of road for one wall
-         vf_ww              =>    urbanparams_vars%vf_ww               , & ! Input:  [real(r8) (:)   ]  view factor of opposing wall for one wall
+    associate(                                                           & 
+         vf_sr              =>    urbanparams_vars%vf_sr               , & ! Input:  [real(r8) (:)   ]  view factor of sky for road                       
+         vf_wr              =>    urbanparams_vars%vf_wr               , & ! Input:  [real(r8) (:)   ]  view factor of one wall for road                  
+         vf_sw              =>    urbanparams_vars%vf_sw               , & ! Input:  [real(r8) (:)   ]  view factor of sky for one wall                   
+         vf_rw              =>    urbanparams_vars%vf_rw               , & ! Input:  [real(r8) (:)   ]  view factor of road for one wall                  
+         vf_ww              =>    urbanparams_vars%vf_ww               , & ! Input:  [real(r8) (:)   ]  view factor of opposing wall for one wall         
 
          sabs_roof_dir      =>    solarabs_vars%sabs_roof_dir_lun      , & ! Output: [real(r8) (:,:) ]  direct  solar absorbed  by roof per unit ground area per unit incident flux
          sabs_roof_dif      =>    solarabs_vars%sabs_roof_dif_lun      , & ! Output: [real(r8) (:,:) ]  diffuse solar absorbed  by roof per unit ground area per unit incident flux
@@ -852,111 +888,122 @@ contains
          )
 
       ! Calculate impervious road
+      
+      do fl = 1,num_urbanl 
+         l = filter_urbanl(fl)
+         wtroad_imperv(l) = 1._r8 - wtroad_perv(l)
+      end do
 
+      do ib = 1,numrad
+         do fl = 1,num_urbanl
+            l = filter_urbanl(fl)
+            if (coszen(l) > 0._r8) then
+
+               ! initial absorption and reflection for road and both walls. 
+               ! distribute reflected radiation to sky, road, and walls 
+               ! according to appropriate view factor. radiation reflected to 
+               ! road and walls will undergo multiple reflections within the canyon. 
+               ! do separately for direct beam and diffuse radiation.
+
+               ! direct beam
+
+               road_a_dir(l)              = 0.0_r8
+               road_r_dir(l)              = 0.0_r8
+               improad_a_dir(l)           = (1._r8-alb_improad_dir(l,ib)) * sdir_road(l,ib) 
+               improad_r_dir(l)           =     alb_improad_dir(l,ib)  * sdir_road(l,ib) 
+               improad_r_sky_dir(l)       = improad_r_dir(l) * vf_sr(l)
+               improad_r_sunwall_dir(l)   = improad_r_dir(l) * vf_wr(l)
+               improad_r_shadewall_dir(l) = improad_r_dir(l) * vf_wr(l)
+               road_a_dir(l)              = road_a_dir(l) + improad_a_dir(l)*wtroad_imperv(l)
+               road_r_dir(l)              = road_r_dir(l) + improad_r_dir(l)*wtroad_imperv(l)
+
+               perroad_a_dir(l)           = (1._r8-alb_perroad_dir(l,ib)) * sdir_road(l,ib) 
+               perroad_r_dir(l)           =     alb_perroad_dir(l,ib)  * sdir_road(l,ib) 
+               perroad_r_sky_dir(l)       = perroad_r_dir(l) * vf_sr(l)
+               perroad_r_sunwall_dir(l)   = perroad_r_dir(l) * vf_wr(l)
+               perroad_r_shadewall_dir(l) = perroad_r_dir(l) * vf_wr(l)
+               road_a_dir(l)              = road_a_dir(l) + perroad_a_dir(l)*wtroad_perv(l)
+               road_r_dir(l)              = road_r_dir(l) + perroad_r_dir(l)*wtroad_perv(l)
+
+               road_r_sky_dir(l)          = road_r_dir(l) * vf_sr(l)
+               road_r_sunwall_dir(l)      = road_r_dir(l) * vf_wr(l)
+               road_r_shadewall_dir(l)    = road_r_dir(l) * vf_wr(l)
+
+               sunwall_a_dir(l)           = (1._r8-alb_wall_dir(l,ib)) * sdir_sunwall(l,ib)
+               sunwall_r_dir(l)           =     alb_wall_dir(l,ib)  * sdir_sunwall(l,ib)
+               sunwall_r_sky_dir(l)       = sunwall_r_dir(l) * vf_sw(l)
+               sunwall_r_road_dir(l)      = sunwall_r_dir(l) * vf_rw(l)
+               sunwall_r_shadewall_dir(l) = sunwall_r_dir(l) * vf_ww(l)
+
+               shadewall_a_dir(l)         = (1._r8-alb_wall_dir(l,ib)) * sdir_shadewall(l,ib)
+               shadewall_r_dir(l)         =     alb_wall_dir(l,ib)  * sdir_shadewall(l,ib)
+               shadewall_r_sky_dir(l)     = shadewall_r_dir(l) * vf_sw(l)
+               shadewall_r_road_dir(l)    = shadewall_r_dir(l) * vf_rw(l)
+               shadewall_r_sunwall_dir(l) = shadewall_r_dir(l) * vf_ww(l)
+
+               ! diffuse
+
+               road_a_dif(l)              = 0.0_r8
+               road_r_dif(l)              = 0.0_r8
+               improad_a_dif(l)           = (1._r8-alb_improad_dif(l,ib)) * sdif_road(l,ib) 
+               improad_r_dif(l)           =     alb_improad_dif(l,ib)  * sdif_road(l,ib) 
+               improad_r_sky_dif(l)       = improad_r_dif(l) * vf_sr(l)
+               improad_r_sunwall_dif(l)   = improad_r_dif(l) * vf_wr(l)
+               improad_r_shadewall_dif(l) = improad_r_dif(l) * vf_wr(l)
+               road_a_dif(l)              = road_a_dif(l) + improad_a_dif(l)*wtroad_imperv(l)
+               road_r_dif(l)              = road_r_dif(l) + improad_r_dif(l)*wtroad_imperv(l)
+
+               perroad_a_dif(l)           = (1._r8-alb_perroad_dif(l,ib)) * sdif_road(l,ib) 
+               perroad_r_dif(l)           =     alb_perroad_dif(l,ib)  * sdif_road(l,ib) 
+               perroad_r_sky_dif(l)       = perroad_r_dif(l) * vf_sr(l)
+               perroad_r_sunwall_dif(l)   = perroad_r_dif(l) * vf_wr(l)
+               perroad_r_shadewall_dif(l) = perroad_r_dif(l) * vf_wr(l)
+               road_a_dif(l)              = road_a_dif(l) + perroad_a_dif(l)*wtroad_perv(l)
+               road_r_dif(l)              = road_r_dif(l) + perroad_r_dif(l)*wtroad_perv(l)
+
+               road_r_sky_dif(l)          = road_r_dif(l) * vf_sr(l)
+               road_r_sunwall_dif(l)      = road_r_dif(l) * vf_wr(l)
+               road_r_shadewall_dif(l)    = road_r_dif(l) * vf_wr(l)
+
+               sunwall_a_dif(l)           = (1._r8-alb_wall_dif(l,ib)) * sdif_sunwall(l,ib)
+               sunwall_r_dif(l)           =     alb_wall_dif(l,ib)  * sdif_sunwall(l,ib)
+               sunwall_r_sky_dif(l)       = sunwall_r_dif(l) * vf_sw(l)
+               sunwall_r_road_dif(l)      = sunwall_r_dif(l) * vf_rw(l)
+               sunwall_r_shadewall_dif(l) = sunwall_r_dif(l) * vf_ww(l)
+
+               shadewall_a_dif(l)         = (1._r8-alb_wall_dif(l,ib)) * sdif_shadewall(l,ib)
+               shadewall_r_dif(l)         =     alb_wall_dif(l,ib)  * sdif_shadewall(l,ib)
+               shadewall_r_sky_dif(l)     = shadewall_r_dif(l) * vf_sw(l)
+               shadewall_r_road_dif(l)    = shadewall_r_dif(l) * vf_rw(l) 
+               shadewall_r_sunwall_dif(l) = shadewall_r_dif(l) * vf_ww(l) 
+
+               ! initialize sum of direct and diffuse solar absorption and reflection for road and both walls
+
+               sabs_improad_dir(l,ib)   = improad_a_dir(l)
+               sabs_perroad_dir(l,ib)   = perroad_a_dir(l)
+               sabs_sunwall_dir(l,ib)   = sunwall_a_dir(l)
+               sabs_shadewall_dir(l,ib) = shadewall_a_dir(l)
+
+               sabs_improad_dif(l,ib)   = improad_a_dif(l)
+               sabs_perroad_dif(l,ib)   = perroad_a_dif(l)
+               sabs_sunwall_dif(l,ib)   = sunwall_a_dif(l)
+               sabs_shadewall_dif(l,ib) = shadewall_a_dif(l)
+
+               sref_improad_dir(l,ib)   = improad_r_sky_dir(l) 
+               sref_perroad_dir(l,ib)   = perroad_r_sky_dir(l) 
+               sref_sunwall_dir(l,ib)   = sunwall_r_sky_dir(l) 
+               sref_shadewall_dir(l,ib) = shadewall_r_sky_dir(l) 
+
+               sref_improad_dif(l,ib)   = improad_r_sky_dif(l)
+               sref_perroad_dif(l,ib)   = perroad_r_sky_dif(l)
+               sref_sunwall_dif(l,ib)   = sunwall_r_sky_dif(l)
+               sref_shadewall_dif(l,ib) = shadewall_r_sky_dif(l)
+            endif
 
-          ! initial absorption and reflection for road and both walls.
-          ! distribute reflected radiation to sky, road, and walls
-          ! according to appropriate view factor. radiation reflected to
-          ! road and walls will undergo multiple reflections within the canyon.
-          ! do separately for direct beam and diffuse radiation.
-
-          ! direct beam
-          wtroad_imperv = 1._r8 - wtroad_perv
-          road_a_dir              = 0.0_r8
-          road_r_dir              = 0.0_r8
-          improad_a_dir           = (1._r8-alb_improad_dir) * sdir_road
-          improad_r_dir           =     alb_improad_dir  * sdir_road
-          improad_r_sky_dir       = improad_r_dir * vf_sr(l)
-          improad_r_sunwall_dir   = improad_r_dir * vf_wr(l)
-          improad_r_shadewall_dir = improad_r_dir * vf_wr(l)
-          road_a_dir              = road_a_dir + improad_a_dir * wtroad_imperv
-          road_r_dir              = road_r_dir + improad_r_dir * wtroad_imperv
-
-          perroad_a_dir           = (1._r8-alb_perroad_dir) * sdir_road
-          perroad_r_dir           =     alb_perroad_dir * sdir_road
-          perroad_r_sky_dir       = perroad_r_dir * vf_sr(l)
-          perroad_r_sunwall_dir   = perroad_r_dir * vf_wr(l)
-          perroad_r_shadewall_dir = perroad_r_dir * vf_wr(l)
-          road_a_dir              = road_a_dir + perroad_a_dir * wtroad_perv
-          road_r_dir              = road_r_dir + perroad_r_dir * wtroad_perv
-
-          road_r_sky_dir          = road_r_dir * vf_sr(l)
-          road_r_sunwall_dir      = road_r_dir * vf_wr(l)
-          road_r_shadewall_dir    = road_r_dir * vf_wr(l)
-
-          sunwall_a_dir           = (1._r8-alb_wall_dir ) * sdir_sunwall
-          sunwall_r_dir           =     alb_wall_dir  * sdir_sunwall
-          sunwall_r_sky_dir       = sunwall_r_dir * vf_sw(l)
-          sunwall_r_road_dir      = sunwall_r_dir * vf_rw(l)
-          sunwall_r_shadewall_dir = sunwall_r_dir * vf_ww(l)
-
-          shadewall_a_dir         = (1._r8-alb_wall_dir) * sdir_shadewall
-          shadewall_r_dir         =     alb_wall_dir  * sdir_shadewall
-          shadewall_r_sky_dir     = shadewall_r_dir * vf_sw(l)
-          shadewall_r_road_dir    = shadewall_r_dir * vf_rw(l)
-          shadewall_r_sunwall_dir = shadewall_r_dir * vf_ww(l)
-
-          ! diffuse
-
-          road_a_dif              = 0.0_r8
-          road_r_dif              = 0.0_r8
-          improad_a_dif           = (1._r8-alb_improad_dif) * sdif_road
-          improad_r_dif           =     alb_improad_dif  * sdif_road
-          improad_r_sky_dif       = improad_r_dif * vf_sr(l)
-          improad_r_sunwall_dif   = improad_r_dif * vf_wr(l)
-          improad_r_shadewall_dif = improad_r_dif * vf_wr(l)
-          road_a_dif              = road_a_dif + improad_a_dif * wtroad_imperv
-          road_r_dif              = road_r_dif + improad_r_dif * wtroad_imperv
-
-          perroad_a_dif           = (1._r8-alb_perroad_dif) * sdif_road
-          perroad_r_dif           =     alb_perroad_dif  * sdif_road
-          perroad_r_sky_dif       = perroad_r_dif * vf_sr(l)
-          perroad_r_sunwall_dif   = perroad_r_dif * vf_wr(l)
-          perroad_r_shadewall_dif = perroad_r_dif * vf_wr(l)
-          road_a_dif              = road_a_dif + perroad_a_dif * wtroad_perv
-          road_r_dif              = road_r_dif + perroad_r_dif * wtroad_perv
-
-          road_r_sky_dif          = road_r_dif * vf_sr(l)
-          road_r_sunwall_dif      = road_r_dif * vf_wr(l)
-          road_r_shadewall_dif    = road_r_dif * vf_wr(l)
-
-          sunwall_a_dif           = (1._r8-alb_wall_dif) * sdif_sunwall
-          sunwall_r_dif           =     alb_wall_dif  * sdif_sunwall
-          sunwall_r_sky_dif       = sunwall_r_dif * vf_sw(l)
-          sunwall_r_road_dif      = sunwall_r_dif * vf_rw(l)
-          sunwall_r_shadewall_dif = sunwall_r_dif * vf_ww(l)
-
-          shadewall_a_dif         = (1._r8-alb_wall_dif) * sdif_shadewall
-          shadewall_r_dif         =     alb_wall_dif  * sdif_shadewall
-          shadewall_r_sky_dif     = shadewall_r_dif * vf_sw(l)
-          shadewall_r_road_dif    = shadewall_r_dif * vf_rw(l)
-          shadewall_r_sunwall_dif = shadewall_r_dif * vf_ww(l)
-
-          ! initialize sum of direct and diffuse solar absorption and reflection for road and both walls
-
-          sabs_improad_dir(l,ib)   = improad_a_dir
-          sabs_perroad_dir(l,ib)   = perroad_a_dir
-          sabs_sunwall_dir(l,ib)   = sunwall_a_dir
-          sabs_shadewall_dir(l,ib) = shadewall_a_dir
-
-          sabs_improad_dif(l,ib)   = improad_a_dif
-          sabs_perroad_dif(l,ib)   = perroad_a_dif
-          sabs_sunwall_dif(l,ib)   = sunwall_a_dif
-          sabs_shadewall_dif(l,ib) = shadewall_a_dif
-
-          sref_improad_dir   = improad_r_sky_dir
-          sref_perroad_dir   = perroad_r_sky_dir
-          sref_sunwall_dir   = sunwall_r_sky_dir
-          sref_shadewall_dir = shadewall_r_sky_dir
-
-          sref_improad_dif   = improad_r_sky_dif
-          sref_perroad_dif   = perroad_r_sky_dif
-          sref_sunwall_dif   = sunwall_r_sky_dif
-          sref_shadewall_dif = shadewall_r_sky_dif
-
+         end do
 
          ! absorption and reflection for walls and road with multiple reflections
-         ! (i.e., absorb and reflect initial reflection in canyon and allow for
+         ! (i.e., absorb and reflect initial reflection in canyon and allow for 
          ! subsequent scattering)
          !
          ! (1) absorption and reflection of scattered solar radiation
@@ -969,219 +1016,231 @@ contains
          !
          ! (4) add solar reflection to sky for ith reflection to total reflection
          !
-         ! (5) stop iteration when absorption for ith reflection is less than some nominal amount.
+         ! (5) stop iteration when absorption for ith reflection is less than some nominal amount. 
          !     small convergence criteria is required to ensure solar radiation is conserved
          !
          ! do separately for direct beam and diffuse
 
-         ! reflected direct beam
+         do fl = 1,num_urbanl
+            l = filter_urbanl(fl)
+            if (coszen(l) > 0._r8) then
 
-         do iter_dir = 1, n
-           ! step (1)
-           stot = (sunwall_r_road_dir + shadewall_r_road_dir) * canyon_hwr
-           !
-           road_a_dir = 0.0_r8
-           road_r_dir = 0.0_r8
-           improad_a_dir = (1._r8-alb_improad_dir) * stot
-           improad_r_dir =     alb_improad_dir  * stot
-           road_a_dir    = road_a_dir + improad_a_dir * wtroad_imperv
-           road_r_dir    = road_r_dir + improad_r_dir * wtroad_imperv
-           perroad_a_dir = (1._r8-alb_perroad_dir) * stot
-           perroad_r_dir =     alb_perroad_dir  * stot
-           road_a_dir    = road_a_dir + perroad_a_dir * wtroad_perv
-           road_r_dir    = road_r_dir + perroad_r_dir * wtroad_perv
+               ! reflected direct beam
 
-           stot = road_r_sunwall_dir/canyon_hwr + shadewall_r_sunwall_dir
-           sunwall_a_dir = (1._r8-alb_wall_dir) * stot
-           sunwall_r_dir =     alb_wall_dir * stot
+               do iter_dir = 1, n
+                  ! step (1)
 
-           stot = road_r_shadewall_dir/canyon_hwr + sunwall_r_shadewall_dir
-           shadewall_a_dir = (1._r8-alb_wall_dir) * stot
-           shadewall_r_dir =     alb_wall_dir  * stot
+                  stot(l) = (sunwall_r_road_dir(l) + shadewall_r_road_dir(l))*canyon_hwr(l)
 
-           ! step (2)
+                  road_a_dir(l) = 0.0_r8
+                  road_r_dir(l) = 0.0_r8
+                  improad_a_dir(l) = (1._r8-alb_improad_dir(l,ib)) * stot(l) 
+                  improad_r_dir(l) =     alb_improad_dir(l,ib)  * stot(l) 
+                  road_a_dir(l)    = road_a_dir(l) + improad_a_dir(l)*wtroad_imperv(l)
+                  road_r_dir(l)    = road_r_dir(l) + improad_r_dir(l)*wtroad_imperv(l)
+                  perroad_a_dir(l) = (1._r8-alb_perroad_dir(l,ib)) * stot(l) 
+                  perroad_r_dir(l) =     alb_perroad_dir(l,ib)  * stot(l) 
+                  road_a_dir(l)    = road_a_dir(l) + perroad_a_dir(l)*wtroad_perv(l)
+                  road_r_dir(l)    = road_r_dir(l) + perroad_r_dir(l)*wtroad_perv(l)
 
-           sabs_improad_dir(l,ib)   = sabs_improad_dir(l,ib)   + improad_a_dir
-           sabs_perroad_dir(l,ib)   = sabs_perroad_dir(l,ib)   + perroad_a_dir
-           sabs_sunwall_dir(l,ib)   = sabs_sunwall_dir(l,ib)   + sunwall_a_dir
-           sabs_shadewall_dir(l,ib) = sabs_shadewall_dir(l,ib) + shadewall_a_dir
+                  stot(l) = road_r_sunwall_dir(l)/canyon_hwr(l) + shadewall_r_sunwall_dir(l)
+                  sunwall_a_dir(l) = (1._r8-alb_wall_dir(l,ib)) * stot(l)
+                  sunwall_r_dir(l) =     alb_wall_dir(l,ib)  * stot(l)
 
-           ! step (3)
+                  stot(l) = road_r_shadewall_dir(l)/canyon_hwr(l) + sunwall_r_shadewall_dir(l)
+                  shadewall_a_dir(l) = (1._r8-alb_wall_dir(l,ib)) * stot(l)
+                  shadewall_r_dir(l) =     alb_wall_dir(l,ib)  * stot(l)
 
-           improad_r_sky_dir       = improad_r_dir * vf_sr(l)
-           improad_r_sunwall_dir   = improad_r_dir * vf_wr(l)
-           improad_r_shadewall_dir = improad_r_dir * vf_wr(l)
+                  ! step (2)
 
-           perroad_r_sky_dir       = perroad_r_dir * vf_sr(l)
-           perroad_r_sunwall_dir   = perroad_r_dir * vf_wr(l)
-           perroad_r_shadewall_dir = perroad_r_dir * vf_wr(l)
+                  sabs_improad_dir(l,ib)   = sabs_improad_dir(l,ib)   + improad_a_dir(l)
+                  sabs_perroad_dir(l,ib)   = sabs_perroad_dir(l,ib)   + perroad_a_dir(l)
+                  sabs_sunwall_dir(l,ib)   = sabs_sunwall_dir(l,ib)   + sunwall_a_dir(l)
+                  sabs_shadewall_dir(l,ib) = sabs_shadewall_dir(l,ib) + shadewall_a_dir(l)
 
-           road_r_sky_dir          = road_r_dir * vf_sr(l)
-           road_r_sunwall_dir      = road_r_dir * vf_wr(l)
-           road_r_shadewall_dir    = road_r_dir * vf_wr(l)
+                  ! step (3)
 
-           sunwall_r_sky_dir       = sunwall_r_dir * vf_sw(l)
-           sunwall_r_road_dir      = sunwall_r_dir * vf_rw(l)
-           sunwall_r_shadewall_dir = sunwall_r_dir * vf_ww(l)
+                  improad_r_sky_dir(l)       = improad_r_dir(l) * vf_sr(l)
+                  improad_r_sunwall_dir(l)   = improad_r_dir(l) * vf_wr(l)
+                  improad_r_shadewall_dir(l) = improad_r_dir(l) * vf_wr(l)
 
-           shadewall_r_sky_dir     = shadewall_r_dir * vf_sw(l)
-           shadewall_r_road_dir    = shadewall_r_dir * vf_rw(l)
-           shadewall_r_sunwall_dir = shadewall_r_dir * vf_ww(l)
+                  perroad_r_sky_dir(l)       = perroad_r_dir(l) * vf_sr(l)
+                  perroad_r_sunwall_dir(l)   = perroad_r_dir(l) * vf_wr(l)
+                  perroad_r_shadewall_dir(l) = perroad_r_dir(l) * vf_wr(l)
 
-           ! step (4)
+                  road_r_sky_dir(l)          = road_r_dir(l) * vf_sr(l)
+                  road_r_sunwall_dir(l)      = road_r_dir(l) * vf_wr(l)
+                  road_r_shadewall_dir(l)    = road_r_dir(l) * vf_wr(l)
 
-           sref_improad_dir   = sref_improad_dir + improad_r_sky_dir
-           sref_perroad_dir   = sref_perroad_dir + perroad_r_sky_dir
-           sref_sunwall_dir   = sref_sunwall_dir + sunwall_r_sky_dir
-           sref_shadewall_dir = sref_shadewall_dir + shadewall_r_sky_dir
+                  sunwall_r_sky_dir(l)       = sunwall_r_dir(l) * vf_sw(l)
+                  sunwall_r_road_dir(l)      = sunwall_r_dir(l) * vf_rw(l)
+                  sunwall_r_shadewall_dir(l) = sunwall_r_dir(l) * vf_ww(l)
 
-           ! step (5)
+                  shadewall_r_sky_dir(l)     = shadewall_r_dir(l) * vf_sw(l)
+                  shadewall_r_road_dir(l)    = shadewall_r_dir(l) * vf_rw(l)
+                  shadewall_r_sunwall_dir(l) = shadewall_r_dir(l) * vf_ww(l)
 
-           crit = max(road_a_dir, sunwall_a_dir, shadewall_a_dir)
-           if (crit < errcrit) exit
+                  ! step (4)
 
-         end do
-         if (iter_dir >= n) then
-           print *, 'urban net solar radiation error: no convergence, direct beam'
-           stop
-           !#py write (iulog,*) 'clm model is stopping'
-           !#py !#py call endrun(decomp_index=l, clmlevel=namel, msg=errmsg(__FILE__, __LINE__))
-         endif
-
-         ! reflected diffuse
-
-         do iter_dif = 1, n
-           ! step (1)
-
-           stot = (sunwall_r_road_dif + shadewall_r_road_dif ) * canyon_hwr
-           road_a_dif    = 0.0_r8
-           road_r_dif    = 0.0_r8
-           improad_a_dif = (1._r8-alb_improad_dif) * stot
-           improad_r_dif =     alb_improad_dif  * stot
-           road_a_dif    = road_a_dif + improad_a_dif * wtroad_imperv
-           road_r_dif    = road_r_dif + improad_r_dif * wtroad_imperv
-           perroad_a_dif = (1._r8-alb_perroad_dif) * stot
-           perroad_r_dif =     alb_perroad_dif  * stot
-           road_a_dif    = road_a_dif + perroad_a_dif * wtroad_perv
-           road_r_dif    = road_r_dif + perroad_r_dif * wtroad_perv
-
-           stot = road_r_sunwall_dif/canyon_hwr + shadewall_r_sunwall_dif
-           sunwall_a_dif = (1._r8-alb_wall_dif) * stot
-           sunwall_r_dif =     alb_wall_dif  * stot
-
-           stot = road_r_shadewall_dif/canyon_hwr + sunwall_r_shadewall_dif
-           shadewall_a_dif = (1._r8-alb_wall_dif) * stot
-           shadewall_r_dif =     alb_wall_dif  * stot
-
-           ! step (2)
-
-           sabs_improad_dif(l,ib)   = sabs_improad_dif(l,ib)   + improad_a_dif
-           sabs_perroad_dif(l,ib)   = sabs_perroad_dif(l,ib)   + perroad_a_dif
-           sabs_sunwall_dif(l,ib)   = sabs_sunwall_dif(l,ib)   + sunwall_a_dif
-           sabs_shadewall_dif(l,ib) = sabs_shadewall_dif(l,ib) + shadewall_a_dif
-
-           ! step (3)
-
-           improad_r_sky_dif        = improad_r_dif  * vf_sr(l)
-           improad_r_sunwall_dif    = improad_r_dif  * vf_wr(l)
-           improad_r_shadewall_dif  = improad_r_dif  * vf_wr(l)
-
-           perroad_r_sky_dif        = perroad_r_dif  * vf_sr(l)
-           perroad_r_sunwall_dif    = perroad_r_dif  * vf_wr(l)
-           perroad_r_shadewall_dif  = perroad_r_dif  * vf_wr(l)
-
-           road_r_sky_dif          = road_r_dif * vf_sr(l)
-           road_r_sunwall_dif      = road_r_dif * vf_wr(l)
-           road_r_shadewall_dif    = road_r_dif * vf_wr(l)
-
-           sunwall_r_sky_dif       = sunwall_r_dif * vf_sw(l)
-           sunwall_r_road_dif      = sunwall_r_dif * vf_rw(l)
-           sunwall_r_shadewall_dif = sunwall_r_dif * vf_ww(l)
-
-           shadewall_r_sky_dif     = shadewall_r_dif * vf_sw(l)
-           shadewall_r_road_dif    = shadewall_r_dif * vf_rw(l)
-           shadewall_r_sunwall_dif = shadewall_r_dif * vf_ww(l)
-
-           ! step (4)
-
-           sref_improad_dif   = sref_improad_dif  + improad_r_sky_dif
-           sref_perroad_dif   = sref_perroad_dif  + perroad_r_sky_dif
-           sref_sunwall_dif   = sref_sunwall_dif  + sunwall_r_sky_dif
-           sref_shadewall_dif = sref_shadewall_dif + shadewall_r_sky_dif
-
-           ! step (5)
-
-           crit = max(road_a_dif, sunwall_a_dif, shadewall_a_dif)
-           if (crit < errcrit) exit
-         end do
+                  sref_improad_dir(l,ib)   = sref_improad_dir(l,ib) + improad_r_sky_dir(l)
+                  sref_perroad_dir(l,ib)   = sref_perroad_dir(l,ib) + perroad_r_sky_dir(l)
+                  sref_sunwall_dir(l,ib)   = sref_sunwall_dir(l,ib) + sunwall_r_sky_dir(l)
+                  sref_shadewall_dir(l,ib) = sref_shadewall_dir(l,ib) + shadewall_r_sky_dir(l)
 
-         if (iter_dif >= n) then
-           print *, 'urban net solar radiation error: no convergence, diffuse'
-           stop
-           !#py write (iulog,*) 'clm model is stopping'
-           !#py !#py call endrun(decomp_index=l, clmlevel=namel, msg=errmsg(__FILE__, __LINE__))
-         endif
-
-         ! total reflected by canyon - sum of solar reflection to sky from canyon.
-         ! project wall fluxes to horizontal surface
-
-         sref_canyon_dir = 0.0_r8
-         sref_canyon_dif = 0.0_r8
-         sref_canyon_dir = sref_canyon_dir + sref_improad_dir * wtroad_imperv
-         sref_canyon_dif = sref_canyon_dif + sref_improad_dif * wtroad_imperv
-         sref_canyon_dir = sref_canyon_dir + sref_perroad_dir * wtroad_perv
-         sref_canyon_dif = sref_canyon_dif + sref_perroad_dif * wtroad_perv
-         sref_canyon_dir = sref_canyon_dir + (sref_sunwall_dir + sref_shadewall_dir)*canyon_hwr
-         sref_canyon_dif = sref_canyon_dif + (sref_sunwall_dif + sref_shadewall_dif)*canyon_hwr
-
-         ! total absorbed by canyon. project wall fluxes to horizontal surface
-
-         sabs_canyon_dir = 0.0_r8
-         sabs_canyon_dif = 0.0_r8
-         sabs_canyon_dir = sabs_canyon_dir + sabs_improad_dir(l,ib)*wtroad_imperv
-         sabs_canyon_dif = sabs_canyon_dif + sabs_improad_dif(l,ib)*wtroad_imperv
-         sabs_canyon_dir = sabs_canyon_dir + sabs_perroad_dir(l,ib)*wtroad_perv
-         sabs_canyon_dif = sabs_canyon_dif + sabs_perroad_dif(l,ib)*wtroad_perv
-         sabs_canyon_dir = sabs_canyon_dir + (sabs_sunwall_dir(l,ib) + sabs_shadewall_dir(l,ib))*canyon_hwr
-         sabs_canyon_dif = sabs_canyon_dif + (sabs_sunwall_dif(l,ib) + sabs_shadewall_dif(l,ib))*canyon_hwr
-
-         ! conservation check. note: previous conservation checks confirm partioning of total direct
-         ! beam and diffuse radiation from atmosphere to road and walls is conserved as
-         !    sdir (from atmosphere) = sdir_road + (sdir_sunwall + sdir_shadewall)*canyon_hwr
-         !    sdif (from atmosphere) = sdif_road + (sdif_sunwall + sdif_shadewall)*canyon_hwr
-
-         stot_dir = sdir_road + (sdir_sunwall + sdir_shadewall)*canyon_hwr
-         stot_dif = sdif_road + (sdif_sunwall + sdif_shadewall)*canyon_hwr
-         !
-         err = stot_dir + stot_dif &
-              - (sabs_canyon_dir + sabs_canyon_dif + sref_canyon_dir + sref_canyon_dif)
-         if (abs(err) > 0.001_r8 ) then
-                  print *, 'urban net solar radiation balance error for ib=',ib,' err= ',err
-                  stop
-                  !#py write(iulog,*)' l= ',l,' ib= ',ib
-                  !#py write(iulog,*)' stot_dir        = ',stot_dir(l)
-                  !#py write(iulog,*)' stot_dif        = ',stot_dif(l)
-                  !#py write(iulog,*)' sabs_canyon_dir = ',sabs_canyon_dir(l)
-                  !#py write(iulog,*)' sabs_canyon_dif = ',sabs_canyon_dif(l)
-                  !#py write(iulog,*)' sref_canyon_dir = ',sref_canyon_dir(l)
-                  !#py write(iulog,*)' sref_canyon_dif = ',sref_canyon_dir(l)
-                  !#py write(iulog,*) 'clm model is stopping'
-                  !#py !#py call endrun(decomp_index=l, clmlevel=namel, msg=errmsg(__FILE__, __LINE__))
-         endif
-
-         ! canyon albedo  -- Not Used ??
-         canyon_alb_dif = sref_canyon_dif / max(stot_dif, 1.e-06_r8)
-         canyon_alb_dir = sref_canyon_dir / max(stot_dir, 1.e-06_r8)
+                  ! step (5)
+
+                  crit = max(road_a_dir(l), sunwall_a_dir(l), shadewall_a_dir(l))
+                  if (crit < errcrit) exit
+               end do
+               if (iter_dir >= n) then
+                  write (iulog,*) 'urban net solar radiation error: no convergence, direct beam'
+                  write (iulog,*) 'elm model is stopping'
+                  call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
+               endif
+
+               ! reflected diffuse
+
+               do iter_dif = 1, n
+                  ! step (1)
 
+                  stot(l) = (sunwall_r_road_dif(l) + shadewall_r_road_dif(l))*canyon_hwr(l)
+                  road_a_dif(l)    = 0.0_r8
+                  road_r_dif(l)    = 0.0_r8
+                  improad_a_dif(l) = (1._r8-alb_improad_dif(l,ib)) * stot(l) 
+                  improad_r_dif(l) =     alb_improad_dif(l,ib)  * stot(l) 
+                  road_a_dif(l)    = road_a_dif(l) + improad_a_dif(l)*wtroad_imperv(l)
+                  road_r_dif(l)    = road_r_dif(l) + improad_r_dif(l)*wtroad_imperv(l)
+                  perroad_a_dif(l) = (1._r8-alb_perroad_dif(l,ib)) * stot(l) 
+                  perroad_r_dif(l) =     alb_perroad_dif(l,ib)  * stot(l) 
+                  road_a_dif(l)    = road_a_dif(l) + perroad_a_dif(l)*wtroad_perv(l)
+                  road_r_dif(l)    = road_r_dif(l) + perroad_r_dif(l)*wtroad_perv(l)
+
+                  stot(l) = road_r_sunwall_dif(l)/canyon_hwr(l) + shadewall_r_sunwall_dif(l)
+                  sunwall_a_dif(l) = (1._r8-alb_wall_dif(l,ib)) * stot(l)
+                  sunwall_r_dif(l) =     alb_wall_dif(l,ib)  * stot(l)
+
+                  stot(l) = road_r_shadewall_dif(l)/canyon_hwr(l) + sunwall_r_shadewall_dif(l)
+                  shadewall_a_dif(l) = (1._r8-alb_wall_dif(l,ib)) * stot(l)
+                  shadewall_r_dif(l) =     alb_wall_dif(l,ib)  * stot(l)
+
+                  ! step (2)
+
+                  sabs_improad_dif(l,ib)   = sabs_improad_dif(l,ib)   + improad_a_dif(l)
+                  sabs_perroad_dif(l,ib)   = sabs_perroad_dif(l,ib)   + perroad_a_dif(l)
+                  sabs_sunwall_dif(l,ib)   = sabs_sunwall_dif(l,ib)   + sunwall_a_dif(l)
+                  sabs_shadewall_dif(l,ib) = sabs_shadewall_dif(l,ib) + shadewall_a_dif(l)
+
+                  ! step (3)
+
+                  improad_r_sky_dif(l)       = improad_r_dif(l) * vf_sr(l)
+                  improad_r_sunwall_dif(l)   = improad_r_dif(l) * vf_wr(l)
+                  improad_r_shadewall_dif(l) = improad_r_dif(l) * vf_wr(l)
+
+                  perroad_r_sky_dif(l)       = perroad_r_dif(l) * vf_sr(l)
+                  perroad_r_sunwall_dif(l)   = perroad_r_dif(l) * vf_wr(l)
+                  perroad_r_shadewall_dif(l) = perroad_r_dif(l) * vf_wr(l)
+
+                  road_r_sky_dif(l)          = road_r_dif(l) * vf_sr(l)
+                  road_r_sunwall_dif(l)      = road_r_dif(l) * vf_wr(l)
+                  road_r_shadewall_dif(l)    = road_r_dif(l) * vf_wr(l)
+
+                  sunwall_r_sky_dif(l)       = sunwall_r_dif(l) * vf_sw(l)
+                  sunwall_r_road_dif(l)      = sunwall_r_dif(l) * vf_rw(l)
+                  sunwall_r_shadewall_dif(l) = sunwall_r_dif(l) * vf_ww(l)
+
+                  shadewall_r_sky_dif(l)     = shadewall_r_dif(l) * vf_sw(l)
+                  shadewall_r_road_dif(l)    = shadewall_r_dif(l) * vf_rw(l)
+                  shadewall_r_sunwall_dif(l) = shadewall_r_dif(l) * vf_ww(l)
+
+                  ! step (4)
+
+                  sref_improad_dif(l,ib)   = sref_improad_dif(l,ib)   + improad_r_sky_dif(l)
+                  sref_perroad_dif(l,ib)   = sref_perroad_dif(l,ib)   + perroad_r_sky_dif(l)
+                  sref_sunwall_dif(l,ib)   = sref_sunwall_dif(l,ib)   + sunwall_r_sky_dif(l)
+                  sref_shadewall_dif(l,ib) = sref_shadewall_dif(l,ib) + shadewall_r_sky_dif(l)
+
+                  ! step (5)
+
+                  crit = max(road_a_dif(l), sunwall_a_dif(l), shadewall_a_dif(l))
+                  if (crit < errcrit) exit
+               end do
+               if (iter_dif >= n) then
+                  write (iulog,*) 'urban net solar radiation error: no convergence, diffuse'
+                  write (iulog,*) 'elm model is stopping'
+                  call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
+               endif
+
+               ! total reflected by canyon - sum of solar reflection to sky from canyon.
+               ! project wall fluxes to horizontal surface
+
+               sref_canyon_dir(l) = 0.0_r8
+               sref_canyon_dif(l) = 0.0_r8
+               sref_canyon_dir(l) = sref_canyon_dir(l) + sref_improad_dir(l,ib)*wtroad_imperv(l)
+               sref_canyon_dif(l) = sref_canyon_dif(l) + sref_improad_dif(l,ib)*wtroad_imperv(l)
+               sref_canyon_dir(l) = sref_canyon_dir(l) + sref_perroad_dir(l,ib)*wtroad_perv(l)
+               sref_canyon_dif(l) = sref_canyon_dif(l) + sref_perroad_dif(l,ib)*wtroad_perv(l)
+               sref_canyon_dir(l) = sref_canyon_dir(l) + (sref_sunwall_dir(l,ib) + sref_shadewall_dir(l,ib))*canyon_hwr(l)
+               sref_canyon_dif(l) = sref_canyon_dif(l) + (sref_sunwall_dif(l,ib) + sref_shadewall_dif(l,ib))*canyon_hwr(l)
+
+               ! total absorbed by canyon. project wall fluxes to horizontal surface
+
+               sabs_canyon_dir(l) = 0.0_r8
+               sabs_canyon_dif(l) = 0.0_r8
+               sabs_canyon_dir(l) = sabs_canyon_dir(l) + sabs_improad_dir(l,ib)*wtroad_imperv(l)
+               sabs_canyon_dif(l) = sabs_canyon_dif(l) + sabs_improad_dif(l,ib)*wtroad_imperv(l)
+               sabs_canyon_dir(l) = sabs_canyon_dir(l) + sabs_perroad_dir(l,ib)*wtroad_perv(l)
+               sabs_canyon_dif(l) = sabs_canyon_dif(l) + sabs_perroad_dif(l,ib)*wtroad_perv(l)
+               sabs_canyon_dir(l) = sabs_canyon_dir(l) + (sabs_sunwall_dir(l,ib) + sabs_shadewall_dir(l,ib))*canyon_hwr(l)
+               sabs_canyon_dif(l) = sabs_canyon_dif(l) + (sabs_sunwall_dif(l,ib) + sabs_shadewall_dif(l,ib))*canyon_hwr(l)
+
+               ! conservation check. note: previous conservation checks confirm partioning of total direct
+               ! beam and diffuse radiation from atmosphere to road and walls is conserved as
+               !    sdir (from atmosphere) = sdir_road + (sdir_sunwall + sdir_shadewall)*canyon_hwr
+               !    sdif (from atmosphere) = sdif_road + (sdif_sunwall + sdif_shadewall)*canyon_hwr
+
+               stot_dir(l) = sdir_road(l,ib) + (sdir_sunwall(l,ib) + sdir_shadewall(l,ib))*canyon_hwr(l)
+               stot_dif(l) = sdif_road(l,ib) + (sdif_sunwall(l,ib) + sdif_shadewall(l,ib))*canyon_hwr(l)
+
+               err = stot_dir(l) + stot_dif(l) &
+                    - (sabs_canyon_dir(l) + sabs_canyon_dif(l) + sref_canyon_dir(l) + sref_canyon_dif(l))
+               if (abs(err) > 0.001_r8 ) then
+                  write(iulog,*)'urban net solar radiation balance error for ib=',ib,' err= ',err
+                  write(iulog,*)' l= ',l,' ib= ',ib 
+                  write(iulog,*)' stot_dir        = ',stot_dir(l)
+                  write(iulog,*)' stot_dif        = ',stot_dif(l)
+                  write(iulog,*)' sabs_canyon_dir = ',sabs_canyon_dir(l)
+                  write(iulog,*)' sabs_canyon_dif = ',sabs_canyon_dif(l)
+                  write(iulog,*)' sref_canyon_dir = ',sref_canyon_dir(l)
+                  write(iulog,*)' sref_canyon_dif = ',sref_canyon_dir(l)
+                  write(iulog,*) 'elm model is stopping'
+                  call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
+               endif
+
+               ! canyon albedo
+
+               canyon_alb_dif(l) = sref_canyon_dif(l) / max(stot_dif(l), 1.e-06_r8)
+               canyon_alb_dir(l) = sref_canyon_dir(l) / max(stot_dir(l), 1.e-06_r8)
+            end if
+
+         end do   ! end of landunit loop
 
          ! Refected and absorbed solar radiation per unit incident radiation for roof
-         sref_roof_dir = alb_roof_dir * sdir
-         sref_roof_dif = alb_roof_dif * sdir
-         sabs_roof_dir(l,ib) = sdir - sref_roof_dir
-         sabs_roof_dif(l,ib) = sdif - sref_roof_dif
+
+         do fl = 1,num_urbanl
+            l = filter_urbanl(fl)
+            if (coszen(l) > 0._r8) then
+               sref_roof_dir(l,ib) = alb_roof_dir(l,ib) * sdir(l,ib)
+               sref_roof_dif(l,ib) = alb_roof_dif(l,ib) * sdif(l,ib)
+               sabs_roof_dir(l,ib) = sdir(l,ib) - sref_roof_dir(l,ib)
+               sabs_roof_dif(l,ib) = sdif(l,ib) - sref_roof_dif(l,ib)
+            end if
+         end do
+
+      end do   ! end of radiation band loop
 
     end associate
 
   end subroutine net_solar
 
 end module UrbanAlbedoMod
+
diff --git a/components/elm/src/biogeophys/UrbanFluxesMod.F90 b/components/elm/src/biogeophys/UrbanFluxesMod.F90
index 5a12848201..fe8039f94b 100644
--- a/components/elm/src/biogeophys/UrbanFluxesMod.F90
+++ b/components/elm/src/biogeophys/UrbanFluxesMod.F90
@@ -14,7 +14,7 @@ module UrbanFluxesMod
   use elm_varctl           , only : iulog
   use abortutils           , only : endrun
   use UrbanParamsType      , only : urbanparams_type
-  use UrbanParamsType      , only : urban_wasteheat_int, urban_hac_on_int, urban_hac_int,urban_hac_off_int
+  use UrbanParamsType      , only : urban_wasteheat_on, urban_hac_on, urban_hac
   use atm2lndType          , only : atm2lnd_type
   use SoilStateType        , only : soilstate_type
   use FrictionVelocityType , only : frictionvel_type
@@ -30,7 +30,7 @@ module UrbanFluxesMod
   use VegetationDataType   , only : veg_es, veg_ef, veg_ws, veg_wf
   use clm_time_manager    , only : get_curr_date, get_step_size, get_nstep
 
-  use timeinfoMod  , only : nstep_mod,  secs_curr
+  use timeinfoMod  , only : nstep_mod, year_curr, mon_curr, day_curr, secs_curr
   use timeinfoMod  , only : dtime_mod
 
   !
@@ -46,129 +46,140 @@ module UrbanFluxesMod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine UrbanFluxes (bounds,       &
+  subroutine UrbanFluxes (bounds, num_nourbanl, filter_nourbanl,                        &
        num_urbanl, filter_urbanl, num_urbanc, filter_urbanc, num_urbanp, filter_urbanp, &
-       urbanparams_vars, soilstate_vars,    &
-      frictionvel_vars )
+       atm2lnd_vars, urbanparams_vars, soilstate_vars,    &
+      frictionvel_vars, energyflux_vars )
     !
     ! !DESCRIPTION:
     ! Turbulent and momentum fluxes from urban canyon (consisting of roof, sunwall,
     ! shadewall, pervious and impervious road).
 
     ! !USES:
+      !$acc routine seq
+    
     use shr_flux_mod         , only : shr_flux_update_stress
     use elm_varcon          , only : cpair, vkc, spval, grav, pondmx_urban, rpi, rgas
     use elm_varcon          , only : ht_wasteheat_factor, ac_wasteheat_factor, wasteheat_limit
     use column_varcon       , only : icol_shadewall, icol_road_perv, icol_road_imperv
     use column_varcon       , only : icol_roof, icol_sunwall
     use filterMod           , only : filter
-    use FrictionVelocityMod , only : FrictionVelocity_loops, MoninObukIni, implicit_stress
+    use FrictionVelocityMod , only : FrictionVelocity, MoninObukIni, implicit_stress
     use QSatMod             , only : QSat
     use elm_varpar          , only : maxpatch_urb, nlevurb, nlevgrnd
     use elm_varctl          , only : use_vsfm
     !
     ! !ARGUMENTS:
     type(bounds_type)      , intent(in)    :: bounds
+    integer                , intent(in)    :: num_nourbanl       ! number of non-urban landunits in clump
+    integer                , intent(in)    :: filter_nourbanl(:) ! non-urban landunit filter
     integer                , intent(in)    :: num_urbanl         ! number of urban landunits in clump
     integer                , intent(in)    :: filter_urbanl(:)   ! urban landunit filter
     integer                , intent(in)    :: num_urbanc         ! number of urban columns in clump
     integer                , intent(in)    :: filter_urbanc(:)   ! urban column filter
     integer                , intent(in)    :: num_urbanp         ! number of urban patches in clump
     integer                , intent(in)    :: filter_urbanp(:)   ! urban pft filter
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(urbanparams_type) , intent(in)    :: urbanparams_vars
     type(soilstate_type)   , intent(inout) :: soilstate_vars
     type(frictionvel_type) , intent(inout) :: frictionvel_vars
+    type(energyflux_type)  , intent(inout) :: energyflux_vars
+    real(r8) :: dtime                                                ! land model time step (sec)
+    integer  :: year,month,day,secs
     !
     ! !LOCAL VARIABLES:
     integer  :: fp,fc,fl,f,p,c,l,t,g,j,pi,i     ! indices
 
-    integer  :: num_copyl                                ! iteration num_urbanl
-    integer  :: num_copyl_old                            ! previous iteration num_copyl
-    integer  :: num_copyc                                ! iteration num_urbanc
-    integer  :: num_copyc_old                            ! previous iteration num_copyc
-    integer  :: num_unconverged  
-
-    real(r8) :: canyontop_wind(1:num_urbanl)              ! wind at canyon top (m/s)
-    real(r8) :: canyon_u_wind(1:num_urbanl)               ! u-component of wind speed inside canyon (m/s)
-    real(r8) :: canyon_wind(1:num_urbanl)                 ! net wind speed inside canyon (m/s)
-    real(r8) :: canyon_resistance(1:num_urbanl)           ! resistance to heat and moisture transfer from canyon road/walls to canyon air (s/m)
-
-    real(r8) :: ur(1:num_urbanl)                          ! wind speed at reference height (m/s)
-    real(r8) :: ustar(1:num_urbanl)                       ! friction velocity (m/s)
-    real(r8) :: ramu(1:num_urbanl)                        ! aerodynamic resistance (s/m)
-    real(r8) :: rahu(1:num_urbanl)                        ! thermal resistance (s/m)
-    real(r8) :: rawu(1:num_urbanl)                        ! moisture resistance (s/m)
-    real(r8) :: temp1(1:num_urbanl)                       ! relation for potential temperature profile
-    real(r8) :: temp12m(1:num_urbanl)                     ! relation for potential temperature profile applied at 2-m
-    real(r8) :: temp2(1:num_urbanl)                       ! relation for specific humidity profile
-    real(r8) :: temp22m(1:num_urbanl)                     ! relation for specific humidity profile applied at 2-m
-    real(r8) :: thm_g(1:num_urbanl)                       ! intermediate variable (forc_t+0.0098*forc_hgt_t)
-    real(r8) :: thv_g(1:num_urbanl)                       ! virtual potential temperature (K)
-    real(r8) :: dth(1:num_urbanl)                         ! diff of virtual temp. between ref. height and surface
-    real(r8) :: dqh(1:num_urbanl)                         ! diff of humidity between ref. height and surface
-    real(r8) :: zldis(1:num_urbanl)                       ! reference height "minus" zero displacement height (m)
-    real(r8) :: um(1:num_urbanl)                          ! wind speed including the stablity effect (m/s)
-    real(r8) :: obu(1:num_urbanl)                         ! Monin-Obukhov length (m)
-    real(r8) :: taf_numer(1:num_urbanl)                   ! numerator of taf equation (K m/s)
-    real(r8) :: taf_denom(1:num_urbanl)                   ! denominator of taf equation (m/s)
-    real(r8) :: qaf_numer(1:num_urbanl)                   ! numerator of qaf equation (kg m/kg s)
-    real(r8) :: qaf_denom(1:num_urbanl)                   ! denominator of qaf equation (m/s)
-    real(r8) :: wtas(1:num_urbanl)                        ! sensible heat conductance for urban air to atmospheric air (m/s)
-    real(r8) :: wtaq(1:num_urbanl)                        ! latent heat conductance for urban air to atmospheric air (m/s)
-    real(r8) :: wts_sum(1:num_urbanl)                     ! sum of wtas, wtus_roof, wtus_road_perv, wtus_road_imperv, wtus_sunwall, wtus_shadewall
-    real(r8) :: wtq_sum(1:num_urbanl)                     ! sum of wtaq, wtuq_roof, wtuq_road_perv, wtuq_road_imperv, wtuq_sunwall, wtuq_shadewall
-    real(r8) :: fm(1:num_urbanl)                          ! needed for BGC only to diagnose 10m wind speed
-    real(r8) :: wtus(1:num_urbanc)                        ! sensible heat conductance for urban columns (scaled) (m/s)
-    real(r8) :: wtuq(1:num_urbanc)                        ! latent heat conductance for urban columns (scaled) (m/s)
+    integer  :: filterl_copy(num_urbanl)                ! iteration copy of filter_urbanl
+    integer  :: filterc_copy(num_urbanc)                ! iteration copy of filter_urbanc
+    integer  :: fnl_iter                                ! iteration num_urbanl
+    integer  :: fnl_iter_old                            ! previous iteration fnl_iter
+    integer  :: fnc_iter                                ! iteration num_urbanc
+    integer  :: fnc_iter_old                            ! previous iteration fnc_iter
+
+    real(r8) :: canyontop_wind(bounds%begl:bounds%endl)              ! wind at canyon top (m/s) 
+    real(r8) :: canyon_u_wind(bounds%begl:bounds%endl)               ! u-component of wind speed inside canyon (m/s)
+    real(r8) :: canyon_wind(bounds%begl:bounds%endl)                 ! net wind speed inside canyon (m/s)
+    real(r8) :: canyon_resistance(bounds%begl:bounds%endl)           ! resistance to heat and moisture transfer from canyon road/walls to canyon air (s/m)
+
+    real(r8) :: ur(bounds%begl:bounds%endl)                          ! wind speed at reference height (m/s)
+    real(r8) :: ustar(bounds%begl:bounds%endl)                       ! friction velocity (m/s)
+    real(r8) :: ramu(bounds%begl:bounds%endl)                        ! aerodynamic resistance (s/m)
+    real(r8) :: rahu(bounds%begl:bounds%endl)                        ! thermal resistance (s/m)
+    real(r8) :: rawu(bounds%begl:bounds%endl)                        ! moisture resistance (s/m)
+    real(r8) :: temp1(bounds%begl:bounds%endl)                       ! relation for potential temperature profile
+    real(r8) :: temp12m(bounds%begl:bounds%endl)                     ! relation for potential temperature profile applied at 2-m
+    real(r8) :: temp2(bounds%begl:bounds%endl)                       ! relation for specific humidity profile
+    real(r8) :: temp22m(bounds%begl:bounds%endl)                     ! relation for specific humidity profile applied at 2-m
+    real(r8) :: thm_g(bounds%begl:bounds%endl)                       ! intermediate variable (forc_t+0.0098*forc_hgt_t)
+    real(r8) :: thv_g(bounds%begl:bounds%endl)                       ! virtual potential temperature (K)
+    real(r8) :: dth(bounds%begl:bounds%endl)                         ! diff of virtual temp. between ref. height and surface
+    real(r8) :: dqh(bounds%begl:bounds%endl)                         ! diff of humidity between ref. height and surface
+    real(r8) :: zldis(bounds%begl:bounds%endl)                       ! reference height "minus" zero displacement height (m)
+    real(r8) :: um(bounds%begl:bounds%endl)                          ! wind speed including the stablity effect (m/s)
+    real(r8) :: obu(bounds%begl:bounds%endl)                         ! Monin-Obukhov length (m)
+    real(r8) :: taf_numer(bounds%begl:bounds%endl)                   ! numerator of taf equation (K m/s)
+    real(r8) :: taf_denom(bounds%begl:bounds%endl)                   ! denominator of taf equation (m/s)
+    real(r8) :: qaf_numer(bounds%begl:bounds%endl)                   ! numerator of qaf equation (kg m/kg s)
+    real(r8) :: qaf_denom(bounds%begl:bounds%endl)                   ! denominator of qaf equation (m/s)
+    real(r8) :: wtas(bounds%begl:bounds%endl)                        ! sensible heat conductance for urban air to atmospheric air (m/s)
+    real(r8) :: wtaq(bounds%begl:bounds%endl)                        ! latent heat conductance for urban air to atmospheric air (m/s)
+    real(r8) :: wts_sum(bounds%begl:bounds%endl)                     ! sum of wtas, wtus_roof, wtus_road_perv, wtus_road_imperv, wtus_sunwall, wtus_shadewall
+    real(r8) :: wtq_sum(bounds%begl:bounds%endl)                     ! sum of wtaq, wtuq_roof, wtuq_road_perv, wtuq_road_imperv, wtuq_sunwall, wtuq_shadewall
+    real(r8) :: beta(bounds%begl:bounds%endl)                        ! coefficient of convective velocity
+    real(r8) :: zii(bounds%begl:bounds%endl)                         ! convective boundary layer height (m)
+    real(r8) :: fm(bounds%begl:bounds%endl)                          ! needed for BGC only to diagnose 10m wind speed
+    real(r8) :: wtus(bounds%begc:bounds%endc)                        ! sensible heat conductance for urban columns (scaled) (m/s)
+    real(r8) :: wtuq(bounds%begc:bounds%endc)                        ! latent heat conductance for urban columns (scaled) (m/s)
     integer  :: iter                                                 ! iteration index
     integer  :: iter_final                                           ! number of iterations used
     real(r8) :: dthv                                                 ! diff of vir. poten. temp. between ref. height and surface
     real(r8) :: tstar                                                ! temperature scaling parameter
     real(r8) :: qstar                                                ! moisture scaling parameter
     real(r8) :: thvstar                                              ! virtual potential temperature scaling parameter
-    real(r8) :: wtus_roof(1:num_urbanl)                   ! sensible heat conductance for roof (scaled) (m/s)
-    real(r8) :: wtuq_roof(1:num_urbanl)                   ! latent heat conductance for roof (scaled) (m/s)
-    real(r8) :: wtus_road_perv(1:num_urbanl)              ! sensible heat conductance for pervious road (scaled) (m/s)
-    real(r8) :: wtuq_road_perv(1:num_urbanl)              ! latent heat conductance for pervious road (scaled) (m/s)
-    real(r8) :: wtus_road_imperv(1:num_urbanl)            ! sensible heat conductance for impervious road (scaled) (m/s)
-    real(r8) :: wtuq_road_imperv(1:num_urbanl)            ! latent heat conductance for impervious road (scaled) (m/s)
-    real(r8) :: wtus_sunwall(1:num_urbanl)                ! sensible heat conductance for sunwall (scaled) (m/s)
-    real(r8) :: wtuq_sunwall(1:num_urbanl)                ! latent heat conductance for sunwall (scaled) (m/s)
-    real(r8) :: wtus_shadewall(1:num_urbanl)              ! sensible heat conductance for shadewall (scaled) (m/s)
-    real(r8) :: wtuq_shadewall(1:num_urbanl)              ! latent heat conductance for shadewall (scaled) (m/s)
-    real(r8) :: wtus_roof_unscl(1:num_urbanl)             ! sensible heat conductance for roof (not scaled) (m/s)
-    real(r8) :: wtuq_roof_unscl(1:num_urbanl)             ! latent heat conductance for roof (not scaled) (m/s)
-    real(r8) :: wtus_road_perv_unscl(1:num_urbanl)        ! sensible heat conductance for pervious road (not scaled) (m/s)
-    real(r8) :: wtuq_road_perv_unscl(1:num_urbanl)        ! latent heat conductance for pervious road (not scaled) (m/s)
-    real(r8) :: wtus_road_imperv_unscl(1:num_urbanl)      ! sensible heat conductance for impervious road (not scaled) (m/s)
-    real(r8) :: wtuq_road_imperv_unscl(1:num_urbanl)      ! latent heat conductance for impervious road (not scaled) (m/s)
-    real(r8) :: wtus_sunwall_unscl(1:num_urbanl)          ! sensible heat conductance for sunwall (not scaled) (m/s)
-    real(r8) :: wtuq_sunwall_unscl(1:num_urbanl)          ! latent heat conductance for sunwall (not scaled) (m/s)
-    real(r8) :: wtus_shadewall_unscl(1:num_urbanl)        ! sensible heat conductance for shadewall (not scaled) (m/s)
-    real(r8) :: wtuq_shadewall_unscl(1:num_urbanl)        ! latent heat conductance for shadewall (not scaled) (m/s)
-    real(r8) :: t_sunwall_innerl(1:num_urbanl)            ! temperature of inner layer of sunwall (K)
-    real(r8) :: t_shadewall_innerl(1:num_urbanl)          ! temperature of inner layer of shadewall (K)
-    real(r8) :: t_roof_innerl(1:num_urbanl)               ! temperature of inner layer of roof (K)
+    real(r8) :: wtus_roof(bounds%begl:bounds%endl)                   ! sensible heat conductance for roof (scaled) (m/s)
+    real(r8) :: wtuq_roof(bounds%begl:bounds%endl)                   ! latent heat conductance for roof (scaled) (m/s)
+    real(r8) :: wtus_road_perv(bounds%begl:bounds%endl)              ! sensible heat conductance for pervious road (scaled) (m/s)
+    real(r8) :: wtuq_road_perv(bounds%begl:bounds%endl)              ! latent heat conductance for pervious road (scaled) (m/s)
+    real(r8) :: wtus_road_imperv(bounds%begl:bounds%endl)            ! sensible heat conductance for impervious road (scaled) (m/s)
+    real(r8) :: wtuq_road_imperv(bounds%begl:bounds%endl)            ! latent heat conductance for impervious road (scaled) (m/s)
+    real(r8) :: wtus_sunwall(bounds%begl:bounds%endl)                ! sensible heat conductance for sunwall (scaled) (m/s)
+    real(r8) :: wtuq_sunwall(bounds%begl:bounds%endl)                ! latent heat conductance for sunwall (scaled) (m/s)
+    real(r8) :: wtus_shadewall(bounds%begl:bounds%endl)              ! sensible heat conductance for shadewall (scaled) (m/s)
+    real(r8) :: wtuq_shadewall(bounds%begl:bounds%endl)              ! latent heat conductance for shadewall (scaled) (m/s)
+    real(r8) :: wtus_roof_unscl(bounds%begl:bounds%endl)             ! sensible heat conductance for roof (not scaled) (m/s)
+    real(r8) :: wtuq_roof_unscl(bounds%begl:bounds%endl)             ! latent heat conductance for roof (not scaled) (m/s)
+    real(r8) :: wtus_road_perv_unscl(bounds%begl:bounds%endl)        ! sensible heat conductance for pervious road (not scaled) (m/s)
+    real(r8) :: wtuq_road_perv_unscl(bounds%begl:bounds%endl)        ! latent heat conductance for pervious road (not scaled) (m/s)
+    real(r8) :: wtus_road_imperv_unscl(bounds%begl:bounds%endl)      ! sensible heat conductance for impervious road (not scaled) (m/s)
+    real(r8) :: wtuq_road_imperv_unscl(bounds%begl:bounds%endl)      ! latent heat conductance for impervious road (not scaled) (m/s)
+    real(r8) :: wtus_sunwall_unscl(bounds%begl:bounds%endl)          ! sensible heat conductance for sunwall (not scaled) (m/s)
+    real(r8) :: wtuq_sunwall_unscl(bounds%begl:bounds%endl)          ! latent heat conductance for sunwall (not scaled) (m/s)
+    real(r8) :: wtus_shadewall_unscl(bounds%begl:bounds%endl)        ! sensible heat conductance for shadewall (not scaled) (m/s)
+    real(r8) :: wtuq_shadewall_unscl(bounds%begl:bounds%endl)        ! latent heat conductance for shadewall (not scaled) (m/s)
+    real(r8) :: t_sunwall_innerl(bounds%begl:bounds%endl)            ! temperature of inner layer of sunwall (K)
+    real(r8) :: t_shadewall_innerl(bounds%begl:bounds%endl)          ! temperature of inner layer of shadewall (K)
+    real(r8) :: t_roof_innerl(bounds%begl:bounds%endl)               ! temperature of inner layer of roof (K)
     real(r8) :: lngth_roof                                           ! length of roof (m)
     real(r8) :: wc                                                   ! convective velocity (m/s)
     real(r8) :: zeta                                                 ! dimensionless height used in Monin-Obukhov theory
     real(r8) :: eflx_sh_grnd_scale(bounds%begp:bounds%endp)          ! scaled sensible heat flux from ground (W/m**2) [+ to atm]
     real(r8) :: qflx_evap_soi_scale(bounds%begp:bounds%endp)         ! scaled soil evaporation (mm H2O/s) (+ = to atm)
-    real(r8) :: eflx_wasteheat_roof(1:num_urbanl)         ! sensible heat flux from urban heating/cooling sources of waste heat for roof (W/m**2)
-    real(r8) :: eflx_wasteheat_sunwall(1:num_urbanl)      ! sensible heat flux from urban heating/cooling sources of waste heat for sunwall (W/m**2)
-    real(r8) :: eflx_wasteheat_shadewall(1:num_urbanl)    ! sensible heat flux from urban heating/cooling sources of waste heat for shadewall (W/m**2)
-    real(r8) :: eflx_heat_from_ac_roof(1:num_urbanl)      ! sensible heat flux put back into canyon due to heat removal by AC for roof (W/m**2)
-    real(r8) :: eflx_heat_from_ac_sunwall(1:num_urbanl)   ! sensible heat flux put back into canyon due to heat removal by AC for sunwall (W/m**2)
-    real(r8) :: eflx_heat_from_ac_shadewall(1:num_urbanl) ! sensible heat flux put back into canyon due to heat removal by AC for shadewall (W/m**2)
-    real(r8) :: eflx(1:num_urbanl)                        ! total sensible heat flux for error check (W/m**2)
-    real(r8) :: qflx(1:num_urbanl)                        ! total water vapor flux for error check (kg/m**2/s)
-    real(r8) :: eflx_scale(1:num_urbanl)                  ! sum of scaled sensible heat fluxes for urban columns for error check (W/m**2)
-    real(r8) :: qflx_scale(1:num_urbanl)                  ! sum of scaled water vapor fluxes for urban columns for error check (kg/m**2/s)
-    real(r8) :: eflx_err(1:num_urbanl)                    ! sensible heat flux error (W/m**2)
-    real(r8) :: qflx_err(1:num_urbanl)                    ! water vapor flux error (kg/m**2/s)
+    real(r8) :: eflx_wasteheat_roof(bounds%begl:bounds%endl)         ! sensible heat flux from urban heating/cooling sources of waste heat for roof (W/m**2)
+    real(r8) :: eflx_wasteheat_sunwall(bounds%begl:bounds%endl)      ! sensible heat flux from urban heating/cooling sources of waste heat for sunwall (W/m**2)
+    real(r8) :: eflx_wasteheat_shadewall(bounds%begl:bounds%endl)    ! sensible heat flux from urban heating/cooling sources of waste heat for shadewall (W/m**2)
+    real(r8) :: eflx_heat_from_ac_roof(bounds%begl:bounds%endl)      ! sensible heat flux put back into canyon due to heat removal by AC for roof (W/m**2)
+    real(r8) :: eflx_heat_from_ac_sunwall(bounds%begl:bounds%endl)   ! sensible heat flux put back into canyon due to heat removal by AC for sunwall (W/m**2)
+    real(r8) :: eflx_heat_from_ac_shadewall(bounds%begl:bounds%endl) ! sensible heat flux put back into canyon due to heat removal by AC for shadewall (W/m**2)
+    real(r8) :: eflx(bounds%begl:bounds%endl)                        ! total sensible heat flux for error check (W/m**2)
+    real(r8) :: qflx(bounds%begl:bounds%endl)                        ! total water vapor flux for error check (kg/m**2/s)
+    real(r8) :: eflx_scale(bounds%begl:bounds%endl)                  ! sum of scaled sensible heat fluxes for urban columns for error check (W/m**2)
+    real(r8) :: qflx_scale(bounds%begl:bounds%endl)                  ! sum of scaled water vapor fluxes for urban columns for error check (kg/m**2/s)
+    real(r8) :: eflx_err(bounds%begl:bounds%endl)                    ! sensible heat flux error (W/m**2)
+    real(r8) :: qflx_err(bounds%begl:bounds%endl)                    ! water vapor flux error (kg/m**2/s)
     real(r8) :: fwet_roof                                            ! fraction of roof surface that is wet (-)
     real(r8) :: fwet_road_imperv                                     ! fraction of impervious road surface that is wet (-)
-    integer  :: local_secp1(1:num_urbanl)                 ! seconds into current date in local time (sec)
+    integer  :: local_secp1(bounds%begl:bounds%endl)                 ! seconds into current date in local time (sec)
                                      ! calendar info for current time step
     logical  :: found                                                ! flag in search loop
     integer  :: indexl                                               ! index of first found in search loop
@@ -183,39 +194,31 @@ contains
     integer, parameter  :: itmin = 3              ! minimum number of iterations
     integer, parameter  :: itmax = 30             ! maximum number of iterations
     integer  :: loopmax                           ! bound for iteration loop
-    real(r8) :: wind_speed0(1:num_urbanl) ! Wind speed from atmosphere at start of iteration
-    real(r8) :: wind_speed_adj(1:num_urbanl) ! Adjusted wind speed for iteration
-    real(r8) :: tau(1:num_urbanl)      ! Stress used in iteration
-    real(r8) :: tau_diff(1:num_urbanl) ! Difference from previous iteration tau
-    real(r8) :: prev_tau(1:num_urbanl) ! Previous iteration tau
+    real(r8) :: wind_speed0(bounds%begl:bounds%endl) ! Wind speed from atmosphere at start of iteration
+    real(r8) :: wind_speed_adj(bounds%begl:bounds%endl) ! Adjusted wind speed for iteration
+    real(r8) :: tau(bounds%begl:bounds%endl)      ! Stress used in iteration
+    real(r8) :: tau_diff(bounds%begl:bounds%endl) ! Difference from previous iteration tau
+    real(r8) :: prev_tau(bounds%begl:bounds%endl) ! Previous iteration tau
     real(r8) :: prev_tau_diff(bounds%begl:bounds%endl) ! Previous difference in iteration tau
-    real(r8), parameter :: beta = 1._r8           ! coefficient of convective velocity
-    real(r8), parameter :: zii  = 1000._r8        ! convective boundary layer height (m)
-    integer :: lnd_to_urban_filter(bounds%begl:bounds%endl) !
-    integer :: col_to_urban_filter(bounds%begc:bounds%endc)
-    logical :: converged_landunits(bounds%begl:bounds%endl)
-    integer :: begl, endl, begc, endc, begp, endp
-    integer :: erridx1, erridx2
-    real(r8) :: sum_denom, sum_numer
     !-----------------------------------------------------------------------
 
-    associate(                                                                &
-         snl                 =>   col_pp%snl                                   , & ! Input:  [integer  (:)   ]  number of snow layers
-         ctype               =>   col_pp%itype                                 , & ! Input:  [integer  (:)   ]  column type
-         z_0_town            =>   lun_pp%z_0_town                              , & ! Input:  [real(r8) (:)   ]  momentum roughness length of urban landunit (m)
-         z_d_town            =>   lun_pp%z_d_town                              , & ! Input:  [real(r8) (:)   ]  displacement height of urban landunit (m)
-         ht_roof             =>   lun_pp%ht_roof                               , & ! Input:  [real(r8) (:)   ]  height of urban roof (m)
-         wtlunit_roof        =>   lun_pp%wtlunit_roof                          , & ! Input:  [real(r8) (:)   ]  weight of roof with respect to landunit
-         canyon_hwr          =>   lun_pp%canyon_hwr                            , & ! Input:  [real(r8) (:)   ]  ratio of building height to street width
-         wtroad_perv         =>   lun_pp%wtroad_perv                           , & ! Input:  [real(r8) (:)   ]  weight of pervious road wrt total road
-
-         forc_t              =>   top_as%tbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric temperature (K)
-         forc_th             =>   top_as%thbot                              , & ! Input:  [real(r8) (:)   ]  atmospheric potential temperature (K)
-         forc_rho            =>   top_as%rhobot                             , & ! Input:  [real(r8) (:)   ]  air density (kg/m**3)
-         forc_q              =>   top_as%qbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric specific humidity (kg/kg)
-         forc_pbot           =>   top_as%pbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)
-         forc_u              =>   top_as%ubot                               , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in east direction (m/s)
-         forc_v              =>   top_as%vbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in north direction (m/s)
+    associate(                                                                & 
+         snl                 =>   col_pp%snl                                   , & ! Input:  [integer  (:)   ]  number of snow layers                              
+         ctype               =>   col_pp%itype                                 , & ! Input:  [integer  (:)   ]  column type                                        
+         z_0_town            =>   lun_pp%z_0_town                              , & ! Input:  [real(r8) (:)   ]  momentum roughness length of urban landunit (m)   
+         z_d_town            =>   lun_pp%z_d_town                              , & ! Input:  [real(r8) (:)   ]  displacement height of urban landunit (m)         
+         ht_roof             =>   lun_pp%ht_roof                               , & ! Input:  [real(r8) (:)   ]  height of urban roof (m)                          
+         wtlunit_roof        =>   lun_pp%wtlunit_roof                          , & ! Input:  [real(r8) (:)   ]  weight of roof with respect to landunit           
+         canyon_hwr          =>   lun_pp%canyon_hwr                            , & ! Input:  [real(r8) (:)   ]  ratio of building height to street width          
+         wtroad_perv         =>   lun_pp%wtroad_perv                           , & ! Input:  [real(r8) (:)   ]  weight of pervious road wrt total road            
+
+         forc_t              =>   top_as%tbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric temperature (K)                       
+         forc_th             =>   top_as%thbot                              , & ! Input:  [real(r8) (:)   ]  atmospheric potential temperature (K)             
+         forc_rho            =>   top_as%rhobot                             , & ! Input:  [real(r8) (:)   ]  air density (kg/m**3)                                 
+         forc_q              =>   top_as%qbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric specific humidity (kg/kg)             
+         forc_pbot           =>   top_as%pbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric pressure (Pa)                         
+         forc_u              =>   top_as%ubot                               , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in east direction (m/s)    
+         forc_v              =>   top_as%vbot                               , & ! Input:  [real(r8) (:)   ]  atmospheric wind speed in north direction (m/s)   
          wsresp              =>   top_as%wsresp                             , & ! Input:  [real(r8) (:)   ]  response of wind to surface stress (m/s/Pa)
          tau_est             =>   top_as%tau_est                            , & ! Input:  [real(r8) (:)   ]  approximate atmosphere change to zonal wind (m/s)
          ugust               =>   top_as%ugust                              , & ! Input:  [real(r8) (:)   ]  gustiness from atmosphere (m/s)
@@ -275,272 +278,183 @@ contains
          qflx_evap_soi       =>   veg_wf%qflx_evap_soi        , & ! Output: [real(r8) (:)   ]  soil evaporation (mm H2O/s) (+ = to atm)
          qflx_tran_veg       =>   veg_wf%qflx_tran_veg        , & ! Output: [real(r8) (:)   ]  vegetation transpiration (mm H2O/s) (+ = to atm)
          qflx_evap_veg       =>   veg_wf%qflx_evap_veg        , & ! Output: [real(r8) (:)   ]  vegetation evaporation (mm H2O/s) (+ = to atm)
-         qflx_evap_tot       =>   veg_wf%qflx_evap_tot         & ! Output: [real(r8) (:)   ]  qflx_evap_soi + qflx_evap_can + qflx_tran_veg
-
+         qflx_evap_tot       =>   veg_wf%qflx_evap_tot        , & ! Output: [real(r8) (:)   ]  qflx_evap_soi + qflx_evap_can + qflx_tran_veg
 
+         begl                =>   bounds%begl                               , &
+         endl                =>   bounds%endl                                 &
          )
-    !$acc enter data create(&
-    !$acc canyontop_wind(:), &
-    !$acc canyon_u_wind(:), &
-    !$acc canyon_wind(:), &
-    !$acc canyon_resistance(:), &
-    !$acc ur(:), &
-    !$acc ustar(:), &
-    !$acc ramu(:), &
-    !$acc rahu(:), &
-    !$acc rawu(:), &
-    !$acc temp1(:), &
-    !$acc temp12m(:), &
-    !$acc temp2(:), &
-    !$acc temp22m(:), &
-    !$acc thm_g(:), &
-    !$acc thv_g(:), &
-    !$acc dth(:), &
-    !$acc dqh(:), &
-    !$acc zldis(:), &
-    !$acc um(:), &
-    !$acc obu(:), &
-    !$acc taf_numer(:), &
-    !$acc taf_denom(:), &
-    !$acc qaf_numer(:), &
-    !$acc qaf_denom(:), &
-    !$acc wtas(:), &
-    !$acc wtaq(:), &
-    !$acc wts_sum(:), &
-    !$acc wtq_sum(:), &
-    !$acc fm(:), &
-    !$acc wtus(:), &
-    !$acc wtuq(:), &
-    !$acc wtus_roof(:), &
-    !$acc wtuq_roof(:), &
-    !$acc wtus_road_perv(:), &
-    !$acc wtuq_road_perv(:), &
-    !$acc wtus_road_imperv(:), &
-    !$acc wtuq_road_imperv(:), &
-    !$acc wtus_sunwall(:), &
-    !$acc wtuq_sunwall(:), &
-    !$acc wtus_shadewall(:), &
-    !$acc wtuq_shadewall(:), &
-    !$acc wtus_roof_unscl(:), &
-    !$acc wtuq_roof_unscl(:), &
-    !$acc wtus_road_perv_unscl(:), &
-    !$acc wtuq_road_perv_unscl(:), &
-    !$acc wtus_road_imperv_unscl(:), &
-    !$acc wtuq_road_imperv_unscl(:), &
-    !$acc wtus_sunwall_unscl(:), &
-    !$acc wtuq_sunwall_unscl(:), &
-    !$acc wtus_shadewall_unscl(:), &
-    !$acc wtuq_shadewall_unscl(:), &
-    !$acc t_sunwall_innerl(:), &
-    !$acc t_shadewall_innerl(:), &
-    !$acc t_roof_innerl(:), &
-    !$acc eflx_sh_grnd_scale(:), &
-    !$acc qflx_evap_soi_scale(:), &
-    !$acc eflx_wasteheat_roof(:), &
-    !$acc eflx_wasteheat_sunwall(:), &
-    !$acc eflx_wasteheat_shadewall(:), &
-    !$acc eflx_heat_from_ac_roof(:), &
-    !$acc eflx_heat_from_ac_sunwall(:), &
-    !$acc eflx_heat_from_ac_shadewall(:), &
-    !$acc eflx(:), &
-    !$acc qflx(:), &
-    !$acc eflx_scale(:), &
-    !$acc qflx_scale(:), &
-    !$acc eflx_err(:), &
-    !$acc qflx_err(:), &
-    !$acc local_secp1(:), &
-    !$acc wind_speed0(:), &
-    !$acc wind_speed_adj(:), &
-    !$acc tau(:), &
-    !$acc tau_diff(:), &
-    !$acc prev_tau(:), &
-    !$acc prev_tau_diff(:), &
-    !$acc lnd_to_urban_filter(:), &
-    !$acc converged_landunits(:), col_to_urban_filter(:) )
-
-
-       begl = bounds%begl
-       endl = bounds%endl
-       begc = bounds%begc
-       endc = bounds%endc
-       begp = bounds%begp
-       endp = bounds%endp
+
+      ! Define fields that appear on the restart file for non-urban landunits
+      do fl = 1,num_nourbanl
+         l = filter_nourbanl(fl)
+         taf(l) = spval
+         qaf(l) = spval
+      end do
+
       ! Get time step
 
-      lnd_to_urban_filter(:) = -9999
+      nstep = nstep_mod
+      dtime = dtime_mod
+      year = year_curr
+      month = mon_curr
+      day = day_curr
+      secs = secs_curr
+
+      ! Set constants (same as in Biogeophysics1Mod)
+      beta(begl:endl) = 1._r8             ! Should be set to the same values as in Biogeophysics1Mod
+      zii(begl:endl)  = 1000._r8          ! Should be set to the same values as in Biogeophysics1Mod
+
       ! Compute canyontop wind using Masson (2000)
-      erridx1 = -9999
-      erridx2 = -9999
-      !$acc parallel loop independent gang vector default(present) copy(erridx1,erridx2) &
-      !$acc present(lnd_to_urban_filter(:), ht_roof(:), z_d_town(:),z_0_town(:))
+
       do fl = 1, num_urbanl
          l = filter_urbanl(fl)
-         lnd_to_urban_filter(l) = fl
          g = lun_pp%gridcell(l)
          t = lun_pp%topounit(l)
 
-         local_secp1(fl)        = secs_curr + nint((grc_pp%londeg(g)/degpsec)/dtime_mod)*dtime_mod
-         local_secp1(fl)        = mod(local_secp1(fl),isecspday)
+         local_secp1(l)        = secs + nint((grc_pp%londeg(g)/degpsec)/dtime)*dtime
+         local_secp1(l)        = mod(local_secp1(l),isecspday)
 
          ! Error checks
 
+#ifndef _OPENACC
          if (ht_roof(l) - z_d_town(l) <= z_0_town(l)) then
-            erridx1 = l
-
+            write (iulog,*) 'aerodynamic parameter error in UrbanFluxes'
+            write (iulog,*) 'h_r - z_d <= z_0'
+            write (iulog,*) 'ht_roof, z_d_town, z_0_town: ', ht_roof(l), z_d_town(l), &
+                 z_0_town(l)
+            write (iulog,*) 'elm model is stopping'
+            call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
          end if
          if (forc_hgt_u_patch(lun_pp%pfti(l)) - z_d_town(l) <= z_0_town(l)) then
-            erridx2 = l
+            write (iulog,*) 'aerodynamic parameter error in UrbanFluxes'
+            write (iulog,*) 'h_u - z_d <= z_0'
+            write (iulog,*) 'forc_hgt_u_patch, z_d_town, z_0_town: ', forc_hgt_u_patch(lun_pp%pfti(l)), z_d_town(l), &
+                 z_0_town(l)
+            write (iulog,*) 'elm model is stopping'
+            call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
          end if
+#endif
          ! Initialize winds for iteration.
          if (implicit_stress) then
-            wind_speed0(fl) = max(0.01_r8, hypot(forc_u(t), forc_v(t)))
-            wind_speed_adj(fl) = wind_speed0(fl)
-            ur(fl) = max(1.0_r8, wind_speed_adj(fl) + ugust(t))
+            wind_speed0(l) = max(0.01_r8, hypot(forc_u(t), forc_v(t)))
+            wind_speed_adj(l) = wind_speed0(l)
+            ur(l) = max(1.0_r8, wind_speed_adj(l) + ugust(t))
 
-            prev_tau(fl) = tau_est(t)
+            prev_tau(l) = tau_est(t)
          else
-            ur(fl) = max(1.0_r8,sqrt(forc_u(t)*forc_u(t)+forc_v(t)*forc_v(t)) + ugust(t))
+            ur(l) = max(1.0_r8,sqrt(forc_u(t)*forc_u(t)+forc_v(t)*forc_v(t)) + ugust(t))
          end if
-         tau_diff(fl) = 1.e100_r8
+         tau_diff(l) = 1.e100_r8
 
       end do
 
-      if(erridx1 > 0) then
-         l = erridx1
-         write (iulog,*) 'aerodynamic parameter error in UrbanFluxes'
-         write (iulog,*) 'h_r - z_d <= z_0'
-         write (iulog,*) 'ht_roof, z_d_town, z_0_town: ', ht_roof(l), z_d_town(l), &
-              z_0_town(l)
-         write (iulog,*) 'elm model is stopping'
-
-         call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
-      end if
-
-      if(erridx2 > 0) then
-         l = erridx2
-         write (iulog,*) 'aerodynamic parameter error in UrbanFluxes'
-         write (iulog,*) 'h_u - z_d <= z_0'
-         write (iulog,*) 'forc_hgt_u_patch, z_d_town, z_0_town: ', forc_hgt_u_patch(lun_pp%pfti(l)), z_d_town(l), &
-             z_0_town(l)
-         write (iulog,*) 'elm model is stopping'
-         call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
-      end if
-
       ! Compute fluxes - Follows elm approach for bare soils (Oleson et al 2004)
 
-      !$acc parallel loop independent gang vector default(present) &
-      !$acc present(z_0_town(:),z_d_town(:),taf(:),qaf(:) )
       do fl = 1, num_urbanl
          l = filter_urbanl(fl)
          t = lun_pp%topounit(l)
          g = lun_pp%gridcell(l)
 
-         thm_g(fl) = forc_t(t) + lapse_rate*forc_hgt_t_patch(lun_pp%pfti(l))
-         thv_g(fl) = forc_th(t)*(1._r8+0.61_r8*forc_q(t))
-         dth(fl)   = thm_g(fl)-taf(l)
-         dqh(fl)   = forc_q(t)-qaf(l)
-         dthv     = dth(fl)*(1._r8+0.61_r8*forc_q(t))+0.61_r8*forc_th(t)*dqh(fl)
-         zldis(fl) = forc_hgt_u_patch(lun_pp%pfti(l)) - z_d_town(l)
+         thm_g(l) = forc_t(t) + lapse_rate*forc_hgt_t_patch(lun_pp%pfti(l))
+         thv_g(l) = forc_th(t)*(1._r8+0.61_r8*forc_q(t))
+         dth(l)   = thm_g(l)-taf(l)
+         dqh(l)   = forc_q(t)-qaf(l)
+         dthv     = dth(l)*(1._r8+0.61_r8*forc_q(t))+0.61_r8*forc_th(t)*dqh(l)
+         zldis(l) = forc_hgt_u_patch(lun_pp%pfti(l)) - z_d_town(l)
 
          ! Initialize Monin-Obukhov length and wind speed including convective velocity
-         call MoninObukIni(ur(fl), thv_g(fl), dthv, zldis(fl), z_0_town(l), um(fl), obu(fl))
+
+         call MoninObukIni(ur(l), thv_g(l), dthv, zldis(l), z_0_town(l), um(l), obu(l))
+
       end do
 
-      ! ! Initialize conductances
-      !$acc parallel loop independent gang vector default(present) 
-      do fl=1,num_urbanl
-        wtus_roof(fl)              = 0._r8
-        wtus_road_perv(fl)         = 0._r8
-        wtus_road_imperv(fl)       = 0._r8
-        wtus_sunwall(fl)           = 0._r8
-        wtus_shadewall(fl)         = 0._r8
-        wtuq_roof(fl)              = 0._r8
-        wtuq_road_perv(fl)         = 0._r8
-        wtuq_road_imperv(fl)       = 0._r8
-        wtuq_sunwall(fl)           = 0._r8
-        wtuq_shadewall(fl)         = 0._r8
-        wtus_roof_unscl(fl)        = 0._r8
-        wtus_road_perv_unscl(fl)   = 0._r8
-        wtus_road_imperv_unscl(fl) = 0._r8
-        wtus_sunwall_unscl(fl)     = 0._r8
-        wtus_shadewall_unscl(fl)   = 0._r8
-        wtuq_roof_unscl(fl)        = 0._r8
-        wtuq_road_perv_unscl(fl)   = 0._r8
-        wtuq_road_imperv_unscl(fl) = 0._r8
-        wtuq_sunwall_unscl(fl)     = 0._r8
-        wtuq_shadewall_unscl(fl)   = 0._r8
-      end do 
+      ! Initialize conductances
+      wtus_roof(begl:endl)        = 0._r8
+      wtus_road_perv(begl:endl)   = 0._r8
+      wtus_road_imperv(begl:endl) = 0._r8
+      wtus_sunwall(begl:endl)     = 0._r8
+      wtus_shadewall(begl:endl)   = 0._r8
+      wtuq_roof(begl:endl)        = 0._r8
+      wtuq_road_perv(begl:endl)   = 0._r8
+      wtuq_road_imperv(begl:endl) = 0._r8
+      wtuq_sunwall(begl:endl)     = 0._r8
+      wtuq_shadewall(begl:endl)   = 0._r8
+      wtus_roof_unscl(begl:endl)        = 0._r8
+      wtus_road_perv_unscl(begl:endl)   = 0._r8
+      wtus_road_imperv_unscl(begl:endl) = 0._r8
+      wtus_sunwall_unscl(begl:endl)     = 0._r8
+      wtus_shadewall_unscl(begl:endl)   = 0._r8
+      wtuq_roof_unscl(begl:endl)        = 0._r8
+      wtuq_road_perv_unscl(begl:endl)   = 0._r8
+      wtuq_road_imperv_unscl(begl:endl) = 0._r8
+      wtuq_sunwall_unscl(begl:endl)     = 0._r8
+      wtuq_shadewall_unscl(begl:endl)   = 0._r8
 
       ! Start stability iteration
-      num_copyl = num_urbanl
-      num_copyc = num_urbanc
+      fnl_iter = num_urbanl
+      fnc_iter = num_urbanc
+      filterl_copy(1:num_urbanl) = filter_urbanl(1:num_urbanl)
+      filterc_copy(1:num_urbanc) = filter_urbanc(1:num_urbanc)
 
       if (implicit_stress) then
          loopmax = itmax
       else
          loopmax = itmin
       end if
-      ! converged_cols(begc:endc) = .false.
-      converged_landunits(begl:endl) = .false.
-      !$acc update device(converged_landunits(:))
+
       ITERATION: do iter = 1, loopmax
 
          ! Get friction velocity, relation for potential
          ! temperature and humidity profiles of surface boundary layer.
 
-         call FrictionVelocity_loops(begl, endl, &
+         if (fnl_iter > 0) then
+            call FrictionVelocity(begl, endl, &
                  num_urbanl, filter_urbanl, &
                  z_d_town(begl:endl), z_0_town(begl:endl), z_0_town(begl:endl), z_0_town(begl:endl), &
-                 obu(1:num_urbanl), iter, ur(1:num_urbanl), um(1:num_urbanl), ustar(1:num_urbanl), &
-                 temp1(1:num_urbanl), temp2(1:num_urbanl), temp12m(1:num_urbanl), &
-                 temp22m(1:num_urbanl), fm(1:num_urbanl), &
-                 frictionvel_vars, converged_landunits(begl:endl),landunit_index=.true.)
-
-         !$acc parallel loop independent gang vector default(present) &
-         !$acc  present(ht_roof(:),wind_hgt_canyon(:),z_0_town(:),&
-         !$acc  z_d_town(:),canyon_hwr(:),converged_landunits(:))
-         do fl = 1, num_urbanl
-            l = filter_urbanl(fl)
+                 obu(begl:endl), iter, ur(begl:endl), um(begl:endl), ustar(begl:endl), &
+                 temp1(begl:endl), temp2(begl:endl), temp12m(begl:endl), temp22m(begl:endl), fm(begl:endl), &
+                 frictionvel_vars, landunit_index=.true.)
+         end if
+
+         do fl = 1, fnl_iter
+            l = filterl_copy(fl)
             t = lun_pp%topounit(l)
             g = lun_pp%gridcell(l)
-            if(converged_landunits(l)) cycle
 
             ! Determine aerodynamic resistance to fluxes from urban canopy air to
             ! atmosphere
-            ramu(fl) = 1._r8/(ustar(fl)*ustar(fl)/um(fl))
-            rahu(fl) = 1._r8/(temp1(fl)*ustar(fl))
-            rawu(fl) = 1._r8/(temp2(fl)*ustar(fl))
+            ramu(l) = 1._r8/(ustar(l)*ustar(l)/um(l))
+            rahu(l) = 1._r8/(temp1(l)*ustar(l))
+            rawu(l) = 1._r8/(temp2(l)*ustar(l))
 
             ! Calculate magnitude of stress and update wind speed.
-            #ifndef _OPENACC
             if (implicit_stress) then
-               tau(fl) = forc_rho(t)*wind_speed_adj(fl)/ramu(fl)
+               tau(l) = forc_rho(t)*wind_speed_adj(l)/ramu(l)
                call shr_flux_update_stress(wind_speed0(l), wsresp(t), tau_est(t), &
                     tau(l), prev_tau(l), tau_diff(l), prev_tau_diff(l), &
                     wind_speed_adj(l))
-               ur(fl) = max(1.0_r8, wind_speed_adj(fl) + ugust(t))
+               ur(l) = max(1.0_r8, wind_speed_adj(l) + ugust(t))
             end if
-            #endif
 
             ! Canyon top wind
             ! If the wind does not change in this loop (explicit stress), then
             ! we only need to calculate this on the first iteration.
             if (implicit_stress .or. iter == 1) then
-               canyontop_wind(fl) = ur(fl) * &
+               canyontop_wind(l) = ur(l) * &
                     log( (ht_roof(l)-z_d_town(l)) / z_0_town(l) ) / &
                     log( (forc_hgt_u_patch(lun_pp%pfti(l))-z_d_town(l)) / z_0_town(l) )
 
-               ! U component of canyon wind
+               ! U component of canyon wind 
 
                if (canyon_hwr(l) < 0.5_r8) then  ! isolated roughness flow
-                  canyon_u_wind(fl) = canyontop_wind(fl) * exp( -0.5_r8*canyon_hwr(l)* &
+                  canyon_u_wind(l) = canyontop_wind(l) * exp( -0.5_r8*canyon_hwr(l)* &
                        (1._r8-(wind_hgt_canyon(l)/ht_roof(l))) )
                else if (canyon_hwr(l) < 1.0_r8) then ! wake interference flow
-                  canyon_u_wind(fl) = canyontop_wind(fl) * (1._r8+2._r8*(2._r8/rpi - 1._r8)* &
+                  canyon_u_wind(l) = canyontop_wind(l) * (1._r8+2._r8*(2._r8/rpi - 1._r8)* &
                        (ht_roof(l)/(ht_roof(l)/canyon_hwr(l)) - 0.5_r8)) * &
                        exp(-0.5_r8*canyon_hwr(l)*(1._r8-(wind_hgt_canyon(l)/ht_roof(l))))
                else  ! skimming flow
-                  canyon_u_wind(fl) = canyontop_wind(fl) * (2._r8/rpi) * &
+                  canyon_u_wind(l) = canyontop_wind(l) * (2._r8/rpi) * &
                        exp(-0.5_r8*canyon_hwr(l)*(1._r8-(wind_hgt_canyon(l)/ht_roof(l))))
                end if
             end if
@@ -548,57 +462,50 @@ contains
             ! Determine magnitude of canyon wind by using horizontal wind determined
             ! previously and vertical wind from friction velocity (Masson 2000)
 
-            canyon_wind(fl) = sqrt(canyon_u_wind(fl)**2._r8 + ustar(fl)**2._r8)
+            canyon_wind(l) = sqrt(canyon_u_wind(l)**2._r8 + ustar(l)**2._r8)
 
             ! Determine canyon_resistance (currently this single resistance determines the
             ! resistance from urban surfaces (roof, pervious and impervious road, sunlit and
             ! shaded walls) to urban canopy air, since it is only dependent on wind speed
             ! Also from Masson 2000.
 
-            canyon_resistance(fl) = cpair * forc_rho(t) / (11.8_r8 + 4.2_r8*canyon_wind(fl))
+            canyon_resistance(l) = cpair * forc_rho(t) / (11.8_r8 + 4.2_r8*canyon_wind(l))
 
          end do
 
          ! This is the first term in the equation solutions for urban canopy air temperature
          ! and specific humidity (numerator) and is a landunit quantity
-         !$acc parallel loop independent gang vector default(present) present(converged_landunits(:))
-         do fl = 1, num_urbanl
-            l = filter_urbanl(fl)
+         do fl = 1, fnl_iter
+            l = filterl_copy(fl)
             t = lun_pp%topounit(l)
             g = lun_pp%gridcell(l)
-            if(converged_landunits(l)) cycle
 
-            taf_numer(fl) = thm_g(fl)/rahu(fl)
-            taf_denom(fl) = 1._r8/rahu(fl)
-            qaf_numer(fl) = forc_q(t)/rawu(fl)
-            qaf_denom(fl) = 1._r8/rawu(fl)
+            taf_numer(l) = thm_g(l)/rahu(l)
+            taf_denom(l) = 1._r8/rahu(l)
+            qaf_numer(l) = forc_q(t)/rawu(l)
+            qaf_denom(l) = 1._r8/rawu(l)
 
             ! First term needed for derivative of heat fluxes
-            wtas(fl) = 1._r8/rahu(fl)
-            wtaq(fl) = 1._r8/rawu(fl)
+            wtas(l) = 1._r8/rahu(l)
+            wtaq(l) = 1._r8/rawu(l)
 
          end do
 
 
          ! Gather other terms for other urban columns for numerator and denominator of
          ! equations for urban canopy air temperature and specific humidity
-         !$acc parallel loop independent gang vector default(present) present(&
-         !$acc wtroad_perv(:),qaf(:),lnd_to_urban_filter(:),converged_landunits(:),&
-         !$acc canyon_hwr(:),wtlunit_roof(:))
-          do fc = 1, num_urbanc
-            c = filter_urbanc(fc)
+
+         do fc = 1, fnc_iter
+            c = filterc_copy(fc)
             l = col_pp%landunit(c)
-            if(converged_landunits(l)) cycle
-            fl = lnd_to_urban_filter(l)
-            col_to_urban_filter(c) = fc
 
             if (ctype(c) == icol_roof) then
 
                ! scaled sensible heat conductance
-               wtus(fc) = wtlunit_roof(l)/canyon_resistance(fl)
-               wtus_roof(fl) = wtus(fc)
+               wtus(c) = wtlunit_roof(l)/canyon_resistance(l)
+               wtus_roof(l) = wtus(c)
                ! unscaled sensible heat conductance
-               wtus_roof_unscl(fl) = 1._r8/canyon_resistance(fl)
+               wtus_roof_unscl(l) = 1._r8/canyon_resistance(l)
 
                if (snow_depth(c) > 0._r8) then
                   fwet_roof = min(snow_depth(c)/0.05_r8, 1._r8)
@@ -610,55 +517,55 @@ contains
                   fwet_roof = 1._r8
                end if
                ! scaled latent heat conductance
-               wtuq(fc) = fwet_roof*(wtlunit_roof(l)/canyon_resistance(fl))
-               wtuq_roof(fl) = wtuq(fc)
+               wtuq(c) = fwet_roof*(wtlunit_roof(l)/canyon_resistance(l))
+               wtuq_roof(l) = wtuq(c)
                ! unscaled latent heat conductance
-               wtuq_roof_unscl(fl) = fwet_roof*(1._r8/canyon_resistance(fl))
+               wtuq_roof_unscl(l) = fwet_roof*(1._r8/canyon_resistance(l))
 
                ! wasteheat from heating/cooling
-               if (urban_hac_int == urban_wasteheat_int) then
-                  eflx_wasteheat_roof(fl) = ac_wasteheat_factor * eflx_urban_ac(c) + &
+               if (trim(urban_hac) == urban_wasteheat_on) then
+                  eflx_wasteheat_roof(l) = ac_wasteheat_factor * eflx_urban_ac(c) + &
                        ht_wasteheat_factor * eflx_urban_heat(c)
                else
-                  eflx_wasteheat_roof(fl) = 0._r8
+                  eflx_wasteheat_roof(l) = 0._r8
                end if
 
                ! If air conditioning on, always replace heat removed with heat into canyon
-               if (urban_hac_int == urban_hac_on_int .or. urban_hac_int == urban_wasteheat_int) then
-                  eflx_heat_from_ac_roof(fl) = abs(eflx_urban_ac(c))
+               if (trim(urban_hac) == urban_hac_on .or. trim(urban_hac) == urban_wasteheat_on) then
+                  eflx_heat_from_ac_roof(l) = abs(eflx_urban_ac(c))
                else
-                  eflx_heat_from_ac_roof(fl) = 0._r8
+                  eflx_heat_from_ac_roof(l) = 0._r8
                end if
 
             else if (ctype(c) == icol_road_perv) then
 
                ! scaled sensible heat conductance
-               wtus(fc) = wtroad_perv(l)*(1._r8-wtlunit_roof(l))/canyon_resistance(fl)
-               wtus_road_perv(fl) = wtus(fc)
+               wtus(c) = wtroad_perv(l)*(1._r8-wtlunit_roof(l))/canyon_resistance(l)
+               wtus_road_perv(l) = wtus(c)
                ! unscaled sensible heat conductance
-               wtus_road_perv_unscl(fl) = 1._r8/canyon_resistance(fl)
+               wtus_road_perv_unscl(l) = 1._r8/canyon_resistance(l)
 
                ! scaled latent heat conductance
-               wtuq(fc) = wtroad_perv(l)*(1._r8-wtlunit_roof(l))/canyon_resistance(fl)
-               wtuq_road_perv(fl) = wtuq(fc)
+               wtuq(c) = wtroad_perv(l)*(1._r8-wtlunit_roof(l))/canyon_resistance(l)
+               wtuq_road_perv(l) = wtuq(c)
                ! unscaled latent heat conductance
-               wtuq_road_perv_unscl(fl) = 1._r8/canyon_resistance(fl)
+               wtuq_road_perv_unscl(l) = 1._r8/canyon_resistance(l)
 
                if (use_vsfm) then
                   if (qaf(l) < qg(c)) then
                      if (do_soilevap_beta()) then
-                        wtuq_road_perv(fl)       = soilbeta(c)*wtuq_road_perv(fl)
-                        wtuq_road_perv_unscl(fl) = soilbeta(c)*wtuq_road_perv_unscl(fl)
+                        wtuq_road_perv(l)       = soilbeta(c)*wtuq_road_perv(l)
+                        wtuq_road_perv_unscl(l) = soilbeta(c)*wtuq_road_perv_unscl(l)
                      endif
                   endif
                endif
             else if (ctype(c) == icol_road_imperv) then
 
                ! scaled sensible heat conductance
-               wtus(fc) = (1._r8-wtroad_perv(l))*(1._r8-wtlunit_roof(l))/canyon_resistance(fl)
-               wtus_road_imperv(fl) = wtus(fc)
+               wtus(c) = (1._r8-wtroad_perv(l))*(1._r8-wtlunit_roof(l))/canyon_resistance(l)
+               wtus_road_imperv(l) = wtus(c)
                ! unscaled sensible heat conductance
-               wtus_road_imperv_unscl(fl) = 1._r8/canyon_resistance(fl)
+               wtus_road_imperv_unscl(l) = 1._r8/canyon_resistance(l)
 
                if (snow_depth(c) > 0._r8) then
                   fwet_road_imperv = min(snow_depth(c)/0.05_r8, 1._r8)
@@ -670,207 +577,174 @@ contains
                   fwet_road_imperv = 1._r8
                end if
                ! scaled latent heat conductance
-               wtuq(fc) = fwet_road_imperv*(1._r8-wtroad_perv(l))*(1._r8-wtlunit_roof(l))/canyon_resistance(fl)
-               wtuq_road_imperv(fl) = wtuq(fc)
+               wtuq(c) = fwet_road_imperv*(1._r8-wtroad_perv(l))*(1._r8-wtlunit_roof(l))/canyon_resistance(l)
+               wtuq_road_imperv(l) = wtuq(c)
                ! unscaled latent heat conductance
-               wtuq_road_imperv_unscl(fl) = fwet_road_imperv*(1._r8/canyon_resistance(fl))
+               wtuq_road_imperv_unscl(l) = fwet_road_imperv*(1._r8/canyon_resistance(l))
 
             else if (ctype(c) == icol_sunwall) then
 
                ! scaled sensible heat conductance
-               wtus(fc) = canyon_hwr(l)*(1._r8-wtlunit_roof(l))/canyon_resistance(fl)
-               wtus_sunwall(fl) = wtus(fc)
+               wtus(c) = canyon_hwr(l)*(1._r8-wtlunit_roof(l))/canyon_resistance(l)
+               wtus_sunwall(l) = wtus(c)
                ! unscaled sensible heat conductance
-               wtus_sunwall_unscl(fl) = 1._r8/canyon_resistance(fl)
+               wtus_sunwall_unscl(l) = 1._r8/canyon_resistance(l)
 
                ! scaled latent heat conductance
-               wtuq(fc) = 0._r8
-               wtuq_sunwall(fl) = wtuq(fc)
+               wtuq(c) = 0._r8
+               wtuq_sunwall(l) = wtuq(c)
                ! unscaled latent heat conductance
-               wtuq_sunwall_unscl(fl) = 0._r8
+               wtuq_sunwall_unscl(l) = 0._r8
 
                ! wasteheat from heating/cooling
-               if (urban_hac_int == urban_wasteheat_int) then
-                  eflx_wasteheat_sunwall(fl) = ac_wasteheat_factor * eflx_urban_ac(c) + &
+               if (trim(urban_hac) == urban_wasteheat_on) then
+                  eflx_wasteheat_sunwall(l) = ac_wasteheat_factor * eflx_urban_ac(c) + &
                        ht_wasteheat_factor * eflx_urban_heat(c)
                else
-                  eflx_wasteheat_sunwall(fl) = 0._r8
+                  eflx_wasteheat_sunwall(l) = 0._r8
                end if
 
                ! If air conditioning on, always replace heat removed with heat into canyon
-               if (urban_hac_int == urban_hac_on_int .or. urban_hac_int == urban_wasteheat_int) then
-                  eflx_heat_from_ac_sunwall(fl) = abs(eflx_urban_ac(c))
+               if (trim(urban_hac) == urban_hac_on .or. trim(urban_hac) == urban_wasteheat_on) then
+                  eflx_heat_from_ac_sunwall(l) = abs(eflx_urban_ac(c))
                else
-                  eflx_heat_from_ac_sunwall(fl) = 0._r8
+                  eflx_heat_from_ac_sunwall(l) = 0._r8
                end if
 
             else if (ctype(c) == icol_shadewall) then
 
                ! scaled sensible heat conductance
-               wtus(fc) = canyon_hwr(l)*(1._r8-wtlunit_roof(l))/canyon_resistance(fl)
-               wtus_shadewall(fl) = wtus(fc)
+               wtus(c) = canyon_hwr(l)*(1._r8-wtlunit_roof(l))/canyon_resistance(l)
+               wtus_shadewall(l) = wtus(c)
                ! unscaled sensible heat conductance
-               wtus_shadewall_unscl(fl) = 1._r8/canyon_resistance(fl)
+               wtus_shadewall_unscl(l) = 1._r8/canyon_resistance(l)
 
                ! scaled latent heat conductance
-               wtuq(fc) = 0._r8
-               wtuq_shadewall(fl) = wtuq(fc)
+               wtuq(c) = 0._r8
+               wtuq_shadewall(l) = wtuq(c)
                ! unscaled latent heat conductance
-               wtuq_shadewall_unscl(fl) = 0._r8
+               wtuq_shadewall_unscl(l) = 0._r8
 
                ! wasteheat from heating/cooling
-               if (urban_hac_int == urban_wasteheat_int) then
-                  eflx_wasteheat_shadewall(fl) = ac_wasteheat_factor * eflx_urban_ac(c) + &
+               if (trim(urban_hac) == urban_wasteheat_on) then
+                  eflx_wasteheat_shadewall(l) = ac_wasteheat_factor * eflx_urban_ac(c) + &
                        ht_wasteheat_factor * eflx_urban_heat(c)
                else
-                  eflx_wasteheat_shadewall(fl) = 0._r8
+                  eflx_wasteheat_shadewall(l) = 0._r8
                end if
 
                ! If air conditioning on, always replace heat removed with heat into canyon
-               if (urban_hac_int == urban_hac_on_int .or. urban_hac_int == urban_wasteheat_int) then
-                  eflx_heat_from_ac_shadewall(fl) = abs(eflx_urban_ac(c))
+               if (trim(urban_hac) == urban_hac_on .or. trim(urban_hac) == urban_wasteheat_on) then
+                  eflx_heat_from_ac_shadewall(l) = abs(eflx_urban_ac(c))
                else
-                  eflx_heat_from_ac_shadewall(fl) = 0._r8
+                  eflx_heat_from_ac_shadewall(l) = 0._r8
                end if
-           ! else
-           !    write(iulog,*) 'c, ctype, pi = ', c, ctype(c), pi
-           !    write(iulog,*) 'Column indices for: shadewall, sunwall, road_imperv, road_perv, roof: '
-           !    write(iulog,*) icol_shadewall, icol_sunwall, icol_road_imperv, icol_road_perv, icol_roof
-               !call endrun(decomp_index=l, elmlevel=namel, msg="ERROR, ctype out of range"//errmsg(__FILE__, __LINE__))
+            else
+#ifndef _OPENACC
+               write(iulog,*) 'c, ctype, pi = ', c, ctype(c), pi
+               write(iulog,*) 'Column indices for: shadewall, sunwall, road_imperv, road_perv, roof: '
+               write(iulog,*) icol_shadewall, icol_sunwall, icol_road_imperv, icol_road_perv, icol_roof
+               call endrun(decomp_index=l, elmlevel=namel, msg="ERROR, ctype out of range"//errmsg(__FILE__, __LINE__))
+#endif
             end if
-           ! Made seperate reduction loop 
-           ! taf_numer(fl) = taf_numer(fl) + t_grnd(c)*wtus(fc)
-           ! taf_denom(fl) = taf_denom(fl) + wtus(fc)
-           ! qaf_numer(fl) = qaf_numer(fl) + qg(c)*wtuq(fc)
-           ! qaf_denom(fl) = qaf_denom(fl) + wtuq(fc)
+
+            taf_numer(l) = taf_numer(l) + t_grnd(c)*wtus(c)
+            taf_denom(l) = taf_denom(l) + wtus(c)
+            qaf_numer(l) = qaf_numer(l) + qg(c)*wtuq(c)
+            qaf_denom(l) = qaf_denom(l) + wtuq(c)
 
          end do
-        !$acc parallel loop independent gang worker default(present) private(sum_denom,sum_numer)&
-        !$acc present(converged_landunits(:))
-        do fl = 1, num_urbanl
-           sum_denom = 0._r8
-           sum_numer = 0._r8
-           l = filter_urbanl(fl)
-           if(converged_landunits(l)) cycle
-           !$acc loop vector reduction(+:sum_denom,sum_numer)
-           do c = lun_pp%coli(l), lun_pp%colf(l)
-              if(col_pp%active(c)) then
-                 fc = col_to_urban_filter(c)
-                 sum_denom = sum_denom + wtus(fc)
-                 sum_numer = sum_numer + t_grnd(c)*wtus(fc)
-              end if
-           end do
-           taf_denom(fl) = taf_denom(fl) + sum_denom
-           taf_numer(fl) = taf_numer(fl) + sum_numer
-        end do
-
-        !$acc parallel loop independent gang worker default(present) private(sum_denom,sum_numer)&
-        !$acc present(qg(:),col_pp%active(:),lun_pp%coli(:),lun_pp%colf(:),col_to_urban_filter(:))
-        do fl = 1, num_urbanl
-           sum_denom = 0._r8
-           sum_numer = 0._r8
-           l = filter_urbanl(fl)
-           !$acc loop vector reduction(+:sum_denom,sum_numer)
-           do c = lun_pp%coli(l), lun_pp%colf(l)
-              if(col_pp%active(c)) then
-                 fc = col_to_urban_filter(c)
-                 sum_denom = sum_denom + wtuq(fc)
-                 sum_numer = sum_numer + qg(c)*wtuq(fc)
-              end if
-           end do
-           qaf_denom(fl) = qaf_denom(fl) + sum_denom
-           qaf_numer(fl) = qaf_numer(fl) + sum_numer
-        end do
 
          ! Calculate new urban canopy air temperature and specific humidity
 
-         !$acc parallel loop independent gang vector default(present)&
-         !$acc present(wtroad_perv(:),taf(:),converged_landunits(:),eflx_heat_from_ac(:),&
-         !$acc eflx_traffic_factor(:),eflx_wasteheat(:),eflx_traffic(:),qaf(:), &
-         !$acc wtlunit_roof(:),canyon_hwr(:) )
-         do fl = 1, num_urbanl
-            l = filter_urbanl(fl)
+         do fl = 1, fnl_iter
+            l = filterl_copy(fl)
             g = lun_pp%gridcell(l)
-            if(converged_landunits(l)) cycle
+
             ! Total waste heat and heat from AC is sum of heat for walls and roofs
             ! accounting for different surface areas
-            eflx_wasteheat(l) = wtlunit_roof(l)*eflx_wasteheat_roof(fl) + &
-                 (1._r8-wtlunit_roof(l))*(canyon_hwr(l)*(eflx_wasteheat_sunwall(fl) + &
-                 eflx_wasteheat_shadewall(fl)))
+            eflx_wasteheat(l) = wtlunit_roof(l)*eflx_wasteheat_roof(l) + &
+                 (1._r8-wtlunit_roof(l))*(canyon_hwr(l)*(eflx_wasteheat_sunwall(l) + &
+                 eflx_wasteheat_shadewall(l)))
 
             ! Limit wasteheat to ensure that we don't get any unrealistically strong
             ! positive feedbacks due to AC in a warmer climate
             eflx_wasteheat(l) = min(eflx_wasteheat(l),wasteheat_limit)
 
-            eflx_heat_from_ac(l) = wtlunit_roof(l)*eflx_heat_from_ac_roof(fl) + &
-                 (1._r8-wtlunit_roof(l))*(canyon_hwr(l)*(eflx_heat_from_ac_sunwall(fl) + &
-                 eflx_heat_from_ac_shadewall(fl)))
+            eflx_heat_from_ac(l) = wtlunit_roof(l)*eflx_heat_from_ac_roof(l) + &
+                 (1._r8-wtlunit_roof(l))*(canyon_hwr(l)*(eflx_heat_from_ac_sunwall(l) + &
+                 eflx_heat_from_ac_shadewall(l)))
 
             ! Calculate traffic heat flux
             ! Only comes from impervious road
             eflx_traffic(l) = (1._r8-wtlunit_roof(l))*(1._r8-wtroad_perv(l))* &
                  eflx_traffic_factor(l)
 
-            taf(l) = taf_numer(fl)/taf_denom(fl)
-            qaf(l) = qaf_numer(fl)/qaf_denom(fl)
+            taf(l) = taf_numer(l)/taf_denom(l)
+            qaf(l) = qaf_numer(l)/qaf_denom(l)
 
-            wts_sum(fl) = wtas(fl) + wtus_roof(fl) + wtus_road_perv(fl) + &
-                 wtus_road_imperv(fl) + wtus_sunwall(fl) + wtus_shadewall(fl)
+            wts_sum(l) = wtas(l) + wtus_roof(l) + wtus_road_perv(l) + &
+                 wtus_road_imperv(l) + wtus_sunwall(l) + wtus_shadewall(l)
 
-            wtq_sum(fl) = wtaq(fl) + wtuq_roof(fl) + wtuq_road_perv(fl) + &
-                 wtuq_road_imperv(fl) + wtuq_sunwall(fl) + wtuq_shadewall(fl)
+            wtq_sum(l) = wtaq(l) + wtuq_roof(l) + wtuq_road_perv(l) + &
+                 wtuq_road_imperv(l) + wtuq_sunwall(l) + wtuq_shadewall(l)
 
          end do
 
          ! This section of code is not required if niters = 1
          ! Determine stability using new taf and qaf
-         ! TODO: Some of these constants replicate what is in FrictionVelocity 
-         !       and BareGround fluxes should consildate. EBK
-         !$acc parallel loop independent gang vector default(present) &
-         !$acc present(taf(:), qaf(:), converged_landunits(:) ) 
-         do fl = 1, num_urbanl
-            l = filter_urbanl(fl)
+         ! TODO: Some of these constants replicate what is in FrictionVelocity and BareGround fluxes should consildate. EBK
+         do fl = 1, fnl_iter
+            l = filterl_copy(fl)
             t = lun_pp%topounit(l)
             g = lun_pp%gridcell(l)
-            if(converged_landunits(l)) cycle
 
-            dth(fl) = thm_g(fl)-taf(l)
-            dqh(fl) = forc_q(t)-qaf(l)
-            tstar = temp1(fl)*dth(fl)
-            qstar = temp2(fl)*dqh(fl)
+            dth(l) = thm_g(l)-taf(l)
+            dqh(l) = forc_q(t)-qaf(l)
+            tstar = temp1(l)*dth(l)
+            qstar = temp2(l)*dqh(l)
             thvstar = tstar*(1._r8+0.61_r8*forc_q(t)) + 0.61_r8*forc_th(t)*qstar
-            zeta = zldis(fl)*vkc*grav*thvstar/(ustar(fl)**2*thv_g(fl))
-           
+            zeta = zldis(l)*vkc*grav*thvstar/(ustar(l)**2*thv_g(l))
+
             if (zeta >= 0._r8) then                   !stable
                zeta = min(2._r8,max(zeta,0.01_r8))
-               um(fl) = max(ur(fl),0.1_r8)
+               um(l) = max(ur(l),0.1_r8)
             else                                      !unstable
                zeta = max(-100._r8,min(zeta,-0.01_r8))
-               wc = beta*(-grav*ustar(fl)*thvstar*zii/thv_g(fl))**0.333_r8
-               um(fl) = sqrt(ur(fl)*ur(fl) + wc*wc)
+               wc = beta(l)*(-grav*ustar(l)*thvstar*zii(l)/thv_g(l))**0.333_r8
+               um(l) = sqrt(ur(l)*ur(l) + wc*wc)
             end if
 
-            obu(fl) = zldis(fl)/zeta
+            obu(l) = zldis(l)/zeta
          end do
 
          ! Test for convergence
          iter_final = iter
          if (iter >= itmin) then
-            num_unconverged = 0
-            !$acc parallel loop independent gang vector default(present) & 
-            !$acc  present(converged_landunits(:)) copy(num_unconverged) reduction(+:num_unconverged)
-            do fl = 1, num_urbanl
-               l = filter_urbanl(fl)
-               if (.not. (abs(tau_diff(fl)) < dtaumin)) then
-                  num_unconverged = num_unconverged + 1
-               else
-                  converged_landunits(l) = .true.
+            fnl_iter_old = fnl_iter
+            fnl_iter = 0
+            do fl = 1, fnl_iter_old
+               l = filterl_copy(fl)
+               if (.not. (abs(tau_diff(l)) < dtaumin)) then
+                  fnl_iter = fnl_iter + 1
+                  filterl_copy(fnl_iter) = l
                end if
             end do
-            if (num_unconverged == 0) then
-               print *, "UrbanFluxes::Converged after ",iter,"iterations"
+            if (fnl_iter == 0) then
                exit ITERATION
             end if
+            ! After weeding out landunits that have converged, we also need to
+            ! filter out the associated columns.
+            fnc_iter_old = fnc_iter
+            fnc_iter = 0
+            do fc = 1, fnc_iter_old
+               c = filterc_copy(fc)
+               l = col_pp%landunit(c)
+               if (.not. (abs(tau_diff(l)) < dtaumin)) then
+                  fnc_iter = fnc_iter + 1
+                  filterc_copy(fnc_iter) = c
+               end if
+            end do
          end if
 
       end do ITERATION ! end iteration
@@ -879,17 +753,9 @@ contains
 
       ! the following initializations are needed to ensure that the values are 0 over non-
       ! active urban Patches
-      ! eflx_sh_grnd_scale(bounds%begp : bounds%endp) = 0._r8
-      ! qflx_evap_soi_scale(bounds%begp : bounds%endp) = 0._r8
-      
-      !$acc parallel loop independent gang vector default(present)
-      do p = begp, endp 
-         eflx_sh_grnd_scale(p) = 0._r8
-         qflx_evap_soi_scale(p) = 0._r8
-      enddo
-       
-      !$acc parallel loop independent gang vector default(present) &
-      !$acc present(qaf(:), taf(:), lnd_to_urban_filter(:))
+      eflx_sh_grnd_scale(bounds%begp : bounds%endp) = 0._r8
+      qflx_evap_soi_scale(bounds%begp : bounds%endp) = 0._r8
+
       do f = 1, num_urbanp
 
          p = filter_urbanp(f)
@@ -897,9 +763,8 @@ contains
          g = veg_pp%gridcell(p)
          t = veg_pp%topounit(p)
          l = veg_pp%landunit(p)
-         fl = lnd_to_urban_filter(l)
-         fc = col_to_urban_filter(c)
-         ram1(p) = ramu(fl)  !pass value to global variable
+
+         ram1(p) = ramu(l)  !pass value to global variable
 
          ! Upward and downward canopy longwave are zero
 
@@ -910,73 +775,73 @@ contains
          ! ground temperature
 
          if (ctype(c) == icol_roof) then
-            cgrnds(p) = forc_rho(t) * cpair * (wtas(fl) + wtus_road_perv(fl) +  &
-                 wtus_road_imperv(fl) + wtus_sunwall(fl) + wtus_shadewall(fl)) * &
-                 (wtus_roof_unscl(fl)/wts_sum(fl))
-            cgrndl(p) = forc_rho(t) * (wtaq(fl) + wtuq_road_perv(fl) +  &
-                 wtuq_road_imperv(fl) + wtuq_sunwall(fl) + wtuq_shadewall(fl)) * &
-                 (wtuq_roof_unscl(fl)/wtq_sum(fl))*dqgdT(c)
+            cgrnds(p) = forc_rho(t) * cpair * (wtas(l) + wtus_road_perv(l) +  &
+                 wtus_road_imperv(l) + wtus_sunwall(l) + wtus_shadewall(l)) * &
+                 (wtus_roof_unscl(l)/wts_sum(l))
+            cgrndl(p) = forc_rho(t) * (wtaq(l) + wtuq_road_perv(l) +  &
+                 wtuq_road_imperv(l) + wtuq_sunwall(l) + wtuq_shadewall(l)) * &
+                 (wtuq_roof_unscl(l)/wtq_sum(l))*dqgdT(c)
          else if (ctype(c) == icol_road_perv) then
-            cgrnds(p) = forc_rho(t) * cpair * (wtas(fl) + wtus_roof(fl) +  &
-                 wtus_road_imperv(fl) + wtus_sunwall(fl) + wtus_shadewall(fl)) * &
-                 (wtus_road_perv_unscl(fl)/wts_sum(fl))
-            cgrndl(p) = forc_rho(t) * (wtaq(fl) + wtuq_roof(fl) +  &
-                 wtuq_road_imperv(fl) + wtuq_sunwall(fl) + wtuq_shadewall(fl)) * &
-                 (wtuq_road_perv_unscl(fl)/wtq_sum(fl))*dqgdT(c)
+            cgrnds(p) = forc_rho(t) * cpair * (wtas(l) + wtus_roof(l) +  &
+                 wtus_road_imperv(l) + wtus_sunwall(l) + wtus_shadewall(l)) * &
+                 (wtus_road_perv_unscl(l)/wts_sum(l))
+            cgrndl(p) = forc_rho(t) * (wtaq(l) + wtuq_roof(l) +  &
+                 wtuq_road_imperv(l) + wtuq_sunwall(l) + wtuq_shadewall(l)) * &
+                 (wtuq_road_perv_unscl(l)/wtq_sum(l))*dqgdT(c)
          else if (ctype(c) == icol_road_imperv) then
-            cgrnds(p) = forc_rho(t) * cpair * (wtas(fl) + wtus_roof(fl) +  &
-                 wtus_road_perv(fl) + wtus_sunwall(fl) + wtus_shadewall(fl)) * &
-                 (wtus_road_imperv_unscl(fl)/wts_sum(fl))
-            cgrndl(p) = forc_rho(t) * (wtaq(fl) + wtuq_roof(fl) +  &
-                 wtuq_road_perv(fl) + wtuq_sunwall(fl) + wtuq_shadewall(fl)) * &
-                 (wtuq_road_imperv_unscl(fl)/wtq_sum(fl))*dqgdT(c)
+            cgrnds(p) = forc_rho(t) * cpair * (wtas(l) + wtus_roof(l) +  &
+                 wtus_road_perv(l) + wtus_sunwall(l) + wtus_shadewall(l)) * &
+                 (wtus_road_imperv_unscl(l)/wts_sum(l))
+            cgrndl(p) = forc_rho(t) * (wtaq(l) + wtuq_roof(l) +  &
+                 wtuq_road_perv(l) + wtuq_sunwall(l) + wtuq_shadewall(l)) * &
+                 (wtuq_road_imperv_unscl(l)/wtq_sum(l))*dqgdT(c)
          else if (ctype(c) == icol_sunwall) then
-            cgrnds(p) = forc_rho(t) * cpair * (wtas(fl) + wtus_roof(fl) +  &
-                 wtus_road_perv(fl) + wtus_road_imperv(fl) + wtus_shadewall(fl)) * &
-                 (wtus_sunwall_unscl(fl)/wts_sum(fl))
+            cgrnds(p) = forc_rho(t) * cpair * (wtas(l) + wtus_roof(l) +  &
+                 wtus_road_perv(l) + wtus_road_imperv(l) + wtus_shadewall(l)) * &
+                 (wtus_sunwall_unscl(l)/wts_sum(l))
             cgrndl(p) = 0._r8
          else if (ctype(c) == icol_shadewall) then
-            cgrnds(p) = forc_rho(t) * cpair * (wtas(fl) + wtus_roof(fl) +  &
-                 wtus_road_perv(fl) + wtus_road_imperv(fl) + wtus_sunwall(fl)) * &
-                 (wtus_shadewall_unscl(fl)/wts_sum(fl))
+            cgrnds(p) = forc_rho(t) * cpair * (wtas(l) + wtus_roof(l) +  &
+                 wtus_road_perv(l) + wtus_road_imperv(l) + wtus_sunwall(l)) * &
+                 (wtus_shadewall_unscl(l)/wts_sum(l))
             cgrndl(p) = 0._r8
          end if
          cgrnd(p)  = cgrnds(p) + cgrndl(p)*htvp(c)
 
          ! Surface fluxes of momentum, sensible and latent heat
 
-         taux(p) = -forc_rho(t)*forc_u(t)/ramu(fl)
-         tauy(p) = -forc_rho(t)*forc_v(t)/ramu(fl)
+         taux(p) = -forc_rho(t)*forc_u(t)/ramu(l)
+         tauy(p) = -forc_rho(t)*forc_v(t)/ramu(l)
          if (implicit_stress) then
-            taux(p) = taux(p) * (wind_speed_adj(fl) / wind_speed0(fl))
-            tauy(p) = tauy(p) * (wind_speed_adj(fl) / wind_speed0(fl))
+            taux(p) = taux(p) * (wind_speed_adj(l) / wind_speed0(l))
+            tauy(p) = tauy(p) * (wind_speed_adj(l) / wind_speed0(l))
          end if
 
          ! Use new canopy air temperature
-         dth(fl) = taf(l) - t_grnd(c)
+         dth(l) = taf(l) - t_grnd(c)
 
          if (ctype(c) == icol_roof) then
-            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_roof_unscl(fl)*dth(fl)
+            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_roof_unscl(l)*dth(l)
             eflx_sh_snow(p)  = 0._r8
             eflx_sh_soil(p)  = 0._r8
             eflx_sh_h2osfc(p)= 0._r8
          else if (ctype(c) == icol_road_perv) then
-            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_road_perv_unscl(fl)*dth(fl)
+            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_road_perv_unscl(l)*dth(l)
             eflx_sh_snow(p)  = 0._r8
             eflx_sh_soil(p)  = 0._r8
             eflx_sh_h2osfc(p)= 0._r8
          else if (ctype(c) == icol_road_imperv) then
-            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_road_imperv_unscl(fl)*dth(fl)
+            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_road_imperv_unscl(l)*dth(l)
             eflx_sh_snow(p)  = 0._r8
             eflx_sh_soil(p)  = 0._r8
             eflx_sh_h2osfc(p)= 0._r8
          else if (ctype(c) == icol_sunwall) then
-            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_sunwall_unscl(fl)*dth(fl)
+            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_sunwall_unscl(l)*dth(l)
             eflx_sh_snow(p)  = 0._r8
             eflx_sh_soil(p)  = 0._r8
             eflx_sh_h2osfc(p)= 0._r8
          else if (ctype(c) == icol_shadewall) then
-            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_shadewall_unscl(fl)*dth(fl)
+            eflx_sh_grnd(p)  = -forc_rho(t)*cpair*wtus_shadewall_unscl(l)*dth(l)
             eflx_sh_snow(p)  = 0._r8
             eflx_sh_soil(p)  = 0._r8
             eflx_sh_h2osfc(p)= 0._r8
@@ -985,24 +850,24 @@ contains
          eflx_sh_tot(p)   = eflx_sh_grnd(p)
          eflx_sh_tot_u(p) = eflx_sh_tot(p)
 
-         dqh(fl) = qaf(l) - qg(c)
+         dqh(l) = qaf(l) - qg(c)
 
          if (ctype(c) == icol_roof) then
-            qflx_evap_soi(p) = -forc_rho(t)*wtuq_roof_unscl(fl)*dqh(fl)
+            qflx_evap_soi(p) = -forc_rho(t)*wtuq_roof_unscl(l)*dqh(l)
          else if (ctype(c) == icol_road_perv) then
             ! Evaporation assigned to soil term if dew or snow
             ! or if no liquid water available in soil column
-            if (dqh(fl) > 0._r8 .or. frac_sno(c) > 0._r8 .or. soilalpha_u(c) <= 0._r8) then
-               qflx_evap_soi(p) = -forc_rho(t)*wtuq_road_perv_unscl(fl)*dqh(fl)
+            if (dqh(l) > 0._r8 .or. frac_sno(c) > 0._r8 .or. soilalpha_u(c) <= 0._r8) then
+               qflx_evap_soi(p) = -forc_rho(t)*wtuq_road_perv_unscl(l)*dqh(l)
                qflx_tran_veg(p) = 0._r8
                ! Otherwise, evaporation assigned to transpiration term
             else
                qflx_evap_soi(p) = 0._r8
-               qflx_tran_veg(p) = -forc_rho(t)*wtuq_road_perv_unscl(fl)*dqh(fl)
+               qflx_tran_veg(p) = -forc_rho(t)*wtuq_road_perv_unscl(l)*dqh(l)
             end if
             qflx_evap_veg(p) = qflx_tran_veg(p)
          else if (ctype(c) == icol_road_imperv) then
-            qflx_evap_soi(p) = -forc_rho(t)*wtuq_road_imperv_unscl(fl)*dqh(fl)
+            qflx_evap_soi(p) = -forc_rho(t)*wtuq_road_imperv_unscl(l)*dqh(l)
          else if (ctype(c) == icol_sunwall) then
             qflx_evap_soi(p) = 0._r8
          else if (ctype(c) == icol_shadewall) then
@@ -1010,68 +875,66 @@ contains
          end if
 
          ! SCALED sensible and latent heat flux for error check
-         eflx_sh_grnd_scale(p)  = -forc_rho(t)*cpair*wtus(fc)*dth(fl)
-         qflx_evap_soi_scale(p) = -forc_rho(t)*wtuq(fc)*dqh(fl)
+         eflx_sh_grnd_scale(p)  = -forc_rho(t)*cpair*wtus(c)*dth(l)
+         qflx_evap_soi_scale(p) = -forc_rho(t)*wtuq(c)*dqh(l)
 
       end do
 
       ! Check to see that total sensible and latent heat equal the sum of
       ! the scaled heat fluxes above
-      !$acc parallel loop independent gang vector default(present) present(qaf(:), taf(:))
       do fl = 1, num_urbanl
          l = filter_urbanl(fl)
          t = lun_pp%topounit(l)
          g = lun_pp%gridcell(l)
-         eflx(fl)       = -(forc_rho(t)*cpair/rahu(fl))*(thm_g(fl) - taf(l))
-         qflx(fl)       = -(forc_rho(t)/rawu(fl))*(forc_q(t) - qaf(l))
-         eflx_scale(fl) = sum(eflx_sh_grnd_scale(lun_pp%pfti(l):lun_pp%pftf(l)))
-         qflx_scale(fl) = sum(qflx_evap_soi_scale(lun_pp%pfti(l):lun_pp%pftf(l)))
-         eflx_err(fl)   = eflx_scale(fl) - eflx(fl)
-         qflx_err(fl)   = qflx_scale(fl) - qflx(fl)
+         eflx(l)       = -(forc_rho(t)*cpair/rahu(l))*(thm_g(l) - taf(l))
+         qflx(l)       = -(forc_rho(t)/rawu(l))*(forc_q(t) - qaf(l))
+         eflx_scale(l) = sum(eflx_sh_grnd_scale(lun_pp%pfti(l):lun_pp%pftf(l)))
+         qflx_scale(l) = sum(qflx_evap_soi_scale(lun_pp%pfti(l):lun_pp%pftf(l)))
+         eflx_err(l)   = eflx_scale(l) - eflx(l)
+         qflx_err(l)   = qflx_scale(l) - qflx(l)
       end do
 
       found = .false.
-      !$acc parallel loop independent gang vector default(present)
       do fl = 1, num_urbanl
          l = filter_urbanl(fl)
-         if (abs(eflx_err(fl)) > 0.01_r8) then
+         if (abs(eflx_err(l)) > 0.01_r8) then
             found = .true.
-            indexl = fl
+            indexl = l
             exit
          end if
       end do
 
+#ifndef _OPENACC
       if ( found ) then
          write(iulog,*)'WARNING:  Total sensible heat does not equal sum of scaled heat fluxes for urban columns ',&
-              ' nstep = ',nstep_mod,' indexl= ',indexl,' eflx_err= ',eflx_err(indexl)
+              ' nstep = ',nstep,' indexl= ',indexl,' eflx_err= ',eflx_err(indexl)
          if (abs(eflx_err(indexl)) > .01_r8) then
-            l = filter_urbanl(indexl)
             write(iulog,*)'elm model is stopping - error is greater than .01 W/m**2'
             write(iulog,*)'eflx_scale    = ',eflx_scale(indexl)
-            write(iulog,*)'eflx_sh_grnd_scale: ',eflx_sh_grnd_scale(lun_pp%pfti(l):lun_pp%pftf(l))
+            write(iulog,*)'eflx_sh_grnd_scale: ',eflx_sh_grnd_scale(lun_pp%pfti(indexl):lun_pp%pftf(indexl))
             write(iulog,*)'eflx          = ',eflx(indexl)
             ! test code, PET
-            write(iulog,*)'tbot          = ',forc_t(lun_pp%topounit(l))
+            write(iulog,*)'tbot          = ',forc_t(lun_pp%topounit(indexl))
             call endrun(decomp_index=indexl, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
          end if
       end if
+#endif
 
-      erridx1 = -9999
-      !$acc parallel loop independent gang vector default(present) copy(erridx1)
+      found = .false.
       do fl = 1, num_urbanl
          l = filter_urbanl(fl)
          ! 4.e-9 kg/m**2/s = 0.01 W/m**2
-         if (abs(qflx_err(fl)) > 4.e-9_r8) then
-            ! found = .true.
-            erridx1 = l
-            ! exit
+         if (abs(qflx_err(l)) > 4.e-9_r8) then
+            found = .true.
+            indexl = l
+            exit
          end if
       end do
 
-      if ( erridx1 > 0 ) then
-         indexl = erridx1
+#ifndef _OPENACC
+      if ( found ) then
          write(iulog,*)'WARNING:  Total water vapor flux does not equal sum of scaled water vapor fluxes for urban columns ',&
-              ' nstep = ',nstep_mod,' indexl= ',indexl,' qflx_err= ',qflx_err(indexl)
+              ' nstep = ',nstep,' indexl= ',indexl,' qflx_err= ',qflx_err(indexl)
          if (abs(qflx_err(indexl)) > 4.e-9_r8) then
             write(iulog,*)'elm model is stopping - error is greater than 4.e-9 kg/m**2/s'
             write(iulog,*)'qflx_scale    = ',qflx_scale(indexl)
@@ -1079,17 +942,18 @@ contains
             call endrun(decomp_index=indexl, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
          end if
       end if
+#endif
 
       ! Check for convergence of stress.
       if (implicit_stress) then
          do fl = 1, num_urbanl
             l = filter_urbanl(fl)
-            if (abs(tau_diff(fl)) > dtaumin) then
-               if (nstep_mod > 0) then ! Suppress common warnings on the first time step.
+            if (abs(tau_diff(l)) > dtaumin) then
+               if (nstep > 0) then ! Suppress common warnings on the first time step.
                   write(iulog,*)'WARNING: Stress did not converge for urban columns ',&
                        ' nstep = ',nstep,' indexl= ',l,' prev_tau_diff= ',prev_tau_diff(l),&
-                       ' tau_diff= ',tau_diff(fl),' tau= ',tau(fl),&
-                       ' wind_speed_adj= ',wind_speed_adj(fl),' iter_final= ',iter_final
+                       ' tau_diff= ',tau_diff(l),' tau= ',tau(l),&
+                       ' wind_speed_adj= ',wind_speed_adj(l),' iter_final= ',iter_final
                end if
             end if
          end do
@@ -1097,36 +961,31 @@ contains
 
       ! Gather terms required to determine internal building temperature
 
-      !$acc parallel loop independent gang vector default(present) present(&
-      !$acc t_soisno(:,:),lnd_to_urban_filter(:) )
       do fc = 1,num_urbanc
          c = filter_urbanc(fc)
          l = col_pp%landunit(c)
-         fl = lnd_to_urban_filter(l)
+
          if (ctype(c) == icol_roof) then
-            t_roof_innerl(fl) = t_soisno(c,nlevurb)
+            t_roof_innerl(l) = t_soisno(c,nlevurb)
          else if (ctype(c) == icol_sunwall) then
-            t_sunwall_innerl(fl) = t_soisno(c,nlevurb)
+            t_sunwall_innerl(l) = t_soisno(c,nlevurb)
          else if (ctype(c) == icol_shadewall) then
-            t_shadewall_innerl(fl) = t_soisno(c,nlevurb)
+            t_shadewall_innerl(l) = t_soisno(c,nlevurb)
          end if
 
       end do
 
       ! Calculate internal building temperature
-      !$acc parallel loop independent gang vector default(present) present(&
-      !$acc ht_roof(:),t_building(:),canyon_hwr(:),wtlunit_roof(:))
       do fl = 1, num_urbanl
          l = filter_urbanl(fl)
 
          lngth_roof = (ht_roof(l)/canyon_hwr(l))*wtlunit_roof(l)/(1._r8-wtlunit_roof(l))
-         t_building(l) = (ht_roof(l)*(t_shadewall_innerl(fl) + t_sunwall_innerl(fl)) &
-              +lngth_roof*t_roof_innerl(fl))/(2._r8*ht_roof(l)+lngth_roof)
+         t_building(l) = (ht_roof(l)*(t_shadewall_innerl(l) + t_sunwall_innerl(l)) &
+              +lngth_roof*t_roof_innerl(l))/(2._r8*ht_roof(l)+lngth_roof)
       end do
 
       ! No roots for urban except for pervious road
 
-      !$acc parallel loop independent gang vector default(present) collapse(2)
       do j = 1, nlevgrnd
          do f = 1, num_urbanp
             p = filter_urbanp(f)
@@ -1134,12 +993,12 @@ contains
             if (ctype(c) == icol_road_perv) then
                rootr(p,j) = rootr_road_perv(c,j)
             else
+
                rootr(p,j) = 0._r8
             end if
          end do
       end do
 
-      !$acc parallel loop independent gang vector default(present) present(taf(:),qaf(:))
       do f = 1, num_urbanp
 
          p = filter_urbanp(f)
@@ -1166,85 +1025,6 @@ contains
 
       end do
 
-    !$acc exit data delete(&
-    !$acc canyontop_wind(:), &
-    !$acc canyon_u_wind(:), &
-    !$acc canyon_wind(:), &
-    !$acc canyon_resistance(:), &
-    !$acc ur(:), &
-    !$acc ustar(:), &
-    !$acc ramu(:), &
-    !$acc rahu(:), &
-    !$acc rawu(:), &
-    !$acc temp1(:), &
-    !$acc temp12m(:), &
-    !$acc temp2(:), &
-    !$acc temp22m(:), &
-    !$acc thm_g(:), &
-    !$acc thv_g(:), &
-    !$acc dth(:), &
-    !$acc dqh(:), &
-    !$acc zldis(:), &
-    !$acc um(:), &
-    !$acc obu(:), &
-    !$acc taf_numer(:), &
-    !$acc taf_denom(:), &
-    !$acc qaf_numer(:), &
-    !$acc qaf_denom(:), &
-    !$acc wtas(:), &
-    !$acc wtaq(:), &
-    !$acc wts_sum(:), &
-    !$acc wtq_sum(:), &
-    !$acc fm(:), &
-    !$acc wtus(:), &
-    !$acc wtuq(:), &
-    !$acc wtus_roof(:), &
-    !$acc wtuq_roof(:), &
-    !$acc wtus_road_perv(:), &
-    !$acc wtuq_road_perv(:), &
-    !$acc wtus_road_imperv(:), &
-    !$acc wtuq_road_imperv(:), &
-    !$acc wtus_sunwall(:), &
-    !$acc wtuq_sunwall(:), &
-    !$acc wtus_shadewall(:), &
-    !$acc wtuq_shadewall(:), &
-    !$acc wtus_roof_unscl(:), &
-    !$acc wtuq_roof_unscl(:), &
-    !$acc wtus_road_perv_unscl(:), &
-    !$acc wtuq_road_perv_unscl(:), &
-    !$acc wtus_road_imperv_unscl(:), &
-    !$acc wtuq_road_imperv_unscl(:), &
-    !$acc wtus_sunwall_unscl(:), &
-    !$acc wtuq_sunwall_unscl(:), &
-    !$acc wtus_shadewall_unscl(:), &
-    !$acc wtuq_shadewall_unscl(:), &
-    !$acc t_sunwall_innerl(:), &
-    !$acc t_shadewall_innerl(:), &
-    !$acc t_roof_innerl(:), &
-    !$acc eflx_sh_grnd_scale(:), &
-    !$acc qflx_evap_soi_scale(:), &
-    !$acc eflx_wasteheat_roof(:), &
-    !$acc eflx_wasteheat_sunwall(:), &
-    !$acc eflx_wasteheat_shadewall(:), &
-    !$acc eflx_heat_from_ac_roof(:), &
-    !$acc eflx_heat_from_ac_sunwall(:), &
-    !$acc eflx_heat_from_ac_shadewall(:), &
-    !$acc eflx(:), &
-    !$acc qflx(:), &
-    !$acc eflx_scale(:), &
-    !$acc qflx_scale(:), &
-    !$acc eflx_err(:), &
-    !$acc qflx_err(:), &
-    !$acc local_secp1(:), &
-    !$acc wind_speed0(:), &
-    !$acc wind_speed_adj(:), &
-    !$acc tau(:), &
-    !$acc tau_diff(:), &
-    !$acc prev_tau(:), &
-    !$acc prev_tau_diff(:), &
-    !$acc lnd_to_urban_filter(:), &
-    !$acc converged_landunits(:),col_to_urban_filter(:) )
-
     end associate
 
   end subroutine UrbanFluxes
diff --git a/components/elm/src/biogeophys/UrbanParamsType.F90 b/components/elm/src/biogeophys/UrbanParamsType.F90
index 2cfeb8e52f..ac193ab95c 100644
--- a/components/elm/src/biogeophys/UrbanParamsType.F90
+++ b/components/elm/src/biogeophys/UrbanParamsType.F90
@@ -102,15 +102,12 @@ module UrbanParamsType
   character(len= *), parameter, public :: urban_hac_on =  'ON'                 
   character(len= *), parameter, public :: urban_wasteheat_on = 'ON_WASTEHEAT'  
   character(len= 16), public           :: urban_hac = urban_hac_off
-  integer, public,parameter  :: urban_hac_off_int = 0
-  integer, public,parameter  :: urban_hac_on_int = 1
-  integer, public,parameter  :: urban_wasteheat_int = 2
-  integer, public  :: urban_hac_int = urban_hac_off_int
+  
   logical, public            :: urban_traffic      = .false.   ! urban traffic fluxes
-  !$acc declare copyin(urban_hac_off_int     )
-  !$acc declare copyin(urban_hac_on_int      )
-  !$acc declare copyin(urban_wasteheat_int)
-  !$acc declare copyin(urban_hac_int       )
+  !$acc declare copyin(urban_hac_off     )
+  !$acc declare copyin(urban_hac_on      )
+  !$acc declare copyin(urban_wasteheat_on)
+  !!!$acc declare copyin(urban_hac       )
   !$acc declare copyin(urban_traffic     )
   !-----------------------------------------------------------------------
 
diff --git a/components/elm/src/biogeophys/UrbanRadiationMod.F90 b/components/elm/src/biogeophys/UrbanRadiationMod.F90
index a5e27e5055..8cccc4e9ac 100644
--- a/components/elm/src/biogeophys/UrbanRadiationMod.F90
+++ b/components/elm/src/biogeophys/UrbanRadiationMod.F90
@@ -16,8 +16,10 @@ module UrbanRadiationMod
   use elm_varctl        , only : iulog
   use abortutils        , only : endrun
   use UrbanParamsType   , only : urbanparams_type
+  use atm2lndType       , only : atm2lnd_type
   use SolarAbsorbedType , only : solarabs_type
   use SurfaceAlbedoType , only : surfalb_type
+  use EnergyFluxType    , only : energyflux_type
   use TopounitDataType  , only : top_af
   use LandunitType      , only : lun_pp
   use ColumnType        , only : col_pp
@@ -40,91 +42,97 @@ module UrbanRadiationMod
 contains
 
   !-----------------------------------------------------------------------
-  subroutine UrbanRadiation ( &
+  subroutine UrbanRadiation (bounds                                   , &
        num_nourbanl, filter_nourbanl                                  , &
        num_urbanl, filter_urbanl                                      , &
-       urbanparams_vars, solarabs_vars, surfalb_vars )
+       num_urbanc, filter_urbanc                                      , &
+       num_urbanp, filter_urbanp                                      , &
+       atm2lnd_vars, urbanparams_vars, &
+       solarabs_vars, surfalb_vars, energyflux_vars)
     !
     ! !DESCRIPTION:
     ! Solar fluxes absorbed and reflected by roof and canyon (walls, road).
     ! Also net and upward longwave fluxes.
 
     ! !USES:
+      !$acc routine seq
     use elm_varcon          , only : spval, sb, tfrz
     use column_varcon       , only : icol_road_perv, icol_road_imperv
     use column_varcon       , only : icol_roof, icol_sunwall, icol_shadewall
     !
     ! !ARGUMENTS:
+    type(bounds_type)      , intent(in)    :: bounds
     integer                , intent(in)    :: num_nourbanl       ! number of non-urban landunits in clump
     integer                , intent(in)    :: filter_nourbanl(:) ! non-urban landunit filter
     integer                , intent(in)    :: num_urbanl         ! number of urban landunits in clump
     integer                , intent(in)    :: filter_urbanl(:)   ! urban landunit filter
+    integer                , intent(in)    :: num_urbanc         ! number of urban columns in clump
+    integer                , intent(in)    :: filter_urbanc(:)   ! urban column filter
+    integer                , intent(in)    :: num_urbanp         ! number of urban patches in clump
+    integer                , intent(in)    :: filter_urbanp(:)   ! urban pft filter
+    type(atm2lnd_type)     , intent(in)    :: atm2lnd_vars
     type(urbanparams_type) , intent(in)    :: urbanparams_vars
     type(solarabs_type)    , intent(inout) :: solarabs_vars
     type(surfalb_type)     , intent(in)    :: surfalb_vars
+    type(energyflux_type)  , intent(inout) :: energyflux_vars
     !
     ! !LOCAL VARIABLES:
-    integer  :: fp,fl,p,c,l,t,g     ! indices
-    integer  :: local_secp1         ! seconds into current date in local time
-    real(r8) :: dtime               ! land model time step (sec)
-    integer  :: year,month,day      ! temporaries (not used)
-    integer  :: secs                ! seconds into current date
+    integer  :: fp,fl,p,c,l,t,g            ! indices
+    integer  :: local_secp1                ! seconds into current date in local time
+    real(r8) :: dtime                      ! land model time step (sec)
+    integer  :: year,month,day             ! temporaries (not used)
+    integer  :: secs                       ! seconds into current date
 
     real(r8), parameter :: mpe    = 1.e-06_r8 ! prevents overflow for division by zero
     real(r8), parameter :: snoem  = 0.97_r8   ! snow emissivity (should use value from Biogeophysics1)
 
-    real(r8) :: lwnet_roof     ! net (outgoing-incoming) longwave radiation (per unit ground area), roof (W/m**2)
-    real(r8) :: lwnet_improad  ! net (outgoing-incoming) longwave radiation (per unit ground area), impervious road (W/m**2)
-    real(r8) :: lwnet_perroad  ! net (outgoing-incoming) longwave radiation (per unit ground area), pervious road (W/m**2)
-    real(r8) :: lwnet_sunwall  ! net (outgoing-incoming) longwave radiation (per unit wall area), sunlit wall (W/m**2)
-    real(r8) :: lwnet_shadewall! net (outgoing-incoming) longwave radiation (per unit wall area), shaded wall (W/m**2)
-    real(r8) :: lwnet_canyon   ! net (outgoing-incoming) longwave radiation for canyon, per unit ground area (W/m**2)
-    real(r8) :: lwup_roof      ! upward longwave radiation (per unit ground area), roof (W/m**2)
-    real(r8) :: lwup_improad   ! upward longwave radiation (per unit ground area), impervious road (W/m**2)
-    real(r8) :: lwup_perroad   ! upward longwave radiation (per unit ground area), pervious road (W/m**2)
-    real(r8) :: lwup_sunwall   ! upward longwave radiation, (per unit wall area), sunlit wall (W/m**2)
-    real(r8) :: lwup_shadewall ! upward longwave radiation, (per unit wall area), shaded wall (W/m**2)
-    real(r8) :: lwup_canyon    ! upward longwave radiation for canyon, per unit ground area (W/m**2)
-    real(r8) :: t_roof         ! roof temperature (K)
-    real(r8) :: t_improad      ! imppervious road temperature (K)
-    real(r8) :: t_perroad      ! pervious road temperature (K)
-    real(r8) :: t_sunwall      ! sunlit wall temperature (K)
-    real(r8) :: t_shadewall    ! shaded wall temperature (K)
-    real(r8) :: lwdown         ! atmospheric downward longwave radiation (W/m**2)
-    real(r8) :: em_roof_s      ! roof emissivity with snow effects
-    real(r8) :: em_improad_s   ! impervious road emissivity with snow effects
-    real(r8) :: em_perroad_s   ! pervious road emissivity with snow effects
+    real(r8) :: lwnet_roof(bounds%begl:bounds%endl)     ! net (outgoing-incoming) longwave radiation (per unit ground area), roof (W/m**2)
+    real(r8) :: lwnet_improad(bounds%begl:bounds%endl)  ! net (outgoing-incoming) longwave radiation (per unit ground area), impervious road (W/m**2)
+    real(r8) :: lwnet_perroad(bounds%begl:bounds%endl)  ! net (outgoing-incoming) longwave radiation (per unit ground area), pervious road (W/m**2)
+    real(r8) :: lwnet_sunwall(bounds%begl:bounds%endl)  ! net (outgoing-incoming) longwave radiation (per unit wall area), sunlit wall (W/m**2)
+    real(r8) :: lwnet_shadewall(bounds%begl:bounds%endl)! net (outgoing-incoming) longwave radiation (per unit wall area), shaded wall (W/m**2)
+    real(r8) :: lwnet_canyon(bounds%begl:bounds%endl)   ! net (outgoing-incoming) longwave radiation for canyon, per unit ground area (W/m**2)
+    real(r8) :: lwup_roof(bounds%begl:bounds%endl)      ! upward longwave radiation (per unit ground area), roof (W/m**2)
+    real(r8) :: lwup_improad(bounds%begl:bounds%endl)   ! upward longwave radiation (per unit ground area), impervious road (W/m**2)
+    real(r8) :: lwup_perroad(bounds%begl:bounds%endl)   ! upward longwave radiation (per unit ground area), pervious road (W/m**2)
+    real(r8) :: lwup_sunwall(bounds%begl:bounds%endl)   ! upward longwave radiation, (per unit wall area), sunlit wall (W/m**2)
+    real(r8) :: lwup_shadewall(bounds%begl:bounds%endl) ! upward longwave radiation, (per unit wall area), shaded wall (W/m**2)
+    real(r8) :: lwup_canyon(bounds%begl:bounds%endl)    ! upward longwave radiation for canyon, per unit ground area (W/m**2)
+    real(r8) :: t_roof(bounds%begl:bounds%endl)         ! roof temperature (K)
+    real(r8) :: t_improad(bounds%begl:bounds%endl)      ! imppervious road temperature (K)
+    real(r8) :: t_perroad(bounds%begl:bounds%endl)      ! pervious road temperature (K)
+    real(r8) :: t_sunwall(bounds%begl:bounds%endl)      ! sunlit wall temperature (K)
+    real(r8) :: t_shadewall(bounds%begl:bounds%endl)    ! shaded wall temperature (K)
+    real(r8) :: lwdown(bounds%begl:bounds%endl)         ! atmospheric downward longwave radiation (W/m**2)
+    real(r8) :: em_roof_s(bounds%begl:bounds%endl)      ! roof emissivity with snow effects
+    real(r8) :: em_improad_s(bounds%begl:bounds%endl)   ! impervious road emissivity with snow effects
+    real(r8) :: em_perroad_s(bounds%begl:bounds%endl)   ! pervious road emissivity with snow effects
     !-----------------------------------------------------------------------
 
-    associate(                                               &
-         ctype              =>    col_pp%itype                   , & ! Input:  [integer (:)    ]  column type
-         coli               =>    lun_pp%coli                    , & ! Input:  [integer (:)    ]  beginning column index for landunit
-         colf               =>    lun_pp%colf                    , & ! Input:  [integer (:)    ]  ending column index for landunit
-         canyon_hwr         =>    lun_pp%canyon_hwr              , & ! Input:  [real(r8) (:)   ]  ratio of building height to street width
-         wtroad_perv        =>    lun_pp%wtroad_perv             , & ! Input:  [real(r8) (:)   ]  weight of pervious road wrt total road
+    associate(                                                                 &
+         ctype              =>    col_pp%itype                                  , & ! Input:  [integer (:)    ]  column type
+         coli               =>    lun_pp%coli                                   , & ! Input:  [integer (:)    ]  beginning column index for landunit
+         colf               =>    lun_pp%colf                                   , & ! Input:  [integer (:)    ]  ending column index for landunit
+         canyon_hwr         =>    lun_pp%canyon_hwr                             , & ! Input:  [real(r8) (:)   ]  ratio of building height to street width
+         wtroad_perv        =>    lun_pp%wtroad_perv                            , & ! Input:  [real(r8) (:)   ]  weight of pervious road wrt total road
 
-         forc_solad         =>    top_af%solad                   , & ! Input:  [real(r8) (:,:) ]  direct beam radiation  (vis=forc_sols , nir=forc_soll ) (W/m**2)
-         forc_solai         =>    top_af%solai                   , & ! Input:  [real(r8) (:,:) ]  diffuse beam radiation (vis=forc_sols , nir=forc_soll ) (W/m**2)
-         forc_solar         =>    top_af%solar                   , & ! Input:  [real(r8) (:)   ]  incident solar radiation (W/m**2)
-         forc_lwrad         =>    top_af%lwrad                   , & ! Input:  [real(r8) (:)   ]  downward infrared (longwave) radiation (W/m**2)
+         forc_solad         =>    top_af%solad                               , & ! Input:  [real(r8) (:,:) ]  direct beam radiation  (vis=forc_sols , nir=forc_soll ) (W/m**2)
+         forc_solai         =>    top_af%solai                               , & ! Input:  [real(r8) (:,:) ]  diffuse beam radiation (vis=forc_sols , nir=forc_soll ) (W/m**2)
+         forc_solar         =>    top_af%solar                               , & ! Input:  [real(r8) (:)   ]  incident solar radiation (W/m**2)
+         forc_lwrad         =>    top_af%lwrad                               , & ! Input:  [real(r8) (:)   ]  downward infrared (longwave) radiation (W/m**2)
 
          frac_sno           =>    col_ws%frac_sno               , & ! Input:  [real(r8) (:)   ]  fraction of ground covered by snow (0 to 1)
 
          t_ref2m            =>    veg_es%t_ref2m             , & ! Input:  [real(r8) (:)   ]  2 m height surface air temperature (K)
-         t_grnd             =>    col_es%t_grnd              , & ! Input:  [real(r8) (:)   ]  ground temperature (K)
+         t_grnd             =>    col_es%t_grnd                , & ! Input:  [real(r8) (:)   ]  ground temperature (K)
 
          em_roof            =>    urbanparams_vars%em_roof                   , & ! Input:  [real(r8) (:)   ]  roof emissivity
          em_improad         =>    urbanparams_vars%em_improad                , & ! Input:  [real(r8) (:)   ]  impervious road emissivity
          em_perroad         =>    urbanparams_vars%em_perroad                , & ! Input:  [real(r8) (:)   ]  pervious road emissivity
          em_wall            =>    urbanparams_vars%em_wall                   , & ! Input:  [real(r8) (:)   ]  wall emissivity
 
-         albd               =>    surfalb_vars%albd_patch     , & ! Input:  [real(r8) (:,:) ] pft surface albedo (direct)
-         albi               =>    surfalb_vars%albi_patch     , & ! Input:  [real(r8) (:,:) ] pft surface albedo (diffuse)
-         vf_sr              =>    urbanparams_vars%vf_sr      , & ! Input:  [real(r8) (:)]  view factor of sky for road
-         vf_wr              =>    urbanparams_vars%vf_wr      , & ! Input:  [real(r8) (:)]  view factor of one wall for road
-         vf_sw              =>    urbanparams_vars%vf_sw      , & ! Input:  [real(r8) (:)]  view factor of sky for one wall
-         vf_rw              =>    urbanparams_vars%vf_rw      , & ! Input:  [real(r8) (:)]  view factor of road for one wall
-         vf_ww              =>    urbanparams_vars%vf_ww      , & ! Input:  [real(r8) (:)]  view factor of opposing wall for one wall
+         albd               =>    surfalb_vars%albd_patch                    , & ! Input:  [real(r8) (:,:) ] pft surface albedo (direct)
+         albi               =>    surfalb_vars%albi_patch                    , & ! Input:  [real(r8) (:,:) ] pft surface albedo (diffuse)
 
          sabs_roof_dir      =>    solarabs_vars%sabs_roof_dir_lun            , & ! Output: [real(r8) (:,:) ]  direct  solar absorbed  by roof per unit ground area per unit incident flux
          sabs_roof_dif      =>    solarabs_vars%sabs_roof_dif_lun            , & ! Output: [real(r8) (:,:) ]  diffuse solar absorbed  by roof per unit ground area per unit incident flux
@@ -143,13 +151,14 @@ contains
 
          eflx_lwrad_out     =>    veg_ef%eflx_lwrad_out       , & ! Output: [real(r8) (:)   ]  emitted infrared (longwave) radiation (W/m**2)
          eflx_lwrad_net     =>    veg_ef%eflx_lwrad_net       , & ! Output: [real(r8) (:)   ]  net infrared (longwave) rad (W/m**2) [+ = to atm]
-         eflx_lwrad_net_u   =>    veg_ef%eflx_lwrad_net_u       & ! Output: [real(r8) (:)   ]  urban net infrared (longwave) rad (W/m**2) [+ = to atm]
+         eflx_lwrad_net_u   =>    veg_ef%eflx_lwrad_net_u     , & ! Output: [real(r8) (:)   ]  urban net infrared (longwave) rad (W/m**2) [+ = to atm]
 
+         begl               =>    bounds%begl                                , &
+         endl               =>    bounds%endl                                  &
          )
 
       ! Define fields that appear on the restart file for non-urban landunits
 
-      !$acc parallel loop independent gang vector default(present)
       do fl = 1,num_nourbanl
          l = filter_nourbanl(fl)
          sabs_roof_dir(l,:)      = spval
@@ -165,7 +174,6 @@ contains
       end do
 
       ! Set input forcing fields
-      !$acc parallel loop independent gang vector default(present)
       do fl = 1,num_urbanl
          l = filter_urbanl(fl)
          t = lun_pp%topounit(l)
@@ -174,130 +182,123 @@ contains
          ! Need to set the following temperatures to some defined value even if it
          ! does not appear in the urban landunit for the net_longwave computation
 
-         t_roof      = 19._r8 + tfrz
-         t_sunwall   = 19._r8 + tfrz
-         t_shadewall = 19._r8 + tfrz
-         t_improad   = 19._r8 + tfrz
-         t_perroad   = 19._r8 + tfrz
+         t_roof(l)      = 19._r8 + tfrz
+         t_sunwall(l)   = 19._r8 + tfrz
+         t_shadewall(l) = 19._r8 + tfrz
+         t_improad(l)   = 19._r8 + tfrz
+         t_perroad(l)   = 19._r8 + tfrz
 
          ! Initial assignment of emissivity
-         em_roof_s    = em_roof(l)
-         em_improad_s = em_improad(l)
-         em_perroad_s = em_perroad(l)
+         em_roof_s(l)    = em_roof(l)
+         em_improad_s(l) = em_improad(l)
+         em_perroad_s(l) = em_perroad(l)
 
          ! Set urban temperatures and emissivity including snow effects.
-         !$acc loop seq
          do c = coli(l),colf(l)
-            if (ctype(c) == icol_roof )  then
-               t_roof     = t_grnd(c)
-               em_roof_s = em_roof(l)*(1._r8-frac_sno(c)) + snoem*frac_sno(c)
+            if (ctype(c) == icol_roof       )  then
+               t_roof(l)      = t_grnd(c)
+               em_roof_s(l) = em_roof(l)*(1._r8-frac_sno(c)) + snoem*frac_sno(c)
             else if (ctype(c) == icol_road_imperv) then
-               t_improad   = t_grnd(c)
-               em_improad_s = em_improad(l)*(1._r8-frac_sno(c)) + snoem*frac_sno(c)
+               t_improad(l)   = t_grnd(c)
+               em_improad_s(l) = em_improad(l)*(1._r8-frac_sno(c)) + snoem*frac_sno(c)
             else if (ctype(c) == icol_road_perv  ) then
-               t_perroad   = t_grnd(c)
-               em_perroad_s = em_perroad(l)*(1._r8-frac_sno(c)) + snoem*frac_sno(c)
+               t_perroad(l)   = t_grnd(c)
+               em_perroad_s(l) = em_perroad(l)*(1._r8-frac_sno(c)) + snoem*frac_sno(c)
             else if (ctype(c) == icol_sunwall    ) then
-               t_sunwall   = t_grnd(c)
+               t_sunwall(l)   = t_grnd(c)
             else if (ctype(c) == icol_shadewall  ) then
-               t_shadewall = t_grnd(c)
+               t_shadewall(l) = t_grnd(c)
             end if
          end do
-         lwdown = forc_lwrad(t)
-
-         ! Net longwave radiation for road and both walls in urban canyon allowing for multiple re-emission
-         ! NOTE: is it better to do surfaces independently in separate routines?
-         ! This would cut local variables in half and make net_longwave more readable
-         !if (num_urbanl > 0) then
-           call net_longwave (    &
-                canyon_hwr(l),      &
-                wtroad_perv(l),     &
-                lwdown,          &
-                em_roof_s,       &
-                em_improad_s,    &
-                em_perroad_s,    &
-                em_wall(l),      &
-                t_roof,          &
-                t_improad,       &
-                t_perroad,       &
-                t_sunwall,       &
-                t_shadewall,     &
-                lwnet_roof,      &
-                lwnet_improad,   &
-                lwnet_perroad,   &
-                lwnet_sunwall,   &
-                lwnet_shadewall, &
-                lwnet_canyon,    &
-                lwup_roof,       &
-                lwup_improad,    &
-                lwup_perroad,    &
-                lwup_sunwall,    &
-                lwup_shadewall,  &
-                lwup_canyon,     &
-                vf_sr(l), vf_wr(l), vf_sw(l), vf_rw(l), vf_ww(l))
-
-        ! end if
+         lwdown(l) = forc_lwrad(t)
+      end do
+
+      ! Net longwave radiation for road and both walls in urban canyon allowing for multiple re-emission
+
+      if (num_urbanl > 0) then
+         call net_longwave (bounds,       &
+              num_urbanl, filter_urbanl,  &
+              canyon_hwr(begl:endl),      &
+              wtroad_perv(begl:endl),     &
+              lwdown(begl:endl),          &
+              em_roof_s(begl:endl),       &
+              em_improad_s(begl:endl),    &
+              em_perroad_s(begl:endl),    &
+              em_wall(begl:endl),         &
+              t_roof(begl:endl),          &
+              t_improad(begl:endl),       &
+              t_perroad(begl:endl),       &
+              t_sunwall(begl:endl),       &
+              t_shadewall(begl:endl),     &
+              lwnet_roof(begl:endl),      &
+              lwnet_improad(begl:endl),   &
+              lwnet_perroad(begl:endl),   &
+              lwnet_sunwall(begl:endl),   &
+              lwnet_shadewall(begl:endl), &
+              lwnet_canyon(begl:endl),    &
+              lwup_roof(begl:endl),       &
+              lwup_improad(begl:endl),    &
+              lwup_perroad(begl:endl),    &
+              lwup_sunwall(begl:endl),    &
+              lwup_shadewall(begl:endl),  &
+              lwup_canyon(begl:endl),     &
+              urbanparams_vars)
+      end if
 
       ! Determine variables needed for history output and communication with atm
       ! Loop over urban patches in clump
-      !NOTE:  Rewrote this loop to have all landunit calcs within one overall loop.
-      !       This saves local memory allocations.
-
-      !$acc loop seq
-      do p = lun_pp%pfti(l), lun_pp%pftf(l)
-        !!are all patches on a active lanunit also active?
-          if(.not. veg_pp%active(p)) then
-            cycle
-          end if
 
-          g = veg_pp%gridcell(p)
-          t = veg_pp%topounit(p)
-          c = veg_pp%column(p)
+      do fp = 1,num_urbanp
+         p = filter_urbanp(fp)
+         c = veg_pp%column(p)
+         l = veg_pp%landunit(p)
+         t = veg_pp%topounit(p)
+         g = veg_pp%gridcell(p)
 
          ! Solar absorbed and longwave out and net
          ! per unit ground area (roof, road) and per unit wall area (sunwall, shadewall)
          ! Each urban pft has its own column - this is used in the logic below
 
          if (ctype(c) == icol_roof) then
-            eflx_lwrad_out(p) = lwup_roof
-            eflx_lwrad_net(p) = lwnet_roof
-            eflx_lwrad_net_u(p) = lwnet_roof
+            eflx_lwrad_out(p) = lwup_roof(l)
+            eflx_lwrad_net(p) = lwnet_roof(l)
+            eflx_lwrad_net_u(p) = lwnet_roof(l)
             sabg(p) = sabs_roof_dir(l,1)*forc_solad(t,1) + &
                  sabs_roof_dif(l,1)*forc_solai(t,1) + &
                  sabs_roof_dir(l,2)*forc_solad(t,2) + &
                  sabs_roof_dif(l,2)*forc_solai(t,2)
 
          else if (ctype(c) == icol_sunwall) then
-            eflx_lwrad_out(p)   = lwup_sunwall
-            eflx_lwrad_net(p)   = lwnet_sunwall
-            eflx_lwrad_net_u(p) = lwnet_sunwall
+            eflx_lwrad_out(p)   = lwup_sunwall(l)
+            eflx_lwrad_net(p)   = lwnet_sunwall(l)
+            eflx_lwrad_net_u(p) = lwnet_sunwall(l)
             sabg(p) = sabs_sunwall_dir(l,1)*forc_solad(t,1) + &
                  sabs_sunwall_dif(l,1)*forc_solai(t,1) + &
                  sabs_sunwall_dir(l,2)*forc_solad(t,2) + &
                  sabs_sunwall_dif(l,2)*forc_solai(t,2)
 
          else if (ctype(c) == icol_shadewall) then
-            eflx_lwrad_out(p)   = lwup_shadewall
-            eflx_lwrad_net(p)   = lwnet_shadewall
-            eflx_lwrad_net_u(p) = lwnet_shadewall
+            eflx_lwrad_out(p)   = lwup_shadewall(l)
+            eflx_lwrad_net(p)   = lwnet_shadewall(l)
+            eflx_lwrad_net_u(p) = lwnet_shadewall(l)
             sabg(p) = sabs_shadewall_dir(l,1)*forc_solad(t,1) + &
                  sabs_shadewall_dif(l,1)*forc_solai(t,1) + &
                  sabs_shadewall_dir(l,2)*forc_solad(t,2) + &
                  sabs_shadewall_dif(l,2)*forc_solai(t,2)
 
          else if (ctype(c) == icol_road_perv) then
-            eflx_lwrad_out(p)   = lwup_perroad
-            eflx_lwrad_net(p)   = lwnet_perroad
-            eflx_lwrad_net_u(p) = lwnet_perroad
+            eflx_lwrad_out(p)   = lwup_perroad(l)
+            eflx_lwrad_net(p)   = lwnet_perroad(l)
+            eflx_lwrad_net_u(p) = lwnet_perroad(l)
             sabg(p) = sabs_perroad_dir(l,1)*forc_solad(t,1) + &
                  sabs_perroad_dif(l,1)*forc_solai(t,1) + &
                  sabs_perroad_dir(l,2)*forc_solad(t,2) + &
                  sabs_perroad_dif(l,2)*forc_solai(t,2)
 
          else if (ctype(c) == icol_road_imperv) then
-            eflx_lwrad_out(p)   = lwup_improad
-            eflx_lwrad_net(p)   = lwnet_improad
-            eflx_lwrad_net_u(p) = lwnet_improad
+            eflx_lwrad_out(p)   = lwup_improad(l)
+            eflx_lwrad_net(p)   = lwnet_improad(l)
+            eflx_lwrad_net_u(p) = lwnet_improad(l)
             sabg(p) = sabs_improad_dir(l,1)*forc_solad(t,1) + &
                  sabs_improad_dif(l,1)*forc_solai(t,1) + &
                  sabs_improad_dir(l,2)*forc_solad(t,2) + &
@@ -310,223 +311,244 @@ contains
 
       end do ! end loop over urban patches
 
-    end do ! end loop over urban landunit
-
     end associate
 
   end subroutine UrbanRadiation
 
   !-----------------------------------------------------------------------
-  subroutine net_longwave (canyon_hwr, wtroad_perv            , &
-       lwdown, em_roof, em_improad, em_perroad, em_wall       , &
-       t_roof,  t_improad, t_perroad, t_sunwall, t_shadewall  , &
+  subroutine net_longwave (bounds                                                             , &
+       num_urbanl, filter_urbanl, canyon_hwr, wtroad_perv                                     , &
+       lwdown, em_roof, em_improad, em_perroad, em_wall                                       , &
+       t_roof,  t_improad, t_perroad, t_sunwall, t_shadewall                                  , &
        lwnet_roof, lwnet_improad, lwnet_perroad, lwnet_sunwall, lwnet_shadewall, lwnet_canyon , &
        lwup_roof, lwup_improad, lwup_perroad, lwup_sunwall, lwup_shadewall, lwup_canyon, &
-       vf_sr, vf_wr, vf_sw, vf_rw, vf_ww)
-    !$acc routine seq 
+       urbanparams_vars)
+    !
     ! !DESCRIPTION:
     ! Net longwave radiation for road and both walls in urban canyon allowing for
     ! multiple reflection. Also net longwave radiation for urban roof.
     !
     ! !USES:
+      !$acc routine seq
     use elm_varcon , only : sb
     !
     ! !ARGUMENTS:
-    real(r8), intent(in)  :: canyon_hwr     ! ratio of building height to street width [landunit]
-    real(r8), intent(in)  :: wtroad_perv    ! weight of pervious road wrt total road [landunit]
-
-    real(r8), intent(in)  :: lwdown         ! atmospheric longwave radiation (W/m**2) [landunit]
-    real(r8), intent(in)  :: em_roof        ! roof emissivity [landunit]
-    real(r8), intent(in)  :: em_improad     ! impervious road emissivity [landunit]
-    real(r8), intent(in)  :: em_perroad     ! pervious road emissivity [landunit]
-    real(r8), intent(in)  :: em_wall        ! wall emissivity [landunit]
-
-    real(r8), intent(in)  :: t_roof         ! roof temperature (K) [landunit]
-    real(r8), intent(in)  :: t_improad      ! impervious road temperature (K) [landunit]
-    real(r8), intent(in)  :: t_perroad      ! ervious road temperature (K) [landunit]
-    real(r8), intent(in)  :: t_sunwall      ! sunlit wall temperature (K) [landunit]
-    real(r8), intent(in)  :: t_shadewall    ! shaded wall temperature (K) [landunit]
-
-    real(r8), intent(out) :: lwnet_roof     ! net (outgoing-incoming) longwave radiation, roof (W/m**2) [landunit]
-    real(r8), intent(out) :: lwnet_improad  ! net (outgoing-incoming) longwave radiation, impervious road (W/m**2) [landunit]
-    real(r8), intent(out) :: lwnet_perroad  ! net (outgoing-incoming) longwave radiation, pervious road (W/m**2) [landunit]
-    real(r8), intent(out) :: lwnet_sunwall  ! net (outgoing-incoming) longwave radiation (per unit wall area), sunlit wall (W/m**2) [landunit]
-    real(r8), intent(out) :: lwnet_shadewall! net (outgoing-incoming) longwave radiation (per unit wall area), shaded wall (W/m**2) [landunit]
-    real(r8), intent(out) :: lwnet_canyon   ! net (outgoing-incoming) longwave radiation for canyon, per unit ground area (W/m**2) [landunit]
-
-    real(r8), intent(out) :: lwup_roof      ! upward longwave radiation, roof (W/m**2) [landunit]
-    real(r8), intent(out) :: lwup_improad   ! upward longwave radiation, impervious road (W/m**2) [landunit]
-    real(r8), intent(out) :: lwup_perroad   ! upward longwave radiation, pervious road (W/m**2) [landunit]
-    real(r8), intent(out) :: lwup_sunwall   ! upward longwave radiation (per unit wall area), sunlit wall (W/m**2) [landunit]
-    real(r8), intent(out) :: lwup_shadewall ! upward longwave radiation (per unit wall area), shaded wall (W/m**2) [landunit]
-    real(r8), intent(out) :: lwup_canyon    ! upward longwave radiation for canyon, per unit ground area (W/m**2) [landunit]
+    type(bounds_type), intent(in) :: bounds
+    integer , intent(in)  :: num_urbanl                      ! number of urban landunits
+    integer , intent(in)  :: filter_urbanl(:)                ! urban landunit filter
+    real(r8), intent(in)  :: canyon_hwr( bounds%begl: )      ! ratio of building height to street width [landunit]
+    real(r8), intent(in)  :: wtroad_perv( bounds%begl: )     ! weight of pervious road wrt total road [landunit]
+
+    real(r8), intent(in)  :: lwdown( bounds%begl: )          ! atmospheric longwave radiation (W/m**2) [landunit]
+    real(r8), intent(in)  :: em_roof( bounds%begl: )         ! roof emissivity [landunit]
+    real(r8), intent(in)  :: em_improad( bounds%begl: )      ! impervious road emissivity [landunit]
+    real(r8), intent(in)  :: em_perroad( bounds%begl: )      ! pervious road emissivity [landunit]
+    real(r8), intent(in)  :: em_wall( bounds%begl: )         ! wall emissivity [landunit]
+
+    real(r8), intent(in)  :: t_roof( bounds%begl: )          ! roof temperature (K) [landunit]
+    real(r8), intent(in)  :: t_improad( bounds%begl: )       ! impervious road temperature (K) [landunit]
+    real(r8), intent(in)  :: t_perroad( bounds%begl: )       ! ervious road temperature (K) [landunit]
+    real(r8), intent(in)  :: t_sunwall( bounds%begl: )       ! sunlit wall temperature (K) [landunit]
+    real(r8), intent(in)  :: t_shadewall( bounds%begl: )     ! shaded wall temperature (K) [landunit]
+
+    real(r8), intent(out) :: lwnet_roof( bounds%begl: )      ! net (outgoing-incoming) longwave radiation, roof (W/m**2) [landunit]
+    real(r8), intent(out) :: lwnet_improad( bounds%begl: )   ! net (outgoing-incoming) longwave radiation, impervious road (W/m**2) [landunit]
+    real(r8), intent(out) :: lwnet_perroad( bounds%begl: )   ! net (outgoing-incoming) longwave radiation, pervious road (W/m**2) [landunit]
+    real(r8), intent(out) :: lwnet_sunwall( bounds%begl: )   ! net (outgoing-incoming) longwave radiation (per unit wall area), sunlit wall (W/m**2) [landunit]
+    real(r8), intent(out) :: lwnet_shadewall( bounds%begl: ) ! net (outgoing-incoming) longwave radiation (per unit wall area), shaded wall (W/m**2) [landunit]
+    real(r8), intent(out) :: lwnet_canyon( bounds%begl: )    ! net (outgoing-incoming) longwave radiation for canyon, per unit ground area (W/m**2) [landunit]
+
+    real(r8), intent(out) :: lwup_roof( bounds%begl: )       ! upward longwave radiation, roof (W/m**2) [landunit]
+    real(r8), intent(out) :: lwup_improad( bounds%begl: )    ! upward longwave radiation, impervious road (W/m**2) [landunit]
+    real(r8), intent(out) :: lwup_perroad( bounds%begl: )    ! upward longwave radiation, pervious road (W/m**2) [landunit]
+    real(r8), intent(out) :: lwup_sunwall( bounds%begl: )    ! upward longwave radiation (per unit wall area), sunlit wall (W/m**2) [landunit]
+    real(r8), intent(out) :: lwup_shadewall( bounds%begl: )  ! upward longwave radiation (per unit wall area), shaded wall (W/m**2) [landunit]
+    real(r8), intent(out) :: lwup_canyon( bounds%begl: )     ! upward longwave radiation for canyon, per unit ground area (W/m**2) [landunit]
     !
-    real(r8), intent(in) ::  vf_sr ! Input:  [real(r8) (:)] urbanparams_vars%vf_sr view factor of sky for road
-    real(r8), intent(in) ::  vf_wr ! Input:  [real(r8) (:)] urbanparams_vars%vf_wr view factor of one wall for road
-    real(r8), intent(in) ::  vf_sw ! Input:  [real(r8) (:)] urbanparams_vars%vf_sw view factor of sky for one wall
-    real(r8), intent(in) ::  vf_rw ! Input:  [real(r8) (:)] urbanparams_vars%vf_rw view factor of road for one wall
-    real(r8), intent(in) ::  vf_ww ! Input:  [real(r8) (:)] urbanparams_vars%vf_ww view factor of opposing wall for one wall
-
+    type(urbanparams_type) , intent(in) :: urbanparams_vars
     !
     ! !LOCAL VARIABLES:
-    real(r8) :: lwdown_road          ! atmospheric longwave radiation for total road (W/m**2)
-    real(r8) :: lwdown_sunwall       ! atmospheric longwave radiation (per unit wall area) for sunlit wall (W/m**2)
-    real(r8) :: lwdown_shadewall     ! atmospheric longwave radiation (per unit wall area) for shaded wall (W/m**2)
-    real(r8) :: lwtot                ! incoming longwave radiation (W/m**2)
-
-    real(r8) :: improad_a            ! absorbed longwave for improad (W/m**2)
-    real(r8) :: improad_r            ! reflected longwave for improad (W/m**2)
-    real(r8) :: improad_r_sky        ! improad_r to sky (W/m**2)
-    real(r8) :: improad_r_sunwall    ! improad_r to sunlit wall (W/m**2)
-    real(r8) :: improad_r_shadewall  ! improad_r to shaded wall (W/m**2)
-    real(r8) :: improad_e            ! emitted longwave for improad (W/m**2)
-    real(r8) :: improad_e_sky        ! improad_e to sky (W/m**2)
-    real(r8) :: improad_e_sunwall    ! improad_e to sunlit wall (W/m**2)
-    real(r8) :: improad_e_shadewall  ! improad_e to shaded wall (W/m**2)
-
-    real(r8) :: perroad_a            ! absorbed longwave for perroad (W/m**2)
-    real(r8) :: perroad_r            ! reflected longwave for perroad (W/m**2)
-    real(r8) :: perroad_r_sky        ! perroad_r to sky (W/m**2)
-    real(r8) :: perroad_r_sunwall    ! perroad_r to sunlit wall (W/m**2)
-    real(r8) :: perroad_r_shadewall  ! perroad_r to shaded wall (W/m**2)
-    real(r8) :: perroad_e            ! emitted longwave for perroad (W/m**2)
-    real(r8) :: perroad_e_sky        ! perroad_e to sky (W/m**2)
-    real(r8) :: perroad_e_sunwall    ! perroad_e to sunlit wall (W/m**2)
-    real(r8) :: perroad_e_shadewall  ! perroad_e to shaded wall (W/m**2)
-
-    real(r8) :: road_a               ! absorbed longwave for total road (W/m**2)
-    real(r8) :: road_r               ! reflected longwave for total road (W/m**2)
-    real(r8) :: road_r_sky           ! total road_r to sky (W/m**2)
-    real(r8) :: road_r_sunwall       ! total road_r to sunlit wall (W/m**2)
-    real(r8) :: road_r_shadewall     ! total road_r to shaded wall (W/m**2)
-    real(r8) :: road_e               ! emitted longwave for total road (W/m**2)
-    real(r8) :: road_e_sky           ! total road_e to sky (W/m**2)
-    real(r8) :: road_e_sunwall       ! total road_e to sunlit wall (W/m**2)
-    real(r8) :: road_e_shadewall     ! total road_e to shaded wall (W/m**2)
-
-    real(r8) :: sunwall_a            ! absorbed longwave (per unit wall area) for sunlit wall (W/m**2)
-    real(r8) :: sunwall_r            ! reflected longwave (per unit wall area) for sunlit wall (W/m**2)
-    real(r8) :: sunwall_r_sky        ! sunwall_r to sky (W/m**2)
-    real(r8) :: sunwall_r_road       ! sunwall_r to road (W/m**2)
-    real(r8) :: sunwall_r_shadewall  ! sunwall_r to opposing (shaded) wall (W/m**2)
-    real(r8) :: sunwall_e            ! emitted longwave (per unit wall area) for sunlit wall (W/m**2)
-    real(r8) :: sunwall_e_sky        ! sunwall_e to sky (W/m**2)
-    real(r8) :: sunwall_e_road       ! sunwall_e to road (W/m**2)
-    real(r8) :: sunwall_e_shadewall  ! sunwall_e to opposing (shaded) wall (W/m**2)
-
-    real(r8) :: shadewall_a          ! absorbed longwave (per unit wall area) for shaded wall (W/m**2)
-    real(r8) :: shadewall_r          ! reflected longwave (per unit wall area) for shaded wall (W/m**2)
-    real(r8) :: shadewall_r_sky      ! shadewall_r to sky (W/m**2)
-    real(r8) :: shadewall_r_road     ! shadewall_r to road (W/m**2)
-    real(r8) :: shadewall_r_sunwall  ! shadewall_r to opposing (sunlit) wall (W/m**2)
-    real(r8) :: shadewall_e          ! emitted longwave (per unit wall area) for shaded wall (W/m**2)
-    real(r8) :: shadewall_e_sky      ! shadewall_e to sky (W/m**2)
-    real(r8) :: shadewall_e_road     ! shadewall_e to road (W/m**2)
-    real(r8) :: shadewall_e_sunwall  ! shadewall_e to opposing (sunlit) wall (W/m**2)
-    integer  :: fl,iter            ! indices
-    integer, parameter  :: n = 50    ! number of interations
-    real(r8) :: crit                 ! convergence criterion (W/m**2)
-    real(r8) :: err                  ! energy conservation error (W/m**2)
-    real(r8) :: wtroad_imperv        ! weight of impervious road wrt total road
+    real(r8) :: lwdown_road(bounds%begl:bounds%endl)         ! atmospheric longwave radiation for total road (W/m**2)
+    real(r8) :: lwdown_sunwall(bounds%begl:bounds%endl)      ! atmospheric longwave radiation (per unit wall area) for sunlit wall (W/m**2)
+    real(r8) :: lwdown_shadewall(bounds%begl:bounds%endl)    ! atmospheric longwave radiation (per unit wall area) for shaded wall (W/m**2)
+    real(r8) :: lwtot(bounds%begl:bounds%endl)               ! incoming longwave radiation (W/m**2)
+
+    real(r8) :: improad_a(bounds%begl:bounds%endl)           ! absorbed longwave for improad (W/m**2)
+    real(r8) :: improad_r(bounds%begl:bounds%endl)           ! reflected longwave for improad (W/m**2)
+    real(r8) :: improad_r_sky(bounds%begl:bounds%endl)       ! improad_r to sky (W/m**2)
+    real(r8) :: improad_r_sunwall(bounds%begl:bounds%endl)   ! improad_r to sunlit wall (W/m**2)
+    real(r8) :: improad_r_shadewall(bounds%begl:bounds%endl) ! improad_r to shaded wall (W/m**2)
+    real(r8) :: improad_e(bounds%begl:bounds%endl)           ! emitted longwave for improad (W/m**2)
+    real(r8) :: improad_e_sky(bounds%begl:bounds%endl)       ! improad_e to sky (W/m**2)
+    real(r8) :: improad_e_sunwall(bounds%begl:bounds%endl)   ! improad_e to sunlit wall (W/m**2)
+    real(r8) :: improad_e_shadewall(bounds%begl:bounds%endl) ! improad_e to shaded wall (W/m**2)
+
+    real(r8) :: perroad_a(bounds%begl:bounds%endl)           ! absorbed longwave for perroad (W/m**2)
+    real(r8) :: perroad_r(bounds%begl:bounds%endl)           ! reflected longwave for perroad (W/m**2)
+    real(r8) :: perroad_r_sky(bounds%begl:bounds%endl)       ! perroad_r to sky (W/m**2)
+    real(r8) :: perroad_r_sunwall(bounds%begl:bounds%endl)   ! perroad_r to sunlit wall (W/m**2)
+    real(r8) :: perroad_r_shadewall(bounds%begl:bounds%endl) ! perroad_r to shaded wall (W/m**2)
+    real(r8) :: perroad_e(bounds%begl:bounds%endl)           ! emitted longwave for perroad (W/m**2)
+    real(r8) :: perroad_e_sky(bounds%begl:bounds%endl)       ! perroad_e to sky (W/m**2)
+    real(r8) :: perroad_e_sunwall(bounds%begl:bounds%endl)   ! perroad_e to sunlit wall (W/m**2)
+    real(r8) :: perroad_e_shadewall(bounds%begl:bounds%endl) ! perroad_e to shaded wall (W/m**2)
+
+    real(r8) :: road_a(bounds%begl:bounds%endl)              ! absorbed longwave for total road (W/m**2)
+    real(r8) :: road_r(bounds%begl:bounds%endl)              ! reflected longwave for total road (W/m**2)
+    real(r8) :: road_r_sky(bounds%begl:bounds%endl)          ! total road_r to sky (W/m**2)
+    real(r8) :: road_r_sunwall(bounds%begl:bounds%endl)      ! total road_r to sunlit wall (W/m**2)
+    real(r8) :: road_r_shadewall(bounds%begl:bounds%endl)    ! total road_r to shaded wall (W/m**2)
+    real(r8) :: road_e(bounds%begl:bounds%endl)              ! emitted longwave for total road (W/m**2)
+    real(r8) :: road_e_sky(bounds%begl:bounds%endl)          ! total road_e to sky (W/m**2)
+    real(r8) :: road_e_sunwall(bounds%begl:bounds%endl)      ! total road_e to sunlit wall (W/m**2)
+    real(r8) :: road_e_shadewall(bounds%begl:bounds%endl)    ! total road_e to shaded wall (W/m**2)
+
+    real(r8) :: sunwall_a(bounds%begl:bounds%endl)           ! absorbed longwave (per unit wall area) for sunlit wall (W/m**2)
+    real(r8) :: sunwall_r(bounds%begl:bounds%endl)           ! reflected longwave (per unit wall area) for sunlit wall (W/m**2)
+    real(r8) :: sunwall_r_sky(bounds%begl:bounds%endl)       ! sunwall_r to sky (W/m**2)
+    real(r8) :: sunwall_r_road(bounds%begl:bounds%endl)      ! sunwall_r to road (W/m**2)
+    real(r8) :: sunwall_r_shadewall(bounds%begl:bounds%endl) ! sunwall_r to opposing (shaded) wall (W/m**2)
+    real(r8) :: sunwall_e(bounds%begl:bounds%endl)           ! emitted longwave (per unit wall area) for sunlit wall (W/m**2)
+    real(r8) :: sunwall_e_sky(bounds%begl:bounds%endl)       ! sunwall_e to sky (W/m**2)
+    real(r8) :: sunwall_e_road(bounds%begl:bounds%endl)      ! sunwall_e to road (W/m**2)
+    real(r8) :: sunwall_e_shadewall(bounds%begl:bounds%endl) ! sunwall_e to opposing (shaded) wall (W/m**2)
+
+    real(r8) :: shadewall_a(bounds%begl:bounds%endl)         ! absorbed longwave (per unit wall area) for shaded wall (W/m**2)
+    real(r8) :: shadewall_r(bounds%begl:bounds%endl)         ! reflected longwave (per unit wall area) for shaded wall (W/m**2)
+    real(r8) :: shadewall_r_sky(bounds%begl:bounds%endl)     ! shadewall_r to sky (W/m**2)
+    real(r8) :: shadewall_r_road(bounds%begl:bounds%endl)    ! shadewall_r to road (W/m**2)
+    real(r8) :: shadewall_r_sunwall(bounds%begl:bounds%endl) ! shadewall_r to opposing (sunlit) wall (W/m**2)
+    real(r8) :: shadewall_e(bounds%begl:bounds%endl)         ! emitted longwave (per unit wall area) for shaded wall (W/m**2)
+    real(r8) :: shadewall_e_sky(bounds%begl:bounds%endl)     ! shadewall_e to sky (W/m**2)
+    real(r8) :: shadewall_e_road(bounds%begl:bounds%endl)    ! shadewall_e to road (W/m**2)
+    real(r8) :: shadewall_e_sunwall(bounds%begl:bounds%endl) ! shadewall_e to opposing (sunlit) wall (W/m**2)
+    integer  :: l,fl,iter                    ! indices
+    integer, parameter  :: n = 50            ! number of interations
+    real(r8) :: crit                         ! convergence criterion (W/m**2)
+    real(r8) :: err                          ! energy conservation error (W/m**2)
+    real(r8) :: wtroad_imperv(bounds%begl:bounds%endl)       ! weight of impervious road wrt total road
     !-----------------------------------------------------------------------
 
+    ! Enforce expected array sizes
+
+
+    associate(                             &
+         vf_sr => urbanparams_vars%vf_sr , & ! Input:  [real(r8) (:)]  view factor of sky for road
+         vf_wr => urbanparams_vars%vf_wr , & ! Input:  [real(r8) (:)]  view factor of one wall for road
+         vf_sw => urbanparams_vars%vf_sw , & ! Input:  [real(r8) (:)]  view factor of sky for one wall
+         vf_rw => urbanparams_vars%vf_rw , & ! Input:  [real(r8) (:)]  view factor of road for one wall
+         vf_ww => urbanparams_vars%vf_ww   & ! Input:  [real(r8) (:)]  view factor of opposing wall for one wall
+         )
+
       ! Calculate impervious road
 
-      wtroad_imperv = 1._r8 - wtroad_perv
+      do fl = 1,num_urbanl
+         l = filter_urbanl(fl)
+         wtroad_imperv(l) = 1._r8 - wtroad_perv(l)
+      end do
+
+      do fl = 1,num_urbanl
+         l = filter_urbanl(fl)
+         ! atmospheric longwave radiation incident on walls and road in urban canyon.
+         ! check for conservation (need to convert wall fluxes to ground area).
+         ! lwdown (from atmosphere) = lwdown_road + (lwdown_sunwall + lwdown_shadewall)*canyon_hwr
 
-      ! atmospheric longwave radiation incident on walls and road in urban canyon.
-      ! check for conservation (need to convert wall fluxes to ground area).
-      ! lwdown (from atmosphere) = lwdown_road + (lwdown_sunwall + lwdown_shadewall)*canyon_hwr
-      lwdown_road = lwdown 
-      lwdown_road      = lwdown * vf_sr
-      lwdown_sunwall   = lwdown * vf_sw
-      lwdown_shadewall = lwdown * vf_sw
+         lwdown_road(l)      = lwdown(l) * vf_sr(l)
+         lwdown_sunwall(l)   = lwdown(l) * vf_sw(l)
+         lwdown_shadewall(l) = lwdown(l) * vf_sw(l)
 
-      err = lwdown - (lwdown_road + (lwdown_shadewall + lwdown_sunwall)*canyon_hwr)
-      if (abs(err) > 0.10_r8 ) then
+         err = lwdown(l) - (lwdown_road(l) + (lwdown_shadewall(l) + lwdown_sunwall(l))*canyon_hwr(l))
+         if (abs(err) > 0.10_r8 ) then
 #ifndef _OPENACC
-         write(iulog,*) 'urban incident atmospheric longwave radiation balance error',err
-         write(iulog,*) 'lwdown     = ',lwdown
-         write(iulog,*) 'vf_sr      = ',vf_sr
-         write(iulog,*) 'vf_sw      = ',vf_sw
-         write(iulog,*) 'canyon_hwr = ',canyon_hwr
-         write(iulog,*) 'elm model is stopping'
-         call endrun()
+             write(iulog,*) 'urban incident atmospheric longwave radiation balance error',err
+             write(iulog,*) 'l          = ',l
+             write(iulog,*) 'lwdown     = ',lwdown(l)
+             write(iulog,*) 'vf_sr      = ',vf_sr(l)
+             write(iulog,*) 'vf_sw      = ',vf_sw(l)
+             write(iulog,*) 'canyon_hwr = ',canyon_hwr(l)
+             write(iulog,*) 'elm model is stopping'
+             call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
 #endif
-      endif
-
-      ! initial absorption, reflection, and emission for road and both walls.
-      ! distribute reflected and emitted radiation to sky, road, and walls according
-      ! to appropriate view factor. radiation reflected to road and walls will
-      ! undergo multiple reflections within the canyon.
-
-      road_a              = 0.0_r8
-      road_r              = 0.0_r8
-      road_e              = 0.0_r8
-      improad_a            =     em_improad   * lwdown_road
-      improad_r            = (1._r8-em_improad ) * lwdown_road
-      improad_r_sky        = improad_r  * vf_sr
-      improad_r_sunwall    = improad_r  * vf_wr
-      improad_r_shadewall  = improad_r  * vf_wr
-      improad_e            = em_improad  * sb * (t_improad **4)
-      improad_e_sky        = improad_e  * vf_sr
-      improad_e_sunwall    = improad_e  * vf_wr
-      improad_e_shadewall  = improad_e  * vf_wr
-      road_a               = road_a  + improad_a *wtroad_imperv
-      road_r               = road_r  + improad_r *wtroad_imperv
-      road_e               = road_e  + improad_e *wtroad_imperv
-
-      perroad_a            =     em_perroad   * lwdown_road
-      perroad_r            = (1._r8-em_perroad ) * lwdown_road
-      perroad_r_sky        = perroad_r  * vf_sr
-      perroad_r_sunwall    = perroad_r  * vf_wr
-      perroad_r_shadewall  = perroad_r  * vf_wr
-      perroad_e            = em_perroad * sb * (t_perroad **4)
-      perroad_e_sky        = perroad_e  * vf_sr
-      perroad_e_sunwall    = perroad_e  * vf_wr
-      perroad_e_shadewall  = perroad_e  * vf_wr
-      road_a               = road_a  + perroad_a *wtroad_perv
-      road_r               = road_r  + perroad_r *wtroad_perv
-      road_e               = road_e  + perroad_e *wtroad_perv
-
-      road_r_sky           = road_r  * vf_sr
-      road_r_sunwall       = road_r  * vf_wr
-      road_r_shadewall     = road_r  * vf_wr
-      road_e_sky           = road_e  * vf_sr
-      road_e_sunwall       = road_e  * vf_wr
-      road_e_shadewall     = road_e  * vf_wr
-
-      sunwall_a            = em_wall  * lwdown_sunwall
-      sunwall_r            = (1._r8-em_wall ) * lwdown_sunwall
-      sunwall_r_sky        = sunwall_r  * vf_sw
-      sunwall_r_road       = sunwall_r  * vf_rw
-      sunwall_r_shadewall  = sunwall_r  * vf_ww
-      sunwall_e            = em_wall  * sb * (t_sunwall **4)
-      sunwall_e_sky        = sunwall_e  * vf_sw
-      sunwall_e_road       = sunwall_e  * vf_rw
-      sunwall_e_shadewall  = sunwall_e  * vf_ww
-
-      shadewall_a          = em_wall  * lwdown_shadewall
-      shadewall_r          = (1._r8-em_wall ) * lwdown_shadewall
-      shadewall_r_sky      = shadewall_r  * vf_sw
-      shadewall_r_road     = shadewall_r  * vf_rw
-      shadewall_r_sunwall  = shadewall_r  * vf_ww
-      shadewall_e          = em_wall  * sb * (t_shadewall **4)
-      shadewall_e_sky      = shadewall_e  * vf_sw
-      shadewall_e_road     = shadewall_e  * vf_rw
-      shadewall_e_sunwall  = shadewall_e  * vf_ww
-
-      ! initialize sum of net and upward longwave radiation for road and both walls
-
-      lwnet_improad    = improad_e    - improad_a
-      lwnet_perroad    = perroad_e    - perroad_a
-      lwnet_sunwall    = sunwall_e    - sunwall_a
-      lwnet_shadewall  = shadewall_e  - shadewall_a
-
-      lwup_improad    = improad_r_sky    + improad_e_sky
-      lwup_perroad    = perroad_r_sky    + perroad_e_sky
-      lwup_sunwall    = sunwall_r_sky    + sunwall_e_sky
-      lwup_shadewall  = shadewall_r_sky  + shadewall_e_sky
+         endif
+      end do
+
+      do fl = 1,num_urbanl
+         l = filter_urbanl(fl)
+
+         ! initial absorption, reflection, and emission for road and both walls.
+         ! distribute reflected and emitted radiation to sky, road, and walls according
+         ! to appropriate view factor. radiation reflected to road and walls will
+         ! undergo multiple reflections within the canyon.
+
+         road_a(l)              = 0.0_r8
+         road_r(l)              = 0.0_r8
+         road_e(l)              = 0.0_r8
+         improad_a(l)           =     em_improad(l)  * lwdown_road(l)
+         improad_r(l)           = (1._r8-em_improad(l)) * lwdown_road(l)
+         improad_r_sky(l)       = improad_r(l) * vf_sr(l)
+         improad_r_sunwall(l)   = improad_r(l) * vf_wr(l)
+         improad_r_shadewall(l) = improad_r(l) * vf_wr(l)
+         improad_e(l)           = em_improad(l) * sb * (t_improad(l)**4)
+         improad_e_sky(l)       = improad_e(l) * vf_sr(l)
+         improad_e_sunwall(l)   = improad_e(l) * vf_wr(l)
+         improad_e_shadewall(l) = improad_e(l) * vf_wr(l)
+         road_a(l)              = road_a(l) + improad_a(l)*wtroad_imperv(l)
+         road_r(l)              = road_r(l) + improad_r(l)*wtroad_imperv(l)
+         road_e(l)              = road_e(l) + improad_e(l)*wtroad_imperv(l)
+
+         perroad_a(l)           =     em_perroad(l)  * lwdown_road(l)
+         perroad_r(l)           = (1._r8-em_perroad(l)) * lwdown_road(l)
+         perroad_r_sky(l)       = perroad_r(l) * vf_sr(l)
+         perroad_r_sunwall(l)   = perroad_r(l) * vf_wr(l)
+         perroad_r_shadewall(l) = perroad_r(l) * vf_wr(l)
+         perroad_e(l)           = em_perroad(l) * sb * (t_perroad(l)**4)
+         perroad_e_sky(l)       = perroad_e(l) * vf_sr(l)
+         perroad_e_sunwall(l)   = perroad_e(l) * vf_wr(l)
+         perroad_e_shadewall(l) = perroad_e(l) * vf_wr(l)
+         road_a(l)              = road_a(l) + perroad_a(l)*wtroad_perv(l)
+         road_r(l)              = road_r(l) + perroad_r(l)*wtroad_perv(l)
+         road_e(l)              = road_e(l) + perroad_e(l)*wtroad_perv(l)
+
+         road_r_sky(l)          = road_r(l) * vf_sr(l)
+         road_r_sunwall(l)      = road_r(l) * vf_wr(l)
+         road_r_shadewall(l)    = road_r(l) * vf_wr(l)
+         road_e_sky(l)          = road_e(l) * vf_sr(l)
+         road_e_sunwall(l)      = road_e(l) * vf_wr(l)
+         road_e_shadewall(l)    = road_e(l) * vf_wr(l)
+
+         sunwall_a(l)           = em_wall(l) * lwdown_sunwall(l)
+         sunwall_r(l)           = (1._r8-em_wall(l)) * lwdown_sunwall(l)
+         sunwall_r_sky(l)       = sunwall_r(l) * vf_sw(l)
+         sunwall_r_road(l)      = sunwall_r(l) * vf_rw(l)
+         sunwall_r_shadewall(l) = sunwall_r(l) * vf_ww(l)
+         sunwall_e(l)           = em_wall(l) * sb * (t_sunwall(l)**4)
+         sunwall_e_sky(l)       = sunwall_e(l) * vf_sw(l)
+         sunwall_e_road(l)      = sunwall_e(l) * vf_rw(l)
+         sunwall_e_shadewall(l) = sunwall_e(l) * vf_ww(l)
+
+         shadewall_a(l)         = em_wall(l) * lwdown_shadewall(l)
+         shadewall_r(l)         = (1._r8-em_wall(l)) * lwdown_shadewall(l)
+         shadewall_r_sky(l)     = shadewall_r(l) * vf_sw(l)
+         shadewall_r_road(l)    = shadewall_r(l) * vf_rw(l)
+         shadewall_r_sunwall(l) = shadewall_r(l) * vf_ww(l)
+         shadewall_e(l)         = em_wall(l) * sb * (t_shadewall(l)**4)
+         shadewall_e_sky(l)     = shadewall_e(l) * vf_sw(l)
+         shadewall_e_road(l)    = shadewall_e(l) * vf_rw(l)
+         shadewall_e_sunwall(l) = shadewall_e(l) * vf_ww(l)
+
+         ! initialize sum of net and upward longwave radiation for road and both walls
+
+         lwnet_improad(l)   = improad_e(l)   - improad_a(l)
+         lwnet_perroad(l)   = perroad_e(l)   - perroad_a(l)
+         lwnet_sunwall(l)   = sunwall_e(l)   - sunwall_a(l)
+         lwnet_shadewall(l) = shadewall_e(l) - shadewall_a(l)
+
+         lwup_improad(l)   = improad_r_sky(l)   + improad_e_sky(l)
+         lwup_perroad(l)   = perroad_r_sky(l)   + perroad_e_sky(l)
+         lwup_sunwall(l)   = sunwall_r_sky(l)   + sunwall_e_sky(l)
+         lwup_shadewall(l) = shadewall_r_sky(l) + shadewall_e_sky(l)
+
+      end do
 
       ! now account for absorption and reflection within canyon of fluxes from road and walls
       ! allowing for multiple reflections
@@ -546,120 +568,129 @@ contains
       ! (5) stop iteration when absorption for ith reflection is less than some nominal amount.
       !     small convergence criteria is required to ensure radiation is conserved
 
-      do iter = 1, n
-          ! step (1)
-
-          lwtot  =  (sunwall_r_road  + sunwall_e_road   &
-               + shadewall_r_road  + shadewall_e_road )*canyon_hwr
-          road_a     = 0.0_r8
-          road_r     = 0.0_r8
-          improad_r  = (1._r8-em_improad ) * lwtot
-          improad_a  =     em_improad   * lwtot
-          road_a     = road_a  + improad_a *wtroad_imperv
-          road_r     = road_r  + improad_r *wtroad_imperv
-          perroad_r  = (1._r8-em_perroad ) * lwtot
-          perroad_a  =     em_perroad   * lwtot
-          road_a     = road_a  + perroad_a *wtroad_perv
-          road_r     = road_r  + perroad_r *wtroad_perv
-
-          lwtot  = (road_r_sunwall  + road_e_sunwall )/canyon_hwr  &
-               + (shadewall_r_sunwall  + shadewall_e_sunwall )
-          sunwall_a  =     em_wall   * lwtot
-          sunwall_r  = (1._r8-em_wall ) * lwtot
-
-          lwtot  = (road_r_shadewall  + road_e_shadewall )/canyon_hwr  &
-               + (sunwall_r_shadewall  + sunwall_e_shadewall )
-          shadewall_a  =     em_wall   * lwtot
-          shadewall_r  = (1._r8-em_wall ) * lwtot
-
-          sunwall_e_road       = 0._r8
-          shadewall_e_road     = 0._r8
-          road_e_sunwall       = 0._r8
-          shadewall_e_sunwall  = 0._r8
-          road_e_shadewall     = 0._r8
-          sunwall_e_shadewall  = 0._r8
-
-          ! step (2)
-
-          lwnet_improad    = lwnet_improad    - improad_a
-          lwnet_perroad    = lwnet_perroad    - perroad_a
-          lwnet_sunwall    = lwnet_sunwall    - sunwall_a
-          lwnet_shadewall  = lwnet_shadewall  - shadewall_a
-
-          ! step (3)
-
-          improad_r_sky       = improad_r  * vf_sr
-          improad_r_sunwall   = improad_r * vf_wr
-          improad_r_shadewall = improad_r * vf_wr
-
-          perroad_r_sky       = perroad_r * vf_sr
-          perroad_r_sunwall   = perroad_r * vf_wr
-          perroad_r_shadewall = perroad_r * vf_wr
-
-          road_r_sky          = road_r * vf_sr
-          road_r_sunwall      = road_r * vf_wr
-          road_r_shadewall    = road_r * vf_wr
-
-          sunwall_r_sky       = sunwall_r * vf_sw
-          sunwall_r_road      = sunwall_r * vf_rw
-          sunwall_r_shadewall = sunwall_r * vf_ww
-
-          shadewall_r_sky     = shadewall_r * vf_sw
-          shadewall_r_road    = shadewall_r * vf_rw
-          shadewall_r_sunwall = shadewall_r * vf_ww
-
-          ! step (4)
-
-          lwup_improad   = lwup_improad   + improad_r_sky
-          lwup_perroad   = lwup_perroad   + perroad_r_sky
-          lwup_sunwall   = lwup_sunwall   + sunwall_r_sky
-          lwup_shadewall = lwup_shadewall + shadewall_r_sky
-
-          ! step (5)
-
-          crit = max(road_a, sunwall_a, shadewall_a)
-          if (crit < .001_r8) exit
-        end do
-
-        if (iter >= n) then
+      do fl = 1,num_urbanl
+         l = filter_urbanl(fl)
+
+         do iter = 1, n
+            ! step (1)
+
+            lwtot(l) =  (sunwall_r_road(l) + sunwall_e_road(l)  &
+                 + shadewall_r_road(l) + shadewall_e_road(l))*canyon_hwr(l)
+            road_a(l)    = 0.0_r8
+            road_r(l)    = 0.0_r8
+            improad_r(l) = (1._r8-em_improad(l)) * lwtot(l)
+            improad_a(l) =     em_improad(l)  * lwtot(l)
+            road_a(l)    = road_a(l) + improad_a(l)*wtroad_imperv(l)
+            road_r(l)    = road_r(l) + improad_r(l)*wtroad_imperv(l)
+            perroad_r(l) = (1._r8-em_perroad(l)) * lwtot(l)
+            perroad_a(l) =     em_perroad(l)  * lwtot(l)
+            road_a(l)    = road_a(l) + perroad_a(l)*wtroad_perv(l)
+            road_r(l)    = road_r(l) + perroad_r(l)*wtroad_perv(l)
+
+            lwtot(l) = (road_r_sunwall(l) + road_e_sunwall(l))/canyon_hwr(l) &
+                 + (shadewall_r_sunwall(l) + shadewall_e_sunwall(l))
+            sunwall_a(l) =     em_wall(l)  * lwtot(l)
+            sunwall_r(l) = (1._r8-em_wall(l)) * lwtot(l)
+
+            lwtot(l) = (road_r_shadewall(l) + road_e_shadewall(l))/canyon_hwr(l) &
+                 + (sunwall_r_shadewall(l) + sunwall_e_shadewall(l))
+            shadewall_a(l) =     em_wall(l)  * lwtot(l)
+            shadewall_r(l) = (1._r8-em_wall(l)) * lwtot(l)
+
+            sunwall_e_road(l)      = 0._r8
+            shadewall_e_road(l)    = 0._r8
+            road_e_sunwall(l)      = 0._r8
+            shadewall_e_sunwall(l) = 0._r8
+            road_e_shadewall(l)    = 0._r8
+            sunwall_e_shadewall(l) = 0._r8
+
+            ! step (2)
+
+            lwnet_improad(l)   = lwnet_improad(l)   - improad_a(l)
+            lwnet_perroad(l)   = lwnet_perroad(l)   - perroad_a(l)
+            lwnet_sunwall(l)   = lwnet_sunwall(l)   - sunwall_a(l)
+            lwnet_shadewall(l) = lwnet_shadewall(l) - shadewall_a(l)
+
+            ! step (3)
+
+            improad_r_sky(l)       = improad_r(l) * vf_sr(l)
+            improad_r_sunwall(l)   = improad_r(l) * vf_wr(l)
+            improad_r_shadewall(l) = improad_r(l) * vf_wr(l)
+
+            perroad_r_sky(l)       = perroad_r(l) * vf_sr(l)
+            perroad_r_sunwall(l)   = perroad_r(l) * vf_wr(l)
+            perroad_r_shadewall(l) = perroad_r(l) * vf_wr(l)
+
+            road_r_sky(l)          = road_r(l) * vf_sr(l)
+            road_r_sunwall(l)      = road_r(l) * vf_wr(l)
+            road_r_shadewall(l)    = road_r(l) * vf_wr(l)
+
+            sunwall_r_sky(l)       = sunwall_r(l) * vf_sw(l)
+            sunwall_r_road(l)      = sunwall_r(l) * vf_rw(l)
+            sunwall_r_shadewall(l) = sunwall_r(l) * vf_ww(l)
+
+            shadewall_r_sky(l)     = shadewall_r(l) * vf_sw(l)
+            shadewall_r_road(l)    = shadewall_r(l) * vf_rw(l)
+            shadewall_r_sunwall(l) = shadewall_r(l) * vf_ww(l)
+
+            ! step (4)
+
+            lwup_improad(l)   = lwup_improad(l)   + improad_r_sky(l)
+            lwup_perroad(l)   = lwup_perroad(l)   + perroad_r_sky(l)
+            lwup_sunwall(l)   = lwup_sunwall(l)   + sunwall_r_sky(l)
+            lwup_shadewall(l) = lwup_shadewall(l) + shadewall_r_sky(l)
+
+            ! step (5)
+
+            crit = max(road_a(l), sunwall_a(l), shadewall_a(l))
+            if (crit < .001_r8) exit
+         end do
+         if (iter >= n) then
 #ifndef _OPENACC
-           write (iulog,*) 'urban net longwave radiation error: no convergence'
-           write (iulog,*) 'elm model is stopping'
-           call endrun()
+             write (iulog,*) 'urban net longwave radiation error: no convergence'
+             write (iulog,*) 'elm model is stopping'
+             call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
 #endif
-        endif
+         endif
 
          ! total net longwave radiation for canyon. project wall fluxes to horizontal surface
 
-         lwnet_canyon = 0.0_r8
-         lwnet_canyon = lwnet_canyon + lwnet_improad*wtroad_imperv
-         lwnet_canyon = lwnet_canyon + lwnet_perroad*wtroad_perv
-         lwnet_canyon = lwnet_canyon + (lwnet_sunwall + lwnet_shadewall)*canyon_hwr
+         lwnet_canyon(l) = 0.0_r8
+         lwnet_canyon(l) = lwnet_canyon(l) + lwnet_improad(l)*wtroad_imperv(l)
+         lwnet_canyon(l) = lwnet_canyon(l) + lwnet_perroad(l)*wtroad_perv(l)
+         lwnet_canyon(l) = lwnet_canyon(l) + (lwnet_sunwall(l) + lwnet_shadewall(l))*canyon_hwr(l)
 
          ! total emitted longwave for canyon. project wall fluxes to horizontal
 
-         lwup_canyon = 0.0_r8
-         lwup_canyon = lwup_canyon + lwup_improad*wtroad_imperv
-         lwup_canyon = lwup_canyon + lwup_perroad*wtroad_perv
-         lwup_canyon = lwup_canyon + (lwup_sunwall + lwup_shadewall)*canyon_hwr
+         lwup_canyon(l) = 0.0_r8
+         lwup_canyon(l) = lwup_canyon(l) + lwup_improad(l)*wtroad_imperv(l)
+         lwup_canyon(l) = lwup_canyon(l) + lwup_perroad(l)*wtroad_perv(l)
+         lwup_canyon(l) = lwup_canyon(l) + (lwup_sunwall(l) + lwup_shadewall(l))*canyon_hwr(l)
 
          ! conservation check. note: previous conservation check confirms partioning of incident
          ! atmospheric longwave radiation to road and walls is conserved as
          ! lwdown (from atmosphere) = lwdown_improad + lwdown_perroad + (lwdown_sunwall + lwdown_shadewall)*canyon_hwr
 
-         err = lwnet_canyon - (lwup_canyon - lwdown)
+         err = lwnet_canyon(l) - (lwup_canyon(l) - lwdown(l))
          if (abs(err) > .10_r8 ) then
 #ifndef _OPENACC
             write (iulog,*) 'urban net longwave radiation balance error',err
             write (iulog,*) 'elm model is stopping'
-            call endrun()
+            call endrun(decomp_index=l, elmlevel=namel, msg=errmsg(__FILE__, __LINE__))
 #endif
          end if
 
+      end do
+
       ! Net longwave radiation for roof
 
-      lwup_roof = em_roof*sb*(t_roof**4) + (1._r8-em_roof)*lwdown
-      lwnet_roof = lwup_roof - lwdown
+      do fl = 1,num_urbanl
+         l = filter_urbanl(fl)
+         lwup_roof(l) = em_roof(l)*sb*(t_roof(l)**4) + (1._r8-em_roof(l))*lwdown(l)
+         lwnet_roof(l) = lwup_roof(l) - lwdown(l)
+      end do
+
+    end associate
 
   end subroutine net_longwave
 
diff --git a/components/elm/src/biogeophys/lapack_acc_seq.F90 b/components/elm/src/biogeophys/lapack_acc_seq.F90
deleted file mode 100644
index aeb3ba0946..0000000000
--- a/components/elm/src/biogeophys/lapack_acc_seq.F90
+++ /dev/null
@@ -1,806 +0,0 @@
-module lapack_acc_seq
-  !! This module contains the needed LAPACK/BLAS routines that need
-  !! to be called on the GPU.  As of CUDA 10.1, cuBLAS being called in
-  !! device code is no longer supported
-
-contains
-
-INTEGER FUNCTION idamax(N,DX,INCX)
-  !$acc routine seq
-  !*
-  !*  -- Reference BLAS level1 routine (version 3.8.0) --
-  !*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
-  !*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-  !*     November 2017
-  !*
-  !*     .. Scalar Arguments ..
-  INTEGER incx,n
-  !*     ..
-  !*     .. Array Arguments ..
-  DOUBLE PRECISION dx(*)
-  !*     ..
-  !*
-  !*  =====================================================================
-  !*
-  !*     .. Local Scalars ..
-  DOUBLE PRECISION dmax
-  INTEGER i,ix
-  !*     ..
-  !*     .. Intrinsic Functions ..
-  INTRINSIC dabs
-  !*     ..
-  idamax = 0
-  IF (n.LT.1 .OR. incx.LE.0) RETURN
-  idamax = 1
-  IF (n.EQ.1) RETURN
-  IF (incx.EQ.1) THEN
-    !
-    !        code for increment equal to 1
-    !
-     dmax = dabs(dx(1))
-     DO i = 2,n
-        IF (dabs(dx(i)).GT.dmax) THEN
-           idamax = i
-           dmax = dabs(dx(i))
-        END IF
-     END DO
-  ELSE
-    !
-    !        code for increment not equal to 1
-    !
-     ix = 1
-     dmax = dabs(dx(1))
-     ix = ix + incx
-     DO i = 2,n
-        IF (dabs(dx(ix)).GT.dmax) THEN
-           idamax = i
-           dmax = dabs(dx(ix))
-        END IF
-        ix = ix + incx
-     END DO
-  END IF
-  RETURN
-END FUNCTION idamax
-
- subroutine dswap_oacc(N,DX,INCX,DY,INCY)
-  !$acc routine seq
-  !*
-  !*  -- Reference BLAS level1 routine (version 3.8.0) --
-  !*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
-  !*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-  !*     November 2017
-  !*
-  !*     .. Scalar Arguments ..
-  INTEGER INCX,INCY,N
-  !*     ..
-  !*     .. Array Arguments ..
-  DOUBLE PRECISION DX(*),DY(*)
-  !*     ..
-  !*
-  !*  =====================================================================
-  !*
-  !*     .. Local Scalars ..
-  DOUBLE PRECISION DTEMP
-  INTEGER I,IX,IY,M,MP1
-  !*     ..
-  !*     .. Intrinsic Functions ..
-  INTRINSIC mod
-  !*     ..
-  IF (n.LE.0) RETURN
-  IF (incx.EQ.1 .AND. incy.EQ.1) THEN
-    !*
-    !*       code for both increments equal to 1
-    !*
-    !*
-    !*       clean-up loop
-    !*
-     m = mod(n,3)
-     IF (m.NE.0) THEN
-        DO i = 1,m
-           dtemp = dx(i)
-           dx(i) = dy(i)
-           dy(i) = dtemp
-        END DO
-        IF (n.LT.3) RETURN
-     END IF
-     mp1 = m + 1
-     DO i = mp1,n,3
-        dtemp = dx(i)
-        dx(i) = dy(i)
-        dy(i) = dtemp
-        dtemp = dx(i+1)
-        dx(i+1) = dy(i+1)
-        dy(i+1) = dtemp
-        dtemp = dx(i+2)
-        dx(i+2) = dy(i+2)
-        dy(i+2) = dtemp
-     END DO
-  ELSE
-    !*
-    !*       code for unequal increments or equal increments not equal
-    !*         to 1
-    !*
-     ix = 1
-     iy = 1
-     IF (incx.LT.0) ix = (-n+1)*incx + 1
-     IF (incy.LT.0) iy = (-n+1)*incy + 1
-     DO i = 1,n
-        dtemp = dx(ix)
-        dx(ix) = dy(iy)
-        dy(iy) = dtemp
-        ix = ix + incx
-        iy = iy + incy
-     END DO
-  END IF
-  RETURN
- end subroutine dswap_oacc
-
- subroutine dscal_oacc(N,DA,DX,INCX)
-  !$acc routine seq
-  !*
-  !*  -- Reference BLAS level1 routine (version 3.8.0) --
-  !*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
-  !*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-  !*     November 2017
-  !*
-  !*     .. Scalar Arguments ..
- DOUBLE PRECISION DA
- INTEGER INCX,N
- !*     ..
- !*     .. Array Arguments ..
- DOUBLE PRECISION DX(*)
- !*     ..
- !*
- !*  =====================================================================
- !*
- !*     .. Local Scalars ..
- INTEGER I,M,MP1,NINCX
- !*     ..
- !*     .. Intrinsic Functions ..
- INTRINSIC mod
- !*     ..
- IF (n.LE.0 .OR. incx.LE.0) RETURN
- IF (incx.EQ.1) THEN
-   !*
-   !*        code for increment equal to 1
-   !*
-   !*
-   !*        clean-up loop
-   !*
-    m = mod(n,5)
-    IF (m.NE.0) THEN
-       DO i = 1,m
-          dx(i) = da*dx(i)
-       END DO
-       IF (n.LT.5) RETURN
-    END IF
-    mp1 = m + 1
-    DO i = mp1,n,5
-       dx(i) = da*dx(i)
-       dx(i+1) = da*dx(i+1)
-       dx(i+2) = da*dx(i+2)
-       dx(i+3) = da*dx(i+3)
-       dx(i+4) = da*dx(i+4)
-    END DO
- ELSE
-   !*
-   !*        code for increment not equal to 1
-   !*
-    nincx = n*incx
-    DO i = 1,nincx,incx
-       dx(i) = da*dx(i)
-    END DO
-  END IF
-  RETURN
- end subroutine dscal_oacc
-
- subroutine dger_oacc(M,N,ALPHA,X,INCX,Y,INCY,A,LDA)
-  !$acc routine seq
-  !*
-  !*  -- Reference BLAS level2 routine (version 3.7.0) --
-  !*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
-  !*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-  !*     December 2016
-  !*
-  !*     .. Scalar Arguments ..
- DOUBLE PRECISION ALPHA
- INTEGER INCX,INCY,LDA,M,N
- !*     ..
- !*     .. Array Arguments ..
- DOUBLE PRECISION A(LDA,*),X(*),Y(*)
- !*     ..
- !*
- !*  =====================================================================
- !*
- !*     .. Parameters ..
- DOUBLE PRECISION ZERO
- parameter(zero=0.0d+0)
- !*     ..
- !*     .. Local Scalars ..
- DOUBLE PRECISION TEMP
- INTEGER I,INFO,IX,J,JY,KX
- !*     ..
- !*     .. Intrinsic Functions ..
- INTRINSIC max
- !*     ..
- !*
- !*     Test the input parameters.
- !*
- info = 0
- IF (m.LT.0) THEN
-     info = 1
- ELSE IF (n.LT.0) THEN
-     info = 2
- ELSE IF (incx.EQ.0) THEN
-     info = 5
- ELSE IF (incy.EQ.0) THEN
-     info = 7
- ELSE IF (lda.LT.max(1,m)) THEN
-     info = 9
- END IF
- IF (info.NE.0) THEN
-     print *,"ERROR",info
-     RETURN
- END IF
- !*
- !*     Quick return if possible.
- !*
- IF ((m.EQ.0) .OR. (n.EQ.0) .OR. (alpha.EQ.zero)) RETURN
- !*
- !*     Start the operations. In this version the elements of A are
- !*     accessed sequentially with one pass through A.
- !*
- IF (incy.GT.0) THEN
-     jy = 1
- ELSE
-     jy = 1 - (n-1)*incy
- END IF
- IF (incx.EQ.1) THEN
-     DO 20 j = 1,n
-         IF (y(jy).NE.zero) THEN
-             temp = alpha*y(jy)
-             DO 10 i = 1,m
-                 a(i,j) = a(i,j) + x(i)*temp
-10             CONTINUE
-         END IF
-         jy = jy + incy
-20     CONTINUE
- ELSE
-     IF (incx.GT.0) THEN
-         kx = 1
-     ELSE
-         kx = 1 - (m-1)*incx
-     END IF
-     DO 40 j = 1,n
-         IF (y(jy).NE.zero) THEN
-             temp = alpha*y(jy)
-             ix = kx
-             DO 30 i = 1,m
-                 a(i,j) = a(i,j) + x(ix)*temp
-                 ix = ix + incx
-30             CONTINUE
-         END IF
-         jy = jy + incy
-40     CONTINUE
-  END IF
-  !*
-  RETURN
-  !*
-  !*     End of DGER  .
-  !*
-  end subroutine dger_oacc
-
-SUBROUTINE dgbtf2_oacc( M, N, KL, KU, AB, LDAB, IPIV, INFO )
-  !$acc routine seq
-  !  -- LAPACK computational routine (version 3.7.0) --
-  !  -- LAPACK is a software package provided by Univ. of Tennessee,    --
-  !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-  !     December 2016
-  !
-  !     .. Scalar Arguments ..
- INTEGER            INFO, KL, KU, LDAB, M, N
- !     ..
- !     .. Array Arguments ..
- INTEGER            IPIV( * )
- DOUBLE PRECISION   AB( LDAB, * )
- !     ..
- !
- !  =====================================================================
- !
- !     .. Parameters ..
- DOUBLE PRECISION   ONE, ZERO
- parameter( one = 1.0d+0, zero = 0.0d+0 )
- !     ..
- !     .. Local Scalars ..
- INTEGER            I, J, JP, JU, KM, KV
- !     ..
- !     .. External Functions ..
- !INTEGER            IDAMAX
- !EXTERNAL           idamax
- !     ..
- !     .. External Subroutines ..
- !EXTERNAL           dger, dscal, dswap
- !     ..
- !     .. Intrinsic Functions ..
- INTRINSIC          max, min
- !     ..
- !     .. Executable Statements ..
- !
- !     KV is the number of superdiagonals in the factor U, allowing for
- !     fill-in.
- !
- kv = ku + kl
- !
- !     Test the input parameters.
- !
- info = 0
- IF( m.LT.0 ) THEN
-    info = -1
- ELSE IF( n.LT.0 ) THEN
-    info = -2
- ELSE IF( kl.LT.0 ) THEN
-    info = -3
- ELSE IF( ku.LT.0 ) THEN
-    info = -4
- ELSE IF( ldab.LT.kl+kv+1 ) THEN
-    info = -6
- END IF
- IF( info.NE.0 ) THEN
-    print *, info, "error in "
-    RETURN
- END IF
- !
- !     Quick return if possible
- !
- IF( m.EQ.0 .OR. n.EQ.0 ) RETURN
- !
- !     Gaussian elimination with partial pivoting
- !
- !     Set fill-in elements in columns KU+2 to KV to zero.
- !
- DO 20 j = ku + 2, min( kv, n )
-    DO 10 i = kv - j + 2, kl
-       ab( i, j ) = zero
-10    CONTINUE
-20 CONTINUE
-  !
-  ! JU is the index of the last column affected by the current stage
-  ! of the factorization.
-  !
- ju = 1
- !
- DO 40 j = 1, min( m, n )
-   !
-   !  Set fill-in elements in column J+KV to zero.
-   !
-    IF( j+kv.LE.n ) THEN
-       DO 30 i = 1, kl
-          ab( i, j+kv ) = zero
-30       CONTINUE
-    END IF
-    !
-    ! Find pivot and test for singularity. KM is the number of
-    ! subdiagonal elements in the current column.
-    !
-    km = min( kl, m-j )
-    jp = idamax( km+1, ab( kv+1, j ), 1 )
-    ipiv( j ) = jp + j - 1
-    IF( ab( kv+jp, j ).NE.zero ) THEN
-       ju = max( ju, min( j+ku+jp-1, n ) )
-       !
-       ! Apply interchange to columns J to JU.
-       !
-       IF( jp.NE.1 ) &
-         CALL dswap_oacc( ju-j+1, ab( kv+jp, j ), ldab-1, &
-                     ab( kv+1, j ), ldab-1 )
-
-       IF( km.GT.0 ) THEN
-         !
-         !   Compute multipliers.
-         !
-          CALL dscal_oacc( km, one / ab( kv+1, j ), ab( kv+2, j ), 1 )
-          !
-          !  Update trailing submatrix within the band.
-          !
-          IF( ju.GT.j ) &
-            CALL dger_oacc( km, ju-j, -one, ab( kv+2, j ), 1, &
-                       ab( kv, j+1 ), ldab-1, ab( kv+1, j+1 ), &
-                       ldab-1 )
-       END IF
-    ELSE
-      !
-      !  If pivot is zero, set INFO to the index of the pivot
-      !  unless a zero pivot has already been found.
-      !
-       IF( info.EQ.0 )  info = j
-
-    END IF
-40 CONTINUE
- RETURN
-!
-!     End of DGBTF2
-!
-END SUBROUTINE DGBTF2_oacc
-
-SUBROUTINE dgbtrf_oacc( M, N, KL, KU, AB, LDAB, IPIV, INFO )
-!$acc routine seq
-!  -- LAPACK computational routine (version 3.7.0) --
-!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
-!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-!     December 2016
-!
-!     .. Scalar Arguments ..
-INTEGER            INFO, KL, KU, LDAB, M, N
-!     ..
-!     .. Array Arguments ..
-INTEGER            IPIV( * )
-DOUBLE PRECISION   AB( LDAB, * )
-!     ..
-!
-!  =====================================================================
-!
-!     .. Parameters ..
-DOUBLE PRECISION   ONE, ZERO
-parameter( one = 1.0d+0, zero = 0.0d+0 )
-INTEGER            NBMAX, LDWORK
-parameter( nbmax = 64, ldwork = nbmax+1 )
-!     ..
-!     .. Local Scalars ..
-INTEGER            I, I2, I3, II, IP, J, J2, J3, JB, JJ, JM, JP, &
-                   JU, K2, KM, KV, NB, NW
-DOUBLE PRECISION   TEMP
-!     ..
-!     .. Local Arrays ..
-DOUBLE PRECISION   WORK13( LDWORK, NBMAX ), &
-                   WORK31( LDWORK, NBMAX )
-!     ..
-!     .. External Functions ..
-!INTEGER            IDAMAX !, ILAENV
-!EXTERNAL           idamax !, ilaenv
-!     ..
-!     .. External Subroutines ..
-!EXTERNAL           dgbtf2, dger, dscal, dswap
-!     ..
-!     .. Intrinsic Functions ..
-INTRINSIC          max, min
-!     ..
-!     .. Executable Statements ..
-!
-!     KV is the number of superdiagonals in the factor U, allowing for
-!     fill-in
-!
-kv = ku + kl
-!
-!     Test the input parameters.
-!
-info = 0
-IF( m.LT.0 ) THEN
-   info = -1
-ELSE IF( n.LT.0 ) THEN
-   info = -2
-ELSE IF( kl.LT.0 ) THEN
-   info = -3
-ELSE IF( ku.LT.0 ) THEN
-   info = -4
-ELSE IF( ldab.LT.kl+kv+1 ) THEN
-   info = -6
-END IF
-IF( info.NE.0 ) THEN
-   print *, "error in dgbtrf", info
-   RETURN
-END IF
-!
-!     Quick return if possible
-!
-IF( m.EQ.0 .OR. n.EQ.0 )   RETURN
-!
-!     Determine the block size for this environment
-!
-!nb = ilaenv( 1, 'DGBTRF', ' ', m, n, kl, ku )
-!
-!     The block size must not exceed the limit set by the size of the
-!     local arrays WORK13 and WORK31.
-!
-!
-!        Use unblocked code
-!
-   CALL dgbtf2_oacc( m, n, kl, ku, ab, ldab, ipiv, info )
-
-!
-RETURN
-!
-!     End of DGBTRF
-!
-END subroutine dgbtrf_oacc
-
-
-SUBROUTINE dtbsv_oacc(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX)
-  !$acc routine seq
-  !NOTE : FOR DGBTRS WE HARDCODE UPLO='UPPER',TRANS='NO TRANSPOSE',DIAG='NON-UNIT'
-  !*
-  !*  -- Reference BLAS level2 routine (version 3.7.0) --
-  !*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
-  !*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-  !*     December 2016
-  !*
-  !*     .. Scalar Arguments ..
- INTEGER INCX,K,LDA,N
- INTEGER DIAG,TRANS,UPLO
- !*     ..
- !*     .. Array Arguments ..
- DOUBLE PRECISION A(LDA,*),X(*)
- !*     ..
- !*
- !*  =====================================================================
- !*
- !*     .. Parameters ..
- DOUBLE PRECISION ZERO
- parameter(zero=0.0d+0)
- !*     ..
- !*     .. Local Scalars ..
- DOUBLE PRECISION TEMP
- INTEGER I,INFO,IX,J,JX,KPLUS1,KX,L
- LOGICAL NOUNIT
- !*     ..
- !*     .. External Subroutines ..
- !*     ..
- !*     .. Intrinsic Functions ..
- INTRINSIC max,min
- !*     ..
- !*
- !*     Test the input parameters.
- !*
- info = 0
- IF (uplo .ne. 1 ) THEN
-     info = 1
- ELSE IF (trans .ne. 0 ) THEN
-     info = 2
- ELSE IF (diag .ne. 0) THEN
-     info = 3
- ELSE IF (n.LT.0) THEN
-     info = 4
- ELSE IF (k.LT.0) THEN
-     info = 5
- ELSE IF (lda.LT. (k+1)) THEN
-     info = 7
- ELSE IF (incx.EQ.0) THEN
-     info = 9
- END IF
- IF (info.NE.0) THEN
-     print *, "ERRROR in dtbsv", info
-     RETURN
- END IF
- !*
- !*     Quick return if possible.
- !*
- IF (n.EQ.0) RETURN
- !*
- nounit = .true.
- !*
- !*     Set up the start point in X if the increment is not unity. This
- !*     will be  ( N - 1 )*INCX  too small for descending loops.
- !*
- IF (incx.LE.0) THEN
-     kx = 1 - (n-1)*incx
- ELSE IF (incx.NE.1) THEN
-     kx = 1
- END IF
- !*
- !*     Start the operations. In this version the elements of A are
- !*     accessed by sequentially with one pass through A.
- !*
-   !*
-   !*        Form  x := inv( A )*x.
-   !*
-         kplus1 = k + 1
-         IF (incx.EQ.1) THEN
-             DO 20 j = n,1,-1
-                 IF (x(j).NE.zero) THEN
-                     l = kplus1 - j
-                     IF (nounit) x(j) = x(j)/a(kplus1,j)
-                     temp = x(j)
-                     DO 10 i = j - 1,max(1,j-k),-1
-                         x(i) = x(i) - temp*a(l+i,j)
-10                     CONTINUE
-                 END IF
-20             CONTINUE
-         ELSE
-             kx = kx + (n-1)*incx
-             jx = kx
-             DO 40 j = n,1,-1
-                 kx = kx - incx
-                 IF (x(jx).NE.zero) THEN
-                     ix = kx
-                     l = kplus1 - j
-                     IF (nounit) x(jx) = x(jx)/a(kplus1,j)
-                     temp = x(jx)
-                     DO 30 i = j - 1,max(1,j-k),-1
-                         x(ix) = x(ix) - temp*a(l+i,j)
-                         ix = ix - incx
-30                     CONTINUE
-                 END IF
-                 jx = jx - incx
-40             CONTINUE
-         END IF
-         !*
- RETURN
- !*
- !*     End of DTBSV .
- !*
-END subroutine DTBSV_oacc
-
-SUBROUTINE dgbtrs_oacc( TRANS, N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )
-  !$acc routine seq
-  !  -- LAPACK computational routine (version 3.7.0) --
-  !  -- LAPACK is a software package provided by Univ. of Tennessee,    --
-  !  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-  !     December 2016
-  !
-  !     .. Scalar Arguments ..
-   INTEGER          TRANS
-   INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS
-   !     ..
-   !     .. Array Arguments ..
-   INTEGER            IPIV( * )
-   DOUBLE PRECISION   AB( LDAB, * ), B( LDB, * )
-   !     ..
-   !
-   !  =====================================================================
-   !
-   !     .. Parameters ..
-   DOUBLE PRECISION   ONE
-   parameter( one = 1.0d+0 )
-   !     ..
-   !     .. Local Scalars ..
-   LOGICAL            LNOTI, NOTRAN
-   INTEGER            I, J, KD, L, LM
-   !*     ..
-   !*     .. External Functions ..
-   !LOGICAL            LSAME
-   !EXTERNAL           lsame
-   !*     ..
-   !*     .. External Subroutines ..
-   !EXTERNAL           dgemv, dger, dswap, dtbsv
-   !*     ..
-   !*     .. Intrinsic Functions ..
-   INTRINSIC          max, min
-   !*     ..
-   !*     .. Executable Statements ..
-   !*
-   !*     Test the input parameters.
-   !*
-   info = 0
-   notran = .true.
-   IF( .NOT.notran ) THEN
-      info = -1
-   ELSE IF( n.LT.0 ) THEN
-      info = -2
-   ELSE IF( kl.LT.0 ) THEN
-      info = -3
-   ELSE IF( ku.LT.0 ) THEN
-      info = -4
-   ELSE IF( nrhs.LT.0 ) THEN
-      info = -5
-   ELSE IF( ldab.LT.( 2*kl+ku+1 ) ) THEN
-      info = -7
-   ELSE IF( ldb.LT.max( 1, n ) ) THEN
-      info = -10
-   END IF
-   IF( info.NE.0 ) THEN
-      print *,"error in solving Ax=b",info
-      RETURN
-   END IF
-   !
-   !     Quick return if possible
-   !
-   IF( n.EQ.0 .OR. nrhs.EQ.0 ) RETURN
-   !
-   kd = ku + kl + 1
-   lnoti = kl.GT.0
-   !
-   IF( notran ) THEN
-     !*
-     !*        Solve  A*X = B.
-     !*
-     !*        Solve L*X = B, overwriting B with X.
-     !*
-     !*        L is represented as a product of permutations and unit lower
-     !*        triangular matrices L = P(1) * L(1) * ... * P(n-1) * L(n-1),
-     !*        where each transformation L(i) is a rank-one modification of
-     !*        the identity matrix.
-     !*
-      IF( lnoti ) THEN
-         DO 10 j = 1, n - 1
-            lm = min( kl, n-j )
-            l = ipiv( j )
-            IF( l.NE.j )  CALL dswap_oacc( nrhs, b( l, 1 ), ldb, b( j, 1 ), ldb )
-
-            CALL dger_oacc( lm, nrhs, -one, ab( kd+1, j ), 1, b( j, 1 ), &
-                      ldb, b( j+1, 1 ), ldb )
-10       CONTINUE
-      END IF
-      !
-      DO 20 i = 1, nrhs
-        !*
-        !*           Solve U*X = B, overwriting B with X.
-        !*
-         CALL dtbsv_oacc( 1, 0, 0, n, kl+ku, &
-                    ab, ldab, b( 1, i ), 1 )
-20    CONTINUE
-  !!
-   END IF
-   RETURN
-   !*
-   !*     End of DGBTRS
-   !*
- END subroutine DGBTRS_oacc
-
-
-
-subroutine dgbsv_oacc( N, KL, KU, NRHS, AB, LDAB, B, LDB, INFO )
-!$acc routine seq
-!  -- LAPACK driver routine (version 3.7.0) --
-!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
-!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-!     December 2016
-!
-!     .. Scalar Arguments ..
-  INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS
-!*     ..
-!*     .. Array Arguments ..
-  DOUBLE PRECISION   AB( LDAB, * ), B( LDB, * )
-!     ..
-!
-!  =====================================================================
-!
-!     .. External Subroutines ..
-!  EXTERNAL           dgbtrf, dgbtrs
-!     ..
-!     .. Intrinsic Functions ..
-  INTRINSIC          max
-  INTEGER   :: IPIV(1:n)
-!     ..
-!     .. Executable Statements ..
-!
-!     Test the input parameters.
-!
-  info = 0
-  IF( n.LT.0 ) THEN
-     info = -1
-  ELSE IF( kl.LT.0 ) THEN
-     info = -2
-  ELSE IF( ku.LT.0 ) THEN
-     info = -3
-  ELSE IF( nrhs.LT.0 ) THEN
-     info = -4
-  ELSE IF( ldab.LT.2*kl+ku+1 ) THEN
-     info = -6
-  ELSE IF( ldb.LT.max( n, 1 ) ) THEN
-     info = -9
-  END IF
-  IF( info.NE.0 ) THEN
-      print *,"error in dgbsv",info
-     RETURN
-  END IF
-!
-!     Compute the LU factorization of the band matrix A.
-!
-  CALL dgbtrf_oacc( n, n, kl, ku, ab, ldab, ipiv, info )
-  IF( info.EQ.0 ) THEN
-!
-!        Solve the system A*X = B, overwriting B with X.
-!   I changed the first argument from 'No transpose' to 0
-     CALL dgbtrs_oacc( 0, n, kl, ku, nrhs, ab, ldab, ipiv, &
-                 b, ldb, info )
-  else
-    print *,"error: dgbsv",info
-
-  END IF
-  RETURN
-!
-!     End of DGBSV
-!
-END subroutine dgbsv_oacc
-
-
-end module lapack_acc_seq
diff --git a/components/elm/src/cpl/lnd_comp_mct.F90 b/components/elm/src/cpl/lnd_comp_mct.F90
index f43bd3dab2..bd296e5b70 100644
--- a/components/elm/src/cpl/lnd_comp_mct.F90
+++ b/components/elm/src/cpl/lnd_comp_mct.F90
@@ -171,10 +171,10 @@ contains
     call shr_file_getLogLevel(shrloglev)
     call shr_file_setLogUnit (iulog)
     
-!#ifdef _OPENACC
-!    if(masterproc) write(iulog,*), "Initializing OpenACC Devices"
-!    call acc_initialization()
-!#endif
+#ifdef _OPENACC
+    if(masterproc) write(iulog,*), "Initializing OpenACC Devices"
+    call acc_initialization()
+#endif
 
 #if _CUDA
     istat = cudaMemGetInfo(free1, total)
@@ -358,7 +358,7 @@ contains
     !
     ! !USES:
     use shr_kind_mod    ,  only : r8 => shr_kind_r8
-    use elm_instMod     , only : lnd2atm_vars, atm2lnd_vars, lnd2glc_vars, glc2lnd_vars, cpl_bypass_input
+    use elm_instMod     , only : lnd2atm_vars, atm2lnd_vars, lnd2glc_vars, glc2lnd_vars
     use elm_driver      ,  only : elm_drv
     use clm_time_manager,  only : get_curr_date, get_nstep, get_curr_calday, get_step_size
     use clm_time_manager,  only : advance_timestep, set_nextsw_cday,update_rad_dtime
@@ -467,11 +467,18 @@ contains
 
     
     ! Map to elm (only when state and/or fluxes need to be updated)
+    call cpu_time(startt) 
     call t_startf ('lc_lnd_import')
-    call lnd_import( bounds, x2l_l%rattr, atm2lnd_vars, glc2lnd_vars, lnd2atm_vars,cpl_bypass_input )
+    call lnd_import( bounds, x2l_l%rattr, atm2lnd_vars, glc2lnd_vars, lnd2atm_vars)
     call t_stopf ('lc_lnd_import')
+    call cpu_time(stopt) 
+    write(iulog, *) "TIMING :: lnd_import ",(stopt-startt)*1.E+3, "ms" 
    
-    call duplicate_lnd_points( bounds, x2l_l%rattr, atm2lnd_vars, glc2lnd_vars, lnd2atm_vars, cpl_bypass_input)
+    ! call cpu_time(startt)  
+    ! call duplicate_lnd_points( bounds, x2l_l%rattr, atm2lnd_vars, glc2lnd_vars, lnd2atm_vars)
+    ! call cpu_time(stopt) 
+    ! write(iulog, *) "TIMING :: duplicate_lnd_points ",(stopt-startt)*1.E+3, "ms" 
+    
     ! Use infodata to set orbital values if updated mid-run
 
     call seq_infodata_GetData( infodata, orb_eccen=eccen, orb_mvelpp=mvelpp, &
@@ -731,7 +738,8 @@ contains
     deallocate(idata)
 
   end subroutine lnd_domain_mct
-  
+
+#ifdef _OPENACC
   subroutine acc_initialization()
       use openacc 
       use spmdMod,    only : iam 
@@ -753,5 +761,5 @@ contains
      write(iulog,*) "iam, mygpu:",iam,mygpu, ngpus
 
   end subroutine 
-
+#endif
 end module lnd_comp_mct
diff --git a/components/elm/src/cpl/lnd_import_export.F90 b/components/elm/src/cpl/lnd_import_export.F90
index 564f4efa6f..9660e09351 100644
--- a/components/elm/src/cpl/lnd_import_export.F90
+++ b/components/elm/src/cpl/lnd_import_export.F90
@@ -5,7 +5,7 @@ module lnd_import_export
   use decompmod    , only: bounds_type
   use lnd2atmType  , only: lnd2atm_type
   use lnd2glcMod   , only: lnd2glc_type
-  use atm2lndType  , only: atm2lnd_type, cplbypass_atminput_type
+  use atm2lndType  , only: atm2lnd_type
   use glc2lndMod   , only: glc2lnd_type
   use GridcellType , only: grc_pp          ! for access to gridcell topology
   use TopounitDataType , only: top_as, top_af  ! atmospheric state and flux variables
@@ -15,12 +15,11 @@ module lnd_import_export
   !
   implicit none
   integer, parameter :: num_unique_sites = 42 !42 is ameriflux in NA
-  logical, parameter :: duplicate_run = .true.
   !===============================================================================
 
 contains
 
-   subroutine duplicate_lnd_points(bounds, x2l, atm2lnd_vars, glc2lnd_vars, lnd2atm_vars,cpl_bypass_input)
+   subroutine duplicate_lnd_points(bounds, x2l, atm2lnd_vars, glc2lnd_vars, lnd2atm_vars)
       !
       use elm_varcon       , only: rair, o2_molar_const, c13ratio
       use elm_varctl       , only: iulog
@@ -32,8 +31,8 @@ contains
       type(atm2lnd_type) , intent(inout) :: atm2lnd_vars      ! clm internal input data type
       type(glc2lnd_type) , intent(inout) :: glc2lnd_vars      ! clm internal input data type
       type(lnd2atm_type) , intent(in)    :: lnd2atm_vars
-      type(cplbypass_atminput_type), intent(inout) :: cpl_bypass_input
       !
+#ifdef CPL_BYPASS
       integer :: g, dup_g, topo, yr, mon, day, tod
       real(r8) :: e, ea         ! vapor pressure (Pa)
       real(r8) :: qsat,vp       ! saturation specific humidity (kg/kg)
@@ -65,17 +64,10 @@ contains
       tdc(t) = min( 50._r8, max(-50._r8,(t-SHR_CONST_TKFRZ)) )
       esatw(t) = 100._r8*(a0+t*(a1+t*(a2+t*(a3+t*(a4+t*(a5+t*a6))))))
       esati(t) = 100._r8*(b0+t*(b1+t*(b2+t*(b3+t*(b4+t*(b5+t*b6))))))
-      ! End declarations
-      if(.not. duplicate_run) then 
-        write(iulog,*) "Not duplicating points:"
-        return
-      endif 
       write(iulog,*) "Duplicating atm Data "
       call shr_sys_flush(iulog)
-      
       do g = bounds%begg+num_unique_sites, bounds%endg
          dup_g = mod(g-1,num_unique_sites)+1
-         ! write(iulog,*) "G, Dup_g", g, dup_g
          !!!!!!!!!!!!!!!!!!!!!
          atm2lnd_vars%forc_flood_grc(g) = atm2lnd_vars%forc_flood_grc(dup_g)
          !
@@ -142,31 +134,31 @@ contains
          tindex = atm2lnd_vars%tindex(dup_g,:,:)
          !
          if (atm2lnd_vars%metsource == 5) then
-          forc_rainc = max((((cpl_bypass_input%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_rainc = max((((atm2lnd_vars%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                                         atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,dup_g,mon) + &
                                         atm2lnd_vars%var_offset(5,dup_g,mon)), 0.0_r8)
-          forc_rainl = max((((cpl_bypass_input%atm_input(11,dup_g,1,tindex(11,2))*atm2lnd_vars%scale_factors(11)+ &
+          forc_rainl = max((((atm2lnd_vars%atm_input(11,dup_g,1,tindex(11,2))*atm2lnd_vars%scale_factors(11)+ &
                                         atm2lnd_vars%add_offsets(11)))*atm2lnd_vars%var_mult(11,dup_g,mon) + &
                                         atm2lnd_vars%var_offset(11,dup_g,mon)), 0.0_r8)
-          forc_snowc = max((((cpl_bypass_input%atm_input(12,dup_g,1,tindex(12,2))*atm2lnd_vars%scale_factors(12)+ &
+          forc_snowc = max((((atm2lnd_vars%atm_input(12,dup_g,1,tindex(12,2))*atm2lnd_vars%scale_factors(12)+ &
                                         atm2lnd_vars%add_offsets(12)))*atm2lnd_vars%var_mult(12,dup_g,mon) + &
                                         atm2lnd_vars%var_offset(12,dup_g,mon)), 0.0_r8)
-          forc_snowl = max((((cpl_bypass_input%atm_input(13,dup_g,1,tindex(13,2))*atm2lnd_vars%scale_factors(13)+ &
+          forc_snowl = max((((atm2lnd_vars%atm_input(13,dup_g,1,tindex(13,2))*atm2lnd_vars%scale_factors(13)+ &
                                         atm2lnd_vars%add_offsets(13)))*atm2lnd_vars%var_mult(13,dup_g,mon) + &
                                           atm2lnd_vars%var_offset(13,dup_g,mon)), 0.0_r8)
          else
           frac = (atm2lnd_vars%forc_t_not_downscaled_grc(dup_g) - SHR_CONST_TKFRZ)*0.5_R8       ! ramp near freezing
           frac = min(1.0_R8,max(0.0_R8,frac))           ! bound in [0,1]
           !Don't interpolate rainfall data
-          forc_rainc = 0.1_R8 * frac * max((((cpl_bypass_input%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_rainc = 0.1_R8 * frac * max((((atm2lnd_vars%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                                         atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,dup_g,mon) + &
                                         atm2lnd_vars%var_offset(5,dup_g,mon)), 0.0_r8)
-          forc_rainl = 0.9_R8 * frac * max((((cpl_bypass_input%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_rainl = 0.9_R8 * frac * max((((atm2lnd_vars%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                                          atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,dup_g,mon) + &
                                          atm2lnd_vars%var_offset(5,dup_g,mon)), 0.0_r8)
-          forc_snowc = 0.1_R8 * (1.0_R8 - frac) * max((((cpl_bypass_input%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_snowc = 0.1_R8 * (1.0_R8 - frac) * max((((atm2lnd_vars%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                   atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,dup_g,mon) + atm2lnd_vars%var_offset(5,dup_g,mon)), 0.0_r8)
-          forc_snowl = 0.9_R8 * (1.0_R8 - frac) * max((((cpl_bypass_input%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_snowl = 0.9_R8 * (1.0_R8 - frac) * max((((atm2lnd_vars%atm_input(5,dup_g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                   atm2lnd_vars%add_offsets(5))) * atm2lnd_vars%var_mult(5,dup_g,mon) + atm2lnd_vars%var_offset(5,dup_g,mon)), 0.0_r8)
          end if
 
@@ -215,11 +207,11 @@ contains
          end do
       end do
       call shr_sys_flush(iulog)
-
+#endif
    end subroutine duplicate_lnd_points
 
   !===============================================================================
-  subroutine lnd_import( bounds, x2l, atm2lnd_vars, glc2lnd_vars, lnd2atm_vars,cpl_bypass_input )
+  subroutine lnd_import( bounds, x2l, atm2lnd_vars, glc2lnd_vars, lnd2atm_vars)
 
     !---------------------------------------------------------------------------
     ! !DESCRIPTION:
@@ -250,7 +242,6 @@ contains
     type(atm2lnd_type) , intent(inout) :: atm2lnd_vars      ! clm internal input data type
     type(glc2lnd_type) , intent(inout) :: glc2lnd_vars      ! clm internal input data type
     type(lnd2atm_type) , intent(in)    :: lnd2atm_vars
-    type(cplbypass_atminput_type), intent(inout) :: cpl_bypass_input
     !
     ! !LOCAL VARIABLES:
     integer  :: g,topo,i,m,thism,nstep,ier  ! indices, number of steps, and error code
@@ -293,6 +284,10 @@ contains
     real(r8) :: tbot, tempndep(1,1,158), thiscalday, wt1(14), wt2(14), thisdoy
     real(r8) :: site_metdata(14,12)
     real(r8) :: var_month_mean(12)
+    !real(r8) :: hdm1(720,360,1), hdm2(720,360,1)
+    !real(r8) :: lnfm1(192,94,2920)
+    !real(r8) :: ndep1(144,96,1), ndep2(144,96,1)
+    !real(r8) :: aerodata(14,144,96,14)
     integer  :: lnfmind(2)
     integer  :: var_month_count(12)
     integer*2 :: temp(1,500000)
@@ -315,7 +310,6 @@ contains
     character(len=CL)  :: stream_fldFileName_popdens ! poplulation density stream filename
     character(len=CL)  :: stream_fldFileName_ndep    ! nitrogen deposition stream filename
     logical :: use_sitedata, has_zonefile, use_daymet, use_livneh
-    integer :: endg
     data caldaym / 1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 /
 
     ! Constants to compute vapor pressure
@@ -360,6 +354,8 @@ contains
     stream_fldFileName_lightng = ' '
     stream_fldFileName_popdens = ' '
 
+    !write(iulog, *) "Modified LND_IMPORT TO DUPLICATE -- REVERT IF DOING PRODUCTION RUNS"
+    call shr_sys_flush(iulog)
 
     co2_type_idx = 0
     if (co2_type == 'prognostic') then
@@ -379,14 +375,9 @@ contains
     ! by 1000 mm/m resulting in an overall factor of unity.
     ! Below the units are therefore given in mm/s.
     thisng = bounds%endg - bounds%begg + 1
-    if(thisng > num_unique_sites .and. duplicate_run) then 
-      endg = num_unique_sites
-    else
-      endg = bounds%endg
-    end if 
     do g = bounds%begg, bounds%endg !bounds%begg+42-1
        i = 1 + (g - bounds%begg)
-
+        
        ! Determine flooding input, sign convention is positive downward and
        ! hierarchy is atm/glc/lnd/rof/ice/ocn.  so water sent from rof to land is negative,
        ! change the sign to indicate addition of water to system.
@@ -630,11 +621,11 @@ contains
             if (.not. const_climate_hist .and. (yr .ge. 1850 .or. use_sitedata)) counti(1) = atm2lnd_vars%timelen(v)
 
             if (i == 1 .and. v == 1)  then
-              allocate(cpl_bypass_input%atm_input       (met_nvars,bounds%begg:bounds%endg,1,1:counti(1)))
-              print *, "met_nvars, bounds%endg, counti(1):",met_nvars,bounds%endg,counti(1) 
+              allocate(atm2lnd_vars%atm_input       (met_nvars,bounds%begg:bounds%endg,1,1:counti(1)))
+              print *, "met_nvars, bounds%endg, counti:", met_nvars, bounds%endg, counti(1) 
             end if
-
-            ierr = nf90_get_var(met_ncids(v), varid, cpl_bypass_input%atm_input(v,g:g,1,1:counti(1)), starti(1:2), counti(1:2))
+            
+            ierr = nf90_get_var(met_ncids(v), varid, atm2lnd_vars%atm_input(v,g:g,1,1:counti(1)), starti(1:2), counti(1:2))
             ierr = nf90_close(met_ncids(v))
 
             if (use_sitedata .and. v == 1) then
@@ -656,7 +647,7 @@ contains
                 do m=1,12
                   if (thisdoy .ge. caldaym(m) .and. thisdoy .lt. caldaym(m+1)) thism = m
                 enddo
-                var_month_mean(thism) = var_month_mean(thism) + (cpl_bypass_input%atm_input(v,g,1,i)* &
+                var_month_mean(thism) = var_month_mean(thism) + (atm2lnd_vars%atm_input(v,g,1,i)* &
                                           atm2lnd_vars%scale_factors(v) + atm2lnd_vars%add_offsets(v))
                 var_month_count(thism)= var_month_count(thism)+1
               end do
@@ -753,25 +744,25 @@ contains
         end do
 
         !Air temperature
-        atm2lnd_vars%forc_t_not_downscaled_grc(g)  = min(((cpl_bypass_input%atm_input(1,g,1,tindex(1,1))*atm2lnd_vars%scale_factors(1)+ &
-                                                      atm2lnd_vars%add_offsets(1))*wt1(1) + (cpl_bypass_input%atm_input(1,g,1,tindex(1,2))* &
+        atm2lnd_vars%forc_t_not_downscaled_grc(g)  = min(((atm2lnd_vars%atm_input(1,g,1,tindex(1,1))*atm2lnd_vars%scale_factors(1)+ &
+                                                      atm2lnd_vars%add_offsets(1))*wt1(1) + (atm2lnd_vars%atm_input(1,g,1,tindex(1,2))* &
                                                       atm2lnd_vars%scale_factors(1)+atm2lnd_vars%add_offsets(1))*wt2(1)) * &
                                                       atm2lnd_vars%var_mult(1,g,mon) + atm2lnd_vars%var_offset(1,g,mon), 323._r8)
-        atm2lnd_vars%forc_th_not_downscaled_grc(g) = min(((cpl_bypass_input%atm_input(1,g,1,tindex(1,1))*atm2lnd_vars%scale_factors(1)+ &
-                                                      atm2lnd_vars%add_offsets(1))*wt1(1) + (cpl_bypass_input%atm_input(1,g,1,tindex(1,2))* &
+        atm2lnd_vars%forc_th_not_downscaled_grc(g) = min(((atm2lnd_vars%atm_input(1,g,1,tindex(1,1))*atm2lnd_vars%scale_factors(1)+ &
+                                                      atm2lnd_vars%add_offsets(1))*wt1(1) + (atm2lnd_vars%atm_input(1,g,1,tindex(1,2))* &
                                                       atm2lnd_vars%scale_factors(1)+atm2lnd_vars%add_offsets(1))*wt2(1)) * &
                                                       atm2lnd_vars%var_mult(1,g,mon) + atm2lnd_vars%var_offset(1,g,mon), 323._r8)
 
         tbot = atm2lnd_vars%forc_t_not_downscaled_grc(g)
 
         !Air pressure
-        atm2lnd_vars%forc_pbot_not_downscaled_grc(g) = max(((cpl_bypass_input%atm_input(2,g,1,tindex(2,1))*atm2lnd_vars%scale_factors(2)+ &
-                                                        atm2lnd_vars%add_offsets(2))*wt1(2) + (cpl_bypass_input%atm_input(2,g,1,tindex(2,2)) &
+        atm2lnd_vars%forc_pbot_not_downscaled_grc(g) = max(((atm2lnd_vars%atm_input(2,g,1,tindex(2,1))*atm2lnd_vars%scale_factors(2)+ &
+                                                        atm2lnd_vars%add_offsets(2))*wt1(2) + (atm2lnd_vars%atm_input(2,g,1,tindex(2,2)) &
                                                         *atm2lnd_vars%scale_factors(2)+atm2lnd_vars%add_offsets(2))*wt2(2)) * &
                                                         atm2lnd_vars%var_mult(2,g,mon) + atm2lnd_vars%var_offset(2,g,mon), 4e4_r8)
         !Specific humidity
-        atm2lnd_vars%forc_q_not_downscaled_grc(g) = max(((cpl_bypass_input%atm_input(3,g,1,tindex(3,1))*atm2lnd_vars%scale_factors(3)+ &
-                                                     atm2lnd_vars%add_offsets(3))*wt1(3) + (cpl_bypass_input%atm_input(3,g,1,tindex(3,2)) &
+        atm2lnd_vars%forc_q_not_downscaled_grc(g) = max(((atm2lnd_vars%atm_input(3,g,1,tindex(3,1))*atm2lnd_vars%scale_factors(3)+ &
+                                                     atm2lnd_vars%add_offsets(3))*wt1(3) + (atm2lnd_vars%atm_input(3,g,1,tindex(3,2)) &
                                                      *atm2lnd_vars%scale_factors(3)+atm2lnd_vars%add_offsets(3))*wt2(3)) * &
                                                      atm2lnd_vars%var_mult(3,g,mon) + atm2lnd_vars%var_offset(3,g,mon), 1e-9_r8)
 
@@ -786,8 +777,8 @@ contains
         end if
 
         !use longwave from file if provided
-        atm2lnd_vars%forc_lwrad_not_downscaled_grc(g) = ((cpl_bypass_input%atm_input(7,g,1,tindex(7,1))*atm2lnd_vars%scale_factors(7)+ &
-                                                        atm2lnd_vars%add_offsets(7))*wt1(7) + (cpl_bypass_input%atm_input(7,g,1,tindex(7,2)) &
+        atm2lnd_vars%forc_lwrad_not_downscaled_grc(g) = ((atm2lnd_vars%atm_input(7,g,1,tindex(7,1))*atm2lnd_vars%scale_factors(7)+ &
+                                                        atm2lnd_vars%add_offsets(7))*wt1(7) + (atm2lnd_vars%atm_input(7,g,1,tindex(7,2)) &
                                                         *atm2lnd_vars%scale_factors(7)+atm2lnd_vars%add_offsets(7))*wt2(7)) * &
                                                         atm2lnd_vars%var_mult(7,g,mon) + atm2lnd_vars%var_offset(7,g,mon)
         if (atm2lnd_vars%forc_lwrad_not_downscaled_grc(g) .le. 50 .or. atm2lnd_vars%forc_lwrad_not_downscaled_grc(g) .ge. 600) then
@@ -831,29 +822,29 @@ contains
         if (atm2lnd_vars%metsource == 5) then
             wt2(4)=1.0   !cosz interp not working
             wt2(8:10)=1.0
-            swndf = max(((cpl_bypass_input%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
+            swndf = max(((atm2lnd_vars%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
                                      atm2lnd_vars%add_offsets(4))*wt2(4)), 0.0_r8)
-            swndr = max(((cpl_bypass_input%atm_input(8,g,1,tindex(8,2))*atm2lnd_vars%scale_factors(8)+ &
+            swndr = max(((atm2lnd_vars%atm_input(8,g,1,tindex(8,2))*atm2lnd_vars%scale_factors(8)+ &
                                      atm2lnd_vars%add_offsets(8))*wt2(8)), 0.0_r8)
-            swvdf = max(((cpl_bypass_input%atm_input(9,g,1,tindex(9,2))*atm2lnd_vars%scale_factors(9)+ &
+            swvdf = max(((atm2lnd_vars%atm_input(9,g,1,tindex(9,2))*atm2lnd_vars%scale_factors(9)+ &
                                      atm2lnd_vars%add_offsets(9))*wt2(9)), 0.0_r8)
-            swvdr = max(((cpl_bypass_input%atm_input(10,g,1,tindex(10,2))*atm2lnd_vars%scale_factors(10)+ &
+            swvdr = max(((atm2lnd_vars%atm_input(10,g,1,tindex(10,2))*atm2lnd_vars%scale_factors(10)+ &
                                      atm2lnd_vars%add_offsets(10))*wt2(10)), 0.0_r8)
             atm2lnd_vars%forc_solad_grc(g,2) = swndr
             atm2lnd_vars%forc_solad_grc(g,1) = swvdr
             atm2lnd_vars%forc_solai_grc(g,2) = swndf
             atm2lnd_vars%forc_solai_grc(g,1) = swvdf
         else
-            swndr = max(((cpl_bypass_input%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
+            swndr = max(((atm2lnd_vars%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
                                      atm2lnd_vars%add_offsets(4))*wt2(4)) * 0.50_R8, 0.0_r8)
-            swndf = max(((cpl_bypass_input%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
+            swndf = max(((atm2lnd_vars%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
                                     atm2lnd_vars%add_offsets(4))*wt2(4))*0.50_R8, 0.0_r8)
-            swvdr = max(((cpl_bypass_input%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
+            swvdr = max(((atm2lnd_vars%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
                                     atm2lnd_vars%add_offsets(4))*wt2(4))*0.50_R8, 0.0_r8)
-            swvdf = max(((cpl_bypass_input%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
+            swvdf = max(((atm2lnd_vars%atm_input(4,g,1,tindex(4,2))*atm2lnd_vars%scale_factors(4)+ &
                                     atm2lnd_vars%add_offsets(4))*wt2(4))*0.50_R8, 0.0_r8)
             ratio_rvrf =   min(0.99_R8,max(0.29548_R8 + 0.00504_R8*swndr &
-                           -1.4957e-05_R8*swndr**2._r8 + 1.4881e-08_R8*swndr**3._r8,0.01_R8))
+                           -1.4957e-05_R8*swndr**2.0_r8 + 1.4881e-08_R8*swndr**3._r8,0.01_R8))
             atm2lnd_vars%forc_solad_grc(g,2) = ratio_rvrf*swndr
             atm2lnd_vars%forc_solai_grc(g,2) = (1._R8 - ratio_rvrf)*swndf
             ratio_rvrf =   min(0.99_R8,max(0.17639_R8 + 0.00380_R8*swvdr  &
@@ -863,46 +854,46 @@ contains
         end if
         !Rain and snow
         if (atm2lnd_vars%metsource == 5) then
-          forc_rainc = max((((cpl_bypass_input%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_rainc = max((((atm2lnd_vars%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                                         atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,g,mon) + &
                                         atm2lnd_vars%var_offset(5,g,mon)), 0.0_r8)
-          forc_rainl = max((((cpl_bypass_input%atm_input(11,g,1,tindex(11,2))*atm2lnd_vars%scale_factors(11)+ &
+          forc_rainl = max((((atm2lnd_vars%atm_input(11,g,1,tindex(11,2))*atm2lnd_vars%scale_factors(11)+ &
                                         atm2lnd_vars%add_offsets(11)))*atm2lnd_vars%var_mult(11,g,mon) + &
                                         atm2lnd_vars%var_offset(11,g,mon)), 0.0_r8)
-          forc_snowc = max((((cpl_bypass_input%atm_input(12,g,1,tindex(12,2))*atm2lnd_vars%scale_factors(12)+ &
+          forc_snowc = max((((atm2lnd_vars%atm_input(12,g,1,tindex(12,2))*atm2lnd_vars%scale_factors(12)+ &
                                         atm2lnd_vars%add_offsets(12)))*atm2lnd_vars%var_mult(12,g,mon) + &
                                         atm2lnd_vars%var_offset(12,g,mon)), 0.0_r8)
-          forc_snowl = max((((cpl_bypass_input%atm_input(13,g,1,tindex(13,2))*atm2lnd_vars%scale_factors(13)+ &
+          forc_snowl = max((((atm2lnd_vars%atm_input(13,g,1,tindex(13,2))*atm2lnd_vars%scale_factors(13)+ &
                                         atm2lnd_vars%add_offsets(13)))*atm2lnd_vars%var_mult(13,g,mon) + &
                                           atm2lnd_vars%var_offset(13,g,mon)), 0.0_r8)
         else
           frac = (atm2lnd_vars%forc_t_not_downscaled_grc(g) - SHR_CONST_TKFRZ)*0.5_R8       ! ramp near freezing
           frac = min(1.0_R8,max(0.0_R8,frac))           ! bound in [0,1]
           !Don't interpolate rainfall data
-          forc_rainc = 0.1_R8 * frac * max((((cpl_bypass_input%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_rainc = 0.1_R8 * frac * max((((atm2lnd_vars%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                                         atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,g,mon) + &
                                         atm2lnd_vars%var_offset(5,g,mon)), 0.0_r8)
-          forc_rainl = 0.9_R8 * frac * max((((cpl_bypass_input%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_rainl = 0.9_R8 * frac * max((((atm2lnd_vars%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                                          atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,g,mon) + &
                                          atm2lnd_vars%var_offset(5,g,mon)), 0.0_r8)
-          forc_snowc = 0.1_R8 * (1.0_R8 - frac) * max((((cpl_bypass_input%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_snowc = 0.1_R8 * (1.0_R8 - frac) * max((((atm2lnd_vars%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                   atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,g,mon) + atm2lnd_vars%var_offset(5,g,mon)), 0.0_r8)
-          forc_snowl = 0.9_R8 * (1.0_R8 - frac) * max((((cpl_bypass_input%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
+          forc_snowl = 0.9_R8 * (1.0_R8 - frac) * max((((atm2lnd_vars%atm_input(5,g,1,tindex(5,2))*atm2lnd_vars%scale_factors(5)+ &
                   atm2lnd_vars%add_offsets(5))) * atm2lnd_vars%var_mult(5,g,mon) + atm2lnd_vars%var_offset(5,g,mon)), 0.0_r8)
         end if
         !Wind
-        atm2lnd_vars%forc_u_grc(g) = (cpl_bypass_input%atm_input(6,g,1,tindex(6,1))*atm2lnd_vars%scale_factors(6)+ &
-                                     atm2lnd_vars%add_offsets(6))*wt1(6) + (cpl_bypass_input%atm_input(6,g,1,tindex(6,2))* &
+        atm2lnd_vars%forc_u_grc(g) = (atm2lnd_vars%atm_input(6,g,1,tindex(6,1))*atm2lnd_vars%scale_factors(6)+ &
+                                     atm2lnd_vars%add_offsets(6))*wt1(6) + (atm2lnd_vars%atm_input(6,g,1,tindex(6,2))* &
                                      atm2lnd_vars%scale_factors(6)+atm2lnd_vars%add_offsets(6))*wt2(6)
         if (atm2lnd_vars%metsource == 5) then
-          atm2lnd_vars%forc_v_grc(g) = (cpl_bypass_input%atm_input(14,g,1,tindex(14,1))*atm2lnd_vars%scale_factors(14)+ &
-                                     atm2lnd_vars%add_offsets(14))*wt1(14) + (cpl_bypass_input%atm_input(14,g,1,tindex(14,2))* &
+          atm2lnd_vars%forc_v_grc(g) = (atm2lnd_vars%atm_input(14,g,1,tindex(14,1))*atm2lnd_vars%scale_factors(14)+ &
+                                     atm2lnd_vars%add_offsets(14))*wt1(14) + (atm2lnd_vars%atm_input(14,g,1,tindex(14,2))* &
                                      atm2lnd_vars%scale_factors(14)+atm2lnd_vars%add_offsets(14))*wt2(14)
         else
             atm2lnd_vars%forc_v_grc(g) = 0.0_R8
         end if
-        atm2lnd_vars%forc_hgt_grc(g) = 30.0_R8 !(cpl_bypass_input%atm_input(8,g,1,tindex(1))*wt1 + &
-                                             !cpl_bypass_input%atm_input(8,g,1,tindex(2))*wt2)    ! zgcmxy  Atm state, default=30m
+        atm2lnd_vars%forc_hgt_grc(g) = 30.0_R8 !(atm2lnd_vars%atm_input(8,g,1,tindex(1))*wt1 + &
+                                             !atm2lnd_vars%atm_input(8,g,1,tindex(2))*wt2)    ! zgcmxy  Atm state, default=30m
 
   !------------------------------------Fire data -------------------------------------------------------
 
diff --git a/components/elm/src/data_types/CNStateType.F90 b/components/elm/src/data_types/CNStateType.F90
index 914373eafe..9424f4aa4f 100644
--- a/components/elm/src/data_types/CNStateType.F90
+++ b/components/elm/src/data_types/CNStateType.F90
@@ -7,20 +7,21 @@ module CNStateType
   use abortutils     , only : endrun
   use spmdMod        , only : masterproc
   use elm_varpar     , only : nlevsno, nlevgrnd, nlevlak, nlevsoifl, nlevsoi, crop_prog
-  use elm_varpar     , only : ndecomp_cascade_transitions, nlevdecomp, nlevdecomp_full, more_vertlayers
+  use elm_varpar     , only : ndecomp_cascade_transitions, nlevdecomp, nlevdecomp_full, more_vertlayers  
   use elm_varcon     , only : spval, ispval, c14ratio, grlnd
   use landunit_varcon, only : istsoil, istcrop
-  use elm_varpar     , only : nlevsno, nlevgrnd, nlevlak, crop_prog
-  use elm_varctl     , only : use_vertsoilc, use_c14, use_cn
+  use elm_varpar     , only : nlevsno, nlevgrnd, nlevlak, crop_prog 
+  use elm_varctl     , only : use_vertsoilc, use_c14, use_cn 
   use elm_varctl     , only : iulog, fsurdat
-  use LandunitType   , only : lun_pp
-  use ColumnType     , only : col_pp
-  use VegetationType      , only : veg_pp
+  use LandunitType   , only : lun_pp                
+  use ColumnType     , only : col_pp                
+  use VegetationType      , only : veg_pp                
   use elm_varctl     , only: forest_fert_exp
   use elm_varctl          , only : nu_com
   use elm_varctl   , only:  use_fates,use_crop
   use topounit_varcon,  only : max_topounits
   use GridcellType    , only : grc_pp
+  ! 
   ! !PUBLIC TYPES:
   implicit none
   save
@@ -32,13 +33,12 @@ module CNStateType
   real(r8)   , pointer, public :: fert_dose         (:,:)
   integer    , pointer, public :: fert_start        (:)
   integer    , pointer, public :: fert_end          (:)
-  !$acc declare create(fert_type(:),fert_dose(:,:),fert_continue(:), fert_start(:), fert_end(:) )
-  !
+  ! 
   ! !PUBLIC TYPES:
   type, public :: cnstate_type
 
      integer  , pointer :: burndate_patch              (:)     ! patch crop burn date
-     real(r8) , pointer :: lfpftd_patch                (:)     ! patch decrease of pft weight (0-1) on the column for the timestep
+     real(r8) , pointer :: lfpftd_patch                (:)     ! patch decrease of pft weight (0-1) on the column for the timestep 
 
      ! Prognostic crop model -  Note that cropplant and harvdate could be 2D to facilitate rotation
      real(r8) , pointer :: hdidx_patch                 (:)     ! patch cold hardening index?
@@ -61,30 +61,30 @@ module CNStateType
 
      real(r8) , pointer :: gdp_lf_col                  (:)     ! col global real gdp data (k US$/capita)
      real(r8) , pointer :: peatf_lf_col                (:)     ! col global peatland fraction data (0-1)
-     integer  , pointer :: abm_lf_col                  (:)     ! col global peak month of crop fire emissions
+     integer  , pointer :: abm_lf_col                  (:)     ! col global peak month of crop fire emissions 
 
      real(r8) , pointer :: lgdp_col                    (:)     ! col gdp limitation factor for fire occurrence (0-1)
      real(r8) , pointer :: lgdp1_col                   (:)     ! col gdp limitation factor for fire spreading (0-1)
      real(r8) , pointer :: lpop_col                    (:)     ! col pop limitation factor for fire spreading (0-1)
 
-     real(r8) , pointer :: fpi_vr_col                  (:,:)   ! col fraction of potential immobilization (no units)
-     real(r8) , pointer :: fpi_col                     (:)     ! col fraction of potential immobilization (no units)
+     real(r8) , pointer :: fpi_vr_col                  (:,:)   ! col fraction of potential immobilization (no units) 
+     real(r8) , pointer :: fpi_col                     (:)     ! col fraction of potential immobilization (no units) 
      real(r8),  pointer :: fpg_col                     (:)     ! col fraction of potential gpp (no units)
 
      !!! add phosphorus  -X. YANG
 
      integer  ,pointer  :: isoilorder                  (:)     ! col global soil order data
-     real(r8) , pointer :: fpi_p_vr_col                (:,:)   ! col fraction of potential immobilization (no units)
-     real(r8) , pointer :: fpi_p_col                   (:)     ! col fraction of potential immobilization (no units)
+     real(r8) , pointer :: fpi_p_vr_col                (:,:)   ! col fraction of potential immobilization (no units) 
+     real(r8) , pointer :: fpi_p_col                   (:)     ! col fraction of potential immobilization (no units) 
      real(r8),  pointer :: fpg_p_col                   (:)     ! col fraction of potential gpp (no units)
 
      real(r8) , pointer :: rf_decomp_cascade_col       (:,:,:) ! col respired fraction in decomposition step (frac)
-     real(r8) , pointer :: pathfrac_decomp_cascade_col (:,:,:) ! col what fraction of C leaving a given pool passes through a given transition (frac)
-     real(r8) , pointer :: nfixation_prof_col          (:,:)   ! col (1/m) profile for N fixation additions
+     real(r8) , pointer :: pathfrac_decomp_cascade_col (:,:,:) ! col what fraction of C leaving a given pool passes through a given transition (frac) 
+     real(r8) , pointer :: nfixation_prof_col          (:,:)   ! col (1/m) profile for N fixation additions 
      real(r8) , pointer :: ndep_prof_col               (:,:)   ! col (1/m) profile for N fixation additions
-     real(r8) , pointer :: pdep_prof_col               (:,:)   ! col (1/m) profile for P deposition additions
-     real(r8) , pointer :: som_adv_coef_col            (:,:)   ! col SOM advective flux (m/s)
-     real(r8) , pointer :: som_diffus_coef_col         (:,:)   ! col SOM diffusivity due to bio/cryo-turbation (m2/s)
+     real(r8) , pointer :: pdep_prof_col               (:,:)   ! col (1/m) profile for P deposition additions 
+     real(r8) , pointer :: som_adv_coef_col            (:,:)   ! col SOM advective flux (m/s) 
+     real(r8) , pointer :: som_diffus_coef_col         (:,:)   ! col SOM diffusivity due to bio/cryo-turbation (m2/s) 
 
      real(r8) , pointer :: tempavg_t2m_patch           (:)     ! patch temporary average 2m air temperature (K)
      real(r8) , pointer :: annavg_t2m_patch            (:)     ! patch annual average 2m air temperature (K)
@@ -108,7 +108,7 @@ module CNStateType
      real(r8) , pointer :: fbac1_col                   (:)     ! col burned area out of conversion region due to land use fire (/sec)
      real(r8) , pointer :: wtlf_col                    (:)     ! col fractional coverage of non-crop Patches (0-1)
      real(r8) , pointer :: lfwt_col                    (:)     ! col fractional coverage of non-crop and non-bare-soil Patches (0-1)
-     real(r8) , pointer :: farea_burned_col            (:)     ! col fractional area burned (/sec)
+     real(r8) , pointer :: farea_burned_col            (:)     ! col fractional area burned (/sec) 
 
      real(r8), pointer :: dormant_flag_patch           (:)     ! patch dormancy flag
      real(r8), pointer :: days_active_patch            (:)     ! patch number of days since last dormancy
@@ -150,12 +150,12 @@ module CNStateType
      real(r8), pointer :: fpg_nh4_vr_col               (:,:)   ! fraction of plant nh4 demand that is satisfied (no units) BGC mode
      real(r8), pointer :: fpg_no3_vr_col               (:,:)   ! fraction of plant no3 demand that is satisfied (no units) BGC mode
      real(r8), pointer :: fpg_vr_col                   (:,:)   ! fraction of plant N demand that is satisfied (no units) CN mode
-     real(r8), pointer :: fpg_p_vr_col                 (:,:)   ! fraction of plant p demand that is satisfied (no units)
-     real(r8), pointer :: cn_scalar                    (:)     ! cn scaling factor for root n uptake kinetics (no units)
+     real(r8), pointer :: fpg_p_vr_col                 (:,:)   ! fraction of plant p demand that is satisfied (no units) 
+     real(r8), pointer :: cn_scalar                    (:)     ! cn scaling factor for root n uptake kinetics (no units) 
      real(r8), pointer :: cp_scalar                    (:)     ! cp scaling factor for root p uptake kinetics (no units)
      real(r8), pointer :: np_scalar                    (:)     ! np scaling factor for root n/p uptake kinetics (no units)
      real(r8), pointer :: cost_ben_scalar              (:)     ! cost benefit analysis scaling factor for root n uptake kinetics (no units)
-     real(r8), pointer :: cn_scalar_runmean            (:)     ! long term average of cn scaling factor for root n uptake kinetics (no units)
+     real(r8), pointer :: cn_scalar_runmean            (:)     ! long term average of cn scaling factor for root n uptake kinetics (no units) 
      real(r8), pointer :: cp_scalar_runmean            (:)     ! long term average of cp scaling factor for root p uptake kinetics (no units)
      real(r8), pointer :: water_scalar                 (:)     ! water scaling factor for plant dynamic allocation
      real(r8), pointer :: water_scalar_runmean         (:)     ! long term average of water scaling factor for plant allocation
@@ -170,15 +170,15 @@ module CNStateType
      real(r8), pointer :: prip_col             (:)   ! parent material phosphorus g/m2
      logical           :: pdatasets_present          ! surface dataset has p pools info
      !!! annual mortality rate dynamically calcaulted at patch
-     real(r8), pointer :: r_mort_cal_patch                 (:)     ! patch annual mortality rate
+     real(r8), pointer :: r_mort_cal_patch                 (:)     ! patch annual mortality rate  
 
    contains
 
-     procedure, public  :: Init
-     procedure, public  :: Restart
+     procedure, public  :: Init         
+     procedure, public  :: Restart      
      procedure, private :: InitAllocate
-     procedure, private :: InitHistory
-     procedure, private :: InitCold
+     procedure, private :: InitHistory  
+     procedure, private :: InitCold     
      procedure, public  :: InitAccBuffer
      procedure, public  :: InitAccVars
      procedure, public  :: UpdateAccVars
@@ -192,13 +192,13 @@ contains
   subroutine Init(this, bounds)
 
     class(cnstate_type) :: this
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds  
 
     call this%InitAllocate ( bounds )
     if (use_cn) then
        call this%InitHistory ( bounds )
     end if
-    call this%InitCold ( bounds )
+    call this%InitCold ( bounds ) 
 
   end subroutine Init
 
@@ -213,7 +213,7 @@ contains
     !
     ! !ARGUMENTS:
     class(cnstate_type) :: this
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds  
     !
     ! !LOCAL VARIABLES:
     integer :: begp, endp
@@ -245,27 +245,27 @@ contains
     allocate(this%stem_prof_patch     (begp:endp,1:nlevdecomp_full)) ; this%stem_prof_patch     (:,:) = spval
 
     allocate(this%gdp_lf_col          (begc:endc))                   ;
-    allocate(this%peatf_lf_col        (begc:endc))                   ;
-    allocate(this%abm_lf_col          (begc:endc))                   ;
+    allocate(this%peatf_lf_col        (begc:endc))                   ; 
+    allocate(this%abm_lf_col          (begc:endc))                   ; 
 
-    allocate(this%lgdp_col            (begc:endc))                   ;
-    allocate(this%lgdp1_col           (begc:endc))                   ;
-    allocate(this%lpop_col            (begc:endc))                   ;
+    allocate(this%lgdp_col            (begc:endc))                   ; 
+    allocate(this%lgdp1_col           (begc:endc))                   ; 
+    allocate(this%lpop_col            (begc:endc))                   ;  
 
     allocate(this%fpi_vr_col          (begc:endc,1:nlevdecomp_full)) ; this%fpi_vr_col          (:,:) = nan
     allocate(this%fpi_col             (begc:endc))                   ; this%fpi_col             (:)   = nan
     allocate(this%fpg_col             (begc:endc))                   ; this%fpg_col             (:)   = nan
     !!! add phosphours related variables
-    allocate(this%isoilorder            (begc:endc))                   ;
+    allocate(this%isoilorder            (begc:endc))                   ; 
     allocate(this%fpi_p_vr_col          (begc:endc,1:nlevdecomp_full)) ; this%fpi_p_vr_col          (:,:) = nan
     allocate(this%fpi_p_col             (begc:endc))                   ; this%fpi_p_col             (:)   = nan
     allocate(this%fpg_p_col             (begc:endc))                   ; this%fpg_p_col             (:)   = nan
     allocate(this%pdep_prof_col         (begc:endc,1:nlevdecomp_full)) ; this%pdep_prof_col       (:,:) = spval
 
-    allocate(this%rf_decomp_cascade_col(begc:endc,1:nlevdecomp_full,1:ndecomp_cascade_transitions));
+    allocate(this%rf_decomp_cascade_col(begc:endc,1:nlevdecomp_full,1:ndecomp_cascade_transitions)); 
     this%rf_decomp_cascade_col(:,:,:) = nan
 
-    allocate(this%pathfrac_decomp_cascade_col(begc:endc,1:nlevdecomp_full,1:ndecomp_cascade_transitions));
+    allocate(this%pathfrac_decomp_cascade_col(begc:endc,1:nlevdecomp_full,1:ndecomp_cascade_transitions));     
     this%pathfrac_decomp_cascade_col(:,:,:) = nan
 
     allocate(this%nfixation_prof_col  (begc:endc,1:nlevdecomp_full)) ; this%nfixation_prof_col  (:,:) = spval
@@ -324,7 +324,7 @@ contains
     allocate(this%tempmax_retransn_patch      (begp:endp)) ;    this%tempmax_retransn_patch      (:) = nan
     allocate(this%annmax_retransn_patch       (begp:endp)) ;    this%annmax_retransn_patch       (:) = nan
     allocate(this%downreg_patch               (begp:endp)) ;    this%downreg_patch               (:) = nan
-    allocate(this%rc14_atm_patch              (begp:endp)) ;    this%rc14_atm_patch              (:) = nan
+    allocate(this%rc14_atm_patch              (begp:endp)) ;    this%rc14_atm_patch              (:) = nan    
 
 
     !! add phosphorus -X.YANG
@@ -332,7 +332,7 @@ contains
     allocate(this%tempmax_retransp_patch      (begp:endp)) ;    this%tempmax_retransp_patch      (:) = nan
     allocate(this%annmax_retransp_patch       (begp:endp)) ;    this%annmax_retransp_patch       (:) = nan
 
-    allocate(this%fpg_nh4_vr_col              (begc:endc,1:nlevdecomp_full)) ; this%fpg_nh4_vr_col(:,:) = nan
+    allocate(this%fpg_nh4_vr_col              (begc:endc,1:nlevdecomp_full)) ; this%fpg_nh4_vr_col(:,:) = nan 
     allocate(this%fpg_no3_vr_col              (begc:endc,1:nlevdecomp_full)) ; this%fpg_no3_vr_col(:,:) = nan
     allocate(this%fpg_vr_col                  (begc:endc,1:nlevdecomp_full)) ; this%fpg_vr_col    (:,:) = nan
     allocate(this%fpg_p_vr_col                (begc:endc,1:nlevdecomp_full)) ; this%fpg_p_vr_col  (:,:) = nan
@@ -355,7 +355,7 @@ contains
     allocate(this%secp_col                    (begc:endc))                   ; this%secp_col(:) = nan
     allocate(this%occp_col                    (begc:endc))                   ; this%occp_col(:) = nan
     allocate(this%prip_col                    (begc:endc))                   ; this%prip_col(:) = nan
-
+    
     allocate(fert_start                       (begc:endc))                   ; fert_start    (:) = 0
     allocate(fert_end                         (begc:endc))                   ; fert_end      (:) = 0
     allocate(this%r_mort_cal_patch                (begp:endp))               ; this%r_mort_cal_patch   (:) = nan
@@ -374,7 +374,7 @@ contains
     !
     ! !ARGUMENTS:
     class(cnstate_type) :: this
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds  
     !
     ! !LOCAL VARIABLES:
     integer           :: begp, endp
@@ -457,15 +457,15 @@ contains
 
     if (nlevdecomp > 1) then
        vr_suffix = "_vr"
-    else
+    else 
        vr_suffix = ""
     endif
     this%fpi_vr_col(begc:endc,:) = spval
-    call hist_addfld_decomp (fname='FPI'//trim(vr_suffix), units='proportion', type2d='levdcmp', &
+    call hist_addfld_decomp (fname='FPI'//trim(vr_suffix), units='proportion', type2d='levdcmp', & 
          avgflag='A', long_name='fraction of potential immobilization of nitrogen', &
          ptr_col=this%fpi_vr_col)
     this%fpi_p_vr_col(begc:endc,:) = spval
-    call hist_addfld_decomp (fname='FPI_P'//trim(vr_suffix), units='proportion', type2d='levdcmp', &
+    call hist_addfld_decomp (fname='FPI_P'//trim(vr_suffix), units='proportion', type2d='levdcmp', & 
          avgflag='A', long_name='fraction of potential immobilization of phosphorus', &
          ptr_col=this%fpi_p_vr_col)
 
@@ -513,7 +513,7 @@ contains
     call hist_addfld1d (fname='BAF_PEATF',  units='proportion/sec', &
          avgflag='A', long_name='fractional area burned in peatland', &
          ptr_col=this%baf_peatf_col)
-
+ 
     this%annavg_t2m_patch(begp:endp) = spval
     call hist_addfld1d (fname='ANNAVG_T2M', units='K', &
          avgflag='A', long_name='annual average 2m air temperature', &
@@ -665,7 +665,7 @@ contains
     call hist_addfld1d (fname='cn_scalar', units='', &
        avgflag='A', long_name='N limitation factor', &
        ptr_patch=this%cn_scalar, default='active')
-
+         
     this%cp_scalar(begp:endp) = spval
     call hist_addfld1d (fname='cp_scalar', units='', &
        avgflag='A', long_name='P limitation factor', &
@@ -710,7 +710,7 @@ contains
     !
     ! !ARGUMENTS:
     class(cnstate_type) :: this
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds   
     !
     ! !LOCAL VARIABLES:
     integer               :: g,l,c,p,n,j,m, t, ti, topi            ! indices
@@ -722,7 +722,7 @@ contains
     integer               :: dimid                    ! dimension id
     integer               :: ier                      ! error status
     type(file_desc_t)     :: ncid                     ! netcdf id
-    logical               :: readvar
+    logical               :: readvar 
     character(len=256)    :: locfn                    ! local filename
     integer               :: begc, endc
     integer               :: begg, endg
@@ -765,13 +765,13 @@ contains
 
 
     ! --------------------------------------------------------------------
-    ! Read in GDP data
+    ! Read in GDP data 
     ! --------------------------------------------------------------------
 
     allocate(gdp(bounds%begg:bounds%endg,1:max_topounits))
     call ncd_io(ncid=ncid, varname='gdp', flag='read', data=gdp, dim1name=grlnd, readvar=readvar)
     if (.not. readvar) then
-       call endrun(msg=' ERROR: gdp NOT on surfdata file'//errMsg(__FILE__, __LINE__))
+       call endrun(msg=' ERROR: gdp NOT on surfdata file'//errMsg(__FILE__, __LINE__)) 
     end if
     do c = bounds%begc, bounds%endc
        g = col_pp%gridcell(c)
@@ -784,13 +784,13 @@ contains
     deallocate(gdp)
 
     ! --------------------------------------------------------------------
-    ! Read in peatf data
+    ! Read in peatf data 
     ! --------------------------------------------------------------------
 
     allocate(peatf(bounds%begg:bounds%endg,1:max_topounits))
     call ncd_io(ncid=ncid, varname='peatf', flag='read', data=peatf, dim1name=grlnd, readvar=readvar)
     if (.not. readvar) then
-       call endrun(msg=' ERROR: peatf NOT on surfdata file'//errMsg(__FILE__, __LINE__))
+       call endrun(msg=' ERROR: peatf NOT on surfdata file'//errMsg(__FILE__, __LINE__)) 
     end if
     do c = bounds%begc, bounds%endc
        g = col_pp%gridcell(c)
@@ -803,7 +803,7 @@ contains
     deallocate(peatf)
 
     ! --------------------------------------------------------------------
-    ! Read in soilorder data
+    ! Read in soilorder data 
     ! --------------------------------------------------------------------
 
     ! Changes: RGK-2020
@@ -900,13 +900,13 @@ contains
     ! --------------------------------------------------------------------
 
     ! --------------------------------------------------------------------
-    ! Read in ABM data
+    ! Read in ABM data 
     ! --------------------------------------------------------------------
 
     allocate(abm(bounds%begg:bounds%endg,1:max_topounits))
     call ncd_io(ncid=ncid, varname='abm', flag='read', data=abm, dim1name=grlnd, readvar=readvar)
     if (.not. readvar) then
-       call endrun(msg=' ERROR: abm NOT on surfdata file'//errMsg(__FILE__, __LINE__))
+       call endrun(msg=' ERROR: abm NOT on surfdata file'//errMsg(__FILE__, __LINE__)) 
     end if
     do c = bounds%begc, bounds%endc
        g = col_pp%gridcell(c)
@@ -926,7 +926,7 @@ contains
        write(iulog,*) 'Successfully read fmax, soil color, sand and clay boundary data'
        write(iulog,*)
     endif
-
+    
     if (masterproc) then
        write(iulog,*) 'Attempting to read initial phosphorus pools data .....'
     end if
@@ -934,7 +934,7 @@ contains
     call getfil (fsurdat, locfn, 0)
     call ncd_pio_openfile (ncid, locfn, 0)
 
-    ! Read soil phosphorus pool Qing Z. 2017
+    ! Read soil phosphorus pool Qing Z. 2017 
     this%pdatasets_present = .true.
     allocate(labp_g(bounds%begg:bounds%endg,1:max_topounits))
     call ncd_io(ncid=ncid, varname='LABILE_P', flag='read', data=labp_g, dim1name=grlnd, readvar=readvar)
@@ -994,13 +994,13 @@ contains
           this%prip_col(c) = prip_g(g,ti)
        end do
     end if
-    deallocate(prip_g)
+    deallocate(prip_g)  
 
     ! --------------------------------------------------------------------
     ! Initialize terms needed for dust model
-    ! TODO - move these terms to DUSTMod module variables
+    ! TODO - move these terms to DUSTMod module variables 
     ! --------------------------------------------------------------------
-
+       
     do c = bounds%begc, bounds%endc
        l = col_pp%landunit(c)
        if (lun_pp%ifspecial(l)) then
@@ -1024,29 +1024,29 @@ contains
        end if
 
        if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-          this%annsum_counter_col(c) = 0._r8
-          this%annavg_t2m_col(c)     = 280._r8
+          this%annsum_counter_col(c) = 0._r8   
+          this%annavg_t2m_col(c)     = 280._r8 
 
-          ! fire related variables
-          this%baf_crop_col(c)       = 0._r8
-          this%baf_peatf_col(c)      = 0._r8
-          this%fbac_col(c)           = 0._r8
-          this%fbac1_col(c)          = 0._r8
-          this%farea_burned_col(c)   = 0._r8
+          ! fire related variables 
+          this%baf_crop_col(c)       = 0._r8 
+          this%baf_peatf_col(c)      = 0._r8 
+          this%fbac_col(c)           = 0._r8 
+          this%fbac1_col(c)          = 0._r8 
+          this%farea_burned_col(c)   = 0._r8 
 
           if (nsrest == nsrStartup) this%nfire_col(c) = 0._r8
 
           ! initialize fpi_vr so that levels below nlevsoi are not nans
-          this%fpi_vr_col(c,1:nlevdecomp_full)          = 0._r8
-          this%fpi_p_vr_col(c,1:nlevdecomp_full)          = 0._r8
-          this%som_adv_coef_col(c,1:nlevdecomp_full)    = 0._r8
-          this%som_diffus_coef_col(c,1:nlevdecomp_full) = 0._r8
+          this%fpi_vr_col(c,1:nlevdecomp_full)          = 0._r8 
+          this%fpi_p_vr_col(c,1:nlevdecomp_full)          = 0._r8 
+          this%som_adv_coef_col(c,1:nlevdecomp_full)    = 0._r8 
+          this%som_diffus_coef_col(c,1:nlevdecomp_full) = 0._r8 
           !this%scalaravg_col(c,1:nlevdecomp_full)       = 0._r8
 
           ! initialize the profiles for converting to vertically resolved carbon pools
-          this%nfixation_prof_col(c,1:nlevdecomp_full)  = 0._r8
-          this%ndep_prof_col(c,1:nlevdecomp_full)       = 0._r8
-          this%pdep_prof_col(c,1:nlevdecomp_full)       = 0._r8
+          this%nfixation_prof_col(c,1:nlevdecomp_full)  = 0._r8 
+          this%ndep_prof_col(c,1:nlevdecomp_full)       = 0._r8 
+          this%pdep_prof_col(c,1:nlevdecomp_full)       = 0._r8 
        end if
     end do
 
@@ -1055,7 +1055,7 @@ contains
 
     do p = bounds%begp,bounds%endp
        l = veg_pp%landunit(p)
-       this%rc14_atm_patch(p)              = c14ratio
+       this%rc14_atm_patch(p)              = c14ratio 
 
        if (lun_pp%ifspecial(l)) then
           this%annavg_t2m_patch  (p)          = spval
@@ -1093,10 +1093,10 @@ contains
 
           this%r_mort_cal_patch(p)           = spval
 
-
+ 
        end if
     end do
-
+       
     ! ecophysiological variables
 
     do p = bounds%begp,bounds%endp
@@ -1168,9 +1168,9 @@ contains
     !
     ! !ARGUMENTS:
     class(cnstate_type)              :: this
-    type(bounds_type), intent(in)    :: bounds
-    type(file_desc_t), intent(inout) :: ncid
-    character(len=*) , intent(in)    :: flag
+    type(bounds_type), intent(in)    :: bounds 
+    type(file_desc_t), intent(inout) :: ncid   
+    character(len=*) , intent(in)    :: flag   
     !
     ! !LOCAL VARIABLES:
     integer, pointer :: temp1d(:) ! temporary
@@ -1179,71 +1179,71 @@ contains
     real(r8), pointer :: ptr2d(:,:) ! temp. pointers for slicing larger arrays
     real(r8), pointer :: ptr1d(:)   ! temp. pointers for slicing larger arrays
     !-----------------------------------------------------------------------
-
+  
     call restartvar(ncid=ncid, flag=flag, varname='dormant_flag', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='dormancy flag', units='1', &
-         interpinic_flag='interp', readvar=readvar, data=this%dormant_flag_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%dormant_flag_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='days_active', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='number of days since last dormancy', units='days' , &
-         interpinic_flag='interp', readvar=readvar, data=this%days_active_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%days_active_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='onset_flag', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='flag if critical growing degree-day sum is exceeded', units='1' , &
-         interpinic_flag='interp', readvar=readvar, data=this%onset_flag_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%onset_flag_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='onset_counter', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='onset days counter', units='sec' , &
-         interpinic_flag='interp', readvar=readvar, data=this%onset_counter_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%onset_counter_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='onset_gddflag', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='onset flag for growing degree day sum', units='' , &
-         interpinic_flag='interp', readvar=readvar, data=this%onset_gddflag_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%onset_gddflag_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='onset_fdd', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='onset freezing degree days counter', units='days' , &
-         interpinic_flag='interp', readvar=readvar, data=this%onset_fdd_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%onset_fdd_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='onset_gdd', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='onset growing degree days', units='days' , &
-         interpinic_flag='interp', readvar=readvar, data=this%onset_gdd_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%onset_gdd_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='onset_swi', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='onset soil water index', units='days' , &
-         interpinic_flag='interp', readvar=readvar, data=this%onset_swi_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%onset_swi_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='offset_flag', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='offset flag', units='1' , &
-         interpinic_flag='interp', readvar=readvar, data=this%offset_flag_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%offset_flag_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='offset_counter', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='offset days counter', units='sec' , &
-         interpinic_flag='interp', readvar=readvar, data=this%offset_counter_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%offset_counter_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='offset_fdd', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='offset freezing degree days counter', units='days' , &
-         interpinic_flag='interp', readvar=readvar, data=this%offset_fdd_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%offset_fdd_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='offset_swi', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%offset_swi_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%offset_swi_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='lgsf', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%lgsf_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%lgsf_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='bglfr', xtype=ncd_double,  &
          dim1name='pft', &
@@ -1253,7 +1253,7 @@ contains
     call restartvar(ncid=ncid, flag=flag, varname='bglfr_leaf', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%bglfr_leaf_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%bglfr_leaf_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='bglfr_froot', xtype=ncd_double,  &
          dim1name='pft', &
@@ -1263,73 +1263,73 @@ contains
     call restartvar(ncid=ncid, flag=flag, varname='bgtr', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%bgtr_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%bgtr_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='annavg_t2m', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%annavg_t2m_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%annavg_t2m_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='tempavg_t2m', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%tempavg_t2m_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%tempavg_t2m_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='alloc_pnow', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%alloc_pnow_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%alloc_pnow_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='c_allometry', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%c_allometry_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%c_allometry_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='n_allometry', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%n_allometry_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%n_allometry_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='tempsum_potential_gpp', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%tempsum_potential_gpp_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%tempsum_potential_gpp_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='annsum_potential_gpp', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%annsum_potential_gpp_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%annsum_potential_gpp_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='tempmax_retransn', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%tempmax_retransn_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%tempmax_retransn_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='annmax_retransn', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%annmax_retransn_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%annmax_retransn_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='downreg', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%downreg_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%downreg_patch) 
 
 
     call restartvar(ncid=ncid, flag=flag, varname='p_allometry', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%p_allometry_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%p_allometry_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='tempmax_retransp', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%tempmax_retransp_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%tempmax_retransp_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='annmax_retransp', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%annmax_retransp_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%annmax_retransp_patch) 
 
     if (use_vertsoilc) then
        ptr2d => this%fpi_vr_col
@@ -1362,7 +1362,7 @@ contains
             long_name='SOM advective flux', units='m/s', fill_value=spval, &
             interpinic_flag='interp', readvar=readvar, data=ptr2d)
     end if
-
+    
     if (use_vertsoilc) then
        ptr2d => this%som_diffus_coef_col
        call restartvar(ncid=ncid, flag=flag, varname='som_diffus_coef_vr', xtype=ncd_double,  &
@@ -1374,32 +1374,32 @@ contains
     call restartvar(ncid=ncid, flag=flag, varname='fpg', xtype=ncd_double,  &
          dim1name='column', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%fpg_col)
+         interpinic_flag='interp', readvar=readvar, data=this%fpg_col) 
 
     call restartvar(ncid=ncid, flag=flag, varname='fpg_p', xtype=ncd_double,  &
          dim1name='column', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%fpg_p_col)
+         interpinic_flag='interp', readvar=readvar, data=this%fpg_p_col) 
 
     call restartvar(ncid=ncid, flag=flag, varname='annsum_counter', xtype=ncd_double,  &
          dim1name='column', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%annsum_counter_col)
+         interpinic_flag='interp', readvar=readvar, data=this%annsum_counter_col) 
 
     call restartvar(ncid=ncid, flag=flag, varname='burndate', xtype=ncd_int,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%burndate_patch)
+         interpinic_flag='interp', readvar=readvar, data=this%burndate_patch) 
 
     call restartvar(ncid=ncid, flag=flag, varname='lfc', xtype=ncd_double,  &
          dim1name='column', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%lfc_col)
+         interpinic_flag='interp', readvar=readvar, data=this%lfc_col) 
 
     call restartvar(ncid=ncid, flag=flag, varname='cannavg_t2m', xtype=ncd_double,  &
          dim1name='column', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%annavg_t2m_col)
+         interpinic_flag='interp', readvar=readvar, data=this%annavg_t2m_col) 
 
     ptr2d => this%scalaravg_col
     call restartvar(ncid=ncid, flag=flag, varname='scalaravg_col', xtype=ncd_double,  &
@@ -1421,7 +1421,7 @@ contains
             interpinic_flag='interp', readvar=readvar, data=this%peaklai_patch)
 
        call restartvar(ncid=ncid, flag=flag,  varname='idop', xtype=ncd_int,  &
-            dim1name='pft', long_name='Date of planting', units='jday', nvalid_range=(/1,366/), &
+            dim1name='pft', long_name='Date of planting', units='jday', nvalid_range=(/1,366/), & 
             interpinic_flag='interp', readvar=readvar, data=this%idop_patch)
 
        call restartvar(ncid=ncid, flag=flag,  varname='aleaf', xtype=ncd_double,  &
@@ -1468,7 +1468,7 @@ contains
     if (use_c14) then
        call restartvar(ncid=ncid, flag=flag, varname='rc14_atm', xtype=ncd_double,  &
             dim1name='pft',    long_name='', units='', &
-            interpinic_flag='interp', readvar=readvar, data=this%rc14_atm_patch)
+            interpinic_flag='interp', readvar=readvar, data=this%rc14_atm_patch) 
        if (flag=='read' .and. .not. readvar) then
           write(iulog,*) 'initializing this%rc14_atm with atmospheric c14 value'
           do i = bounds%begp, bounds%endp
@@ -1569,7 +1569,7 @@ contains
     call extract_accum_field ('wlim_m', rbufslp, nstep)
     this%water_scalar_runmean(begp:endp) = rbufslp(begp:endp)
     deallocate(rbufslp)
-
+  
   end subroutine InitAccVars
 
   !-----------------------------------------------------------------------
diff --git a/components/elm/src/data_types/ColumnDataType.F90 b/components/elm/src/data_types/ColumnDataType.F90
index b106e363da..9a5e66df57 100644
--- a/components/elm/src/data_types/ColumnDataType.F90
+++ b/components/elm/src/data_types/ColumnDataType.F90
@@ -6,11 +6,13 @@ module ColumnDataType
   ! --------------------------------------------------------
   !
   use shr_kind_mod    , only : r8 => shr_kind_r8
+  use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
   use shr_const_mod   , only : SHR_CONST_TKFRZ
   use shr_const_mod   , only : SHR_CONST_PDB
+  use shr_log_mod     , only : errMsg => shr_log_errMsg
+  use shr_sys_mod     , only : shr_sys_flush
   use abortutils      , only : endrun
-  use shr_log_mod     , only : errMsg => shr_log_errMsg 
-  !use MathfuncMod     , only : dot_sum
+  use MathfuncMod     , only : dot_sum
   use elm_varpar      , only : nlevsoi, nlevsno, nlevgrnd, nlevlak, nlevurb
   use elm_varpar      , only : ndecomp_cascade_transitions, ndecomp_pools, nlevcan
   use elm_varpar      , only : nlevdecomp_full, crop_prog, nlevdecomp
@@ -49,13 +51,6 @@ module ColumnDataType
   implicit none
   save
   public
-  public :: col_cf_summary_for_ch4
-  public :: col_cs_summary, col_cf_summary
-  public :: col_ps_summary, col_pf_summary
-  public :: col_ns_summary, col_nf_summary
-  public :: col_cf_setvalues, col_pf_setvalues, col_nf_setvalues
-  public :: col_ps_setvalues, col_pf_setvalues
-
   !
   ! NOTE(bandre, 2013-10) according to Charlie Koven, nfix_timeconst
   ! is currently used as a flag and rate constant. Rate constant: time
@@ -224,7 +219,7 @@ module ColumnDataType
   contains
     procedure, public :: Init    => col_cs_init
     procedure, public :: Restart => col_cs_restart
-    !procedure, public :: Summary => col_cs_summary
+    procedure, public :: Summary => col_cs_summary
     procedure, public :: Clean   => col_cs_clean
     procedure, public :: ZeroForFates => col_cs_zero_forfates_veg
   end type column_carbon_state
@@ -292,8 +287,8 @@ module ColumnDataType
   contains
     procedure, public :: Init       => col_ns_init
     procedure, public :: Restart    => col_ns_restart
-    !procedure, public :: SetValues  => col_ns_setvalues
-    !procedure, public :: Summary    => col_ns_summary
+    procedure, public :: SetValues  => col_ns_setvalues
+    procedure, public :: Summary    => col_ns_summary
     procedure, public :: Clean      => col_ns_clean
     procedure, public :: ZeroForFates => col_ns_zero_forfates_veg
   end type column_nitrogen_state
@@ -365,8 +360,8 @@ module ColumnDataType
   contains
     procedure, public :: Init      => col_ps_init
     procedure, public :: Restart   => col_ps_restart
-    !procedure, public :: SetValues => col_ps_setvalues
-    !procedure, public :: Summary   => col_ps_summary
+    procedure, public :: SetValues => col_ps_setvalues
+    procedure, public :: Summary   => col_ps_summary
     procedure, public :: Clean     => col_ps_clean
     procedure, public :: ZeroForFates => col_ps_zero_forfates_veg
   end type column_phosphorus_state
@@ -628,9 +623,9 @@ module ColumnDataType
   contains
     procedure, public :: Init       => col_cf_init
     procedure, public :: Restart    => col_cf_restart
-    !procedure, public :: Summary    => col_cf_summary
-    !procedure, public :: SummaryCH4 => col_cf_summary_for_ch4
-    !procedure, public :: SetValues  => col_cf_setvalues
+    procedure, public :: Summary    => col_cf_summary
+    procedure, public :: SummaryCH4 => col_cf_summary_for_ch4
+    procedure, public :: SetValues  => col_cf_setvalues
     procedure, public :: ZeroDWT    => col_cf_zerodwt
     procedure, public :: Clean      => col_cf_clean
     procedure, public :: ZeroForFates => col_cf_zero_forfates_veg
@@ -824,10 +819,10 @@ module ColumnDataType
   contains
     procedure, public :: Init       => col_nf_init
      procedure, public :: Restart    => col_nf_restart
-    !procedure, public :: SetValues  => col_nf_setvalues
+    procedure, public :: SetValues  => col_nf_setvalues
     procedure, public :: ZeroForFates => col_nf_zero_forfates_veg
     procedure, public :: ZeroDWT    => col_nf_zerodwt
-    !procedure, public :: Summary    => col_nf_summary
+    procedure, public :: Summary    => col_nf_summary
     procedure, public :: SummaryInt => col_nf_summaryint
     procedure, public :: Clean      => col_nf_clean
   end type column_nitrogen_flux
@@ -960,10 +955,10 @@ module ColumnDataType
   contains
     procedure, public :: Init       => col_pf_init
     procedure, public :: Restart    => col_pf_restart
-    !procedure, public :: SetValues  => col_pf_setvalues
+    procedure, public :: SetValues  => col_pf_setvalues
     procedure, public :: ZeroForFates => col_pf_zero_forfates_veg
     procedure, public :: ZeroDWT    => col_pf_zerodwt
-    !procedure, public :: Summary    => col_pf_summary
+    procedure, public :: Summary    => col_pf_summary
     procedure, public :: SummaryInt => col_pf_summaryint
     procedure, public :: Clean      => col_pf_clean
   end type column_phosphorus_flux
@@ -1013,7 +1008,6 @@ contains
   subroutine col_es_init(this, begc, endc)
     !
     ! !USES:
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     use landunit_varcon, only : istice, istwet, istsoil, istdlak, istice_mec
     use elm_varctl     , only : iulog, use_cn, use_vancouver, use_mexicocity
     use column_varcon  , only : icol_road_perv, icol_road_imperv, icol_roof, icol_sunwall, icol_shadewall
@@ -1232,7 +1226,6 @@ contains
     ! Read/Write column energy state information to/from restart file.
     !
     ! !USES:
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     !
     ! !ARGUMENTS:
     class(column_energy_state) :: this
@@ -1294,7 +1287,6 @@ contains
   subroutine col_ws_init(this, begc, endc, h2osno_input, snow_depth_input, watsat_input)
     !
     use elm_varctl  , only : use_lake_wat_storage
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class(column_water_state) :: this
     integer , intent(in)      :: begc,endc
@@ -1590,7 +1582,7 @@ contains
        this%h2osoi_ice(c,-nlevsno+1:) = spval
 
        if (.not. lun_pp%lakpoi(l)) then  !not lake
-          nlevbed = col_pp%nlevbed(c)
+	       nlevbed = col_pp%nlevbed(c)
           ! volumetric water
           if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
              nlevs = nlevgrnd
@@ -1598,7 +1590,7 @@ contains
                 if (j > nlevbed) then
                    this%h2osoi_vol(c,j) = 0.0_r8
                 else
-                     if (use_fates_planthydro .or. use_hydrstress) then
+		               if (use_fates_planthydro .or. use_hydrstress) then
                       this%h2osoi_vol(c,j) = 0.70_r8*watsat_input(c,j) !0.15_r8 to avoid very dry conditions that cause errors in FATES HYDRO
                    else
                       this%h2osoi_vol(c,j) = 0.15_r8
@@ -1709,7 +1701,6 @@ contains
     use elm_varctl, only : use_lake_wat_storage
     !
     ! !ARGUMENTS:
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     class(column_water_state) :: this
     type(bounds_type), intent(in)    :: bounds
     type(file_desc_t), intent(inout) :: ncid
@@ -1919,7 +1910,6 @@ contains
   subroutine col_cs_init(this, begc, endc, carbon_type, ratio, c12_carbonstate_vars)
     !
     ! !ARGUMENTS:
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     class(column_carbon_state)    :: this
     integer          , intent(in) :: begc,endc
     character(len=3) , intent(in) :: carbon_type ! one of ['c12', c13','c14']
@@ -2414,7 +2404,6 @@ contains
     ! Read/Write column carbon state information to/from restart file.
     !
     ! !ARGUMENTS:
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     class(column_carbon_state)       :: this
     type(bounds_type), intent(in)    :: bounds
     type(file_desc_t), intent(inout) :: ncid
@@ -2847,16 +2836,16 @@ contains
         end if ! read
      end if ! c12 or c14 (PET: why not c13?)
 
-end subroutine col_cs_restart
+  end subroutine col_cs_restart
 
   !-----------------------------------------------------------------------
   subroutine col_cs_summary(this, bounds, num_soilc, filter_soilc)
     !
     ! !DESCRIPTION:
     ! Column-level carbon state summary calculations
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type(column_carbon_state) :: this
+    class(column_carbon_state) :: this
     type(bounds_type)      , intent(in)    :: bounds
     integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
@@ -3101,7 +3090,6 @@ end subroutine col_cs_restart
   !------------------------------------------------------------------------
   subroutine col_ns_init(this, begc, endc, col_cs)
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class(column_nitrogen_state)          :: this
     integer, intent(in)                   :: begc,endc
@@ -3420,7 +3408,7 @@ end subroutine col_cs_restart
        this%cropseedn_deficit(c) = 0._r8
     end do
 
-    call col_ns_SetValues (this,num_column=num_special_col, filter_column=special_col, value_column=0._r8)
+    call this%SetValues (num_column=num_special_col, filter_column=special_col, value_column=0._r8)
 
   end subroutine col_ns_init
 
@@ -3430,7 +3418,6 @@ end subroutine col_cs_restart
     ! !DESCRIPTION:
     ! Read/write CN restart data for nitrogen state
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class (column_nitrogen_state)              :: this
     type(bounds_type)          , intent(in)    :: bounds
@@ -3690,11 +3677,11 @@ end subroutine col_cs_restart
           do c = bounds%begc, bounds%endc
              do j = 1, nlevdecomp
                 if ( exit_spinup ) then
-                   m = decomp_cascade_con%spinup_factor(k)
+		             m = decomp_cascade_con%spinup_factor(k)
                    if (decomp_cascade_con%spinup_factor(k) > 1) m = m / cnstate_vars%scalaravg_col(c,j)
                 else if ( enter_spinup ) then
                    m = 1. / decomp_cascade_con%spinup_factor(k)
-                   if (decomp_cascade_con%spinup_factor(k) > 1) m = m * cnstate_vars%scalaravg_col(c,j)
+		             if (decomp_cascade_con%spinup_factor(k) > 1) m = m * cnstate_vars%scalaravg_col(c,j)
                 end if
                 this%decomp_npools_vr(c,j,k) = this%decomp_npools_vr(c,j,k) * m
              end do
@@ -3709,9 +3696,9 @@ end subroutine col_cs_restart
     !
     ! !DESCRIPTION:
     ! Set column-level nitrogen state variables
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type (column_nitrogen_state) :: this
+    class (column_nitrogen_state) :: this
     integer , intent(in) :: num_column
     integer , intent(in) :: filter_column(:)
     real(r8), intent(in) :: value_column
@@ -3776,9 +3763,9 @@ end subroutine col_cs_restart
 
   !-----------------------------------------------------------------------
   subroutine col_ns_summary(this, bounds, num_soilc, filter_soilc)
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type (column_nitrogen_state)  :: this
+    class (column_nitrogen_state)  :: this
     type(bounds_type) , intent(in) :: bounds
     integer           , intent(in) :: num_soilc       ! number of soil columns in filter
     integer           , intent(in) :: filter_soilc(:) ! filter for soil columns
@@ -4071,7 +4058,6 @@ end subroutine col_cs_restart
   !------------------------------------------------------------------------
   subroutine col_ps_init(this, begc, endc, col_cs)
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class(column_phosphorus_state)        :: this
     integer, intent(in)                   :: begc,endc
@@ -4405,7 +4391,7 @@ end subroutine col_cs_restart
        this%totprodp(c) = 0._r8
     end do
 
-    call col_ps_SetValues (this,num_column=num_special_col, filter_column=special_col, value_column=0._r8)
+    call this%SetValues (num_column=num_special_col, filter_column=special_col, value_column=0._r8)
 
   end subroutine col_ps_init
 
@@ -4415,7 +4401,6 @@ end subroutine col_cs_restart
     ! !DESCRIPTION:
     ! Read/write vegetation-level phosphorus state restart data
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class (column_phosphorus_state)            :: this
     type(bounds_type)          , intent(in)    :: bounds
@@ -4622,12 +4607,12 @@ end subroutine col_cs_restart
        do k = 1, ndecomp_pools
           do c = bounds%begc, bounds%endc
              do j = 1, nlevdecomp
-                if ( exit_spinup ) then
-                   m = decomp_cascade_con%spinup_factor(k)
+	             if ( exit_spinup ) then
+		             m = decomp_cascade_con%spinup_factor(k)
                    if (decomp_cascade_con%spinup_factor(k) > 1) m = m  / cnstate_vars%scalaravg_col(c,j)
                 else if ( enter_spinup ) then
                    m = 1. / decomp_cascade_con%spinup_factor(k)
-                   if (decomp_cascade_con%spinup_factor(k) > 1) m = m  * cnstate_vars%scalaravg_col(c,j)
+		             if (decomp_cascade_con%spinup_factor(k) > 1) m = m  * cnstate_vars%scalaravg_col(c,j)
                 end if
                 this%decomp_ppools_vr(c,j,k) = this%decomp_ppools_vr(c,j,k) * m
              end do
@@ -4746,7 +4731,7 @@ end subroutine col_cs_restart
     ! Set phosphorus state variables, column-level
     !$acc routine seq
     ! !ARGUMENTS:
-    type (column_phosphorus_state) :: this
+    class (column_phosphorus_state) :: this
     integer , intent(in)            :: num_column
     integer , intent(in)            :: filter_column(:)
     real(r8), intent(in)            :: value_column
@@ -4810,9 +4795,9 @@ end subroutine col_cs_restart
 
   !-----------------------------------------------------------------------
   subroutine col_ps_summary(this, bounds, num_soilc, filter_soilc)
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type(column_phosphorus_state) :: this
+    class (column_phosphorus_state) :: this
     type(bounds_type) , intent(in)  :: bounds
     integer           , intent(in)  :: num_soilc       ! number of soil columns in filter
     integer           , intent(in)  :: filter_soilc(:) ! filter for soil columns
@@ -5097,7 +5082,6 @@ end subroutine col_cs_restart
   !------------------------------------------------------------------------
   subroutine col_ef_init(this, begc, endc)
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class(column_energy_flux) :: this
     integer, intent(in) :: begc,endc
@@ -5211,7 +5195,6 @@ end subroutine col_cs_restart
     !
     ! !USES:
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class(column_energy_flux) :: this
     type(bounds_type), intent(in)    :: bounds
@@ -5246,7 +5229,6 @@ end subroutine col_cs_restart
   !------------------------------------------------------------------------
   subroutine col_wf_init(this, begc, endc)
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class(column_water_flux) :: this
     integer, intent(in) :: begc,endc
@@ -5493,7 +5475,6 @@ end subroutine col_cs_restart
     ! Read/Write column water state information to/from restart file.
     !
     ! !USES:
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     !
     ! !ARGUMENTS:
     class(column_water_flux) :: this
@@ -5568,7 +5549,6 @@ end subroutine col_cs_restart
   !------------------------------------------------------------------------
   subroutine col_cf_init(this, begc, endc, carbon_type)
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class(column_carbon_flux) :: this
     integer, intent(in) :: begc,endc
@@ -6654,7 +6634,7 @@ end subroutine col_cs_restart
        this%landuptake(c)  = 0._r8
     end do
 
-    call col_cf_SetValues (this,num_column=num_special_col, filter_column=special_col, value_column=0._r8)
+    call this%SetValues (num_column=num_special_col, filter_column=special_col, value_column=0._r8)
 
   end subroutine col_cf_init
 
@@ -6664,7 +6644,6 @@ end subroutine col_cs_restart
     ! !DESCRIPTION:
     ! Read/write restart data for column carbon flux
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class (column_carbon_flux)        :: this
     type(bounds_type) , intent(in)    :: bounds
@@ -6690,7 +6669,7 @@ end subroutine col_cs_restart
             interpinic_flag='interp', readvar=readvar, data=ptr2d)
     end if
 
-    !    if(use_fates) return
+!    if(use_fates) return
 
     !-------------------------------
     ! Prognostic crop variables
@@ -6741,14 +6720,13 @@ end subroutine col_cs_restart
     ! !DESCRIPTION:
     ! column-level carbon flux summary calculations
     !
-    !$acc routine seq
-    use timeinfoMod , only : dtime_mod
+    !
     ! !ARGUMENTS:
-    type(column_carbon_flux)              :: this
+    class(column_carbon_flux)              :: this
     type(bounds_type)      , intent(in)    :: bounds
     integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
-    character(len=4)       , intent(in)    :: isotope
+    character(len=*)       , intent(in)    :: isotope
     !
     ! !LOCAL VARIABLES:
     real(r8) :: nfixlags, dtime ! temp variables for making lagged npp
@@ -6766,11 +6744,11 @@ end subroutine col_cs_restart
 
     ! PET: retaining the following here during migration, but this is science code that should
     ! really be in the NDynamics module. Flag for relocation during ELM v2 code cleanup.
-    if ( isotope == 'bulk') then
+    if ( trim(isotope) == 'bulk') then
        if (nfix_timeconst > 0._r8 .and. nfix_timeconst < 500._r8 ) then
 
           ! this code is to calculate an exponentially-relaxed npp value for use in NDynamics code
-           dtime = dtime_mod
+           dtime = get_step_size()
           nfixlags = nfix_timeconst * secspday
 
           do fc = 1,num_soilc
@@ -6825,13 +6803,13 @@ end subroutine col_cs_restart
                this%somhr(c)
        end do
 
-! #ifndef _OPENACC
-!     elseif (is_active_betr_bgc) then
-!        do fc = 1, num_soilc
-!           c = filter_soilc(fc)
-!           this%hr(c) = dot_sum(this%hr_vr(c,1:nlevdecomp),dzsoi_decomp(1:nlevdecomp))
-!        enddo
-! #endif
+
+    elseif (is_active_betr_bgc) then
+
+       do fc = 1, num_soilc
+          c = filter_soilc(fc)
+          this%hr(c) = dot_sum(this%hr_vr(c,1:nlevdecomp),dzsoi_decomp(1:nlevdecomp))
+       enddo
     endif
 
     ! some zeroing
@@ -6902,11 +6880,9 @@ end subroutine col_cs_restart
     !----------------------------------------------------------------
     ! bgc interface & pflotran:
     !----------------------------------------------------------------
-#ifndef _OPENACC
     if (use_elm_interface .and. (use_pflotran .and. pf_cmode)) then
         call col_cf_summary_pf(this, bounds, num_soilc, filter_soilc)
     end if
-#endif
     !----------------------------------------------------------------
 
     do fc = 1,num_soilc
@@ -7153,9 +7129,9 @@ end subroutine col_cs_restart
     ! summarize column-level fluxes for methane calculation
     !
     ! !USES:
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type(column_carbon_flux)     :: this
+    class(column_carbon_flux)     :: this
     type(bounds_type), intent(in) :: bounds
     integer, intent(in) :: num_soilc
     integer, intent(in) :: filter_soilc(:)
@@ -7188,9 +7164,9 @@ end subroutine col_cs_restart
 
        do j = 1,nlevdecomp
           do fc = 1,num_soilc
-            c = filter_soilc(fc)
+             c = filter_soilc(fc)
 
-            this%decomp_cascade_hr(c,k) = &
+             this%decomp_cascade_hr(c,k) = &
                 this%decomp_cascade_hr(c,k) + &
                 this%decomp_cascade_hr_vr(c,j,k) * dzsoi_decomp(j)
 
@@ -7200,39 +7176,39 @@ end subroutine col_cs_restart
 
       ! litter heterotrophic respiration (LITHR)
       do k = 1, ndecomp_cascade_transitions
-       if ( is_litter(decomp_cascade_con%cascade_donor_pool(k)) .or. is_cwd((decomp_cascade_con%cascade_donor_pool(k)))) then
+        if ( is_litter(decomp_cascade_con%cascade_donor_pool(k)) .or. is_cwd((decomp_cascade_con%cascade_donor_pool(k)))) then
           do fc = 1,num_soilc
             c = filter_soilc(fc)
             this%lithr(c) = &
               this%lithr(c) + &
               this%decomp_cascade_hr(c,k)
           end do
-       end if
+        end if
       end do
 
       ! soil organic matter heterotrophic respiration (SOMHR)
       do k = 1, ndecomp_cascade_transitions
-       if ( is_soil(decomp_cascade_con%cascade_donor_pool(k)) ) then
+        if ( is_soil(decomp_cascade_con%cascade_donor_pool(k)) ) then
           do fc = 1,num_soilc
             c = filter_soilc(fc)
             this%somhr(c) = &
               this%somhr(c) + &
               this%decomp_cascade_hr(c,k)
           end do
-       end if
+        end if
       end do
 
       ! total heterotrophic respiration, vertically resolved (HR)
 
       do k = 1, ndecomp_cascade_transitions
-       do j = 1,nlevdecomp
+        do j = 1,nlevdecomp
           do fc = 1,num_soilc
             c = filter_soilc(fc)
             this%hr_vr(c,j) = &
                 this%hr_vr(c,j) + &
                 this%decomp_cascade_hr_vr(c,j,k)
           end do
-       end do
+        end do
       end do
     endif
 
@@ -7244,9 +7220,9 @@ end subroutine col_cs_restart
   subroutine col_cf_setvalues ( this, num_column, filter_column, value_column)
     ! !DESCRIPTION:
     ! Set column-level carbon fluxes
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type (column_carbon_flux) :: this
+    class (column_carbon_flux) :: this
     integer , intent(in) :: num_column
     integer , intent(in) :: filter_column(:)
     real(r8), intent(in) :: value_column
@@ -7469,6 +7445,8 @@ end subroutine col_cs_restart
        this%rr(c) = 0._r8   ! This counterpart is
                             ! actually in SummaryRR
     end do
+
+
   end subroutine col_cf_zero_forfates_veg_rr
 
 
@@ -7702,7 +7680,6 @@ end subroutine col_cs_restart
   !------------------------------------------------------------------------
   subroutine col_nf_init(this, begc, endc)
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class(column_nitrogen_flux) :: this
     integer, intent(in) :: begc,endc
@@ -7856,7 +7833,7 @@ end subroutine col_cs_restart
     allocate(this%actual_immob_no3                (begc:endc))                    ; this%actual_immob_no3              (:)   = nan
     allocate(this%actual_immob_nh4                (begc:endc))                    ; this%actual_immob_nh4              (:)   = nan
     allocate(this%smin_no3_to_plant               (begc:endc))                    ; this%smin_no3_to_plant             (:)   = nan
-    allocate(this%smin_nh4_to_plant               (begc:endc))                    ; this%smin_nh4_to_plant             (:)   = nan
+    allocate(this%smin_nh4_to_plant               (begc:endc))                    ; this%smin_nh4_to_plant             (:)   = nan 
     allocate(this%plant_to_litter_nflux           (begc:endc))                    ; this%plant_to_litter_nflux         (:)   = 0._r8
     allocate(this%plant_to_cwd_nflux              (begc:endc))                    ; this%plant_to_cwd_nflux            (:)   = nan
     ! C4MIP output variable
@@ -8590,7 +8567,7 @@ end subroutine col_cs_restart
        this%dwt_nloss(c) = 0._r8
     end do
 
-    call col_nf_SetValues (this,num_column=num_special_col, filter_column=special_col, value_column=0._r8)
+    call this%SetValues (num_column=num_special_col, filter_column=special_col, value_column=0._r8)
 
   end subroutine col_nf_init
 
@@ -8600,7 +8577,6 @@ end subroutine col_cs_restart
     ! !DESCRIPTION:
     ! Read/write restart data for column-level nitrogen fluxes
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class (column_nitrogen_flux)      :: this
     type(bounds_type) , intent(in)    :: bounds
@@ -8706,9 +8682,9 @@ end subroutine col_cs_restart
     !
     ! !DESCRIPTION:
     ! Set column-level nitrogen fluxes
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type (column_nitrogen_flux) :: this
+    class (column_nitrogen_flux) :: this
     integer , intent(in)         :: num_column
     integer , intent(in)         :: filter_column(:)
     real(r8), intent(in)         :: value_column
@@ -9012,9 +8988,9 @@ end subroutine col_cs_restart
     !
     ! !DESCRIPTION:
     ! Column-level nitrogen summary calculations
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type (column_nitrogen_flux)            :: this
+    class(column_nitrogen_flux)            :: this
     type(bounds_type)      , intent(in)    :: bounds
     integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
@@ -9259,11 +9235,9 @@ end subroutine col_cs_restart
     enddo
 
     ! bgc interface & pflotran
-    #ifndef _OPENACC
     if (use_elm_interface .and. (use_pflotran .and. pf_cmode)) then
         call this%SummaryInt(bounds, num_soilc, filter_soilc)
     end if
-    #endif
 
   end subroutine col_nf_summary
 
@@ -9484,7 +9458,6 @@ end subroutine col_cs_restart
   !------------------------------------------------------------------------
   subroutine col_pf_init(this, begc, endc)
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class(column_phosphorus_flux) :: this
     integer, intent(in) :: begc,endc
@@ -10195,7 +10168,7 @@ end subroutine col_cs_restart
        this%dwt_ploss(c) = 0._r8
     end do
 
-    call col_pf_SetValues (this,num_column=num_special_col, filter_column=special_col, value_column=0._r8)
+    call this%SetValues (num_column=num_special_col, filter_column=special_col, value_column=0._r8)
 
   end subroutine col_pf_init
 
@@ -10205,7 +10178,6 @@ end subroutine col_cs_restart
     ! !DESCRIPTION:
     ! Read/write restart data for column-level phosphorus fluxes
     !
-    use shr_infnan_mod  , only : isnan => shr_infnan_isnan,nan => shr_infnan_nan, assignment(=)
     ! !ARGUMENTS:
     class (column_phosphorus_flux)     :: this
     type(bounds_type) , intent(in)     :: bounds
@@ -10277,7 +10249,7 @@ end subroutine col_cs_restart
     ! Set phosphorus flux variables
     !$acc routine seq
     ! !ARGUMENTS:
-    type (column_phosphorus_flux) :: this
+    class (column_phosphorus_flux) :: this
     integer , intent(in) :: num_column
     integer , intent(in) :: filter_column(:)
     real(r8), intent(in) :: value_column
@@ -10549,9 +10521,9 @@ end subroutine col_cs_restart
 
   !-----------------------------------------------------------------------
   subroutine col_pf_summary(this, bounds, num_soilc, filter_soilc)
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type (column_phosphorus_flux) :: this
+    class (column_phosphorus_flux) :: this
     type(bounds_type) , intent(in) :: bounds
     integer           , intent(in) :: num_soilc       ! number of soil columns in filter
     integer           , intent(in) :: filter_soilc(:) ! filter for soil columns
@@ -10835,12 +10807,10 @@ end subroutine col_cs_restart
        end do
     end if
 
-    #ifndef _OPENACC
     ! bgc interface & pflotran:
     if (use_elm_interface) then
         call this%SummaryInt(bounds, num_soilc, filter_soilc)
     end if
-    #endif
 
   end subroutine col_pf_summary
 
diff --git a/components/elm/src/data_types/GridcellDataType.F90 b/components/elm/src/data_types/GridcellDataType.F90
index 6376034618..0019cbb32d 100644
--- a/components/elm/src/data_types/GridcellDataType.F90
+++ b/components/elm/src/data_types/GridcellDataType.F90
@@ -3,7 +3,7 @@ module GridcellDataType
   !-----------------------------------------------------------------------
   ! !DESCRIPTION:
   ! Gridcell data type allocation and initialization
-  ! --------------------------------------------------------
+  ! -------------------------------------------------------- 
   !
   use shr_kind_mod      , only : r8 => shr_kind_r8
   use shr_infnan_mod    , only : nan => shr_infnan_nan, assignment(=)
@@ -23,7 +23,7 @@ module GridcellDataType
   implicit none
   save
   private
-
+  
   !-----------------------------------------------------------------------
   ! Define the data structure that holds energy state information at the gridcell level.
   !-----------------------------------------------------------------------
@@ -38,7 +38,7 @@ module GridcellDataType
     procedure, public :: Init    => grc_es_init
     procedure, public :: Clean   => grc_es_clean
   end type gridcell_energy_state
-
+  
   !-----------------------------------------------------------------------
   ! Define the data structure that holds energy flux information at the gridcell level.
   !-----------------------------------------------------------------------
@@ -50,7 +50,7 @@ module GridcellDataType
     procedure, public :: Restart => grc_ef_restart
     procedure, public :: Clean   => grc_ef_clean
   end type gridcell_energy_flux
-
+  
   !-----------------------------------------------------------------------
   ! Define the data structure that holds water state information at the gridcell level.
   !-----------------------------------------------------------------------
@@ -82,7 +82,7 @@ module GridcellDataType
     procedure, public :: Restart => grc_ws_restart
     procedure, public :: Clean   => grc_ws_clean
   end type gridcell_water_state
-
+  
   !-----------------------------------------------------------------------
   ! Define the data structure that holds water flux information at the gridcell level.
   !-----------------------------------------------------------------------
@@ -101,7 +101,7 @@ module GridcellDataType
     procedure, public :: Restart => grc_wf_restart
     procedure, public :: Clean   => grc_wf_clean
   end type gridcell_water_flux
-
+  
   !-----------------------------------------------------------------------
   ! Define the data structure that holds carbon state information at the gridcell level.
   !-----------------------------------------------------------------------
@@ -133,7 +133,7 @@ module GridcellDataType
     procedure, public :: Restart => grc_cs_restart
     procedure, public :: Clean   => grc_cs_clean
   end type gridcell_carbon_state
-
+  
   !-----------------------------------------------------------------------
   ! Define the data structure that holds carbon flux information at the gridcell level.
   !-----------------------------------------------------------------------
@@ -163,21 +163,21 @@ module GridcellDataType
     procedure, public :: ZeroDWT => grc_cf_zerodwt
     procedure, public :: Clean   => grc_cf_clean
   end type gridcell_carbon_flux
-
+  
   !-----------------------------------------------------------------------
   ! Define the data structure that holds nitrogen state information at the gridcell level.
   !-----------------------------------------------------------------------
   type, public :: gridcell_nitrogen_state
     real(r8), pointer :: seedn          (:) => null()   ! (gNm2) nitrogen pool for seeding new PFTs via dynamic landcover
     real(r8), pointer :: begnb          (:) => null()   ! (gNm2) nitrogen mass, beginning of time step
-    real(r8), pointer :: endnb          (:) => null()   ! (gNm2) nitrogen mass, end of time step
+    real(r8), pointer :: endnb          (:) => null()   ! (gNm2) nitrogen mass, end of time step 
     real(r8), pointer :: errnb          (:) => null()   ! (gNm2) nitrogen balance error for the timestep
 
   contains
     procedure, public :: Init    => grc_ns_init
     procedure, public :: Clean   => grc_ns_clean
   end type gridcell_nitrogen_state
-
+  
   !-----------------------------------------------------------------------
   ! Define the data structure that holds nitrogen flux information at the gridcell level.
   !-----------------------------------------------------------------------
@@ -196,7 +196,7 @@ module GridcellDataType
     procedure, public :: ZeroDWT => grc_nf_zerodwt
     procedure, public :: Clean   => grc_nf_clean
   end type gridcell_nitrogen_flux
-
+ 
   !-----------------------------------------------------------------------
   ! Define the data structure that holds phosphorus state information at the gridcell level.
   !-----------------------------------------------------------------------
@@ -209,7 +209,7 @@ module GridcellDataType
     procedure, public :: Init    => grc_ps_init
     procedure, public :: Clean   => grc_ps_clean
   end type gridcell_phosphorus_state
-
+  
   !-----------------------------------------------------------------------
   ! Define the data structure that holds phosphorus flux information at the gridcell level.
   !-----------------------------------------------------------------------
@@ -227,7 +227,7 @@ module GridcellDataType
     procedure, public :: ZeroDWT => grc_pf_zerodwt
     procedure, public :: Clean   => grc_pf_clean
   end type gridcell_phosphorus_flux
-
+  
   !-----------------------------------------------------------------------
   ! declare the public instances of gridcell-level data types
   !-----------------------------------------------------------------------
@@ -246,10 +246,7 @@ module GridcellDataType
   type(gridcell_phosphorus_state)      , public, target :: grc_ps     ! gridcell phosphorus state
   type(gridcell_phosphorus_flux)       , public, target :: grc_pf     ! gridcell phosphorus flux
   !------------------------------------------------------------------------
-  !$acc declare create(grc_ns, grc_ps, grc_ws, grc_pf, grc_nf, grc_cf, grc_cs )
-  !$acc declare create(c13_grc_cs,c14_grc_cs,c13_grc_cf,c14_grc_cf)
-  !$acc declare create(grc_es, grc_ef)
-  !$acc declare create(grc_wf)
+
 contains
 
   !------------------------------------------------------------------------
@@ -281,7 +278,7 @@ contains
     this%heat2(begg:endg) = spval
     call hist_addfld1d (fname='GC_HEAT2',  units='J/m^2',  &
          avgflag='A', long_name='post land cover change total heat content', &
-         ptr_lnd=this%heat2, default='inactive')
+         ptr_lnd=this%heat2, default='inactive')  
 
     this%liquid_water_temp1(begg:endg) = spval
     call hist_addfld1d (fname='LIQUID_WATER_TEMP1', units='K', &
@@ -301,7 +298,7 @@ contains
     deallocate(this%liquid_water_temp1)
     deallocate(this%liquid_water_temp2)
   end subroutine grc_es_clean
-
+  
   !------------------------------------------------------------------------
   ! Subroutines to initialize and clean gridcell energy flux data structure
   !------------------------------------------------------------------------
@@ -320,7 +317,7 @@ contains
     !-----------------------------------------------------------------------
     ! initialize history fields for select members of grc_ef
     !-----------------------------------------------------------------------
-    this%eflx_dynbal(begg:endg) = spval
+    this%eflx_dynbal(begg:endg) = spval 
     call hist_addfld1d (fname='EFLX_DYNBAL',  units='W/m^2',  &
          avgflag='A', long_name='dynamic land cover change conversion energy flux', &
          ptr_lnd=this%eflx_dynbal)
@@ -329,7 +326,7 @@ contains
 
   !------------------------------------------------------------------------
   subroutine grc_ef_restart(this, bounds, ncid, flag)
-    !
+    ! 
     ! !DESCRIPTION:
     ! Read/Write gridcell energy flux information to/from restart file.
     !
@@ -337,9 +334,9 @@ contains
     !
     ! !ARGUMENTS:
     class(gridcell_energy_flux) :: this
-    type(bounds_type), intent(in)    :: bounds
-    type(file_desc_t), intent(inout) :: ncid
-    character(len=*) , intent(in)    :: flag
+    type(bounds_type), intent(in)    :: bounds 
+    type(file_desc_t), intent(inout) :: ncid   
+    character(len=*) , intent(in)    :: flag   
     !
     ! !LOCAL VARIABLES:
     logical :: readvar   ! determine if variable is on initial file
@@ -354,7 +351,7 @@ contains
     !------------------------------------------------------------------------
     deallocate(this%eflx_dynbal)
   end subroutine grc_ef_clean
-
+  
   !------------------------------------------------------------------------
   ! Subroutines to initialize and clean gridcell water state data structure
   !------------------------------------------------------------------------
@@ -398,18 +395,18 @@ contains
          ptr_lnd=this%liq1)
 
     this%liq2(begg:endg) = spval
-    call hist_addfld1d (fname='GC_LIQ2',  units='mm',  &
-         avgflag='A', long_name='post landuse change gridcell total liq content', &
-         ptr_lnd=this%liq2, default='inactive')
+    call hist_addfld1d (fname='GC_LIQ2',  units='mm',  &  
+         avgflag='A', long_name='post landuse change gridcell total liq content', &              
+         ptr_lnd=this%liq2, default='inactive')     
 
     this%ice1(begg:endg) = spval
-    call hist_addfld1d (fname='GC_ICE1',  units='mm',  &
-         avgflag='A', long_name='initial gridcell total ice content', &
-         ptr_lnd=this%ice1)
+    call hist_addfld1d (fname='GC_ICE1',  units='mm',  &  
+         avgflag='A', long_name='initial gridcell total ice content', &              
+         ptr_lnd=this%ice1)     
 
     this%ice2(begg:endg) = spval
-    call hist_addfld1d (fname='GC_ICE2',  units='mm',  &
-         avgflag='A', long_name='post land cover change total ice content', &
+    call hist_addfld1d (fname='GC_ICE2',  units='mm',  &  
+         avgflag='A', long_name='post land cover change total ice content', &              
          ptr_lnd=this%ice2, default='inactive')
 
     this%tws(begg:endg) = spval
@@ -430,7 +427,7 @@ contains
 
   !------------------------------------------------------------------------
   subroutine grc_ws_restart(this, bounds, ncid, flag)
-    !
+    ! 
     ! !DESCRIPTION:
     ! Read/Write gridcell water state information to/from restart file.
     !
@@ -438,9 +435,9 @@ contains
     !
     ! !ARGUMENTS:
     class(gridcell_water_state) :: this
-    type(bounds_type), intent(in)    :: bounds
-    type(file_desc_t), intent(inout) :: ncid
-    character(len=*) , intent(in)    :: flag
+    type(bounds_type), intent(in)    :: bounds 
+    type(file_desc_t), intent(inout) :: ncid   
+    character(len=*) , intent(in)    :: flag   
     !
     ! !LOCAL VARIABLES:
     logical :: readvar   ! determine if variable is on initial file
@@ -449,9 +446,9 @@ contains
          dim1name='gridcell', &
          long_name='surface watertotal water storage at the beginning of a month', units='mm', &
           interpinic_flag='interp', readvar=readvar, data=this%tws_month_beg)
-
+  
   end subroutine grc_ws_restart
-
+  
   !------------------------------------------------------------------------
   subroutine grc_ws_clean(this)
     !
@@ -496,28 +493,28 @@ contains
     ! initialize history fields for select members of grc_wf
     !-----------------------------------------------------------------------
     this%qflx_liq_dynbal(begg:endg) = spval
-    call hist_addfld1d (fname='QFLX_LIQ_DYNBAL',  units='mm/s',  &
-         avgflag='A', long_name='liq dynamic land cover change conversion runoff flux', &
-         ptr_lnd=this%qflx_liq_dynbal)
+    call hist_addfld1d (fname='QFLX_LIQ_DYNBAL',  units='mm/s',  &  
+         avgflag='A', long_name='liq dynamic land cover change conversion runoff flux', &              
+         ptr_lnd=this%qflx_liq_dynbal)     
 
     this%qflx_ice_dynbal(begg:endg) = spval
     call hist_addfld1d (fname='QFLX_ICE_DYNBAL',  units='mm/s',  &
-         avgflag='A', long_name='ice dynamic land cover change conversion runoff flux', &
+         avgflag='A', long_name='ice dynamic land cover change conversion runoff flux', &                                   
          ptr_lnd=this%qflx_ice_dynbal)
-
+  
   end subroutine grc_wf_init
 
   !------------------------------------------------------------------------
   subroutine grc_wf_restart(this, bounds, ncid, flag)
-    !
+    ! 
     ! !DESCRIPTION:
     ! Read/Write gridcell water flux information to/from restart file.
     !
     ! !ARGUMENTS:
     class(gridcell_water_flux) :: this
-    type(bounds_type), intent(in)    :: bounds
-    type(file_desc_t), intent(inout) :: ncid
-    character(len=*) , intent(in)    :: flag
+    type(bounds_type), intent(in)    :: bounds 
+    type(file_desc_t), intent(inout) :: ncid   
+    character(len=*) , intent(in)    :: flag   
     !
     ! !LOCAL VARIABLES:
     logical :: readvar   ! determine if variable is on initial file
@@ -547,7 +544,7 @@ contains
     ! !ARGUMENTS:
     class(gridcell_carbon_state) :: this
     integer, intent(in) :: begg,endg
-    character(len=3) , intent(in) :: carbon_type ! one of ['c12', c13','c14']
+    character(len=3) , intent(in) :: carbon_type ! one of ['c12', c13','c14']    
 
     !
     ! !LOCAL VARIABLES:
@@ -592,19 +589,19 @@ contains
           call hist_addfld1d (fname='SEEDC_GRC', units='gC/m^2', &
                avgflag='A', long_name='pool for seeding new PFTs via dynamic landcover', &
                ptr_gcell=this%seedc)
-       end if
+       end if 
        if (carbon_type == 'c13') then
           this%seedc(begg:endg) = spval
           call hist_addfld1d (fname='C13_SEEDC_GRC', units='gC/m^2', &
                avgflag='A', long_name='pool for seeding new PFTs via dynamic landcover', &
                ptr_gcell=this%seedc)
-       end if
+       end if 
        if (carbon_type == 'c14') then
           this%seedc(begg:endg) = spval
           call hist_addfld1d (fname='C14_SEEDC_GRC', units='gC/m^2', &
                avgflag='A', long_name='pool for seeding new PFTs via dynamic landcover', &
                ptr_gcell=this%seedc)
-       end if
+       end if 
     end if
     
     this%tcs_month_beg(begg:endg) = spval
@@ -627,7 +624,7 @@ contains
     do g = begg, endg
        this%seedc(g) = 0._r8
     end do
-
+    
   end subroutine grc_cs_init
 
   !------------------------------------------------------------------------
@@ -857,7 +854,7 @@ contains
             avgflag='A', long_name='C14 dead stem harvest to 100-yr wood product pool', &
             ptr_col=this%hrv_deadstemc_to_prod100c, default='inactive')
     endif
-
+    
     !-----------------------------------------------------------------------
     ! set cold-start initial values for select members of grc_cf
     !-----------------------------------------------------------------------
@@ -869,9 +866,9 @@ contains
        this%cinputs(g)                   = 0._r8
        this%coutputs(g)                  = 0._r8
     end do
-
+    
   end subroutine grc_cf_init
-
+  
   !-----------------------------------------------------------------------
   subroutine grc_cf_zerodwt( this, bounds )
     !
@@ -880,7 +877,7 @@ contains
     !
     ! !ARGUMENTS:
     class(gridcell_carbon_flux)      :: this
-    type(bounds_type), intent(in)  :: bounds
+    type(bounds_type), intent(in)  :: bounds 
     !
     ! !LOCAL VARIABLES:
     integer  :: g          ! indices
@@ -948,7 +945,7 @@ contains
 
 
   end subroutine grc_ns_init
-
+  
   !------------------------------------------------------------------------
   subroutine grc_ns_clean(this)
     !
@@ -957,7 +954,7 @@ contains
     !------------------------------------------------------------------------
 
   end subroutine grc_ns_clean
-
+  
   !------------------------------------------------------------------------
   ! Subroutines to initialize and clean gridcell nitrogen flux data structure
   !------------------------------------------------------------------------
@@ -970,7 +967,7 @@ contains
     ! !LOCAL VARIABLES:
     integer :: g
     !------------------------------------------------------------------------
-
+    
     !-----------------------------------------------------------------------
     ! allocate for each member of grc_nf
     !-----------------------------------------------------------------------
@@ -982,7 +979,7 @@ contains
     allocate(this%dwt_prod100n_gain     (begg:endg)) ; this%dwt_prod100n_gain     (:) = nan
     allocate(this%ninputs               (begg:endg)) ; this%ninputs               (:) = nan
     allocate(this%noutputs              (begg:endg)) ; this%noutputs              (:) = nan
-
+    
     !-----------------------------------------------------------------------
     ! initialize history fields for select members of grc_nf
     !-----------------------------------------------------------------------
@@ -1026,9 +1023,9 @@ contains
        this%ninputs(g)                   = 0._r8
        this%noutputs(g)                  = 0._r8
     end do
-
+    
   end subroutine grc_nf_init
-
+  
   !-----------------------------------------------------------------------
   subroutine grc_nf_zerodwt( this, bounds )
     !
@@ -1037,12 +1034,12 @@ contains
     !
     ! !ARGUMENTS:
     class(gridcell_nitrogen_flux)  :: this
-    type(bounds_type), intent(in)  :: bounds
+    type(bounds_type), intent(in)  :: bounds 
     !
     ! !LOCAL VARIABLES:
     integer  :: g          ! indices
     !-----------------------------------------------------------------------
-
+  
     do g = bounds%begg, bounds%endg
        this%dwt_seedn_to_leaf(g)     = 0._r8
        this%dwt_seedn_to_deadstem(g) = 0._r8
@@ -1053,16 +1050,16 @@ contains
     end do
 
   end subroutine grc_nf_zerodwt
-
+  
   !------------------------------------------------------------------------
   subroutine grc_nf_clean(this)
     !
     ! !ARGUMENTS:
     class(gridcell_nitrogen_flux) :: this
     !------------------------------------------------------------------------
-
+  
   end subroutine grc_nf_clean
-
+  
   subroutine grc_ps_init (this, begg, endg)
     !
     ! !ARGUMENTS:
@@ -1072,7 +1069,7 @@ contains
     ! !LOCAL VARIABLES:
     integer :: g
     !------------------------------------------------------------------------
-
+    
     !-----------------------------------------------------------------------
     ! allocate for each member of grc_ps
     !-----------------------------------------------------------------------
@@ -1080,7 +1077,7 @@ contains
     allocate(this%begpb   (begg:endg)) ; this%begpb   (:) = nan
     allocate(this%endpb   (begg:endg)) ; this%endpb   (:) = nan
     allocate(this%errpb   (begg:endg)) ; this%errpb   (:) = nan
-
+    
     !-----------------------------------------------------------------------
     ! initialize history fields for select members of grc_ps
     !-----------------------------------------------------------------------
@@ -1096,7 +1093,7 @@ contains
        this%seedp(g) = 0._r8
     end do
 
-
+  
   end subroutine grc_ps_init
 
   !------------------------------------------------------------------------
@@ -1105,7 +1102,7 @@ contains
     ! !ARGUMENTS:
     class(gridcell_phosphorus_state) :: this
     !------------------------------------------------------------------------
-
+  
   end subroutine grc_ps_clean
 
   subroutine grc_pf_init (this, begg, endg)
@@ -1117,7 +1114,7 @@ contains
     ! !LOCAL VARIABLES:
     integer :: g
     !------------------------------------------------------------------------
-
+    
     !-----------------------------------------------------------------------
     ! allocate for each member of grc_pf
     !-----------------------------------------------------------------------
@@ -1129,7 +1126,7 @@ contains
     allocate(this%dwt_prod100p_gain      (begg:endg))   ; this%dwt_prod100p_gain      (:) = nan
     allocate(this%pinputs                (begg:endg))   ; this%pinputs                (:) = nan
     allocate(this%poutputs               (begg:endg))   ; this%poutputs               (:) = nan
-
+    
     !-----------------------------------------------------------------------
     ! initialize history fields for select members of grc_pf
     !-----------------------------------------------------------------------
@@ -1173,7 +1170,7 @@ contains
        this%pinputs(g)                   = 0._r8
        this%poutputs(g)                  = 0._r8
     end do
-
+  
   end subroutine grc_pf_init
 
   !-----------------------------------------------------------------------
@@ -1184,7 +1181,7 @@ contains
     !
     ! !ARGUMENTS:
     class(gridcell_phosphorus_flux) :: this
-    type(bounds_type), intent(in)  :: bounds
+    type(bounds_type), intent(in)  :: bounds 
     !
     ! !LOCAL VARIABLES:
     integer  :: g          ! indices
@@ -1197,16 +1194,19 @@ contains
        this%dwt_prod10p_gain(g)      = 0._r8
        this%dwt_prod100p_gain(g)     = 0._r8
     end do
-
+  
   end subroutine grc_pf_zerodwt
-
+  
   !------------------------------------------------------------------------
   subroutine grc_pf_clean(this)
     !
     ! !ARGUMENTS:
     class(gridcell_phosphorus_flux) :: this
     !------------------------------------------------------------------------
-
+  
   end subroutine grc_pf_clean
-
+  
 end module GridcellDataType
+
+  
+    
diff --git a/components/elm/src/data_types/GridcellType.F90 b/components/elm/src/data_types/GridcellType.F90
index ac251cf7e4..13a80e15ba 100644
--- a/components/elm/src/data_types/GridcellType.F90
+++ b/components/elm/src/data_types/GridcellType.F90
@@ -41,12 +41,9 @@ module GridcellType
      integer , pointer :: nlandunits   (:) => null() ! number of landunits for each gridcell
      integer , pointer :: coli         (:) => null() ! beginning column index for each gridcell
      integer , pointer :: colf         (:) => null() ! ending column index for each gridcell
-     integer , pointer :: cols (:,:) => null() 
      integer , pointer :: ncolumns     (:) => null() ! number of columns for each gridcell
-     
      integer , pointer :: pfti         (:) => null() ! beginning pft index for each gridcell
      integer , pointer :: pftf         (:) => null() ! ending pft index for each gridcell
-     integer , pointer :: pfts         (:,:) => null() 
      integer , pointer :: npfts        (:) => null() ! number of patches for each gridcell
 
      ! Physical properties
diff --git a/components/elm/src/data_types/VegetationDataType.F90 b/components/elm/src/data_types/VegetationDataType.F90
index 4bbb09fa24..c45c0e50b9 100644
--- a/components/elm/src/data_types/VegetationDataType.F90
+++ b/components/elm/src/data_types/VegetationDataType.F90
@@ -41,14 +41,6 @@ module VegetationDataType
   implicit none
   save
   public
-
-  public :: veg_cf_summary_for_ch4
-  public :: veg_cf_summary, veg_cs_summary
-  public :: veg_pf_summary, veg_ps_summary
-  public :: veg_nf_summary, veg_ns_summary
-  public :: veg_cf_setvalues, veg_pf_setvalues, veg_nf_setvalues
-  public :: veg_cf_summary_rr
-
   !-----------------------------------------------------------------------
   ! Define the data structure that holds energy state information at the vegetation level.
   !-----------------------------------------------------------------------
@@ -162,7 +154,7 @@ module VegetationDataType
   contains
     procedure, public :: Init     => veg_cs_init
     procedure, public :: Restart  => veg_cs_restart
-    !procedure, public :: Summary  => veg_cs_summary
+    procedure, public :: Summary  => veg_cs_summary
     procedure, public :: ZeroDwt  => veg_cs_zerodwt
     procedure, public :: Clean    => veg_cs_clean
   end type vegetation_carbon_state
@@ -247,7 +239,7 @@ module VegetationDataType
   contains
     procedure, public :: Init      => veg_ns_init
     procedure, public :: Restart   => veg_ns_restart
-    !procedure, public :: Summary   => veg_ns_summary
+    procedure, public :: Summary   => veg_ns_summary
     procedure, public :: SetValues => veg_ns_setvalues
     procedure, public :: ZeroDwt   => veg_ns_zerodwt
     procedure, public :: Clean     => veg_ns_clean
@@ -295,7 +287,7 @@ module VegetationDataType
     procedure, public :: Restart   => veg_ps_restart
     procedure, public :: SetValues => veg_ps_setvalues
     procedure, public :: ZeroDWT   => veg_ps_zerodwt
-    !procedure, public :: Summary   => veg_ps_summary
+    procedure, public :: Summary   => veg_ps_summary
     procedure, public :: Clean     => veg_ps_clean
   end type vegetation_phosphorus_state
 
@@ -663,10 +655,10 @@ module VegetationDataType
   contains
     procedure, public :: Init       => veg_cf_init
     procedure, public :: Restart    => veg_cf_restart
-    !procedure, public :: Summary    => veg_cf_summary
-    !procedure, public :: SummaryRR  => veg_cf_summary_rr      ! Root respiration summary
-    !procedure, public :: SummaryCH4 => veg_cf_summary_for_ch4 ! Summary for CH4 model
-    !procedure, public :: SetValues  => veg_cf_setvalues
+    procedure, public :: Summary    => veg_cf_summary
+    procedure, public :: SummaryRR  => veg_cf_summary_rr      ! Root respiration summary
+    procedure, public :: SummaryCH4 => veg_cf_summary_for_ch4 ! Summary for CH4 model
+    procedure, public :: SetValues  => veg_cf_setvalues
     procedure, public :: Clean      => veg_cf_clean
   end type vegetation_carbon_flux
 
@@ -848,8 +840,8 @@ module VegetationDataType
   contains
     procedure, public :: Init      => veg_nf_init
     procedure, public :: Restart   => veg_nf_restart
-    !procedure, public :: SetValues => veg_nf_setvalues
-    !procedure, public :: Summary   => veg_nf_summary
+    procedure, public :: SetValues => veg_nf_setvalues
+    procedure, public :: Summary   => veg_nf_summary
     procedure, public :: Clean     => veg_nf_clean
   end type vegetation_nitrogen_flux
 
@@ -1013,8 +1005,8 @@ module VegetationDataType
   contains
     procedure, public :: Init      => veg_pf_init
     procedure, public :: Restart   => veg_pf_restart
-    !procedure, public :: SetValues => veg_pf_setvalues
-    !procedure, public :: Summary   => veg_pf_summary
+    procedure, public :: SetValues => veg_pf_setvalues
+    procedure, public :: Summary   => veg_pf_summary
     procedure, public :: Clean     => veg_pf_clean
   end type vegetation_phosphorus_flux
 
@@ -3515,9 +3507,9 @@ module VegetationDataType
     !
     ! !DESCRIPTION:
     ! Vegetation-level carbon state summary calculations
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
-    type(vegetation_carbon_state)                :: this
+    class(vegetation_carbon_state)                :: this
     type(bounds_type)         , intent(in)    :: bounds
     integer                   , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                   , intent(in)    :: filter_soilc(:) ! filter for soil columns
@@ -4192,9 +4184,8 @@ module VegetationDataType
     ! !DESCRIPTION:
     ! Vegetation-level nitrogen state summary calculations
     !
-    !$acc routine seq
     ! !ARGUMENTS:
-    type(vegetation_nitrogen_state)            :: this
+    class(vegetation_nitrogen_state)            :: this
     type(bounds_type)           , intent(in)    :: bounds
     integer                     , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                     , intent(in)    :: filter_soilc(:) ! filter for soil columns
@@ -4862,7 +4853,7 @@ module VegetationDataType
     !
     ! !DESCRIPTION:
     ! Set phosphorus state variables, column-level
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
     class (vegetation_phosphorus_state) :: this
     integer , intent(in)                :: num_patch
@@ -4941,9 +4932,8 @@ module VegetationDataType
   !-----------------------------------------------------------------------
   subroutine veg_ps_summary (this, bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_ps)
     !
-    !$acc routine seq
     ! !ARGUMENTS:
-    type (vegetation_phosphorus_state) :: this
+    class (vegetation_phosphorus_state) :: this
     type(bounds_type) , intent(in)      :: bounds
     integer           , intent(in)      :: num_soilc       ! number of soil columns in filter
     integer           , intent(in)      :: filter_soilc(:) ! filter for soil columns
@@ -7947,7 +7937,7 @@ module VegetationDataType
        end if
     end do
 
-    call veg_cf_SetValues (this, num_patch=num_special_patch, filter_patch=special_patch, value_patch=0._r8)
+    call this%SetValues (num_patch=num_special_patch, filter_patch=special_patch, value_patch=0._r8)
 
   end subroutine veg_cf_init
 
@@ -8098,15 +8088,14 @@ module VegetationDataType
     !
     ! !USES:
     !
-    !$acc routine seq
     ! !ARGUMENTS:
-    type(vegetation_carbon_flux)                 :: this
+    class(vegetation_carbon_flux)                 :: this
     type(bounds_type)      , intent(in)    :: bounds
     integer                , intent(in)    :: num_soilp       ! number of soil patches in filter
     integer                , intent(in)    :: filter_soilp(:) ! filter for soil patches
     integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
-    character(len=4)       , intent(in)    :: isotope
+    character(len=*)       , intent(in)    :: isotope
     type(column_carbon_flux), intent(inout):: col_cf_input    ! receives p2c output
     !
     ! !LOCAL VARIABLES:
@@ -8239,7 +8228,7 @@ module VegetationDataType
             this%ar(p)
 
        ! update the annual NPP accumulator, for use in allocation code
-       if (isotope == 'bulk') then
+       if (trim(isotope) == 'bulk') then
           this%tempsum_npp(p) = &
                this%tempsum_npp(p) + &
                this%npp(p)
@@ -8471,16 +8460,16 @@ module VegetationDataType
   end subroutine veg_cf_summary
 
   !------------------------------------------------------------
-  subroutine veg_cf_summary_rr(this, num_soilp, filter_soilp, num_soilc, filter_soilc, col_cf_input)
+  subroutine veg_cf_summary_rr(this, bounds, num_soilp, filter_soilp, num_soilc, filter_soilc, col_cf_input)
     !
     ! !DESCRIPTION:
     ! summarize root respiration
     !
     ! !USES:
-    use subgridAveMod, only : p2c_1d_filter_parallel
     !
     ! !ARGUMENTS:
-    type(vegetation_carbon_flux) :: this
+    class(vegetation_carbon_flux) :: this
+    type(bounds_type), intent(in) :: bounds
     integer, intent(in) :: num_soilp
     integer, intent(in) :: filter_soilp(:)
     integer, intent(in) :: num_soilc
@@ -8490,7 +8479,10 @@ module VegetationDataType
     ! !LOCAL VARIABLES
     integer :: fp, p
     !------------------------------------------------------------
-    !$acc parallel loop independent gang vector private(p) default(present)
+    associate( &
+      rr_patch => this%rr, &
+      rr_col   => col_cf_input%rr &
+      )
     do fp = 1,num_soilp
       p = filter_soilp(fp)
       ! root respiration (RR)
@@ -8506,23 +8498,23 @@ module VegetationDataType
       this%cpool_livecroot_storage_gr(p) + &
       this%cpool_deadcroot_storage_gr(p)
     enddo
-    call p2c_1d_filter_parallel(num_soilc, filter_soilc, &
-            this%rr, &
-            col_cf_input%rr)
+    call p2c_1d_filter(bounds, num_soilc, filter_soilc, &
+            rr_patch(bounds%begp:bounds%endp), &
+            rr_col(bounds%begc:bounds%endc))
+  end associate
 
   end subroutine veg_cf_summary_rr
 
   !------------------------------------------------------------
   subroutine veg_cf_summary_for_ch4( this, bounds, num_soilp, filter_soilp)
     !
-    !$acc routine seq
     ! !DESCRIPTION:
     ! summarize vegetation-level fluxes for methane calculation
     !
     ! !USES:
     !
     ! !ARGUMENTS:
-    type(vegetation_carbon_flux) :: this
+    class(vegetation_carbon_flux) :: this
     type(bounds_type), intent(in) :: bounds
     integer, intent(in) :: num_soilp
     integer, intent(in) :: filter_soilp(:)
@@ -8581,8 +8573,9 @@ module VegetationDataType
     !
     ! !DESCRIPTION:
     ! Set vegetation-level carbon fluxes
+    !
     ! !ARGUMENTS:
-    type (vegetation_carbon_flux) :: this
+    class (vegetation_carbon_flux) :: this
     integer , intent(in) :: num_patch
     integer , intent(in) :: filter_patch(:)
     real(r8), intent(in) :: value_patch
@@ -8769,7 +8762,7 @@ module VegetationDataType
           this%npp(i)                                 = value_patch
           this%agnpp(i)                               = value_patch
           this%bgnpp(i)                               = value_patch
-          this%agwdnpp(i)                             = value_patch
+          this%agwdnpp(i)                               = value_patch
           this%litfall(i)                             = value_patch
           this%vegfire(i)                             = value_patch
           this%wood_harvestc(i)                       = value_patch
@@ -9529,7 +9522,7 @@ module VegetationDataType
        end if
     end do
 
-    call veg_nf_SetValues (this, num_patch=num_special_patch, filter_patch=special_patch, value_patch=0._r8)
+    call this%SetValues (num_patch=num_special_patch, filter_patch=special_patch, value_patch=0._r8)
 
   end subroutine veg_nf_init
 
@@ -9612,8 +9605,9 @@ module VegetationDataType
     !
     ! !DESCRIPTION:
     ! Set vegetation-level nitrogen fluxes
+    !
     ! !ARGUMENTS:
-    type (vegetation_nitrogen_flux) :: this
+    class (vegetation_nitrogen_flux) :: this
     integer , intent(in)             :: num_patch
     integer , intent(in)             :: filter_patch(:)
     real(r8), intent(in)             :: value_patch
@@ -9621,6 +9615,7 @@ module VegetationDataType
     ! !LOCAL VARIABLES:
     integer :: fi,i     ! loop index
     !------------------------------------------------------------------------
+
     do fi = 1,num_patch
        i=filter_patch(fi)
 
@@ -9781,9 +9776,8 @@ module VegetationDataType
     ! !DESCRIPTION:
     ! Vegetation-level nitrogen flux summary calculations
     !
-    !$acc routine seq
     ! !ARGUMENTS:
-    type(vegetation_nitrogen_flux)             :: this
+    class(vegetation_nitrogen_flux)             :: this
     type(bounds_type)           , intent(in)    :: bounds
     integer                     , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                     , intent(in)    :: filter_soilc(:) ! filter for soil columns
@@ -10641,7 +10635,7 @@ module VegetationDataType
        end if
     end do
 
-    call veg_pf_SetValues (this, num_patch=num_special_patch, filter_patch=special_patch, value_patch=0._r8)
+    call this%SetValues (num_patch=num_special_patch, filter_patch=special_patch, value_patch=0._r8)
 
   end subroutine veg_pf_init
 
@@ -10739,8 +10733,9 @@ module VegetationDataType
     !
     ! !DESCRIPTION:
     ! Set phosphorus flux variables
+    !
     ! !ARGUMENTS:
-    type (vegetation_phosphorus_flux) :: this
+    class (vegetation_phosphorus_flux) :: this
     integer , intent(in) :: num_patch
     integer , intent(in) :: filter_patch(:)
     real(r8), intent(in) :: value_patch
@@ -10903,9 +10898,8 @@ module VegetationDataType
   !-----------------------------------------------------------------------
   subroutine veg_pf_summary(this, bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, col_pf)
     !
-    !$acc routine seq
     ! !ARGUMENTS:
-    type (vegetation_phosphorus_flux) :: this
+    class (vegetation_phosphorus_flux) :: this
     type(bounds_type) , intent(in)     :: bounds
     integer           , intent(in)     :: num_soilc       ! number of soil columns in filter
     integer           , intent(in)     :: filter_soilc(:) ! filter for soil columns
diff --git a/components/elm/src/dyn_subgrid/dynColumnStateUpdaterMod.F90 b/components/elm/src/dyn_subgrid/dynColumnStateUpdaterMod.F90
index c4d524d421..badbdcd8e4 100644
--- a/components/elm/src/dyn_subgrid/dynColumnStateUpdaterMod.F90
+++ b/components/elm/src/dyn_subgrid/dynColumnStateUpdaterMod.F90
@@ -119,17 +119,17 @@ module dynColumnStateUpdaterMod
 
   type :: column_state_updater_type
 
-     real(r8), pointer :: cwtgcell_old(:) => null() ! old column weights on the grid cell
-     real(r8), pointer :: cwtgcell_new(:) => null()  ! new column weights on the grid cell
+     real(r8), allocatable :: cwtgcell_old(:)  ! old column weights on the grid cell
+     real(r8), allocatable :: cwtgcell_new(:)  ! new column weights on the grid cell
 
      ! (cwtgcell_new - cwtgcell_old) from last call to set_new_weights
-     real(r8), pointer :: area_gained_col(:) => null() 
+     real(r8), allocatable :: area_gained_col(:)
 
      ! For each column, a 'template' column determined as: the first active column on the
      ! natural veg landunit in the same grid cell as the target column. 'active' is
      ! determined at the time of the call to set_old_weights, so that we consider whether
      ! a column was active in the previous time step, rather than newly-active.
-     integer , pointer :: natveg_template_col(:) => null() 
+     integer , allocatable :: natveg_template_col(:)
 
      ! Whether there have been any changes in this time step. This is indexed by clump so
      ! that it is thread-safe (so the different clumps don't stomp on each other). This
@@ -137,26 +137,25 @@ module dynColumnStateUpdaterMod
      ! clumps. (In the future, we plan to rework threading so that there is a separate
      ! object for each clump. In this case the indexing by clump will go away here -
      ! instead, there will be a single scalar 'any_changes' logical for each object.)
-     logical, pointer :: any_changes(:) => null() 
+     logical, allocatable :: any_changes(:)
 
    contains
 
 
-  ! Various ways to update a column-level state variable based on changing column areas:
-  !procedure, public :: update_column_state_no_special_handling
-  procedure, public  :: update_column_state_fill_special_using_natveg
-  procedure, public  :: update_column_state_fill_using_fixed_values
-  procedure, public  :: update_column_state_fill_special_using_fixed_value
-  procedure, public  :: initColumnStateUpdater
+     ! Various ways to update a column-level state variable based on changing column areas:
+     !procedure, public :: update_column_state_no_special_handling
+     procedure, public :: update_column_state_fill_special_using_natveg
+     procedure, public :: update_column_state_fill_using_fixed_values
+     procedure, public :: update_column_state_fill_special_using_fixed_value
+
 
   end type column_state_updater_type
 
- ! interface column_state_updater_type
- !    module procedure constructor  ! initialize a column_state_updater_type object
- ! end interface column_state_updater_type
+  interface column_state_updater_type
+     module procedure constructor  ! initialize a column_state_updater_type object
+  end interface column_state_updater_type
+
 
-  ! object used to update column-level states after subgrid weight updates
-  !type(column_state_updater_type), public :: column_state_updater
   ! !PUBLIC VARIABLES:
   ! For update_column_state_fill_using_fixed_values, any landunit with
   ! FILLVAL_USE_EXISTING_VALUE will use the existing value in the state variable
@@ -171,74 +170,40 @@ contains
   ! Constructors
   ! ========================================================================
 
-  !!-----------------------------------------------------------------------
-  !function constructor(bounds, nclumps)
-  !  !
-  !  ! !DESCRIPTION:
-  !  ! Initialize a column_state_updater_type object
-  !  !
-  !  ! !USES:
-  !  use shr_infnan_mod , only : nan => shr_infnan_nan, assignment(=)
-  !  !
-  !  ! !ARGUMENTS:
-  !  type(column_state_updater_type) :: constructor  ! function result
-  !  type(bounds_type), intent(in)   :: bounds       ! processor bounds
-  !  integer          , intent(in)   :: nclumps      ! number of clumps per proc
-  !  !
-  !  ! !LOCAL VARIABLES:
-
-  !  character(len=*), parameter :: subname = 'constructor'
-  !  !-----------------------------------------------------------------------
-
-  !  SHR_ASSERT(bounds%level == BOUNDS_LEVEL_PROC, errMsg(sourcefile, __LINE__))
-
-  !  allocate(constructor%cwtgcell_old(bounds%begc:bounds%endc))
-  !  constructor%cwtgcell_old(:) = nan
-  !  allocate(constructor%cwtgcell_new(bounds%begc:bounds%endc))
-  !  constructor%cwtgcell_new(:) = nan
-  !  allocate(constructor%area_gained_col(bounds%begc:bounds%endc))
-  !  constructor%area_gained_col(:) = nan
-  !  allocate(constructor%natveg_template_col(bounds%begc:bounds%endc))
-  !  constructor%natveg_template_col(:) = TEMPLATE_NONE_FOUND
-
-  !  allocate(constructor%any_changes(nclumps))
-  !  constructor%any_changes(:) = .false.
-
-  !end function constructor
-
   !-----------------------------------------------------------------------
-  subroutine initColumnStateUpdater(this, bounds, nclumps)
-   !
-   ! !DESCRIPTION:
-   ! Initialize a column_state_updater_type object
-   !
-   ! !USES:
-   use shr_infnan_mod , only : nan => shr_infnan_nan, assignment(=)
-   !
-   ! !ARGUMENTS:
-   class(column_state_updater_type) :: this  ! function result
-   type(bounds_type), intent(in)   :: bounds       ! processor bounds
-   integer          , intent(in)   :: nclumps      ! number of clumps per proc
-   !
-   ! !LOCAL VARIABLES:
-   ! character(len=*), parameter :: subname = 'constructor'
-   !-----------------------------------------------------------------------
-
-   SHR_ASSERT(bounds%level == BOUNDS_LEVEL_PROC, errMsg(sourcefile, __LINE__))
-
-   allocate(this%cwtgcell_old(bounds%begc:bounds%endc))
-   this%cwtgcell_old(:) = nan
-   allocate(this%cwtgcell_new(bounds%begc:bounds%endc))
-   this%cwtgcell_new(:) = nan
-   allocate(this%area_gained_col(bounds%begc:bounds%endc))
-   this%area_gained_col(:) = nan
-   allocate(this%natveg_template_col(bounds%begc:bounds%endc))
-   this%natveg_template_col(:) = TEMPLATE_NONE_FOUND
-
-   allocate(this%any_changes(nclumps))
-   this%any_changes(:) = .false.
-
-  end subroutine initColumnStateUpdater
+  function constructor(bounds, nclumps)
+    !
+    ! !DESCRIPTION:
+    ! Initialize a column_state_updater_type object
+    !
+    ! !USES:
+    use shr_infnan_mod , only : nan => shr_infnan_nan, assignment(=)
+    !
+    ! !ARGUMENTS:
+    type(column_state_updater_type) :: constructor  ! function result
+    type(bounds_type), intent(in)   :: bounds       ! processor bounds
+    integer          , intent(in)   :: nclumps      ! number of clumps per proc
+    !
+    ! !LOCAL VARIABLES:
+
+    character(len=*), parameter :: subname = 'constructor'
+    !-----------------------------------------------------------------------
+
+    SHR_ASSERT(bounds%level == BOUNDS_LEVEL_PROC, errMsg(sourcefile, __LINE__))
+
+    allocate(constructor%cwtgcell_old(bounds%begc:bounds%endc))
+    constructor%cwtgcell_old(:) = nan
+    allocate(constructor%cwtgcell_new(bounds%begc:bounds%endc))
+    constructor%cwtgcell_new(:) = nan
+    allocate(constructor%area_gained_col(bounds%begc:bounds%endc))
+    constructor%area_gained_col(:) = nan
+    allocate(constructor%natveg_template_col(bounds%begc:bounds%endc))
+    constructor%natveg_template_col(:) = TEMPLATE_NONE_FOUND
+
+    allocate(constructor%any_changes(nclumps))
+    constructor%any_changes(:) = .false.
+
+  end function constructor
 
   ! ========================================================================
   ! Public methods
@@ -348,10 +313,10 @@ contains
     logical  :: vals_input_valid(bounds%begc:bounds%endc)
     logical  :: has_prognostic_state(bounds%begc:bounds%endc)
     real(r8) :: non_conserved_mass(bounds%begg:bounds%endg)
-    !character(len=:), allocatable :: err_msg
+    character(len=:), allocatable :: err_msg
     real(r8), parameter :: conservation_tolerance = 1.e-12_r8
 
-    !character(len=*), parameter :: subname = 'update_column_state_no_special_handling'
+    character(len=*), parameter :: subname = 'update_column_state_no_special_handling'
     !-----------------------------------------------------------------------
 
 
@@ -385,8 +350,8 @@ contains
        ! Since there is no special handling in this routine, the non_conserved_mass variable
        ! should not have any accumulation. We allow for roundoff-level accumulation in case
        ! non-conserved mass is determined in a way that is prone to roundoff-level errors.
-       !err_msg = subname//': ERROR: failure to conserve mass when using no special handling'
-       !SHR_ASSERT_ALL(abs(non_conserved_mass(bounds%begg:bounds%endg)) < conservation_tolerance, err_msg)
+       err_msg = subname//': ERROR: failure to conserve mass when using no special handling'
+       SHR_ASSERT_ALL(abs(non_conserved_mass(bounds%begg:bounds%endg)) < conservation_tolerance, err_msg)
 
     end if
 
@@ -723,7 +688,7 @@ contains
     ! call to update_column_state, and then does the call to update_column_state.
     !
     ! !USES:
-    !$acc routine seq
+    !
     ! !ARGUMENTS:
     type(column_state_updater_type), intent(in) :: this
     type(bounds_type), intent(in) :: bounds
@@ -769,7 +734,6 @@ contains
     character(len=*), parameter :: subname = 'update_column_state_with_optional_fractions'
     !-----------------------------------------------------------------------
 
-#ifndef _OPENACC
     if (present(fractional_area_old) .and. .not. present(fractional_area_new)) then
        call endrun(subname//' ERROR: If fractional_area_old is provided, then fractional_area_new must be provided, too')
     end if
@@ -777,7 +741,6 @@ contains
     if (present(fractional_area_new) .and. .not. present(fractional_area_old)) then
        call endrun(subname//' ERROR: If fractional_area_new is provided, then fractional_area_old must be provided, too')
     end if
-#endif 
 
     if (present(fractional_area_old)) then
        my_fractional_area_old(bounds%begc:bounds%endc) = fractional_area_old(bounds%begc:bounds%endc)
diff --git a/components/elm/src/dyn_subgrid/dynConsBiogeochemMod.F90 b/components/elm/src/dyn_subgrid/dynConsBiogeochemMod.F90
index 59a3afc079..5a9d73ba94 100644
--- a/components/elm/src/dyn_subgrid/dynConsBiogeochemMod.F90
+++ b/components/elm/src/dyn_subgrid/dynConsBiogeochemMod.F90
@@ -1,1172 +1,1126 @@
 module dynConsBiogeochemMod
-   
-   #include "shr_assert.h"
-   
-   !---------------------------------------------------------------------------
-   !
-   ! !DESCRIPTION:
-   ! Handle conservation of biogeochemical quantities (C & N) with dynamic land cover.
-   !
-   ! !USES:
-   use shr_kind_mod             , only : r8 => shr_kind_r8
-   use shr_log_mod              , only : errMsg => shr_log_errMsg
-   use decompMod                , only : bounds_type
-   use abortutils               , only : endrun
-   use elm_varctl               , only : iulog, use_c13, use_c14
-   use VegetationPropertiesType , only : veg_vp
-   use CanopyStateType          , only : canopystate_type
-   use PhotosynthesisType       , only : photosyns_type
-   use CNStateType              , only : cnstate_type
-   use GridcellDataType         , only : grc_cf, c13_grc_cf, c14_grc_cf
-   use GridcellDataType         , only : grc_nf, grc_pf
-   use LandunitType             , only : lun_pp
-   use ColumnType               , only : col_pp
-   use ColumnDataType           , only : column_carbon_state, column_nitrogen_state
-   use ColumnDataType           , only : column_phosphorus_state
-   use ColumnDataType           , only : col_cf, c13_col_cf, c14_col_cf
-   use ColumnDataType           , only : col_nf, col_pf
-   use VegetationType           , only : veg_pp
-   use VegetationDataType       , only : vegetation_carbon_state, vegetation_carbon_flux
-   use VegetationDataType       , only : vegetation_nitrogen_state
-   use VegetationDataType       , only : vegetation_phosphorus_state
-   use VegetationDataType       , only : veg_cf, c13_veg_cf, c14_veg_cf
-   use VegetationDataType       , only : veg_nf, veg_pf
-   use elm_varcon               , only : c14ratio
-   use dynPatchStateUpdaterMod  , only : patch_state_updater_type
-   use dynSubgridAdjustmentsMod , only : dyn_veg_cs_Adjustments, dyn_col_cs_Adjustments
-   use dynSubgridAdjustmentsMod , only : dyn_veg_ns_Adjustments, dyn_col_ns_Adjustments
-   use dynSubgridAdjustmentsMod , only : dyn_veg_ps_Adjustments, dyn_col_ps_Adjustments
-   use GridcellType             , only : grc_pp 
-   !
-   ! !PUBLIC MEMBER FUNCTIONS:
-   implicit none
-   private
-   
-   save
-   
-   public :: dyn_cnbal_patch
-   public :: dyn_cnbal_column
-   !-----------------------------------------------------------------------
-   
-   contains
-   
-   !-----------------------------------------------------------------------
-   subroutine dyn_cnbal_patch(bounds, &
-      num_soilp_with_inactive, filter_soilp_with_inactive, &
-      num_soilc_with_inactive, filter_soilc_with_inactive, &
-      prior_weights, &
-      patch_state_updater, &
-      canopystate_vars, photosyns_vars, cnstate_vars, &
-      veg_cs, c13_veg_cs, c14_veg_cs, &
-      veg_ns, veg_ps, dt)
-      !
-      ! !DESCRIPTION:
-      ! Modify pft-level state and flux variables to maintain carbon and nitrogen balance with
-      ! dynamic pft-weights.
-      !
-      ! !USES:
-      use shr_const_mod      , only : SHR_CONST_PDB
-      use landunit_varcon    , only : istsoil, istcrop
-      use elm_varpar         , only : numveg, nlevdecomp, max_patch_per_col
-      use pftvarcon          , only : pconv, pprod10, pprod100
-      use elm_varcon         , only : c13ratio, c14ratio
-      use dynPriorWeightsMod , only : prior_weights_type
-      !
-      ! !ARGUMENTS:
-      type(bounds_type)              , intent(in)    :: bounds
-      integer                        , intent(in)    :: num_soilp_with_inactive ! number of points in filter
-      integer                        , intent(in)    :: filter_soilp_with_inactive(:) ! soil patch filter that includes inactive points
-      integer                        , intent(in)    :: num_soilc_with_inactive ! number of points in filter
-      integer                        , intent(in)    :: filter_soilc_with_inactive(:) ! soil column filter that includes inactive points
-      type(prior_weights_type)       , intent(in)    :: prior_weights ! weights prior to the subgrid weight updates
-      type(patch_state_updater_type) , intent(in)    :: patch_state_updater
-      type(canopystate_type)         , intent(inout) :: canopystate_vars
-      type(photosyns_type)           , intent(inout) :: photosyns_vars
-      type(cnstate_type)             , intent(inout) :: cnstate_vars
-      type(vegetation_carbon_state)  , intent(inout) :: veg_cs
-      type(vegetation_carbon_state)  , intent(inout) :: c13_veg_cs
-      type(vegetation_carbon_state)  , intent(inout) :: c14_veg_cs
-      type(vegetation_nitrogen_state), intent(inout) :: veg_ns
-      type(vegetation_phosphorus_state),intent(inout) :: veg_ps
-      real(r8)                         ,intent(in)    :: dt                            ! land model time step (sec)
-      
-      !
-      ! !LOCAL VARIABLES:
-      integer   :: p,c,l,g,j,fp,fc               ! indices
-      integer   :: begg, endg 
-      integer   :: ier                           ! error code
-      real(r8)  :: dwt                           ! change in pft weight (relative to column)
-      character(len=32)    :: subname='dyn_cbal' ! subroutine name
-      
-      !! ACTUAL VARIABLES that will be re-used for each species 
-      real(r8)  :: dwt_leaf_seed 
-      real(r8)  :: dwt_deadstem_seed  ! pft-level mass gain due to seeding of new area
-      real(r8)  :: dwt_pool_seed      ! pft-level mass gain due to seeding of new area
-      real(r8)  :: dwt_froot_to_litter(1:num_soilp_with_inactive)! pft-level mass loss due to weight shift
-      real(r8)  :: dwt_livecroot_to_litter(1:num_soilp_with_inactive)   ! pft-level mass loss due to weight shift
-      real(r8)  :: dwt_deadcroot_to_litter(1:num_soilp_with_inactive)   ! pft-level mass loss due to weight shift
-      real(r8)  :: conv_flux(1:num_soilp_with_inactive)                 ! pft-level mass loss due to weight shift
-      real(r8)  :: prod10_flux(1:num_soilp_with_inactive)               ! pft-level mass loss due to weight shift
-      real(r8)  :: prod100_flux(1:num_soilp_with_inactive)              ! pft-level mass loss due to weight shift
-      real(r8)  :: crop_product_flux(1:num_soilp_with_inactive)         ! pft-level mass loss due to weight shift
-      integer   :: patch_to_soil_filter(bounds%begp:bounds%endp)
-      
-      
-      !! C13
-      real(r8), allocatable :: dwt_leafc13_seed(:)           ! pft-level mass gain due to seeding of new area
-      real(r8), allocatable :: dwt_deadstemc13_seed(:)       ! pft-level mass gain due to seeding of new area
-      real(r8), allocatable :: dwt_frootc13_to_litter(:)     ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: dwt_livecrootc13_to_litter(:) ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: dwt_deadcrootc13_to_litter(:) ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: conv_c13flux(:)               ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: prod10_c13flux(:)             ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: prod100_c13flux(:)            ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: crop_product_c13flux(:)       ! pft-level mass loss due to weight shift
-      !! C14
-      real(r8), allocatable :: dwt_leafc14_seed(:)           ! pft-level mass gain due to seeding of new area
-      real(r8), allocatable :: dwt_deadstemc14_seed(:)       ! pft-level mass gain due to seeding of new area
-      real(r8), allocatable :: dwt_frootc14_to_litter(:)     ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: dwt_livecrootc14_to_litter(:) ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: dwt_deadcrootc14_to_litter(:) ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: conv_c14flux(:)               ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: prod10_c14flux(:)             ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: prod100_c14flux(:)            ! pft-level mass loss due to weight shift
-      real(r8), allocatable :: crop_product_c14flux(:)       ! pft-level mass loss due to weight shift
-      real(r8) :: froot, croot
-      real(r8) :: fr_flab, fr_fcel, fr_flig
-      real(r8) :: startt, stopt
-      real(r8) :: sum1, sum2, sum3, sum4 ,sum5, sum_seed2pool
-      !-----------------------------------------------------------------------
-      begg = bounds%begg
-      endg = bounds%endg
-       
-      if ( use_c13 ) then
-         allocate(dwt_leafc13_seed           (num_soilp_with_inactive), stat=ier)
-         allocate(dwt_deadstemc13_seed       (num_soilp_with_inactive), stat=ier)
-         allocate(dwt_frootc13_to_litter     (num_soilp_with_inactive), stat=ier)
-         allocate(dwt_livecrootc13_to_litter (num_soilp_with_inactive), stat=ier)
-         allocate(dwt_deadcrootc13_to_litter (num_soilp_with_inactive), stat=ier)
-         allocate(conv_c13flux               (num_soilp_with_inactive), stat=ier)
-         allocate(prod10_c13flux             (num_soilp_with_inactive), stat=ier)
-         allocate(prod100_c13flux            (num_soilp_with_inactive), stat=ier)
-         allocate(crop_product_c13flux       (num_soilp_with_inactive), stat=ier)
-      endif
-      if ( use_c14 ) then
-         allocate(dwt_leafc14_seed           (num_soilp_with_inactive), stat=ier)
-         allocate(dwt_deadstemc14_seed       (num_soilp_with_inactive), stat=ier)
-         allocate(dwt_frootc14_to_litter     (num_soilp_with_inactive), stat=ier)
-         allocate(dwt_livecrootc14_to_litter (num_soilp_with_inactive), stat=ier)
-         allocate(dwt_deadcrootc14_to_litter (num_soilp_with_inactive), stat=ier)
-         allocate(conv_c14flux               (num_soilp_with_inactive), stat=ier)
-         allocate(prod10_c14flux             (num_soilp_with_inactive), stat=ier)
-         allocate(prod100_c14flux            (num_soilp_with_inactive), stat=ier)
-         allocate(crop_product_c14flux       (num_soilp_with_inactive), stat=ier)
-      endif
-      
-
-      !$acc enter data create(&
-      !$acc dwt_froot_to_litter(:)    ,&
-      !$acc dwt_livecroot_to_litter(:),&
-      !$acc dwt_deadcroot_to_litter(:),&
-      !$acc conv_flux(:)              ,&
-      !$acc prod10_flux(:)            ,&
-      !$acc prod100_flux(:)           ,&
-      !$acc crop_product_flux(:)      ,&
-      !$acc patch_to_soil_filter(:)  )
-      !$acc enter data create(sum1, sum2, sum3, sum4, sum5, sum_seed2pool) 
-
-      !$acc parallel loop independent gang vector default(present) 
+
+#include "shr_assert.h"
+
+  !---------------------------------------------------------------------------
+  !
+  ! !DESCRIPTION:
+  ! Handle conservation of biogeochemical quantities (C & N) with dynamic land cover.
+  !
+  ! !USES:
+  use shr_kind_mod             , only : r8 => shr_kind_r8
+  use shr_log_mod              , only : errMsg => shr_log_errMsg
+  use decompMod                , only : bounds_type
+  use abortutils               , only : endrun
+  use elm_varctl               , only : iulog, use_c13, use_c14
+  use VegetationPropertiesType , only : veg_vp
+  use CanopyStateType          , only : canopystate_type
+  use PhotosynthesisType       , only : photosyns_type
+  use CNStateType              , only : cnstate_type
+  use GridcellDataType         , only : grc_cf, c13_grc_cf, c14_grc_cf
+  use GridcellDataType         , only : grc_nf, grc_pf
+  use LandunitType             , only : lun_pp
+  use ColumnType               , only : col_pp
+  use ColumnDataType           , only : column_carbon_state, column_nitrogen_state
+  use ColumnDataType           , only : column_phosphorus_state
+  use ColumnDataType           , only : col_cf, c13_col_cf, c14_col_cf
+  use ColumnDataType           , only : col_nf, col_pf
+  use VegetationType           , only : veg_pp
+  use VegetationDataType       , only : vegetation_carbon_state, vegetation_carbon_flux
+  use VegetationDataType       , only : vegetation_nitrogen_state
+  use VegetationDataType       , only : vegetation_phosphorus_state
+  use VegetationDataType       , only : veg_cf, c13_veg_cf, c14_veg_cf
+  use VegetationDataType       , only : veg_nf, veg_pf
+  use elm_varcon               , only : c14ratio
+  use dynPatchStateUpdaterMod  , only : patch_state_updater_type
+  use dynSubgridAdjustmentsMod , only : dyn_veg_cs_Adjustments, dyn_col_cs_Adjustments
+  use dynSubgridAdjustmentsMod , only : dyn_veg_ns_Adjustments, dyn_col_ns_Adjustments
+  use dynSubgridAdjustmentsMod , only : dyn_veg_ps_Adjustments, dyn_col_ps_Adjustments
+
+
+  !
+  ! !PUBLIC MEMBER FUNCTIONS:
+  implicit none
+  private
+
+  save
+
+  public :: dyn_cnbal_patch
+  public :: dyn_cnbal_column
+  !-----------------------------------------------------------------------
+
+contains
+
+  !-----------------------------------------------------------------------
+  subroutine dyn_cnbal_patch(bounds, &
+       num_soilp_with_inactive, filter_soilp_with_inactive, &
+       num_soilc_with_inactive, filter_soilc_with_inactive, &
+       prior_weights, &
+       patch_state_updater, &
+       canopystate_vars, photosyns_vars, cnstate_vars, &
+       veg_cs, c13_veg_cs, c14_veg_cs, &
+       veg_ns, veg_ps, dt)
+    !
+    ! !DESCRIPTION:
+    ! Modify pft-level state and flux variables to maintain carbon and nitrogen balance with
+    ! dynamic pft-weights.
+    !
+    ! !USES:
+    use shr_const_mod      , only : SHR_CONST_PDB
+    use landunit_varcon    , only : istsoil, istcrop
+    use elm_varpar         , only : numveg, nlevdecomp, max_patch_per_col
+    use pftvarcon          , only : pconv, pprod10, pprod100
+    use elm_varcon         , only : c13ratio, c14ratio
+    use clm_time_manager   , only : get_step_size
+    use dynPriorWeightsMod , only : prior_weights_type
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)              , intent(in)    :: bounds
+    integer                        , intent(in)    :: num_soilp_with_inactive ! number of points in filter
+    integer                        , intent(in)    :: filter_soilp_with_inactive(:) ! soil patch filter that includes inactive points
+    integer                        , intent(in)    :: num_soilc_with_inactive ! number of points in filter
+    integer                        , intent(in)    :: filter_soilc_with_inactive(:) ! soil column filter that includes inactive points
+    type(prior_weights_type)       , intent(in)    :: prior_weights ! weights prior to the subgrid weight updates
+    type(patch_state_updater_type) , intent(in)    :: patch_state_updater
+    type(canopystate_type)         , intent(inout) :: canopystate_vars
+    type(photosyns_type)           , intent(inout) :: photosyns_vars
+    type(cnstate_type)             , intent(inout) :: cnstate_vars
+    type(vegetation_carbon_state)  , intent(inout) :: veg_cs
+    type(vegetation_carbon_state)  , intent(inout) :: c13_veg_cs
+    type(vegetation_carbon_state)  , intent(inout) :: c14_veg_cs
+    type(vegetation_nitrogen_state), intent(inout) :: veg_ns
+    type(vegetation_phosphorus_state),intent(inout) :: veg_ps
+    real(r8)                         ,intent(in)    :: dt                            ! land model time step (sec)
+
+    !
+    ! !LOCAL VARIABLES:
+    integer   :: p,c,l,g,j,fp               ! indices
+    integer   :: ier                           ! error code
+    real(r8)  :: dwt                           ! change in pft weight (relative to column)
+    real(r8)  :: dwt_leafc_seed(1:num_soilp_with_inactive) ! pft-level mass gain due to seeding of new area
+    real(r8)  :: dwt_leafn_seed(1:num_soilp_with_inactive) ! pft-level mass gain due to seeding of new area
+    real(r8)  :: dwt_deadstemc_seed(1:num_soilp_with_inactive) ! pft-level mass gain due to seeding of new area
+    real(r8)  :: dwt_deadstemn_seed(1:num_soilp_with_inactive) ! pft-level mass gain due to seeding of new area
+    real(r8)  :: dwt_npool_seed(1:num_soilp_with_inactive)     ! pft-level mass gain due to seeding of new area
+    real(r8)  :: dwt_frootc_to_litter(1:num_soilp_with_inactive)       ! pft-level mass loss due to weight shift
+    real(r8)  :: dwt_livecrootc_to_litter(1:num_soilp_with_inactive)   ! pft-level mass loss due to weight shift
+    real(r8)  :: dwt_deadcrootc_to_litter(1:num_soilp_with_inactive)   ! pft-level mass loss due to weight shift
+    real(r8)  :: dwt_frootn_to_litter(1:num_soilp_with_inactive)       ! pft-level mass loss due to weight shift
+    real(r8)  :: dwt_livecrootn_to_litter(1:num_soilp_with_inactive)   ! pft-level mass loss due to weight shift
+    real(r8)  :: dwt_deadcrootn_to_litter(1:num_soilp_with_inactive)   ! pft-level mass loss due to weight shift
+    real(r8)  :: conv_cflux(1:num_soilp_with_inactive)                 ! pft-level mass loss due to weight shift
+    real(r8)  :: prod10_cflux(1:num_soilp_with_inactive)               ! pft-level mass loss due to weight shift
+    real(r8)  :: prod100_cflux(1:num_soilp_with_inactive)              ! pft-level mass loss due to weight shift
+    real(r8)  :: crop_product_cflux(1:num_soilp_with_inactive)         ! pft-level mass loss due to weight shift
+    real(r8)  :: conv_nflux(1:num_soilp_with_inactive)                 ! pft-level mass loss due to weight shift
+    real(r8)  :: prod10_nflux(1:num_soilp_with_inactive)               ! pft-level mass loss due to weight shift
+    real(r8)  :: prod100_nflux(1:num_soilp_with_inactive)              ! pft-level mass loss due to weight shift
+    real(r8)  :: crop_product_nflux(1:num_soilp_with_inactive)         ! pft-level mass loss due to weight shift
+    character(len=32)             :: subname='dyn_cbal'            ! subroutine name
+
+    ! ! add phosphorus local variables
+    real(r8)  :: dwt_leafp_seed(1:num_soilp_with_inactive)             ! pft-level mass gain due to seeding of new area
+    real(r8)  :: dwt_deadstemp_seed(1:num_soilp_with_inactive)         ! pft-level mass gain due to seeding of new area
+    real(r8)  :: dwt_ppool_seed(1:num_soilp_with_inactive)             ! pft-level mass gain due to seeding of new area
+    real(r8)  :: dwt_frootp_to_litter(1:num_soilp_with_inactive)       ! pft-level mass loss due to weight shift
+    real(r8)  :: dwt_livecrootp_to_litter(1:num_soilp_with_inactive)   ! pft-level mass loss due to weight shift
+    real(r8)  :: dwt_deadcrootp_to_litter(1:num_soilp_with_inactive)   ! pft-level mass loss due to weight shift
+    real(r8)  :: conv_pflux(1:num_soilp_with_inactive)                 ! pft-level mass loss due to weight shift
+    real(r8)  :: prod10_pflux(1:num_soilp_with_inactive)               ! pft-level mass loss due to weight shift
+    real(r8)  :: prod100_pflux(1:num_soilp_with_inactive)              ! pft-level mass loss due to weight shift
+    real(r8)  :: crop_product_pflux(1:num_soilp_with_inactive)         ! pft-level mass loss due to weight shift
+
+    !! C13
+    real(r8), allocatable :: dwt_leafc13_seed(:)           ! pft-level mass gain due to seeding of new area
+    real(r8), allocatable :: dwt_deadstemc13_seed(:)       ! pft-level mass gain due to seeding of new area
+    real(r8), allocatable :: dwt_frootc13_to_litter(:)     ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: dwt_livecrootc13_to_litter(:) ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: dwt_deadcrootc13_to_litter(:) ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: conv_c13flux(:)               ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: prod10_c13flux(:)             ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: prod100_c13flux(:)            ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: crop_product_c13flux(:)       ! pft-level mass loss due to weight shift
+    !! C14
+    real(r8), allocatable :: dwt_leafc14_seed(:)           ! pft-level mass gain due to seeding of new area
+    real(r8), allocatable :: dwt_deadstemc14_seed(:)       ! pft-level mass gain due to seeding of new area
+    real(r8), allocatable :: dwt_frootc14_to_litter(:)     ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: dwt_livecrootc14_to_litter(:) ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: dwt_deadcrootc14_to_litter(:) ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: conv_c14flux(:)               ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: prod10_c14flux(:)             ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: prod100_c14flux(:)            ! pft-level mass loss due to weight shift
+    real(r8), allocatable :: crop_product_c14flux(:)       ! pft-level mass loss due to weight shift
+    real(r8) :: froot, croot
+    real(r8) :: fr_flab, fr_fcel, fr_flig
+    !-----------------------------------------------------------------------
+
+    if ( use_c13 ) then
+       allocate(dwt_leafc13_seed           (num_soilp_with_inactive), stat=ier)
+       allocate(dwt_deadstemc13_seed       (num_soilp_with_inactive), stat=ier)
+       allocate(dwt_frootc13_to_litter     (num_soilp_with_inactive), stat=ier)
+       allocate(dwt_livecrootc13_to_litter (num_soilp_with_inactive), stat=ier)
+       allocate(dwt_deadcrootc13_to_litter (num_soilp_with_inactive), stat=ier)
+       allocate(conv_c13flux               (num_soilp_with_inactive), stat=ier)
+       allocate(prod10_c13flux             (num_soilp_with_inactive), stat=ier)
+       allocate(prod100_c13flux            (num_soilp_with_inactive), stat=ier)
+       allocate(crop_product_c13flux       (num_soilp_with_inactive), stat=ier)
+    endif
+    if ( use_c14 ) then
+       allocate(dwt_leafc14_seed           (num_soilp_with_inactive), stat=ier)
+       allocate(dwt_deadstemc14_seed       (num_soilp_with_inactive), stat=ier)
+       allocate(dwt_frootc14_to_litter     (num_soilp_with_inactive), stat=ier)
+       allocate(dwt_livecrootc14_to_litter (num_soilp_with_inactive), stat=ier)
+       allocate(dwt_deadcrootc14_to_litter (num_soilp_with_inactive), stat=ier)
+       allocate(conv_c14flux               (num_soilp_with_inactive), stat=ier)
+       allocate(prod10_c14flux             (num_soilp_with_inactive), stat=ier)
+       allocate(prod100_c14flux            (num_soilp_with_inactive), stat=ier)
+       allocate(crop_product_c14flux       (num_soilp_with_inactive), stat=ier)
+    endif
+
+    do fp = 1, num_soilp_with_inactive
+      ! initialize all the pft-level local flux arrays
+      dwt_leafc_seed(fp)           = 0._r8
+      dwt_deadstemc_seed(fp)       = 0._r8
+      dwt_frootc_to_litter(fp)     = 0._r8
+      dwt_livecrootc_to_litter(fp) = 0._r8
+      dwt_deadcrootc_to_litter(fp) = 0._r8
+      conv_cflux(fp)               = 0._r8
+      prod10_cflux(fp)             = 0._r8
+      prod100_cflux(fp)            = 0._r8
+      crop_product_cflux(fp)       = 0._r8
+
+      dwt_leafn_seed(fp)           = 0._r8
+      dwt_deadstemn_seed(fp)       = 0._r8
+      dwt_npool_seed(fp)           = 0._r8
+      dwt_frootn_to_litter(fp)     = 0._r8
+      dwt_livecrootn_to_litter(fp) = 0._r8
+      dwt_deadcrootn_to_litter(fp) = 0._r8
+      conv_nflux(fp)               = 0._r8
+      prod10_nflux(fp)             = 0._r8
+      prod100_nflux(fp)            = 0._r8
+      crop_product_nflux(fp)       = 0._r8
+
+      dwt_leafp_seed(fp)           = 0._r8
+      dwt_deadstemp_seed(fp)       = 0._r8
+      dwt_ppool_seed(fp)           = 0._r8
+      dwt_frootp_to_litter(fp)     = 0._r8
+      dwt_livecrootp_to_litter(fp) = 0._r8
+      dwt_deadcrootp_to_litter(fp) = 0._r8
+      conv_pflux(fp)               = 0._r8
+      prod10_pflux(fp)             = 0._r8
+      prod100_pflux(fp)            = 0._r8
+      crop_product_pflux(fp)       = 0._r8
+    enddo
+
+    if(use_c13) then
       do fp = 1, num_soilp_with_inactive
-         ! initialize all the pft-level local flux arrays
-         dwt_pool_seed         = 0.0_r8
-         dwt_froot_to_litter(fp)    = 0.0_r8
-         dwt_livecroot_to_litter(fp)= 0.0_r8
-         dwt_deadcroot_to_litter(fp)= 0.0_r8
-         conv_flux(fp)              = 0.0_r8
-         prod10_flux(fp)            = 0.0_r8
-         prod100_flux(fp)           = 0.0_r8
-         crop_product_flux(fp)      = 0.0_r8
+        dwt_leafc13_seed(fp)           = 0._r8
+        dwt_deadstemc13_seed(fp)       = 0._r8
+        dwt_frootc13_to_litter(fp)     = 0._r8
+        dwt_livecrootc13_to_litter(fp) = 0._r8
+        dwt_deadcrootc13_to_litter(fp) = 0._r8
+        conv_c13flux(fp)               = 0._r8
+        prod10_c13flux(fp)             = 0._r8
+        prod100_c13flux(fp)            = 0._r8
+        crop_product_c13flux(fp)       = 0._r8
+
       enddo
-      
-      if(use_c13) then
-         do fp = 1, num_soilp_with_inactive
-            dwt_leafc13_seed(fp)           = 0._r8
-            dwt_deadstemc13_seed(fp)       = 0._r8
-            dwt_frootc13_to_litter(fp)     = 0._r8
-            dwt_livecrootc13_to_litter(fp) = 0._r8
-            dwt_deadcrootc13_to_litter(fp) = 0._r8
-            conv_c13flux(fp)               = 0._r8
-            prod10_c13flux(fp)             = 0._r8
-            prod100_c13flux(fp)            = 0._r8
-            crop_product_c13flux(fp)       = 0._r8
-            
-         enddo
-      end if
-      
-      if ( use_c14 ) then
-         do fp = 1, num_soilp_with_inactive
-            dwt_leafc14_seed(fp)           = 0._r8
-            dwt_deadstemc14_seed(fp)       = 0._r8
-            dwt_frootc14_to_litter(fp)     = 0._r8
-            dwt_livecrootc14_to_litter(fp) = 0._r8
-            dwt_deadcrootc14_to_litter(fp) = 0._r8
-            conv_c14flux(fp)               = 0._r8
-            prod10_c14flux(fp)             = 0._r8
-            prod100_c14flux(fp)            = 0._r8
-            crop_product_c14flux(fp)       = 0._r8
-         enddo
-      endif
-      
-      !$acc parallel loop independent gang vector default(present) present(veg_cs,veg_ns,veg_ps) private(p,c,l,dwt)
-      do fp = 1, num_soilp_with_inactive
-         p = filter_soilp_with_inactive(fp)
-         c = veg_pp%column(p)
-         l = veg_pp%landunit(p)
-         patch_to_soil_filter(p) = fp
-         
-         ! calculate the change in weight for the timestep
-         dwt = veg_pp%wtcol(p)-prior_weights%pwtcol(p)
-         cnstate_vars%lfpftd_patch(p) = -dwt
-         
-         ! Patches for which weight increases on this timestep
-         if (dwt > 0._r8) then
-            
-            ! first identify Patches that are initiating on this timestep
-            ! and set all the necessary state and flux variables
-            if (prior_weights%pwtcol(p) == 0._r8) then
-               
-               ! set initial conditions for PFT that is being initiated
-               ! in this time step.  Based on the settings in cnIniTimeVar.
-               
-               ! pft-level carbon state variables
-               
-               veg_cs%leafc(p)              = 0._r8
-               veg_cs%leafc_storage(p)      = 0._r8
-               veg_cs%leafc_xfer(p)         = 0._r8
-               veg_cs%frootc(p)             = 0._r8
-               veg_cs%frootc_storage(p)     = 0._r8
-               veg_cs%frootc_xfer(p)        = 0._r8
-               veg_cs%livestemc(p)          = 0._r8
-               veg_cs%livestemc_storage(p)  = 0._r8
-               veg_cs%livestemc_xfer(p)     = 0._r8
-               veg_cs%deadstemc(p)          = 0._r8
-               veg_cs%deadstemc_storage(p)  = 0._r8
-               veg_cs%deadstemc_xfer(p)     = 0._r8
-               veg_cs%livecrootc(p)         = 0._r8
-               veg_cs%livecrootc_storage(p) = 0._r8
-               veg_cs%livecrootc_xfer(p)    = 0._r8
-               veg_cs%deadcrootc(p)         = 0._r8
-               veg_cs%deadcrootc_storage(p) = 0._r8
-               veg_cs%deadcrootc_xfer(p)    = 0._r8
-               veg_cs%gresp_storage(p)      = 0._r8
-               veg_cs%gresp_xfer(p)         = 0._r8
-               veg_cs%cpool(p)              = 0._r8
-               veg_cs%xsmrpool(p)           = 0._r8
-               veg_cs%ctrunc(p)             = 0._r8
-               veg_cs%dispvegc(p)           = 0._r8
-               veg_cs%storvegc(p)           = 0._r8
-               veg_cs%totvegc(p)            = 0._r8
-               veg_cs%totpftc(p)            = 0._r8
-               
-               veg_ns%leafn(p)              = 0._r8
-               veg_ns%leafn_storage(p)      = 0._r8
-               veg_ns%leafn_xfer(p)         = 0._r8
-               veg_ns%frootn(p)             = 0._r8
-               veg_ns%frootn_storage(p)     = 0._r8
-               veg_ns%frootn_xfer(p)        = 0._r8
-               veg_ns%livestemn(p)          = 0._r8
-               veg_ns%livestemn_storage(p)  = 0._r8
-               veg_ns%livestemn_xfer(p)     = 0._r8
-               veg_ns%deadstemn(p)          = 0._r8
-               veg_ns%deadstemn_storage(p)  = 0._r8
-               veg_ns%deadstemn_xfer(p)     = 0._r8
-               veg_ns%livecrootn(p)         = 0._r8
-               veg_ns%livecrootn_storage(p) = 0._r8
-               veg_ns%livecrootn_xfer(p)    = 0._r8
-               veg_ns%deadcrootn(p)         = 0._r8
-               veg_ns%deadcrootn_storage(p) = 0._r8
-               veg_ns%deadcrootn_xfer(p)    = 0._r8
-               veg_ns%retransn(p)           = 0._r8
-               veg_ns%npool(p)              = 0._r8
-               veg_ns%ntrunc(p)             = 0._r8
-               veg_ns%dispvegn(p)           = 0._r8
-               veg_ns%storvegn(p)           = 0._r8
-               veg_ns%totvegn(p)            = 0._r8
-               veg_ns%totpftn(p)            = 0._r8
-               
-               veg_ps%leafp(p)              = 0._r8
-               veg_ps%leafp_storage(p)      = 0._r8
-               veg_ps%leafp_xfer(p)         = 0._r8
-               veg_ps%frootp(p)             = 0._r8
-               veg_ps%frootp_storage(p)     = 0._r8
-               veg_ps%frootp_xfer(p)        = 0._r8
-               veg_ps%livestemp(p)          = 0._r8
-               veg_ps%livestemp_storage(p)  = 0._r8
-               veg_ps%livestemp_xfer(p)     = 0._r8
-               veg_ps%deadstemp(p)          = 0._r8
-               veg_ps%deadstemp_storage(p)  = 0._r8
-               veg_ps%deadstemp_xfer(p)     = 0._r8
-               veg_ps%livecrootp(p)         = 0._r8
-               veg_ps%livecrootp_storage(p) = 0._r8
-               veg_ps%livecrootp_xfer(p)    = 0._r8
-               veg_ps%deadcrootp(p)         = 0._r8
-               veg_ps%deadcrootp_storage(p) = 0._r8
-               veg_ps%deadcrootp_xfer(p)    = 0._r8
-               veg_ps%retransp(p)           = 0._r8
-               veg_ps%ppool(p)              = 0._r8
-               veg_ps%ptrunc(p)             = 0._r8
-               veg_ps%dispvegp(p)           = 0._r8
-               veg_ps%storvegp(p)           = 0._r8
-               veg_ps%totvegp(p)            = 0._r8
-               veg_ps%totpftp (p)           = 0._r8
-               
-               canopystate_vars%laisun_patch(p) = 0._r8
-               canopystate_vars%laisha_patch(p) = 0._r8
-               
-               cnstate_vars%dormant_flag_patch(p)          = 1._r8
-               cnstate_vars%days_active_patch(p)           = 0._r8
-               cnstate_vars%onset_flag_patch(p)            = 0._r8
-               cnstate_vars%onset_counter_patch(p)         = 0._r8
-               cnstate_vars%onset_gddflag_patch(p)         = 0._r8
-               cnstate_vars%onset_fdd_patch(p)             = 0._r8
-               cnstate_vars%onset_gdd_patch(p)             = 0._r8
-               cnstate_vars%onset_swi_patch(p)             = 0._r8
-               cnstate_vars%offset_flag_patch(p)           = 0._r8
-               cnstate_vars%offset_counter_patch(p)        = 0._r8
-               cnstate_vars%offset_fdd_patch(p)            = 0._r8
-               cnstate_vars%offset_swi_patch(p)            = 0._r8
-               cnstate_vars%lgsf_patch(p)                  = 0._r8
-               cnstate_vars%bglfr_patch(p)                 = 0._r8
-               cnstate_vars%bglfr_leaf_patch(p)            = 0._r8
-               cnstate_vars%bglfr_froot_patch(p)           = 0._r8
-               cnstate_vars%bgtr_patch(p)                  = 0._r8
-               cnstate_vars%annavg_t2m_patch(p)            = cnstate_vars%annavg_t2m_col(c)
-               cnstate_vars%tempavg_t2m_patch(p)           = 0._r8
-               cnstate_vars%alloc_pnow_patch(p)            = 1._r8
-               cnstate_vars%c_allometry_patch(p)           = 0._r8
-               cnstate_vars%n_allometry_patch(p)           = 0._r8
-               cnstate_vars%p_allometry_patch(p)           = 0._r8
-               cnstate_vars%tempsum_potential_gpp_patch(p) = 0._r8
-               cnstate_vars%annsum_potential_gpp_patch(p)  = 0._r8
-               cnstate_vars%tempmax_retransn_patch(p)      = 0._r8
-               cnstate_vars%annmax_retransn_patch(p)       = 0._r8
-               cnstate_vars%downreg_patch(p)               = 0._r8
-               
-               cnstate_vars%tempmax_retransp_patch(p)      = 0._r8
-               cnstate_vars%annmax_retransp_patch(p)       = 0._r8
-               
-               if ( use_c14 ) then
-                  cnstate_vars%rc14_atm_patch(p) = c14ratio
-                  cnstate_vars%rc14_atm_patch(p) = 0._r8
-               endif
-               veg_cf%xsmrpool_recover(p)      = 0._r8
-               veg_cf%plant_calloc(p)          = 0._r8
-               veg_cf%excess_cflux(p)          = 0._r8
-               veg_cf%prev_leafc_to_litter(p)  = 0._r8
-               veg_cf%prev_frootc_to_litter(p) = 0._r8
-               veg_cf%availc(p)                = 0._r8
-               veg_cf%gpp_before_downreg(p)    = 0._r8
-               veg_cf%tempsum_npp(p)           = 0._r8
-               veg_cf%annsum_npp(p)            = 0._r8
-      
-               if ( use_c13 ) then
-                  veg_cf%xsmrpool_c13ratio(p) = c13ratio
-               end if
-               veg_nf%plant_ndemand(p)         = 0._r8
-               veg_nf%avail_retransn(p)        = 0._r8
-               veg_nf%plant_nalloc(p)          = 0._r8
-               
-               veg_pf%plant_pdemand(p)         = 0._r8
-               veg_pf%avail_retransp(p)        = 0._r8
-               veg_pf%plant_palloc(p)          = 0._r8
-               
-               ! if ( use_c13 ) then
-               !    call CarbonStateVarsInit(c13_veg_cs, p)
-               ! endif
-               ! if ( use_c14 ) then
-               !    call CarbonStateVarsInit(c14_veg_cs, p)
-               ! endif
-               
-               ! add phosphorus related variables
-               photosyns_vars%psnsun_patch(p) = 0._r8
-               photosyns_vars%psnsha_patch(p) = 0._r8
-               !if ( use_c13 ) then
-               !   photosyns_vars%alphapsnsun_patch(p) = 0._r8
-               !   photosyns_vars%alphapsnsha_patch(p) = 0._r8
-               !   photosyns_vars%rc13_canair_patch(p) = 0._r8
-               !   photosyns_vars%rc13_psnsun_patch(p) = 0._r8
-               !   photosyns_vars%rc13_psnsha_patch(p) = 0._r8
-               !   photosyns_vars%c13_psnsun_patch(p) = 0._r8
-               !   photosyns_vars%c13_psnsha_patch(p) = 0._r8
-               !   
-               !endif
-               !if ( use_c14 ) then
-               !   photosyns_vars%c14_psnsun_patch(p) = 0._r8
-               !   photosyns_vars%c14_psnsha_patch(p) = 0._r8
-               !end if
-               
-            end if  ! end initialization of new pft
-         end if  ! weight decreasing
-      end do     ! patch loop
-      
-      !$acc parallel loop independent gang vector default(present) private(p,c,l,g) &
-      !$acc present(conv_flux(:),dwt_froot_to_litter(:), &
-      !$acc dwt_livecroot_to_litter(:),dwt_deadcroot_to_litter(:),prod10_flux(:), prod100_flux(:), &
-      !$acc crop_product_flux(:)      )  
+    end if
+
+    if ( use_c14 ) then
       do fp = 1, num_soilp_with_inactive
-         p = filter_soilp_with_inactive(fp)
-         c = veg_pp%column(p)
-         l = veg_pp%landunit(p)
-         g = veg_pp%gridcell(p) 
-         dwt_leaf_seed   = 0.0_r8
-         dwt_deadstem_seed = 0.0_r8
-         
-         call dyn_veg_cs_Adjustments(    &
+          dwt_leafc14_seed(fp)           = 0._r8
+          dwt_deadstemc14_seed(fp)       = 0._r8
+          dwt_frootc14_to_litter(fp)     = 0._r8
+          dwt_livecrootc14_to_litter(fp) = 0._r8
+          dwt_deadcrootc14_to_litter(fp) = 0._r8
+          conv_c14flux(fp)               = 0._r8
+          prod10_c14flux(fp)             = 0._r8
+          prod100_c14flux(fp)            = 0._r8
+          crop_product_c14flux(fp)       = 0._r8
+        enddo
+    endif
+
+    do fp = 1, num_soilp_with_inactive
+       p = filter_soilp_with_inactive(fp)
+       c = veg_pp%column(p)
+       l = veg_pp%landunit(p)
+       if (.not.(lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) ) Then
+         print *, "istsoil,istcrop",istsoil, istcrop
+         print *, lun_pp%itype(l)
+       end if
+       ! calculate the change in weight for the timestep
+       dwt = veg_pp%wtcol(p)-prior_weights%pwtcol(p)
+       cnstate_vars%lfpftd_patch(p) = -dwt
+
+        ! Patches for which weight increases on this timestep
+        if (dwt > 0._r8) then
+
+          ! first identify Patches that are initiating on this timestep
+          ! and set all the necessary state and flux variables
+          if (prior_weights%pwtcol(p) == 0._r8) then
+
+            ! set initial conditions for PFT that is being initiated
+            ! in this time step.  Based on the settings in cnIniTimeVar.
+
+            ! pft-level carbon state variables
+            call CarbonStateVarsInit     (veg_cs, p)
+            call NitrogenStateVarsInit   (veg_ns, p)
+            call PhosphorusStateVarsInit (veg_ps, p)
+            call CanopyStateVarsInit     (canopystate_vars, p)
+            call CNStateVarsInit         (cnstate_vars, p, c)
+            call CarbonFluxVarsInit      (veg_cf, p)
+            call NitrogenFluxVarsInit    ( p)
+            call PhosphorusFluxVarsInit  ( p)
+
+            if ( use_c13 ) then
+               call CarbonStateVarsInit(c13_veg_cs, p)
+            endif
+
+            if ( use_c14 ) then
+               call CarbonStateVarsInit(c14_veg_cs, p)
+            endif
+
+            ! add phosphorus related variables
+
+            if ( use_c13 ) then
+               photosyns_vars%alphapsnsun_patch(p) = 0._r8
+               photosyns_vars%alphapsnsha_patch(p) = 0._r8
+               photosyns_vars%rc13_canair_patch(p) = 0._r8
+               photosyns_vars%rc13_psnsun_patch(p) = 0._r8
+               photosyns_vars%rc13_psnsha_patch(p) = 0._r8
+               photosyns_vars%c13_psnsun_patch(p) = 0._r8
+               photosyns_vars%c13_psnsha_patch(p) = 0._r8
+
+            endif
+            photosyns_vars%psnsun_patch(p) = 0._r8
+            photosyns_vars%psnsha_patch(p) = 0._r8
+            if ( use_c14 ) then
+               photosyns_vars%c14_psnsun_patch(p) = 0._r8
+               photosyns_vars%c14_psnsha_patch(p) = 0._r8
+            end if
+
+        end if  ! end initialization of new pft
+      end if       ! weight decreasing
+    end do     ! patch loop
+
+    do fp = 1, num_soilp_with_inactive
+       p = filter_soilp_with_inactive(fp)
+       c = veg_pp%column(p)
+       l = veg_pp%landunit(p)
+
+       call dyn_veg_cs_Adjustments(    &
             l, c, p,        &
             prior_weights,                 &
             patch_state_updater,           &
-            dwt_leaf_seed,             &
-            dwt_deadstem_seed,         &
-            conv_flux(fp),                 &
-            dwt_froot_to_litter(fp),       &
-            dwt_livecroot_to_litter(fp),   &
-            dwt_deadcroot_to_litter(fp),   &
-            prod10_flux(fp),               &
-            prod100_flux(fp),              &
-            crop_product_flux(fp),         &
+            dwt_leafc_seed(fp),                &
+            dwt_deadstemc_seed(fp),            &
+            conv_cflux(fp),                    &
+            dwt_frootc_to_litter(fp),          &
+            dwt_livecrootc_to_litter(fp),      &
+            dwt_deadcrootc_to_litter(fp),      &
+            prod10_cflux(fp),                  &
+            prod100_cflux(fp),                 &
+            crop_product_cflux(fp),            &
             veg_cs                         &
             )
-         
-         veg_cf%dwt_seedc_to_leaf(p) = dwt_leaf_seed/dt
-         veg_cf%dwt_seedc_to_deadstem(p) = dwt_deadstem_seed/dt
-         veg_cf%dwt_conv_cflux(p) = -conv_flux(fp)/dt
-         veg_cf%dwt_prod10c_gain(p) = -prod10_flux(fp)/dt
-         veg_cf%dwt_prod100c_gain(p) = - prod100_flux(fp)/dt
-         veg_cf%dwt_crop_productc_gain(p) = - crop_product_flux(fp)/dt
-         
-      end do
-
-      ! Note that patch-level fluxes are stored per unit GRIDCELL area - thus, we don't
-      ! need to multiply by the patch's gridcell weight when translating patch-level
-      ! fluxes into gridcell-level fluxes.
-      ! NOTE: The grc_xf variables are zero'd at the start of each timestep in elm_driver::zero_elm_weights
-      
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3,sum4,sum5)
-      do g = begg, endg 
-         sum1 = 0._r8; sum2 = 0._r8; sum3 = 0._r8 
-         sum4 = 0._r8; sum5 = 0._r8
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5) 
-         do fp = 1, grc_pp%npfts(g)
-            p = grc_pp%pfts(fp,g)
-            l = veg_pp%landunit(p)
-            if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-               sum1 = sum1 + veg_cf%dwt_conv_cflux(p)
-               sum2 = sum2 + veg_cf%dwt_prod10c_gain(p)
-               sum3 = sum3 + veg_cf%dwt_seedc_to_leaf(p)
-               sum4 = sum4 + veg_cf%dwt_prod100c_gain(p)
-               sum5 = sum5 + veg_cf%dwt_seedc_to_deadstem(p)
-            end if 
-         end do 
-         grc_cf%dwt_conv_cflux(g)        = grc_cf%dwt_conv_cflux(g)    + sum1 
-         grc_cf%dwt_prod10c_gain(g)      = grc_cf%dwt_prod10c_gain(g)  + sum2 
-         grc_cf%dwt_seedc_to_leaf(g)     = grc_cf%dwt_seedc_to_leaf(g) + sum3
-         grc_cf%dwt_prod100c_gain(g)     = grc_cf%dwt_prod100c_gain(g) + sum4
-         grc_cf%dwt_seedc_to_deadstem(g) = grc_cf%dwt_seedc_to_deadstem(g) + sum5
-      end do 
-
-      ! calculate pft-to-column for fluxes into litter and CWD pools 
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1,sum2,sum3,sum4,sum5) &
-      !$acc present(dwt_froot_to_litter(:),dwt_livecroot_to_litter(:),dwt_deadcroot_to_litter(:)) 
-      do j = 1, nlevdecomp
-         do fc = 1, num_soilc_with_inactive
-            c = filter_soilc_with_inactive(fc)
-            l = col_pp%landunit(c) 
-            
-            sum1 = 0.0_r8; sum2 = 0.0_r8 
-            sum3 = 0.0_r8; sum4 = 0.0_r8;
-            sum5 = 0.0_r8;
-            !
-            !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5) private(froot,croot,fr_flab,fr_fcel,fr_flig,fp)
-            do p = col_pp%pfti(c), col_pp%pftf(c) 
-               if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-                  fp = patch_to_soil_filter(p)
-                  froot   = cnstate_vars%froot_prof_patch(p,j)
-                  croot   = cnstate_vars%croot_prof_patch(p,j)
-                  fr_flab = veg_vp%fr_flab(veg_pp%itype(p))
-                  fr_fcel = veg_vp%fr_fcel(veg_pp%itype(p))
-                  fr_flig = veg_vp%fr_flig(veg_pp%itype(p))
-                  
-                  ! fine root litter carbon fluxes
-                  sum1 = sum1 + (dwt_froot_to_litter(fp)* fr_flab)/dt * froot
-                  sum2 = sum2 + (dwt_froot_to_litter(fp)* fr_fcel)/dt * froot
-                  sum3 = sum3 + (dwt_froot_to_litter(fp)* fr_flig)/dt * froot
-                  !
-                  sum4 = sum4 + (dwt_livecroot_to_litter(fp))/dt * croot
-                  sum5 = sum5 + (dwt_deadcroot_to_litter(fp))/dt * croot
-               end if 
-            end do 
-            ! 
-            col_cf%dwt_frootc_to_litr_met_c(c,j) = col_cf%dwt_frootc_to_litr_met_c(c,j) + sum1 
-            col_cf%dwt_frootc_to_litr_cel_c(c,j) = col_cf%dwt_frootc_to_litr_cel_c(c,j) + sum2 
-            col_cf%dwt_frootc_to_litr_lig_c(c,j) = col_cf%dwt_frootc_to_litr_lig_c(c,j) + sum3 
-            !
-            col_cf%dwt_livecrootc_to_cwdc(c,j) = col_cf%dwt_livecrootc_to_cwdc(c,j) + sum4
-            !
-            col_cf%dwt_deadcrootc_to_cwdc(c,j) = col_cf%dwt_deadcrootc_to_cwdc(c,j) + sum5 
-         end do 
-      end do 
-      
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3,sum4,sum5) &
-      !$acc present(dwt_froot_to_litter(:),dwt_livecroot_to_litter(:),dwt_deadcroot_to_litter(:),&
-      !$acc  conv_flux(:), crop_product_flux(:), prod10_flux(:),prod100_flux(:)) 
-      do fc = 1, num_soilc_with_inactive 
-         c = filter_soilc_with_inactive(fc) 
-         l = col_pp%landunit(c) 
-         sum1 = 0.0_r8; sum2 = 0.0_r8; 
-         sum3 = 0.0_r8; sum4 = 0.0_r8 
-         sum5 = 0.0_r8;
-         
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5) private(fp)
-         do p = col_pp%pfti(c), col_pp%pftf(c) 
-            if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-               fp = patch_to_soil_filter(p)
-               ! column-level fluxes are accumulated as positive fluxes.
-               ! column-level C flux updates
-               sum1 = sum1 - prod10_flux(fp)/dt
-               sum2 = sum2 - prod100_flux(fp)/dt
-               sum3 = sum3 - crop_product_flux(fp)/dt
-               sum4 = sum4 - conv_flux(fp)/dt
-               sum5 = sum5 + dwt_froot_to_litter(fp)/dt + dwt_livecroot_to_litter(fp)/dt + dwt_deadcroot_to_litter(fp)/dt
-               
-            endif 
-         end do 
-         col_cf%dwt_prod10c_gain(c) = col_cf%dwt_prod10c_gain(c) + sum1
-         col_cf%dwt_prod100c_gain(c)= col_cf%dwt_prod100c_gain(c)+ sum2
-         col_cf%dwt_crop_productc_gain(c) = col_cf%dwt_crop_productc_gain(c) + sum3 
-         col_cf%dwt_conv_cflux(c) = col_cf%dwt_conv_cflux(c) + sum4 
-         col_cf%dwt_slash_cflux(c) = col_cf%dwt_slash_cflux(c) + sum5 
-      end do 
-      
-      !$acc parallel loop independent gang vector default(present)
+
+    enddo
+
+    if (use_c13) then
       do fp = 1, num_soilp_with_inactive
          p = filter_soilp_with_inactive(fp)
          c = veg_pp%column(p)
          l = veg_pp%landunit(p)
-         dwt_leaf_seed   = 0.0_r8
-         dwt_deadstem_seed = 0.0_r8
-         dwt_pool_seed = 0._r8
-         call dyn_veg_ns_Adjustments(    &
+         call dyn_veg_cs_Adjustments( &
+              l, c, p,        &
+              prior_weights,                 &
+              patch_state_updater,           &
+              dwt_leafc13_seed(fp),              &
+              dwt_deadstemc13_seed(fp),          &
+              conv_c13flux(fp),                  &
+              dwt_frootc13_to_litter(fp),        &
+              dwt_livecrootc13_to_litter(fp),    &
+              dwt_deadcrootc13_to_litter(fp),    &
+              prod10_c13flux(fp),                &
+              prod100_c13flux(fp),               &
+              crop_product_c13flux(fp),          &
+              c13_veg_cs                     &
+              )
+      enddo
+    endif
+
+    if (use_c14) then
+      do fp = 1, num_soilp_with_inactive
+         p = filter_soilp_with_inactive(fp)
+         c = veg_pp%column(p)
+         l = veg_pp%landunit(p)
+         call dyn_veg_cs_Adjustments( &
+              l, c, p,        &
+              prior_weights,                 &
+              patch_state_updater,           &
+              dwt_leafc14_seed(fp),              &
+              dwt_deadstemc14_seed(fp),          &
+              conv_c14flux(fp),                  &
+              dwt_frootc14_to_litter(fp),        &
+              dwt_livecrootc14_to_litter(fp),    &
+              dwt_deadcrootc14_to_litter(fp),    &
+              prod10_c14flux(fp),                &
+              prod100_c14flux(fp),               &
+              crop_product_c14flux(fp),          &
+              c14_veg_cs                     &
+            )
+      enddo
+    endif
+
+
+    do fp = 1, num_soilp_with_inactive
+       p = filter_soilp_with_inactive(fp)
+       c = veg_pp%column(p)
+       l = veg_pp%landunit(p)
+       call dyn_veg_ns_Adjustments(    &
             l,c,p,              &
             prior_weights,                 &
             patch_state_updater,           &
-            dwt_leaf_seed,             &
-            dwt_deadstem_seed,         &
-            dwt_pool_seed,             &
-            conv_flux(fp),                 &
-            dwt_froot_to_litter(fp),       &
-            dwt_livecroot_to_litter(fp),   &
-            dwt_deadcroot_to_litter(fp),   &
-            prod10_flux(fp),               &
-            prod100_flux(fp),              &
-            crop_product_flux(fp),         &
+            dwt_leafn_seed(fp),             &
+            dwt_deadstemn_seed(fp),         &
+            dwt_npool_seed(fp),             &
+            conv_nflux(fp),                 &
+            dwt_frootn_to_litter(fp),       &
+            dwt_livecrootn_to_litter(fp),   &
+            dwt_deadcrootn_to_litter(fp),   &
+            prod10_nflux(fp),               &
+            prod100_nflux(fp),              &
+            crop_product_nflux(fp),         &
             veg_ns                         &
             )
-         
-         veg_nf%dwt_seedn_to_leaf(p)  = dwt_leaf_seed/dt
-         veg_nf%dwt_seedn_to_deadstem(p) = dwt_deadstem_seed/dt
-         veg_nf%dwt_seedn_to_npool(p) = dwt_pool_seed/dt
-         veg_nf%dwt_conv_nflux(p) = -conv_flux(fp)/dt
-         veg_nf%dwt_prod10n_gain(p) = -prod10_flux(fp)/dt
-         veg_nf%dwt_prod100n_gain(p)= -prod100_flux(fp)/dt
-         veg_nf%dwt_crop_productn_gain(p) = -crop_product_flux(fp)/dt
-      enddo
+    enddo
+
+    do fp = 1, num_soilp_with_inactive
+       p = filter_soilp_with_inactive(fp)
+       c = veg_pp%column(p)
+       l = veg_pp%landunit(p)
+       call dyn_veg_ps_Adjustments(    &
+           l,c,p,                  &
+           prior_weights,                 &
+           patch_state_updater,           &
+           dwt_leafp_seed(fp),            &
+           dwt_deadstemp_seed(fp),        &
+           dwt_ppool_seed(fp),            &
+           conv_pflux(fp),                &
+           dwt_frootp_to_litter(fp),      &
+           dwt_livecrootp_to_litter(fp),  &
+           dwt_deadcrootp_to_litter(fp),  &
+           prod10_pflux(fp),              &
+           prod100_pflux(fp),             &
+           crop_product_pflux(fp),        &
+           veg_ps                         &
+           )
+    end do
 
-      ! NOTE: The grc_xf variables are zero'd at the start of each timestep in elm_driver::zero_elm_weights
-      !$acc parallel loop independent gang worker default(present) private(sum1)
-      do g = begg, endg 
-         sum1 = 0._r8; sum2 = 0._r8; sum3 = 0._r8 
-         sum4 = 0._r8; sum5 = 0._r8; sum_seed2pool = 0._r8
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5,sum_seed2pool) 
-         do fp = 1, grc_pp%npfts(g)
-            p = grc_pp%pfts(fp,g)
-            l = veg_pp%landunit(p)
-
-            if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-               sum1 = sum1 + veg_nf%dwt_conv_nflux(p)
-               sum2 = sum2 + veg_nf%dwt_prod10n_gain(p)
-               sum3 = sum3 + veg_nf%dwt_seedn_to_leaf(p)
-               sum4 = sum4 + veg_nf%dwt_prod100n_gain(p)
-               sum5 = sum5 + veg_nf%dwt_seedn_to_deadstem(p)
-               sum_seed2pool = sum_seed2pool + veg_nf%dwt_seedn_to_npool(p)
-            end if 
-         end do 
-         grc_nf%dwt_conv_nflux(g)        = grc_nf%dwt_conv_nflux(g)    + sum1 
-         grc_nf%dwt_prod10n_gain(g)      = grc_nf%dwt_prod10n_gain(g)  + sum2 
-         grc_nf%dwt_prod100n_gain(g)     = grc_nf%dwt_prod100n_gain(g) + sum4
-         grc_nf%dwt_seedn_to_leaf(g)     = grc_nf%dwt_seedn_to_leaf(g) + sum3
-         grc_nf%dwt_seedn_to_npool(g)    = grc_nf%dwt_seedn_to_npool(g) + sum_seed2pool
-         grc_nf%dwt_seedn_to_deadstem(g) = grc_nf%dwt_seedn_to_deadstem(g) + sum5
-      end do 
-      
-      ! calculate pft-to-column for fluxes into litter and CWD pools 
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1,sum2,sum3,sum4,sum5,c,l) &
-      !$acc present(dwt_froot_to_litter(:),dwt_livecroot_to_litter(:),dwt_deadcroot_to_litter(:)) 
-      do j = 1, nlevdecomp
-         do fc = 1, num_soilc_with_inactive
-            c = filter_soilc_with_inactive(fc)
-            l = col_pp%landunit(c) 
-            
-            sum1 = 0.0_r8
-            sum2 = 0.0_r8 
-            sum3 = 0.0_r8 
-            sum4 = 0.0_r8 
-            sum5 = 0.0_r8 
-            
-            !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5) private(froot,croot,fr_flab,fr_fcel,fr_flig,fp)
-            do p = col_pp%pfti(c), col_pp%pftf(c) 
-               if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-                  fp = patch_to_soil_filter(p)
-
-                  froot   = cnstate_vars%froot_prof_patch(p,j)
-                  croot   = cnstate_vars%croot_prof_patch(p,j)
-                  fr_flab = veg_vp%fr_flab(veg_pp%itype(p))
-                  fr_fcel = veg_vp%fr_fcel(veg_pp%itype(p))
-                  fr_flig = veg_vp%fr_flig(veg_pp%itype(p))
-                  
-                  ! fine root litter carbon fluxes
-                  sum1 = sum1 + (dwt_froot_to_litter(fp)* fr_flab)/dt * froot
-                  sum2 = sum2 + (dwt_froot_to_litter(fp)* fr_fcel)/dt * froot
-                  sum3 = sum3 + (dwt_froot_to_litter(fp)* fr_flig)/dt * froot
-                  
-                  ! livecroot fluxes to cwd
-                  sum4 = sum4 + (dwt_livecroot_to_litter(fp))/dt * croot
-                  ! 
-                  sum5 = sum5 + (dwt_deadcroot_to_litter(fp))/dt * croot
-               end if 
-            end do 
-            ! 
-            col_nf%dwt_frootn_to_litr_met_n(c,j) = col_nf%dwt_frootn_to_litr_met_n(c,j) + sum1 
-            col_nf%dwt_frootn_to_litr_cel_n(c,j) = col_nf%dwt_frootn_to_litr_cel_n(c,j) + sum2 
-            col_nf%dwt_frootn_to_litr_lig_n(c,j) = col_nf%dwt_frootn_to_litr_lig_n(c,j) + sum3 
-            ! 
-            col_nf%dwt_livecrootn_to_cwdn(c,j)   = col_nf%dwt_livecrootn_to_cwdn(c,j) + sum4 
-            !
-            col_nf%dwt_deadcrootn_to_cwdn(c,j) = col_nf%dwt_deadcrootn_to_cwdn(c,j) + sum5 
-         end do 
-      end do 
-      
-      !$acc parallel loop independent gang worker default(present) private(c,l,sum1,sum2,sum3,sum4,sum5) &
-      !$acc present(dwt_froot_to_litter(:),dwt_livecroot_to_litter(:),dwt_deadcroot_to_litter(:),&
-      !$acc  conv_flux(:), crop_product_flux(:), prod10_flux(:),prod100_flux(:))
-      do fc = 1, num_soilc_with_inactive 
-         c = filter_soilc_with_inactive(fc) 
-         l = col_pp%landunit(c) 
-         sum1 = 0.0_r8; sum2 = 0.0_r8; 
-         sum3 = 0.0_r8; sum4 = 0.0_r8 
-         sum5 = 0.0_r8;
-         
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5) private(fp)
-         do p = col_pp%pfti(c), col_pp%pftf(c) 
-            if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-               ! column-level fluxes are accumulated as positive fluxes.
-               ! column-level C flux updates
-               fp = patch_to_soil_filter(p)
-
-               sum1 = sum1 - prod10_flux(fp)/dt
-               sum2 = sum2 - prod100_flux(fp)/dt
-               sum3 = sum3 - crop_product_flux(fp)/dt
-               sum4 = sum4 - conv_flux(fp)/dt
-               sum5 = sum5 + dwt_froot_to_litter(fp)/dt + &
-               dwt_livecroot_to_litter(fp)/dt + &
-               dwt_deadcroot_to_litter(fp)/dt
-               
-            endif 
-         end do 
-         col_nf%dwt_prod10n_gain(c)  = col_nf%dwt_prod10n_gain(c) + sum1
-         col_nf%dwt_prod100n_gain(c) = col_nf%dwt_prod100n_gain(c)+ sum2
-         col_nf%dwt_crop_productn_gain(c) = col_nf%dwt_crop_productn_gain(c) + sum3 
-         col_nf%dwt_conv_nflux(c)  = col_nf%dwt_conv_nflux(c) + sum4 
-         col_nf%dwt_slash_nflux(c) = col_nf%dwt_slash_nflux(c) + sum5 
-      end do 
-      
-      !$acc parallel loop independent gang vector default(present) private(p,c,l)
+    ! calculate column-level seeding fluxes
+    do fp = 1, num_soilp_with_inactive
+       p = filter_soilp_with_inactive(fp)
+       g = veg_pp%gridcell(p)
+
+       ! C fluxes
+       veg_cf%dwt_seedc_to_leaf(p) = dwt_leafc_seed(fp)/dt
+       grc_cf%dwt_seedc_to_leaf(g)   = &
+            grc_cf%dwt_seedc_to_leaf(g) + &
+            veg_cf%dwt_seedc_to_leaf(p)
+
+       veg_cf%dwt_seedc_to_deadstem(p) = dwt_deadstemc_seed(fp)/dt
+       grc_cf%dwt_seedc_to_deadstem(g)   = &
+            grc_cf%dwt_seedc_to_deadstem(g) + &
+            veg_cf%dwt_seedc_to_deadstem(p)
+
+       if ( use_c13 ) then
+          c13_veg_cf%dwt_seedc_to_leaf(p) = dwt_leafc_seed(fp)/dt
+          c13_grc_cf%dwt_seedc_to_leaf(g)   = &
+               c13_grc_cf%dwt_seedc_to_leaf(g) + &
+               c13_veg_cf%dwt_seedc_to_leaf(p)
+
+          c13_veg_cf%dwt_seedc_to_deadstem(p) = dwt_deadstemc_seed(fp)/dt
+          c13_grc_cf%dwt_seedc_to_deadstem(g)   = &
+               c13_grc_cf%dwt_seedc_to_deadstem(g) + &
+               c13_veg_cf%dwt_seedc_to_deadstem(p)
+       endif
+
+       if ( use_c14 ) then
+          c14_veg_cf%dwt_seedc_to_leaf(p) = dwt_leafc_seed(fp)/dt
+          c14_grc_cf%dwt_seedc_to_leaf(g)   = &
+               c14_grc_cf%dwt_seedc_to_leaf(g) + &
+               c14_veg_cf%dwt_seedc_to_leaf(p)
+
+          c14_veg_cf%dwt_seedc_to_deadstem(p) = dwt_deadstemc_seed(fp)/dt
+          c14_grc_cf%dwt_seedc_to_deadstem(g)   = &
+               c14_grc_cf%dwt_seedc_to_deadstem(g) + &
+               c14_veg_cf%dwt_seedc_to_deadstem(p)
+       endif
+
+       ! N fluxes
+       veg_nf%dwt_seedn_to_leaf(p)   = dwt_leafn_seed(fp)/dt
+       grc_nf%dwt_seedn_to_leaf(g)     = &
+            grc_nf%dwt_seedn_to_leaf(g) + &
+            veg_nf%dwt_seedn_to_leaf(p)
+
+       veg_nf%dwt_seedn_to_deadstem(p) = dwt_deadstemn_seed(fp)/dt
+       grc_nf%dwt_seedn_to_deadstem(g)   = &
+            grc_nf%dwt_seedn_to_deadstem(g) + &
+            veg_nf%dwt_seedn_to_deadstem(p)
+
+
+       veg_nf%dwt_seedn_to_npool(p) = dwt_npool_seed(fp)/dt
+       grc_nf%dwt_seedn_to_npool(g)   = &
+            grc_nf%dwt_seedn_to_npool(g) + &
+            veg_nf%dwt_seedn_to_npool(p)
+
+       ! P fluxes
+       veg_pf%dwt_seedp_to_leaf(p)   = dwt_leafp_seed(fp)/dt
+       grc_pf%dwt_seedp_to_leaf(g)     = &
+            grc_pf%dwt_seedp_to_leaf(g) + &
+            veg_pf%dwt_seedp_to_leaf(p)
+
+       veg_pf%dwt_seedp_to_deadstem(p) = dwt_deadstemp_seed(fp)/dt
+       grc_pf%dwt_seedp_to_deadstem(g)   = &
+            grc_pf%dwt_seedp_to_deadstem(g) + &
+            veg_pf%dwt_seedp_to_deadstem(p)
+
+
+       veg_pf%dwt_seedp_to_ppool(p) = dwt_npool_seed(fp)/dt
+       grc_pf%dwt_seedp_to_ppool(g)   = &
+            grc_pf%dwt_seedp_to_ppool(g) + &
+            veg_pf%dwt_seedp_to_ppool(p)
+
+    end do
+
+    ! calculate patch-to-column slash fluxes into litter and CWD pools
+    do fp = 1, num_soilp_with_inactive
+       p = filter_soilp_with_inactive(fp)
+       c = veg_pp%column(p)
+
+       ! fine and coarse root to litter and CWD slash carbon fluxes
+       col_cf%dwt_slash_cflux(c) =            &
+            col_cf%dwt_slash_cflux(c)       + &
+            dwt_frootc_to_litter(fp)     /dt + &
+            dwt_livecrootc_to_litter(fp) /dt + &
+            dwt_deadcrootc_to_litter(fp) /dt
+
+       if ( use_c13 ) then
+          c13_col_cf%dwt_slash_cflux(c) =          &
+               c13_col_cf%dwt_slash_cflux(c)     + &
+               dwt_frootc13_to_litter(fp)     /dt + &
+               dwt_livecrootc13_to_litter(fp) /dt + &
+               dwt_deadcrootc13_to_litter(fp) /dt
+       endif
+
+       if ( use_c14 ) then
+          c14_col_cf%dwt_slash_cflux(c) =          &
+               c14_col_cf%dwt_slash_cflux(c)     + &
+               dwt_frootc14_to_litter(fp)     /dt + &
+               dwt_livecrootc14_to_litter(fp) /dt + &
+               dwt_deadcrootc14_to_litter(fp) /dt
+       endif
+
+       col_nf%dwt_slash_nflux(c) =            &
+            col_nf%dwt_slash_nflux(c)       + &
+            dwt_frootn_to_litter(fp)     /dt + &
+            dwt_livecrootn_to_litter(fp) /dt + &
+            dwt_deadcrootn_to_litter(fp) /dt
+
+       col_pf%dwt_slash_pflux(c) =            &
+            col_pf%dwt_slash_pflux(c)       + &
+            dwt_frootp_to_litter(fp)     /dt + &
+            dwt_livecrootp_to_litter(fp) /dt + &
+            dwt_deadcrootp_to_litter(fp) /dt
+
+    end do
+
+    ! calculate pft-to-column for fluxes into litter and CWD pools
+    do j = 1, nlevdecomp
       do fp = 1, num_soilp_with_inactive
          p = filter_soilp_with_inactive(fp)
          c = veg_pp%column(p)
-         l = veg_pp%landunit(p)
-         dwt_leaf_seed   = 0.0_r8
-         dwt_deadstem_seed = 0.0_r8
-         dwt_pool_seed = 0._r8
-         
-         call dyn_veg_ps_Adjustments( &
-         l,c,p,                  &
-         prior_weights,                &
-         patch_state_updater,          &
-         dwt_leaf_seed,            &
-         dwt_deadstem_seed,        &
-         dwt_pool_seed,            &
-         conv_flux(fp),                &
-         dwt_froot_to_litter(fp),      &
-         dwt_livecroot_to_litter(fp),  &
-         dwt_deadcroot_to_litter(fp),  &
-         prod10_flux(fp),              &
-         prod100_flux(fp),             &
-         crop_product_flux(fp),        &
-         veg_ps                        &
-         )
-         
-         ! P fluxes
-         veg_pf%dwt_seedp_to_leaf(p)   = dwt_leaf_seed/dt
-         veg_pf%dwt_seedp_to_ppool(p) = dwt_pool_seed/dt
-         veg_pf%dwt_seedp_to_deadstem(p) = dwt_deadstem_seed/dt
-         veg_pf%dwt_conv_pflux(p) = -conv_flux(fp)/dt
-         veg_pf%dwt_prod10p_gain(p)  = -prod10_flux(fp)/dt
-         veg_pf%dwt_prod100p_gain(p) = -prod100_flux(fp)/dt
-         veg_pf%dwt_crop_productp_gain(p) = -crop_product_flux(fp)/dt
-      end do
-
-      ! NOTE: The grc_xf variables are zero'd at the start of each timestep in elm_driver::zero_elm_weights
-      !$acc parallel loop independent gang worker default(present) private(sum1)
-      do g = begg, endg 
-         sum1 = 0._r8; sum2 = 0._r8; sum3 = 0._r8 
-         sum4 = 0._r8; sum5 = 0._r8; sum_seed2pool = 0._r8
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5,sum_seed2pool) 
-         do fp = 1, grc_pp%npfts(g)
-            p = grc_pp%pfts(fp,g)
-            l = veg_pp%landunit(p)
-            if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-               sum1 = sum1 + veg_pf%dwt_conv_pflux(p)
-               sum2 = sum2 + veg_pf%dwt_prod10p_gain(p)
-               sum3 = sum3 + veg_pf%dwt_seedp_to_leaf(p)
-               sum4 = sum4 + veg_pf%dwt_prod100p_gain(p)
-               sum5 = sum5 + veg_pf%dwt_seedp_to_deadstem(p)
-               sum_seed2pool = sum_seed2pool + veg_pf%dwt_seedp_to_ppool(p)
-            end if 
-         end do 
-         grc_pf%dwt_conv_pflux(g)        = grc_pf%dwt_conv_pflux(g)    + sum1 
-         grc_pf%dwt_prod10p_gain(g)      = grc_pf%dwt_prod10p_gain(g)  + sum2 
-         grc_pf%dwt_prod100p_gain(g)     = grc_pf%dwt_prod100p_gain(g) + sum4
-         grc_pf%dwt_seedp_to_leaf(g)     = grc_pf%dwt_seedp_to_leaf(g) + sum3
-         grc_pf%dwt_seedp_to_ppool(g)    = grc_pf%dwt_seedp_to_ppool(g) + sum_seed2pool
-         grc_pf%dwt_seedp_to_deadstem(g) = grc_pf%dwt_seedp_to_deadstem(g) + sum5
-      end do 
-
-      ! calculate pft-to-column for fluxes into litter and CWD pools 
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1,sum2,sum3,sum4,sum5,c,l) &
-      !$acc present(dwt_froot_to_litter(:),dwt_livecroot_to_litter(:),dwt_deadcroot_to_litter(:) )
-      do j = 1, nlevdecomp
-         do fc = 1, num_soilc_with_inactive
-            c = filter_soilc_with_inactive(fc)
-            l = col_pp%landunit(c) 
-
-            sum1 = 0.0_r8; sum2 = 0.0_r8 
-            sum3 = 0.0_r8; sum4 = 0.0_r8 
-            sum5 = 0.0_r8 
-            
-            !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5) private(froot,croot,fr_flab,fr_fcel,fr_flig,fp)
-            do p = col_pp%pfti(c), col_pp%pftf(c) 
-               if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-                  fp = patch_to_soil_filter(p)
-                  froot   = cnstate_vars%froot_prof_patch(p,j)
-                  croot   = cnstate_vars%croot_prof_patch(p,j)
-                  fr_flab = veg_vp%fr_flab(veg_pp%itype(p))
-                  fr_fcel = veg_vp%fr_fcel(veg_pp%itype(p))
-                  fr_flig = veg_vp%fr_flig(veg_pp%itype(p))
-                  ! fine root litter carbon fluxes
-                  sum1 = sum1 + (dwt_froot_to_litter(fp)* fr_flab)/dt * froot
-                  sum2 = sum2 + (dwt_froot_to_litter(fp)* fr_fcel)/dt * froot
-                  sum3 = sum3 + (dwt_froot_to_litter(fp)* fr_flig)/dt * froot
-                  ! livecroot fluxes to cwd
-                  sum4 = sum4 + (dwt_livecroot_to_litter(fp))/dt * croot
-                  sum5 = sum5 + (dwt_deadcroot_to_litter(fp))/dt * croot
-               end if 
-            end do 
-            col_pf%dwt_frootp_to_litr_met_p(c,j) = col_pf%dwt_frootp_to_litr_met_p(c,j) + sum1 
-            col_pf%dwt_frootp_to_litr_cel_p(c,j) = col_pf%dwt_frootp_to_litr_cel_p(c,j) + sum2 
-            col_pf%dwt_frootp_to_litr_lig_p(c,j) = col_pf%dwt_frootp_to_litr_lig_p(c,j) + sum3 
-            ! 
-            col_pf%dwt_livecrootp_to_cwdp(c,j) = col_pf%dwt_livecrootp_to_cwdp(c,j) + sum4 
-            col_pf%dwt_deadcrootp_to_cwdp(c,j) = col_pf%dwt_deadcrootp_to_cwdp(c,j) + sum5 
-         end do 
-      end do 
-      
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3,sum4,sum5,c,l) &
-      !$acc present(dwt_froot_to_litter(:),dwt_livecroot_to_litter(:),dwt_deadcroot_to_litter(:),&
-      !$acc  conv_flux(:), crop_product_flux(:), prod10_flux(:),prod100_flux(:))
-      do fc = 1, num_soilc_with_inactive 
-         c = filter_soilc_with_inactive(fc) 
-         l = col_pp%landunit(c) 
-         sum1 = 0.0_r8; sum2 = 0.0_r8; 
-         sum3 = 0.0_r8; sum4 = 0.0_r8 
-         sum5 = 0.0_r8;
-         
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5) private(fp)
-         do p = col_pp%pfti(c), col_pp%pftf(c) 
-            if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-               ! column-level fluxes are accumulated as positive fluxes.
-               ! column-level C flux updates
-               fp = patch_to_soil_filter(p)
-               
-               sum1 = sum1 - prod10_flux(fp)/dt
-               sum2 = sum2 - prod100_flux(fp)/dt
-               sum3 = sum3 - crop_product_flux(fp)/dt
-               sum4 = sum4 - conv_flux(fp)/dt
-               sum5 = sum5 + dwt_froot_to_litter(fp)/dt + &
-                           dwt_livecroot_to_litter(fp)/dt + &
-                           dwt_deadcroot_to_litter(fp)/dt
-               
-            endif 
-         end do 
-         col_pf%dwt_prod10p_gain(c) = col_pf%dwt_prod10p_gain(c) + sum1
-         col_pf%dwt_prod100p_gain(c)= col_pf%dwt_prod100p_gain(c)+ sum2
-         col_pf%dwt_crop_productp_gain(c) = col_pf%dwt_crop_productp_gain(c) + sum3 
-         col_pf%dwt_conv_pflux(c) = col_pf%dwt_conv_pflux(c) + sum4 
-         col_pf%dwt_slash_pflux(c) = col_pf%dwt_slash_pflux(c) + sum5 
-      end do 
-      
-      !$acc exit data delete( &
-      !$acc dwt_froot_to_litter(:) ,&
-      !$acc dwt_livecroot_to_litter(:),&
-      !$acc dwt_deadcroot_to_litter(:),&
-      !$acc conv_flux(:)              ,&
-      !$acc prod10_flux(:)            ,&
-      !$acc prod100_flux(:)           ,&
-      !$acc crop_product_flux(:)      ,&
-      !$acc  patch_to_soil_filter(:)  )
-      !$acc exit data delete(sum1,sum2,sum3,sum4,sum5,sum_seed2pool)  
-      ! Deallocate pft-level flux arrays
-      if ( use_c13 ) then
-         deallocate(dwt_leafc13_seed)
-         deallocate(dwt_deadstemc13_seed)
-         deallocate(dwt_frootc13_to_litter)
-         deallocate(dwt_livecrootc13_to_litter)
-         deallocate(dwt_deadcrootc13_to_litter)
-         deallocate(conv_c13flux)
-         deallocate(prod10_c13flux)
-         deallocate(prod100_c13flux)
-         deallocate(crop_product_c13flux)
-      endif
-      
-      if ( use_c14 ) then
-         deallocate(dwt_leafc14_seed)
-         deallocate(dwt_deadstemc14_seed)
-         deallocate(dwt_frootc14_to_litter)
-         deallocate(dwt_livecrootc14_to_litter)
-         deallocate(dwt_deadcrootc14_to_litter)
-         deallocate(conv_c14flux)
-         deallocate(prod10_c14flux)
-         deallocate(prod100_c14flux)
-         deallocate(crop_product_c14flux)
-      endif
-      
-   end subroutine dyn_cnbal_patch
-   
-   !-----------------------------------------------------------------------
-   subroutine CarbonStateVarsInit(cs, p)
-      !
-      ! !DESCRIPTION:
-      ! Initializes p-th patch of carbonstate_type
-      !
-      !$acc routine seq 
-      implicit none
-      !
-      ! !ARGUMENT
-      type(vegetation_carbon_state), intent(inout) :: cs
-      integer                    , intent(in)    :: p
-      
-      cs%leafc(p)              = 0._r8
-      cs%leafc_storage(p)      = 0._r8
-      cs%leafc_xfer(p)         = 0._r8
-      cs%frootc(p)             = 0._r8
-      cs%frootc_storage(p)     = 0._r8
-      cs%frootc_xfer(p)        = 0._r8
-      cs%livestemc(p)          = 0._r8
-      cs%livestemc_storage(p)  = 0._r8
-      cs%livestemc_xfer(p)     = 0._r8
-      cs%deadstemc(p)          = 0._r8
-      cs%deadstemc_storage(p)  = 0._r8
-      cs%deadstemc_xfer(p)     = 0._r8
-      cs%livecrootc(p)         = 0._r8
-      cs%livecrootc_storage(p) = 0._r8
-      cs%livecrootc_xfer(p)    = 0._r8
-      cs%deadcrootc(p)         = 0._r8
-      cs%deadcrootc_storage(p) = 0._r8
-      cs%deadcrootc_xfer(p)    = 0._r8
-      cs%gresp_storage(p)      = 0._r8
-      cs%gresp_xfer(p)         = 0._r8
-      cs%cpool(p)              = 0._r8
-      cs%xsmrpool(p)           = 0._r8
-      cs%ctrunc(p)             = 0._r8
-      cs%dispvegc(p)           = 0._r8
-      cs%storvegc(p)           = 0._r8
-      cs%totvegc(p)            = 0._r8
-      cs%totpftc(p)            = 0._r8
-      
-   end subroutine CarbonStateVarsInit
-   
-   !-----------------------------------------------------------------------
-   subroutine NitrogenStateVarsInit(veg_ns, p)
-      !
-      ! !DESCRIPTION:
-      ! Initializes p-th patch of nitrogenstate_type
-      !
-      !$acc routine seq 
-      implicit none
-      !
-      ! !ARGUMENT
-      type(vegetation_nitrogen_state), intent(inout) :: veg_ns
-      integer                 , intent(in)    :: p
-      
-      veg_ns%leafn(p)              = 0._r8
-      veg_ns%leafn_storage(p)      = 0._r8
-      veg_ns%leafn_xfer(p)         = 0._r8
-      veg_ns%frootn(p)             = 0._r8
-      veg_ns%frootn_storage(p)     = 0._r8
-      veg_ns%frootn_xfer(p)        = 0._r8
-      veg_ns%livestemn(p)          = 0._r8
-      veg_ns%livestemn_storage(p)  = 0._r8
-      veg_ns%livestemn_xfer(p)     = 0._r8
-      veg_ns%deadstemn(p)          = 0._r8
-      veg_ns%deadstemn_storage(p)  = 0._r8
-      veg_ns%deadstemn_xfer(p)     = 0._r8
-      veg_ns%livecrootn(p)         = 0._r8
-      veg_ns%livecrootn_storage(p) = 0._r8
-      veg_ns%livecrootn_xfer(p)    = 0._r8
-      veg_ns%deadcrootn(p)         = 0._r8
-      veg_ns%deadcrootn_storage(p) = 0._r8
-      veg_ns%deadcrootn_xfer(p)    = 0._r8
-      veg_ns%retransn(p)           = 0._r8
-      veg_ns%npool(p)              = 0._r8
-      veg_ns%ntrunc(p)             = 0._r8
-      veg_ns%dispvegn(p)           = 0._r8
-      veg_ns%storvegn(p)           = 0._r8
-      veg_ns%totvegn(p)            = 0._r8
-      veg_ns%totpftn(p)            = 0._r8
-      
-   end subroutine NitrogenStateVarsInit
-   
-   !-----------------------------------------------------------------------
-   subroutine PhosphorusStateVarsInit(veg_ps, p)
-      !
-      ! !DESCRIPTION:
-      ! Initializes p-th patch of phosphorusstate_type
-      !
-      !$acc routine seq 
-      implicit none
-      !
-      ! !ARGUMENT
-      type(vegetation_phosphorus_state), intent(inout) :: veg_ps
-      integer                   , intent(in)    :: p
-      
-      veg_ps%leafp(p)              = 0._r8
-      veg_ps%leafp_storage(p)      = 0._r8
-      veg_ps%leafp_xfer(p)         = 0._r8
-      veg_ps%frootp(p)             = 0._r8
-      veg_ps%frootp_storage(p)     = 0._r8
-      veg_ps%frootp_xfer(p)        = 0._r8
-      veg_ps%livestemp(p)          = 0._r8
-      veg_ps%livestemp_storage(p)  = 0._r8
-      veg_ps%livestemp_xfer(p)     = 0._r8
-      veg_ps%deadstemp(p)          = 0._r8
-      veg_ps%deadstemp_storage(p)  = 0._r8
-      veg_ps%deadstemp_xfer(p)     = 0._r8
-      veg_ps%livecrootp(p)         = 0._r8
-      veg_ps%livecrootp_storage(p) = 0._r8
-      veg_ps%livecrootp_xfer(p)    = 0._r8
-      veg_ps%deadcrootp(p)         = 0._r8
-      veg_ps%deadcrootp_storage(p) = 0._r8
-      veg_ps%deadcrootp_xfer(p)    = 0._r8
-      veg_ps%retransp(p)           = 0._r8
-      veg_ps%ppool(p)              = 0._r8
-      veg_ps%ptrunc(p)             = 0._r8
-      veg_ps%dispvegp(p)           = 0._r8
-      veg_ps%storvegp(p)           = 0._r8
-      veg_ps%totvegp(p)            = 0._r8
-      veg_ps%totpftp (p)           = 0._r8
-      
-   end subroutine PhosphorusStateVarsInit
-   
-   !-----------------------------------------------------------------------
-   subroutine CanopyStateVarsInit(canopystate_vars, p)
-      !
-      ! !DESCRIPTION:
-      ! Initializes p-th patch of canopystate_type
-      !
-      !$acc routine seq 
-      implicit none
-      !
-      ! !ARGUMENT
-      type(canopystate_type), intent(inout) :: canopystate_vars
-      integer               , intent(in)    :: p
-      
-      canopystate_vars%laisun_patch(p) = 0._r8
-      canopystate_vars%laisha_patch(p) = 0._r8
-      
-   end subroutine CanopyStateVarsInit
-   
-   !-----------------------------------------------------------------------
-   subroutine CNStateVarsInit(cnstate_vars, p, c)
-      !
-      ! !DESCRIPTION:
-      ! Initializes p-th patch of cnstate_type
-      !
-      !$acc routine seq 
-      use elm_varcon, only : c14ratio
-      implicit none
-      !
-      ! !ARGUMENT
-      type(cnstate_type), intent(inout) :: cnstate_vars
-      integer           , intent(in)    :: p
-      integer           , intent(in)    :: c
-      
-      cnstate_vars%dormant_flag_patch(p)          = 1._r8
-      cnstate_vars%days_active_patch(p)           = 0._r8
-      cnstate_vars%onset_flag_patch(p)            = 0._r8
-      cnstate_vars%onset_counter_patch(p)         = 0._r8
-      cnstate_vars%onset_gddflag_patch(p)         = 0._r8
-      cnstate_vars%onset_fdd_patch(p)             = 0._r8
-      cnstate_vars%onset_gdd_patch(p)             = 0._r8
-      cnstate_vars%onset_swi_patch(p)             = 0._r8
-      cnstate_vars%offset_flag_patch(p)           = 0._r8
-      cnstate_vars%offset_counter_patch(p)        = 0._r8
-      cnstate_vars%offset_fdd_patch(p)            = 0._r8
-      cnstate_vars%offset_swi_patch(p)            = 0._r8
-      cnstate_vars%lgsf_patch(p)                  = 0._r8
-      cnstate_vars%bglfr_patch(p)                 = 0._r8
-      cnstate_vars%bglfr_leaf_patch(p)            = 0._r8
-      cnstate_vars%bglfr_froot_patch(p)           = 0._r8
-      cnstate_vars%bgtr_patch(p)                  = 0._r8
-      cnstate_vars%annavg_t2m_patch(p)            = cnstate_vars%annavg_t2m_col(c)
-      cnstate_vars%tempavg_t2m_patch(p)           = 0._r8
-      cnstate_vars%alloc_pnow_patch(p)            = 1._r8
-      cnstate_vars%c_allometry_patch(p)           = 0._r8
-      cnstate_vars%n_allometry_patch(p)           = 0._r8
-      cnstate_vars%p_allometry_patch(p)           = 0._r8
-      cnstate_vars%tempsum_potential_gpp_patch(p) = 0._r8
-      cnstate_vars%annsum_potential_gpp_patch(p)  = 0._r8
-      cnstate_vars%tempmax_retransn_patch(p)      = 0._r8
-      cnstate_vars%annmax_retransn_patch(p)       = 0._r8
-      cnstate_vars%downreg_patch(p)               = 0._r8
-      
-      cnstate_vars%tempmax_retransp_patch(p)      = 0._r8
-      cnstate_vars%annmax_retransp_patch(p)       = 0._r8
-      
-      if ( use_c14 ) then
-         cnstate_vars%rc14_atm_patch(p) = c14ratio
-         cnstate_vars%rc14_atm_patch(p) = 0._r8
-      endif
-      
-   end subroutine CNStateVarsInit
-   
-   !-----------------------------------------------------------------------
-   subroutine CarbonFluxVarsInit(cf, p)
-      !
-      ! !DESCRIPTION:
-      ! Initializes p-th patch of carbonflux_type
-      !
-      !$acc routine seq 
-      use elm_varcon, only : c13ratio
-      !
-      implicit none
-      !
-      ! !ARGUMENT
-      type(vegetation_carbon_flux), intent(inout) :: cf
-      integer              , intent(in)    :: p
-      
-      cf%xsmrpool_recover(p)      = 0._r8
-      cf%plant_calloc(p)          = 0._r8
-      cf%excess_cflux(p)          = 0._r8
-      cf%prev_leafc_to_litter(p)  = 0._r8
-      cf%prev_frootc_to_litter(p) = 0._r8
-      cf%availc(p)                = 0._r8
-      cf%gpp_before_downreg(p)    = 0._r8
-      cf%tempsum_npp(p)           = 0._r8
-      cf%annsum_npp(p)            = 0._r8
-      
-      if ( use_c13 ) then
-         cf%xsmrpool_c13ratio(p) = c13ratio
-      end if
-      
-   end subroutine CarbonFluxVarsInit
-   
-   !-----------------------------------------------------------------------
-   subroutine NitrogenFluxVarsInit(p)
-      !
-      ! !DESCRIPTION:
-      ! Initializes p-th patch of nitrogenflux_type
-      !
-      !$acc routine seq 
-      implicit none
-      !
-      ! !ARGUMENT
-      integer                , intent(in)    :: p
-      
-      veg_nf%plant_ndemand(p)         = 0._r8
-      veg_nf%avail_retransn(p)        = 0._r8
-      veg_nf%plant_nalloc(p)          = 0._r8
-      
-   end subroutine NitrogenFluxVarsInit
-   
-   !-----------------------------------------------------------------------
-   subroutine PhosphorusFluxVarsInit( p)
-      !
-      ! !DESCRIPTION:
-      ! Initializes p-th patch of phosphorusflux_type
-      !
-      !$acc routine seq 
-      implicit none
-      !
-      ! !ARGUMENT
-      integer                  , intent(in)    :: p
-      
-      veg_pf%plant_pdemand(p)         = 0._r8
-      veg_pf%avail_retransp(p)        = 0._r8
-      veg_pf%plant_palloc(p)          = 0._r8
-      
-   end subroutine PhosphorusFluxVarsInit
-   
+
+          froot   = cnstate_vars%froot_prof_patch(p,j)
+          croot   = cnstate_vars%croot_prof_patch(p,j)
+          fr_flab = veg_vp%fr_flab(veg_pp%itype(p))
+          fr_fcel = veg_vp%fr_fcel(veg_pp%itype(p))
+          fr_flig = veg_vp%fr_flig(veg_pp%itype(p))
+
+          ! fine root litter carbon fluxes
+          col_cf%dwt_frootc_to_litr_met_c(c,j) = &
+               col_cf%dwt_frootc_to_litr_met_c(c,j) + &
+               (dwt_frootc_to_litter(fp)* fr_flab)/dt * froot
+
+          col_cf%dwt_frootc_to_litr_cel_c(c,j) = &
+               col_cf%dwt_frootc_to_litr_cel_c(c,j) + &
+               (dwt_frootc_to_litter(fp)* fr_fcel)/dt * froot
+
+          col_cf%dwt_frootc_to_litr_lig_c(c,j) = &
+               col_cf%dwt_frootc_to_litr_lig_c(c,j) + &
+               (dwt_frootc_to_litter(fp)* fr_flig)/dt * froot
+
+
+          ! fine root litter nitrogen fluxes
+          col_nf%dwt_frootn_to_litr_met_n(c,j) = &
+               col_nf%dwt_frootn_to_litr_met_n(c,j) + &
+               (dwt_frootn_to_litter(fp)* fr_flab)/dt * froot
+          col_nf%dwt_frootn_to_litr_cel_n(c,j) = &
+
+               col_nf%dwt_frootn_to_litr_cel_n(c,j) + &
+               (dwt_frootn_to_litter(fp)* fr_fcel)/dt * froot
+
+          col_nf%dwt_frootn_to_litr_lig_n(c,j) = &
+               col_nf%dwt_frootn_to_litr_lig_n(c,j) + &
+               (dwt_frootn_to_litter(fp)* fr_flig)/dt * froot
+
+          ! fine root litter phosphorus fluxes
+          col_pf%dwt_frootp_to_litr_met_p(c,j) = &
+               col_pf%dwt_frootp_to_litr_met_p(c,j) + &
+               (dwt_frootp_to_litter(fp)* fr_flab)/dt * froot
+          col_pf%dwt_frootp_to_litr_cel_p(c,j) = &
+
+               col_pf%dwt_frootp_to_litr_cel_p(c,j) + &
+               (dwt_frootp_to_litter(fp)* fr_fcel)/dt * froot
+
+          col_pf%dwt_frootp_to_litr_lig_p(c,j) = &
+               col_pf%dwt_frootp_to_litr_lig_p(c,j) + &
+               (dwt_frootp_to_litter(fp)* fr_flig)/dt * froot
+
+          ! livecroot fluxes to cwd
+          col_cf%dwt_livecrootc_to_cwdc(c,j) = &
+               col_cf%dwt_livecrootc_to_cwdc(c,j) + &
+               (dwt_livecrootc_to_litter(fp))/dt * croot
+
+          col_nf%dwt_livecrootn_to_cwdn(c,j) = &
+               col_nf%dwt_livecrootn_to_cwdn(c,j) + &
+               (dwt_livecrootn_to_litter(fp))/dt * croot
+
+          col_pf%dwt_livecrootp_to_cwdp(c,j) = &
+               col_pf%dwt_livecrootp_to_cwdp(c,j) + &
+               (dwt_livecrootp_to_litter(fp))/dt * croot
+
+          ! deadcroot fluxes to cwd
+          col_cf%dwt_deadcrootc_to_cwdc(c,j) = &
+               col_cf%dwt_deadcrootc_to_cwdc(c,j) + &
+               (dwt_deadcrootc_to_litter(fp))/dt * croot
+
+          col_nf%dwt_deadcrootn_to_cwdn(c,j) = &
+               col_nf%dwt_deadcrootn_to_cwdn(c,j) + &
+               (dwt_deadcrootn_to_litter(fp))/dt * croot
+
+          col_pf%dwt_deadcrootp_to_cwdp(c,j) = &
+               col_pf%dwt_deadcrootp_to_cwdp(c,j) + &
+               (dwt_deadcrootp_to_litter(fp))/dt * croot
+
+          if ( use_c13 ) then
+             ! C13 fine root litter fluxes
+             c13_col_cf%dwt_frootc_to_litr_met_c(c,j) = &
+                  c13_col_cf%dwt_frootc_to_litr_met_c(c,j) + &
+                  (dwt_frootc13_to_litter(fp)* fr_flab)/dt * froot
+
+             c13_col_cf%dwt_frootc_to_litr_cel_c(c,j) = &
+                  c13_col_cf%dwt_frootc_to_litr_cel_c(c,j) + &
+                  (dwt_frootc13_to_litter(fp)* fr_fcel)/dt * froot
+
+             c13_col_cf%dwt_frootc_to_litr_lig_c(c,j) = &
+                  c13_col_cf%dwt_frootc_to_litr_lig_c(c,j) + &
+                  (dwt_frootc13_to_litter(fp)* fr_flig)/dt * froot
+
+             ! livecroot fluxes to cwd
+             c13_col_cf%dwt_livecrootc_to_cwdc(c,j) = &
+                  c13_col_cf%dwt_livecrootc_to_cwdc(c,j) + &
+                  (dwt_livecrootc13_to_litter(fp))/dt * croot
+
+             ! deadcroot fluxes to cwd
+             c13_col_cf%dwt_deadcrootc_to_cwdc(c,j) = &
+                  c13_col_cf%dwt_deadcrootc_to_cwdc(c,j) + &
+                  (dwt_deadcrootc13_to_litter(fp))/dt * croot
+
+          endif
+
+          if ( use_c14 ) then
+             ! C14 fine root litter fluxes
+             c14_col_cf%dwt_frootc_to_litr_met_c(c,j) = &
+                  c14_col_cf%dwt_frootc_to_litr_met_c(c,j) + &
+                  (dwt_frootc14_to_litter(fp)* fr_flab)/dt * froot
+
+             c14_col_cf%dwt_frootc_to_litr_cel_c(c,j) = &
+                  c14_col_cf%dwt_frootc_to_litr_cel_c(c,j) + &
+                  (dwt_frootc14_to_litter(fp)* fr_fcel)/dt * froot
+
+             c14_col_cf%dwt_frootc_to_litr_lig_c(c,j) = &
+                  c14_col_cf%dwt_frootc_to_litr_lig_c(c,j) + &
+                  (dwt_frootc14_to_litter(fp)* fr_flig)/dt * froot
+
+             ! livecroot fluxes to cwd
+             c14_col_cf%dwt_livecrootc_to_cwdc(c,j) = &
+                  c14_col_cf%dwt_livecrootc_to_cwdc(c,j) + &
+                  (dwt_livecrootc14_to_litter(fp))/dt * croot
+
+             ! deadcroot fluxes to cwd
+             c14_col_cf%dwt_deadcrootc_to_cwdc(c,j) = &
+                  c14_col_cf%dwt_deadcrootc_to_cwdc(c,j) + &
+                  (dwt_deadcrootc14_to_litter(fp))/dt * croot
+          endif
+       end do
+    end do
+    ! calculate pft-to-column for fluxes into product pools and conversion flux
+    do fp = 1, num_soilp_with_inactive
+       p = filter_soilp_with_inactive(fp)
+       c = veg_pp%column(p)
+       g = veg_pp%gridcell(p)
+
+       ! column-level fluxes are accumulated as positive fluxes.
+       ! column-level C flux updates
+       col_cf%dwt_conv_cflux(c) = col_cf%dwt_conv_cflux(c) - conv_cflux(fp)/dt
+       col_cf%dwt_prod10c_gain(c) = col_cf%dwt_prod10c_gain(c) - prod10_cflux(fp)/dt
+       col_cf%dwt_prod100c_gain(c) = col_cf%dwt_prod100c_gain(c) - prod100_cflux(fp)/dt
+       col_cf%dwt_crop_productc_gain(c) = col_cf%dwt_crop_productc_gain(c) - crop_product_cflux(fp)/dt
+
+       veg_cf%dwt_prod10c_gain(p) = - prod10_cflux(fp)/dt
+       grc_cf%dwt_prod10c_gain(g)   = grc_cf%dwt_prod10c_gain(g) + veg_cf%dwt_prod10c_gain(p)
+
+       veg_cf%dwt_prod100c_gain(p) = - prod100_cflux(fp)/dt
+       grc_cf%dwt_prod100c_gain(g)   = grc_cf%dwt_prod100c_gain(g) + veg_cf%dwt_prod100c_gain(p)
+
+       veg_cf%dwt_crop_productc_gain(p) = - crop_product_cflux(fp)/dt
+
+       if ( use_c13 ) then
+          ! C13 column-level flux updates
+          c13_col_cf%dwt_conv_cflux(c) = c13_col_cf%dwt_conv_cflux(c) - conv_c13flux(fp)/dt
+          c13_col_cf%dwt_prod10c_gain(c) = c13_col_cf%dwt_prod10c_gain(c) - prod10_c13flux(fp)/dt
+          c13_col_cf%dwt_prod100c_gain(c) = c13_col_cf%dwt_prod100c_gain(c) - prod100_c13flux(fp)/dt
+          c13_col_cf%dwt_crop_productc_gain(c) = c13_col_cf%dwt_crop_productc_gain(c) - crop_product_c13flux(fp)/dt
+
+          c13_veg_cf%dwt_prod10c_gain(p) = - prod10_c13flux(fp)/dt
+          c13_grc_cf%dwt_prod10c_gain(g)   = c13_grc_cf%dwt_prod10c_gain(g) + c13_veg_cf%dwt_prod10c_gain(p)
+
+          c13_veg_cf%dwt_prod100c_gain(p) = - prod100_c13flux(fp)/dt
+          c13_grc_cf%dwt_prod100c_gain(g)   = c13_grc_cf%dwt_prod100c_gain(g) + c13_veg_cf%dwt_prod100c_gain(p)
+
+          c13_veg_cf%dwt_crop_productc_gain(p) = - crop_product_c13flux(fp)/dt
+
+       endif
+
+       if ( use_c14 ) then
+          ! C14 column-level flux updates
+          c14_col_cf%dwt_conv_cflux(c) = c14_col_cf%dwt_conv_cflux(c) - conv_c14flux(fp)/dt
+          c14_col_cf%dwt_prod10c_gain(c) = c14_col_cf%dwt_prod10c_gain(c) - prod10_c14flux(fp)/dt
+          c14_col_cf%dwt_prod100c_gain(c) = c14_col_cf%dwt_prod100c_gain(c) - prod100_c14flux(fp)/dt
+          c14_col_cf%dwt_crop_productc_gain(c) = c14_col_cf%dwt_crop_productc_gain(c) - crop_product_c14flux(fp)/dt
+
+          c14_veg_cf%dwt_prod10c_gain(p) = - prod10_c14flux(fp)/dt
+          c14_grc_cf%dwt_prod10c_gain(g)   = c14_grc_cf%dwt_prod10c_gain(g) + c14_veg_cf%dwt_prod10c_gain(p)
+
+          c14_veg_cf%dwt_prod100c_gain(p) = - prod100_c14flux(fp)/dt
+          c14_grc_cf%dwt_prod100c_gain(g)   = c14_grc_cf%dwt_prod100c_gain(g) + c14_veg_cf%dwt_prod100c_gain(p)
+
+          c14_veg_cf%dwt_crop_productc_gain(p) = - crop_product_c14flux(fp)/dt
+
+       endif
+
+       ! column-level N flux updates
+       col_nf%dwt_conv_nflux(c) = col_nf%dwt_conv_nflux(c) - conv_nflux(fp)/dt
+       col_nf%dwt_prod10n_gain(c) = col_nf%dwt_prod10n_gain(c) - prod10_nflux(fp)/dt
+       col_nf%dwt_prod100n_gain(c) = col_nf%dwt_prod100n_gain(c) - prod100_nflux(fp)/dt
+       col_nf%dwt_crop_productn_gain(c) = col_nf%dwt_crop_productn_gain(c) - crop_product_nflux(fp)/dt
+
+       veg_nf%dwt_prod10n_gain(p) = -prod10_nflux(fp)/dt
+       grc_nf%dwt_prod10n_gain(g)   = grc_nf%dwt_prod10n_gain(g) + veg_nf%dwt_prod10n_gain(p)
+
+       veg_nf%dwt_prod100n_gain(p)= -prod100_nflux(fp)/dt
+       grc_nf%dwt_prod100n_gain(g)  = grc_nf%dwt_prod100n_gain(g) + veg_nf%dwt_prod100n_gain(p)
+
+       veg_nf%dwt_crop_productn_gain(p) = -crop_product_nflux(fp)/dt
+
+       ! column-level P flux updates
+
+       col_pf%dwt_conv_pflux(c) = col_pf%dwt_conv_pflux(c) - conv_pflux(fp)/dt
+       col_pf%dwt_prod10p_gain(c) = col_pf%dwt_prod10p_gain(c) - prod10_pflux(fp)/dt
+       col_pf%dwt_prod100p_gain(c) = col_pf%dwt_prod100p_gain(c) - prod100_pflux(fp)/dt
+       col_pf%dwt_crop_productp_gain(c) = col_pf%dwt_crop_productp_gain(c) - crop_product_pflux(fp)/dt
+
+       veg_pf%dwt_prod10p_gain(p) = -prod10_pflux(fp)/dt
+       grc_pf%dwt_prod10p_gain(g)   = grc_pf%dwt_prod10p_gain(g) + veg_pf%dwt_prod10p_gain(p)
+
+       veg_pf%dwt_prod100p_gain(p)= -prod100_pflux(fp)/dt
+       grc_pf%dwt_prod100p_gain(g)  = grc_pf%dwt_prod100p_gain(g) + veg_pf%dwt_prod100p_gain(p)
+
+       veg_pf%dwt_crop_productp_gain(p) = -crop_product_pflux(fp)/dt
+
+    end do
+
+    do fp = 1, num_soilp_with_inactive
+       p = filter_soilp_with_inactive(fp)
+       g = veg_pp%gridcell(p)
+
+       ! Note that patch-level fluxes are stored per unit GRIDCELL area - thus, we don't
+       ! need to multiply by the patch's gridcell weight when translating patch-level
+       ! fluxes into gridcell-level fluxes.
+
+       veg_cf%dwt_conv_cflux(p) = -conv_cflux(fp)/dt
+       grc_cf%dwt_conv_cflux(g) = &
+            grc_cf%dwt_conv_cflux(g) + &
+            veg_cf%dwt_conv_cflux(p)
+
+       if ( use_c13 ) then
+          ! C13 column-level flux updates
+          c13_veg_cf%dwt_conv_cflux(p) = -conv_c13flux(fp)/dt
+          c13_grc_cf%dwt_conv_cflux(g) = &
+               c13_grc_cf%dwt_conv_cflux(g) + &
+               c13_veg_cf%dwt_conv_cflux(p)
+       endif
+
+       if ( use_c14 ) then
+          ! C14 column-level flux updates
+          c14_veg_cf%dwt_conv_cflux(p) = -conv_c14flux(fp)/dt
+          c14_grc_cf%dwt_conv_cflux(g) = &
+               c14_grc_cf%dwt_conv_cflux(g) + &
+               c14_veg_cf%dwt_conv_cflux(p)
+       endif
+
+       veg_nf%dwt_conv_nflux(p) = -conv_nflux(fp)/dt
+       grc_nf%dwt_conv_nflux(g) = &
+            grc_nf%dwt_conv_nflux(g) + &
+            veg_nf%dwt_conv_nflux(p)
+
+       veg_pf%dwt_conv_pflux(p) = -conv_pflux(fp)/dt
+       grc_pf%dwt_conv_pflux(g) = &
+            grc_pf%dwt_conv_pflux(g) + &
+            veg_pf%dwt_conv_pflux(p)
+
+    end do
+
+    ! Deallocate pft-level flux arrays
+    if ( use_c13 ) then
+       deallocate(dwt_leafc13_seed)
+       deallocate(dwt_deadstemc13_seed)
+       deallocate(dwt_frootc13_to_litter)
+       deallocate(dwt_livecrootc13_to_litter)
+       deallocate(dwt_deadcrootc13_to_litter)
+       deallocate(conv_c13flux)
+       deallocate(prod10_c13flux)
+       deallocate(prod100_c13flux)
+       deallocate(crop_product_c13flux)
+    endif
+
+    if ( use_c14 ) then
+       deallocate(dwt_leafc14_seed)
+       deallocate(dwt_deadstemc14_seed)
+       deallocate(dwt_frootc14_to_litter)
+       deallocate(dwt_livecrootc14_to_litter)
+       deallocate(dwt_deadcrootc14_to_litter)
+       deallocate(conv_c14flux)
+       deallocate(prod10_c14flux)
+       deallocate(prod100_c14flux)
+       deallocate(crop_product_c14flux)
+    endif
+
+ end subroutine dyn_cnbal_patch
+
+ !-----------------------------------------------------------------------
+ subroutine CarbonStateVarsInit(cs, p)
+   !
+   ! !DESCRIPTION:
+   ! Initializes p-th patch of carbonstate_type
+   !
+   implicit none
+   !
+   ! !ARGUMENT
+   type(vegetation_carbon_state), intent(inout) :: cs
+   integer                    , intent(in)    :: p
+
+   cs%leafc(p)              = 0._r8
+   cs%leafc_storage(p)      = 0._r8
+   cs%leafc_xfer(p)         = 0._r8
+   cs%frootc(p)             = 0._r8
+   cs%frootc_storage(p)     = 0._r8
+   cs%frootc_xfer(p)        = 0._r8
+   cs%livestemc(p)          = 0._r8
+   cs%livestemc_storage(p)  = 0._r8
+   cs%livestemc_xfer(p)     = 0._r8
+   cs%deadstemc(p)          = 0._r8
+   cs%deadstemc_storage(p)  = 0._r8
+   cs%deadstemc_xfer(p)     = 0._r8
+   cs%livecrootc(p)         = 0._r8
+   cs%livecrootc_storage(p) = 0._r8
+   cs%livecrootc_xfer(p)    = 0._r8
+   cs%deadcrootc(p)         = 0._r8
+   cs%deadcrootc_storage(p) = 0._r8
+   cs%deadcrootc_xfer(p)    = 0._r8
+   cs%gresp_storage(p)      = 0._r8
+   cs%gresp_xfer(p)         = 0._r8
+   cs%cpool(p)              = 0._r8
+   cs%xsmrpool(p)           = 0._r8
+   cs%ctrunc(p)             = 0._r8
+   cs%dispvegc(p)           = 0._r8
+   cs%storvegc(p)           = 0._r8
+   cs%totvegc(p)            = 0._r8
+   cs%totpftc(p)            = 0._r8
+
+ end subroutine CarbonStateVarsInit
+
+ !-----------------------------------------------------------------------
+ subroutine NitrogenStateVarsInit(veg_ns, p)
+   !
+   ! !DESCRIPTION:
+   ! Initializes p-th patch of nitrogenstate_type
+   !
+   implicit none
+   !
+   ! !ARGUMENT
+   type(vegetation_nitrogen_state), intent(inout) :: veg_ns
+   integer                 , intent(in)    :: p
+
+   veg_ns%leafn(p)              = 0._r8
+   veg_ns%leafn_storage(p)      = 0._r8
+   veg_ns%leafn_xfer(p)         = 0._r8
+   veg_ns%frootn(p)             = 0._r8
+   veg_ns%frootn_storage(p)     = 0._r8
+   veg_ns%frootn_xfer(p)        = 0._r8
+   veg_ns%livestemn(p)          = 0._r8
+   veg_ns%livestemn_storage(p)  = 0._r8
+   veg_ns%livestemn_xfer(p)     = 0._r8
+   veg_ns%deadstemn(p)          = 0._r8
+   veg_ns%deadstemn_storage(p)  = 0._r8
+   veg_ns%deadstemn_xfer(p)     = 0._r8
+   veg_ns%livecrootn(p)         = 0._r8
+   veg_ns%livecrootn_storage(p) = 0._r8
+   veg_ns%livecrootn_xfer(p)    = 0._r8
+   veg_ns%deadcrootn(p)         = 0._r8
+   veg_ns%deadcrootn_storage(p) = 0._r8
+   veg_ns%deadcrootn_xfer(p)    = 0._r8
+   veg_ns%retransn(p)           = 0._r8
+   veg_ns%npool(p)              = 0._r8
+   veg_ns%ntrunc(p)             = 0._r8
+   veg_ns%dispvegn(p)           = 0._r8
+   veg_ns%storvegn(p)           = 0._r8
+   veg_ns%totvegn(p)            = 0._r8
+   veg_ns%totpftn(p)            = 0._r8
+
+ end subroutine NitrogenStateVarsInit
+
+ !-----------------------------------------------------------------------
+ subroutine PhosphorusStateVarsInit(veg_ps, p)
+   !
+   ! !DESCRIPTION:
+   ! Initializes p-th patch of phosphorusstate_type
+   !
+   implicit none
+   !
+   ! !ARGUMENT
+   type(vegetation_phosphorus_state), intent(inout) :: veg_ps
+   integer                   , intent(in)    :: p
+
+   veg_ps%leafp(p)              = 0._r8
+   veg_ps%leafp_storage(p)      = 0._r8
+   veg_ps%leafp_xfer(p)         = 0._r8
+   veg_ps%frootp(p)             = 0._r8
+   veg_ps%frootp_storage(p)     = 0._r8
+   veg_ps%frootp_xfer(p)        = 0._r8
+   veg_ps%livestemp(p)          = 0._r8
+   veg_ps%livestemp_storage(p)  = 0._r8
+   veg_ps%livestemp_xfer(p)     = 0._r8
+   veg_ps%deadstemp(p)          = 0._r8
+   veg_ps%deadstemp_storage(p)  = 0._r8
+   veg_ps%deadstemp_xfer(p)     = 0._r8
+   veg_ps%livecrootp(p)         = 0._r8
+   veg_ps%livecrootp_storage(p) = 0._r8
+   veg_ps%livecrootp_xfer(p)    = 0._r8
+   veg_ps%deadcrootp(p)         = 0._r8
+   veg_ps%deadcrootp_storage(p) = 0._r8
+   veg_ps%deadcrootp_xfer(p)    = 0._r8
+   veg_ps%retransp(p)           = 0._r8
+   veg_ps%ppool(p)              = 0._r8
+   veg_ps%ptrunc(p)             = 0._r8
+   veg_ps%dispvegp(p)           = 0._r8
+   veg_ps%storvegp(p)           = 0._r8
+   veg_ps%totvegp(p)            = 0._r8
+   veg_ps%totpftp (p)           = 0._r8
+
+ end subroutine PhosphorusStateVarsInit
+
+ !-----------------------------------------------------------------------
+ subroutine CanopyStateVarsInit(canopystate_vars, p)
+   !
+   ! !DESCRIPTION:
+   ! Initializes p-th patch of canopystate_type
+   !
+   implicit none
+   !
+   ! !ARGUMENT
+   type(canopystate_type), intent(inout) :: canopystate_vars
+   integer               , intent(in)    :: p
+
+   canopystate_vars%laisun_patch(p) = 0._r8
+   canopystate_vars%laisha_patch(p) = 0._r8
+
+ end subroutine CanopyStateVarsInit
+
+ !-----------------------------------------------------------------------
+ subroutine CNStateVarsInit(cnstate_vars, p, c)
+   !
+   ! !DESCRIPTION:
+   ! Initializes p-th patch of cnstate_type
+   !
+   use elm_varcon, only : c14ratio
+   implicit none
+   !
+   ! !ARGUMENT
+   type(cnstate_type), intent(inout) :: cnstate_vars
+   integer           , intent(in)    :: p
+   integer           , intent(in)    :: c
+
+   cnstate_vars%dormant_flag_patch(p)          = 1._r8
+   cnstate_vars%days_active_patch(p)           = 0._r8
+   cnstate_vars%onset_flag_patch(p)            = 0._r8
+   cnstate_vars%onset_counter_patch(p)         = 0._r8
+   cnstate_vars%onset_gddflag_patch(p)         = 0._r8
+   cnstate_vars%onset_fdd_patch(p)             = 0._r8
+   cnstate_vars%onset_gdd_patch(p)             = 0._r8
+   cnstate_vars%onset_swi_patch(p)             = 0._r8
+   cnstate_vars%offset_flag_patch(p)           = 0._r8
+   cnstate_vars%offset_counter_patch(p)        = 0._r8
+   cnstate_vars%offset_fdd_patch(p)            = 0._r8
+   cnstate_vars%offset_swi_patch(p)            = 0._r8
+   cnstate_vars%lgsf_patch(p)                  = 0._r8
+   cnstate_vars%bglfr_patch(p)                 = 0._r8
+   cnstate_vars%bglfr_leaf_patch(p)            = 0._r8
+   cnstate_vars%bglfr_froot_patch(p)           = 0._r8
+   cnstate_vars%bgtr_patch(p)                  = 0._r8
+   cnstate_vars%annavg_t2m_patch(p)            = cnstate_vars%annavg_t2m_col(c)
+   cnstate_vars%tempavg_t2m_patch(p)           = 0._r8
+   cnstate_vars%alloc_pnow_patch(p)            = 1._r8
+   cnstate_vars%c_allometry_patch(p)           = 0._r8
+   cnstate_vars%n_allometry_patch(p)           = 0._r8
+   cnstate_vars%p_allometry_patch(p)           = 0._r8
+   cnstate_vars%tempsum_potential_gpp_patch(p) = 0._r8
+   cnstate_vars%annsum_potential_gpp_patch(p)  = 0._r8
+   cnstate_vars%tempmax_retransn_patch(p)      = 0._r8
+   cnstate_vars%annmax_retransn_patch(p)       = 0._r8
+   cnstate_vars%downreg_patch(p)               = 0._r8
+
+   cnstate_vars%tempmax_retransp_patch(p)      = 0._r8
+   cnstate_vars%annmax_retransp_patch(p)       = 0._r8
+
+   if ( use_c14 ) then
+      cnstate_vars%rc14_atm_patch(p) = c14ratio
+      cnstate_vars%rc14_atm_patch(p) = 0._r8
+   endif
+
+ end subroutine CNStateVarsInit
+
+ !-----------------------------------------------------------------------
+ subroutine CarbonFluxVarsInit(cf, p)
+   !
+   ! !DESCRIPTION:
+   ! Initializes p-th patch of carbonflux_type
+   !
+   use elm_varcon, only : c13ratio
+   !
+   implicit none
+   !
+   ! !ARGUMENT
+   type(vegetation_carbon_flux), intent(inout) :: cf
+   integer              , intent(in)    :: p
+
+   cf%xsmrpool_recover(p)      = 0._r8
+   cf%plant_calloc(p)          = 0._r8
+   cf%excess_cflux(p)          = 0._r8
+   cf%prev_leafc_to_litter(p)  = 0._r8
+   cf%prev_frootc_to_litter(p) = 0._r8
+   cf%availc(p)                = 0._r8
+   cf%gpp_before_downreg(p)    = 0._r8
+   cf%tempsum_npp(p)           = 0._r8
+   cf%annsum_npp(p)            = 0._r8
+
+   if ( use_c13 ) then
+      cf%xsmrpool_c13ratio(p) = c13ratio
+   end if
+
+ end subroutine CarbonFluxVarsInit
+
+ !-----------------------------------------------------------------------
+ subroutine NitrogenFluxVarsInit(p)
+   !
+   ! !DESCRIPTION:
+   ! Initializes p-th patch of nitrogenflux_type
+   !
+   implicit none
+   !
+   ! !ARGUMENT
+   integer                , intent(in)    :: p
+
+   veg_nf%plant_ndemand(p)         = 0._r8
+   veg_nf%avail_retransn(p)        = 0._r8
+   veg_nf%plant_nalloc(p)          = 0._r8
+
+ end subroutine NitrogenFluxVarsInit
+
+ !-----------------------------------------------------------------------
+ subroutine PhosphorusFluxVarsInit( p)
+   !
+   ! !DESCRIPTION:
+   ! Initializes p-th patch of phosphorusflux_type
+   !
+   implicit none
+   !
+   ! !ARGUMENT
+   integer                  , intent(in)    :: p
+
+   veg_pf%plant_pdemand(p)         = 0._r8
+   veg_pf%avail_retransp(p)        = 0._r8
+   veg_pf%plant_palloc(p)          = 0._r8
+
+ end subroutine PhosphorusFluxVarsInit
+
+ !-----------------------------------------------------------------------
+ subroutine dyn_cnbal_column( bounds, clump_index, column_state_updater, &
+       col_cs, c13_col_cs, c14_col_cs, &
+       col_ns, col_ps)
+   !
+   ! !DESCRIPTION:
+   ! Modify column-level state variables to maintain carbon, nitrogen
+   ! and phosphorus balance with dynamic column weights.
+   !
+   ! !USES:
+   use dynColumnStateUpdaterMod, only : column_state_updater_type
+   use dynPriorWeightsMod      , only : prior_weights_type
+   use elm_varctl              , only : use_lch4
+   !
+   ! !ARGUMENTS:
+   type(bounds_type)               , intent(in)    :: bounds
+   integer                         , intent(in)    :: clump_index
+   type(column_state_updater_type) , intent(in)    :: column_state_updater
+   type(column_carbon_state)       , intent(inout) :: col_cs
+   type(column_carbon_state)       , intent(inout) :: c13_col_cs
+   type(column_carbon_state)       , intent(inout) :: c14_col_cs
+   type(column_nitrogen_state)     , intent(inout) :: col_ns
+   type(column_phosphorus_state)   , intent(inout) :: col_ps
+   !
+   ! !LOCAL VARIABLES:
+
+   character(len=*), parameter :: subname = 'dyn_cnbal_col'
    !-----------------------------------------------------------------------
-   subroutine dyn_cnbal_column( bounds, clump_index, column_state_updater, &
-      col_cs, c13_col_cs, c14_col_cs, &
-      col_ns, col_ps)
-      !
-      ! !DESCRIPTION:
-      ! Modify column-level state variables to maintain carbon, nitrogen
-      ! and phosphorus balance with dynamic column weights.
-      !
-      ! !USES:
-      !$acc routine seq 
-      use dynColumnStateUpdaterMod, only : column_state_updater_type
-      use dynPriorWeightsMod      , only : prior_weights_type
-      use elm_varctl              , only : use_lch4
-      !
-      ! !ARGUMENTS:
-      type(bounds_type)               , intent(in)    :: bounds
-      integer                         , intent(in)    :: clump_index
-      type(column_state_updater_type) , intent(in)    :: column_state_updater
-      type(column_carbon_state)       , intent(inout) :: col_cs
-      type(column_carbon_state)       , intent(inout) :: c13_col_cs
-      type(column_carbon_state)       , intent(inout) :: c14_col_cs
-      type(column_nitrogen_state)     , intent(inout) :: col_ns
-      type(column_phosphorus_state)   , intent(inout) :: col_ps
-      !
-      ! !LOCAL VARIABLES:
-      
-      !    character(len=*), parameter :: subname = 'dyn_cnbal_col'
-      !-----------------------------------------------------------------------
-      !call dyn_col_cs_Adjustments(bounds, clump_index, column_state_updater, col_cs)
-      ! if (use_c13) then
-      !    call dyn_col_cs_Adjustments(bounds, clump_index, column_state_updater, c13_col_cs)
-      ! end if
-      ! if (use_c14) then
-      !    call dyn_col_cs_Adjustments(bounds, clump_index, column_state_updater, c14_col_cs)
-      ! end if
-      
-      ! call dyn_col_ns_Adjustments(bounds, clump_index, column_state_updater, col_ns)
-      ! call dyn_col_ps_Adjustments(bounds, clump_index, column_state_updater, col_ps)
-      
-      ! DynamicColumnAdjustments for CH4 needs to be implemented
-      
-   end subroutine dyn_cnbal_column
-   
-end module dynConsBiogeochemMod
+
+    call dyn_col_cs_Adjustments(bounds, clump_index, column_state_updater, col_cs)
+
+   if (use_c13) then
+      call dyn_col_cs_Adjustments(bounds, clump_index, column_state_updater, c13_col_cs)
+   end if
+
+   if (use_c14) then
+      call dyn_col_cs_Adjustments(bounds, clump_index, column_state_updater, c14_col_cs)
+   end if
+
+   call dyn_col_ns_Adjustments(bounds, clump_index, column_state_updater, col_ns)
+
+   call dyn_col_ps_Adjustments(bounds, clump_index, column_state_updater, col_ps)
+
+   ! DynamicColumnAdjustments for CH4 needs to be implemented
+
+end subroutine dyn_cnbal_column
+
+ end module dynConsBiogeochemMod
diff --git a/components/elm/src/dyn_subgrid/dynConsBiogeophysMod.F90 b/components/elm/src/dyn_subgrid/dynConsBiogeophysMod.F90
index e065c0a222..281530e5d6 100644
--- a/components/elm/src/dyn_subgrid/dynConsBiogeophysMod.F90
+++ b/components/elm/src/dyn_subgrid/dynConsBiogeophysMod.F90
@@ -22,7 +22,7 @@ module dynConsBiogeophysMod
   use TotalWaterAndHeatMod, only : AdjustDeltaHeatForDeltaLiq
   use TotalWaterAndHeatMod, only : heat_base_temp
   use elm_varcon        , only : tfrz, cpliq
-  use subgridAveMod     , only : p2c, c2g_1d_parallel, unity
+  use subgridAveMod     , only : p2c, c2g
   use dynSubgridControlMod, only : get_for_testing_zero_dynbal_fluxes
   use elm_varcon        , only : spval
   use GridcellDataType  , only : grc_es, grc_ef, grc_ws, grc_wf
@@ -48,7 +48,8 @@ contains
   subroutine dyn_hwcontent_init(bounds,                                      &
        num_nolakec, filter_nolakec,                                          &
        num_lakec, filter_lakec,                                              &
-       urbanparams_vars, soilstate_vars, soilhydrology_vars, lakestate_vars )
+       urbanparams_vars, soilstate_vars, soilhydrology_vars, lakestate_vars, &
+       energyflux_vars)
     !
     ! !DESCRIPTION:
     ! Initialize variables used for dyn_hwcontent, and compute grid cell-level heat
@@ -57,6 +58,7 @@ contains
     ! Should be called BEFORE any subgrid weight updates this time step
     !
     ! !ARGUMENTS:
+      !$acc routine seq
     type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_nolakec
     integer                  , intent(in)    :: filter_nolakec(:)
@@ -66,6 +68,7 @@ contains
     type(soilstate_type)     , intent(in)    :: soilstate_vars
     type(soilhydrology_type) , intent(in)    :: soilhydrology_vars
     type(lakestate_type)     , intent(in)    :: lakestate_vars
+    type(energyflux_type)    , intent(inout) :: energyflux_vars
     !
     ! !LOCAL VARIABLES:
     integer :: g   ! grid cell index
@@ -98,13 +101,14 @@ contains
        num_nolakec, filter_nolakec, &
        num_lakec, filter_lakec, &
        urbanparams_vars, soilstate_vars, soilhydrology_vars, lakestate_vars &
-       , dtime)
+       , energyflux_vars, dtime)
     !
     ! Should be called AFTER all subgrid weight updates this time step
     !
     ! !USES:
     !
     ! !ARGUMENTS:
+    !$acc routine seq
     type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_nolakec
     integer                  , intent(in)    :: filter_nolakec(:)
@@ -114,15 +118,16 @@ contains
     type(soilstate_type)     , intent(in)    :: soilstate_vars
     type(soilhydrology_type) , intent(in)    :: soilhydrology_vars
     type(lakestate_type)     , intent(in)    :: lakestate_vars
+    type(energyflux_type)    , intent(inout) :: energyflux_vars
     real(r8)                 , intent(in)    :: dtime ! land model time step (sec)
 
     !
     ! !LOCAL VARIABLES:
     integer  :: begg, endg
     integer  :: g     ! grid cell index
-    real(r8) :: delta_liq ! change in gridcell h2o liq content
-    real(r8) :: delta_ice ! change in gridcell h2o ice content
-    real(r8) :: delta_heat! change in gridcell heat content
+    real(r8) :: delta_liq(bounds%begg:bounds%endg)  ! change in gridcell h2o liq content
+    real(r8) :: delta_ice(bounds%begg:bounds%endg)  ! change in gridcell h2o ice content
+    real(r8) :: delta_heat(bounds%begg:bounds%endg) ! change in gridcell heat content
     !---------------------------------------------------------------------------
 
     associate( &
@@ -151,24 +156,43 @@ contains
          heat_grc = heat2(bounds%begg:bounds%endg), &
          liquid_water_temp_grc = liquid_water_temp2(bounds%begg:bounds%endg))
 
-   ! if (get_for_testing_zero_dynbal_fluxes()) then
-   !    do g = begg, endg
-   !       delta_liq(g) = 0._r8
-   !       delta_ice(g) = 0._r8
-   !       delta_heat(g) = 0._r8
-   !   end do
-   ! else
-    !$acc parallel loop independent gang vector default(present)
-    do g = begg, endg
-       delta_liq  = liq2(g) - liq1(g)
-       delta_ice  = ice2(g) - ice1(g)
-       delta_heat = heat2(g) - heat1(g)
-       grc_wf%qflx_liq_dynbal (g) = delta_liq/dtime
-       grc_wf%qflx_ice_dynbal (g) = delta_ice/dtime
-       grc_ef%eflx_dynbal    (g) = delta_heat/dtime
-    end do
-   !end if
-
+    if (get_for_testing_zero_dynbal_fluxes()) then
+       do g = begg, endg
+          delta_liq(g) = 0._r8
+          delta_ice(g) = 0._r8
+          delta_heat(g) = 0._r8
+      end do
+    else
+       do g = begg, endg
+          delta_liq(g)  = liq2(g) - liq1(g)
+          delta_ice(g)  = ice2(g) - ice1(g)
+          delta_heat(g) = heat2(g) - heat1(g)
+          grc_wf%qflx_liq_dynbal (g) = delta_liq(g)/dtime
+          grc_wf%qflx_ice_dynbal (g) = delta_ice(g)/dtime
+          grc_ef%eflx_dynbal    (g) = delta_heat(g)/dtime
+       end do
+    end if
+    !call AdjustDeltaHeatForDeltaLiq( &
+    !     bounds, &
+    !     delta_liq = delta_liq(bounds%begg:bounds%endg), &
+    !     liquid_water_temp1 = temperature_vars%liquid_water_temp1_grc(bounds%begg:bounds%endg), &
+    !     liquid_water_temp2 = temperature_vars%liquid_water_temp2_grc(bounds%begg:bounds%endg), &
+    !     delta_heat = delta_heat(bounds%begg:bounds%endg))
+
+    !call grc_wf%qflx_liq_dynbal_dribbler%set_curr_delta(bounds, &
+    !     delta_liq(begg:endg))
+    !call grc_wf%qflx_liq_dynbal_dribbler%get_curr_flux(bounds, &
+    !     grc_wf%qflx_liq_dynbal(begg:endg))
+
+    !call grc_wf%qflx_ice_dynbal_dribbler%set_curr_delta(bounds, &
+    !     delta_ice(begg:endg))
+    !call grc_wf%qflx_ice_dynbal_dribbler%get_curr_flux(bounds, &
+    !     grc_wf%qflx_ice_dynbal(begg:endg))
+
+    !call energyflux_vars%eflx_dynbal_dribbler%set_curr_delta(bounds, &
+    !     delta_heat(begg:endg))
+    !call energyflux_vars%eflx_dynbal_dribbler%get_curr_flux(bounds, &
+    !     energyflux_vars%eflx_dynbal_grc(begg:endg))
     end associate
   end subroutine dyn_hwcontent_final
 
@@ -183,6 +207,7 @@ contains
     ! Compute gridcell total liquid and ice water contents
     !
     ! !ARGUMENTS:
+    !$acc routine seq
     type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_nolakec
     integer                  , intent(in)    :: filter_nolakec(:)
@@ -196,12 +221,9 @@ contains
     ! !LOCAL VARIABLES:
     real(r8) :: liquid_mass_col(bounds%begc:bounds%endc) ! kg m-2
     real(r8) :: ice_mass_col(bounds%begc:bounds%endc)    ! kg m-2
-    
-    !-----------------------------------------------------------------------
-    !$acc enter data create(&
-    !$acc liquid_mass_col(:), &
-    !$acc ice_mass_col(:))
 
+
+    !-----------------------------------------------------------------------
     call ComputeLiqIceMassNonLake(bounds, num_nolakec, filter_nolakec, &
          soilhydrology_vars,  &
          liquid_mass_col(bounds%begc:bounds%endc), &
@@ -212,21 +234,17 @@ contains
          liquid_mass_col(bounds%begc:bounds%endc), &
          ice_mass_col(bounds%begc:bounds%endc))
 
-    call c2g_1d_parallel(bounds, &
+    call c2g(bounds, &
          carr = liquid_mass_col(bounds%begc:bounds%endc), &
          garr = liquid_mass(bounds%begg:bounds%endg), &
-         c2l_scale_type = unity, &
-         l2g_scale_type = unity, para=.true.)
+         c2l_scale_type = 0, &
+         l2g_scale_type = 0)
 
-    call c2g_1d_parallel(bounds, &
+    call c2g(bounds, &
          carr = ice_mass_col(bounds%begc:bounds%endc), &
          garr = ice_mass(bounds%begg:bounds%endg), &
-         c2l_scale_type = unity, &
-         l2g_scale_type = unity, para=.true.)
-
-    !$acc exit data delete(&
-    !$acc liquid_mass_col(:), &
-    !$acc ice_mass_col(:))
+         c2l_scale_type = 0, &
+         l2g_scale_type = 0)
 
   end subroutine dyn_water_content
 
@@ -247,6 +265,7 @@ contains
     ! we include the latent heat of fusion.
     !
     ! !ARGUMENTS:
+      !$acc routine seq
     type(bounds_type)        , intent(in)  :: bounds
     integer                  , intent(in)  :: num_nolakec
     integer                  , intent(in)  :: filter_nolakec(:)
@@ -271,12 +290,9 @@ contains
     real(r8) :: cv_liquid_grc(bounds%begg:bounds%endg) ! cv_liquid_col averaged to grid cell [J/(m^2 K)]
     !-------------------------------------------------------------------------------
 
-    !$acc enter data create(&
-    !$acc heat_col(:), &
-    !$acc heat_liquid_col(:), &
-    !$acc cv_liquid_col(:), &
-    !$acc heat_liquid_grc(:), &
-    !$acc cv_liquid_grc(:))
+    ! Enforce expected array sizes
+    !!SHR_ASSERT_ALL((ubound(heat_grc) == (/bounds%endg/)), errMsg(__FILE__, __LINE__))
+    !!SHR_ASSERT_ALL((ubound(liquid_water_temp_grc) == (/bounds%endg/)), errMsg(__FILE__, __LINE__))
 
     heat_col(bounds%begc:bounds%endc)        = spval
     heat_liquid_col(bounds%begc:bounds%endc) = spval
@@ -294,25 +310,24 @@ contains
          heat_liquid = heat_liquid_col(bounds%begc:bounds%endc), &
          cv_liquid = cv_liquid_col(bounds%begc:bounds%endc))
 
-    call c2g_1d_parallel(bounds, &
+    call c2g(bounds, &
          carr = heat_col(bounds%begc:bounds%endc), &
          garr = heat_grc(bounds%begg:bounds%endg), &
-         c2l_scale_type = unity, &
-         l2g_scale_type = unity, para=.true.)
+         c2l_scale_type = 0, &
+         l2g_scale_type = 0)
 
-    call c2g_1d_parallel(bounds, &
+    call c2g(bounds, &
          carr = heat_liquid_col(bounds%begc:bounds%endc), &
          garr = heat_liquid_grc(bounds%begg:bounds%endg), &
-         c2l_scale_type = unity, &
-         l2g_scale_type = unity, para=.true.)
+         c2l_scale_type = 0, &
+         l2g_scale_type = 0)
 
-    call c2g_1d_parallel(bounds, &
+    call c2g(bounds, &
          carr = cv_liquid_col(bounds%begc:bounds%endc), &
          garr = cv_liquid_grc(bounds%begg:bounds%endg), &
-         c2l_scale_type = unity, &
-         l2g_scale_type = unity, para=.true.)
+         c2l_scale_type = 0, &
+         l2g_scale_type = 0)
 
-    !$acc parallel loop independent gang vector default(present)
     do g = bounds%begg, bounds%endg
        if (cv_liquid_grc(g) > 0._r8) then
           liquid_water_temp_grc(g) = &
@@ -323,13 +338,6 @@ contains
        end if
     end do
 
-    !$acc exit data delete(&
-    !$acc heat_col(:), &
-    !$acc heat_liquid_col(:), &
-    !$acc cv_liquid_col(:), &
-    !$acc heat_liquid_grc(:), &
-    !$acc cv_liquid_grc(:))
-
   end subroutine dyn_heat_content
 
 end module dynConsBiogeophysMod
diff --git a/components/elm/src/dyn_subgrid/dynHarvestMod.F90 b/components/elm/src/dyn_subgrid/dynHarvestMod.F90
index 311ac7a5a3..1585d8ae37 100644
--- a/components/elm/src/dyn_subgrid/dynHarvestMod.F90
+++ b/components/elm/src/dyn_subgrid/dynHarvestMod.F90
@@ -27,8 +27,7 @@ module dynHarvestMod
   use VegetationDataType    , only : veg_cs, veg_cf, veg_ns, veg_nf  
   use VegetationDataType    , only : veg_ps, veg_pf  
   use topounit_varcon      , only : max_topounits
-  use timeinfoMod 
-  !
+  
   ! !PUBLIC MEMBER FUNCTIONS:
   implicit none
   private
@@ -57,8 +56,7 @@ module dynHarvestMod
   real(r8) , allocatable   :: harvest(:,:) ! harvest rates
   logical                  :: do_harvest ! whether we're in a period when we should do harvest
   !---------------------------------------------------------------------------
-  !$acc declare create(harvest(:))
-  !$acc declare create(do_harvest) 
+
 contains
 
   !-----------------------------------------------------------------------
@@ -179,10 +177,11 @@ contains
     ! Harvest mortality routine for coupled carbon-nitrogen code (CN)
     
     ! !USES:
-    !$acc routine seq 
     use pftvarcon       , only : noveg, nbrdlf_evr_shrub, pprodharv10
     use elm_varcon      , only : secspday
+    use clm_time_manager, only : get_days_per_year
     use GridcellType   , only : grc_pp
+    
     ! !ARGUMENTS:
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
     integer                  , intent(in)    :: filter_soilc(:) ! column filter for soil points
@@ -339,7 +338,7 @@ contains
    )
 
 
-   days_per_year = dayspyr_mod !get_days_per_year()
+   days_per_year = get_days_per_year()
 
    ! patch loop
    do fp = 1,num_soilp
@@ -474,7 +473,7 @@ contains
    ! !DESCRIPTION:
    ! called at the end of CNHarvest to gather all pft-level harvest litterfall fluxes
    ! to the column level and assign them to the three litter pools
-   !$acc routine seq 
+   
    ! !USES:
    use elm_varpar , only : maxpatch_pft, nlevdecomp
    !
diff --git a/components/elm/src/dyn_subgrid/dynInitColumnsMod.F90 b/components/elm/src/dyn_subgrid/dynInitColumnsMod.F90
index 03c1f9292d..1703607f3e 100644
--- a/components/elm/src/dyn_subgrid/dynInitColumnsMod.F90
+++ b/components/elm/src/dyn_subgrid/dynInitColumnsMod.F90
@@ -18,7 +18,6 @@ module dynInitColumnsMod
   use LandunitType      , only : lun_pp
   use ColumnType        , only : col_pp
   use ColumnDataType    , only : col_es, col_ws
-  use shr_sys_mod            , only : shr_sys_flush
   !
   ! !PUBLIC MEMBER FUNCTIONS:
   implicit none
@@ -52,7 +51,7 @@ contains
     ! !ARGUMENTS:
       !$acc routine seq
     type(bounds_type)        , intent(in)    :: bounds                        ! bounds
-    logical                  , intent(in)    :: cactive_prior(:) ! column-level active flags from prior time step
+    logical                  , intent(in)    :: cactive_prior( bounds%begc: ) ! column-level active flags from prior time step
     type(soilhydrology_type) , intent(inout) :: soilhydrology_vars
     !
     ! !LOCAL VARIABLES:
@@ -60,15 +59,16 @@ contains
     integer :: c_template ! index of template column
 
     !-----------------------------------------------------------------------
+
+
     do c = bounds%begc, bounds%endc
        ! If this column is newly-active, then we need to initialize it using the routines in this module
-       !write(iulog,*) "activ, cactive prior", c , col_pp%active(c), cactive_prior(c)
        if (col_pp%active(c) .and. .not. cactive_prior(c)) then
           c_template = initial_template_col_dispatcher(bounds, c, cactive_prior(bounds%begc:bounds%endc))
           if (c_template /= ispval) then
              call copy_state(c, c_template, soilhydrology_vars)
           else
-             print * ,' WARNING: No template column found to initialize newly-active column'
+             write(iulog,*)' WARNING: No template column found to initialize newly-active column'
           end if
        end if
     end do
@@ -109,17 +109,17 @@ contains
     case(istcrop)
        c_template = initial_template_col_crop(bounds, c_new,cactive_prior(bounds%begc:bounds%endc) )
     case(istice)
-      ! write(iulog,*) ' ERROR: Ability to initialize a newly-active glacier column not yet implemented'
+       write(iulog,*) ' ERROR: Ability to initialize a newly-active glacier column not yet implemented'
     case(istice_mec)
-       !write(iulog,*) ' ERROR: Ability to initialize a newly-active glacier mec column not yet implemented'
+       write(iulog,*) ' ERROR: Ability to initialize a newly-active glacier mec column not yet implemented'
     case(istdlak)
-       !write(iulog,*) ' ERROR: Ability to initialize a newly-active lake column not yet implemented'
+       write(iulog,*) ' ERROR: Ability to initialize a newly-active lake column not yet implemented'
     case(istwet)
-       !write(iulog,*) ' ERROR: Ability to initialize a newly-active wetland column not yet implemented'
-    !case(isturb_MIN:isturb_MAX)
-       !write(iulog,*)' ERROR: Ability to initialize a newly-active urban column not yet implemented'
+       write(iulog,*) ' ERROR: Ability to initialize a newly-active wetland column not yet implemented'
+    case(isturb_MIN:isturb_MAX)
+       write(iulog,*)' ERROR: Ability to initialize a newly-active urban column not yet implemented'
     case default
-       !write(iulog,*) ' ERROR: Unknown landunit type: ', ltype
+       write(iulog,*) ' ERROR: Unknown landunit type: ', ltype
     end select
 
   end function initial_template_col_dispatcher
@@ -145,14 +145,13 @@ contains
     !
     ! !LOCAL VARIABLES:
     !-----------------------------------------------------------------------
-    #ifndef _OPENACC
+
     if (col_pp%wtgcell(c_new) > 0._r8) then
 
-       write(iulog,*) ' ERROR: Expectation is that the only vegetated columns that',c_new, col_pp%wtgcell(c_new)
+       write(iulog,*) ' ERROR: Expectation is that the only vegetated columns that',c_new
        write(iulog,*) ' can newly become active are ones with 0 weight on the grid cell'
        call endrun()
     end if
-    #endif 
 
     c_template = ispval
 
diff --git a/components/elm/src/dyn_subgrid/dynPatchStateUpdaterMod.F90 b/components/elm/src/dyn_subgrid/dynPatchStateUpdaterMod.F90
index 24e136a905..125de3c910 100644
--- a/components/elm/src/dyn_subgrid/dynPatchStateUpdaterMod.F90
+++ b/components/elm/src/dyn_subgrid/dynPatchStateUpdaterMod.F90
@@ -32,6 +32,7 @@ module dynPatchStateUpdaterMod
   private
   !
   ! !PUBLIC TYPES:
+  public :: patch_state_updater_type
 
   ! Public routines
   public :: set_old_patch_weights     ! set weights before dyn subgrid updates
@@ -46,7 +47,7 @@ module dynPatchStateUpdaterMod
   ! based on pft type.
   public :: update_patch_state_partition_flux_by_type
 
-  type, public :: patch_state_updater_type
+  type :: patch_state_updater_type
 
      real(r8), pointer :: pwtgcell_old(:) => null() ! old patch weights on the gridcell
      real(r8), pointer :: pwtgcell_new(:) => null()! new patch weights on the gridcell
@@ -66,9 +67,10 @@ module dynPatchStateUpdaterMod
 
    contains
      ! Public routines
-     procedure, public :: initPatchStateUpdater
-     procedure, public :: set_old_patch_weights     ! set weights before dyn subgrid updates
-     procedure, public :: set_new_patch_weights     ! set weights after dyn subgrid updates
+     !procedure, public :: set_old_patch_weights     ! set weights before dyn subgrid updates
+     !procedure, public :: set_new_patch_weights     ! set weights after dyn subgrid updates
+
+
 
      ! returns a patch-level logical array that is true wherever the patch weight was zero
      ! prior to weight updates
@@ -84,12 +86,10 @@ module dynPatchStateUpdaterMod
 
   end type patch_state_updater_type
 
-  ! interface patch_state_updater_type
-  !    module procedure constructor
-  ! end interface patch_state_updater_type
-  
-  ! object used to update patch-level states after subgrid weight updates
-  !type(patch_state_updater_type), public  :: patch_state_updater
+  interface patch_state_updater_type
+     module procedure constructor
+  end interface patch_state_updater_type
+
   ! Update a patch-level state variable and compute associated fluxes based on changing
   ! patch areas
 
@@ -103,47 +103,7 @@ contains
   ! ========================================================================
 
   !-----------------------------------------------------------------------
-  !function constructor(bounds) result(this)
-  !  !
-  !  ! !DESCRIPTION:
-  !  ! Initialize a patch_state_updater_type object
-  !  !
-  !  ! !USES:
-  !  !
-  !  ! !ARGUMENTS:
-  !  type(patch_state_updater_type) :: this  ! function result
-  !  type(bounds_type), intent(in) :: bounds
-  !  !
-  !  ! !LOCAL VARIABLES:
-  !  integer :: begp, endp
-  !  integer :: begc, endc
-
-  !  character(len=*), parameter :: subname = 'constructor'
-  !  !-----------------------------------------------------------------------
-
-  !  SHR_ASSERT(bounds%level == BOUNDS_LEVEL_PROC, errMsg(sourcefile, __LINE__))
-
-  !  begp = bounds%begp
-  !  endp = bounds%endp
-  !  begc = bounds%begc
-  !  endc = bounds%endc
-
-  !  allocate(this%pwtgcell_old(begp:endp))
-  !  this%pwtgcell_old(:) = spval
-  !  allocate(this%pwtgcell_new(begp:endp))
-  !  this%pwtgcell_new(:) = spval
-  !  allocate(this%cwtgcell_old(begc:endc))
-  !  this%cwtgcell_old(:) = spval
-  !  allocate(this%dwt(begp:endp))
-  !  this%dwt(:) = spval
-  !  allocate(this%growing_old_fraction(begp:endp))
-  !  this%growing_old_fraction(:) = spval
-  !  allocate(this%growing_new_fraction(begp:endp))
-  !  this%growing_new_fraction(:) = spval
-
-  !end function constructor
-  subroutine initPatchStateUpdater(this, bounds)  
-      implicit none 
+  function constructor(bounds) result(this)
     !
     ! !DESCRIPTION:
     ! Initialize a patch_state_updater_type object
@@ -151,7 +111,7 @@ contains
     ! !USES:
     !
     ! !ARGUMENTS:
-    class(patch_state_updater_type) :: this  ! function result
+    type(patch_state_updater_type) :: this  ! function result
     type(bounds_type), intent(in) :: bounds
     !
     ! !LOCAL VARIABLES:
@@ -160,13 +120,14 @@ contains
 
     character(len=*), parameter :: subname = 'constructor'
     !-----------------------------------------------------------------------
+
     SHR_ASSERT(bounds%level == BOUNDS_LEVEL_PROC, errMsg(sourcefile, __LINE__))
 
     begp = bounds%begp
     endp = bounds%endp
     begc = bounds%begc
     endc = bounds%endc
-    print *, "PATCH_STATE_UPDATER:",begp,endp 
+
     allocate(this%pwtgcell_old(begp:endp))
     this%pwtgcell_old(:) = spval
     allocate(this%pwtgcell_new(begp:endp))
@@ -179,9 +140,9 @@ contains
     this%growing_old_fraction(:) = spval
     allocate(this%growing_new_fraction(begp:endp))
     this%growing_new_fraction(:) = spval
- end subroutine initPatchStateUpdater 
 
- 
+  end function constructor
+
   ! ========================================================================
   ! Public methods
   ! ========================================================================
@@ -296,8 +257,15 @@ contains
     ! a patch-level array, it is expressed as mass per unit area GRIDCELL.
     real(r8), intent(inout), optional :: seed_addition
     !
+    character(len=*), parameter :: subname = 'update_patch_state'
     !-----------------------------------------------------------------------
 
+    if (present(seed_addition)) then
+       if (.not. present(seed)) then
+          call endrun(subname//' ERROR: seed_addition can only be provided if seed is provided')
+       end if
+    end if
+
     if (this%dwt(p) > 0._r8) then
       var = var * this%growing_old_fraction(p)
       if (present(seed)) then
diff --git a/components/elm/src/dyn_subgrid/dynSubgridAdjustmentsMod.F90 b/components/elm/src/dyn_subgrid/dynSubgridAdjustmentsMod.F90
index adf29cf89e..5e2ec82105 100644
--- a/components/elm/src/dyn_subgrid/dynSubgridAdjustmentsMod.F90
+++ b/components/elm/src/dyn_subgrid/dynSubgridAdjustmentsMod.F90
@@ -20,14 +20,12 @@ module dynSubgridAdjustmentsMod
   use elm_varcon             , only : dzsoi_decomp
   use dynPatchStateUpdaterMod, only : patch_state_updater_type
   use dynPatchStateUpdaterMod, only : update_patch_state, update_patch_state_partition_flux_by_type
-  use dynColumnStateUpdaterMod , only : column_state_updater_type, update_column_state_no_special_handling
+  use dynColumnStateUpdaterMod,only : column_state_updater_type, update_column_state_no_special_handling
   use ColumnDataType         , only : column_carbon_state, column_nitrogen_state
   use ColumnDataType         , only : column_phosphorus_state
   use VegetationDataType     , only : vegetation_carbon_state, vegetation_nitrogen_state
   use VegetationDataType     , only : vegetation_phosphorus_state
   use SpeciesMod             , only : CN_SPECIES_N, CN_SPECIES_P
-  use decompMod, only :  get_clump_bounds_gpu
-  use elm_varctl , only : iulog 
 
   !
   ! !PUBLIC MEMBER FUNCTIONS:
@@ -106,37 +104,37 @@ contains
     real(r8) :: deadstemc_patch_temp
     !-----------------------------------------------------------------------
     associate(&
-      leafc          => veg_cs%leafc        , &
-      leafc_storage  => veg_cs%leafc_storage, &
-      leafc_xfer     => veg_cs%leafc_xfer   , &
-      frootc         => veg_cs%frootc          ,&
-      frootc_storage => veg_cs%frootc_storage  ,&
-      frootc_xfer    => veg_cs%frootc_xfer    , &
-      livestemc      => veg_cs%livestemc            ,&
-      livestemc_storage => veg_cs%livestemc_storage  ,&
-      livestemc_xfer    => veg_cs%livestemc_xfer     ,&
-      deadstemc         => veg_cs%deadstemc                ,&
-      deadstemc_storage => veg_cs%deadstemc_storage  ,&
-      deadstemc_xfer    => veg_cs%deadstemc_xfer    , &
-      livecrootc         => veg_cs%livecrootc          ,&
-      livecrootc_storage => veg_cs%livecrootc_storage  ,&
-      livecrootc_xfer    => veg_cs%livecrootc_xfer     ,&
-      deadcrootc         => veg_cs%deadcrootc          ,&
-      deadcrootc_storage => veg_cs%deadcrootc_storage  ,&
-      deadcrootc_xfer    => veg_cs%deadcrootc_xfer    , &
-      gresp_storage      => veg_cs%gresp_storage ,&
-      gresp_xfer         => veg_cs%gresp_xfer   , &
-      cpool              => veg_cs%cpool        , &
-      xsmrpool           => veg_cs%xsmrpool     , &
-      ctrunc             => veg_cs%ctrunc       , &
-      dispvegc           => veg_cs%dispvegc     , &
-      storvegc           => veg_cs%storvegc     , &
-      totvegc            => veg_cs%totvegc      , &
-      totpftc            => veg_cs%totpftc      , &
-      grainc             => veg_cs%grainc       , &
-      grainc_storage     => veg_cs%grainc_storage, &
-      grainc_xfer        => veg_cs%grainc_xfer   , &
-      cropseedc_deficit  => veg_cs%cropseedc_deficit &
+      leafc          => veg_cs%leafc         (p), &
+      leafc_storage  => veg_cs%leafc_storage (p), &
+      leafc_xfer     => veg_cs%leafc_xfer    (p), &
+      frootc         => veg_cs%frootc        (p)   ,&
+      frootc_storage => veg_cs%frootc_storage(p)  ,&
+      frootc_xfer    => veg_cs%frootc_xfer   (p)  , &
+      livestemc      => veg_cs%livestemc     (p)        ,&
+      livestemc_storage => veg_cs%livestemc_storage(p)  ,&
+      livestemc_xfer    => veg_cs%livestemc_xfer   (p)  ,&
+      deadstemc         => veg_cs%deadstemc        (p)        ,&
+      deadstemc_storage => veg_cs%deadstemc_storage(p)  ,&
+      deadstemc_xfer    => veg_cs%deadstemc_xfer   (p) , &
+      livecrootc         => veg_cs%livecrootc      (p)    ,&
+      livecrootc_storage => veg_cs%livecrootc_storage (p) ,&
+      livecrootc_xfer    => veg_cs%livecrootc_xfer    (p) ,&
+      deadcrootc         => veg_cs%deadcrootc         (p) ,&
+      deadcrootc_storage => veg_cs%deadcrootc_storage (p) ,&
+      deadcrootc_xfer    => veg_cs%deadcrootc_xfer    (p), &
+      gresp_storage      => veg_cs%gresp_storage (p) ,&
+      gresp_xfer         => veg_cs%gresp_xfer    (p), &
+      cpool              => veg_cs%cpool         (p), &
+      xsmrpool           => veg_cs%xsmrpool      (p), &
+      ctrunc             => veg_cs%ctrunc        (p), &
+      dispvegc           => veg_cs%dispvegc      (p), &
+      storvegc           => veg_cs%storvegc      (p), &
+      totvegc            => veg_cs%totvegc       (p), &
+      totpftc            => veg_cs%totpftc       (p), &
+      grainc             => veg_cs%grainc(p)        , &
+      grainc_storage     => veg_cs%grainc_storage(p), &
+      grainc_xfer        => veg_cs%grainc_xfer(p)   , &
+      cropseedc_deficit  => veg_cs%cropseedc_deficit(p) &
       )
 
     patch_grew   = (patch_state_updater%dwt(p) > 0._r8)
@@ -144,9 +142,9 @@ contains
 
     call ComputeSeedAmounts(p                  , &
          species                    = veg_cs%species     , &
-         leaf_patch                 = leafc(p)           , &
-         leaf_storage_patch         = leafc_storage(p)   , &
-         leaf_xfer_patch            = leafc_xfer(p)      , &
+         leaf_patch                 = leafc           , &
+         leaf_storage_patch         = leafc_storage   , &
+         leaf_xfer_patch            = leafc_xfer      , &
          ! Calculations only needed for patches that grew:
          compute_here_patch         = patch_grew      , &
          ! For patches that previously had zero area, ignore the current state for the
@@ -159,67 +157,67 @@ contains
 
     ! 1) LEAFC_PATCH
     call update_patch_state(patch_state_updater,          &
-         p,c                                 , &
-         var               = leafc(p)        , &
-         flux_out_grc_area = conv_cflux      , &
+         p,c                              , &
+         var               = leafc        , &
+         flux_out_grc_area = conv_cflux            , &
          seed              = seed_leafc_patch      , &
          seed_addition     = dwt_leafc_seed    )
 
     ! 2) LEAFC_STORAGE_PATCH
-    call update_patch_state(patch_state_updater ,&
-         p, c                            , & 
-         var               = leafc_storage(p)  , &
-         flux_out_grc_area = conv_cflux     , &
-         seed              = seed_leafc_storage_patch , &
+    call update_patch_state(patch_state_updater,                 &
+         p, c                            , &
+         var               = leafc_storage       , &
+         flux_out_grc_area = conv_cflux                   , &
+         seed              = seed_leafc_storage_patch     , &
          seed_addition     = dwt_leafc_seed            )
 
     ! 3) LEAF_XFER_PATCH
-    call update_patch_state(patch_state_updater, &
+    call update_patch_state(patch_state_updater,                 &
          p , c                           , &
-         var               = leafc_xfer(p) , &
-         flux_out_grc_area = conv_cflux, &
-         seed              = seed_leafc_xfer_patch , &
+         var               = leafc_xfer          , &
+         flux_out_grc_area = conv_cflux                   , &
+         seed              = seed_leafc_xfer_patch        , &
          seed_addition     = dwt_leafc_seed         )
 
     ! 4) FROOTC_PATCH
     call update_patch_state(patch_state_updater,                 &
          p ,c               , &
-         var               = frootc(p)              , &
+         var               = frootc              , &
          flux_out_col_area = dwt_frootc_to_litter )
 
     ! 5) FROOTC_STORAGE_PATCH
     call update_patch_state(patch_state_updater,  &
          p, c                    , &
-         var               = frootc_storage(p) , &
+         var               = frootc_storage  , &
          flux_out_grc_area = conv_cflux )
 
     ! 6) FROOTC_XFER_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                       , &
-         var               = frootc_xfer(p)   , &
+         var               = frootc_xfer   , &
          flux_out_grc_area = conv_cflux )
 
     ! 7) LIVESTEMC_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                             , &
-         var               = livestemc(p)           , &
+         var               = livestemc           , &
          flux_out_grc_area = conv_cflux )
 
     ! 8) LIVESTEMC_STORAGE_PATCH
-    call update_patch_state(patch_state_updater,  &
+    call update_patch_state(patch_state_updater,                 &
          p, c                   , &
-         var               = livestemc_storage(p)   , &
+         var               = livestemc_storage   , &
          flux_out_grc_area = conv_cflux )
 
     ! 9) LIVESTEMC_XFER_PATCH
     call update_patch_state(patch_state_updater,    &
          p,c                , &
-         var               = livestemc_xfer(p)      , &
+         var               = livestemc_xfer      , &
          flux_out_grc_area = conv_cflux )
 
     ! 10) PROD10_CFLUX
     wood_product_cflux       = 0._r8
-    deadstemc_patch_temp     = deadstemc(p)
+    deadstemc_patch_temp     = deadstemc
     call update_patch_state_partition_flux_by_type(&
          patch_state_updater    ,&
          p,c             ,&
@@ -232,7 +230,7 @@ contains
 
     ! 11) PROD100_CFLUX
     wood_product_cflux       = 0._r8
-    deadstemc_patch_temp     = deadstemc(p)
+    deadstemc_patch_temp     = deadstemc
     call update_patch_state_partition_flux_by_type(&
          patch_state_updater    ,&
          p,c                   , &
@@ -250,7 +248,7 @@ contains
          p,c                   , &
          flux1_out_dest             = 'g'   , &
          flux1_fraction_by_pft_type = pconv               , &
-         var                        = deadstemc(p)  , &
+         var                        = deadstemc  , &
          flux1_out                  = conv_cflux          , &
          flux2_out                  = wood_product_cflux  , &
          seed                       = seed_deadstemc_patch, &
@@ -259,116 +257,116 @@ contains
     ! 13) DEADSTEMC_STORAGE_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                    , &
-         var               = deadstemc_storage(p)   , &
+         var               = deadstemc_storage   , &
          flux_out_grc_area = conv_cflux )
 
     ! 14) DEADSTEMC_XFER_PATCH
      call update_patch_state(patch_state_updater,                 &
          p,c                              , &
-         var               = deadstemc_xfer(p)      , &
+         var               = deadstemc_xfer      , &
          flux_out_grc_area = conv_cflux )
 
     ! 15) LIVECROOTC_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c          , &
-         var               = livecrootc(p)          , &
+         var               = livecrootc          , &
          flux_out_col_area = dwt_livecrootc_to_litter )
 
     ! 16) LIVECROOTC_STORAGE_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c      , &
-         var               = livecrootc_storage(p)  , &
+         var               = livecrootc_storage  , &
          flux_out_grc_area = conv_cflux )
 
     ! 17) LIVECROOTC_XFER_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                                   , &
-         var               = livecrootc_xfer(p)     , &
+         var               = livecrootc_xfer     , &
          flux_out_grc_area = conv_cflux )
 
     ! 18) DEADCROOTC_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                                     , &
-         var               = deadcrootc(p)          , &
+         var               = deadcrootc          , &
          flux_out_col_area = dwt_deadcrootc_to_litter )
 
     ! 19) DEADCROOTC_STORAGE_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                              , &
-         var               = deadcrootc_storage(p)  , &
+         var               = deadcrootc_storage  , &
          flux_out_grc_area = conv_cflux )
 
     ! 20) DEADCROOT_XFER_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                              , &
-         var               = deadcrootc_xfer(p)     , &
+         var               = deadcrootc_xfer     , &
          flux_out_grc_area = conv_cflux )
 
     ! 21) GRESP_STORAGE_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                              , &
-         var               = gresp_storage(p)       , &
+         var               = gresp_storage       , &
          flux_out_grc_area = conv_cflux )
 
     ! 22) GRESP_XFER_STORAGE
     call update_patch_state(patch_state_updater,                 &
          p,c                             , &
-         var               = gresp_xfer(p)          , &
+         var               = gresp_xfer          , &
          flux_out_grc_area = conv_cflux )
 
     ! 23) CPOOL_PATCH
-    call update_patch_state(patch_state_updater ,&
+    call update_patch_state(patch_state_updater,                 &
          p,c                            , &
-         var               = cpool(p)   , &
+         var               = cpool               , &
          flux_out_grc_area = conv_cflux )
 
     ! 24) XSMRPOOL_PATCH
     call update_patch_state(patch_state_updater,                 &
-         p,c                             , &
-         var               = xsmrpool(p) , &
+         p,c                              , &
+         var               = xsmrpool            , &
          flux_out_grc_area = conv_cflux )
 
     ! 25) CTRUNC_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                         , &
-         var               = ctrunc(p) , &
+         var               = ctrunc              , &
          flux_out_grc_area = conv_cflux )
 
     ! 26) DISPVEGC_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                   , &
-         var               = dispvegc(p) )
+         var               = dispvegc )
 
     ! 27) STORVEGC_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                     , &
-         var               = storvegc(p) )
+         var               = storvegc )
 
     ! 28) TOTVEGC_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                               , &
-         var               = totvegc(p) )
+         var               = totvegc )
 
     ! 29) TOTPFTC_PATCH
     call update_patch_state(patch_state_updater,                 &
          p,c                     , &
-         var               = totpftc(p) )
+         var               = totpftc )
 
     if (use_crop) then
 
       call update_patch_state(patch_state_updater, &
            p,c               ,&
-           var = grainc(p)               , &
+           var = grainc               , &
            flux_out_col_area = crop_product_cflux)
 
       call update_patch_state(patch_state_updater, &
            p,c               ,&
-           var = grainc_storage(p)  , &
+           var = grainc_storage        , &
            flux_out_grc_area = conv_cflux)
 
       call update_patch_state(patch_state_updater, &
            p,c               ,&
-           var = grainc_xfer(p) , &
+           var = grainc_xfer , &
            flux_out_grc_area = conv_cflux)
        !============================================================!
 
@@ -376,7 +374,7 @@ contains
        ! of the atmosphere.
        call update_patch_state(patch_state_updater,                 &
             p,c               ,&
-            var = cropseedc_deficit(p)  , &
+            var = cropseedc_deficit  , &
             flux_out_grc_area = conv_cflux )
 
     end if
@@ -390,29 +388,25 @@ contains
   end subroutine dyn_veg_cs_Adjustments
 
   !-----------------------------------------------------------------------
-  subroutine dyn_col_cs_Adjustments(proc_begc,proc_endc, nclumps, column_state_updater, col_cs)
+  subroutine dyn_col_cs_Adjustments(bounds, clump_index, column_state_updater, col_cs)
     !
     ! !DESCRIPTION:
     ! Adjust column-level carbon state variables and compute associated fluxes
     ! when patch areas change due to dynamic landuse
     !
     ! !USES:
-    use decompMod, only :  get_clump_bounds_gpu
-    use elm_varctl, only : iulog 
-    use dynUpdateModAcc , only : update_column_state_no_special_handling_acc
     !
     ! !ARGUMENTS:
-    integer                         , intent(in)   :: proc_begc, proc_endc, nclumps
+      !$acc routine seq
+    type(bounds_type)               , intent(in)    :: bounds
+    integer                         , intent(in)    :: clump_index
     type(column_state_updater_type) , intent(in)    :: column_state_updater
     type(column_carbon_state)       , intent(inout) :: col_cs
     !
     ! !LOCAL VARIABLES:
-    type(bounds_type)        :: bounds
-    integer         :: l, j,c, nc 
+    integer         :: l, j
     integer         :: begc, endc
-    real(r8)        :: adjustment_one_level(proc_begc:proc_endc,1:nlevdecomp, 1:ndecomp_pools)
-    real(r8)        :: sum1 
-    real :: startt, stopt 
+    real(r8)        :: adjustment_one_level(bounds%begc:bounds%endc)
     !-----------------------------------------------------------------------
     associate(&
       decomp_cpools_vr    => col_cs%decomp_cpools_vr , &
@@ -421,155 +415,69 @@ contains
       prod10c   => col_cs%prod10c, &
       prod100c  => col_cs%prod100c &
       )
+    begc = bounds%begc
+    endc = bounds%endc
+
+    col_cs%dyn_cbal_adjustments(begc:endc) = 0._r8
 
-    call cpu_time(startt) 
-    !$acc enter data create(adjustment_one_level(:,:,:),sum1)
-    !$acc parallel loop independent gang vector default(present) 
-    do c = proc_begc, proc_endc
-     col_cs%dyn_cbal_adjustments(c) = 0._r8
-    end do 
-    call cpu_time(stopt)
-    !write(iulog,*) "col_cs_Adjustment::init ",(stopt-startt)*1.E+3,"ms"
-
-    call cpu_time(startt)
-    !$acc parallel loop gang independent default(present)
     do l = 1, ndecomp_pools
-      !$acc loop worker independent 
        do j = 1, nlevdecomp
-          !$acc loop vector independent private(bounds, begc,endc)
-          do nc =1, nclumps
-            if (column_state_updater%any_changes(nc)) then
-               call get_clump_bounds_gpu(nc, bounds)
-               begc = bounds%begc; endc = bounds%endc 
-               call update_column_state_no_special_handling_acc( column_state_updater , &
-                    bounds      = bounds,                                         &
-                    clump_index = nc,                                    &
-                    var         = decomp_cpools_vr(begc:endc, j, l),     &
-                    adjustment  = adjustment_one_level(begc:endc,j,l))
-            end if 
-          end do 
+          call update_column_state_no_special_handling( column_state_updater , &
+               bounds      = bounds,                                         &
+               clump_index = clump_index,                                    &
+               var         = decomp_cpools_vr(begc:endc, j, l),     &
+               adjustment  = adjustment_one_level(begc:endc))
+
+          col_cs%dyn_cbal_adjustments(begc:endc) = &
+               col_cs%dyn_cbal_adjustments(begc:endc) + &
+               adjustment_one_level(begc:endc) * dzsoi_decomp(j)
+
        end do
     end do
-    call cpu_time(stopt) 
-    !write(iulog,*) "col_cs_Adjustment::3D loop ",(stopt-startt)*1.E+3,"ms"
-
-    call cpu_time(startt) 
-     !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1)
-     do l = 1, ndecomp_pools
-          do c = proc_begc, proc_endc
-               sum1 = 0._r8
-               !$acc loop vector reduction(+:sum1)
-               do j = 1, nlevdecomp 
-                    sum1 = sum1 + adjustment_one_level(c,j,l) * dzsoi_decomp(j)
-               end do
-               col_cs%dyn_cbal_adjustments(c) = col_cs%dyn_cbal_adjustments(c) + sum1
-          end do 
-     end do
-     call cpu_time(stopt)
-    !write(iulog,*) "col_cs_Adjustment::Reduction ",(stopt-startt)*1.E+3,"ms"
-
-     call cpu_time(startt) 
-     !$acc parallel loop independent gang default(present) present(ctrunc_vr(:,:),adjustment_one_level(:,:,:)) 
-     do j = 1, nlevdecomp
-          !$acc loop vector independent private(begc,endc,bounds)
-          do nc =1, nclumps
-            if (column_state_updater%any_changes(nc)) then
-               call get_clump_bounds_gpu(nc, bounds)
-               begc = bounds%begc; endc = bounds%endc 
-
-               call update_column_state_no_special_handling_acc( column_state_updater , &
-                    bounds      = bounds,                                         &
-                    clump_index = nc,                                    &
-                    var         = ctrunc_vr(begc:endc,j),     &
-                    adjustment  = adjustment_one_level(begc:endc,j, 1))
-            end if 
-          end do 
-    end do 
-    call cpu_time(stopt) 
-    !write(iulog,*) "col_cs_Adjustment::2D loop ",(stopt-startt)*1.E+3,"ms"
-
-    call cpu_time(startt) 
-     !$acc parallel loop independent gang worker default(present) private(sum1)
-    do c = proc_begc, proc_endc
-          sum1 = 0._r8
-          !$acc loop vector reduction(+:sum1)
-          do j = 1, nlevdecomp 
-               sum1 = sum1 + adjustment_one_level(c,j,1) * dzsoi_decomp(j)
-          end do
-          col_cs%dyn_cbal_adjustments(c) = col_cs%dyn_cbal_adjustments(c) + sum1
-     end do 
-     call cpu_time(stopt)
-    !write(iulog,*) "col_cs_Adjustment::2D reduction ",(stopt-startt)*1.E+3,"ms"
-
-     call cpu_time(startt) 
-     !$acc parallel default(present)
-     !$acc loop gang vector independent private(begc,endc,bounds)
-     do nc =1, nclumps
-         if (column_state_updater%any_changes(nc)) then
-          call get_clump_bounds_gpu(nc, bounds)
-          begc = bounds%begc; endc = bounds%endc 
-
-          call update_column_state_no_special_handling_acc(column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = prod1c(begc:endc),     &
-               adjustment  = adjustment_one_level(begc:endc,1,1))
-         
-          !$acc loop seq 
-          do c = begc, endc     
-               col_cs%dyn_cbal_adjustments(c) = &
-                    col_cs%dyn_cbal_adjustments(c) + &
-                    adjustment_one_level(c,1,1)
-          end do
-         end if  
-     end do 
-
-    !$acc loop gang vector independent private(begc,endc,bounds)
-     do nc =1, nclumps
-      if (column_state_updater%any_changes(nc)) then 
-         call get_clump_bounds_gpu(nc, bounds)
-          begc = bounds%begc; endc = bounds%endc 
-
-          call update_column_state_no_special_handling_acc(column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = prod10c(begc:endc),     &
-               adjustment  = adjustment_one_level(begc:endc,1,1))
-
-          !$acc loop seq 
-          do c = begc, endc     
-               col_cs%dyn_cbal_adjustments(c) = &
-                    col_cs%dyn_cbal_adjustments(c) + &
-                    adjustment_one_level(c,1,1)
-          end do
-      end if 
-     end do 
-
-     !$acc loop gang vector independent private(begc,endc,bounds)
-     do nc =1, nclumps
-      if (column_state_updater%any_changes(nc)) then
-          call get_clump_bounds_gpu(nc, bounds)
-          begc = bounds%begc; endc = bounds%endc 
-
-          call update_column_state_no_special_handling_acc(column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = prod100c(begc:endc),     &
-               adjustment  = adjustment_one_level(begc:endc,1,1))
-
-          !$acc loop seq 
-          do c = begc, endc     
-               col_cs%dyn_cbal_adjustments(c) = &
-                    col_cs%dyn_cbal_adjustments(c) + &
-                    adjustment_one_level(c,1,1)
-          end do
-         end if 
-     end do
-     !$acc end parallel 
-     call cpu_time(stopt) 
-     
-     !$acc exit data delete(adjustment_one_level(:,:,:),sum1)
-     !write(iulog,*) "col_cs_Adjustment::Final parallel region ",(stopt-startt)*1.E+3,"ms"
+
+    do j = 1, nlevdecomp
+       call update_column_state_no_special_handling( column_state_updater , &
+            bounds      = bounds,                                         &
+            clump_index = clump_index,                                    &
+            var         = ctrunc_vr(begc:endc,j),     &
+            adjustment  = adjustment_one_level(begc:endc))
+
+       col_cs%dyn_cbal_adjustments(begc:endc) = &
+            col_cs%dyn_cbal_adjustments(begc:endc) + &
+            adjustment_one_level(begc:endc) * dzsoi_decomp(j)
+
+    end do
+
+    call update_column_state_no_special_handling( column_state_updater, &
+         bounds      = bounds,                                         &
+         clump_index = clump_index,                                    &
+         var         = prod1c(begc:endc),     &
+         adjustment  = adjustment_one_level(begc:endc))
+
+    col_cs%dyn_cbal_adjustments(begc:endc) = &
+         col_cs%dyn_cbal_adjustments(begc:endc) + &
+         adjustment_one_level(begc:endc)
+
+    call update_column_state_no_special_handling( column_state_updater, &
+         bounds      = bounds,                                         &
+         clump_index = clump_index,                                    &
+         var         = prod10c(begc:endc),     &
+         adjustment  = adjustment_one_level(begc:endc))
+
+    col_cs%dyn_cbal_adjustments(begc:endc) = &
+         col_cs%dyn_cbal_adjustments(begc:endc) + &
+         adjustment_one_level(begc:endc)
+
+    call update_column_state_no_special_handling( column_state_updater, &
+         bounds      = bounds,                                         &
+         clump_index = clump_index,                                    &
+         var         = prod100c(begc:endc),     &
+         adjustment  = adjustment_one_level(begc:endc))
+
+    col_cs%dyn_cbal_adjustments(begc:endc) = &
+         col_cs%dyn_cbal_adjustments(begc:endc) + &
+         adjustment_one_level(begc:endc)
+
     end associate
   end subroutine dyn_col_cs_Adjustments
 
@@ -631,35 +539,35 @@ contains
     real(r8)   :: deadstemn_patch_temp
     !-----------------------------------------------------------------------
     associate(&
-      leafn          => veg_ns%leafn         , &
-      leafn_storage  => veg_ns%leafn_storage , &
-      leafn_xfer     => veg_ns%leafn_xfer    , &
-      frootn         => veg_ns%frootn        , &
-      frootn_storage => veg_ns%frootn_storage, &
-      frootn_xfer    => veg_ns%frootn_xfer   , &
-      livestemn         => veg_ns%livestemn  , &
-      livestemn_storage => veg_ns%livestemn_storage  , &
-      livestemn_xfer    => veg_ns%livestemn_xfer     , &
-      deadstemn         => veg_ns%deadstemn          , &
-      deadstemn_storage => veg_ns%deadstemn_storage  , &
-      deadstemn_xfer    => veg_ns%deadstemn_xfer     , &
-      livecrootn         => veg_ns%livecrootn          , &
-      livecrootn_storage => veg_ns%livecrootn_storage  , &
-      livecrootn_xfer    => veg_ns%livecrootn_xfer     , &
-      deadcrootn         => veg_ns%deadcrootn          , &
-      deadcrootn_storage => veg_ns%deadcrootn_storage  , &
-      deadcrootn_xfer    => veg_ns%deadcrootn_xfer     , &
-      retransn           => veg_ns%retransn  , &
-      npool              => veg_ns%npool     , &
-      ntrunc             => veg_ns%ntrunc    , &
-      dispvegn           => veg_ns%dispvegn  , &
-      storvegn           => veg_ns%storvegn  , &
-      totvegn            => veg_ns%totvegn   , &
-      totpftn            => veg_ns%totpftn   , &
-      grainn             => veg_ns%grainn    , &
-      grainn_storage     => veg_ns%grainn_storage, &
-      grainn_xfer        => veg_ns%grainn_xfer   , &
-      cropseedn_deficit  => veg_ns%cropseedn_deficit &
+      leafn          => veg_ns%leafn         (p), &
+      leafn_storage  => veg_ns%leafn_storage (p), &
+      leafn_xfer     => veg_ns%leafn_xfer    (p), &
+      frootn         => veg_ns%frootn        (p), &
+      frootn_storage => veg_ns%frootn_storage(p), &
+      frootn_xfer    => veg_ns%frootn_xfer   (p), &
+      livestemn         => veg_ns%livestemn  (p), &
+      livestemn_storage => veg_ns%livestemn_storage (p) , &
+      livestemn_xfer    => veg_ns%livestemn_xfer    (p) , &
+      deadstemn         => veg_ns%deadstemn         (p) , &
+      deadstemn_storage => veg_ns%deadstemn_storage (p) , &
+      deadstemn_xfer    => veg_ns%deadstemn_xfer    (p) , &
+      livecrootn         => veg_ns%livecrootn       (p)   , &
+      livecrootn_storage => veg_ns%livecrootn_storage (p) , &
+      livecrootn_xfer    => veg_ns%livecrootn_xfer    (p) , &
+      deadcrootn         => veg_ns%deadcrootn         (p) , &
+      deadcrootn_storage => veg_ns%deadcrootn_storage (p) , &
+      deadcrootn_xfer    => veg_ns%deadcrootn_xfer    (p) , &
+      retransn           => veg_ns%retransn (p) , &
+      npool              => veg_ns%npool    (p) , &
+      ntrunc             => veg_ns%ntrunc   (p)   , &
+      dispvegn           => veg_ns%dispvegn (p) , &
+      storvegn           => veg_ns%storvegn (p) , &
+      totvegn            => veg_ns%totvegn  (p) , &
+      totpftn            => veg_ns%totpftn  (p) , &
+      grainn             => veg_ns%grainn(p)        , &
+      grainn_storage     => veg_ns%grainn_storage(p), &
+      grainn_xfer        => veg_ns%grainn_xfer(p)   , &
+      cropseedn_deficit  => veg_ns%cropseedn_deficit(p) &
       )
 
     patch_grew   = (patch_state_updater%dwt(p) > 0._r8)
@@ -667,9 +575,9 @@ contains
 
     call ComputeSeedAmounts(p           , &
          species                    = CN_SPECIES_N   , &
-         leaf_patch                 = leafn(p)          , &
-         leaf_storage_patch         = leafn_storage(p)  , &
-         leaf_xfer_patch            = leafn_xfer(p)     , &
+         leaf_patch                 = leafn          , &
+         leaf_storage_patch         = leafn_storage  , &
+         leaf_xfer_patch            = leafn_xfer     , &
          ! Calculations only needed for patches that grew:
          compute_here_patch         = patch_grew     , &
          ! For patches that previously had zero area, ignore the current state for the
@@ -685,7 +593,7 @@ contains
     ! 1) LEAFN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                                , &
-         var               = leafn(p)       , &
+         var               = leafn             , &
          flux_out_grc_area = conv_nflux        , &
          seed              = seed_leafn_patch  , &
          seed_addition     = dwt_leafn_seed   )
@@ -693,7 +601,7 @@ contains
     ! 2) LEAFN_STORAGE_PATCH
     call update_patch_state(patch_state_updater,  &
          p,c                             , &
-         var               = leafn_storage(p)   , &
+         var               = leafn_storage      , &
          flux_out_grc_area = conv_nflux         , &
          seed              = seed_leafn_storage_patch    , &
          seed_addition     = dwt_leafn_seed             )
@@ -701,7 +609,7 @@ contains
     ! 3) LEAFN_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c     , &
-         var               = leafn_xfer(p)  , &
+         var               = leafn_xfer     , &
          flux_out_grc_area = conv_nflux              , &
          seed              = seed_leafn_xfer_patch   , &
          seed_addition     = dwt_leafn_seed          )
@@ -709,42 +617,42 @@ contains
     ! 4) FROOTN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                    , &
-         var               = frootn(p)       , &
+         var               = frootn          , &
          flux_out_col_area = dwt_frootn_to_litter  )
 
     ! 5) FROOTN_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c           , &
-         var               = frootn_storage(p)    , &
+         var               = frootn_storage       , &
          flux_out_grc_area = conv_nflux    )
 
     ! 6) FROOTN_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                             , &
-         var               = frootn_xfer(p)       , &
+         var               = frootn_xfer          , &
          flux_out_grc_area = conv_nflux      )
 
     ! 7) LIVESTEMN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                                       , &
-         var               = livestemn(p)         , &
+         var               = livestemn            , &
          flux_out_grc_area = conv_nflux  )
 
     ! 8) LIVESTEMN_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                                   , &
-         var               = livestemn_storage(p) , &
+         var               = livestemn_storage    , &
          flux_out_grc_area = conv_nflux  )
 
     ! 9) LIVESTEMN_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                               , &
-         var               = livestemn_xfer(p)    , &
+         var               = livestemn_xfer       , &
          flux_out_grc_area = conv_nflux  )
 
     ! 10) PROD10_NFLUX
     wood_product_nflux        = 0._r8
-    deadstemn_patch_temp      = deadstemn(p)
+    deadstemn_patch_temp      = deadstemn
     call update_patch_state_partition_flux_by_type(patch_state_updater , &
          p,c                  , &
          flux1_out_dest = 'c'                                , &
@@ -756,7 +664,7 @@ contains
 
     ! 11) PROD100_NFLUX
     wood_product_nflux        = 0._r8
-    deadstemn_patch_temp      = deadstemn(p)
+    deadstemn_patch_temp      = deadstemn
     call update_patch_state_partition_flux_by_type(patch_state_updater , &
          p,c              , &
          flux1_out_dest = 'c'                                , &
@@ -771,120 +679,120 @@ contains
     call update_patch_state_partition_flux_by_type(patch_state_updater , &
          p,c                         , &
          flux1_out_dest = 'g'                           , &
-         flux1_fraction_by_pft_type = pconv             , &
-         var                        = deadstemn(p)      , &
-         flux1_out                  = conv_nflux           , &
-         flux2_out                  = wood_product_nflux   , &
-         seed                       = seed_deadstemn_patch , &
+         flux1_fraction_by_pft_type = pconv               , &
+         var                        = deadstemn           , &
+         flux1_out                  = conv_nflux                 , &
+         flux2_out                  = wood_product_nflux         , &
+         seed                       = seed_deadstemn_patch       , &
          seed_addition              = dwt_deadstemn_seed     )
 
     ! 13) DEADSTEMN_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c               , &
-         var               = deadstemn_storage(p)    , &
+         var               = deadstemn_storage    , &
          flux_out_grc_area = conv_nflux  )
 
     ! 14) DEADSTEMN_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c  , &
-         var               = deadstemn_xfer(p)       , &
+         var               = deadstemn_xfer       , &
          flux_out_grc_area = conv_nflux  )
 
     ! 15) LIVECROOTN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c              , &
-         var               = livecrootn(p)           , &
+         var               = livecrootn           , &
          flux_out_col_area = dwt_livecrootn_to_litter  )
 
     ! 16) LIVECROOTN_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c  , &
-         var               = livecrootn_storage(p)   , &
+         var               = livecrootn_storage   , &
          flux_out_grc_area = conv_nflux  )
 
     ! 17) LIVECROOTN_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c    , &
-         var               = livecrootn_xfer(p)      , &
+         var               = livecrootn_xfer      , &
          flux_out_grc_area = conv_nflux  )
 
     ! 18) DEADCROOTN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c    , &
-         var               = deadcrootn(p)           , &
+         var               = deadcrootn           , &
          flux_out_col_area = dwt_deadcrootn_to_litter  )
 
     ! 19) DEADCROOTN_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c          , &
-         var               = deadcrootn_storage(p)   , &
+         var               = deadcrootn_storage   , &
          flux_out_grc_area = conv_nflux  )
 
     ! 20) DEADCROOT_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c   , &
-         var               = deadcrootn_xfer(p)     , &
+         var               = deadcrootn_xfer      , &
          flux_out_grc_area = conv_nflux  )
 
     ! 21) RETRANSN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c     , &
-         var               = retransn (p)            , &
+         var               = retransn             , &
          flux_out_grc_area = conv_nflux  )
 
     ! 22) NTRUNC_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c    , &
-         var               = ntrunc(p)               , &
+         var               = ntrunc               , &
          flux_out_grc_area = conv_nflux  )
 
     ! 23) CPOOL_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c   , &
-         var               = npool(p)                , &
+         var               = npool                , &
          flux_out_grc_area = conv_nflux  )
 
     ! 24) DISPVEGN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c              , &
-         var               = dispvegn(p)  )
+         var               = dispvegn  )
 
     ! 25) STORVEGN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                         , &
-         var               = storvegn(p)  )
+         var               = storvegn  )
 
     ! 26) TOTVEGN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c   , &
-         var               = totvegn(p)  )
+         var               = totvegn  )
 
     ! 27) TOTPFTN_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c, &
-         var    = totpftn(p)  )
+         var    = totpftn  )
 
     if (use_crop) then
       call update_patch_state(patch_state_updater, &
            p,c     , &
-           var = grainn(p)     , &
+           var = grainn     , &
            flux_out_col_area = crop_product_nflux)
 
       call update_patch_state(patch_state_updater, &
            p,c           , &
-           var = grainn_storage(p)   , &
+           var = grainn_storage   , &
            flux_out_grc_area = conv_nflux)
 
       call update_patch_state(patch_state_updater, &
            p,c      , &
-           var = grainn_xfer(p) , &
+           var = grainn_xfer , &
            flux_out_grc_area = conv_nflux)
 
        ! This is a negative pool. So any deficit that we haven't repaid gets sucked out
        ! of the atmosphere.
-       call update_patch_state(patch_state_updater, &
+       call update_patch_state(patch_state_updater,       &
             p,c, &
-            var = cropseedn_deficit(p)   , &
+            var = cropseedn_deficit   , &
             flux_out_grc_area = conv_nflux  )
     end if
 
@@ -898,29 +806,28 @@ contains
   end subroutine dyn_veg_ns_Adjustments
 
   !-----------------------------------------------------------------------
-  subroutine dyn_col_ns_Adjustments(proc_begc,proc_endc, nclumps, column_state_updater, col_ns)
+  subroutine dyn_col_ns_Adjustments(bounds, clump_index, column_state_updater, col_ns)
     !
     ! !DESCRIPTION:
     ! Adjust state variables and compute associated fluxes when patch areas change due to
     ! dynamic landuse
     !
     ! !USES:
+      !$acc routine seq
+    use dynPriorWeightsMod       , only : prior_weights_type
     use landunit_varcon          , only : istsoil, istcrop
-    use dynUpdateModAcc , only : update_column_state_no_special_handling_acc
     use dynColumnStateUpdaterMod , only : column_state_updater_type
-    !
+        !
     ! !ARGUMENTS:
-    integer                         , intent(in)  :: proc_begc, proc_endc, nclumps
+    type(bounds_type)               , intent(in)    :: bounds
+    integer                         , intent(in)    :: clump_index
     type(column_state_updater_type) , intent(in)    :: column_state_updater
     type(column_nitrogen_state)     , intent(inout) :: col_ns
     !
     ! !LOCAL VARIABLES:
-    type(bounds_type) :: bounds
-    integer           :: l, j,c,nc
-    integer           :: begc, endc
-    real(r8)          :: adjustment_one_level(proc_begc:proc_endc,1:nlevdecomp, 1:ndecomp_pools)
-    real :: startt, stopt 
-    real(r8)        :: sum1 
+    integer                     :: l, j
+    integer                     :: begc, endc
+    real(r8)                    :: adjustment_one_level(bounds%begc:bounds%endc)
     !-----------------------------------------------------------------------
     associate(&
       decomp_npools_vr    => col_ns%decomp_npools_vr , &
@@ -933,181 +840,87 @@ contains
       prod100n            => col_ns%prod100n     &
       )
 
-      call cpu_time(startt) 
-    !$acc enter data create(adjustment_one_level(:,:,:),sum1)
-
-    !$acc parallel loop independent gang vector default(present) 
-    do c = proc_begc, proc_endc
-     col_ns%dyn_nbal_adjustments(c) = 0._r8
-    end do 
-    call cpu_time(stopt)
-    !write(iulog,*) "col_ps_Adjustment::init ",(stopt-startt)*1.E+3,"ms"
-
-    call cpu_time(startt)
-    !$acc parallel loop gang independent default(present) present(adjustment_one_level(:,:,:)) 
+    begc = bounds%begc
+    endc = bounds%endc
+    col_ns%dyn_nbal_adjustments(begc:endc) = 0._r8
     do l = 1, ndecomp_pools
-      !$acc loop worker independent 
        do j = 1, nlevdecomp
-          !$acc loop vector independent private(bounds, begc,endc)
-          do nc =1, nclumps
-            if (column_state_updater%any_changes(nc)) then
-               call get_clump_bounds_gpu(nc, bounds)
-               begc = bounds%begc; endc = bounds%endc 
-               
-               call update_column_state_no_special_handling_acc( column_state_updater, &
-                  bounds      = bounds,                                         &
-                  clump_index = nc,                                    &
-                  var         = decomp_npools_vr(begc:endc, j, l),     &
-                  adjustment  = adjustment_one_level(begc:endc,j,l) )
-            end if 
-         end do 
+          call update_column_state_no_special_handling(column_state_updater, &
+               bounds      = bounds,                                         &
+               clump_index = clump_index,                                    &
+               var         = decomp_npools_vr(begc:endc, j, l),     &
+               adjustment  = adjustment_one_level(begc:endc))
+
+          col_ns%dyn_nbal_adjustments(begc:endc) = &
+               col_ns%dyn_nbal_adjustments(begc:endc) + &
+               adjustment_one_level(begc:endc) * dzsoi_decomp(j)
 
        end do
     end do
 
-    call cpu_time(stopt) 
-    !write(iulog,*) "col_ps_Adjustment::3D loop ",(stopt-startt)*1.E+3,"ms"
-
-    call cpu_time(startt) 
-     !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1)
-     do l = 1, ndecomp_pools
-          do c = proc_begc, proc_endc
-               sum1 = 0._r8
-               !$acc loop vector reduction(+:sum1)
-               do j = 1, nlevdecomp 
-                    sum1 = sum1 + adjustment_one_level(c,j,l) * dzsoi_decomp(j)
-               end do
-               col_ns%dyn_nbal_adjustments(c) = col_ns%dyn_nbal_adjustments(c) + sum1
-          end do 
-     end do
-     call cpu_time(stopt)
-    !write(iulog,*) "col_ns_Adjustment::Reduction ",(stopt-startt)*1.E+3,"ms"
-
-    call cpu_time(startt) 
-
-   !$acc parallel loop independent gang default(present) present(adjustment_one_level(:,:,:))
     do j = 1, nlevdecomp
-      !$acc loop vector independent private(begc,endc,bounds)
-      do nc =1, nclumps
-        if (column_state_updater%any_changes(nc)) then
-           call get_clump_bounds_gpu(nc, bounds)
-           begc = bounds%begc; endc = bounds%endc       
-           
-           
-           call update_column_state_no_special_handling_acc(column_state_updater, &
+       call update_column_state_no_special_handling(column_state_updater, &
             bounds      = bounds,                                         &
-            clump_index = nc,                                    &
+            clump_index = clump_index,                                    &
             var         = ntrunc_vr(begc:endc,j),     &
-            adjustment  = adjustment_one_level(begc:endc,j,1))
+            adjustment  = adjustment_one_level(begc:endc))
 
+       col_ns%dyn_nbal_adjustments(begc:endc) = &
+            col_ns%dyn_nbal_adjustments(begc:endc) + &
+            adjustment_one_level(begc:endc) * dzsoi_decomp(j)
 
-       call update_column_state_no_special_handling_acc(column_state_updater, &
+
+       call update_column_state_no_special_handling(column_state_updater, &
            bounds      = bounds                          , &
-           clump_index = nc                     , &
+           clump_index = clump_index                     , &
            var         = sminn_vr(begc:endc, j), &
-           adjustment  = adjustment_one_level(begc:endc,j,2))
+           adjustment  = adjustment_one_level(begc:endc))
+
+       col_ns%dyn_nbal_adjustments(begc:endc) = &
+           col_ns%dyn_nbal_adjustments(begc:endc) + &
+           adjustment_one_level(begc:endc) * dzsoi_decomp(j)
 
-       call update_column_state_no_special_handling_acc(column_state_updater, &
+       call update_column_state_no_special_handling(column_state_updater, &
             bounds      = bounds                          , &
-            clump_index = nc                     , &
+            clump_index = clump_index                     , &
             var         = smin_nh4_vr(begc:endc, j) , &
-            adjustment  = adjustment_one_level(begc:endc,j,3))
+            adjustment  = adjustment_one_level(begc:endc))
 
-       call update_column_state_no_special_handling_acc(column_state_updater, &
+       call update_column_state_no_special_handling(column_state_updater, &
             bounds      = bounds                          , &
-            clump_index = nc                     , &
+            clump_index = clump_index                     , &
             var         = smin_no3_vr(begc:endc, j) , &
-            adjustment  = adjustment_one_level(begc:endc,j,4))
-        end if 
-      end do 
+            adjustment  = adjustment_one_level(begc:endc))
     end do
-    call cpu_time(stopt)
-    !write(iulog,*) "col_ns_Adjustment::2D loop ",(stopt-startt)*1.E+3,"ms"
-
-    call cpu_time(startt) 
-    !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1)
-    do l = 1, 4
-         do c = proc_begc, proc_endc
-              sum1 = 0._r8
-              !$acc loop vector reduction(+:sum1)
-              do j = 1, nlevdecomp 
-                   sum1 = sum1 + adjustment_one_level(c,j,l) * dzsoi_decomp(j)
-              end do
-              col_ns%dyn_nbal_adjustments(c) = col_ns%dyn_nbal_adjustments(c) + sum1
-         end do 
-    end do
-    call cpu_time(stopt)
-   !write(iulog,*) "col_ns_Adjustment::2D vr Reduction ",(stopt-startt)*1.E+3,"ms"
-
-   call cpu_time(startt) 
-     !$acc parallel default(present) present(adjustment_one_level(:,:,:))
-     !$acc loop gang vector independent private(begc,endc,bounds)
-     do nc =1, nclumps
-         if (column_state_updater%any_changes(nc)) then
-          call get_clump_bounds_gpu(nc, bounds)
-          begc = bounds%begc; endc = bounds%endc 
-
-          call update_column_state_no_special_handling_acc(column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = prod1n(begc:endc),     &
-               adjustment  = adjustment_one_level(begc:endc,1,1))
-         
-          !$acc loop seq 
-          do c = begc, endc     
-               col_ns%dyn_nbal_adjustments(c) = &
-                    col_ns%dyn_nbal_adjustments(c) + &
-                    adjustment_one_level(c,1,1)
-          end do
-         end if  
-     end do 
-
-    !$acc loop gang vector independent private(begc,endc,bounds)
-     do nc =1, nclumps
-      if (column_state_updater%any_changes(nc)) then 
-         call get_clump_bounds_gpu(nc, bounds)
-          begc = bounds%begc; endc = bounds%endc 
-
-          call update_column_state_no_special_handling_acc(column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = prod10n(begc:endc),     &
-               adjustment  = adjustment_one_level(begc:endc,1,1))
-
-          !$acc loop seq 
-          do c = begc, endc     
-               col_ns%dyn_nbal_adjustments(c) = &
-                    col_ns%dyn_nbal_adjustments(c) + &
-                    adjustment_one_level(c,1,1)
-          end do
-      end if 
-     end do 
-
-     !$acc loop gang vector independent private(begc,endc,bounds)
-     do nc =1, nclumps
-      if (column_state_updater%any_changes(nc)) then
-          call get_clump_bounds_gpu(nc, bounds)
-          begc = bounds%begc; endc = bounds%endc 
-
-          call update_column_state_no_special_handling_acc(column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = prod100n(begc:endc),     &
-               adjustment  = adjustment_one_level(begc:endc,1,1))
-
-          !$acc loop seq 
-          do c = begc, endc     
-               col_ns%dyn_nbal_adjustments(c) = &
-                    col_ns%dyn_nbal_adjustments(c) + &
-                    adjustment_one_level(c,1,1)
-          end do
-      end if 
-     end do
-     !$acc end parallel 
-     call cpu_time(stopt) 
-     
-     !$acc exit data delete(adjustment_one_level(:,:,:), sum1)
-     !write(iulog,*) "col_ns_Adjustment::Final parallel region ",(stopt-startt)*1.E+3,"ms"
+    call update_column_state_no_special_handling(column_state_updater, &
+         bounds      = bounds,                                         &
+         clump_index = clump_index,                                    &
+         var         = prod1n(begc:endc),     &
+         adjustment  = adjustment_one_level(begc:endc))
+
+    col_ns%dyn_nbal_adjustments(begc:endc) = &
+         col_ns%dyn_nbal_adjustments(begc:endc) + &
+         adjustment_one_level(begc:endc)
+
+    call update_column_state_no_special_handling(column_state_updater, &
+         bounds      = bounds,                                         &
+         clump_index = clump_index,                                    &
+         var         = prod10n(begc:endc),     &
+         adjustment  = adjustment_one_level(begc:endc))
+
+    col_ns%dyn_nbal_adjustments(begc:endc) = &
+         col_ns%dyn_nbal_adjustments(begc:endc) + &
+         adjustment_one_level(begc:endc)
+
+    call update_column_state_no_special_handling(column_state_updater, &
+         bounds      = bounds,                                         &
+         clump_index = clump_index,                                    &
+         var         = prod100n(begc:endc),     &
+         adjustment  = adjustment_one_level(begc:endc))
+
+    col_ns%dyn_nbal_adjustments(begc:endc) = &
+         col_ns%dyn_nbal_adjustments(begc:endc) + &
+         adjustment_one_level(begc:endc)
     !=======================================================!
     end associate
 
@@ -1172,44 +985,44 @@ contains
     real(r8)  :: deadstemp_patch_temp
     !-----------------------------------------------------------------------
     associate(&
-      leafp          => veg_ps%leafp         , &
-      leafp_storage  => veg_ps%leafp_storage , &
-      leafp_xfer     => veg_ps%leafp_xfer    , &
-      frootp         => veg_ps%frootp        , &
-      frootp_storage => veg_ps%frootp_storage, &
-      frootp_xfer    => veg_ps%frootp_xfer    , &
-      livestemp         => veg_ps%livestemp   , &
-      livestemp_storage => veg_ps%livestemp_storage  , &
-      livestemp_xfer    => veg_ps%livestemp_xfer     , &
-      deadstemp         => veg_ps%deadstemp          , &
-      deadstemp_storage => veg_ps%deadstemp_storage  , &
-      deadstemp_xfer    => veg_ps%deadstemp_xfer     , &
-      livecrootp         => veg_ps%livecrootp        , &
-      livecrootp_storage => veg_ps%livecrootp_storage, &
-      livecrootp_xfer    => veg_ps%livecrootp_xfer   , &
-      deadcrootp         => veg_ps%deadcrootp        , &
-      deadcrootp_storage => veg_ps%deadcrootp_storage ,&
-      deadcrootp_xfer    => veg_ps%deadcrootp_xfer   , &
-      retransp           => veg_ps%retransp  ,&
-      ppool              => veg_ps%ppool    , &
-      ptrunc             => veg_ps%ptrunc   , &
-      dispvegp           => veg_ps%dispvegp  , &
-      storvegp           => veg_ps%storvegp  , &
-      totvegp            => veg_ps%totvegp   , &
-      totpftp            => veg_ps%totpftp   , &
-      grainp             => veg_ps%grainp    , &
-      grainp_storage     => veg_ps%grainp_storage , &
-      grainp_xfer        => veg_ps%grainp_xfer    , &
-      cropseedp_deficit  => veg_ps%cropseedp_deficit &
+      leafp          => veg_ps%leafp         (p), &
+      leafp_storage  => veg_ps%leafp_storage (p), &
+      leafp_xfer     => veg_ps%leafp_xfer    (p), &
+      frootp         => veg_ps%frootp        (p)        ,&
+      frootp_storage => veg_ps%frootp_storage(p)  ,&
+      frootp_xfer    => veg_ps%frootp_xfer   (p) , &
+      livestemp         => veg_ps%livestemp  (p)              ,&
+      livestemp_storage => veg_ps%livestemp_storage  (p) ,&
+      livestemp_xfer    => veg_ps%livestemp_xfer     (p), &
+      deadstemp         => veg_ps%deadstemp          (p)       ,&
+      deadstemp_storage => veg_ps%deadstemp_storage  (p) ,&
+      deadstemp_xfer    => veg_ps%deadstemp_xfer     (p), &
+      livecrootp         => veg_ps%livecrootp        (p)   ,&
+      livecrootp_storage => veg_ps%livecrootp_storage(p) ,&
+      livecrootp_xfer    => veg_ps%livecrootp_xfer   (p), &
+      deadcrootp         => veg_ps%deadcrootp        (p)       ,&
+      deadcrootp_storage => veg_ps%deadcrootp_storage(p) ,&
+      deadcrootp_xfer    => veg_ps%deadcrootp_xfer   (p), &
+      retransp           => veg_ps%retransp (p) ,&
+      ppool              => veg_ps%ppool    (p), &
+      ptrunc             => veg_ps%ptrunc   (p)   , &
+      dispvegp           => veg_ps%dispvegp (p) , &
+      storvegp           => veg_ps%storvegp (p) , &
+      totvegp            => veg_ps%totvegp  (p) , &
+      totpftp            => veg_ps%totpftp  (p) , &
+      grainp             => veg_ps%grainp(p)        , &
+      grainp_storage     => veg_ps%grainp_storage(p), &
+      grainp_xfer        => veg_ps%grainp_xfer(p)   , &
+      cropseedp_deficit  => veg_ps%cropseedp_deficit(p) &
       )
       patch_grew   = (patch_state_updater%dwt(p) > 0._r8)
       old_weight_was_zero = (patch_state_updater%pwtgcell_old(p) == 0._r8)
 
     call ComputeSeedAmounts(p           , &
          species                    = CN_SPECIES_P , &
-         leaf_patch                 = leafp(p)               , &
-         leaf_storage_patch         = leafp_storage(p)       , &
-         leaf_xfer_patch            = leafp_xfer(p)          , &
+         leaf_patch                 = leafp               , &
+         leaf_storage_patch         = leafp_storage       , &
+         leaf_xfer_patch            = leafp_xfer          , &
          ! Calculations only needed for patches that grew:
          compute_here_patch         = patch_grew                 , &
          ! For patches that previously had zero area, ignore the current state for the
@@ -1225,7 +1038,7 @@ contains
     ! 1) LEAFP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                           , &
-         var               = leafp(p)            , &
+         var               = leafp               , &
          flux_out_grc_area = conv_pflux          , &
          seed              = seed_leafp_patch    , &
          seed_addition     = dwt_leafp_seed     )
@@ -1233,7 +1046,7 @@ contains
     ! 2) LEAFP_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                   , &
-         var               = leafp_storage(p)            , &
+         var               = leafp_storage               , &
          flux_out_grc_area = conv_pflux                  , &
          seed              = seed_leafp_storage_patch    , &
          seed_addition     = dwt_leafp_seed             )
@@ -1241,7 +1054,7 @@ contains
     ! 3) LEAFP_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                  , &
-         var               = leafp_xfer(p)       , &
+         var               = leafp_xfer       , &
          flux_out_grc_area = conv_pflux              , &
          seed              = seed_leafp_xfer_patch   , &
          seed_addition     = dwt_leafp_seed          )
@@ -1249,24 +1062,24 @@ contains
     ! 4) FROOTP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                           , &
-         var               = frootp(p)               , &
+         var               = frootp               , &
          flux_out_col_area = dwt_frootp_to_litter  )
 
     ! 5) FROOTP_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                             , &
-         var               = frootp_storage(p)       , &
+         var               = frootp_storage       , &
          flux_out_grc_area = conv_pflux  )
 
     ! 6) FROOTP_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                         , &
-         var               = frootp_xfer (p)         , &
+         var               = frootp_xfer          , &
          flux_out_grc_area = conv_pflux  )
 
     ! 7) PROD10_PFLUX
     wood_product_pflux        = 0._r8
-    deadstemp_patch_temp      = deadstemp(p)
+    deadstemp_patch_temp      = deadstemp
     call update_patch_state_partition_flux_by_type(patch_state_updater, &
          p,c                            , &
          flux1_out_dest = 'c'                                , &
@@ -1278,7 +1091,7 @@ contains
 
     ! 8) PROD100_PFLUX
     wood_product_pflux        = 0._r8
-    deadstemp_patch_temp      = deadstemp(p)
+    deadstemp_patch_temp      = deadstemp
     call update_patch_state_partition_flux_by_type(patch_state_updater, &
          p,c                          , &
          flux1_out_dest = 'c'                                , &
@@ -1294,7 +1107,7 @@ contains
          p,c       , &
          flux1_out_dest = 'g'                                , &
          flux1_fraction_by_pft_type = pconv                   , &
-         var                        = deadstemp(p)               , &
+         var                        = deadstemp               , &
          flux1_out                  = conv_pflux                 , &
          flux2_out                  = wood_product_pflux         , &
          seed                       = seed_deadstemp_patch       , &
@@ -1303,128 +1116,128 @@ contains
     ! 10) DEADSTEMP_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                     , &
-         var               = deadstemp_storage(p)    , &
+         var               = deadstemp_storage    , &
          flux_out_grc_area = conv_pflux  )
 
     ! 11) DEADSTEMP_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c            , &
-         var               = deadstemp_xfer (p)      , &
+         var               = deadstemp_xfer       , &
          flux_out_grc_area = conv_pflux  )
 
     ! 12) LIVESTEMP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c           , &
-         var               = livestemp(p)            , &
+         var               = livestemp            , &
          flux_out_grc_area = conv_pflux  )
 
     ! 13) LIVESTEMP_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                 , &
-         var               = livestemp_storage(p)    , &
+         var               = livestemp_storage    , &
          flux_out_grc_area = conv_pflux  )
 
     ! 14) LIVESTEMP_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c       , &
-         var               = livestemp_xfer(p)      , &
+         var               = livestemp_xfer       , &
          flux_out_grc_area = conv_pflux  )
 
     ! 15) LIVECROOTP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                 , &
-         var               = livecrootp(p)           , &
+         var               = livecrootp           , &
          flux_out_col_area = dwt_livecrootp_to_litter  )
 
     ! 16) LIVECROOTP_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                          , &
-         var               = livecrootp_storage(p)   , &
+         var               = livecrootp_storage   , &
          flux_out_grc_area = conv_pflux  )
 
     ! 17) LIVECROOTP_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                      , &
-         var               = livecrootp_xfer(p)      , &
+         var               = livecrootp_xfer      , &
          flux_out_grc_area = conv_pflux  )
 
     ! 18) DEADCROOTP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                             , &
-         var               = deadcrootp(p)           , &
+         var               = deadcrootp           , &
          flux_out_col_area = dwt_deadcrootp_to_litter  )
 
     ! 19) DEADCROOTP_STORAGE_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                       , &
-         var               = deadcrootp_storage(p)  , &
+         var               = deadcrootp_storage   , &
          flux_out_grc_area = conv_pflux  )
 
     ! 20) DEADCROOT_XFER_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                             , &
-         var               = deadcrootp_xfer(p)     , &
+         var               = deadcrootp_xfer      , &
          flux_out_grc_area = conv_pflux  )
 
     ! 21) RETRANSP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                     , &
-         var               = retransp(p)             , &
+         var               = retransp             , &
          flux_out_grc_area = conv_pflux  )
 
     ! 22) PTRUNC_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                           , &
-         var               = ptrunc (p)              , &
+         var               = ptrunc               , &
          flux_out_grc_area = conv_pflux  )
 
     ! 23) PPOOL_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                         , &
-         var               = ppool(p)                , &
+         var               = ppool                , &
          flux_out_grc_area = conv_pflux  )
 
     ! 24) DISPVEGP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                      , &
-         var               = dispvegp(p)  )
+         var               = dispvegp  )
 
     ! 25) STORVEGP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                    , &
-         var               = storvegp(p)  )
+         var               = storvegp  )
 
     ! 26) TOTVEGP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c             , &
-         var               = totvegp(p)  )
+         var               = totvegp  )
 
     ! 27) TOTPFTP_PATCH
     call update_patch_state(patch_state_updater,       &
          p,c                   , &
-         var               = totpftp(p)  )
+         var               = totpftp  )
 
     if (use_crop) then
       call update_patch_state(patch_state_updater, &
            p,c     , &
-           var = grainp (p)    , &
+           var = grainp     , &
            flux_out_col_area = crop_product_pflux)
 
       call update_patch_state(patch_state_updater, &
            p,c           , &
-           var = grainp_storage (p)  , &
+           var = grainp_storage   , &
            flux_out_grc_area = conv_pflux)
 
       call update_patch_state(patch_state_updater, &
            p,c      , &
-           var = grainp_xfer(p) , &
+           var = grainp_xfer , &
            flux_out_grc_area = conv_pflux)
 
        ! This is a negative pool. So any deficit that we haven't repaid gets sucked out
        ! of the atmosphere.
        call update_patch_state(patch_state_updater,       &
             p,c     , &
-            var = cropseedp_deficit(p)   , &
+            var = cropseedp_deficit   , &
             flux_out_grc_area = conv_pflux  )
     end if
 
@@ -1437,30 +1250,28 @@ contains
   end subroutine dyn_veg_ps_Adjustments
 
   !-----------------------------------------------------------------------
-  subroutine dyn_col_ps_Adjustments(proc_begc,proc_endc, nclumps,column_state_updater, col_ps)
+  subroutine dyn_col_ps_Adjustments(bounds, clump_index, column_state_updater, col_ps)
     !
     ! !DESCRIPTION:
     ! Adjust state variables and compute associated fluxes when patch areas change due to
     ! dynamic landuse
     !
     ! !USES:
+    !$acc routine seq
+    use dynPriorWeightsMod       , only : prior_weights_type
     use landunit_varcon          , only : istsoil, istcrop
     use dynColumnStateUpdaterMod , only : column_state_updater_type
-    use dynUpdateModAcc , only : update_column_state_no_special_handling_acc
-
     !
     ! !ARGUMENTS:
-    integer                         , intent(in)  :: proc_begc, proc_endc, nclumps
+    type(bounds_type)               , intent(in)    :: bounds
+    integer                         , intent(in)    :: clump_index
     type(column_state_updater_type) , intent(in)    :: column_state_updater
     type(column_phosphorus_state)   , intent(inout) :: col_ps
     !
     ! !LOCAL VARIABLES:
-    type(bounds_type)        :: bounds
-    integer           :: l, j,c,nc
+    integer           :: l, j
     integer           :: begc, endc
-    real(r8)          :: adjustment_one_level(proc_begc:proc_endc,1:nlevdecomp, 1:ndecomp_pools)
-    real :: startt, stopt 
-    real(r8)        :: sum1 
+    real(r8)          :: adjustment_one_level(bounds%begc:bounds%endc)
     !-----------------------------------------------------------------------
     associate(&
       decomp_ppools_vr    => col_ps%decomp_ppools_vr , &
@@ -1475,174 +1286,108 @@ contains
       prod100p            => col_ps%prod100p &
       )
 
-     !$acc enter data create( adjustment_one_level(:,:,:), sum1)
+    begc = bounds%begc
+    endc = bounds%endc
 
-    !$acc parallel loop independent gang vector default(present) 
-    do c = proc_begc, proc_endc
-     col_ps%dyn_pbal_adjustments(c) = 0._r8
-    end do 
-    
-    !$acc parallel loop gang independent default(present)
+    col_ps%dyn_pbal_adjustments(begc:endc) = 0._r8
     do l = 1, ndecomp_pools
-      !$acc loop worker independent 
        do j = 1, nlevdecomp
-          !$acc loop vector independent private(bounds, begc,endc)
-          do nc =1, nclumps
-            if (column_state_updater%any_changes(nc)) then
-               call get_clump_bounds_gpu(nc, bounds)
-               begc = bounds%begc; endc = bounds%endc 
-               
-               call update_column_state_no_special_handling_acc( column_state_updater, &
-                  bounds      = bounds,                                         &
-                  clump_index = nc,                                    &
-                  var         = decomp_ppools_vr(begc:endc, j, l),     &
-                  adjustment  = adjustment_one_level(begc:endc,j,l) )
-            end if 
-         end do 
+
+          call update_column_state_no_special_handling( column_state_updater, &
+               bounds      = bounds,                                         &
+               clump_index = clump_index,                                    &
+               var         = decomp_ppools_vr(begc:endc, j, l),     &
+               adjustment  = adjustment_one_level(begc:endc) )
+
+          col_ps%dyn_pbal_adjustments(begc:endc) =      &
+               col_ps%dyn_pbal_adjustments(begc:endc) + &
+               adjustment_one_level(begc:endc) * dzsoi_decomp(j)
 
        end do
     end do
 
-     !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1)
-     do l = 1, ndecomp_pools
-          do c = proc_begc, proc_endc
-               sum1 = 0._r8
-               !$acc loop vector reduction(+:sum1)
-               do j = 1, nlevdecomp 
-                    sum1 = sum1 + adjustment_one_level(c,j,l) * dzsoi_decomp(j)
-               end do
-               col_ps%dyn_pbal_adjustments(c) = col_ps%dyn_pbal_adjustments(c) + sum1
-          end do 
-     end do
-
-    !$acc parallel loop independent gang default(present)
     do j = 1, nlevdecomp
-      !$acc loop vector independent private(begc,endc,bounds)
-      do nc =1, nclumps
-        if (column_state_updater%any_changes(nc)) then
-           call get_clump_bounds_gpu(nc, bounds)
-           begc = bounds%begc; endc = bounds%endc
+       call update_column_state_no_special_handling( column_state_updater, &
+            bounds      = bounds,                                         &
+            clump_index = clump_index,                                    &
+            var         = ptrunc_vr(begc:endc,j),                &
+            adjustment  = adjustment_one_level(begc:endc))
+
+       col_ps%dyn_pbal_adjustments(begc:endc) =      &
+            col_ps%dyn_pbal_adjustments(begc:endc) + &
+            adjustment_one_level(begc:endc) * dzsoi_decomp(j)
+       call update_column_state_no_special_handling( column_state_updater, &
+            bounds      = bounds,                                         &
+            clump_index = clump_index,                                    &
+            var         = solutionp_vr(begc:endc,j),             &
+            adjustment  = adjustment_one_level(begc:endc))
 
-            call update_column_state_no_special_handling_acc( column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = ptrunc_vr(begc:endc,j),                &
-               adjustment  = adjustment_one_level(begc:endc,j,1))
-
-            call update_column_state_no_special_handling_acc( column_state_updater, &
-                 bounds      = bounds,                                         &
-                 clump_index = nc,                                    &
-                 var         = solutionp_vr(begc:endc,j),             &
-                 adjustment  = adjustment_one_level(begc:endc,j,2))
-
-            call update_column_state_no_special_handling_acc( column_state_updater, &
-                 bounds      = bounds,                                         &
-                 clump_index = nc,                                    &
-                 var         = labilep_vr(begc:endc,j),               &
-                 adjustment  = adjustment_one_level(begc:endc,j,3))
-
-            !!
-            call update_column_state_no_special_handling_acc( column_state_updater, &
-                 bounds      = bounds,                                         &
-                 clump_index = nc,                                    &
-                 var         = secondp_vr(begc:endc,j),               &
-                 adjustment  = adjustment_one_level(begc:endc,j,4))
-
-
-            call update_column_state_no_special_handling_acc( column_state_updater, &
-                 bounds      = bounds,                                         &
-                 clump_index = nc,                                    &
-                 var         = occlp_vr(begc:endc,j),               &
-                 adjustment  = adjustment_one_level(begc:endc,j,5))
-
-            call update_column_state_no_special_handling_acc( column_state_updater, &
-                 bounds      = bounds,                                         &
-                 clump_index = nc,                                    &
-                 var         = primp_vr(begc:endc,j),               &
-                 adjustment  = adjustment_one_level(begc:endc,j,5))
-        end if 
-      end do 
-    end do
+       col_ps%dyn_pbal_adjustments(begc:endc) =      &
+            col_ps%dyn_pbal_adjustments(begc:endc) + &
+            adjustment_one_level(begc:endc) * dzsoi_decomp(j)
 
-    !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1)
-    do l = 1, 4
-         do c = proc_begc, proc_endc
-              sum1 = 0._r8
-              !$acc loop vector reduction(+:sum1)
-              do j = 1, nlevdecomp 
-                   sum1 = sum1 + adjustment_one_level(c,j,l) * dzsoi_decomp(j)
-              end do
-              col_ps%dyn_pbal_adjustments(c) = col_ps%dyn_pbal_adjustments(c) + sum1
-         end do 
-    end do
-     
-    !$acc parallel default(present)
-     !$acc loop gang vector independent private(begc,endc,bounds)
-     do nc =1, nclumps
-         if (column_state_updater%any_changes(nc)) then
-          call get_clump_bounds_gpu(nc, bounds)
-          begc = bounds%begc; endc = bounds%endc 
-
-          call update_column_state_no_special_handling_acc(column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = prod1p(begc:endc),     &
-               adjustment  = adjustment_one_level(begc:endc,1,1))
-         
-          !$acc loop seq 
-          do c = begc, endc     
-               col_ps%dyn_pbal_adjustments(c) = &
-                    col_ps%dyn_pbal_adjustments(c) + &
-                    adjustment_one_level(c,1,1)
-          end do
-         end if  
-     end do 
-
-    !$acc loop gang vector independent private(begc,endc,bounds)
-     do nc =1, nclumps
-      if (column_state_updater%any_changes(nc)) then 
-         call get_clump_bounds_gpu(nc, bounds)
-          begc = bounds%begc; endc = bounds%endc 
-
-          call update_column_state_no_special_handling_acc(column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = prod10p(begc:endc),     &
-               adjustment  = adjustment_one_level(begc:endc,1,1))
-
-          !$acc loop seq 
-          do c = begc, endc     
-               col_ps%dyn_pbal_adjustments(c) = &
-                    col_ps%dyn_pbal_adjustments(c) + &
-                    adjustment_one_level(c,1,1)
-          end do
-      end if 
-     end do 
-
-     !$acc loop gang vector independent private(begc,endc,bounds)
-     do nc =1, nclumps
-      if (column_state_updater%any_changes(nc)) then
-          call get_clump_bounds_gpu(nc, bounds)
-          begc = bounds%begc; endc = bounds%endc 
-
-          call update_column_state_no_special_handling_acc(column_state_updater, &
-               bounds      = bounds,                                         &
-               clump_index = nc,                                    &
-               var         = prod100p(begc:endc),     &
-               adjustment  = adjustment_one_level(begc:endc,1,1))
-
-          !$acc loop seq 
-          do c = begc, endc     
-               col_ps%dyn_pbal_adjustments(c) = &
-                    col_ps%dyn_pbal_adjustments(c) + &
-                    adjustment_one_level(c,1,1)
-          end do
-      end if 
-     end do
-     !$acc end parallel 
-     
-     !$acc exit data delete(adjustment_one_level(:,:,:),sum1)
+       call update_column_state_no_special_handling( column_state_updater, &
+            bounds      = bounds,                                         &
+            clump_index = clump_index,                                    &
+            var         = labilep_vr(begc:endc,j),               &
+            adjustment  = adjustment_one_level(begc:endc))
+
+       col_ps%dyn_pbal_adjustments(begc:endc) =      &
+            col_ps%dyn_pbal_adjustments(begc:endc) + &
+            adjustment_one_level(begc:endc) * dzsoi_decomp(j)
+       !!
+       call update_column_state_no_special_handling( column_state_updater, &
+            bounds      = bounds,                                         &
+            clump_index = clump_index,                                    &
+            var         = secondp_vr(begc:endc,j),               &
+            adjustment  = adjustment_one_level(begc:endc))
+
+       col_ps%dyn_pbal_adjustments(begc:endc) =      &
+            col_ps%dyn_pbal_adjustments(begc:endc) + &
+            adjustment_one_level(begc:endc) * dzsoi_decomp(j)
+
+       call update_column_state_no_special_handling( column_state_updater, &
+            bounds      = bounds,                                         &
+            clump_index = clump_index,                                    &
+            var         = occlp_vr(begc:endc,j),               &
+            adjustment  = adjustment_one_level(begc:endc))
+
+       call update_column_state_no_special_handling( column_state_updater, &
+            bounds      = bounds,                                         &
+            clump_index = clump_index,                                    &
+            var         = primp_vr(begc:endc,j),               &
+            adjustment  = adjustment_one_level(begc:endc))
 
+    end do
+    call update_column_state_no_special_handling( column_state_updater, &
+         bounds      = bounds,                                         &
+         clump_index = clump_index,                                    &
+         var         = prod1p(begc:endc),     &
+         adjustment  = adjustment_one_level(begc:endc))
+
+    col_ps%dyn_pbal_adjustments(begc:endc) = &
+         col_ps%dyn_pbal_adjustments(begc:endc) + &
+         adjustment_one_level(begc:endc)
+
+    call update_column_state_no_special_handling( column_state_updater, &
+         bounds      = bounds,                                         &
+         clump_index = clump_index,                                    &
+         var         = prod10p(begc:endc),     &
+         adjustment  = adjustment_one_level(begc:endc))
+
+    col_ps%dyn_pbal_adjustments(begc:endc) = &
+         col_ps%dyn_pbal_adjustments(begc:endc) + &
+         adjustment_one_level(begc:endc)
+
+    call update_column_state_no_special_handling( column_state_updater, &
+         bounds      = bounds,                                         &
+         clump_index = clump_index,                                    &
+         var         = prod100p(begc:endc),     &
+         adjustment  = adjustment_one_level(begc:endc))
+
+    col_ps%dyn_pbal_adjustments(begc:endc) = &
+         col_ps%dyn_pbal_adjustments(begc:endc) + &
+         adjustment_one_level(begc:endc)
 
     end associate
 
diff --git a/components/elm/src/dyn_subgrid/dynSubgridControlMod.F90 b/components/elm/src/dyn_subgrid/dynSubgridControlMod.F90
index f4440a87d1..c6c1464927 100644
--- a/components/elm/src/dyn_subgrid/dynSubgridControlMod.F90
+++ b/components/elm/src/dyn_subgrid/dynSubgridControlMod.F90
@@ -34,19 +34,19 @@ module dynSubgridControlMod
   private :: check_namelist_consistency ! check consistency of namelist settings
   !
   ! !PRIVATE TYPES:
-  type, public :: dyn_subgrid_control_type
-
-     character(len=256)  :: flanduse_timeseries ! transient landuse dataset
-     logical :: do_transient_pfts   ! whether to apply transient natural PFTs from dataset
-     logical :: do_transient_crops  ! whether to apply transient crops from dataset
-     logical :: do_harvest          ! whether to apply harvest from dataset
+  type dyn_subgrid_control_type
+     private
+     character(len=fname_len) :: flanduse_timeseries = ' ' ! transient landuse dataset
+     logical :: do_transient_pfts  = .false. ! whether to apply transient natural PFTs from dataset
+     logical :: do_transient_crops = .false. ! whether to apply transient crops from dataset
+     logical :: do_harvest         = .false. ! whether to apply harvest from dataset
 
      ! The following is only meant for testing: Whether area changes are allowed at times
      ! other than the year boundary. This should only arise in some test configurations
      ! where we artificially create changes more frequently so that we can run short
      ! tests. This flag is only used for error-checking, not controlling any model
      ! behavior.
-     logical :: for_testing_allow_non_annual_changes
+     logical :: for_testing_allow_non_annual_changes = .false.
 
      ! The following is only meant for testing: If .true., set the dynbal water and
      ! energy fluxes to zero. This is needed in some tests where we have daily rather
@@ -54,19 +54,18 @@ module dynSubgridControlMod
      ! those tests, we end up with sensible heat fluxes of thousands of W m-2 or more,
      ! which causes CAM to blow up. However, note that setting it to true will break
      ! water and energy conservation!
-     logical :: for_testing_zero_dynbal_fluxes
+     logical :: for_testing_zero_dynbal_fluxes = .false.
 
-     logical  :: initialized   ! whether this object has been initialized
+     logical :: initialized        = .false. ! whether this object has been initialized
   end type dyn_subgrid_control_type
-
-  type(dyn_subgrid_control_type), public :: dyn_subgrid_control_inst
-  !$acc declare create(dyn_subgrid_control_inst)
+  
+  type(dyn_subgrid_control_type) :: dyn_subgrid_control_inst
 
   character(len=*), parameter, private :: sourcefile = &
        __FILE__
 
 contains
-
+  
   !-----------------------------------------------------------------------
   subroutine dynSubgridControl_init( NLFilename )
     !
@@ -80,18 +79,10 @@ contains
     character(len=*), intent(in) :: NLFilename ! Namelist filename
     !
     ! !LOCAL VARIABLES:
-
+    
     character(len=*), parameter :: subname = 'dynSubgridControl_init'
     !-----------------------------------------------------------------------
-    !allocate(dyn_subgrid_control_inst%initialized            )
-    !allocate(    dyn_subgrid_control_inst%flanduse_timeseries  )
-    !allocate(    dyn_subgrid_control_inst%do_transient_pfts    )
-    !allocate(    dyn_subgrid_control_inst%do_transient_crops   )
-    !allocate(    dyn_subgrid_control_inst%do_harvest           )
-    !allocate(dyn_subgrid_control_inst%for_testing_allow_non_annual_changes)
-    !allocate(dyn_subgrid_control_inst%for_testing_zero_dynbal_fluxes      )
-
-
+    
     call read_namelist( NLFilename )
     if (masterproc) then
        call check_namelist_consistency
@@ -128,10 +119,10 @@ contains
     ! other local variables:
     integer :: nu_nml    ! unit for namelist file
     integer :: nml_error ! namelist i/o error flag
-
+    
     character(len=*), parameter :: subname = 'read_namelist'
     !-----------------------------------------------------------------------
-
+    
     namelist /dynamic_subgrid/ &
          flanduse_timeseries, &
          do_transient_pfts, &
@@ -171,12 +162,13 @@ contains
     call shr_mpi_bcast (for_testing_allow_non_annual_changes, mpicom)
     call shr_mpi_bcast (for_testing_zero_dynbal_fluxes, mpicom)
 
-    dyn_subgrid_control_inst%flanduse_timeseries = flanduse_timeseries
-    dyn_subgrid_control_inst%do_transient_pfts = do_transient_pfts
-    dyn_subgrid_control_inst%do_transient_crops = do_transient_crops
-    dyn_subgrid_control_inst%do_harvest = do_harvest
-    dyn_subgrid_control_inst%for_testing_allow_non_annual_changes = for_testing_allow_non_annual_changes
-    dyn_subgrid_control_inst%for_testing_zero_dynbal_fluxes = for_testing_zero_dynbal_fluxes
+    dyn_subgrid_control_inst = dyn_subgrid_control_type( &
+         flanduse_timeseries = flanduse_timeseries, &
+         do_transient_pfts = do_transient_pfts, &
+         do_transient_crops = do_transient_crops, &
+         do_harvest = do_harvest, &
+         for_testing_allow_non_annual_changes = for_testing_allow_non_annual_changes, &
+         for_testing_zero_dynbal_fluxes = for_testing_zero_dynbal_fluxes)
 
     if (masterproc) then
        write(iulog,*) ' '
@@ -199,10 +191,10 @@ contains
     ! !ARGUMENTS:
     !
     ! !LOCAL VARIABLES:
-
+    
     character(len=*), parameter :: subname = 'check_namelist_consistency'
     !-----------------------------------------------------------------------
-
+    
     if (dyn_subgrid_control_inst%flanduse_timeseries == ' ') then
        if (dyn_subgrid_control_inst%do_transient_pfts) then
           write(iulog,*) 'ERROR: do_transient_pfts can only be true if you are running with'
@@ -270,8 +262,8 @@ contains
     ! !DESCRIPTION:
     ! Return the value of the do_transient_pfts control flag
     !-----------------------------------------------------------------------
-    !$acc routine seq 
-    !SHR_ASSERT(dyn_subgrid_control_inst%initialized, errMsg(sourcefile, __LINE__))
+    
+    SHR_ASSERT(dyn_subgrid_control_inst%initialized, errMsg(sourcefile, __LINE__))
 
     get_do_transient_pfts = dyn_subgrid_control_inst%do_transient_pfts
 
@@ -282,7 +274,9 @@ contains
     ! !DESCRIPTION:
     ! Return the value of the do_transient_crops control flag
     !-----------------------------------------------------------------------
-    !$acc routine seq 
+    
+    SHR_ASSERT(dyn_subgrid_control_inst%initialized, errMsg(sourcefile, __LINE__))
+
     get_do_transient_crops = dyn_subgrid_control_inst%do_transient_crops
 
   end function get_do_transient_crops
@@ -292,10 +286,10 @@ contains
     ! !DESCRIPTION:
     ! Returns true if any aspects of prescribed transient landcover are enabled
     !-----------------------------------------------------------------------
-    !$acc routine seq
+
     run_has_transient_landcover = &
-         (dyn_subgrid_control_inst%do_transient_pfts .or. &
-         dyn_subgrid_control_inst%do_transient_crops)
+         (get_do_transient_pfts() .or. &
+         get_do_transient_crops())
   end function run_has_transient_landcover
 
   !-----------------------------------------------------------------------
@@ -303,7 +297,8 @@ contains
     ! !DESCRIPTION:
     ! Return the value of the do_harvest control flag
     !-----------------------------------------------------------------------
-    !$acc routine seq 
+    
+    SHR_ASSERT(dyn_subgrid_control_inst%initialized, errMsg(sourcefile, __LINE__))
 
     get_do_harvest = dyn_subgrid_control_inst%do_harvest
 
@@ -317,7 +312,8 @@ contains
     ! year boundary. (This should typically only be true for testing.) (This only
     ! controls error-checking, not any operation of the code.)
     !-----------------------------------------------------------------------
-    !$acc routine seq 
+
+    SHR_ASSERT(dyn_subgrid_control_inst%initialized, errMsg(sourcefile, __LINE__))
 
     get_for_testing_allow_non_annual_changes = dyn_subgrid_control_inst%for_testing_allow_non_annual_changes
 
@@ -325,7 +321,7 @@ contains
 
   !-----------------------------------------------------------------------
   logical function get_for_testing_zero_dynbal_fluxes()
-    !$acc routine seq
+    !
     ! !DESCRIPTION:
     ! Return true if the user has requested to set the dynbal water and energy fluxes to
     ! zero. This should typically only be true for testing: This is needed in some tests
@@ -335,6 +331,8 @@ contains
     ! true will break water and energy conservation!
     ! -----------------------------------------------------------------------
 
+    SHR_ASSERT(dyn_subgrid_control_inst%initialized, errMsg(sourcefile, __LINE__))
+
     get_for_testing_zero_dynbal_fluxes = dyn_subgrid_control_inst%for_testing_zero_dynbal_fluxes
 
   end function get_for_testing_zero_dynbal_fluxes
diff --git a/components/elm/src/dyn_subgrid/dynSubgridDriverMod.F90 b/components/elm/src/dyn_subgrid/dynSubgridDriverMod.F90
index 5a36018d67..f117a27352 100644
--- a/components/elm/src/dyn_subgrid/dynSubgridDriverMod.F90
+++ b/components/elm/src/dyn_subgrid/dynSubgridDriverMod.F90
@@ -9,13 +9,13 @@ module dynSubgridDriverMod
   ! dynamic landunits).
   !
   ! !USES:
-  use shr_kind_mod        , only : r8 => shr_kind_r8
+  use shr_kind_mod           , only : r8 => shr_kind_r8
   use dynSubgridControlMod, only : get_flanduse_timeseries
   use dynSubgridControlMod, only : get_do_transient_pfts, get_do_transient_crops
   use dynSubgridControlMod, only : get_do_harvest
   use dynPriorWeightsMod  , only : prior_weights_type
-  use dynPatchStateUpdaterMod      , only : patch_state_updater_type  !, initPatchStateUpdater, patch_state_updater 
-  use dynColumnStateUpdaterMod     , only : column_state_updater_type !, initColumnStateUpdater
+  use dynPatchStateUpdaterMod      , only : patch_state_updater_type
+  use dynColumnStateUpdaterMod     , only : column_state_updater_type
   use UrbanParamsType     , only : urbanparams_type
   use CanopyStateType     , only : canopystate_type
   use CNStateType         , only : cnstate_type
@@ -45,15 +45,21 @@ module dynSubgridDriverMod
   public :: dynSubgrid_driver           ! top-level driver for transient land cover
   public :: dynSubgrid_wrapup_weight_changes ! reconcile various variables after subgrid weights change
   !
+  ! !PRIVATE TYPES:
   ! saved weights from before the subgrid weight updates
-  type(prior_weights_type),public :: prior_weights
+  type(prior_weights_type) :: prior_weights
+
+  ! object used to update patch-level states after subgrid weight updates
+  type(patch_state_updater_type), target :: patch_state_updater
+
+  ! object used to update column-level states after subgrid weight updates
+  type(column_state_updater_type), target :: column_state_updater
   !---------------------------------------------------------------------------
-  !$acc declare create(prior_weights)
 
 contains
 
   !-----------------------------------------------------------------------
-  subroutine dynSubgrid_init(bounds, glc2lnd_vars, crop_vars, patch_state_updater, column_state_updater)
+  subroutine dynSubgrid_init(bounds, glc2lnd_vars, crop_vars)
     !
     ! !DESCRIPTION:
     ! Determine initial subgrid weights for prescribed transient Patches and/or
@@ -75,9 +81,6 @@ contains
     type(bounds_type) , intent(in)    :: bounds  ! processor-level bounds
     type(glc2lnd_type), intent(inout) :: glc2lnd_vars
     type(crop_type)   , intent(inout) :: crop_vars
-    type(patch_state_updater_type), intent(inout) :: patch_state_updater 
-    type(column_state_updater_type), intent(inout) :: column_state_updater 
-
     !
     ! !LOCAL VARIABLES:
     integer           :: nclumps      ! number of clumps on this processor
@@ -91,36 +94,36 @@ contains
     nclumps = get_proc_clumps()
 
     prior_weights        = prior_weights_type(bounds)
-    call patch_state_updater%initPatchStateUpdater( bounds) 
-    call column_state_updater%initColumnStateUpdater(bounds, nclumps)
+    patch_state_updater  = patch_state_updater_type(bounds)
+    column_state_updater = column_state_updater_type(bounds, nclumps)
 
     ! Initialize stuff for prescribed transient Patches
-     if (get_do_transient_pfts()) then
-        call dynpft_init(bounds, dynpft_filename=get_flanduse_timeseries())
-     end if
+    if (get_do_transient_pfts()) then
+       call dynpft_init(bounds, dynpft_filename=get_flanduse_timeseries())
+    end if
 
-     ! Initialize stuff for harvest (currently shares the flanduse_timeseries file)
-     if (get_do_harvest()) then
-        call dynHarvest_init(bounds, harvest_filename=get_flanduse_timeseries())
-     end if
+    ! Initialize stuff for harvest (currently shares the flanduse_timeseries file)
+    if (get_do_harvest()) then
+       call dynHarvest_init(bounds, harvest_filename=get_flanduse_timeseries())
+    end if
 
-     ! Initialize stuff for prescribed transient crops
-     if (get_do_transient_crops()) then
-        call dyncrop_init(bounds, dyncrop_filename=get_flanduse_timeseries())
-     end if
+    ! Initialize stuff for prescribed transient crops
+    if (get_do_transient_crops()) then
+       call dyncrop_init(bounds, dyncrop_filename=get_flanduse_timeseries())
+    end if
 
     ! ------------------------------------------------------------------------
     ! Set initial subgrid weights for aspects that are read from file. This is relevant
     ! for cold start and use_init_interp-based initialization.
     ! ------------------------------------------------------------------------
-    
-     if (get_do_transient_pfts()) then
-        call dynpft_interp(bounds)
-     end if
 
-     if (get_do_transient_crops()) then
-        call dyncrop_interp(bounds, crop_vars)
-     end if
+    if (get_do_transient_pfts()) then
+       call dynpft_interp(bounds)
+    end if
+
+    if (get_do_transient_crops()) then
+       call dyncrop_interp(bounds, crop_vars)
+    end if
 
     !$OMP PARALLEL DO PRIVATE (nc, bounds_clump)
     do nc = 1, nclumps
@@ -137,8 +140,7 @@ contains
        energyflux_vars, canopystate_vars, photosyns_vars, cnstate_vars, &
        veg_cs, c13_veg_cs, c14_veg_cs, &
        col_cs, c13_col_cs, c14_col_cs, col_cf, &
-       grc_cs, grc_cf, glc2lnd_vars, crop_vars,&
-       patch_state_updater, column_state_updater)
+       grc_cs, grc_cf, glc2lnd_vars, crop_vars)
     !
     ! !DESCRIPTION:
     ! Update subgrid weights for prescribed transient Patches and/or dynamic
@@ -157,9 +159,9 @@ contains
     use dynInitColumnsMod    , only : initialize_new_columns
     use dynConsBiogeophysMod , only : dyn_hwcontent_init, dyn_hwcontent_final
     use dynConsBiogeochemMod , only : dyn_cnbal_patch, dyn_cnbal_column
-    ! use dynpftFileMod        , only : dynpft_interp
+    use dynpftFileMod        , only : dynpft_interp
     use dynHarvestMod        , only : dynHarvest_interp
-    ! use dynEDMod             , only : dyn_ED
+    use dynEDMod             , only : dyn_ED
     use reweightMod          , only : reweight_wrapup
     use subgridWeightsMod    , only : compute_higher_order_weights, set_subgrid_diagnostic_fields
     use CarbonStateUpdate1Mod   , only : CarbonStateUpdateDynPatch
@@ -168,6 +170,7 @@ contains
     use dynPatchStateUpdaterMod   , only : set_old_patch_weights, set_new_patch_weights
     use dynColumnStateUpdaterMod  , only : set_old_column_weights, set_new_column_weights
     use dynPriorWeightsMod        , only : set_prior_weights
+    use clm_time_manager , only : get_step_size
     !
     ! !ARGUMENTS:
     type(bounds_type)        , intent(in)    :: bounds_proc  ! processor-level bounds
@@ -191,8 +194,7 @@ contains
     type(glc2lnd_type)       , intent(inout) :: glc2lnd_vars
 
     type(crop_type)          , intent(inout) :: crop_vars
-    type(patch_state_updater_type), intent(inout) :: patch_state_updater 
-    type(column_state_updater_type), intent(inout) :: column_state_updater 
+
     !
     ! !LOCAL VARIABLES:
     integer           :: nclumps      ! number of clumps on this processor
@@ -205,6 +207,7 @@ contains
     SHR_ASSERT(bounds_proc%level == BOUNDS_LEVEL_PROC, subname // ': argument must be PROC-level bounds')
 
     nclumps = get_proc_clumps()
+    dt = real(get_step_size(), r8)
     ! ==========================================================================
     ! Do initialization, prior to land cover change
     ! ==========================================================================
@@ -216,7 +219,8 @@ contains
        call dyn_hwcontent_init(bounds_clump, &
             filter(nc)%num_nolakec, filter(nc)%nolakec, &
             filter(nc)%num_lakec, filter(nc)%lakec, &
-            urbanparams_vars, soilstate_vars, soilhydrology_vars, lakestate_vars )
+            urbanparams_vars, soilstate_vars, soilhydrology_vars, lakestate_vars, &
+            energyflux_vars)
 
        call set_prior_weights(prior_weights, bounds_clump)
        call set_old_patch_weights  (patch_state_updater,bounds_clump)
@@ -228,17 +232,17 @@ contains
     ! Do land cover change that requires I/O, and thus must be outside a threaded region
     ! ==========================================================================
 
-    ! if (get_do_transient_pfts()) then
-    !    call dynpft_interp(bounds_proc)
-    ! end if
-    !
-    ! if (get_do_transient_crops()) then
-    !    call dyncrop_interp(bounds_proc,crop_vars)
-    ! end if
-    !
-    ! if (get_do_harvest()) then
-    !    call dynHarvest_interp(bounds_proc)
-    ! end if
+    if (get_do_transient_pfts()) then
+       call dynpft_interp(bounds_proc)
+    end if
+
+    if (get_do_transient_crops()) then
+       call dyncrop_interp(bounds_proc,crop_vars)
+    end if
+
+    if (get_do_harvest()) then
+       call dynHarvest_interp(bounds_proc)
+    end if
 
     ! ==========================================================================
     ! Do everything else related to land cover change
@@ -248,9 +252,9 @@ contains
     do nc = 1, nclumps
        call get_clump_bounds(nc, bounds_clump)
 
-       ! if (use_fates) then
-       !    call dyn_ED(bounds_clump)
-       ! end if
+       if (use_fates) then
+          call dyn_ED(bounds_clump)
+       end if
 
        if (create_glacier_mec_landunit) then
           call glc2lnd_vars%update_glc2lnd(bounds_clump)
@@ -279,7 +283,7 @@ contains
             filter(nc)%num_nolakec, filter(nc)%nolakec, &
             filter(nc)%num_lakec, filter(nc)%lakec, &
             urbanparams_vars, soilstate_vars, soilhydrology_vars, lakestate_vars, &
-            dt)
+            energyflux_vars, dt)
 
        if (use_cn) then
           call dyn_cnbal_patch(bounds_clump, &
@@ -291,15 +295,15 @@ contains
                veg_cs, c13_veg_cs, c14_veg_cs, &
                veg_ns, veg_ps, dt)
 
-          ! ! Transfer root/seed litter C/N/P to decomposer pools
-          ! call CarbonStateUpdateDynPatch(bounds_clump, &
-          !      filter_inactive_and_active(nc)%num_soilc, filter_inactive_and_active(nc)%soilc,dt)
+          ! Transfer root/seed litter C/N/P to decomposer pools
+          call CarbonStateUpdateDynPatch(bounds_clump, &
+               filter_inactive_and_active(nc)%num_soilc, filter_inactive_and_active(nc)%soilc,dt)
 
-          ! call NitrogenStateUpdateDynPatch(bounds_clump, &
-          !      filter_inactive_and_active(nc)%num_soilc, filter_inactive_and_active(nc)%soilc,dt)
+          call NitrogenStateUpdateDynPatch(bounds_clump, &
+               filter_inactive_and_active(nc)%num_soilc, filter_inactive_and_active(nc)%soilc,dt)
 
-          ! call PhosphorusStateUpdateDynPatch(bounds_clump, &
-          !      filter_inactive_and_active(nc)%num_soilc, filter_inactive_and_active(nc)%soilc,dt)
+          call PhosphorusStateUpdateDynPatch(bounds_clump, &
+               filter_inactive_and_active(nc)%num_soilc, filter_inactive_and_active(nc)%soilc,dt)
 
        end if
 
@@ -332,13 +336,15 @@ contains
     !
     ! !LOCAL VARIABLES:
 
-    !character(len=*), parameter :: subname = 'dynSubgrid_wrapup_weight_changes'
+    character(len=*), parameter :: subname = 'dynSubgrid_wrapup_weight_changes'
     !-----------------------------------------------------------------------
     associate( &
       icemask_grc => glc2lnd_vars%icemask_grc &
       )
     !SHR_ASSERT(bounds_clump%level == BOUNDS_LEVEL_CLUMP, subname // ': argument must be CLUMP-level bounds')
+
     call update_landunit_weights(bounds_clump)
+
     call compute_higher_order_weights(bounds_clump)
 
     ! Here: filters are re-made
diff --git a/components/elm/src/external_models/fates b/components/elm/src/external_models/fates
index 9387855943..3870829463 160000
--- a/components/elm/src/external_models/fates
+++ b/components/elm/src/external_models/fates
@@ -1 +1 @@
-Subproject commit 93878559435ca8dc521c0e8507bd732dc96eaf40
+Subproject commit 38708294635e62c98538e18249bbbfdbc066ada9
diff --git a/components/elm/src/external_models/sbetr b/components/elm/src/external_models/sbetr
index 1977407ee0..51be6d5f85 160000
--- a/components/elm/src/external_models/sbetr
+++ b/components/elm/src/external_models/sbetr
@@ -1 +1 @@
-Subproject commit 1977407ee0867f75e350a87d1da062644c583bd3
+Subproject commit 51be6d5f858145654d3c94c2985b3e347dd5a1d4
diff --git a/components/elm/src/main/ColumnWorkRoutinesMod.F90 b/components/elm/src/main/ColumnWorkRoutinesMod.F90
deleted file mode 100644
index 9aa5a09f92..0000000000
--- a/components/elm/src/main/ColumnWorkRoutinesMod.F90
+++ /dev/null
@@ -1,2024 +0,0 @@
-module ColumnWorkRoutinesMod
-
-   use shr_kind_mod   , only : r8 => shr_kind_r8
-   use elm_varpar     , only : ndecomp_cascade_transitions, ndecomp_pools
-   use elm_varpar     , only : nlevdecomp_full, nlevdecomp
-   use elm_varcon     , only : spval
-   use ColumnDataType , only : column_carbon_flux, column_carbon_state
-   use ColumnDataType , only : column_nitrogen_flux, column_nitrogen_state
-   use ColumnDataType , only : column_phosphorus_flux, column_phosphorus_state
-   use decompMod      , only : bounds_type
-   use CNDecompCascadeConType , only : decomp_cascade_con
-   use elm_varcon      , only : watmin, bdsno, zsoi, zisoi, dzsoi_decomp
-   use elm_varctl      , only : bound_h2osoi, use_cn, iulog, use_vertsoilc, spinup_state
-   use elm_varpar      , only : i_met_lit, i_cel_lit, i_lig_lit, i_cwd
-   use elm_varcon      , only : spval, ispval, zlnd, snw_rds_min, denice, denh2o, tfrz, pondmx
-   use elm_varctl      , only : use_erosion
-   use elm_varctl      , only : use_elm_interface, use_pflotran, pf_cmode
-   use elm_varctl      , only : hist_wrtch4diag, use_century_decomp
-   use elm_varctl      , only : get_carbontag, override_bgc_restart_mismatch_dump
-   use elm_varctl      , only : pf_hmode, nu_com
-   use ch4varcon       , only : allowlakeprod
-   use pftvarcon       , only : VMAX_MINSURF_P_vr, KM_MINSURF_P_vr
-   use soilorder_varcon, only : smax, ks_sorption
-   use elm_varctl      , only : use_fates
-   use elm_varcon      , only : secspday 
-   use ColumnDataType  , only : nfix_timeconst 
-   use shr_sys_mod ,only : shr_sys_flush 
-   use Tracer_varcon , only : is_active_betr_bgc 
-   implicit none
-   public
-   public :: col_cf_setvalues_acc 
-   public :: col_nf_setvalues_acc
-   public :: col_pf_setvalues_acc
-   public :: col_cs_summary_acc
-   public :: col_ns_summary_acc
-   public :: col_ps_summary_acc
-   public :: col_cf_summary_acc 
-   public :: col_nf_summary_acc
-   public :: col_pf_summary_acc
-   public :: col_cf_summary_for_ch4_acc
-
-contains
-
-   !-----------------------------------------------------------------------
-   subroutine col_cf_setvalues_acc( this, num_column, filter_column)
-     ! !DESCRIPTION:
-     ! Set column-level carbon fluxes
-     ! !ARGUMENTS:
-     type (column_carbon_flux) :: this
-     integer , intent(in) :: num_column
-     integer , intent(in) :: filter_column(:)
-     real(r8), parameter :: value_column=0.0_r8
-     !
-     ! !LOCAL VARIABLES:
-     integer :: fi,i,j,k,l     ! loop index
-     !------------------------------------------------------------------------
-
-     !$acc parallel loop independent gang vector default(present) collapse(2) !async(1)
-     do j = 1, nlevdecomp_full
-        do fi = 1,num_column
-           i = filter_column(fi)
-           
-           this%phenology_c_to_litr_met_c(i,j)     = value_column
-           this%phenology_c_to_litr_cel_c(i,j)     = value_column
-           this%phenology_c_to_litr_lig_c(i,j)     = value_column
-
-           this%gap_mortality_c_to_litr_met_c(i,j) = value_column
-           this%gap_mortality_c_to_litr_cel_c(i,j) = value_column
-           this%gap_mortality_c_to_litr_lig_c(i,j) = value_column
-           this%gap_mortality_c_to_cwdc(i,j)       = value_column
-
-           this%fire_mortality_c_to_cwdc(i,j)      = value_column
-           this%m_c_to_litr_met_fire(i,j)          = value_column
-           this%m_c_to_litr_cel_fire(i,j)          = value_column
-           this%m_c_to_litr_lig_fire(i,j)          = value_column
-
-           this%harvest_c_to_litr_met_c(i,j)       = value_column
-           this%harvest_c_to_litr_cel_c(i,j)       = value_column
-           this%harvest_c_to_litr_lig_c(i,j)       = value_column
-           this%harvest_c_to_cwdc(i,j)             = value_column
-
-           this%hr_vr(i,j)                         = value_column
-        end do
-     end do
-
-     !$acc parallel loop independent gang worker default(present) collapse(2) !async(2)
-     do k = 1, ndecomp_pools
-        do j = 1, nlevdecomp_full
-           !$acc loop vector independent
-           do fi = 1,num_column
-              i = filter_column(fi)
-              this%m_decomp_cpools_to_fire_vr(i,j,k) = value_column
-              this%decomp_cpools_transport_tendency(i,j,k) = value_column
-              this%decomp_cpools_yield_vr(i,j,k) = value_column
-              this%bgc_cpool_ext_inputs_vr(i,j, k) = value_column
-              this%bgc_cpool_ext_loss_vr(i,j, k) = value_column
-              this%decomp_cpools_sourcesink(i,j,k) = value_column
-
-           end do
-        end do
-     end do
-
-     !$acc parallel loop independent gang vector default(present) collapse(2) !async(3)
-     do l = 1, ndecomp_cascade_transitions
-        do fi = 1,num_column
-           i = filter_column(fi)
-           this%decomp_cascade_hr(i,l) = value_column
-           this%decomp_cascade_ctransfer(i,l) = value_column
-        end do
-     end do
-
-     !$acc parallel loop independent gang worker default(present) collapse(2) !async(4)
-     do l = 1, ndecomp_cascade_transitions
-        do j = 1, nlevdecomp_full
-           !$acc loop vector independent
-           do fi = 1,num_column
-              i = filter_column(fi)
-              this%decomp_cascade_hr_vr(i,j,l) = value_column
-              this%decomp_cascade_ctransfer_vr(i,j,l) = value_column
-              this%decomp_k(i,j,l) = value_column
-           end do
-        end do
-     end do
-
-     !$acc parallel loop independent gang vector default(present) collapse(2) !async(5)
-     do k = 1, ndecomp_pools
-        do fi = 1,num_column
-           i = filter_column(fi)
-           this%decomp_cpools_leached(i,k) = value_column
-           this%decomp_cpools_erode(i,k) = value_column
-           this%decomp_cpools_deposit(i,k) = value_column
-           this%decomp_cpools_yield(i,k) = value_column
-           this%m_decomp_cpools_to_fire(i,k) = value_column
-        end do
-     end do
-
-     !$acc parallel loop independent gang vector default(present) !async(6)
-     do fi = 1,num_column
-        i = filter_column(fi)
-
-        this%hrv_deadstemc_to_prod10c(i)  = value_column
-        this%hrv_deadstemc_to_prod100c(i) = value_column
-        this%hrv_cropc_to_prod1c(i)       = value_column
-        this%somc_fire(i)                 = value_column
-        this%prod1c_loss(i)               = value_column
-        this%prod10c_loss(i)              = value_column
-        this%prod100c_loss(i)             = value_column
-        this%product_closs(i)             = value_column
-        this%somhr(i)                     = value_column
-        this%lithr(i)                     = value_column
-        this%hr(i)                        = value_column
-        this%sr(i)                        = value_column
-        this%er(i)                        = value_column
-        this%litfire(i)                   = value_column
-        this%somfire(i)                   = value_column
-        this%totfire(i)                   = value_column
-        this%nep(i)                       = value_column
-        this%nbp(i)                       = value_column
-        this%nee(i)                       = value_column
-        this%cinputs(i)                   = value_column
-        this%coutputs(i)                  = value_column
-        this%fire_closs(i)                = value_column
-        this%cwdc_hr(i)                   = value_column
-        this%cwdc_loss(i)                 = value_column
-        this%litterc_loss(i)              = value_column
-        this%som_c_leached(i)             = value_column
-        this%somc_erode(i)                = value_column
-        this%somc_deposit(i)              = value_column
-        this%somc_yield(i)                = value_column
-
-        ! Zero p2c column fluxes
-        this%rr(i)                    = value_column
-        this%ar(i)                    = value_column
-        this%gpp(i)                   = value_column
-        this%npp(i)                   = value_column
-        this%fire_closs(i)            = value_column
-        this%litfall(i)               = value_column
-        this%vegfire(i)               = value_column
-        this%wood_harvestc(i)         = value_column
-        this%hrv_xsmrpool_to_atm(i)   = value_column
-     end do
-
-     !$acc parallel loop independent gang vector collapse(2) default(present) !async(7)
-     do j = 1, nlevdecomp_full
-        do fi = 1,num_column
-           i = filter_column(fi)
-           this%f_co2_soil_vr(i,j) = value_column
-        end do
-     end do
-     ! !$acc wait
-  end subroutine col_cf_setvalues_acc
-
-   !-----------------------------------------------------------------------
-   subroutine col_nf_setvalues_acc( this, num_column, filter_column)
-     !
-     ! !DESCRIPTION:
-     ! Set column-level nitrogen fluxes
-     ! !ARGUMENTS:
-     type (column_nitrogen_flux)  :: this
-     integer , intent(in)         :: num_column
-     integer , intent(in)         :: filter_column(:)
-     real(r8), parameter         :: value_column=0.0_r8
-     !
-     ! !LOCAL VARIABLES:
-     integer :: fi,i,j,k,l     ! loop index
-     !------------------------------------------------------------------------
-
-     !$acc parallel loop independent gang vector collapse(2) default(present) !async(1)
-     do j = 1, nlevdecomp_full
-        do fi = 1,num_column
-           i = filter_column(fi)
-
-           ! phenology: litterfall and crop fluxes associated wit
-           this%phenology_n_to_litr_met_n(i,j)        = value_column
-           this%phenology_n_to_litr_cel_n(i,j)        = value_column
-           this%phenology_n_to_litr_lig_n(i,j)        = value_column
-
-           ! gap mortality
-           this%gap_mortality_n_to_litr_met_n(i,j)    = value_column
-           this%gap_mortality_n_to_litr_cel_n(i,j)    = value_column
-           this%gap_mortality_n_to_litr_lig_n(i,j)    = value_column
-           this%gap_mortality_n_to_cwdn(i,j)          = value_column
-
-           ! fire
-           this%fire_mortality_n_to_cwdn(i,j)         = value_column
-           this%m_n_to_litr_met_fire(i,j)             = value_column
-           this%m_n_to_litr_cel_fire(i,j)             = value_column
-           this%m_n_to_litr_lig_fire(i,j)             = value_column
-
-           ! harvest
-           this%harvest_n_to_litr_met_n(i,j)          = value_column
-           this%harvest_n_to_litr_cel_n(i,j)          = value_column
-           this%harvest_n_to_litr_lig_n(i,j)          = value_column
-           this%harvest_n_to_cwdn(i,j)                = value_column
-
-           this%f_nit_vr(i,j)                      = value_column
-           this%f_denit_vr(i,j)                    = value_column
-           this%smin_no3_leached_vr(i,j)           = value_column
-           this%smin_no3_runoff_vr(i,j)            = value_column
-           this%n2_n2o_ratio_denit_vr(i,j)         = value_column
-           this%pot_f_nit_vr(i,j)                  = value_column
-           this%pot_f_denit_vr(i,j)                = value_column
-           this%actual_immob_no3_vr(i,j)           = value_column
-           this%actual_immob_nh4_vr(i,j)           = value_column
-           this%smin_no3_to_plant_vr(i,j)          = value_column
-           this%smin_nh4_to_plant_vr(i,j)          = value_column
-           this%f_n2o_denit_vr(i,j)                = value_column
-           this%f_n2o_nit_vr(i,j)                  = value_column
-
-           this%smin_no3_massdens_vr(i,j)          = value_column
-           this%k_nitr_t_vr(i,j)                   = value_column
-           this%k_nitr_ph_vr(i,j)                  = value_column
-           this%k_nitr_h2o_vr(i,j)                 = value_column
-           this%k_nitr_vr(i,j)                     = value_column
-           this%wfps_vr(i,j)                       = value_column
-           this%fmax_denit_carbonsubstrate_vr(i,j) = value_column
-           this%fmax_denit_nitrate_vr(i,j)         = value_column
-           this%f_denit_base_vr(i,j)               = value_column
-
-           this%diffus(i,j)                        = value_column
-           this%ratio_k1(i,j)                      = value_column
-           this%ratio_no3_co2(i,j)                 = value_column
-           this%soil_co2_prod(i,j)                 = value_column
-           this%fr_WFPS(i,j)                       = value_column
-           this%soil_bulkdensity(i,j)              = value_column
-
-           this%r_psi(i,j)                         = value_column
-           this%anaerobic_frac(i,j)                = value_column
-
-           ! pflotran
-           this%plant_ndemand_vr(i,j)              = value_column
-           this%f_ngas_decomp_vr(i,j)              = value_column
-           this%f_ngas_nitri_vr(i,j)               = value_column
-           this%f_ngas_denit_vr(i,j)               = value_column
-           this%f_n2o_soil_vr(i,j)                 = value_column
-           this%f_n2_soil_vr(i,j)                  = value_column
-
-           this%potential_immob_vr(i,j)               = value_column
-           this%actual_immob_vr(i,j)                  = value_column
-           this%sminn_to_plant_vr(i,j)                = value_column
-           this%supplement_to_sminn_vr(i,j)           = value_column
-           this%gross_nmin_vr(i,j)                    = value_column
-           this%net_nmin_vr(i,j)                      = value_column
-           this%sminn_nh4_input_vr(i,j)               = value_column
-           this%sminn_no3_input_vr(i,j)               = value_column
-        end do
-     end do
-
-     !$acc parallel loop independent gang vector default(present) !async(2)
-     do fi = 1,num_column
-        i = filter_column(fi)
-
-        this%ndep_to_sminn(i)             = value_column
-        this%nfix_to_sminn(i)             = value_column
-        this%nfix_to_ecosysn(i)           = value_column
-        this%fert_to_sminn(i)             = value_column
-        this%soyfixn_to_sminn(i)          = value_column
-        this%hrv_deadstemn_to_prod10n(i)  = value_column
-        this%hrv_deadstemn_to_prod100n(i) = value_column
-        this%hrv_cropn_to_prod1n(i)       = value_column
-        this%prod10n_loss(i)              = value_column
-        this%prod100n_loss(i)             = value_column
-        this%prod1n_loss(i)               = value_column
-        this%product_nloss(i)             = value_column
-        this%potential_immob(i)           = value_column
-        this%actual_immob(i)              = value_column
-        this%sminn_to_plant(i)            = value_column
-        this%supplement_to_sminn(i)       = value_column
-        this%gross_nmin(i)                = value_column
-        this%net_nmin(i)                  = value_column
-        this%denit(i)                     = value_column
-
-        this%f_nit(i)                  = value_column
-        this%pot_f_nit(i)              = value_column
-        this%f_denit(i)                = value_column
-        this%pot_f_denit(i)            = value_column
-        this%f_n2o_denit(i)            = value_column
-        this%f_n2o_nit(i)              = value_column
-        this%smin_no3_leached(i)       = value_column
-        this%smin_no3_runoff(i)        = value_column
-
-        this%f_ngas_decomp(i)         = value_column
-        this%f_ngas_nitri(i)          = value_column
-        this%f_ngas_denit(i)          = value_column
-        this%f_n2o_soil(i)            = value_column
-        this%f_n2_soil(i)             = value_column
-
-        this%smin_nh4_to_plant(i)      = value_column
-        this%smin_no3_to_plant(i)      = value_column
-
-        this%ninputs(i)                   = value_column
-        this%noutputs(i)                  = value_column
-        this%fire_nloss(i)                = value_column
-        this%som_n_leached(i)             = value_column
-        this%sminn_input(i)               = value_column
-        this%sminn_nh4_input(i)           = value_column
-        this%sminn_no3_input(i)           = value_column
-        this%somn_erode(i)                = value_column
-        this%somn_deposit(i)              = value_column
-        this%somn_yield(i)                = value_column
-        ! Zero p2c column fluxes
-        this%fire_nloss(i) = value_column
-        this%wood_harvestn(i) = value_column
-
-        ! bgc-interface
-        this%plant_ndemand(i) = value_column
-     end do
-
-     !$acc parallel loop independent gang vector collapse(2) default(present) !async(3)
-     do k = 1, ndecomp_pools
-        do fi = 1,num_column
-           i = filter_column(fi)
-           this%decomp_npools_leached(i,k) = value_column
-           this%decomp_npools_erode(i,k) = value_column
-           this%decomp_npools_deposit(i,k) = value_column
-           this%decomp_npools_yield(i,k) = value_column
-           this%m_decomp_npools_to_fire(i,k) = value_column
-           this%bgc_npool_inputs(i,k) = value_column
-        end do
-     end do
-
-     !$acc parallel loop independent gang worker collapse(2) default(present) !async(4)
-     do k = 1, ndecomp_pools
-        do j = 1, nlevdecomp_full
-           !$acc loop vector independent
-           do fi = 1,num_column
-              i = filter_column(fi)
-              this%m_decomp_npools_to_fire_vr(i,j,k) = value_column
-              this%decomp_npools_transport_tendency(i,j,k) = value_column
-              this%decomp_npools_yield_vr(i,j,k) = value_column
-              this%bgc_npool_ext_inputs_vr(i,j,k) = value_column
-              this%bgc_npool_ext_loss_vr(i,j,k) = value_column
-              this%decomp_npools_sourcesink(i,j,k) = value_column
-           end do
-        end do
-     end do
-
-     !$acc parallel loop independent gang vector collapse(2) default(present) !async(5)
-     do l = 1, ndecomp_cascade_transitions
-      do fi = 1,num_column
-         i = filter_column(fi)
-         this%decomp_cascade_ntransfer(i,l) = value_column
-         this%decomp_cascade_sminn_flux(i,l) = value_column
-      end do
-     end do
-
-      !$acc parallel loop independent gang worker collapse(2) default(present) !async(6)
-      do l = 1, ndecomp_cascade_transitions
-       do j = 1, nlevdecomp_full
-          !$acc loop vector independent
-          do fi = 1,num_column
-             i = filter_column(fi)
-             this%decomp_cascade_ntransfer_vr(i,j,l) = value_column
-             this%decomp_cascade_sminn_flux_vr(i,j,l) = value_column
-          end do
-       end do
-      end do
-
-   
-     ! !$acc wait
-
-  end subroutine col_nf_setvalues_acc
-
-   !-----------------------------------------------------------------------
-   subroutine col_pf_setvalues_acc( this, num_column, filter_column)
-     !
-     ! !DESCRIPTION:
-     ! Set phosphorus flux variables
-     ! !ARGUMENTS:
-     type (column_phosphorus_flux) :: this
-     integer , intent(in) :: num_column
-     integer , intent(in) :: filter_column(:)
-     real(r8), parameter :: value_column=0.0_r8
-     !
-     ! !LOCAL VARIABLES:
-     integer :: fi,i,j,k,l     ! loop index
-     !------------------------------------------------------------------------
-     !$acc parallel loop independent gang vector collapse(2) default(present) !async(1)
-     do j = 1, nlevdecomp_full
-        do fi = 1,num_column
-           i = filter_column(fi)
-
-           ! phenology: litterfall and crop fluxes associated wit
-           this%phenology_p_to_litr_met_p(i,j)        = value_column
-           this%phenology_p_to_litr_cel_p(i,j)        = value_column
-           this%phenology_p_to_litr_lig_p(i,j)        = value_column
-
-           ! gap mortality
-           this%gap_mortality_p_to_litr_met_p(i,j)    = value_column
-           this%gap_mortality_p_to_litr_cel_p(i,j)    = value_column
-           this%gap_mortality_p_to_litr_lig_p(i,j)    = value_column
-           this%gap_mortality_p_to_cwdp(i,j)          = value_column
-
-           ! fire
-           this%fire_mortality_p_to_cwdp(i,j)         = value_column
-           this%m_p_to_litr_met_fire(i,j)             = value_column
-           this%m_p_to_litr_cel_fire(i,j)             = value_column
-           this%m_p_to_litr_lig_fire(i,j)             = value_column
-
-           ! harvest
-           this%harvest_p_to_litr_met_p(i,j)          = value_column
-           this%harvest_p_to_litr_cel_p(i,j)          = value_column
-           this%harvest_p_to_litr_lig_p(i,j)          = value_column
-           this%harvest_p_to_cwdp(i,j)                = value_column
-
-           this%primp_to_labilep_vr(i,j)              = value_column
-           this%labilep_to_secondp_vr(i,j)            = value_column
-           this%secondp_to_labilep_vr(i,j)            = value_column
-           this%secondp_to_occlp_vr(i,j)              = value_column
-
-           this%sminp_leached_vr(i,j)                 = value_column
-
-           this%labilep_yield_vr(i,j)                 = value_column
-           this%secondp_yield_vr(i,j)                 = value_column
-           this%occlp_yield_vr(i,j)                   = value_column
-           this%primp_yield_vr(i,j)                   = value_column
-
-           this%potential_immob_p_vr(i,j)             = value_column
-           this%actual_immob_p_vr(i,j)                = value_column
-           this%sminp_to_plant_vr(i,j)                = value_column
-           this%supplement_to_sminp_vr(i,j)           = value_column
-           this%gross_pmin_vr(i,j)                    = value_column
-           this%net_pmin_vr(i,j)                      = value_column
-           this%biochem_pmin_vr(i,j)                  = value_column
-           this%biochem_pmin_to_ecosysp_vr(i,j)       = value_column
-
-           ! bgc interface & pflotran
-           this%plant_pdemand_vr(i,j)                 = value_column
-           this%adsorb_to_labilep_vr(i,j)             = value_column
-           this%desorb_to_solutionp_vr(i,j)           = value_column
-        end do
-     end do
-
-     !$acc parallel loop independent gang vector default(present) !async(2)
-     do fi = 1,num_column
-        i = filter_column(fi)
-
-        this%pdep_to_sminp(i)             = value_column
-        this%fert_p_to_sminp(i)           = value_column
-        this%hrv_deadstemp_to_prod10p(i)  = value_column
-        this%hrv_deadstemp_to_prod100p(i) = value_column
-        this%hrv_cropp_to_prod1p(i)       = value_column
-        this%prod10p_loss(i)              = value_column
-        this%prod100p_loss(i)             = value_column
-        this%product_ploss(i)             = value_column
-        this%prod1p_loss(i)               = value_column
-        this%potential_immob_p(i)         = value_column
-        this%actual_immob_p(i)            = value_column
-        this%sminp_to_plant(i)            = value_column
-        this%supplement_to_sminp(i)       = value_column
-        this%gross_pmin(i)                = value_column
-        this%net_pmin(i)                  = value_column
-        this%biochem_pmin(i)              = value_column
-        this%biochem_pmin_to_plant(i)     = value_column
-        this%primp_to_labilep(i)          = value_column
-        this%labilep_to_secondp(i)        = value_column
-        this%secondp_to_labilep(i)        = value_column
-        this%secondp_to_occlp(i)          = value_column
-        this%sminp_leached(i)             = value_column
-        this%fire_ploss(i)                = value_column
-        this%pinputs(i)                   = value_column
-        this%poutputs(i)                  = value_column
-        this%som_p_leached(i)             = value_column
-        this%somp_erode(i)                = value_column
-        this%somp_deposit(i)              = value_column
-        this%somp_yield(i)                = value_column
-        this%labilep_erode(i)             = value_column
-        this%labilep_deposit(i)           = value_column
-        this%labilep_yield(i)             = value_column
-        this%secondp_erode(i)             = value_column
-        this%secondp_deposit(i)           = value_column
-        this%secondp_yield(i)             = value_column
-        this%occlp_erode(i)               = value_column
-        this%occlp_deposit(i)             = value_column
-        this%occlp_yield(i)               = value_column
-        this%primp_erode(i)               = value_column
-        this%primp_deposit(i)             = value_column
-        this%primp_yield(i)               = value_column
-
-        ! Zero p2c column fluxes
-        this%fire_ploss(i)                = value_column
-        this%wood_harvestp(i)             = value_column
-
-        ! bgc-interface
-        this%plant_pdemand(i)             = value_column
-
-        this%fire_ploss(i)                = value_column
-        this%wood_harvestp(i)             = value_column
-
-        this%adsorb_to_labilep(i)         = value_column
-        this%desorb_to_solutionp(i)       = value_column
-
-     end do
-
-     !$acc parallel loop independent gang vector collapse(2) default(present) !async(3)
-     do k = 1, ndecomp_pools
-        do fi = 1,num_column
-           i = filter_column(fi)
-           this%decomp_ppools_leached(i,k) = value_column
-           this%decomp_ppools_erode(i,k) = value_column
-           this%decomp_ppools_deposit(i,k) = value_column
-           this%decomp_ppools_yield(i,k) = value_column
-           this%m_decomp_ppools_to_fire(i,k) = value_column
-        end do
-     end do
-
-     !$acc parallel loop independent gang worker collapse(2) default(present) !async(4)
-     do k = 1, ndecomp_pools
-        do j = 1, nlevdecomp_full
-           !$acc loop vector independent
-           do fi = 1,num_column
-              i = filter_column(fi)
-              this%m_decomp_ppools_to_fire_vr(i,j,k) = value_column
-              this%decomp_ppools_transport_tendency(i,j,k) = value_column
-              this%decomp_ppools_yield_vr(i,j,k) = value_column
-              this%decomp_ppools_sourcesink(i,j,k) = value_column
-              this%biochem_pmin_ppools_vr(i,j,k) = value_column
-
-           end do
-        end do
-     end do
-
-     !$acc parallel loop independent gang vector collapse(2) default(present) !async(5)
-     do l = 1, ndecomp_cascade_transitions
-        do fi = 1,num_column
-           i = filter_column(fi)
-           this%decomp_cascade_ptransfer(i,l) = value_column
-           this%decomp_cascade_sminp_flux(i,l) = value_column
-        end do
-     end do
-
-     !$acc parallel loop independent gang worker collapse(2) default(present) !async(6)
-     do l = 1, ndecomp_cascade_transitions
-        do j = 1, nlevdecomp_full
-           !$acc loop vector independent
-           do fi = 1,num_column
-              i = filter_column(fi)
-              this%decomp_cascade_ptransfer_vr(i,j,l) = value_column
-              this%decomp_cascade_sminp_flux_vr(i,j,l) = value_column
-           end do
-        end do
-     end do
-
-  end subroutine col_pf_setvalues_acc
-
-  !-----------------------------------------------------------------------
-  subroutine col_cs_summary_acc(this, num_soilc, filter_soilc)
-   !
-   ! !DESCRIPTION:
-   ! Column-level carbon state summary calculations
-   ! !ARGUMENTS:
-   type(column_carbon_state) :: this
-   integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
-   integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
-   !
-   ! !LOCAL VARIABLES:
-   real(r8) :: nfixlags, dtime ! temp variables for making lagged npp
-   integer  :: c,p,j,k,l       ! indices
-   integer  :: fp,fc           ! lake filter indices
-   real(r8), parameter :: maxdepth = 1._r8  ! depth to integrate soil variables
-   integer  :: nlev
-   real(r8) :: sum1, sum2, sum3
-   !-----------------------------------------------------------------------
-
-   nlev = nlevdecomp
-   if (use_pflotran .and. pf_cmode) nlev = nlevdecomp_full
-   !$acc enter data create(sum1, sum2, sum3) 
-
-   ! vertically integrate each of the decomposing C pools
-   
-   !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1) 
-   do l = 1, ndecomp_pools
-      do fc = 1,num_soilc
-         sum1 = 0.0_r8 
-         c = filter_soilc(fc)
-         !$acc loop vector reduction(+:sum1)
-         do j = 1, nlev
-            sum1 = sum1 + this%decomp_cpools_vr(c,j,l) * dzsoi_decomp(j)
-         end do
-         this%decomp_cpools(c,l) = sum1 
-      end do
-   end do
-
-   if ( nlevdecomp > 1) then
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1)
-      do l = 1, ndecomp_pools
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            sum1 = 0.0_r8 
-            !$acc loop vector reduction(+:sum1) 
-            do j = 1, nlevdecomp
-               if ( zisoi(j) <= maxdepth ) then
-                  sum1 = sum1 + this%decomp_cpools_vr(c,j,l) * dzsoi_decomp(j)
-               elseif ( zisoi(j-1) < maxdepth ) then
-                  sum1 = sum1 + this%decomp_cpools_vr(c,j,l) * (maxdepth - zisoi(j-1))
-               endif
-            end do
-            this%decomp_cpools_1m(c,l) = sum1 
-         end do
-      end do
-
-      ! total litter carbon in the top meter (TOTLITC_1m)
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0.0_r8 
-         sum2 = 0.0_r8 
-         !$acc loop vector reduction(+:sum1,sum2)
-         do l = 1, ndecomp_pools
-            ! total litter carbon in the top meter (TOTLITC_1m)
-            if ( decomp_cascade_con%is_litter(l) ) then
-               sum1 = sum1 + this%decomp_cpools_1m(c,l)
-            endif
-            ! total soil organic matter carbon in the top meter (TOTSOMC_1m)
-            if(decomp_cascade_con%is_soil(l) ) then 
-               sum2 = sum2 + this%decomp_cpools_1m(c,l)
-            end if 
-         end do
-         this%totlitc_1m(c) = sum1
-         this%totsomc_1m(c) = sum2 
-      end do
-
-   end if ! nlevdecomp>1
-
-   ! total litter carbon (TOTLITC)
-   !$acc parallel loop independent gang worker default(present) private(sum1,sum2,sum3)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0.0_r8 
-      sum2 = 0.0_r8 
-      sum3 = 0.0_r8
-      !$acc loop vector reduction(+:sum1,sum2,sum3) 
-      do l = 1, ndecomp_pools
-         ! total litter carbon (TOTLITC)
-         if ( decomp_cascade_con%is_litter(l) ) then
-            sum1 = sum1 + this%decomp_cpools(c,l)
-         endif
-         ! total soil organic matter carbon (TOTSOMC)
-         if ( decomp_cascade_con%is_soil(l) ) then
-            sum2 = sum2 + this%decomp_cpools(c,l)
-         endif
-         ! coarse woody debris carbon
-         if ( decomp_cascade_con%is_cwd(l) ) then
-            sum3 = sum3 + this%decomp_cpools(c,l)
-         end if 
-      end do
-      this%totlitc(c) = sum1
-      this%totsomc(c) = sum2 
-      this%cwdc(c)    = sum3
-   end do
-
-   ! ! total soil organic matter carbon (TOTSOMC)
-   ! truncation carbon
-   !$acc parallel loop independent gang worker default(present) private(sum1)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0.0_r8 
-      !$acc loop vector reduction(+:sum1) 
-      do j = 1, nlev
-         sum1 = sum1 + this%ctrunc_vr(c,j) * dzsoi_decomp(j)
-      end do
-      this%ctrunc(c) = sum1 
-   end do
-
-   !$acc parallel loop independent gang vector default(present) 
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-
-      ! total product carbon
-      this%totprodc(c) =      &
-           this%prod10c(c)  + &
-           this%prod100c(c) + &
-           this%prod1c(c)
-
-      ! total ecosystem carbon, including veg but excluding cpool (TOTECOSYSC)
-      this%totecosysc(c) =    &
-           this%cwdc(c)     + &
-           this%totlitc(c)  + &
-           this%totsomc(c)  + &
-           this%totprodc(c) + &
-           this%totvegc(c)
-
-      ! total column carbon, including veg and cpool (TOTCOLC)
-      ! adding col_ctrunc, seedc
-      this%totcolc(c) =       &
-           this%totpftc(c)  + &
-           this%cwdc(c)     + &
-           this%totlitc(c)  + &
-           this%totsomc(c)  + &
-           this%totprodc(c) + &
-           this%ctrunc(c)   + &
-           this%cropseedc_deficit(c)
-
-      this%totabgc(c) =       &
-           this%totprodc(c) + &
-           this%seedc(c)    + &
-           this%ctrunc(c)   + &
-           this%totpftc(c)
-   end do
-   !$acc exit data delete(sum1, sum2, sum3) 
-
- end subroutine col_cs_summary_acc
-
- !-----------------------------------------------------------------------
- subroutine col_ns_summary_acc(this, num_soilc, filter_soilc)
-   ! !ARGUMENTS:
-   type (column_nitrogen_state)  :: this
-   integer           , intent(in) :: num_soilc       ! number of soil columns in filter
-   integer           , intent(in) :: filter_soilc(:) ! filter for soil columns
-   !
-   ! !LOCAL VARIABLES:
-   integer  :: c,p,j,k,l   ! indices
-   integer  :: fp,fc       ! lake filter indices
-   real(r8), parameter :: maxdepth = 1._r8   ! depth to integrate soil variables
-   integer  :: nlev
-   real(r8) :: sum1,sum2,sum3 
-   !-----------------------------------------------------------------------
-
-   ! vertically integrate NO3 NH4 N2O pools
-   nlev = nlevdecomp
-   if (use_pflotran .and. pf_cmode) nlev = nlevdecomp_full
-   !$acc enter data create(sum1,sum2,sum3)
-
-   !$acc parallel loop gang worker independent default(present) private(sum1,sum2,sum3)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0._r8 
-      sum2 = 0._r8 
-      sum3 = 0._r8 
-      !$acc loop vector reduction(+:sum1,sum2,sum3)
-      do j = 1, nlev
-         sum1 = sum1 + this%smin_no3_vr(c,j) * dzsoi_decomp(j)
-
-         sum2 = sum2 + this%smin_nh4_vr(c,j) * dzsoi_decomp(j)
-         if(use_pflotran .and. pf_cmode) then
-            sum3 = sum3 + this%smin_nh4sorb_vr(c,j) * dzsoi_decomp(j)
-         end if
-      end do
-      this%smin_no3(c) = sum1 
-      this%smin_nh4(c) = sum2 
-      if(use_pflotran .and. pf_cmode) this%smin_nh4sorb(c) = sum3 
-   end do
-
-   ! vertically integrate each of the decomposing N pools
-   !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1)
-   do l = 1, ndecomp_pools
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1)
-         do j = 1, nlev
-            sum1 = sum1 + this%decomp_npools_vr(c,j,l) * dzsoi_decomp(j)
-         end do
-         this%decomp_npools(c,l) = sum1 
-      end do
-   end do
-
-   ! for vertically-resolved soil biogeochemistry, calculate some diagnostics of carbon pools to a given depth
-   if ( nlevdecomp > 1) then
-      ! vertically integrate each of the decomposing n pools to 1 meter
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(sum1)
-      do l = 1, ndecomp_pools
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            sum1 = 0._r8 
-            !$acc loop vector reduction(+:sum1) 
-            do j = 1, nlevdecomp
-               if ( zisoi(j) <= maxdepth ) then
-                  sum1 = sum1 + this%decomp_npools_vr(c,j,l) * dzsoi_decomp(j)
-               elseif ( zisoi(j-1) < maxdepth ) then
-                  sum1 = sum1 + this%decomp_npools_vr(c,j,l) * (maxdepth - zisoi(j-1))
-               endif
-            end do
-            this%decomp_npools_1m(c,l) = sum1  
-         end do
-      end do
-      
-      !$acc parallel loop independent gang worker  default(present) private(sum1,sum2)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0.0_r8 
-         sum2 = 0.0_r8
-         !$acc loop vector reduction(+:sum1,sum2) 
-         do l = 1, ndecomp_pools
-            ! total litter nitrogen to 1 meter (TOTLITN_1m)
-            if ( decomp_cascade_con%is_litter(l) ) then
-               sum1 = sum1 + this%decomp_npools_1m(c,l)
-            end if
-            ! total soil organic matter nitrogen to 1 meter (TOTSOMN_1m)
-            if ( decomp_cascade_con%is_soil(l) ) then
-               sum2 = sum2 + this%decomp_npools_1m(c,l)
-            end if 
-
-         end do
-         this%totlitn_1m(c) = sum1
-         this%totsomn_1m(c) = sum2 
-
-      end do
-
-   endif
-
-   ! ! total litter nitrogen (TOTLITN)
-   !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0.0_r8
-      sum2 = 0.0_r8 
-      sum3 = 0.0_r8
-      !$acc loop vector reduction(+:sum1,sum2,sum3)
-      do l = 1, ndecomp_pools
-         if ( decomp_cascade_con%is_litter(l) ) then
-            sum1 = sum1 + this%decomp_npools(c,l)
-         end if
-         if ( decomp_cascade_con%is_soil(l) ) then
-            sum2 = sum2 + this%decomp_npools(c,l)
-         end if 
-         if ( decomp_cascade_con%is_cwd(l) ) then
-            sum3 = sum3 + this%decomp_npools(c,l)
-         endif 
-      end do
-      this%totlitn(c) = sum1 
-      this%totsomn(c) = sum2 
-      this%cwdn(c)    = sum3 
-   end do
-
-   ! ! total soil organic matter nitrogen (TOTSOMN)
-   !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0.0_r8
-      sum2 = 0.0_r8
-     !$acc loop vector reduction(+:sum1,sum2)  
-      do j = 1, nlev
-         sum1 = sum1 + this%sminn_vr(c,j) * dzsoi_decomp(j)
-         sum2 = sum2 + this%ntrunc_vr(c,j) * dzsoi_decomp(j)
-      end do
-      this%sminn(c) = sum1
-      this%ntrunc(c) = sum2 
-
-   end do
-
-   ! ! total col_ntrunc
-
-   !$acc parallel loop independent gang vector default(present) 
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-
-      ! total wood product nitrogen
-      this%totprodn(c) = &
-           this%prod1n(c) + &
-           this%prod10n(c) + &
-           this%prod100n(c)
-
-      ! total ecosystem nitrogen, including veg (TOTECOSYSN)
-      this%totecosysn(c) = &
-           this%cwdn(c) + &
-           this%totlitn(c) + &
-           this%totsomn(c) + &
-           this%sminn(c) + &
-           this%totprodn(c) + &
-           this%totvegn(c)
-
-      ! total column nitrogen, including pft (TOTCOLN)
-      this%totcoln(c) = &
-           this%totpftn(c) + &
-           this%cwdn(c) + &
-           this%totlitn(c) + &
-           this%totsomn(c) + &
-           this%sminn(c) + &
-           this%totprodn(c) + &
-           this%ntrunc(c)+ &
-           this%plant_n_buffer(c) + &
-           this%cropseedn_deficit(c)
-
-      this%totabgn (c) =  &
-           this%totpftn(c) + &
-           this%totprodn(c) + &
-           this%seedn(c) + &
-           this%ntrunc(c)+ &
-           this%plant_n_buffer(c)
-
-      this%totblgn(c) = &
-           this%cwdn(c) + &
-           this%totlitn(c) + &
-           this%totsomn(c) + &
-           this%sminn(c)
-   end do
-   !$acc exit data delete(sum1,sum2,sum3)
-
- end subroutine col_ns_summary_acc
-
- !-----------------------------------------------------------------------
- subroutine col_ps_summary_acc(this, num_soilc, filter_soilc)
-   ! !ARGUMENTS:
-   type(column_phosphorus_state) :: this
-   integer           , intent(in)  :: num_soilc       ! number of soil columns in filter
-   integer           , intent(in)  :: filter_soilc(:) ! filter for soil columns
-   !
-   ! !LOCAL VARIABLES:
-   integer  :: c,j,k,l  ! indices
-   integer  :: fc       ! lake filter indices
-   real(r8), parameter :: maxdepth=1.0_r8  ! depth to integrate soil variables
-   real(r8) :: sum1, sum2, sum3, sum4, sum5 
-   !-----------------------------------------------------------------------
-
-   !$acc enter data create( sum1, sum2, sum3, sum4, sum5)
-  !$acc parallel loop independent gang vector default(present) private(sum1,sum2,sum3,sum4,sum5) 
-  do fc = 1,num_soilc
-   c = filter_soilc(fc)
-   sum1 = 0.0_r8 
-   sum2 = 0.0_r8 
-   sum3 = 0.0_r8 
-   sum4 = 0.0_r8 
-   sum5 = 0.0_r8 
-   !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5) 
-   do j = 1, nlevdecomp
-        sum1 = sum1 + this%solutionp_vr(c,j) * dzsoi_decomp(j)
-        sum2 = sum2 + this%labilep_vr(c,j) * dzsoi_decomp(j)
-        sum3 = sum3 + this%secondp_vr(c,j) * dzsoi_decomp(j)
-        sum4 = sum4 + this%occlp_vr(c,j) * dzsoi_decomp(j)
-        sum5 = sum5 + this%primp_vr(c,j) * dzsoi_decomp(j)
-     end do
-     this%solutionp(c) = sum1 
-     this%labilep(c)   = sum2 
-     this%secondp(c)   = sum3 
-     this%occlp(c)     = sum4 
-     this%primp(c)     = sum5 
-  end do
-
-  ! vertically integrate each of the decomposing P pools
-
-  !$acc parallel loop independent collapse(2) gang worker default(present) private(sum1)
-  do l = 1, ndecomp_pools
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0.0_r8 
-         !$acc loop vector reduction(+:sum1)
-         do j = 1, nlevdecomp
-           sum1 = sum1 + this%decomp_ppools_vr(c,j,l) * dzsoi_decomp(j)
-        end do
-        this%decomp_ppools(c,l) = sum1 
-     end do
-  end do
-
-  ! for vertically-resolved soil biogeochemistry, calculate some diagnostics of carbon pools to a given depth
-  if ( nlevdecomp > 1) then
-
-     ! vertically integrate each of the decomposing n pools to 1 meter
-      !$acc parallel loop independent gang worker default(present) private(sum1)
-      do l = 1, ndecomp_pools
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            sum1 = 0.0_r8 
-            !$acc loop vector reduction(+:sum1) 
-            do j = 1, nlevdecomp
-               if ( zisoi(j) <= maxdepth ) then
-                 sum1 = sum1 + this%decomp_ppools_vr(c,j,l) * dzsoi_decomp(j)
-               elseif ( zisoi(j-1) < maxdepth ) then
-                 sum1 = sum1 + this%decomp_ppools_vr(c,j,l) * (maxdepth - zisoi(j-1))
-               endif
-            end do
-            this%decomp_ppools_1m(c,l) = sum1 
-        end do
-     end do
-
-     ! total litter phosphorus to 1 meter (TOTLITN_1m)
-
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0.0_r8 
-         sum2 = 0.0_r8 
-         !$acc loop vector reduction(+:sum1) 
-         do l = 1, ndecomp_pools
-            if ( decomp_cascade_con%is_litter(l) ) then
-              sum1 = sum1 + this%decomp_ppools_1m(c,l)
-            end if
-            ! total soil organic matter phosphorus to 1 meter (TOTSOMN_1m)
-            if ( decomp_cascade_con%is_soil(l) ) then
-               sum2 = sum2 + this%decomp_ppools_1m(c,l)
-            end if 
-
-         end do
-         this%totlitp_1m(c) = sum1 
-         this%totsomp_1m(c) = sum2 
-      end do
-
-  endif
-
-  !$acc parallel loop independent gang worker default(present) private(sum1,sum2, sum3) 
-  do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0.0_r8;
-      sum2 = 0.0_r8;
-      sum3 = 0.0_r8;
-
-      !$acc loop vector reduction(+:sum1)
-      do l = 1, ndecomp_pools
-         ! total litter phosphorus (TOTLITP)
-         if ( decomp_cascade_con%is_litter(l) ) then
-           sum1 = sum1 + this%decomp_ppools(c,l)
-         end if
-         ! total soil organic matter phosphorus (TOTSOMP)
-         if ( decomp_cascade_con%is_soil(l) ) then 
-            sum2 = sum2 + this%decomp_ppools(c,l) 
-         end if 
-         ! total cwdn
-         if ( decomp_cascade_con%is_cwd(l) ) then
-            sum3 = sum3 + this%decomp_ppools(c,l)
-         end if 
-      end do
-      this%totlitp(c) = sum1 
-      this%totsomp(c) = sum2 
-      this%cwdp(c)    = sum3 
-  end do
-
-  !$acc parallel loop independent collapse(2) gang vector default(present)
-  do j = 1, nlevdecomp
-     do fc = 1,num_soilc
-        c = filter_soilc(fc)
-        this%sminp_vr(c,j) = this%solutionp_vr(c,j) + &
-                                 this%labilep_vr(c,j) + &
-                                 this%secondp_vr(c,j)
-     end do
-  end do
-
-   !$acc parallel loop independent gang worker default(present) private(sum1,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0.0_r8
-      sum2 = 0.0_r8 
-      !$acc loop vector reduction(+:sum1,sum2) 
-      do j = 1, nlevdecomp
-        sum1 = sum1 + this%sminp_vr(c,j) * dzsoi_decomp(j)
-        sum2 = sum2 + this%ptrunc_vr(c,j) * dzsoi_decomp(j)
-
-      end do
-      this%sminp(c) = sum1 
-      this%ptrunc(c) = sum2 
-   end do
-
-  ! total col_ptrunc
-
-   !$acc parallel loop independent gang vector default(present) 
-  do fc = 1,num_soilc
-     c = filter_soilc(fc)
-
-     ! total wood product phosphorus
-     this%totprodp(c) = &
-          this%prod1p(c) + &
-          this%prod10p(c) + &
-          this%prod100p(c)
-
-     ! total ecosystem phosphorus, including veg (TOTECOSYSP)
-     this%totecosysp(c) = &
-          this%cwdp(c) + &
-          this%totlitp(c) + &
-          this%totsomp(c) + &
-          this%solutionp(c) + &
-          this%labilep(c) + &
-          this%secondp(c) + &
-          this%primp(c) + &
-          this%occlp(c) + &
-          this%totprodp(c) + &
-          this%totvegp(c)
-
-     ! total column phosphorus, including pft (TOTCOLP)
-     this%totcolp(c) = &
-          this%totpftp(c) + &
-          this%cwdp(c) + &
-          this%totlitp(c) + &
-          this%totsomp(c) + &
-          this%totprodp(c) + &
-          this%solutionp(c) + &
-          this%labilep(c) + &
-          this%secondp(c) + &
-          this%ptrunc(c) + &
-          this%cropseedp_deficit(c)
-  end do
-
-  !$acc exit data delete( sum1, sum2, sum3, sum4, sum5)
-
- end subroutine col_ps_summary_acc
-
- !-----------------------------------------------------------------------
- subroutine col_cf_summary_acc(this, num_soilc, filter_soilc, isotope)
-   !
-   ! !DESCRIPTION:
-   ! column-level carbon flux summary calculations
-   !
-   use timeinfoMod , only : dtime_mod
-   ! !ARGUMENTS:
-   type(column_carbon_flux), intent(inout):: this
-   integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
-   integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
-   character(len=4)       , intent(in)    :: isotope
-   !
-   ! !LOCAL VARIABLES:
-   real(r8) :: nfixlags, dtime ! temp variables for making lagged npp
-   integer  :: c,p,j,k,l       ! indices
-   integer  :: fc              ! lake filter indices
-   real(r8) :: maxdepth        ! depth to integrate soil variables
-   integer  :: nlev
-   real(r8) :: sum1, sum2, sum3, sum4 
-   !-----------------------------------------------------------------------
-   associate(&
-        is_litter =>    decomp_cascade_con%is_litter , & ! Input:  [logical (:) ]  TRUE => pool is a litter pool
-        is_soil   =>    decomp_cascade_con%is_soil   , & ! Input:  [logical (:) ]  TRUE => pool is a soil pool
-        is_cwd    =>    decomp_cascade_con%is_cwd      & ! Input:  [logical (:) ]  TRUE => pool is a cwd pool
-        )
-
-        !$acc enter data create(sum1, sum2)
-
-   ! PET: retaining the following here during migration, but this is science code that should
-   ! really be in the NDynamics module. Flag for relocation during ELM v2 code cleanup.
-   if ( isotope == 'bulk') then
-      if (nfix_timeconst > 0._r8 .and. nfix_timeconst < 500._r8 ) then
-
-         ! this code is to calculate an exponentially-relaxed npp value for use in NDynamics code
-         nfixlags = nfix_timeconst * secspday
-
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            if ( this%lag_npp(c) /= spval ) then
-               this%lag_npp(c) = &
-                    this%lag_npp(c) * exp(-dtime_mod/nfixlags) + &
-                    this%npp(c) * (1._r8 - exp(-dtime_mod/nfixlags))
-            else
-               ! first timestep
-               this%lag_npp(c) = this%npp(c)
-            endif
-         end do
-      endif
-   endif
-   nlev = nlevdecomp
-   if (use_pflotran .and. pf_cmode) nlev = nlevdecomp_full
-
-   if ( (.not. is_active_betr_bgc           ) .and. &
-        (.not. (use_pflotran .and. pf_cmode))) then
-
-      ! vertically integrate HR and decomposition cascade fluxes
-      !$acc parallel loop independent gang worker collapse(2) default(present) private(c,sum1)
-      do k = 1, ndecomp_cascade_transitions
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            sum1 = 0._r8
-            !$acc loop vector reduction(+:sum1)
-            do j = 1,nlev
-                   sum1 = sum1 + this%decomp_cascade_ctransfer_vr(c,j,k) * dzsoi_decomp(j)
-            end do
-            this%decomp_cascade_ctransfer(c,k) = this%decomp_cascade_ctransfer(c,k) + sum1 
-         end do
-      end do
-
-
-      ! total heterotrophic respiration (HR)
-      !$acc parallel loop independent gang vector default(present) private(c)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         this%hr(c) = &
-              this%lithr(c) + &
-              this%somhr(c)
-      end do
-
-
-   endif
-
-   !$acc parallel loop independent gang worker default(present) private(c, sum1)
-   do k = 1, ndecomp_cascade_transitions
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8
-         !$acc loop vector reduction(+:sum1)
-         do j = 1,nlevdecomp
-            ! vertically integrate HR and decomposition cascade fluxes
-             sum1 = sum1 + this%decomp_cascade_hr_vr(c,j,k) * dzsoi_decomp(j)
-
-         end do
-         this%decomp_cascade_hr(c,k) = sum1; 
-      end do
-   end do
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0._r8
-      sum2 = 0._r8
-      !$acc loop vector reduction(+:sum1)
-      do k = 1, ndecomp_cascade_transitions
-         ! litter heterotrophic respiration (LITHR)
-         if ( is_litter(decomp_cascade_con%cascade_donor_pool(k)) .or. is_cwd((decomp_cascade_con%cascade_donor_pool(k)))) then
-            sum1 = sum1 + this%decomp_cascade_hr(c,k)
-         end if
-         ! soil organic matter heterotrophic respiration (SOMHR)
-         if ( is_soil(decomp_cascade_con%cascade_donor_pool(k)) ) then
-            sum2 = sum2  + this%decomp_cascade_hr(c,k)
-         end if
-      end do
-      this%lithr(c) = sum1; 
-      this%somhr(c) = sum2; 
-   end do
-
-   ! total heterotrophic respiration, vertically resolved (HR)
-   !$acc parallel loop independent gang worker default(present) private(c,sum1)
-   do j = 1,nlevdecomp
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         if (.not. (use_pflotran .and. pf_cmode)) then
-            ! pflotran has returned 'hr_vr(begc:endc,1:nlevdecomp)' to ALM before this subroutine is called in CNEcosystemDynNoLeaching2
-            sum1 = 0._r8 
-         else 
-            sum1 = this%hr_vr(c,j)
-         end if 
-         !$acc loop vector reduction(+:sum1)
-         do k = 1, ndecomp_cascade_transitions
-           sum1 = sum1 + this%decomp_cascade_hr_vr(c,j,k)
-         end do
-
-         this%hr_vr(c,j) = sum1 
-      end do
-   end do
-
-   !----------------------------------------------------------------
-   !$acc parallel loop independent gang vector default(present) 
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      ! total soil respiration, heterotrophic + root respiration (SR)
-      this%sr(c) = &
-           this%rr(c) + &
-           this%hr(c)
-
-      ! total ecosystem respiration, autotrophic + heterotrophic (ER)
-      this%er(c) = &
-           this%ar(c) + &
-           this%hr(c)
-
-      ! litter fire losses (LITFIRE)
-      this%litfire(c) = 0._r8
-
-      ! total product loss
-      this%product_closs(c) = &
-           this%prod10c_loss(c)  + &
-           this%prod100c_loss(c) + &
-           this%prod1c_loss(c)
-
-      ! soil organic matter fire losses (SOMFIRE)
-      this%somfire(c) = 0._r8
-
-      ! total ecosystem fire losses (TOTFIRE)
-      this%totfire(c) = &
-           this%litfire(c) + &
-           this%somfire(c) + &
-           this%vegfire(c)
-   end do
-
-   ! vertically integrate column-level carbon fire losses
-   !$acc parallel loop independent gang worker default(present) private(c, sum1)
-   do l = 1, ndecomp_pools
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1)
-         do j = 1,nlev
-            sum1 = sum1 + this%m_decomp_cpools_to_fire_vr(c,j,l)*dzsoi_decomp(j)
-         end do
-         this%m_decomp_cpools_to_fire(c,l) = this%m_decomp_cpools_to_fire(c,l) + sum1
-      end do
-   end do
-
-   ! column-level carbon losses to fire, including pft losses
-   !$acc parallel loop independent gang worker default(present) private(c,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum2 = this%fire_closs_p2c(c)
-      !$acc loop vector reduction(+:sum2)
-      do l = 1, ndecomp_pools
-         sum2 = sum2 + this%m_decomp_cpools_to_fire(c,l)
-      end do
-      this%fire_closs(c) = sum2
-   end do
-
-   ! column-level carbon losses to fire, including pft losses
-   !$acc parallel loop independent gang vector default(present) 
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-
-      ! column-level carbon losses due to landcover change
-      this%dwt_closs(c) = &
-           this%dwt_conv_cflux(c)
-
-      ! net ecosystem production, excludes fire flux, landcover change, and loss from wood products, positive for sink (NEP)
-      this%nep(c) = &
-           this%gpp(c) - &
-           this%er(c)
-
-      ! net biome production of carbon, includes depletion from: fire flux, landcover change flux, and loss
-      ! from wood products pools, positive for sink (NBP)
-      this%nbp(c) =             &
-           this%nep(c)        - &
-           this%fire_closs(c) - &
-           this%dwt_closs(c)  - &
-           this%product_closs(c)
-
-      ! net ecosystem exchange of carbon, includes fire flux, landcover change flux, loss
-      ! from wood products pools, and hrv_xsmrpool flux, positive for source (NEE)
-      this%nee(c) =                &
-           -this%nep(c)           + &
-           this%fire_closs(c)    + &
-           this%dwt_closs(c)     + &
-           this%product_closs(c) + &
-           this%hrv_xsmrpool_to_atm(c)
-
-      ! land use flux and land uptake
-      this%landuseflux(c) = &
-           this%dwt_closs(c) + &
-           this%product_closs(c)
-
-      this%landuptake(c) = &
-           this%nee(c) - &
-           this%landuseflux(c)
-
-      ! (cWDC_HR) - coarse woody debris heterotrophic respiration
-      if  (.not. is_active_betr_bgc) this%cwdc_hr(c) = 0._r8
-
-   end do
-
-   if  (.not. is_active_betr_bgc) then
-
-      ! (cWDC_LOSS) - coarse woody debris C loss
-      !$acc parallel loop independent gang worker default(present) private(c,sum1)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1)
-         do l = 1, ndecomp_pools
-            if ( is_cwd(l) ) then
-               sum1 = sum1 + this%m_decomp_cpools_to_fire(c,l)
-            end if
-         end do
-         this%cwdc_loss(c) = sum1 
-      end do
-
-      
-      !$acc parallel loop independent gang worker default(present) private(c,sum1)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1)
-         do k = 1, ndecomp_cascade_transitions
-            if ( is_cwd(decomp_cascade_con%cascade_donor_pool(k)) ) then
-               sum1 = sum1 + this%decomp_cascade_ctransfer(c,k)
-            end if
-         end do
-         this%cwdc_loss(c) = this%cwdc_loss(c) + sum1
-      end do
-
-      if (.not.(use_pflotran .and. pf_cmode)) then
-         ! (LITTERC_LOSS) - litter C loss
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            this%litterc_loss(c) = this%lithr(c)
-         end do
-      end if !(.not.(use_pflotran .and. pf_cmode))
-
-      !$acc parallel loop independent gang worker default(present) private(c, sum1)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         if(.not.(use_pflotran .and. pf_cmode)) then 
-            sum1 = this%lithr(c) 
-         else 
-            sum1 = this%litterc_loss(c) 
-         end if 
-         !$acc loop vector reduction(+:sum1) 
-         do l = 1, ndecomp_pools
-            if ( is_litter(l) ) then
-                sum1 = sum1 + this%m_decomp_cpools_to_fire(c,l)
-            end if
-         end do
-         this%litterc_loss(c) = sum1 
-      end do
-
-      !$acc parallel loop independent gang worker default(present) private(sum1,c)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8 
-         !$acc loop vector reduction(+:sum1) 
-         do k = 1, ndecomp_cascade_transitions
-            if ( is_litter(decomp_cascade_con%cascade_donor_pool(k)) ) then
-               sum1 = sum1 + this%decomp_cascade_ctransfer(c,k)
-            end if
-          end do
-          this%litterc_loss(c) = this%litterc_loss(c) + sum1
-      end do
-
-   end if ! .not. is_active_betr_bgc
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2)
-   do fc = 1,num_soilc
-       c = filter_soilc(fc)
-       sum1 = 0._r8
-       sum2 = 0._r8
-       !$acc loop vector reduction(+:sum1,sum2) 
-       do j = 1, nlev
-           sum1 = sum1 + &
-               this%phenology_c_to_litr_met_c(c,j)* dzsoi_decomp(j) + &
-               this%phenology_c_to_litr_cel_c(c,j)* dzsoi_decomp(j) + &
-               this%phenology_c_to_litr_lig_c(c,j)* dzsoi_decomp(j) + &
-               this%gap_mortality_c_to_litr_met_c(c,j)* dzsoi_decomp(j) + &
-               this%gap_mortality_c_to_litr_cel_c(c,j)* dzsoi_decomp(j) + &
-               this%gap_mortality_c_to_litr_lig_c(c,j)* dzsoi_decomp(j) + &
-               this%m_c_to_litr_met_fire(c,j)* dzsoi_decomp(j) + &
-               this%m_c_to_litr_cel_fire(c,j)* dzsoi_decomp(j) + &
-               this%m_c_to_litr_lig_fire(c,j)* dzsoi_decomp(j)
-           
-            sum2 = sum2 + &
-               this%gap_mortality_c_to_cwdc(c,j)* dzsoi_decomp(j) + &
-               this%fire_mortality_c_to_cwdc(c,j)* dzsoi_decomp(j)
-       end do
-       this%plant_to_litter_cflux(c) = sum1 
-       this%plant_to_cwd_cflux(c)  = sum2 
-   end do
-
-   !$acc exit data delete(sum1, sum2)
-
-   end associate
-
- end subroutine col_cf_summary_acc
-
- !-----------------------------------------------------------------------
- subroutine col_nf_summary_acc(this, num_soilc, filter_soilc)
-   !
-   ! !DESCRIPTION:
-   ! Column-level nitrogen summary calculations
-   ! !ARGUMENTS:
-   type (column_nitrogen_flux)            :: this
-   integer                , intent(in)    :: num_soilc       ! number of soil columns in filter
-   integer                , intent(in)    :: filter_soilc(:) ! filter for soil columns
-   !
-   ! !LOCAL VARIABLES:
-   integer  :: fc,c,j,k,l       ! indices
-   integer  :: nlev
-   real(r8) :: sum1, sum2, sum3,sum4,sum5,sum6,sum7,sum8 
-   !-----------------------------------------------------------------------
-
-   !$acc enter data create(sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8)
-   nlev = nlevdecomp
-   if (use_pflotran .and. pf_cmode) nlev = nlevdecomp_full
-   
-   if (  (.not. (use_pflotran .and. pf_cmode)) ) then
-      ! BeTR is off AND PFLOTRAN's pf_cmode is false
-      ! vertically integrate decomposing N cascade fluxes and
-      !soil mineral N fluxes associated with decomposition cascade
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2,c)
-      do k = 1, ndecomp_cascade_transitions
-         do fc = 1,num_soilc
-            c = filter_soilc(fc)
-            sum1 = 0._r8 
-            sum2 = 0._r8
-            !$acc loop vector reduction(+:sum1,sum2)
-            do j = 1,nlev
-               sum1 = sum1 + this%decomp_cascade_ntransfer_vr(c,j,k) * dzsoi_decomp(j)
-
-               sum2 = sum2 + this%decomp_cascade_sminn_flux_vr(c,j,k) * dzsoi_decomp(j)
-            end do
-            this%decomp_cascade_ntransfer(c,k) = this%decomp_cascade_ntransfer(c,k) + sum1
-            this%decomp_cascade_sminn_flux(c,k)= this%decomp_cascade_sminn_flux(c,k) + sum2
-         end do
-      end do
-
-      ! vertically integrate NO3 NH4 N2O fluxes and pools
-      !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1=0._r8;sum2=0._r8
-         sum3=0._r8;sum4=0._r8;
-         sum5=0._r8;sum6=0._r8;
-         sum7=0._r8;sum8=0._r8;
-
-         !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8)
-         do j = 1, nlev
-
-            ! nitrification and denitrification fluxes
-            sum1 = sum1 + this%f_nit_vr(c,j) * dzsoi_decomp(j)
-            sum2 = sum2 + this%f_denit_vr(c,j) * dzsoi_decomp(j)
-            sum3 = sum3 + this%pot_f_nit_vr(c,j) * dzsoi_decomp(j)
-            sum4 = sum4 + this%pot_f_denit_vr(c,j) * dzsoi_decomp(j)
-            sum5 = sum5 + this%f_n2o_nit_vr(c,j) * dzsoi_decomp(j)
-            sum6 = sum6 + this%f_n2o_denit_vr(c,j) * dzsoi_decomp(j)
-            ! leaching/runoff flux
-            sum7 = sum7 + this%smin_no3_leached_vr(c,j) * dzsoi_decomp(j)
-            sum8 = sum8 +  this%smin_no3_runoff_vr(c,j) * dzsoi_decomp(j)
-         end do
-         this%f_nit(c) = this%f_nit(c) + sum1
-         this%f_denit(c) = this%f_denit(c) + sum2 
-         this%pot_f_nit(c) = this%pot_f_nit(c) + sum3
-         this%pot_f_denit(c) = this%pot_f_denit(c) + sum4
-         this%f_n2o_nit(c) = this%f_n2o_nit(c) + sum5
-         this%f_n2o_denit(c) = this%f_n2o_denit(c) + sum6 
-         this%smin_no3_leached(c) =this%smin_no3_leached(c) + sum7
-         this%smin_no3_runoff(c) = this%smin_no3_runoff(c) + sum8
-
-         this%denit(c) = this%f_denit(c)
-
-      end do
-
-   end if
-
-   ! vertically integrate column-level fire N losses
-   !$acc parallel loop gang worker collapse(2) default(present) private(c,sum1)
-   do k = 1, ndecomp_pools
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8
-         !$acc loop vector reduction(+:sum1)
-         do j = 1, nlev
-            sum1 = sum1 + this%m_decomp_npools_to_fire_vr(c,j,k) * dzsoi_decomp(j)
-         end do
-         this%m_decomp_npools_to_fire(c,k) = this%m_decomp_npools_to_fire(c,k) + sum1
-      end do
-   end do
-
-   ! total column-level fire N losses
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      this%fire_nloss(c) = this%fire_nloss_p2c(c)
-   end do
-   !$acc parallel loop gang worker default(present) private(c,sum1)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = this%fire_nloss_p2c(c)
-      !$acc loop vector reduction(+:sum1)
-      do k = 1, ndecomp_pools
-         sum1 = sum1 + this%m_decomp_npools_to_fire(c,k)
-      enddo 
-      this%fire_nloss(c) = sum1 
-   end do
-
-   ! supplementary N supplement_to_sminn
-   !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2,sum3,sum4)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0._r8;sum2=0._r8;sum3=0._r8
-      sum4 = 0._r8;
-      !$acc loop vector reduction(+:sum1,sum2,sum3,sum4)
-      do j = 1, nlev
-         sum1 = sum1 + this%supplement_to_sminn_vr(c,j) * dzsoi_decomp(j)
-         sum2 = sum2 + (this%sminn_nh4_input_vr(c,j)+this%sminn_no3_input_vr(c,j))*dzsoi_decomp(j)
-         sum3 = sum3 + this%sminn_nh4_input_vr(c,j)*dzsoi_decomp(j)
-         sum4 = sum4 + this%sminn_no3_input_vr(c,j)*dzsoi_decomp(j)
-      end do
-      this%supplement_to_sminn(c) = sum1
-      this%sminn_input(c) = this%sminn_input(c) + sum2
-      this%sminn_nh4_input(c) = this%sminn_nh4_input(c) + sum3
-      this%sminn_no3_input(c) = this%sminn_no3_input(c) + sum4 
-   end do
-
-   !$acc parallel loop independent gang vector default(present) private(c)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      ! column-level N losses due to landcover change
-      this%dwt_nloss(c) = &
-           this%dwt_conv_nflux(c)
-      ! total wood product N loss
-      this%product_nloss(c) = &
-           this%prod10n_loss(c) + &
-           this%prod100n_loss(c)+ &
-           this%prod1n_loss(c)
-   end do
-
-   ! add up all vertical transport tendency terms and calculate total som leaching loss as the sum of these
-   
-   !$acc parallel loop gang worker default(present) private(c,sum1,sum2)
-   do l = 1, ndecomp_pools
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8;
-         sum2 = 0._r8
-         !$acc loop vector reduction(+:sum1,sum2)
-         do j = 1, nlev
-            sum1 = sum1 + this%decomp_npools_transport_tendency(c,j,l) * dzsoi_decomp(j)
-
-            sum2 = sum2 + (this%bgc_npool_ext_inputs_vr(c,j,l)-this%bgc_npool_ext_loss_vr(c,j,l))*dzsoi_decomp(j)
-         end do
-         this%decomp_npools_leached(c,l) =  sum1
-         this%bgc_npool_inputs(c,l) = this%bgc_npool_inputs(c,l) + sum2
-      end do
-   end do
-
-   !$acc parallel loop independent gang worker default(present) private(sum1,c)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0._r8
-      !$acc loop vector reduction(+:sum1)
-      do l = 1, ndecomp_pools
-         sum1 = sum1 + this%decomp_npools_leached(c,l)
-      end do
-      this%som_n_leached(c) = sum1
-   end do 
-
-   ! FATES uses the plant_to_litter_nflux variable for mass accounting, so bypass here
-   if(.not.use_fates)then
-      !$acc parallel loop independent gang worker default(present) private(sum1,sum2,c)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8; sum2 = 0._r8;
-         this%plant_to_litter_nflux(c) = 0._r8
-         this%plant_to_cwd_nflux(c) = 0._r8
-         !$acc loop vector reduction(+:sum1,sum2)
-         do j = 1, nlev
-            sum1 = sum1  + &
-                 this%phenology_n_to_litr_met_n(c,j)* dzsoi_decomp(j) + &
-                 this%phenology_n_to_litr_cel_n(c,j)* dzsoi_decomp(j) + &
-                 this%phenology_n_to_litr_lig_n(c,j)* dzsoi_decomp(j) + &
-                 this%gap_mortality_n_to_litr_met_n(c,j)* dzsoi_decomp(j) + &
-                 this%gap_mortality_n_to_litr_cel_n(c,j)* dzsoi_decomp(j) + &
-                 this%gap_mortality_n_to_litr_lig_n(c,j)* dzsoi_decomp(j) + &
-                 this%m_n_to_litr_met_fire(c,j)* dzsoi_decomp(j) + &
-                 this%m_n_to_litr_cel_fire(c,j)* dzsoi_decomp(j) + &
-                 this%m_n_to_litr_lig_fire(c,j)* dzsoi_decomp(j)
-            sum1 = sum2 + &
-                 this%gap_mortality_n_to_cwdn(c,j)* dzsoi_decomp(j) + &
-                 this%fire_mortality_n_to_cwdn(c,j)* dzsoi_decomp(j)
-         end do
-         this%plant_to_litter_nflux(c) = sum1;
-         this%plant_to_cwd_nflux(c) = sum2
-      end do
-   end if
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0._r8
-      sum2 = 0._r8
-      !$acc loop vector reduction(+:sum1,sum2)
-      do j = 1, nlev
-         sum1 = sum1 + this%smin_no3_to_plant_vr(c,j) * dzsoi_decomp(j)
-         sum2 = sum2 + this%smin_nh4_to_plant_vr(c,j) * dzsoi_decomp(j)
-      enddo
-      this%smin_no3_to_plant(c) = sum1
-      this%smin_nh4_to_plant(c) = sum2 
-   enddo
-
-   !$acc exit data delete(sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8)
-
-
- end subroutine col_nf_summary_acc
-
-  !-----------------------------------------------------------------------
- subroutine col_pf_summary_acc(this, num_soilc, filter_soilc)
-   ! !ARGUMENTS:
-   type (column_phosphorus_flux) :: this
-   integer           , intent(in) :: num_soilc       ! number of soil columns in filter
-   integer           , intent(in) :: filter_soilc(:) ! filter for soil columns
-   !
-   ! !LOCAL VARIABLES:
-   integer  :: c,j,k,l   ! indices
-   integer  :: fc       ! lake filter indices
-   real(r8) :: maxdepth    ! depth to integrate soil variables
-   real(r8) :: sum1, sum2, sum3,sum4,sum5,sum6,sum7,sum8 
-   !-----------------------------------------------------------------------
-
-   !$acc enter data create(sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8)
-
-   ! pflotran
-   if (.not.(use_pflotran .and. pf_cmode)) then
-   ! vertically integrate decomposing P cascade fluxes and soil mineral P fluxes associated with decomposition cascade
-   !$acc parallel loop independent gang worker collapse(2) default(present) private(c, sum1,sum2)
-   do k = 1, ndecomp_cascade_transitions
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8 
-         sum2 = 0._r8 
-
-         !$acc loop vector reduction(+:sum1,sum2)
-         do j = 1,nlevdecomp
-            sum1 = sum1 + this%decomp_cascade_ptransfer_vr(c,j,k) * dzsoi_decomp(j)
-            sum2 = sum2 + this%decomp_cascade_sminp_flux_vr(c,j,k) * dzsoi_decomp(j)
-         end do
-         this%decomp_cascade_ptransfer(c,k) = this%decomp_cascade_ptransfer(c,k) + sum1 
-         this%decomp_cascade_sminp_flux(c,k) = this%decomp_cascade_sminp_flux(c,k) + sum2 
-      end do
-   end do
-   end if !if (.not.(use_pflotran .and. pf_cmode))
-
-   ! vertically integrate inorganic P flux
-   !$acc parallel loop independent gang worker default(present) private(c,sum1)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum1 = 0._r8
-      !$acc loop vector reduction(+:sum1)
-      do j = 1, nlevdecomp
-          sum1 = sum1 + this%primp_to_labilep_vr(c,j) * dzsoi_decomp(j)
-      end do
-      this%primp_to_labilep(c) = this%primp_to_labilep(c) + sum1 
-   end do
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum2 = 0._r8
-      !$acc loop vector reduction(+:sum2)
-      do j = 1, nlevdecomp
-         sum2 = sum2 + this%labilep_to_secondp_vr(c,j) * dzsoi_decomp(j)
-      end do
-      this%labilep_to_secondp(c) = this%labilep_to_secondp(c) + sum2 
-   end do
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum3)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum3 = 0._r8
-      !$acc loop vector reduction(+:sum3)
-      do j = 1, nlevdecomp
-          sum3 = sum3 + this%secondp_to_labilep_vr(c,j) * dzsoi_decomp(j)
-      end do
-      this%secondp_to_labilep(c) = this%secondp_to_labilep(c) + sum3 
-   end do
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum4)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum4 = 0._r8
-      !$acc loop vector reduction(+:sum4)
-      do j = 1, nlevdecomp
-          sum4 = sum4 + this%secondp_to_occlp_vr(c,j) * dzsoi_decomp(j)
-      end do
-      this%secondp_to_occlp(c) = this%secondp_to_occlp(c) + sum4 
-   end do
-
-   ! vertically integrate leaching flux
-  !$acc parallel loop independent gang worker default(present) private(c,sum5)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum5 = 0._r8
-      !$acc loop vector reduction(+:sum5)
-      do j = 1, nlevdecomp
-         sum5 = sum5 + this%sminp_leached_vr(c,j) * dzsoi_decomp(j)
-      end do
-      this%sminp_leached(c) = this%sminp_leached(c) + sum5 
-   end do
-
-   ! vertically integrate column-level fire P losses
-   !$acc parallel loop independent gang worker default(present) private(c,sum1)
-   do k = 1, ndecomp_pools
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8
-         !$acc loop vector reduction(+:sum1)
-         do j = 1, nlevdecomp
-            sum1 = sum1 + this%m_decomp_ppools_to_fire_vr(c,j,k) * dzsoi_decomp(j)
-         end do
-         this%m_decomp_ppools_to_fire(c,k) = this%m_decomp_ppools_to_fire(c,k) + sum1
-      end do
-   end do
-
-   ! total column-level fire P losses
-   !$acc parallel loop independent gang worker default(present) private(c,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      this%fire_ploss(c) = this%fire_ploss_p2c(c)
-      sum2 = 0._r8 
-      !$acc loop vector reduction(+:sum2) 
-      do k = 1, ndecomp_pools
-         sum2 = sum2 + this%m_decomp_ppools_to_fire(c,k)
-      end do
-      this%fire_ploss(c) = this%fire_ploss(c) + sum2 
-   end do
-
-   ! supplementary P supplement_to_sminp
-   !zero'd out 
-   !$acc parallel loop independent gang worker default(present) private(c,sum3)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum3 = 0._r8
-      !$acc loop vector reduction(+:sum3) 
-      do j = 1, nlevdecomp
-         sum3 = sum3 + this%supplement_to_sminp_vr(c,j) * dzsoi_decomp(j)
-      end do
-      this%supplement_to_sminp(c) = sum3 
-   end do
-
-   !$acc parallel loop independent gang vector default(present) private(c)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-
-      ! column-level P losses due to landcover change
-      this%dwt_ploss(c) = &
-           this%dwt_conv_pflux(c)
-
-      ! total wood product P loss
-      this%product_ploss(c) = &
-           this%prod10p_loss(c) + &
-           this%prod100p_loss(c) + &
-           this%prod1p_loss(c)
-   end do
-
-   ! add up all vertical transport tendency terms and calculate total som leaching loss as the sum of these
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum1)
-   do l = 1, ndecomp_pools
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8
-         !$acc loop vector reduction(+:sum1)
-         do j = 1, nlevdecomp
-             sum1 = sum1 + this%decomp_ppools_transport_tendency(c,j,l) * dzsoi_decomp(j)
-         end do
-         this%decomp_ppools_leached(c,l) = sum1
-      end do
-   end do
-
-      !zero'd out 
-   !$acc parallel loop independent gang worker default(present) private(c,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum2 = 0._r8
-      !$acc loop vector reduction(+:sum2) 
-      do l = 1, ndecomp_pools
-          sum2 = sum2 + this%decomp_ppools_leached(c,l)
-      end do
-      this%som_p_leached(c) = sum2 
-   end do
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum2)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum2 = 0._r8 
-      !$acc loop vector reduction(+:sum2)
-      do j = 1, nlevdecomp
-         sum2 = sum2 + this%biochem_pmin_vr(c,j)* dzsoi_decomp(j)
-      end do
-      this%biochem_pmin(c) = sum2 
-   end do
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum3,sum4)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum3 = 0._r8 
-      sum4 = 0._r8 
-      !$acc loop vector reduction(+:sum3,sum4)
-      do j = 1, nlevdecomp
-          sum3 = sum3 + this%adsorb_to_labilep_vr(c,j)* dzsoi_decomp(j)
-          sum4 = sum4 + this%desorb_to_solutionp_vr(c,j)* dzsoi_decomp(j)
-      end do
-      this%adsorb_to_labilep(c) = sum3 
-      this%desorb_to_solutionp(c) = sum4 
-   end do
-
-   !$acc parallel loop independent gang worker default(present) private(c,sum3,sum4)
-   do fc = 1,num_soilc
-      c = filter_soilc(fc)
-      sum3 = 0._r8
-      sum4 = 0._r8
-      !$acc loop vector reduction(+:sum3,sum4)
-      do j = 1, nlevdecomp
-         sum3 = sum3 + this%actual_immob_p_vr(c,j) * dzsoi_decomp(j)
-         sum4 = sum4 + this%sminp_to_plant_vr(c,j) * dzsoi_decomp(j)
-      end do
-      this%actual_immob_p(c) = sum3
-      this%smin_p_to_plant(c) = sum4  
-   end do
-
-   if(.not.use_fates)then
-      
-   !$acc parallel loop independent gang worker default(present) private(c,sum1,sum2)
-      do fc = 1,num_soilc
-         c = filter_soilc(fc)
-         sum1 = 0._r8
-         sum2 = 0._r8
-         !$acc loop vector reduction(+:sum1,sum2)
-         do j = 1, nlevdecomp
-            sum1 = sum1  + &
-                 this%phenology_p_to_litr_met_p(c,j)* dzsoi_decomp(j) + &
-                 this%phenology_p_to_litr_cel_p(c,j)* dzsoi_decomp(j) + &
-                 this%phenology_p_to_litr_lig_p(c,j)* dzsoi_decomp(j) + &
-                 this%gap_mortality_p_to_litr_met_p(c,j)* dzsoi_decomp(j) + &
-                 this%gap_mortality_p_to_litr_cel_p(c,j)* dzsoi_decomp(j) + &
-                 this%gap_mortality_p_to_litr_lig_p(c,j)* dzsoi_decomp(j) + &
-                 this%m_p_to_litr_met_fire(c,j)* dzsoi_decomp(j) + &
-                 this%m_p_to_litr_cel_fire(c,j)* dzsoi_decomp(j) + &
-                 this%m_p_to_litr_lig_fire(c,j)* dzsoi_decomp(j)
-            sum2 = sum2 + &
-                 this%gap_mortality_p_to_cwdp(c,j)* dzsoi_decomp(j) + &
-                 this%fire_mortality_p_to_cwdp(c,j)* dzsoi_decomp(j)
-         end do
-         this%plant_to_litter_pflux(c) = sum1 
-         this%plant_to_cwd_pflux(c)    = sum2 
-      end do
-   end if
-   !$acc exit data delete(sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8)
-
- end subroutine col_pf_summary_acc
-
-!------------------------------------------------------------
- subroutine col_cf_summary_for_ch4_acc( this, num_soilc, filter_soilc)
-   !
-   ! !DESCRIPTION:
-   ! summarize column-level fluxes for methane calculation
-   !
-   ! !USES:
-   ! !ARGUMENTS:
-   type(column_carbon_flux)     :: this
-   integer, intent(in) :: num_soilc
-   integer, intent(in) :: filter_soilc(:)
-   !
-   ! !LOCAL VARIABLES
-   integer :: fc, c
-   integer :: j,k,l       ! indices
-   real(r8) :: sum1,sum2,sum3
-   !------------------------------------------------------------
-   associate(&
-       is_litter =>    decomp_cascade_con%is_litter , & ! Input:  [logical (:) ]  TRUE => pool is a litter pool
-       is_soil   =>    decomp_cascade_con%is_soil   , & ! Input:  [logical (:) ]  TRUE => pool is a soil pool
-       is_cwd    =>    decomp_cascade_con%is_cwd      &
-   )
-   !$acc enter data create(sum1,sum2,sum3)
- 
-   if ( (.not. is_active_betr_bgc           ) .and. &
-       (.not. (use_pflotran .and. pf_cmode))) then
-     ! vertically integrate HR and decomposition cascade fluxes
-     !$acc parallel loop independent gang worker collapse(2) private(c,sum1) default(present)
-     do k = 1, ndecomp_cascade_transitions
-       do fc = 1,num_soilc
-           sum1 = 0.0_r8
-           c = filter_soilc(fc)
-           !$acc loop vector reduction(+:sum1)
-           do j = 1,nlevdecomp
-           sum1 = sum1 + &
-               this%decomp_cascade_hr_vr(c,j,k) * dzsoi_decomp(j)
-           end do
-          this%decomp_cascade_hr(c,k) = sum1
-       end do
-     end do
- 
-     ! litter heterotrophic respiration (LITHR)
-     !$acc parallel loop independent gang worker private(c,sum1) default(present)
-     do fc = 1,num_soilc
-       c = filter_soilc(fc)
-       sum1 = 0._r8
-       !$acc loop vector reduction(+:sum1)
-       do k = 1, ndecomp_cascade_transitions
-           if ( is_litter(decomp_cascade_con%cascade_donor_pool(k)) .or. &
-                 is_cwd((decomp_cascade_con%cascade_donor_pool(k)))) then
-               sum1= sum1 + this%decomp_cascade_hr(c,k)
-          end if
-         end do
-         this%lithr(c) = sum1
-     end do
- 
-     ! soil organic matter heterotrophic respiration (SOMHR)
-     !$acc parallel loop independent gang worker private(c,sum1) default(present)
-     do fc = 1,num_soilc
-       c = filter_soilc(fc)
-       sum1 = 0._r8
-       !$acc loop vector reduction(+:sum1)
-       do k = 1, ndecomp_cascade_transitions
-           if ( is_soil(decomp_cascade_con%cascade_donor_pool(k)) ) then
-              sum1 = sum1 + this%decomp_cascade_hr(c,k)
-           end if
-         end do
-         this%somhr(c) = sum1
-     end do
- 
-     ! total heterotrophic respiration, vertically resolved (HR)
-     !$acc parallel loop independent gang worker collapse(2) private(c,sum1) default(present)
-     do j = 1,nlevdecomp
-      do fc = 1,num_soilc
-          c = filter_soilc(fc)
-          sum1 = 0._r8
-          !$acc loop vector reduction(+:sum1)
-          do k = 1, ndecomp_cascade_transitions
-           sum1 = sum1 + this%decomp_cascade_hr_vr(c,j,k)
-          end do
-          this%hr_vr(c,j) = sum1
-      end do
-     end do
- 
-   endif
- 
-   end associate
- 
- end subroutine col_cf_summary_for_ch4_acc
-
-end module ColumnWorkRoutinesMod
diff --git a/components/elm/src/main/ForcingUpdateMod.F90 b/components/elm/src/main/ForcingUpdateMod.F90
deleted file mode 100644
index 96905194e3..0000000000
--- a/components/elm/src/main/ForcingUpdateMod.F90
+++ /dev/null
@@ -1,522 +0,0 @@
-module ForcingUpdateMod
-
-  use shr_kind_mod     , only : r8 => shr_kind_r8
-  use atm2lndType      , only : atm2lnd_type, cplbypass_atminput_type
-  use TopounitDataType , only : top_af, top_as
-  use GridcellType     , only : grc_pp
-  use TopounitType     , only : top_pp 
-  use shr_const_mod    , only : SHR_CONST_TKFRZ, SHR_CONST_STEBOL
-  use elm_varctl       , only: const_climate_hist, add_temperature, add_co2, use_cn
-  use elm_varctl       , only: startdate_add_temperature, startdate_add_co2
-  use elm_varctl       , only: co2_type, co2_ppmv,  use_c13, create_glacier_mec_landunit
-
-  use elm_varcon       , only: rair, o2_molar_const, c13ratio
-  use decompMod        , only : bounds_type
-  use domainMod        , only : ldomain_gpu
-
-  ! Constants to compute vapor pressure
-  real(r8),parameter :: a0=6.107799961_r8, a1=4.436518521e-01_r8, &
-       a2=1.428945805e-02_r8, a3=2.650648471e-04_r8, &
-       a4=3.031240396e-06_r8, a5=2.034080948e-08_r8, &
-       a6=6.136820929e-11_r8
-
-  real(r8), parameter :: b0=6.109177956_r8, b1=5.034698970e-01_r8, &
-       b2=1.886013408e-02_r8, b3=4.176223716e-04_r8, &
-       b4=5.824720280e-06_r8, b5=4.838803174e-08_r8, &
-       b6=1.838826904e-10_r8
-
-  integer, dimension(13) :: caldaym = (/ 1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 /)
-  !$acc declare copyin(caldaym)
-  !$acc declare copyin(a0,a1,a2,a3,a4,a5,a6)
-  !$acc declare copyin(b0,b1,b2,b3,b4,b5,b6)
-
-  public :: update_forcings_cplbypass
-  private :: szenith
-contains
-
-  real(r8) function tdc(t)
-    !$acc routine seq
-    implicit none
-    real(r8), intent(in) :: t
-    tdc = min( 50._r8, max(-50._r8,(t-SHR_CONST_TKFRZ)) )
-  end function tdc
-  real(r8) function esatw(t)
-    !$acc routine seq
-    implicit none
-    real(r8), intent(in) :: t
-    esatw = 100._r8*(a0+t*(a1+t*(a2+t*(a3+t*(a4+t*(a5+t*a6))))))
-  end function esatw
-  real(r8) function esati(t)
-    !$acc routine seq
-    implicit none
-    real(r8), intent(in) :: t
-    esati= 100._r8*(b0+t*(b1+t*(b2+t*(b3+t*(b4+t*(b5+t*b6))))))
-  end function esati
-
-  subroutine update_forcings_cplbypass(bounds, atm2lnd_vars, cpl_bypass_input, &
-            dtime, thiscalday,tod, yr, mon, nstep)
-    implicit none
-    type(bounds_type)  , intent(in)   :: bounds
-    type(atm2lnd_type), intent(inout) :: atm2lnd_vars
-    type(cplbypass_atminput_type), intent(in) :: cpl_bypass_input 
-    real(r8)  , intent(in)    :: dtime
-    real(r8)  , intent(in)    :: thiscalday
-    integer   , intent(in)    :: tod, yr, mon, nstep
-    integer :: v, g, av, topo
-    integer, parameter :: met_nvars = 7
-    integer  :: swrad_period_len, swrad_period_start, thishr, thismin
-    integer ::  aindex(2), starti(3), counti(3), tm, nindex(2)
-    real(r8) :: wt1(14), wt2(14), tbot, t, qsat
-    real(r8) :: swndf, swndr, swvdf, swvdr, ratio_rvrf, frac, q
-    real(r8) :: e, ea, vp  ! vapor pressure (Pa)
-    real(r8) :: avgcosz, thiscosz
-    integer  :: sdate_addt, sy_addt, sm_addt, sd_addt
-    integer  :: sdate_addco2, sy_addco2, sm_addco2, sd_addco2
-    real(r8) :: forc_rainc    ! rainxy Atm flux mm/s
-    real(r8) :: forc_t        ! atmospheric temperature (Kelvin)
-    real(r8) :: forc_q        ! atmospheric specific humidity (kg/kg)
-    real(r8) :: forc_pbot     ! atmospheric pressure (Pa)
-    real(r8) :: forc_rainl    ! rainxy Atm flux mm/s
-    real(r8) :: forc_snowc    ! snowfxy Atm flux  mm/s
-    real(r8) :: forc_snowl    ! snowfxl Atm flux  mm/s
-    real(r8) :: co2_ppmv_diag ! temporary
-    real(r8) :: co2_ppmv_prog ! temporary
-    real(r8) :: co2_ppmv_val  ! temporary
-    integer  :: co2_type_idx  ! integer flag for co2_type
-    integer :: igridcell
-    integer :: begg, endg, begt, endt 
-
-    associate(  &
-      tindex => atm2lnd_vars%tindex  &
-      )
-      igridcell = bounds%begg
-      begg = bounds%begg
-      endg = bounds%endg 
-      begt = bounds%begt 
-      endt = bounds%endt  
-   
-      !$acc enter data create(wt1(:), wt2(:),aindex(:),starti(:),counti(:),nindex(:))
-   !$acc parallel loop independent gang vector collapse(2) default(present)
-   do v=1,met_nvars
-      do g = bounds%begg,bounds%endg
-         if (atm2lnd_vars%npf(v) - 1._r8 .gt. 1e-3) then
-           if (v .eq. 4 .or. v .eq. 5 .or. (v .ge. 8 .and. v .le. 13)) then    !rad/Precipitation
-             if (mod(tod/int(dtime),nint(atm2lnd_vars%npf(v))) == 1 .and. nstep .gt. 3) then
-               tindex(g,v,1) = tindex(g,v,1)+1
-               tindex(g,v,2) = tindex(g,v,2)+1
-             end if
-           else
-             if (mod(tod/int(dtime)-1,nint(atm2lnd_vars%npf(v))) <= atm2lnd_vars%npf(v)/2._r8 .and. &
-                 mod(tod/int(dtime),nint(atm2lnd_vars%npf(v))) > atm2lnd_vars%npf(v)/2._r8) then
-               tindex(g,v,1) = tindex(g,v,1)+1
-               tindex(g,v,2) = tindex(g,v,2)+1
-             end if
-           end if
-         else
-           tindex(g,v,1) = tindex(g,v,1)+nint(1/atm2lnd_vars%npf(v))
-           tindex(g,v,2) = tindex(g,v,2)+nint(1/atm2lnd_vars%npf(v))
-         end if
-
-         if (const_climate_hist .or. yr .le. atm2lnd_vars%startyear_met) then
-           if (tindex(g,v,1) .gt. atm2lnd_vars%timelen_spinup(v)) tindex(g,v,1) = 1
-           if (tindex(g,v,2) .gt. atm2lnd_vars%timelen_spinup(v)) tindex(g,v,2) = 1
-         else if (yr .gt. atm2lnd_vars%endyear_met_trans) then
-           if (tindex(g,v,1) .gt. atm2lnd_vars%timelen(v)) then
-              tindex(g,v,1) = atm2lnd_vars%timelen(v)-atm2lnd_vars%timelen_spinup(v)+1
-           end if
-           if (tindex(g,v,2) .gt. atm2lnd_vars%timelen(v)) then
-              tindex(g,v,2) = atm2lnd_vars%timelen(v)-atm2lnd_vars%timelen_spinup(v)+1
-           end if
-         end if
-       end do ! end gridcell 
-      end do 
-      !!
-      !get weights for linear interpolation
-      !$acc parallel loop independent gang vector default(present)
-       do v=1,met_nvars
-         if (atm2lnd_vars%npf(v) - 1._r8 .gt. 1e-3) then
-            wt1(v) = 1._r8 - (mod((tod+86400)/dtime-atm2lnd_vars%npf(v)/2._r8, &
-                atm2lnd_vars%npf(v))*1._r8)/atm2lnd_vars%npf(v)
-                wt2(v) = 1._r8 - wt1(v)
-          else
-            wt1(v) = 0._r8
-            wt2(v) = 1._r8
-          end if
-        end do
-      
-      !$acc parallel loop independent gang vector default(present)  
-      do g = begg, endg 
-        !Air temperature
-        atm2lnd_vars%forc_t_not_downscaled_grc(g)  = min(((cpl_bypass_input%atm_input(1,g,1,tindex(g,1,1))*atm2lnd_vars%scale_factors(1)+ &
-                                                  atm2lnd_vars%add_offsets(1))*wt1(1) + (cpl_bypass_input%atm_input(1,g,1,tindex(g,1,2))* &
-                                                  atm2lnd_vars%scale_factors(1)+atm2lnd_vars%add_offsets(1))*wt2(1)) * &
-                                                  atm2lnd_vars%var_mult(1,g,mon) + atm2lnd_vars%var_offset(1,g,mon), 323._r8)
-
-        !Note: looks like same calculation as above 
-        atm2lnd_vars%forc_th_not_downscaled_grc(g) = min(((cpl_bypass_input%atm_input(1,g,1,tindex(g,1,1))*atm2lnd_vars%scale_factors(1)+ &
-                                                  atm2lnd_vars%add_offsets(1))*wt1(1) + (cpl_bypass_input%atm_input(1,g,1,tindex(g,1,2))* &
-                                                  atm2lnd_vars%scale_factors(1)+atm2lnd_vars%add_offsets(1))*wt2(1)) * &
-                                                  atm2lnd_vars%var_mult(1,g,mon) + atm2lnd_vars%var_offset(1,g,mon), 323._r8)
-
-        tbot = atm2lnd_vars%forc_t_not_downscaled_grc(g)
-
-        !Air pressure
-        atm2lnd_vars%forc_pbot_not_downscaled_grc(g) = max(((cpl_bypass_input%atm_input(2,g,1,tindex(g,2,1))*atm2lnd_vars%scale_factors(2)+ &
-                                                    atm2lnd_vars%add_offsets(2))*wt1(2) + (cpl_bypass_input%atm_input(2,g,1,tindex(g,2,2)) &
-                                                    *atm2lnd_vars%scale_factors(2)+atm2lnd_vars%add_offsets(2))*wt2(2)) * &
-                                                    atm2lnd_vars%var_mult(2,g,mon) + atm2lnd_vars%var_offset(2,g,mon), 4e4_r8)
-
-        !Specific humidity
-        atm2lnd_vars%forc_q_not_downscaled_grc(g) = max(((cpl_bypass_input%atm_input(3,g,1,tindex(g,3,1))*atm2lnd_vars%scale_factors(3)+ &
-                                                 atm2lnd_vars%add_offsets(3))*wt1(3) + (cpl_bypass_input%atm_input(3,g,1,tindex(g,3,2)) &
-                                                 *atm2lnd_vars%scale_factors(3)+atm2lnd_vars%add_offsets(3))*wt2(3)) * &
-                                                 atm2lnd_vars%var_mult(3,g,mon) + atm2lnd_vars%var_offset(3,g,mon), 1e-9_r8)
-        if (atm2lnd_vars%metsource == 2) then  !convert RH to qbot
-           if (tbot > SHR_CONST_TKFRZ) then
-             e = esatw(tdc(tbot))
-           else
-             e = esati(tdc(tbot))
-           end if
-           qsat           = 0.622_r8*e / (atm2lnd_vars%forc_pbot_not_downscaled_grc(g) - 0.378_r8*e)
-           atm2lnd_vars%forc_q_not_downscaled_grc(g) = qsat * atm2lnd_vars%forc_q_not_downscaled_grc(g) / 100.0_r8
-        end if
-
-        !use longwave from file if provided
-        atm2lnd_vars%forc_lwrad_not_downscaled_grc(g) = ((cpl_bypass_input%atm_input(7,g,1,tindex(g,7,1))*atm2lnd_vars%scale_factors(7)+ &
-                                                    atm2lnd_vars%add_offsets(7))*wt1(7) + (cpl_bypass_input%atm_input(7,g,1,tindex(g,7,2)) &
-                                                    *atm2lnd_vars%scale_factors(7)+atm2lnd_vars%add_offsets(7))*wt2(7)) * &
-                                                    atm2lnd_vars%var_mult(7,g,mon) + atm2lnd_vars%var_offset(7,g,mon)
-        !=======================================================================================================!!
-         if (atm2lnd_vars%forc_lwrad_not_downscaled_grc(g) .le. 50 .or. atm2lnd_vars%forc_lwrad_not_downscaled_grc(g) .ge. 600) then
-         !Longwave radiation (calculated from air temperature, humidity)
-            e =  atm2lnd_vars%forc_pbot_not_downscaled_grc(g) * atm2lnd_vars%forc_q_not_downscaled_grc(g) / &
-                  (0.622_R8 + 0.378_R8 * atm2lnd_vars%forc_q_not_downscaled_grc(g) )
-            ea = 0.70_R8 + 5.95e-05_R8 * 0.01_R8 * e * exp(1500.0_R8/tbot)
-            atm2lnd_vars%forc_lwrad_not_downscaled_grc(g) = ea * SHR_CONST_STEBOL * tbot**4
-          end if
-    !Shortwave radiation (cosine zenith angle interpolation)
-    thishr = (tod-dtime/2)/3600
-    if (thishr < 0) thishr=thishr+24
-    thismin = mod((tod-dtime/2)/60, 60)
-    thiscosz = max(cos(szenith(ldomain_gpu%lonc(g),ldomain_gpu%latc(g),0,int(thiscalday),thishr,thismin,0)* &
-                    3.14159265358979/180.0d0), 0.001d0)
-    avgcosz = 0d0
-    if (atm2lnd_vars%npf(4) - 1._r8 .gt. 1e-3) then
-      swrad_period_len   = dtime*nint(atm2lnd_vars%npf(4))
-      swrad_period_start = ((tod-dtime/2)/swrad_period_len) * swrad_period_len
-      !set to last period if first model timestep of the day
-      if (tod-dtime/2 < 0) swrad_period_start = ((86400-dtime/2)/swrad_period_len) * swrad_period_len
-      do tm=1,nint(atm2lnd_vars%npf(4))
-        !Get the average cosine zenith angle over the time resolution of the input data
-        thishr  = (swrad_period_start+(tm-1)*dtime+dtime/2)/3600
-        if (thishr > 23) thishr=thishr-24
-        thismin = mod((swrad_period_start+(tm-1)*dtime+dtime/2)/60, 60)
-        avgcosz  = avgcosz + max(cos(szenith(ldomain_gpu%lonc(g),ldomain_gpu%latc(g),0,int(thiscalday),thishr, thismin, 0) &
-                   *3.14159265358979/180.0d0), 0.001d0)/atm2lnd_vars%npf(4)
-      end do
-
-    else
-      avgcosz = thiscosz
-    end if
-    if (thiscosz > 0.001d0) then
-        wt2(4) = min(thiscosz/avgcosz, 10.0_r8)
-    else
-        wt2(4) = 0d0
-    end if
-
-    swndr = max(((cpl_bypass_input%atm_input(4,g,1,tindex(g,4,2))*atm2lnd_vars%scale_factors(4)+ &
-                             atm2lnd_vars%add_offsets(4))*wt2(4)) * 0.50_R8, 0.0_r8)
-
-    swndf = max(((cpl_bypass_input%atm_input(4,g,1,tindex(g,4,2))*atm2lnd_vars%scale_factors(4)+ &
-                            atm2lnd_vars%add_offsets(4))*wt2(4))*0.50_R8, 0.0_r8)
-
-    swvdr = max(((cpl_bypass_input%atm_input(4,g,1,tindex(g,4,2))*atm2lnd_vars%scale_factors(4)+ &
-                            atm2lnd_vars%add_offsets(4))*wt2(4))*0.50_R8, 0.0_r8)
-
-    swvdf = max(((cpl_bypass_input%atm_input(4,g,1,tindex(g,4,2))*atm2lnd_vars%scale_factors(4)+ &
-                            atm2lnd_vars%add_offsets(4))*wt2(4))*0.50_R8, 0.0_r8)
-
-    ratio_rvrf =   min(0.99_R8,max(0.29548_R8 + 0.00504_R8*swndr &
-                   -1.4957e-05_R8*swndr**2 + 1.4881e-08_R8*swndr**3,0.01_R8))
-
-    atm2lnd_vars%forc_solad_grc(g,2) = ratio_rvrf*swndr
-    atm2lnd_vars%forc_solai_grc(g,2) = (1._R8 - ratio_rvrf)*swndf
-    ratio_rvrf =   min(0.99_R8,max(0.17639_R8 + 0.00380_R8*swvdr  &
-                       -9.0039e-06_R8*swvdr**2 +8.1351e-09_R8*swvdr**3,0.01_R8))
-    atm2lnd_vars%forc_solad_grc(g,1) = ratio_rvrf*swvdr
-    atm2lnd_vars%forc_solai_grc(g,1) = (1._R8 - ratio_rvrf)*swvdf
-
-    frac = (atm2lnd_vars%forc_t_not_downscaled_grc(g) - SHR_CONST_TKFRZ)*0.5_R8       ! ramp near freezing
-    frac = min(1.0_R8,max(0.0_R8,frac)) 
-
-    !Don't interpolate rainfall data
-    forc_rainc = 0.1_R8 * frac * max((((cpl_bypass_input%atm_input(5,g,1,tindex(g,5,2))*atm2lnd_vars%scale_factors(5)+ &
-                                  atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,g,mon) + &
-                                  atm2lnd_vars%var_offset(5,g,mon)), 0.0_r8)
-    !!!!
-    forc_rainl = 0.9_R8 * frac * max((((cpl_bypass_input%atm_input(5,g,1,tindex(g,5,2))*atm2lnd_vars%scale_factors(5)+ &
-                                   atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,g,mon) + &
-                                   atm2lnd_vars%var_offset(5,g,mon)), 0.0_r8)
-    !!!!
-    forc_snowc = 0.1_R8 * (1.0_R8 - frac) * max((((cpl_bypass_input%atm_input(5,g,1,tindex(g,5,2))*atm2lnd_vars%scale_factors(5)+ &
-            atm2lnd_vars%add_offsets(5)))*atm2lnd_vars%var_mult(5,g,mon) + atm2lnd_vars%var_offset(5,g,mon)), 0.0_r8)
-    !!!!
-    forc_snowl = 0.9_R8 * (1.0_R8 - frac) * max((((cpl_bypass_input%atm_input(5,g,1,tindex(g,5,2))*atm2lnd_vars%scale_factors(5)+ &
-            atm2lnd_vars%add_offsets(5))) * atm2lnd_vars%var_mult(5,g,mon) + atm2lnd_vars%var_offset(5,g,mon)), 0.0_r8)
-
-
-    !Wind
-    atm2lnd_vars%forc_u_grc(g) = (cpl_bypass_input%atm_input(6,g,1,tindex(g,6,1))*atm2lnd_vars%scale_factors(6)+ &
-                                 atm2lnd_vars%add_offsets(6))*wt1(6) + (cpl_bypass_input%atm_input(6,g,1,tindex(g,6,2))* &
-                                 atm2lnd_vars%scale_factors(6)+atm2lnd_vars%add_offsets(6))*wt2(6)
-    if (atm2lnd_vars%metsource == 5) then
-      atm2lnd_vars%forc_v_grc(g) = (cpl_bypass_input%atm_input(14,g,1,tindex(g,14,1))*atm2lnd_vars%scale_factors(14)+ &
-                                 atm2lnd_vars%add_offsets(14))*wt1(14) + (cpl_bypass_input%atm_input(14,g,1,tindex(g,14,2))* &
-                                 atm2lnd_vars%scale_factors(14)+atm2lnd_vars%add_offsets(14))*wt2(14)
-    else
-        atm2lnd_vars%forc_v_grc(g) = 0.0_R8
-    end if
-    atm2lnd_vars%forc_hgt_grc(g) = 30.0_R8
-   end do 
-
-   !------------------------------------Fire data -------------------------------------------------------
-   !get weights for interpolation
-   !$acc parallel loop independent gang vector default(present) 
-   do g = begg, endg 
-      wt1(1) = 1._r8 - (thiscalday -1._r8)/365._r8
-      wt2(1) = 1._r8 - wt1(1)
-      atm2lnd_vars%forc_hdm(g) = atm2lnd_vars%hdm1(atm2lnd_vars%hdmind(g,1),atm2lnd_vars%hdmind(g,2),1)*wt1(1) + &
-                               atm2lnd_vars%hdm2(atm2lnd_vars%hdmind(g,1),atm2lnd_vars%hdmind(g,2),1)*wt2(1)
-      !------------------------------------------------------!
-      atm2lnd_vars%forc_lnfm(g) = atm2lnd_vars%lnfm(g, ((int(thiscalday)-1)*8+tod/(3600*3))+1)
-
-      !DMR note - ndep will NOT be correct if more than 1850 years of model
-      !spinup (model year > 1850)
-      nindex(1) = min(max(yr-1848,2), 168)
-      nindex(2) = min(nindex(1)+1, 168)
-
-      !get weights for interpolation
-      wt1(1) = 1._r8 - (thiscalday -1._r8)/365._r8
-      wt2(1) = 1._r8 - wt1(1)
-
-      atm2lnd_vars%forc_ndep_grc(g) = (atm2lnd_vars%ndep1(atm2lnd_vars%ndepind(g,1),atm2lnd_vars%ndepind(g,2),1)*wt1(1) + &
-                                        atm2lnd_vars%ndep2(atm2lnd_vars%ndepind(g,1),atm2lnd_vars%ndepind(g,2),1)*wt2(1)) / (365._r8 * 86400._r8)
-   end do 
-   
-   !------------------------------------Aerosol forcing--------------------------------------------------
-
-    !get weights for interpolation (note this method doesn't get the month boundaries quite right..
-   !$acc parallel loop independent gang vector default(present) collapse(2) 
-   do av = 1,14
-      do g = begg, endg 
-      
-         aindex(1) = mon+1
-         if (thiscalday .le. (caldaym(mon+1)+caldaym(mon))/2._r8) then
-            wt1(1) = 0.5_r8 + (thiscalday-caldaym(mon))/(caldaym(mon+1)-caldaym(mon))
-            aindex(2) = aindex(1)-1
-         else
-            wt1(1) = 1.0_r8 - (thiscalday-(caldaym(mon+1)+caldaym(mon))/2._r8)/   &
-                           (caldaym(mon+1)-caldaym(mon))
-            aindex(2) = aindex(1)+1
-         end if
-         wt2(1) = 1._r8 - wt1(1)
-
-       atm2lnd_vars%forc_aer_grc(g,av)  =  atm2lnd_vars%aerodata(av,atm2lnd_vars%ndepind(g,1), &
-         atm2lnd_vars%ndepind(g,2),aindex(1))*wt1(1)+atm2lnd_vars%aerodata(av,atm2lnd_vars%ndepind(g,1), &
-         atm2lnd_vars%ndepind(g,2),aindex(2))*wt2(1)
-     end do
-   end do 
-
-   !set the topounit-level atmospheric state and flux forcings (bypass mode)
-   !$acc parallel loop independent gang vector default(present) 
-   do topo = begt, endt 
-       g = top_pp%gridcell(topo) 
-       ! first, all the state forcings
-       top_as%tbot(topo)    = atm2lnd_vars%forc_t_not_downscaled_grc(g)     ! forc_txy  Atm state K
-       top_as%thbot(topo)   = atm2lnd_vars%forc_th_not_downscaled_grc(g)    ! forc_thxy Atm state K
-       top_as%pbot(topo)    = atm2lnd_vars%forc_pbot_not_downscaled_grc(g)  ! ptcmxy    Atm state Pa
-       top_as%qbot(topo)    = atm2lnd_vars%forc_q_not_downscaled_grc(g)     ! forc_qxy  Atm state kg/kg
-       top_as%ubot(topo)    = atm2lnd_vars%forc_u_grc(g)                    ! forc_uxy  Atm state m/s
-       top_as%vbot(topo)    = atm2lnd_vars%forc_v_grc(g)                    ! forc_vxy  Atm state m/s
-       top_as%zbot(topo)    = atm2lnd_vars%forc_hgt_grc(g)                  ! zgcmxy    Atm state m
-
-       ! assign the state forcing fields derived from other inputs
-       ! Horizontal windspeed (m/s)
-       top_as%windbot(topo) = sqrt(top_as%ubot(topo)**2 + top_as%vbot(topo)**2)
-       ! Relative humidity (percent)
-       if (top_as%tbot(topo) > SHR_CONST_TKFRZ) then
-          e = esatw(tdc(top_as%tbot(topo)))
-       else
-          e = esati(tdc(top_as%tbot(topo)))
-       end if
-       qsat           = 0.622_r8*e / (top_as%pbot(topo) - 0.378_r8*e)
-       top_as%rhbot(topo) = 100.0_r8*(top_as%qbot(topo) / qsat)
-       ! partial pressure of oxygen (Pa)
-       top_as%po2bot(topo) = o2_molar_const * top_as%pbot(topo)
-       ! air density (kg/m**3) - uses a temporary calculation of water vapor pressure (Pa)
-       vp = top_as%qbot(topo) * top_as%pbot(topo)  / (0.622_r8 + 0.378_r8 * top_as%qbot(topo))
-       top_as%rhobot(topo) = (top_as%pbot(topo) - 0.378_r8 * vp) / (rair * top_as%tbot(topo))
-
-       ! second, all the flux forcings
-       top_af%rain(topo)    = forc_rainc + forc_rainl            ! sum of convective and large-scale rain
-       top_af%snow(topo)    = forc_snowc + forc_snowl            ! sum of convective and large-scale snow
-       top_af%solad(topo,2) = atm2lnd_vars%forc_solad_grc(g,2)   ! forc_sollxy  Atm flux  W/m^2
-       top_af%solad(topo,1) = atm2lnd_vars%forc_solad_grc(g,1)   ! forc_solsxy  Atm flux  W/m^2
-       top_af%solai(topo,2) = atm2lnd_vars%forc_solai_grc(g,2)   ! forc_solldxy Atm flux  W/m^2
-       top_af%solai(topo,1) = atm2lnd_vars%forc_solai_grc(g,1)   ! forc_solsdxy Atm flux  W/m^2
-       top_af%lwrad(topo)   = atm2lnd_vars%forc_lwrad_not_downscaled_grc(g)     ! flwdsxy Atm flux  W/m^2
-       ! derived flux forcings
-       top_af%solar(topo) = top_af%solad(topo,2) + top_af%solad(topo,1) + &
-                            top_af%solai(topo,2) + top_af%solai(topo,1)
-      !!This is for co2_type_idx = 0
-       co2_ppmv_val = co2_ppmv
-       !
-       co2_ppmv_prog = co2_ppmv
-       co2_ppmv_diag = co2_ppmv
-       top_as%pco2bot(topo) = co2_ppmv_val * 1.e-6_r8 * top_as%pbot(topo)
-       if (use_c13) then
-          top_as%pc13o2bot(topo) = top_as%pco2bot(topo) * c13ratio
-       end if
-   end do
-   
-   !$acc parallel loop independent gang vector default(present) 
-   do g = begg, endg 
-     ! Determine derived quantities for required fields
-     forc_t = atm2lnd_vars%forc_t_not_downscaled_grc(g)
-     forc_q = atm2lnd_vars%forc_q_not_downscaled_grc(g)
-     forc_pbot = atm2lnd_vars%forc_pbot_not_downscaled_grc(g)
-
-     atm2lnd_vars%forc_hgt_u_grc(g) = atm2lnd_vars%forc_hgt_grc(g)    !observational height of wind [m]
-     atm2lnd_vars%forc_hgt_t_grc(g) = atm2lnd_vars%forc_hgt_grc(g)    !observational height of temperature [m]
-     atm2lnd_vars%forc_hgt_q_grc(g) = atm2lnd_vars%forc_hgt_grc(g)    !observational height of humidity [m]
-     atm2lnd_vars%forc_vp_grc(g)    = forc_q * forc_pbot  / (0.622_r8 + 0.378_r8 * forc_q)
-     atm2lnd_vars%forc_rho_not_downscaled_grc(g) = &
-          (forc_pbot - 0.378_r8 * atm2lnd_vars%forc_vp_grc(g)) / (rair * forc_t)
-     atm2lnd_vars%forc_po2_grc(g)   = o2_molar_const * forc_pbot
-     atm2lnd_vars%forc_wind_grc(g)  = sqrt(atm2lnd_vars%forc_u_grc(g)**2 + atm2lnd_vars%forc_v_grc(g)**2)
-     atm2lnd_vars%forc_solar_grc(g) = atm2lnd_vars%forc_solad_grc(g,1) + atm2lnd_vars%forc_solai_grc(g,1) + &
-                                      atm2lnd_vars%forc_solad_grc(g,2) + atm2lnd_vars%forc_solai_grc(g,2)
-
-     atm2lnd_vars%forc_rain_not_downscaled_grc(g)  = forc_rainc + forc_rainl
-     atm2lnd_vars%forc_snow_not_downscaled_grc(g)  = forc_snowc + forc_snowl
-     if (forc_t > SHR_CONST_TKFRZ) then
-        e = esatw(tdc(forc_t))
-     else
-        e = esati(tdc(forc_t))
-     end if
-     qsat           = 0.622_r8*e / (forc_pbot - 0.378_r8*e)
-     atm2lnd_vars%forc_rh_grc(g) = 100.0_r8*(forc_q / qsat)
-     ! Make sure relative humidity is properly bounded
-     ! atm2lnd_vars%forc_rh_grc(g) = min( 100.0_r8, atm2lnd_vars%forc_rh_grc(g) )
-     ! atm2lnd_vars%forc_rh_grc(g) = max(   0.0_r8, atm2lnd_vars%forc_rh_grc(g) )
-
-     ! Determine derived quantities for optional fields
-     ! Note that the following does unit conversions from ppmv to partial pressures (Pa)
-     ! Note that forc_pbot is in Pa
-
-     co2_type_idx = 2
-     !get weights/indices for interpolation (assume values represent annual averages)
-     nindex(1) = min(max(yr,1850),2100)-1764
-     if (thiscalday .le. 182.5) then
-       nindex(2) = nindex(1)-1
-     else
-       nindex(2) = nindex(1)+1
-     end if
-     wt1(1) = 1._r8 - abs((182.5 - (thiscalday -1._r8))/365._r8)
-     wt2(1) = 1._r8 - wt1(1)
-
-     co2_ppmv_val = atm2lnd_vars%co2_input(1,1,nindex(1))*wt1(1) + atm2lnd_vars%co2_input(1,1,nindex(2))*wt2(1)
-
-     if (use_c13) then
-       atm2lnd_vars%forc_pc13o2_grc(g) = (atm2lnd_vars%c13o2_input(1,1,nindex(1))*wt1(1) + &
-            atm2lnd_vars%c13o2_input(1,1,nindex(2))*wt2(1)) * 1.e-6_r8 * forc_pbot
-     end if
-
-     co2_type_idx = 1
-     atm2lnd_vars%forc_pco2_grc(g)   = co2_ppmv_val * 1.e-6_r8 * forc_pbot
-   end do 
-
-   !$acc parallel loop independent gang vector default(present) 
-   do topo = begt, endt
-       g = top_pp%gridcell(topo) 
-       top_as%pco2bot(topo) = atm2lnd_vars%forc_pco2_grc(g)
-       if (use_c13) then
-          top_as%pc13o2bot(topo) = atm2lnd_vars%forc_pc13o2_grc(g)
-       end if
-   end do
-
-      !$acc exit data delete(wt1(:), wt2(:),aindex(:),starti(:),counti(:),nindex(:))
-
-   end associate
-
-  end subroutine update_forcings_cplbypass
-
-  real(r8) function szenith(xcoor, ycoor, ltm, jday, hr, min, offset)
-    !Function to calcualte solar zenith angle
-    !Used in coupler bypass mode to compute inerpolation for incoming solar
-    !$acc routine seq
-    use shr_kind_mod , only: r8 => shr_kind_r8
-    implicit none
-    !inputs
-    real(r8) xcoor, ycoor, offset_min
-    integer jday, hr, min, ltm, offset
-    !working variables
-    real(r8) d2r, r2d, lsn, latrad, decrad, decdeg, ha
-    real(r8) hangle, harad, saltrad, saltdeg, sazirad, sazideg
-    real(r8) szendeg,szenrad
-    real,parameter :: pi = 3.14159265358979
-    offset_min = offset/60d0   !note assumes 1hr or smaller timestep
-    min = min - offset_min
-
-    !adjust time for offsets
-    if (min < 0) then
-      hr = hr - 1
-      min = min+60
-    end if
-    if (min >= 60) then
-      hr = hr+1
-      min = min-60
-    end if
-    if (hr < 0) then
-      hr = hr+24
-      jday = jday-1
-    end if
-    if (hr >= 24) then
-      hr = hr-24
-      jday = jday+1
-    end if
-
-    if (jday < 1) jday = 1
-    if (xcoor > 180d0) xcoor = xcoor-360d0
-
-    d2r     = pi/180d0
-    r2d     = 1/d2r
-    lsn     = 12.0d0+((ltm-xcoor)/15.0d0)
-    latrad  = ycoor*d2r
-    decrad  = 23.45*d2r*sin(d2r*360d0*(284d0+jday)/365d0)
-    decdeg  = decrad*r2d
-    ha      = hr+min/60.0d0
-    hangle  = (lsn-ha)*60.0d0
-    harad   = hangle*0.0043633d0
-
-    saltrad = asin((sin(latrad)*sin(decrad))+(cos(latrad)*cos(decrad) &
-         *cos(harad)))
-    saltdeg = saltrad * r2d
-    sazirad = asin(cos(decrad)*sin(harad)/cos(saltrad))
-    sazideg = sazirad * r2d
-
-    IF (saltdeg.LT.0.0d0 .OR. saltrad.GT.180.0d0) THEN  ! sun is below horizon
-       saltdeg = 0.0d0
-       saltrad = 0.0d0
-       szendeg = 90.0d0
-       szenrad = 90.0d0*d2r
-       !mass    = 1229d0**.5d0             ! if solaralt=0 -> sin(0)=0
-    ELSE
-       szendeg = 90d0-saltdeg
-       szenrad = szendeg*d2r
-    ENDIF
-    szenith = szendeg
-
-  end function szenith
-
-end module ForcingUpdateMod
diff --git a/components/elm/src/main/VegetationSummaryRoutines.F90 b/components/elm/src/main/VegetationSummaryRoutines.F90
deleted file mode 100644
index 45965e65ea..0000000000
--- a/components/elm/src/main/VegetationSummaryRoutines.F90
+++ /dev/null
@@ -1,1669 +0,0 @@
-module VegetationSummaryRoutinesMod
-
-   use elm_varpar
-   !use VegetationDataType , only : veg_cf, veg_cs, veg_pf, veg_ps
-   use VegetationDataType , only : vegetation_carbon_flux, vegetation_carbon_state
-   use VegetationDataType , only : vegetation_nitrogen_flux, vegetation_nitrogen_state
-   use VegetationDataType , only : vegetation_phosphorus_flux, vegetation_phosphorus_state
-   use VegetationType , only : veg_pp
-   use ColumnType     , only : col_pp
-   use ColumnDataType , only : column_carbon_flux, column_carbon_state
-   use ColumnDataType , only : column_nitrogen_flux, column_nitrogen_state
-   use ColumnDataType , only : column_phosphorus_flux, column_phosphorus_state
-   use CNDecompCascadeConType
-
-   use elm_varpar
-   use elm_varctl
-   use elm_varcon
-
-   public :: veg_cf_summary_acc
-   public :: veg_cs_summary_acc
-   public :: veg_nf_summary_acc
-   public :: veg_ns_summary_acc
-   public :: veg_pf_summary_acc
-   public :: veg_ps_summary_acc
-   public :: summary_p2c
-   public :: veg_cf_setvalues_acc
-   public :: veg_pf_setvalues_acc
-   public :: veg_nf_setvalues_acc
-
-   public :: summary_veg_flux_p2c, summary_veg_state_p2c
-   public :: veg_cf_summary_rr
-
-contains
-   !------------------------------------------------------------
-  subroutine veg_cf_summary_rr(this, num_soilp, filter_soilp, num_soilc, filter_soilc, col_cf_input)
-   !
-   ! !DESCRIPTION:
-   ! summarize root respiration
-   !
-   ! !USES:
-   use subgridAveMod, only : p2c_1d_filter_parallel
-   !
-   ! !ARGUMENTS:
-   type(vegetation_carbon_flux) :: this
-   integer, intent(in) :: num_soilp
-   integer, intent(in) :: filter_soilp(:)
-   integer, intent(in) :: num_soilc
-   integer, intent(in) :: filter_soilc(:)
-   type(column_carbon_flux), intent(inout) :: col_cf_input
-   !
-   ! !LOCAL VARIABLES
-   integer :: fp, p
-   !------------------------------------------------------------
-   !$acc parallel loop independent gang vector private(p) default(present)
-   do fp = 1,num_soilp
-     p = filter_soilp(fp)
-     ! root respiration (RR)
-     this%rr(p) = &
-     this%froot_mr(p) + &
-     this%cpool_froot_gr(p) + &
-     this%cpool_livecroot_gr(p) + &
-     this%cpool_deadcroot_gr(p) + &
-     this%transfer_froot_gr(p) + &
-     this%transfer_livecroot_gr(p) + &
-     this%transfer_deadcroot_gr(p) + &
-     this%cpool_froot_storage_gr(p) + &
-     this%cpool_livecroot_storage_gr(p) + &
-     this%cpool_deadcroot_storage_gr(p)
-   enddo
-   call p2c_1d_filter_parallel(num_soilc, filter_soilc, &
-           this%rr, col_cf_input%rr)
-
- end subroutine veg_cf_summary_rr
-
-
-   subroutine veg_cf_summary_for_ch4_acc( this,num_soilp,filter_soilp )
-     !
-     ! !DESCRIPTION:
-     ! summarize vegetation-level fluxes for methane calculation
-     !
-     ! !USES:
-     !
-     ! !ARGUMENTS:
-     type(vegetation_carbon_flux) :: this
-     integer , intent(in) :: num_soilp 
-     integer , intent(in) :: filter_soilp(:)
-     !!LOCAL VARIABLES:
-     integer :: fp, p 
-
-    !$acc parallel loop independent gang vector default(present) 
-    do fp = 1, num_soilp 
-      p = filter_soilp(fp)
-        !------------------------------------------------------------
-        ! aboveground NPP: leaf, live stem, dead stem (AGNPP)
-        ! This is supposed to correspond as closely as possible to
-        ! field measurements of AGNPP, so it ignores the storage pools
-        ! and only treats the fluxes into displayed pools.
-
-        this%agnpp(p) = &
-             this%cpool_to_leafc(p)                  + &
-             this%leafc_xfer_to_leafc(p)             + &
-             this%cpool_to_livestemc(p)              + &
-             this%livestemc_xfer_to_livestemc(p)     + &
-             this%cpool_to_deadstemc(p)              + &
-             this%deadstemc_xfer_to_deadstemc(p)
-
-        if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-           this%agnpp(p) =                    &
-                this%agnpp(p)               + &
-                this%cpool_to_grainc(p)     + &
-                this%grainc_xfer_to_grainc(p)
-        endif
-
-        ! belowground NPP: fine root, live coarse root, dead coarse root (BGNPP)
-        ! This is supposed to correspond as closely as possible to
-        ! field measurements of BGNPP, so it ignores the storage pools
-        ! and only treats the fluxes into displayed pools.
-        this%bgnpp(p) = &
-             this%cpool_to_frootc(p)                   + &
-             this%frootc_xfer_to_frootc(p)             + &
-             this%cpool_to_livecrootc(p)               + &
-             this%livecrootc_xfer_to_livecrootc(p)     + &
-             this%cpool_to_deadcrootc(p)               + &
-             this%deadcrootc_xfer_to_deadcrootc(p)
-
-        this%agwdnpp(p) = &
-             this%cpool_to_livestemc(p)              + &
-             this%livestemc_xfer_to_livestemc(p)     + &
-             this%cpool_to_deadstemc(p)              + &
-             this%deadstemc_xfer_to_deadstemc(p)
-   end do 
-
-  end subroutine veg_cf_summary_for_ch4_acc
-
-  !-----------------------------------------------------------------------
-  subroutine veg_cf_summary_acc(this, num_soilp,filter_soilp, isotope)
-    !
-    ! !DESCRIPTION:
-    ! patch-level carbon flux summary calculations
-    !
-    ! !USES:
-    !
-    ! !ARGUMENTS:
-    type(vegetation_carbon_flux)                 :: this
-    integer , intent(in) :: num_soilp 
-    integer , intent(in) :: filter_soilp(:)
-    integer ,intent(in)  :: isotope
-    !!LOCAL VARIABLES:
-    integer :: fp, p 
-
-    !$acc data copyin(isotope)
-
-   !$acc parallel loop independent gang vector default(present) 
-   do fp = 1, num_soilp 
-      p = filter_soilp(fp)
-      ! calculate pft-level summary carbon fluxes and states
-
-       ! gross primary production (GPP)
-       this%gpp(p) = &
-            this%psnsun_to_cpool(p) + &
-            this%psnshade_to_cpool(p)
-
-       ! maintenance respiration (MR)
-       this%leaf_mr(p)      = this%leaf_curmr(p)      + this%leaf_xsmr(p)
-       this%froot_mr(p)     = this%froot_curmr(p)     + this%froot_xsmr(p)
-       this%livestem_mr(p)  = this%livestem_curmr(p)  + this%livestem_xsmr(p)
-       this%livecroot_mr(p) = this%livecroot_curmr(p) + this%livecroot_xsmr(p)
-
-       this%mr(p)  = &
-            this%leaf_mr(p)     + &
-            this%froot_mr(p)    + &
-            this%livestem_mr(p) + &
-            this%livecroot_mr(p)
-
-       ! growth respiration (GR)
-       ! current GR is respired this time step for new growth displayed in this timestep
-       this%current_gr(p) = &
-            this%cpool_leaf_gr(p)      + &
-            this%cpool_froot_gr(p)     + &
-            this%cpool_livestem_gr(p)  + &
-            this%cpool_deadstem_gr(p)  + &
-            this%cpool_livecroot_gr(p) + &
-            this%cpool_deadcroot_gr(p)
-
-       ! transfer GR is respired this time step for transfer growth displayed in this timestep
-       this%transfer_gr(p) = &
-            this%transfer_leaf_gr(p)      + &
-            this%transfer_froot_gr(p)     + &
-            this%transfer_livestem_gr(p)  + &
-            this%transfer_deadstem_gr(p)  + &
-            this%transfer_livecroot_gr(p) + &
-            this%transfer_deadcroot_gr(p)
-
-       ! storage GR is respired this time step for growth sent to storage for later display
-       this%storage_gr(p) = &
-            this%cpool_leaf_storage_gr(p)      + &
-            this%cpool_froot_storage_gr(p)     + &
-            this%cpool_livestem_storage_gr(p)  + &
-            this%cpool_deadstem_storage_gr(p)  + &
-            this%cpool_livecroot_storage_gr(p) + &
-            this%cpool_deadcroot_storage_gr(p)
-
-       if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-          this%mr(p) = &
-               this%mr(p) + &
-               this%grain_mr(p)
-
-          this%current_gr(p) = &
-               this%current_gr(p) + &
-               this%cpool_grain_gr(p)
-
-          this%transfer_gr(p) = &
-               this%transfer_gr(p) + &
-               this%transfer_grain_gr(p)
-
-          this%storage_gr(p) = &
-               this%storage_gr(p) + &
-               this%cpool_grain_storage_gr(p)
-       end if
-
-       ! GR is the sum of current + transfer + storage GR
-       this%gr(p) = &
-            this%current_gr(p)  + &
-            this%transfer_gr(p) + &
-            this%storage_gr(p)
-
-       ! autotrophic respiration (AR)
-       if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-          this%ar(p) = &
-               this%mr(p) + &
-               this%gr(p) + &
-               this%xr(p) + &
-               this%xsmrpool_to_atm(p) ! xsmr... is -ve (slevis)
-          if (nu_com .ne. 'RD' ) then
-             this%ar(p) = this%ar(p) + &
-                  this%xsmrpool_turnover(p)
-          end if
-       else
-          this%ar(p) = &
-               this%mr(p) + &
-               this%gr(p) + &
-               this%xr(p)
-           if (nu_com .ne. 'RD' ) then
-              this%ar(p) = this%ar(p) + &
-                   this%xsmrpool_turnover(p)
-           end if
-       end if
-
-       ! net primary production (NPP)
-       this%npp(p) = &
-            this%gpp(p) - &
-            this%ar(p)
-
-       ! update the annual NPP accumulator, for use in allocation code
-       if (isotope == 2) then
-          this%tempsum_npp(p) = &
-               this%tempsum_npp(p) + &
-               this%npp(p)
-       end if
-
-       ! litterfall (LITFALL)
-
-       this%litfall(p) = &
-            this%leafc_to_litter(p)                     + &
-            this%frootc_to_litter(p)                    + &
-            this%m_leafc_to_litter(p)                   + &
-            this%m_leafc_storage_to_litter(p)           + &
-            this%m_leafc_xfer_to_litter(p)              + &
-            this%m_frootc_to_litter(p)                  + &
-            this%m_frootc_storage_to_litter(p)          + &
-            this%m_frootc_xfer_to_litter(p)             + &
-            this%m_livestemc_to_litter(p)               + &
-            this%m_livestemc_storage_to_litter(p)       + &
-            this%m_livestemc_xfer_to_litter(p)          + &
-            this%m_deadstemc_to_litter(p)               + &
-            this%m_deadstemc_storage_to_litter(p)       + &
-            this%m_deadstemc_xfer_to_litter(p)          + &
-            this%m_livecrootc_to_litter(p)              + &
-            this%m_livecrootc_storage_to_litter(p)      + &
-            this%m_livecrootc_xfer_to_litter(p)         + &
-            this%m_deadcrootc_to_litter(p)              + &
-            this%m_deadcrootc_storage_to_litter(p)      + &
-            this%m_deadcrootc_xfer_to_litter(p)         + &
-            this%m_gresp_storage_to_litter(p)           + &
-            this%m_gresp_xfer_to_litter(p)              + &
-            this%m_leafc_to_litter_fire(p)              + &
-            this%m_leafc_storage_to_litter_fire(p)      + &
-            this%m_leafc_xfer_to_litter_fire(p)         + &
-            this%m_livestemc_to_litter_fire(p)          + &
-            this%m_livestemc_storage_to_litter_fire(p)  + &
-            this%m_livestemc_xfer_to_litter_fire(p)     + &
-            this%m_deadstemc_to_litter_fire(p)          + &
-            this%m_deadstemc_storage_to_litter_fire(p)  + &
-            this%m_deadstemc_xfer_to_litter_fire(p)     + &
-            this%m_frootc_to_litter_fire(p)             + &
-            this%m_frootc_storage_to_litter_fire(p)     + &
-            this%m_frootc_xfer_to_litter_fire(p)        + &
-            this%m_livecrootc_to_litter_fire(p)         + &
-            this%m_livecrootc_storage_to_litter_fire(p) + &
-            this%m_livecrootc_xfer_to_litter_fire(p)    + &
-            this%m_deadcrootc_to_litter_fire(p)         + &
-            this%m_deadcrootc_storage_to_litter_fire(p) + &
-            this%m_deadcrootc_xfer_to_litter_fire(p)    + &
-            this%m_gresp_storage_to_litter_fire(p)      + &
-            this%m_gresp_xfer_to_litter_fire(p)         + &
-            this%hrv_leafc_to_litter(p)                 + &
-            this%hrv_leafc_storage_to_litter(p)         + &
-            this%hrv_leafc_xfer_to_litter(p)            + &
-            this%hrv_frootc_to_litter(p)                + &
-            this%hrv_frootc_storage_to_litter(p)        + &
-            this%hrv_frootc_xfer_to_litter(p)           + &
-            this%hrv_livestemc_to_litter(p)             + &
-            this%hrv_livestemc_storage_to_litter(p)     + &
-            this%hrv_livestemc_xfer_to_litter(p)        + &
-            this%hrv_deadstemc_storage_to_litter(p)     + &
-            this%hrv_deadstemc_xfer_to_litter(p)        + &
-            this%hrv_livecrootc_to_litter(p)            + &
-            this%hrv_livecrootc_storage_to_litter(p)    + &
-            this%hrv_livecrootc_xfer_to_litter(p)       + &
-            this%hrv_deadcrootc_to_litter(p)            + &
-            this%hrv_deadcrootc_storage_to_litter(p)    + &
-            this%hrv_deadcrootc_xfer_to_litter(p)       + &
-            this%hrv_gresp_storage_to_litter(p)         + &
-            this%hrv_gresp_xfer_to_litter(p)            + &
-            this%hrv_cpool_to_litter(p)
-
-       ! patch-level fire losses (VEGFIRE)
-       this%vegfire(p) = 0._r8
-
-       ! patch-level wood harvest
-       this%wood_harvestc(p) = &
-            this%hrv_deadstemc_to_prod10c(p) + &
-            this%hrv_deadstemc_to_prod100c(p)
-       if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-          this%wood_harvestc(p) = &
-               this%wood_harvestc(p) + &
-               this%hrv_cropc_to_prod1c(p)
-       end if
-
-       ! patch-level carbon losses to fire changed by F. Li and S. Levis
-       this%fire_closs(p) = &
-            this%m_leafc_to_fire(p)                + &
-            this%m_leafc_storage_to_fire(p)        + &
-            this%m_leafc_xfer_to_fire(p)           + &
-            this%m_frootc_to_fire(p)               + &
-            this%m_frootc_storage_to_fire(p)       + &
-            this%m_frootc_xfer_to_fire(p)          + &
-            this%m_livestemc_to_fire(p)            + &
-            this%m_livestemc_storage_to_fire(p)    + &
-            this%m_livestemc_xfer_to_fire(p)       + &
-            this%m_deadstemc_to_fire(p)            + &
-            this%m_deadstemc_storage_to_fire(p)    + &
-            this%m_deadstemc_xfer_to_fire(p)       + &
-            this%m_livecrootc_to_fire(p)           + &
-            this%m_livecrootc_storage_to_fire(p)   + &
-            this%m_livecrootc_xfer_to_fire(p)      + &
-            this%m_deadcrootc_to_fire(p)           + &
-            this%m_deadcrootc_storage_to_fire(p)   + &
-            this%m_deadcrootc_xfer_to_fire(p)      + &
-            this%m_gresp_storage_to_fire(p)        + &
-            this%m_gresp_xfer_to_fire(p)           + &
-            this%m_cpool_to_fire(p)
-
-       if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-          this%litfall(p) =                  &
-               this%litfall(p)             + &
-               this%livestemc_to_litter(p) + &
-               this%grainc_to_food(p)
-       end if
-
-       ! new summary variables for CLAMP
-
-       ! (FROOTC_ALLOC) - fine root C allocation
-       this%frootc_alloc(p) = &
-            this%frootc_xfer_to_frootc(p)    + &
-            this%cpool_to_frootc(p)
-
-       ! (FROOTC_LOSS) - fine root C loss changed by F. Li and S. Levis
-       this%frootc_loss(p) = &
-            this%m_frootc_to_litter(p)       + &
-            this%m_frootc_to_fire(p)         + &
-            this%m_frootc_to_litter_fire(p)  + &
-            this%hrv_frootc_to_litter(p)     + &
-            this%frootc_to_litter(p)
-
-       ! (LEAFC_ALLOC) - leaf C allocation
-       this%leafc_alloc(p) = &
-            this%leafc_xfer_to_leafc(p)    + &
-            this%cpool_to_leafc(p)
-
-       ! (LEAFC_LOSS) - leaf C loss changed by F. Li and S. Levis
-       this%leafc_loss(p) = &
-            this%m_leafc_to_litter(p)      + &
-            this%m_leafc_to_fire(p)        + &
-            this%m_leafc_to_litter_fire(p) + &
-            this%hrv_leafc_to_litter(p)    + &
-            this%leafc_to_litter(p)
-
-       if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-          this%leafc_loss(p) = &
-               this%leafc_loss(p) + &
-               this%hrv_leafc_to_prod1c(p)
-       end if
-
-
-       ! (WOODC_ALLOC) - wood C allocation
-       this%woodc_alloc(p) = &
-            this%livestemc_xfer_to_livestemc(p)   + &
-            this%deadstemc_xfer_to_deadstemc(p)   + &
-            this%livecrootc_xfer_to_livecrootc(p) + &
-            this%deadcrootc_xfer_to_deadcrootc(p) + &
-            this%cpool_to_livestemc(p)            + &
-            this%cpool_to_deadstemc(p)            + &
-            this%cpool_to_livecrootc(p)           + &
-            this%cpool_to_deadcrootc(p)
-
-       ! (WOODC_LOSS) - wood C loss
-       this%woodc_loss(p) = &
-            this%m_livestemc_to_litter(p)            + &
-            this%m_deadstemc_to_litter(p)            + &
-            this%m_livecrootc_to_litter(p)           + &
-            this%m_deadcrootc_to_litter(p)           + &
-            this%m_livestemc_to_fire(p)              + &
-            this%m_deadstemc_to_fire(p)              + &
-            this%m_livecrootc_to_fire(p)             + &
-            this%m_deadcrootc_to_fire(p)             + &
-            this%hrv_livestemc_to_litter(p)          + &
-            this%hrv_livestemc_storage_to_litter(p)  + &
-            this%hrv_livestemc_xfer_to_litter(p)     + &
-            this%hrv_deadstemc_to_prod10c(p)         + &
-            this%hrv_deadstemc_to_prod100c(p)        + &
-            this%hrv_deadstemc_storage_to_litter(p)  + &
-            this%hrv_deadstemc_xfer_to_litter(p)     + &
-            this%hrv_livecrootc_to_litter(p)         + &
-            this%hrv_livecrootc_storage_to_litter(p) + &
-            this%hrv_livecrootc_xfer_to_litter(p)    + &
-            this%hrv_deadcrootc_to_litter(p)         + &
-            this%hrv_deadcrootc_storage_to_litter(p) + &
-            this%hrv_deadcrootc_xfer_to_litter(p)
-       ! putting the harvested crop stem and grain in the wood loss bdrewniak
-       if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-          this%woodc_loss(p) = &
-               this%woodc_loss(p) + &
-               this%hrv_grainc_to_prod1c(p) + &
-               this%hrv_livestemc_to_prod1c(p)
-       end if
-   end do 
-   !$acc end data 
-  end subroutine veg_cf_summary_acc
-
-  !-----------------------------------------------------------------------
-  subroutine veg_cs_summary_acc(this, num_soilp, filter_soilp)
-    !
-    ! !DESCRIPTION:
-    ! Vegetation-level carbon state summary calculations
-    ! !ARGUMENTS:
-    type(vegetation_carbon_state)                :: this
-    integer , intent(in) :: num_soilp 
-    integer , intent(in) :: filter_soilp(:)
-
-    !!LOCAL VARIABLES:
-    integer :: fp, p 
-
-   !$acc parallel loop independent gang vector default(present) 
-   do fp = 1, num_soilp 
-      p = filter_soilp(fp)
-
-      ! displayed vegetation carbon, excluding storage and cpool (DISPVEGC)
-      this%dispvegc(p) =        &
-           this%leafc(p)      + &
-           this%frootc(p)     + &
-           this%livestemc(p)  + &
-           this%deadstemc(p)  + &
-           this%livecrootc(p) + &
-           this%deadcrootc(p)
-
-      ! stored vegetation carbon, excluding cpool (STORVEGC)
-      this%storvegc(p) =                &
-           this%cpool(p)              + &
-           this%leafc_storage(p)      + &
-           this%frootc_storage(p)     + &
-           this%livestemc_storage(p)  + &
-           this%deadstemc_storage(p)  + &
-           this%livecrootc_storage(p) + &
-           this%deadcrootc_storage(p) + &
-           this%leafc_xfer(p)         + &
-           this%frootc_xfer(p)        + &
-           this%livestemc_xfer(p)     + &
-           this%deadstemc_xfer(p)     + &
-           this%livecrootc_xfer(p)    + &
-           this%deadcrootc_xfer(p)    + &
-           this%gresp_storage(p)      + &
-           this%gresp_xfer(p)
-
-      if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-          this%storvegc(p) =            &
-               this%storvegc(p)       + &
-               this%grainc_storage(p) + &
-               this%grainc_xfer(p)
-
-          this%dispvegc(p) =            &
-               this%dispvegc(p)       + &
-               this%grainc(p)
-      end if
-
-      ! total vegetation carbon, excluding cpool (TOTVEGC)
-      this%totvegc(p) = &
-           this%dispvegc(p) + &
-           this%storvegc(p)
-
-      ! total pft-level carbon, including xsmrpool, ctrunc
-      this%totpftc(p) = &
-           this%totvegc(p) + &
-           this%xsmrpool(p) + &
-           this%ctrunc(p)
-
-      ! (WOODC) - wood C
-      this%woodc(p) = &
-           this%deadstemc(p)    + &
-           this%livestemc(p)    + &
-           this%deadcrootc(p)   + &
-           this%livecrootc(p)
-
-      this%totvegc_abg(p) = &
-               this%leafc(p)              + &
-               this%leafc_storage(p)      + &
-               this%leafc_xfer(p)         + &
-               this%livestemc(p)          + &
-               this%livestemc_storage(p)  + &
-               this%livestemc_xfer(p)     + &
-               this%deadstemc(p)          + &
-               this%deadstemc_storage(p)  + &
-               this%deadstemc_xfer(p)
-   end do 
-
-  end subroutine veg_cs_summary_acc
-
-subroutine summary_veg_state_p2c ( numfc, filterc,veg_cs, col_cs, &
-                  veg_ps,col_ps, veg_ns, col_ns)
-  !
-  ! !DESCRIPTION:
-  ! perform pft to column averaging for single level pft arrays
-  !
-  ! !ARGUMENTS:
-  integer , intent(in)  :: numfc
-  integer , intent(in)  :: filterc(numfc)
-  type(vegetation_carbon_state), intent(inout)   :: veg_cs
-  type(column_carbon_state)    , intent(inout)   :: col_cs  ! column-level state for p2c
-  type(vegetation_phosphorus_state), intent(inout)::veg_ps
-  type(column_phosphorus_state), intent(inout)   :: col_ps
-  type(vegetation_nitrogen_state), intent(inout) :: veg_ns
-  type(column_nitrogen_state)  , intent(inout)   :: col_ns
-
-  ! !LOCAL VARIABLES:
-  integer :: fc,c,p  ! indices
-  real(r8) :: sum1, sum2, sum3, sum4
-  real(r8) :: psum1, psum2, psum3
-  real(r8) :: nsum1, nsum2, nsum3, nsum4
-
-
-  !-----------------------------------------------------------------------
-  !$acc enter data create(sum1,sum2,sum3,sum4,psum1,psum2,psum3,&
-   !$acc nsum1, nsum2, nsum3, nsum4)
-  !$acc parallel loop gang worker default(present) private(c)
-  do fc = 1,numfc
-     c = filterc(fc)
-     sum1= 0._r8
-     sum2= 0._r8
-     sum3= 0._r8
-     sum4= 0._r8
-     psum1 = 0._r8; psum2 = 0._r8; psum3 = 0._r8;
-     nsum1 = 0._r8; nsum2 = 0._r8; nsum3 = 0._r8; nsum4 = 0._r8
-     !$acc loop vector reduction(+:sum1,sum2,sum3,sum4,psum1,psum2,psum3,nsum1, nsum2, nsum3, nsum4)
-     do p = col_pp%pfti(c), col_pp%pftf(c)
-        if (veg_pp%active(p)) then
-            sum1 = sum1 + veg_cs%totpftc(p)           * veg_pp%wtcol(p)
-            sum2 = sum2 + veg_cs%totvegc(p)           * veg_pp%wtcol(p)
-            sum3 = sum3 + veg_cs%totvegc_abg(p)       * veg_pp%wtcol(p)
-            sum4 = sum4 + veg_cs%cropseedc_deficit(p) * veg_pp%wtcol(p)
-            ! phosphorus state:
-            psum1 = psum1 + veg_ps%totvegp(p) * veg_pp%wtcol(p)
-            psum2 = psum2 + veg_ps%totpftp(p) * veg_pp%wtcol(p)
-            psum3 = psum3 + veg_ps%cropseedp_deficit(p) * veg_pp%wtcol(p)
-            !Nitrogen State:
-            nsum1 = nsum1 + veg_ns%totvegn(p) * veg_pp%wtcol(p)
-            nsum2 = nsum2 + veg_ns%totpftn(p) * veg_pp%wtcol(p)
-            nsum3 = nsum3 + veg_ns%cropseedn_deficit(p) * veg_pp%wtcol(p)
-            nsum4 = nsum4 + veg_ns%plant_n_buffer(p) * veg_pp%wtcol(p)
-         end if
-     end do
-     col_cs%totpftc(c)          = sum1
-     col_cs%totvegc(c)          = sum2
-     col_cs%totvegc_abg(c)      = sum3
-     col_cs%cropseedc_deficit(c)= sum4
-     ! phosphorus state:
-     col_ps%totpftp(c)          = psum1
-     col_ps%totvegp(c)          = psum2
-     col_ps%cropseedp_deficit(c)= psum3
-     ! nitrogen state:
-     col_ns%totpftn(c)           = nsum1
-     col_ns%totvegn(c)           = nsum2
-     col_ns%cropseedn_deficit(c) = nsum3
-     col_ns%plant_n_buffer(c)    = nsum4
-
-  end do
-
-end subroutine summary_veg_state_p2c
-
-subroutine summary_veg_flux_p2c(numfc, filterc, veg_cf, col_cf,&
-                     veg_pf,col_pf, veg_nf, col_nf)
-
-   integer , intent(in)  :: numfc
-   integer , intent(in)  :: filterc(numfc)
-   type(vegetation_carbon_flux), intent(inout)   :: veg_cf
-   type (column_carbon_flux), intent(inout) :: col_cf          ! column-level state for p2c
-   type(vegetation_phosphorus_flux), intent(inout) :: veg_pf
-   type(column_phosphorus_flux)  , intent(inout)   :: col_pf
-   type(vegetation_nitrogen_flux), intent(inout)   :: veg_nf
-   type(column_nitrogen_flux)    , intent(inout)   :: col_nf
-
-   ! !LOCAL VARIABLES:
-   integer :: fc,c,p  ! indices
-   real(r8) :: sum1, sum2, sum3, sum4, sum5, sum6, sum7, sum8
-   real(r8) :: psum1, psum2, nsum1, nsum2
-
-
-   !$acc enter data create(sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8,&
-   !$acc                   psum1,psum2)
-
-   !$acc parallel loop gang worker default(present) private(c)
-   do fc = 1,numfc
-     c = filterc(fc)
-     sum1= 0._r8; sum2= 0._r8; sum3= 0._r8
-     sum4= 0._r8; sum5= 0._r8; sum6= 0._r8
-     sum7= 0._r8; sum8= 0._r8
-
-     psum1 = 0._r8; psum2 = 0._r8;
-     !$acc loop vector reduction(+:sum1,sum2,sum3,sum4 ,&
-     !$acc  sum5, sum6, sum7, sum8, psum1, psum2)
-     do p = col_pp%pfti(c), col_pp%pftf(c)
-         if (veg_pp%active(p)) then
-             ! carbon flux :
-             sum1 = sum1 + veg_cf%gpp(p)     * veg_pp%wtcol(p)
-             sum2 = sum2 + veg_cf%ar (p)     * veg_pp%wtcol(p)
-             sum3 = sum3 + veg_cf%npp(p)     * veg_pp%wtcol(p)
-             sum4 = sum4 + veg_cf%vegfire(p) * veg_pp%wtcol(p)
-             sum5 = sum5 + veg_cf%wood_harvestc(p) * veg_pp%wtcol(p)
-             sum6 = sum6 + veg_cf%fire_closs(p) * veg_pp%wtcol(p)
-             sum7 = sum7 + veg_cf%litfall(p) * veg_pp%wtcol(p)
-             sum8 = sum8 + veg_cf%hrv_xsmrpool_to_atm(p) * veg_pp%wtcol(p)
-             ! phophorus flux :
-             psum1 = psum1 + veg_pf%fire_ploss(p)   * veg_pp%wtcol(p)
-             psum2 = psum2 + veg_pf%wood_harvestp(p)* veg_pp%wtcol(p)
-             ! nitrogen flux :
-             nsum1 = nsum1 + veg_nf%fire_nloss(p)   * veg_pp%wtcol(p)
-             nsum2 = nsum2 + veg_nf%wood_harvestn(p)* veg_pp%wtcol(p)
-          end if
-     end do
-     col_cf%gpp(c)  = sum1; col_cf%ar (c)  = sum2
-     col_cf%npp(c)  = sum3; col_cf%vegfire(c) = sum4
-     col_cf%wood_harvestc(c)  = sum5
-     col_cf%fire_closs_p2c(c) = sum6
-     col_cf%litfall(c) = sum7; col_cf%hrv_xsmrpool_to_atm(c) = sum8
-     ! phosphorus flux :
-     col_pf%fire_ploss_p2c(c) = psum1
-     col_pf%wood_harvestp(c)  = psum2
-     ! nitrogen flux :
-     col_nf%fire_nloss_p2c(c) = nsum1
-     col_nf%wood_harvestn(c)  = nsum2
-   end do
-
-end subroutine summary_veg_flux_p2c
-
-!-----------------------------------------------------------------------
-subroutine veg_nf_summary_acc(this, num_soilp, filter_soilp)
-  !
-  ! !DESCRIPTION:
-  ! Vegetation-level nitrogen flux summary calculations
-  !
-  ! !ARGUMENTS:
-  type(vegetation_nitrogen_flux)             :: this
-  integer , intent(in) :: num_soilp
-  integer , intent(in) :: filter_soilp(:) 
-  !
-  integer :: fp, p 
-
-  !$acc parallel loop independent gang vector default(present) 
-  do fp = 1, num_soilp 
-      p = filter_soilp(fp)
-     ! total N deployment (from sminn and retranslocated N pool) (NDEPLOY)
-     this%ndeploy(p) = &
-          this%sminn_to_npool(p) + &
-          this%retransn_to_npool(p)
-
-     ! pft-level wood harvest
-     this%wood_harvestn(p) = &
-          this%hrv_deadstemn_to_prod10n(p) + &
-          this%hrv_deadstemn_to_prod100n(p)
-     if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-          this%wood_harvestn(p) = &
-          this%wood_harvestn(p) + &
-          this%hrv_cropn_to_prod1n(p)
-     end if
-
-     ! total pft-level fire N losses
-     this%fire_nloss(p) = &
-          this%m_leafn_to_fire(p)               + &
-          this%m_leafn_storage_to_fire(p)       + &
-          this%m_leafn_xfer_to_fire(p)          + &
-          this%m_frootn_to_fire(p)              + &
-          this%m_frootn_storage_to_fire(p)      + &
-          this%m_frootn_xfer_to_fire(p)         + &
-          this%m_livestemn_to_fire(p)           + &
-          this%m_livestemn_storage_to_fire(p)   + &
-          this%m_livestemn_xfer_to_fire(p)      + &
-          this%m_deadstemn_to_fire(p)           + &
-          this%m_deadstemn_storage_to_fire(p)   + &
-          this%m_deadstemn_xfer_to_fire(p)      + &
-          this%m_livecrootn_to_fire(p)          + &
-          this%m_livecrootn_storage_to_fire(p)  + &
-          this%m_livecrootn_xfer_to_fire(p)     + &
-          this%m_deadcrootn_to_fire(p)          + &
-          this%m_deadcrootn_storage_to_fire(p)  + &
-          this%m_deadcrootn_xfer_to_fire(p)     + &
-          this%m_retransn_to_fire(p)            + &
-          this%m_npool_to_fire(p)
-
-    this%gap_nloss_litter(p) = &
-         this%m_leafn_to_litter(p)              + &
-         this%m_leafn_storage_to_litter(p)      + &
-         this%m_leafn_xfer_to_litter(p)         + &
-         this%m_frootn_to_litter(p)             + &
-         this%m_frootn_storage_to_litter(p)     + &
-         this%m_frootn_xfer_to_litter(p)        + &
-         this%m_livestemn_to_litter(p)          + &
-         this%m_livestemn_storage_to_litter(p)  + &
-         this%m_livestemn_xfer_to_litter(p)     + &
-         this%m_deadstemn_to_litter(p)          + &
-         this%m_deadstemn_storage_to_litter(p)  + &
-         this%m_deadstemn_xfer_to_litter(p)     + &
-         this%m_livecrootn_to_litter(p)         + &
-         this%m_livecrootn_storage_to_litter(p) + &
-         this%m_livecrootn_xfer_to_litter(p)    + &
-         this%m_deadcrootn_to_litter(p)         + &
-         this%m_deadcrootn_storage_to_litter(p) + &
-         this%m_deadcrootn_xfer_to_litter(p)    + &
-         this%m_retransn_to_litter(p)           + &
-         this%m_npool_to_litter(p)
-
-    this%fire_nloss_litter(p) = &
-         this%m_deadstemn_to_litter_fire(p)     + &
-         this%m_deadcrootn_to_litter_fire(p)    + &
-         this%m_retransn_to_litter_fire(p)      + &
-         this%m_npool_to_litter_fire(p)         + &
-         this%m_leafn_to_litter_fire(p)         + &
-         this%m_frootn_to_litter_fire(p)        + &
-         this%m_livestemn_to_litter_fire(p)     + &
-         this%m_livecrootn_to_litter_fire(p)    + &
-         this%m_leafn_storage_to_litter_fire(p) + &
-         this%m_frootn_storage_to_litter_fire(p)       + &
-         this%m_livestemn_storage_to_litter_fire(p)    + &
-         this%m_deadstemn_storage_to_litter_fire(p)    + &
-         this%m_livecrootn_storage_to_litter_fire(p)   + &
-         this%m_deadcrootn_storage_to_litter_fire(p)   + &
-         this%m_leafn_xfer_to_litter_fire(p)           + &
-         this%m_frootn_xfer_to_litter_fire(p)          + &
-         this%m_livestemn_xfer_to_litter_fire(p)       + &
-         this%m_deadstemn_xfer_to_litter_fire(p)       + &
-         this%m_livecrootn_xfer_to_litter_fire(p)      + &
-         this%m_deadcrootn_xfer_to_litter_fire(p)
-
-    this%hrv_nloss_litter(p) = &
-         this%hrv_retransn_to_litter(p)          + &
-         this%hrv_npool_to_litter(p)             + &
-         this%hrv_leafn_to_litter(p)             + &
-         this%hrv_leafn_storage_to_litter(p)     + &
-         this%hrv_leafn_xfer_to_litter(p)        + &
-         this%hrv_frootn_to_litter(p)            + &
-         this%hrv_frootn_storage_to_litter(p)    + &
-         this%hrv_frootn_xfer_to_litter(p)       + &
-         this%hrv_livestemn_to_litter(p)         + &
-         this%hrv_livestemn_storage_to_litter(p) + &
-         this%hrv_livestemn_xfer_to_litter(p)    + &
-         this%hrv_deadstemn_storage_to_litter(p) + &
-         this%hrv_deadstemn_xfer_to_litter(p)    + &
-         this%hrv_livecrootn_to_litter(p)        + &
-         this%hrv_livecrootn_storage_to_litter(p)+ &
-         this%hrv_livecrootn_xfer_to_litter(p)   + &
-         this%hrv_deadcrootn_to_litter(p)        + &
-         this%hrv_deadcrootn_storage_to_litter(p)+ &
-         this%hrv_deadcrootn_xfer_to_litter(p)
-    if (crop_prog) then
-       this%sen_nloss_litter(p) = &
-           this%livestemn_to_litter(p)            + &
-           this%leafn_to_litter(p)                + &
-           this%frootn_to_litter(p)
-    else
-       this%sen_nloss_litter(p) = &
-           this%leafn_to_litter(p)                + &
-           this%frootn_to_litter(p)
-    end if
-   end do 
-
-  ! call p2c(bounds, num_soilc, filter_soilc, &
-  !      fire_nloss_patch(bounds%begp:bounds%endp)    , &
-  !      fire_nloss_col(bounds%begc:bounds%endc))
-  !
-  ! call p2c(bounds, num_soilc, filter_soilc, &
-  !      wood_harvestn_patch(bounds%begp:bounds%endp) , &
-  !      wood_harvestn_col(bounds%begc:bounds%endc))
-
-end subroutine veg_nf_summary_acc
-
-!-----------------------------------------------------------------------
-subroutine veg_ns_summary_acc(this,num_soilp, filter_soilp)
-  !
-  ! !DESCRIPTION:
-  ! Vegetation-level nitrogen state summary calculations
-  !
-  ! !ARGUMENTS:
-  type(vegetation_nitrogen_state)            :: this
-  integer , intent(in) :: num_soilp
-  integer , intent(in) :: filter_soilp(:) 
-  ! !LOCAL VARIABLES:
-  !
-  integer :: fp, p 
-
-  !$acc parallel loop independent gang vector default(present) 
-  do fp = 1, num_soilp 
-      p = filter_soilp(fp)
-
-     ! displayed vegetation nitrogen, excluding storage (DISPVEGN)
-     this%dispvegn(p) = &
-          this%leafn(p)      + &
-          this%frootn(p)     + &
-          this%livestemn(p)  + &
-          this%deadstemn(p)  + &
-          this%livecrootn(p) + &
-          this%deadcrootn(p)
-
-    ! stored vegetation nitrogen, including retranslocated N pool (STORVEGN)
-    this%storvegn(p) = &
-         this%leafn_storage(p)      + &
-         this%frootn_storage(p)     + &
-         this%livestemn_storage(p)  + &
-         this%deadstemn_storage(p)  + &
-         this%livecrootn_storage(p) + &
-         this%deadcrootn_storage(p) + &
-         this%leafn_xfer(p)         + &
-         this%frootn_xfer(p)        + &
-         this%livestemn_xfer(p)     + &
-         this%deadstemn_xfer(p)     + &
-         this%livecrootn_xfer(p)    + &
-         this%deadcrootn_xfer(p)    + &
-         this%npool(p)              + &
-         this%retransn(p)
-
-    if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-       this%dispvegn(p) = &
-            this%dispvegn(p) + &
-            this%grainn(p)
-
-       this%storvegn(p) = &
-            this%storvegn(p) + &
-            this%grainn_storage(p)     + &
-            this%grainn_xfer(p)
-    end if
-
-    ! total vegetation nitrogen (TOTVEGN)
-    this%totvegn(p) = &
-         this%dispvegn(p) + &
-         this%storvegn(p)
-
-    ! total pft-level carbon (add pft_ntrunc)
-    this%totpftn(p) = &
-         this%totvegn(p) + &
-         this%ntrunc(p)
-   end do 
-
- ! call p2c(bounds, num_soilc, filter_soilc, &
- !      plant_n_buffer_patch(bounds%begp:bounds%endp)  , &
- !      plant_n_buffer_col(bounds%begc:bounds%endc))
- !
- ! call p2c(bounds, num_soilc, filter_soilc, &
- !      totvegn_patch(bounds%begp:bounds%endp) , &
- !      totvegn_col(bounds%begc:bounds%endc))
- !
- ! call p2c(bounds, num_soilc, filter_soilc, &
- !      totpftn_patch(bounds%begp:bounds%endp) , &
- !      totpftn_col(bounds%begc:bounds%endc))
- !
- ! call p2c(bounds, num_soilc, filter_soilc, &
- !      cropseedn_deficit_patch(bounds%begp:bounds%endp) , &
- !      cropseedn_deficit_col(bounds%begc:bounds%endc))
-
-end subroutine veg_ns_summary_acc
-
-!-----------------------------------------------------------------------
-subroutine veg_ps_summary_acc(this, num_soilp, filter_soilp)
-  ! !ARGUMENTS:
-  type (vegetation_phosphorus_state) :: this
-  integer , intent(in) :: num_soilp
-  integer , intent(in) :: filter_soilp(:) 
-  ! !LOCAL VARIABLES:
-  !
-  integer :: fp, p 
-  !$acc parallel loop independent gang vector default(present) 
-  do fp = 1, num_soilp 
-      p = filter_soilp(fp)
-     ! displayed vegetation phosphorus, excluding storage (DISPVEGN)
-     this%dispvegp(p) = &
-          this%leafp(p)      + &
-          this%frootp(p)     + &
-          this%livestemp(p)  + &
-          this%deadstemp(p)  + &
-          this%livecrootp(p) + &
-          this%deadcrootp(p)
-
-    ! stored vegetation phosphorus, including retranslocated N pool (STORVEGN)
-    this%storvegp(p) = &
-         this%leafp_storage(p)      + &
-         this%frootp_storage(p)     + &
-         this%livestemp_storage(p)  + &
-         this%deadstemp_storage(p)  + &
-         this%livecrootp_storage(p) + &
-         this%deadcrootp_storage(p) + &
-         this%leafp_xfer(p)         + &
-         this%frootp_xfer(p)        + &
-         this%livestemp_xfer(p)     + &
-         this%deadstemp_xfer(p)     + &
-         this%livecrootp_xfer(p)    + &
-         this%deadcrootp_xfer(p)    + &
-         this%ppool(p)              + &
-         this%retransp(p)
-
-    if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-      this%dispvegp(p) = &
-           this%dispvegp(p) + &
-           this%grainp(p)
-
-      this%storvegp(p) = &
-           this%storvegp(p) + &
-           this%grainp_storage(p)     + &
-           this%grainp_xfer(p)
-    end if
-
-    ! total vegetation phosphorus (TOTVEGN)
-    this%totvegp(p) = this%dispvegp(p) + this%storvegp(p)
-
-    ! total pft-level carbon (add pft_ntrunc)
-    this%totpftp(p) = this%totvegp(p) + this%ptrunc(p)
-
-   end do 
-
- ! call p2c(bounds, num_soilc, filter_soilc, &
- !     totvegp_patch(bounds%begp:bounds%endp)  , &
- !     totvegp_col(bounds%begc:bounds%endc) )
- !
- ! call p2c(bounds, num_soilc, filter_soilc, &
- !     totpftp_patch(bounds%begp:bounds%endp) , &
- !     totpftp_col(bounds%begc:bounds%endc) )
- !
- ! call p2c(bounds, num_soilc, filter_soilc, &
- !     cropseedp_deficit_patch(bounds%begp:bounds%endp) , &
- !     cropseedp_deficit_col(bounds%begc:bounds%endc) )
-
-end subroutine veg_ps_summary_acc
-
-
-
-!-----------------------------------------------------------------------
-subroutine veg_pf_summary_acc(this,num_soilp, filter_soilp)
-  !
-  ! !ARGUMENTS:
-  type (vegetation_phosphorus_flux) :: this
-  integer , intent(in) :: num_soilp
-  integer , intent(in) :: filter_soilp(:) 
-  ! !LOCAL VARIABLES:
-  !
-  integer :: fp, p
-   
-  !$acc parallel loop independent gang vector default(present) 
-  do fp = 1, num_soilp 
-      p = filter_soilp(fp)
-      ! total P deployment (from sminn and retranslocated P pool) (PDEPLOY)
-      this%pdeploy(p) = &
-          this%sminp_to_ppool(p) + &
-          this%retransp_to_ppool(p)
-
-     ! pft-level wood harvest
-     this%wood_harvestp(p) = &
-          this%hrv_deadstemp_to_prod10p(p) + &
-          this%hrv_deadstemp_to_prod100p(p)
-     if ( crop_prog .and. veg_pp%itype(p) >= npcropmin )then
-          this%wood_harvestp(p) = &
-          this%wood_harvestp(p) + &
-          this%hrv_cropp_to_prod1p(p)
-     end if
-
-     ! total pft-level fire P losses
-     this%fire_ploss(p) = &
-          this%m_leafp_to_fire(p)               + &
-          this%m_leafp_storage_to_fire(p)       + &
-          this%m_leafp_xfer_to_fire(p)          + &
-          this%m_frootp_to_fire(p)              + &
-          this%m_frootp_storage_to_fire(p)      + &
-          this%m_frootp_xfer_to_fire(p)         + &
-          this%m_livestemp_to_fire(p)           + &
-          this%m_livestemp_storage_to_fire(p)   + &
-          this%m_livestemp_xfer_to_fire(p)      + &
-          this%m_deadstemp_to_fire(p)           + &
-          this%m_deadstemp_storage_to_fire(p)   + &
-          this%m_deadstemp_xfer_to_fire(p)      + &
-          this%m_livecrootp_to_fire(p)          + &
-          this%m_livecrootp_storage_to_fire(p)  + &
-          this%m_livecrootp_xfer_to_fire(p)     + &
-          this%m_deadcrootp_to_fire(p)          + &
-          this%m_deadcrootp_storage_to_fire(p)  + &
-          this%m_deadcrootp_xfer_to_fire(p)     + &
-          this%m_retransp_to_fire(p)            + &
-          this%m_ppool_to_fire(p)
-
-    this%gap_ploss_litter(p) = &
-         this%m_leafp_to_litter(p)              + &
-         this%m_leafp_storage_to_litter(p)      + &
-         this%m_leafp_xfer_to_litter(p)         + &
-         this%m_frootp_to_litter(p)             + &
-         this%m_frootp_storage_to_litter(p)     + &
-         this%m_frootp_xfer_to_litter(p)        + &
-         this%m_livestemp_to_litter(p)          + &
-         this%m_livestemp_storage_to_litter(p)  + &
-         this%m_livestemp_xfer_to_litter(p)     + &
-         this%m_deadstemp_to_litter(p)          + &
-         this%m_deadstemp_storage_to_litter(p)  + &
-         this%m_deadstemp_xfer_to_litter(p)     + &
-         this%m_livecrootp_to_litter(p)         + &
-         this%m_livecrootp_storage_to_litter(p) + &
-         this%m_livecrootp_xfer_to_litter(p)    + &
-         this%m_deadcrootp_to_litter(p)         + &
-         this%m_deadcrootp_storage_to_litter(p) + &
-         this%m_deadcrootp_xfer_to_litter(p)    + &
-         this%m_retransp_to_litter(p)           + &
-         this%m_ppool_to_litter(p)
-
-    this%fire_ploss_litter(p) = &
-         this%m_deadstemp_to_litter_fire(p)     + &
-         this%m_deadcrootp_to_litter_fire(p)    + &
-         this%m_retransp_to_litter_fire(p)      + &
-         this%m_ppool_to_litter_fire(p)         + &
-         this%m_leafp_to_litter_fire(p)         + &
-         this%m_frootp_to_litter_fire(p)        + &
-         this%m_livestemp_to_litter_fire(p)     + &
-         this%m_livecrootp_to_litter_fire(p)    + &
-         this%m_leafp_storage_to_litter_fire(p) + &
-         this%m_frootp_storage_to_litter_fire(p)       + &
-         this%m_livestemp_storage_to_litter_fire(p)    + &
-         this%m_deadstemp_storage_to_litter_fire(p)    + &
-         this%m_livecrootp_storage_to_litter_fire(p)   + &
-         this%m_deadcrootp_storage_to_litter_fire(p)   + &
-         this%m_leafp_xfer_to_litter_fire(p)           + &
-         this%m_frootp_xfer_to_litter_fire(p)          + &
-         this%m_livestemp_xfer_to_litter_fire(p)       + &
-         this%m_deadstemp_xfer_to_litter_fire(p)       + &
-         this%m_livecrootp_xfer_to_litter_fire(p)      + &
-         this%m_deadcrootp_xfer_to_litter_fire(p)
-
-    this%hrv_ploss_litter(p) = &
-         this%hrv_retransp_to_litter(p)         + &
-         this%hrv_ppool_to_litter(p)            + &
-         this%hrv_leafp_to_litter(p)            + &
-         this%hrv_leafp_storage_to_litter(p)    + &
-         this%hrv_leafp_xfer_to_litter(p)       + &
-         this%hrv_frootp_to_litter(p)           + &
-         this%hrv_frootp_storage_to_litter(p)   + &
-         this%hrv_frootp_xfer_to_litter(p)      + &
-         this%hrv_livestemp_to_litter(p)        + &
-         this%hrv_livestemp_storage_to_litter(p)+ &
-         this%hrv_livestemp_xfer_to_litter(p)   + &
-         this%hrv_deadstemp_storage_to_litter(p)+ &
-         this%hrv_deadstemp_xfer_to_litter(p)   + &
-         this%hrv_livecrootp_to_litter(p)       + &
-         this%hrv_livecrootp_storage_to_litter(p)+ &
-         this%hrv_livecrootp_xfer_to_litter(p)  + &
-         this%hrv_deadcrootp_to_litter(p)       + &
-         this%hrv_deadcrootp_storage_to_litter(p)+ &
-         this%hrv_deadcrootp_xfer_to_litter(p)
-
-    if (crop_prog) then
-       this%sen_ploss_litter(p) = &
-           this%livestemp_to_litter(p)            + &
-           this%leafp_to_litter(p)                + &
-           this%frootp_to_litter(p)
-    else
-       this%sen_ploss_litter(p) = &
-           this%leafp_to_litter(p)                + &
-           this%frootp_to_litter(p)
-    end if
-   end do 
-  ! call p2c(bounds, num_soilc, filter_soilc, &
-  !      fire_ploss_patch(bounds%begp:bounds%endp)     , &
-  !      fire_ploss_col(bounds%begc:bounds%endc) )
-  !
-  ! call p2c(bounds, num_soilc, filter_soilc, &
-  !      wood_harvestp_patch(bounds%begp:bounds%endp) , &
-  !      wood_harvestp_col(bounds%begc:bounds%endc))
-
-end subroutine veg_pf_summary_acc
-
-
-!-----------------------------------------------------------------------
-subroutine veg_cf_setvalues_acc ( this, num_soilp,filter_soilp, value_patch)
-  !
-  ! !DESCRIPTION:
-  ! Set vegetation-level carbon fluxes
-  ! !ARGUMENTS:
-  type (vegetation_carbon_flux) :: this
-  integer , intent(in) :: num_soilp 
-  integer , intent(in) :: filter_soilp(:) 
-  real(r8), intent(in) :: value_patch
-
-  integer :: fp, i
-  !$acc data copyin(value_patch)
-  if(.not.use_fates) then
-   !$acc parallel loop independent gang vector default(present) 
-   do fp = 1, num_soilp 
-      i = filter_soilp(fp) 
-      this%m_leafc_to_litter(i)                   = value_patch
-      this%m_frootc_to_litter(i)                  = value_patch
-      this%m_leafc_storage_to_litter(i)           = value_patch
-      this%m_frootc_storage_to_litter(i)          = value_patch
-      this%m_livestemc_storage_to_litter(i)       = value_patch
-      this%m_deadstemc_storage_to_litter(i)       = value_patch
-      this%m_livecrootc_storage_to_litter(i)      = value_patch
-      this%m_deadcrootc_storage_to_litter(i)      = value_patch
-      this%m_leafc_xfer_to_litter(i)              = value_patch
-      this%m_frootc_xfer_to_litter(i)             = value_patch
-      this%m_livestemc_xfer_to_litter(i)          = value_patch
-      this%m_deadstemc_xfer_to_litter(i)          = value_patch
-      this%m_livecrootc_xfer_to_litter(i)         = value_patch
-      this%m_deadcrootc_xfer_to_litter(i)         = value_patch
-      this%m_livestemc_to_litter(i)               = value_patch
-      this%m_deadstemc_to_litter(i)               = value_patch
-      this%m_livecrootc_to_litter(i)              = value_patch
-      this%m_deadcrootc_to_litter(i)              = value_patch
-      this%m_gresp_storage_to_litter(i)           = value_patch
-      this%m_gresp_xfer_to_litter(i)              = value_patch
-      this%m_cpool_to_litter(i)                   = value_patch
-      this%hrv_leafc_to_litter(i)                 = value_patch
-      this%hrv_leafc_storage_to_litter(i)         = value_patch
-      this%hrv_leafc_xfer_to_litter(i)            = value_patch
-      this%hrv_frootc_to_litter(i)                = value_patch
-      this%hrv_frootc_storage_to_litter(i)        = value_patch
-      this%hrv_frootc_xfer_to_litter(i)           = value_patch
-      this%hrv_livestemc_to_litter(i)             = value_patch
-      this%hrv_livestemc_storage_to_litter(i)     = value_patch
-      this%hrv_livestemc_xfer_to_litter(i)        = value_patch
-      this%hrv_deadstemc_to_prod10c(i)            = value_patch
-      this%hrv_deadstemc_to_prod100c(i)           = value_patch
-      this%hrv_leafc_to_prod1c(i)                 = value_patch
-      this%hrv_livestemc_to_prod1c(i)             = value_patch
-      this%hrv_grainc_to_prod1c(i)                = value_patch
-      this%hrv_cropc_to_prod1c(i)                 = value_patch
-      this%hrv_deadstemc_storage_to_litter(i)     = value_patch
-      this%hrv_deadstemc_xfer_to_litter(i)        = value_patch
-      this%hrv_livecrootc_to_litter(i)            = value_patch
-      this%hrv_livecrootc_storage_to_litter(i)    = value_patch
-      this%hrv_livecrootc_xfer_to_litter(i)       = value_patch
-      this%hrv_deadcrootc_to_litter(i)            = value_patch
-      this%hrv_deadcrootc_storage_to_litter(i)    = value_patch
-      this%hrv_deadcrootc_xfer_to_litter(i)       = value_patch
-      this%hrv_gresp_storage_to_litter(i)         = value_patch
-      this%hrv_gresp_xfer_to_litter(i)            = value_patch
-      this%hrv_xsmrpool_to_atm(i)                 = value_patch
-      this%hrv_cpool_to_litter(i)                 = value_patch
-
-      this%m_leafc_to_fire(i)                     = value_patch
-      this%m_leafc_storage_to_fire(i)             = value_patch
-      this%m_leafc_xfer_to_fire(i)                = value_patch
-      this%m_livestemc_to_fire(i)                 = value_patch
-      this%m_livestemc_storage_to_fire(i)         = value_patch
-      this%m_livestemc_xfer_to_fire(i)            = value_patch
-      this%m_deadstemc_to_fire(i)                 = value_patch
-      this%m_deadstemc_storage_to_fire(i)         = value_patch
-      this%m_deadstemc_xfer_to_fire(i)            = value_patch
-      this%m_frootc_to_fire(i)                    = value_patch
-      this%m_frootc_storage_to_fire(i)            = value_patch
-      this%m_frootc_xfer_to_fire(i)               = value_patch
-      this%m_livecrootc_to_fire(i)                = value_patch
-      this%m_livecrootc_storage_to_fire(i)        = value_patch
-      this%m_livecrootc_xfer_to_fire(i)           = value_patch
-      this%m_deadcrootc_to_fire(i)                = value_patch
-      this%m_deadcrootc_storage_to_fire(i)        = value_patch
-      this%m_deadcrootc_xfer_to_fire(i)           = value_patch
-      this%m_gresp_storage_to_fire(i)             = value_patch
-      this%m_gresp_xfer_to_fire(i)                = value_patch
-      this%m_cpool_to_fire(i)                     = value_patch
-
-      this%m_leafc_to_litter_fire(i)              = value_patch
-      this%m_leafc_storage_to_litter_fire(i)      = value_patch
-      this%m_leafc_xfer_to_litter_fire(i)         = value_patch
-      this%m_livestemc_to_litter_fire(i)          = value_patch
-      this%m_livestemc_storage_to_litter_fire(i)  = value_patch
-      this%m_livestemc_xfer_to_litter_fire(i)     = value_patch
-      this%m_livestemc_to_deadstemc_fire(i)       = value_patch
-      this%m_deadstemc_to_litter_fire(i)          = value_patch
-      this%m_deadstemc_storage_to_litter_fire(i)  = value_patch
-      this%m_deadstemc_xfer_to_litter_fire(i)     = value_patch
-      this%m_frootc_to_litter_fire(i)             = value_patch
-      this%m_frootc_storage_to_litter_fire(i)     = value_patch
-      this%m_frootc_xfer_to_litter_fire(i)        = value_patch
-      this%m_livecrootc_to_litter_fire(i)         = value_patch
-      this%m_livecrootc_storage_to_litter_fire(i) = value_patch
-      this%m_livecrootc_xfer_to_litter_fire(i)    = value_patch
-      this%m_livecrootc_to_deadcrootc_fire(i)     = value_patch
-      this%m_deadcrootc_to_litter_fire(i)         = value_patch
-      this%m_deadcrootc_storage_to_litter_fire(i) = value_patch
-      this%m_deadcrootc_xfer_to_litter_fire(i)    = value_patch
-      this%m_gresp_storage_to_litter_fire(i)      = value_patch
-      this%m_gresp_xfer_to_litter_fire(i)         = value_patch
-      this%m_cpool_to_litter_fire(i)              = value_patch
-      this%leafc_xfer_to_leafc(i)                 = value_patch
-      this%frootc_xfer_to_frootc(i)               = value_patch
-      this%livestemc_xfer_to_livestemc(i)         = value_patch
-      this%deadstemc_xfer_to_deadstemc(i)         = value_patch
-      this%livecrootc_xfer_to_livecrootc(i)       = value_patch
-      this%deadcrootc_xfer_to_deadcrootc(i)       = value_patch
-      this%leafc_to_litter(i)                     = value_patch
-      this%frootc_to_litter(i)                    = value_patch
-      this%leaf_mr(i)                             = value_patch
-      this%froot_mr(i)                            = value_patch
-      this%livestem_mr(i)                         = value_patch
-      this%livecroot_mr(i)                        = value_patch
-      this%grain_mr(i)                            = value_patch
-      this%leaf_curmr(i)                          = value_patch
-      this%froot_curmr(i)                         = value_patch
-      this%livestem_curmr(i)                      = value_patch
-      this%livecroot_curmr(i)                     = value_patch
-      this%grain_curmr(i)                         = value_patch
-      this%leaf_xsmr(i)                           = value_patch
-      this%froot_xsmr(i)                          = value_patch
-      this%livestem_xsmr(i)                       = value_patch
-      this%livecroot_xsmr(i)                      = value_patch
-      this%grain_xsmr(i)                          = value_patch
-      this%xr(i)                                  = value_patch
-      this%psnsun_to_cpool(i)                     = value_patch
-      this%psnshade_to_cpool(i)                   = value_patch
-      this%cpool_to_xsmrpool(i)                   = value_patch
-      this%cpool_to_leafc(i)                      = value_patch
-      this%cpool_to_leafc_storage(i)              = value_patch
-      this%cpool_to_frootc(i)                     = value_patch
-      this%cpool_to_frootc_storage(i)             = value_patch
-      this%cpool_to_livestemc(i)                  = value_patch
-      this%cpool_to_livestemc_storage(i)          = value_patch
-      this%cpool_to_deadstemc(i)                  = value_patch
-      this%cpool_to_deadstemc_storage(i)          = value_patch
-      this%cpool_to_livecrootc(i)                 = value_patch
-      this%cpool_to_livecrootc_storage(i)         = value_patch
-      this%cpool_to_deadcrootc(i)                 = value_patch
-      this%cpool_to_deadcrootc_storage(i)         = value_patch
-      this%cpool_to_gresp_storage(i)              = value_patch
-      this%cpool_leaf_gr(i)                       = value_patch
-      this%cpool_leaf_storage_gr(i)               = value_patch
-      this%transfer_leaf_gr(i)                    = value_patch
-      this%cpool_froot_gr(i)                      = value_patch
-      this%cpool_froot_storage_gr(i)              = value_patch
-      this%transfer_froot_gr(i)                   = value_patch
-      this%cpool_livestem_gr(i)                   = value_patch
-      this%cpool_livestem_storage_gr(i)           = value_patch
-      this%transfer_livestem_gr(i)                = value_patch
-      this%cpool_deadstem_gr(i)                   = value_patch
-      this%cpool_deadstem_storage_gr(i)           = value_patch
-      this%transfer_deadstem_gr(i)                = value_patch
-      this%cpool_livecroot_gr(i)                  = value_patch
-      this%cpool_livecroot_storage_gr(i)          = value_patch
-      this%transfer_livecroot_gr(i)               = value_patch
-      this%cpool_deadcroot_gr(i)                  = value_patch
-      this%cpool_deadcroot_storage_gr(i)          = value_patch
-      this%transfer_deadcroot_gr(i)               = value_patch
-      this%leafc_storage_to_xfer(i)               = value_patch
-      this%frootc_storage_to_xfer(i)              = value_patch
-      this%livestemc_storage_to_xfer(i)           = value_patch
-      this%deadstemc_storage_to_xfer(i)           = value_patch
-      this%livecrootc_storage_to_xfer(i)          = value_patch
-      this%deadcrootc_storage_to_xfer(i)          = value_patch
-      this%gresp_storage_to_xfer(i)               = value_patch
-      this%livestemc_to_deadstemc(i)              = value_patch
-      this%livecrootc_to_deadcrootc(i)            = value_patch
-      this%gpp(i)                                 = value_patch
-      this%gpp_before_downreg(i)                  = value_patch
-      this%mr(i)                                  = value_patch
-      this%current_gr(i)                          = value_patch
-      this%transfer_gr(i)                         = value_patch
-      this%storage_gr(i)                          = value_patch
-      this%gr(i)                                  = value_patch
-      this%ar(i)                                  = value_patch
-      this%rr(i)                                  = value_patch
-      this%npp(i)                                 = value_patch
-      this%agnpp(i)                               = value_patch
-      this%bgnpp(i)                               = value_patch
-      this%agwdnpp(i)                             = value_patch
-      this%litfall(i)                             = value_patch
-      this%vegfire(i)                             = value_patch
-      this%wood_harvestc(i)                       = value_patch
-      this%cinputs(i)                             = value_patch
-      this%coutputs(i)                            = value_patch
-      this%fire_closs(i)                          = value_patch
-      this%frootc_alloc(i)                        = value_patch
-      this%frootc_loss(i)                         = value_patch
-      this%leafc_alloc(i)                         = value_patch
-      this%leafc_loss(i)                          = value_patch
-      this%woodc_alloc(i)                         = value_patch
-      this%woodc_loss(i)                          = value_patch
-      this%xsmrpool_turnover(i)                   = value_patch
-   end do 
-  end if !(.not.use_fates)
-
-  if ( crop_prog )then
-      !$acc parallel loop independent gang vector default(present) 
-      do fp = 1, num_soilp 
-         i = filter_soilp(fp) 
-        this%xsmrpool_to_atm(i)         = value_patch
-        this%livestemc_to_litter(i)     = value_patch
-        this%grainc_to_food(i)          = value_patch
-        this%grainc_xfer_to_grainc(i)   = value_patch
-        this%cpool_to_grainc(i)         = value_patch
-        this%cpool_to_grainc_storage(i) = value_patch
-        this%cpool_grain_gr(i)          = value_patch
-        this%cpool_grain_storage_gr(i)  = value_patch
-        this%transfer_grain_gr(i)       = value_patch
-        this%grainc_storage_to_xfer(i)  = value_patch
-        this%crop_seedc_to_leaf(i)      = value_patch
-      end do 
-  end if
-
-  !$acc end data
-
-end subroutine veg_cf_setvalues_acc
-
-!-----------------------------------------------------------------------
-subroutine veg_nf_setvalues_acc( this, num_soilp,filter_soilp, value_patch)
-  !
-  ! !DESCRIPTION:
-  ! Set vegetation-level nitrogen fluxes
-  ! !ARGUMENTS:
-  type (vegetation_nitrogen_flux) :: this
-  integer , intent(in) :: num_soilp
-  integer , intent(in) :: filter_soilp(:)
-  real(r8), intent(in) :: value_patch
-  !
-  integer :: fp, i
-  !$acc data copyin(value_patch)
-  !------------------------------------------------------------------------
-  !$acc parallel loop independent gang vector default(present) 
-  do fp = 1, num_soilp 
-      i = filter_soilp(fp) 
-     this%m_leafn_to_litter(i)                   = value_patch
-     this%m_frootn_to_litter(i)                  = value_patch
-     this%m_leafn_storage_to_litter(i)           = value_patch
-     this%m_frootn_storage_to_litter(i)          = value_patch
-     this%m_livestemn_storage_to_litter(i)       = value_patch
-     this%m_deadstemn_storage_to_litter(i)       = value_patch
-     this%m_livecrootn_storage_to_litter(i)      = value_patch
-     this%m_deadcrootn_storage_to_litter(i)      = value_patch
-     this%m_leafn_xfer_to_litter(i)              = value_patch
-     this%m_frootn_xfer_to_litter(i)             = value_patch
-     this%m_livestemn_xfer_to_litter(i)          = value_patch
-     this%m_deadstemn_xfer_to_litter(i)          = value_patch
-     this%m_livecrootn_xfer_to_litter(i)         = value_patch
-     this%m_deadcrootn_xfer_to_litter(i)         = value_patch
-     this%m_livestemn_to_litter(i)               = value_patch
-     this%m_deadstemn_to_litter(i)               = value_patch
-     this%m_livecrootn_to_litter(i)              = value_patch
-     this%m_deadcrootn_to_litter(i)              = value_patch
-     this%m_retransn_to_litter(i)                = value_patch
-     this%m_npool_to_litter(i)                   = value_patch
-     this%hrv_leafn_to_litter(i)                 = value_patch
-     this%hrv_frootn_to_litter(i)                = value_patch
-     this%hrv_leafn_storage_to_litter(i)         = value_patch
-     this%hrv_frootn_storage_to_litter(i)        = value_patch
-     this%hrv_livestemn_storage_to_litter(i)     = value_patch
-     this%hrv_deadstemn_storage_to_litter(i)     = value_patch
-     this%hrv_livecrootn_storage_to_litter(i)    = value_patch
-     this%hrv_deadcrootn_storage_to_litter(i)    = value_patch
-     this%hrv_leafn_xfer_to_litter(i)            = value_patch
-     this%hrv_frootn_xfer_to_litter(i)           = value_patch
-     this%hrv_livestemn_xfer_to_litter(i)        = value_patch
-     this%hrv_deadstemn_xfer_to_litter(i)        = value_patch
-     this%hrv_livecrootn_xfer_to_litter(i)       = value_patch
-     this%hrv_deadcrootn_xfer_to_litter(i)       = value_patch
-     this%hrv_livestemn_to_litter(i)             = value_patch
-     this%hrv_deadstemn_to_prod10n(i)            = value_patch
-     this%hrv_deadstemn_to_prod100n(i)           = value_patch
-
-     this%hrv_leafn_to_prod1n(i)                 = value_patch
-     this%hrv_livestemn_to_prod1n(i)             = value_patch
-     this%hrv_grainn_to_prod1n(i)                = value_patch
-     this%hrv_cropn_to_prod1n(i)                 = value_patch
-     this%hrv_livecrootn_to_litter(i)            = value_patch
-     this%hrv_deadcrootn_to_litter(i)            = value_patch
-     this%hrv_retransn_to_litter(i)              = value_patch
-     this%hrv_npool_to_litter(i)                 = value_patch
-
-     this%m_leafn_to_fire(i)                     = value_patch
-     this%m_leafn_storage_to_fire(i)             = value_patch
-     this%m_leafn_xfer_to_fire(i)                = value_patch
-     this%m_livestemn_to_fire(i)                 = value_patch
-     this%m_livestemn_storage_to_fire(i)         = value_patch
-     this%m_livestemn_xfer_to_fire(i)            = value_patch
-     this%m_deadstemn_to_fire(i)                 = value_patch
-     this%m_deadstemn_storage_to_fire(i)         = value_patch
-     this%m_deadstemn_xfer_to_fire(i)            = value_patch
-     this%m_frootn_to_fire(i)                    = value_patch
-     this%m_frootn_storage_to_fire(i)            = value_patch
-     this%m_frootn_xfer_to_fire(i)               = value_patch
-     this%m_livecrootn_to_fire(i)                = value_patch
-     this%m_livecrootn_storage_to_fire(i)        = value_patch
-     this%m_livecrootn_xfer_to_fire(i)           = value_patch
-     this%m_deadcrootn_to_fire(i)                = value_patch
-     this%m_deadcrootn_storage_to_fire(i)        = value_patch
-     this%m_deadcrootn_xfer_to_fire(i)           = value_patch
-     this%m_retransn_to_fire(i)                  = value_patch
-     this%m_npool_to_fire(i)                     = value_patch
-
-     this%m_leafn_to_litter_fire(i)              = value_patch
-     this%m_leafn_storage_to_litter_fire(i)      = value_patch
-     this%m_leafn_xfer_to_litter_fire(i)         = value_patch
-     this%m_livestemn_to_litter_fire(i)          = value_patch
-     this%m_livestemn_storage_to_litter_fire(i)  = value_patch
-     this%m_livestemn_xfer_to_litter_fire(i)     = value_patch
-     this%m_livestemn_to_deadstemn_fire(i)       = value_patch
-     this%m_deadstemn_to_litter_fire(i)          = value_patch
-     this%m_deadstemn_storage_to_litter_fire(i)  = value_patch
-     this%m_deadstemn_xfer_to_litter_fire(i)     = value_patch
-     this%m_frootn_to_litter_fire(i)             = value_patch
-     this%m_frootn_storage_to_litter_fire(i)     = value_patch
-     this%m_frootn_xfer_to_litter_fire(i)        = value_patch
-     this%m_livecrootn_to_litter_fire(i)         = value_patch
-     this%m_livecrootn_storage_to_litter_fire(i) = value_patch
-     this%m_livecrootn_xfer_to_litter_fire(i)    = value_patch
-     this%m_livecrootn_to_deadcrootn_fire(i)     = value_patch
-     this%m_deadcrootn_to_litter_fire(i)         = value_patch
-     this%m_deadcrootn_storage_to_litter_fire(i) = value_patch
-     this%m_deadcrootn_xfer_to_litter_fire(i)    = value_patch
-     this%m_retransn_to_litter_fire(i)           = value_patch
-     this%m_npool_to_litter_fire(i)              = value_patch
-
-     this%leafn_xfer_to_leafn(i)                 = value_patch
-     this%frootn_xfer_to_frootn(i)               = value_patch
-     this%livestemn_xfer_to_livestemn(i)         = value_patch
-     this%deadstemn_xfer_to_deadstemn(i)         = value_patch
-     this%livecrootn_xfer_to_livecrootn(i)       = value_patch
-     this%deadcrootn_xfer_to_deadcrootn(i)       = value_patch
-     this%leafn_to_litter(i)                     = value_patch
-     this%leafn_to_retransn(i)                   = value_patch
-     this%frootn_to_litter(i)                    = value_patch
-     this%retransn_to_npool(i)                   = value_patch
-     this%sminn_to_npool(i)                      = value_patch
-     this%npool_to_leafn(i)                      = value_patch
-     this%npool_to_leafn_storage(i)              = value_patch
-     this%npool_to_frootn(i)                     = value_patch
-     this%npool_to_frootn_storage(i)             = value_patch
-     this%npool_to_livestemn(i)                  = value_patch
-     this%npool_to_livestemn_storage(i)          = value_patch
-     this%npool_to_deadstemn(i)                  = value_patch
-     this%npool_to_deadstemn_storage(i)          = value_patch
-     this%npool_to_livecrootn(i)                 = value_patch
-     this%npool_to_livecrootn_storage(i)         = value_patch
-     this%npool_to_deadcrootn(i)                 = value_patch
-     this%npool_to_deadcrootn_storage(i)         = value_patch
-     this%leafn_storage_to_xfer(i)               = value_patch
-     this%frootn_storage_to_xfer(i)              = value_patch
-     this%livestemn_storage_to_xfer(i)           = value_patch
-     this%deadstemn_storage_to_xfer(i)           = value_patch
-     this%livecrootn_storage_to_xfer(i)          = value_patch
-     this%deadcrootn_storage_to_xfer(i)          = value_patch
-     this%livestemn_to_deadstemn(i)              = value_patch
-     this%livestemn_to_retransn(i)               = value_patch
-     this%livecrootn_to_deadcrootn(i)            = value_patch
-     this%livecrootn_to_retransn(i)              = value_patch
-     this%ndeploy(i)                             = value_patch
-     this%wood_harvestn(i)                       = value_patch
-     this%fire_nloss(i)                          = value_patch
-     this%nfix_to_plantn(i)                      = value_patch
-     this%gap_nloss_litter(i)                    = value_patch
-     this%fire_nloss_litter(i)                   = value_patch
-     this%hrv_nloss_litter(i)                    = value_patch
-     this%sen_nloss_litter(i)                    = value_patch
-     this%crop_seedn_to_leaf(i)                  = value_patch
-     this%livestemn_to_litter(i)                 = value_patch
-
-      if ( crop_prog )then
-        this%grainn_to_food(i)                   = value_patch
-        this%grainn_xfer_to_grainn(i)            = value_patch
-        this%npool_to_grainn(i)                  = value_patch
-        this%npool_to_grainn_storage(i)          = value_patch
-        this%grainn_storage_to_xfer(i)           = value_patch
-        this%soyfixn(i)                          = value_patch
-        this%frootn_to_retransn(i)               = value_patch
-      end if
-   end do 
-   !$acc end data 
-
-end subroutine veg_nf_setvalues_acc
-
-!-----------------------------------------------------------------------
-subroutine veg_pf_setvalues_acc ( this, num_soilp, filter_soilp, value_patch)
-  !
-  ! !DESCRIPTION:
-  ! Set phosphorus flux variables
-  ! !ARGUMENTS:
-  type (vegetation_phosphorus_flux) :: this
-  integer, intent(in) :: num_soilp 
-  integer, intent(in) :: filter_soilp(:)  
-  real(r8), intent(in) :: value_patch
-
-  integer :: fp, i
-  !$acc data copyin(value_patch)
-
-  !------------------------------------------------------------------------
-  !$acc parallel loop independent gang vector default(present) 
-  do fp = 1, num_soilp 
-      i = filter_soilp(fp) 
-     this%m_leafp_to_litter(i)                   = value_patch
-     this%m_frootp_to_litter(i)                  = value_patch
-     this%m_leafp_storage_to_litter(i)           = value_patch
-     this%m_frootp_storage_to_litter(i)          = value_patch
-     this%m_livestemp_storage_to_litter(i)       = value_patch
-     this%m_deadstemp_storage_to_litter(i)       = value_patch
-     this%m_livecrootp_storage_to_litter(i)      = value_patch
-     this%m_deadcrootp_storage_to_litter(i)      = value_patch
-     this%m_leafp_xfer_to_litter(i)              = value_patch
-     this%m_frootp_xfer_to_litter(i)             = value_patch
-     this%m_livestemp_xfer_to_litter(i)          = value_patch
-     this%m_deadstemp_xfer_to_litter(i)          = value_patch
-     this%m_livecrootp_xfer_to_litter(i)         = value_patch
-     this%m_deadcrootp_xfer_to_litter(i)         = value_patch
-     this%m_livestemp_to_litter(i)               = value_patch
-     this%m_deadstemp_to_litter(i)               = value_patch
-     this%m_livecrootp_to_litter(i)              = value_patch
-     this%m_deadcrootp_to_litter(i)              = value_patch
-     this%m_retransp_to_litter(i)                = value_patch
-     this%m_ppool_to_litter(i)                   = value_patch
-     this%hrv_leafp_to_litter(i)                 = value_patch
-     this%hrv_frootp_to_litter(i)                = value_patch
-     this%hrv_leafp_storage_to_litter(i)         = value_patch
-     this%hrv_frootp_storage_to_litter(i)        = value_patch
-     this%hrv_livestemp_storage_to_litter(i)     = value_patch
-     this%hrv_deadstemp_storage_to_litter(i)     = value_patch
-     this%hrv_livecrootp_storage_to_litter(i)    = value_patch
-     this%hrv_deadcrootp_storage_to_litter(i)    = value_patch
-     this%hrv_leafp_xfer_to_litter(i)            = value_patch
-     this%hrv_frootp_xfer_to_litter(i)           = value_patch
-     this%hrv_livestemp_xfer_to_litter(i)        = value_patch
-     this%hrv_deadstemp_xfer_to_litter(i)        = value_patch
-     this%hrv_livecrootp_xfer_to_litter(i)       = value_patch
-     this%hrv_deadcrootp_xfer_to_litter(i)       = value_patch
-     this%hrv_livestemp_to_litter(i)             = value_patch
-     this%hrv_deadstemp_to_prod10p(i)            = value_patch
-     this%hrv_deadstemp_to_prod100p(i)           = value_patch
-     this%hrv_leafp_to_prod1p(i)                 = value_patch
-     this%hrv_livestemp_to_prod1p(i)             = value_patch
-     this%hrv_grainp_to_prod1p(i)                = value_patch
-     this%hrv_cropp_to_prod1p(i)                 = value_patch
-     this%hrv_livecrootp_to_litter(i)            = value_patch
-     this%hrv_deadcrootp_to_litter(i)            = value_patch
-     this%hrv_retransp_to_litter(i)              = value_patch
-     this%hrv_ppool_to_litter(i)                 = value_patch
-
-     this%m_leafp_to_fire(i)                     = value_patch
-     this%m_leafp_storage_to_fire(i)             = value_patch
-     this%m_leafp_xfer_to_fire(i)                = value_patch
-     this%m_livestemp_to_fire(i)                 = value_patch
-     this%m_livestemp_storage_to_fire(i)         = value_patch
-     this%m_livestemp_xfer_to_fire(i)            = value_patch
-     this%m_deadstemp_to_fire(i)                 = value_patch
-     this%m_deadstemp_storage_to_fire(i)         = value_patch
-     this%m_deadstemp_xfer_to_fire(i)            = value_patch
-     this%m_frootp_to_fire(i)                    = value_patch
-     this%m_frootp_storage_to_fire(i)            = value_patch
-     this%m_frootp_xfer_to_fire(i)               = value_patch
-     this%m_livecrootp_to_fire(i)                = value_patch
-     this%m_livecrootp_storage_to_fire(i)        = value_patch
-     this%m_livecrootp_xfer_to_fire(i)           = value_patch
-     this%m_deadcrootp_to_fire(i)                = value_patch
-     this%m_deadcrootp_storage_to_fire(i)        = value_patch
-     this%m_deadcrootp_xfer_to_fire(i)           = value_patch
-     this%m_retransp_to_fire(i)                  = value_patch
-     this%m_ppool_to_fire(i)                     = value_patch
-
-     this%m_leafp_to_litter_fire(i)              = value_patch
-     this%m_leafp_storage_to_litter_fire(i)      = value_patch
-     this%m_leafp_xfer_to_litter_fire(i)         = value_patch
-     this%m_livestemp_to_litter_fire(i)          = value_patch
-     this%m_livestemp_storage_to_litter_fire(i)  = value_patch
-     this%m_livestemp_xfer_to_litter_fire(i)     = value_patch
-     this%m_livestemp_to_deadstemp_fire(i)       = value_patch
-     this%m_deadstemp_to_litter_fire(i)          = value_patch
-     this%m_deadstemp_storage_to_litter_fire(i)  = value_patch
-     this%m_deadstemp_xfer_to_litter_fire(i)     = value_patch
-     this%m_frootp_to_litter_fire(i)             = value_patch
-     this%m_frootp_storage_to_litter_fire(i)     = value_patch
-     this%m_frootp_xfer_to_litter_fire(i)        = value_patch
-     this%m_livecrootp_to_litter_fire(i)         = value_patch
-     this%m_livecrootp_storage_to_litter_fire(i) = value_patch
-     this%m_livecrootp_xfer_to_litter_fire(i)    = value_patch
-     this%m_livecrootp_to_deadcrootp_fire(i)     = value_patch
-     this%m_deadcrootp_to_litter_fire(i)         = value_patch
-     this%m_deadcrootp_storage_to_litter_fire(i) = value_patch
-     this%m_deadcrootp_xfer_to_litter_fire(i)    = value_patch
-     this%m_retransp_to_litter_fire(i)           = value_patch
-     this%m_ppool_to_litter_fire(i)              = value_patch
-
-     this%leafp_xfer_to_leafp(i)                 = value_patch
-     this%frootp_xfer_to_frootp(i)               = value_patch
-     this%livestemp_xfer_to_livestemp(i)         = value_patch
-     this%deadstemp_xfer_to_deadstemp(i)         = value_patch
-     this%livecrootp_xfer_to_livecrootp(i)       = value_patch
-     this%deadcrootp_xfer_to_deadcrootp(i)       = value_patch
-     this%leafp_to_litter(i)                     = value_patch
-     this%leafp_to_retransp(i)                   = value_patch
-     this%frootp_to_litter(i)                    = value_patch
-     this%retransp_to_ppool(i)                   = value_patch
-     this%sminp_to_ppool(i)                      = value_patch
-     this%ppool_to_leafp(i)                      = value_patch
-     this%ppool_to_leafp_storage(i)              = value_patch
-     this%ppool_to_frootp(i)                     = value_patch
-     this%ppool_to_frootp_storage(i)             = value_patch
-     this%ppool_to_livestemp(i)                  = value_patch
-     this%ppool_to_livestemp_storage(i)          = value_patch
-     this%ppool_to_deadstemp(i)                  = value_patch
-     this%ppool_to_deadstemp_storage(i)          = value_patch
-     this%ppool_to_livecrootp(i)                 = value_patch
-     this%ppool_to_livecrootp_storage(i)         = value_patch
-     this%ppool_to_deadcrootp(i)                 = value_patch
-     this%ppool_to_deadcrootp_storage(i)         = value_patch
-     this%leafp_storage_to_xfer(i)               = value_patch
-     this%frootp_storage_to_xfer(i)              = value_patch
-     this%livestemp_storage_to_xfer(i)           = value_patch
-     this%deadstemp_storage_to_xfer(i)           = value_patch
-     this%livecrootp_storage_to_xfer(i)          = value_patch
-     this%deadcrootp_storage_to_xfer(i)          = value_patch
-     this%livestemp_to_deadstemp(i)              = value_patch
-     this%livestemp_to_retransp(i)               = value_patch
-     this%livecrootp_to_deadcrootp(i)            = value_patch
-     this%livecrootp_to_retransp(i)              = value_patch
-     this%pdeploy(i)                             = value_patch
-     this%wood_harvestp(i)                       = value_patch
-     this%fire_ploss(i)                          = value_patch
-     this%biochem_pmin_to_plant(i)               = value_patch
-     this%gap_ploss_litter(i)                    = value_patch
-     this%fire_ploss_litter(i)                   = value_patch
-     this%hrv_ploss_litter(i)                    = value_patch
-     this%sen_ploss_litter(i)                    = value_patch
-     this%livestemp_to_litter(i)                 = value_patch
-
-      if ( crop_prog )then
-         this%grainp_to_food(i)                   = value_patch
-         this%grainp_xfer_to_grainp(i)            = value_patch
-         this%ppool_to_grainp(i)                  = value_patch
-         this%ppool_to_grainp_storage(i)          = value_patch
-         this%grainp_storage_to_xfer(i)           = value_patch
-         this%frootp_to_retransp(i)               = value_patch
-         this%crop_seedp_to_leaf(i)               = value_patch
-      end if
-end do 
-!$acc end data
-end subroutine veg_pf_setvalues_acc
-
-end module VegetationSummaryRoutinesMod
diff --git a/components/elm/src/main/atm2lndMod.F90 b/components/elm/src/main/atm2lndMod.F90
index a3231b6f19..27d18c89e8 100644
--- a/components/elm/src/main/atm2lndMod.F90
+++ b/components/elm/src/main/atm2lndMod.F90
@@ -45,13 +45,13 @@ contains
     !
     ! Downscaling is done over columns defined by filter_do_smb_c. But we also do direct copies
     ! of gridcell-level forcings into column-level forcings over all other active columns.
-    !$acc routine seq 
+    !
     ! !USES:
     use elm_varcon      , only : rair, cpair, grav, lapse_glcmec
     use elm_varcon      , only : glcmec_rain_snow_threshold
     use landunit_varcon , only : istice_mec 
     use elm_varctl      , only : glcmec_downscale_rain_snow_convert
-    !use domainMod       , only : ldomain
+    use domainMod       , only : ldomain
     use QsatMod         , only : Qsat
     !
     ! !ARGUMENTS:
@@ -71,7 +71,7 @@ contains
     real(r8) :: egcm_c, rhos_c
     real(r8) :: dum1,   dum2
 
-    !character(len=*), parameter :: subname = 'downscale_forcings'
+    character(len=*), parameter :: subname = 'downscale_forcings'
     !-----------------------------------------------------------------------
 
     associate(&
@@ -120,7 +120,7 @@ contains
          ! This is a simple downscaling procedure 
          ! Note that forc_hgt, forc_u, and forc_v are not downscaled.
 
-         hsurf_g = 0 !ldomain%topo(g)                       ! gridcell sfc elevation
+         hsurf_g = ldomain%topo(g)                       ! gridcell sfc elevation
          hsurf_c = col_pp%glc_topo(c)                       ! column sfc elevation
          tbot_g  = forc_t_g(g)                           ! atm sfc temp
          thbot_g = forc_th_g(g)                          ! atm sfc pot temp
@@ -182,7 +182,7 @@ contains
 
       call downscale_longwave(bounds, num_do_smb_c, filter_do_smb_c, atm2lnd_vars)
 
-      !call check_downscale_consistency(bounds, atm2lnd_vars)
+      call check_downscale_consistency(bounds, atm2lnd_vars)
 
     end associate
 
@@ -194,9 +194,9 @@ contains
     ! !DESCRIPTION:
     ! Downscale longwave radiation from gridcell to column
     ! Must be done AFTER temperature downscaling
-    !$acc routine seq 
+    !
     ! !USES:
-    !use domainMod       , only : ldomain
+    use domainMod       , only : ldomain
     use landunit_varcon , only : istice_mec 
     use elm_varcon      , only : lapse_glcmec
     use elm_varctl      , only : glcmec_downscale_longwave
@@ -254,7 +254,7 @@ contains
             l = col_pp%landunit(c)
             g = col_pp%gridcell(c)
 
-            hsurf_g = 0 !ldomain%topo(g)
+            hsurf_g = ldomain%topo(g)
             hsurf_c = col_pp%glc_topo(c)
 
             ! Here we assume that deltaLW = (dLW/dT)*(dT/dz)*deltaz
@@ -295,7 +295,7 @@ contains
 
 
          ! Make sure that, after normalization, the grid cell mean is conserved
-#ifndef _OPENACC 
+
          do g = bounds%begg, bounds%endg
             if (sum_wts_g(g) > 0._r8) then
                if (abs((newsum_lwrad_g(g) / sum_wts_g(g)) - forc_lwrad_g(g)) > 1.e-8_r8) then
@@ -306,7 +306,7 @@ contains
                end if
             end if
          end do
-#endif 
+
       end if    ! glcmec_downscale_longwave
 
     end associate
@@ -344,13 +344,18 @@ contains
     !              forc_lwrad_c(c) = forc_lwrad_c(c) * lwrad_norm_g(g)
     !   where lwrad_norm_g is the array of norms computed by this routine
 
-    !$acc routine seq 
+    !
     ! !ARGUMENTS:
     real(r8), intent(in)  :: orig_field(:)  ! the original field, at the grid cell level
     real(r8), intent(in)  :: sum_field(:)   ! the new weighted sum across columns (dimensioned by grid cell)
     real(r8), intent(in)  :: sum_wts(:)     ! sum of the weights used to create sum_field (dimensioned by grid cell)
     real(r8), intent(out) :: norms(:)       ! computed normalization factors
     !-----------------------------------------------------------------------
+
+    SHR_ASSERT((size(orig_field) == size(norms)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT((size(sum_field) == size(norms)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT((size(sum_wts) == size(norms)), errMsg(__FILE__, __LINE__))
+
     where (sum_wts == 0._r8)
        ! Avoid divide by zero; if sum_wts is 0, then the normalization doesn't matter,
        ! because the adjusted values won't affect the grid cell mean.
diff --git a/components/elm/src/main/atm2lndType.F90 b/components/elm/src/main/atm2lndType.F90
index 2e0a5a69d7..886f4724fd 100644
--- a/components/elm/src/main/atm2lndType.F90
+++ b/components/elm/src/main/atm2lndType.F90
@@ -35,17 +35,13 @@ module atm2lndType
   ! code. Instead use the datatype variables that have a _col suffix
   ! which gives the downscaled versions of these fields.
   !----------------------------------------------------
-
-  type,public :: cplbypass_atminput_type
+  type, public :: atm2lnd_type
       !DMR additions for CPL_BYPASS option
+#ifdef CPL_BYPASS
       integer*2, pointer :: atm_input                (:,:,:,:) => null()  !Single-site meteorological input
-  end type
-
-  type, public :: atm2lnd_type
-      !!#ifdef CPL_BYPASS
       integer, pointer  :: loaded_bypassdata                   => null()
       real(r8), pointer :: add_offsets                     (:) => null()  !offsets for compressed met drivers
-      real(r8), pointer :: scale_factors                   (:) => null()  !scale factors for compressed met drivers
+      real(r8), pointer :: scale_factors                   (:) => null()  !scale factors for compressed met drivers      
       integer(r8), pointer :: startyear_met                    => null()  !staring driver met year
       integer(r8), pointer :: endyear_met_spinup               => null()  !end driver met year for spinup cycle
       integer(r8), pointer :: endyear_met_trans                => null()  !end driver met year for transient simulation
@@ -61,16 +57,16 @@ module atm2lndType
       real(r8), pointer :: c13o2_input                 (:,:,:) => null()  !annual C13O2 input data
       integer, pointer :: ndepind                        (:,:) => null()  !annual nitrogen deposition data
       integer, pointer :: hdmind                         (:,:) => null()  !popluation density
-      real(r8), pointer ::  hdm1                       (:,:,:) => null()
+      real(r8), pointer :: forc_hdm                      (:)   => null() 
+      real(r8), pointer :: forc_lnfm                     (:)   => null()
+      real(r8), pointer ::  hdm1                       (:,:,:) => null() 
       real(r8), pointer ::  hdm2                       (:,:,:) => null()
       real(r8), pointer ::  lnfm_all                   (:,:,:) => null()
       real(r8), pointer ::  lnfm                         (:,:) => null()
       real(r8), pointer ::  ndep1                      (:,:,:) => null()
       real(r8), pointer ::  ndep2                      (:,:,:) => null()
       real(r8), pointer ::  aerodata                 (:,:,:,:) => null()
-      real(r8), pointer :: forc_hdm                      (:)   => null()
-      real(r8), pointer :: forc_lnfm                     (:)   => null()
-      !!#endif
+#endif
      ! atm->lnd not downscaled
      real(r8), pointer :: forc_u_grc                    (:)   => null() ! atm wind speed, east direction (m/s)
      real(r8), pointer :: forc_v_grc                    (:)   => null() ! atm wind speed, north direction (m/s)
@@ -92,14 +88,14 @@ module atm2lndType
      real(r8), pointer :: forc_aer_grc                  (:,:) => null() ! aerosol deposition array
      real(r8), pointer :: forc_pch4_grc                 (:)   => null() ! CH4 partial pressure (Pa)
 
-     real(r8), pointer :: forc_t_not_downscaled_grc     (:)   => null() ! not downscaled atm temperature (Kelvin)
-     real(r8), pointer :: forc_th_not_downscaled_grc    (:)   => null() ! not downscaled atm potential temperature (Kelvin)
-     real(r8), pointer :: forc_q_not_downscaled_grc     (:)   => null() ! not downscaled atm specific humidity (kg/kg)
-     real(r8), pointer :: forc_pbot_not_downscaled_grc  (:)   => null() ! not downscaled atm pressure (Pa)
-     real(r8), pointer :: forc_rho_not_downscaled_grc   (:)   => null() ! not downscaled atm density (kg/m**3)
-     real(r8), pointer :: forc_rain_not_downscaled_grc  (:)   => null() ! not downscaled atm rain rate [mm/s]
-     real(r8), pointer :: forc_snow_not_downscaled_grc  (:)   => null() ! not downscaled atm snow rate [mm/s]
-     real(r8), pointer :: forc_lwrad_not_downscaled_grc (:)   => null() ! not downscaled atm downwrd IR longwave radiation (W/m**2)
+     real(r8), pointer :: forc_t_not_downscaled_grc     (:)   => null() ! not downscaled atm temperature (Kelvin)       
+     real(r8), pointer :: forc_th_not_downscaled_grc    (:)   => null() ! not downscaled atm potential temperature (Kelvin)    
+     real(r8), pointer :: forc_q_not_downscaled_grc     (:)   => null() ! not downscaled atm specific humidity (kg/kg)  
+     real(r8), pointer :: forc_pbot_not_downscaled_grc  (:)   => null() ! not downscaled atm pressure (Pa)              
+     real(r8), pointer :: forc_rho_not_downscaled_grc   (:)   => null() ! not downscaled atm density (kg/m**3)                      
+     real(r8), pointer :: forc_rain_not_downscaled_grc  (:)   => null() ! not downscaled atm rain rate [mm/s]                       
+     real(r8), pointer :: forc_snow_not_downscaled_grc  (:)   => null() ! not downscaled atm snow rate [mm/s]                       
+     real(r8), pointer :: forc_lwrad_not_downscaled_grc (:)   => null() ! not downscaled atm downwrd IR longwave radiation (W/m**2) 
 
      ! atm->lnd downscaled
      real(r8), pointer :: forc_t_downscaled_col         (:)   => null() ! downscaled atm temperature (Kelvin)
@@ -117,27 +113,27 @@ module atm2lndType
      real(r8), pointer :: volrmch_grc                   (:)   => null() ! rof volr main channel (m3)
      real(r8), pointer :: supply_grc                    (:)   => null() ! rof volr supply (mm/s)
      real(r8), pointer :: deficit_grc                   (:)   => null() ! rof volr deficit (mm/s)
-
+	 
      ! anomaly forcing
-     real(r8), pointer :: af_precip_grc                 (:)   => null() ! anomaly forcing
-     real(r8), pointer :: af_uwind_grc                  (:)   => null() ! anomaly forcing
-     real(r8), pointer :: af_vwind_grc                  (:)   => null() ! anomaly forcing
-     real(r8), pointer :: af_tbot_grc                   (:)   => null() ! anomaly forcing
-     real(r8), pointer :: af_pbot_grc                   (:)   => null() ! anomaly forcing
-     real(r8), pointer :: af_shum_grc                   (:)   => null() ! anomaly forcing
-     real(r8), pointer :: af_swdn_grc                   (:)   => null() ! anomaly forcing
-     real(r8), pointer :: af_lwdn_grc                   (:)   => null() ! anomaly forcing
+     real(r8), pointer :: af_precip_grc                 (:)   => null() ! anomaly forcing 
+     real(r8), pointer :: af_uwind_grc                  (:)   => null() ! anomaly forcing 
+     real(r8), pointer :: af_vwind_grc                  (:)   => null() ! anomaly forcing 
+     real(r8), pointer :: af_tbot_grc                   (:)   => null() ! anomaly forcing 
+     real(r8), pointer :: af_pbot_grc                   (:)   => null() ! anomaly forcing 
+     real(r8), pointer :: af_shum_grc                   (:)   => null() ! anomaly forcing 
+     real(r8), pointer :: af_swdn_grc                   (:)   => null() ! anomaly forcing 
+     real(r8), pointer :: af_lwdn_grc                   (:)   => null() ! anomaly forcing 
      real(r8), pointer :: bc_precip_grc                 (:)   => null() ! anomaly forcing - add bias correction
 
      ! time averaged quantities
-     real(r8) , pointer :: fsd24_patch                  (:)   => null() ! patch 24hr average of direct beam radiation
-     real(r8) , pointer :: fsd240_patch                 (:)   => null() ! patch 240hr average of direct beam radiation
-     real(r8) , pointer :: fsi24_patch                  (:)   => null() ! patch 24hr average of diffuse beam radiation
-     real(r8) , pointer :: fsi240_patch                 (:)   => null() ! patch 240hr average of diffuse beam radiation
+     real(r8) , pointer :: fsd24_patch                  (:)   => null() ! patch 24hr average of direct beam radiation 
+     real(r8) , pointer :: fsd240_patch                 (:)   => null() ! patch 240hr average of direct beam radiation 
+     real(r8) , pointer :: fsi24_patch                  (:)   => null() ! patch 24hr average of diffuse beam radiation 
+     real(r8) , pointer :: fsi240_patch                 (:)   => null() ! patch 240hr average of diffuse beam radiation 
      real(r8) , pointer :: prec365_patch                (:)   => null() ! patch 365-day running mean of tot. precipitation
-     real(r8) , pointer :: prec60_patch                 (:)   => null() ! patch 60-day running mean of tot. precipitation (mm/s)
-     real(r8) , pointer :: prec10_patch                 (:)   => null() ! patch 10-day running mean of tot. precipitation (mm/s)
-     real(r8) , pointer :: prec24_patch                 (:)   => null() ! patch 24-hour running mean of tot. precipitation (mm/s)
+     real(r8) , pointer :: prec60_patch                 (:)   => null() ! patch 60-day running mean of tot. precipitation (mm/s) 
+     real(r8) , pointer :: prec10_patch                 (:)   => null() ! patch 10-day running mean of tot. precipitation (mm/s) 
+     real(r8) , pointer :: prec24_patch                 (:)   => null() ! patch 24-hour running mean of tot. precipitation (mm/s) 
      real(r8) , pointer :: rh24_patch                   (:)   => null() ! patch 24-hour running mean of relative humidity
      real(r8) , pointer :: wind24_patch                 (:)   => null() ! patch 24-hour running mean of wind
      real(r8) , pointer :: t_mo_patch                   (:)   => null() ! patch 30-day average temperature (Kelvin)
@@ -146,8 +142,8 @@ module atm2lndType
    contains
 
      procedure, public  :: Init
-     procedure, private :: InitAllocate
-     procedure, private :: InitHistory
+     procedure, private :: InitAllocate 
+     procedure, private :: InitHistory  
      procedure, public  :: InitAccBuffer
      procedure, public  :: InitAccVars
      procedure, public  :: UpdateAccVars
@@ -162,22 +158,13 @@ contains
   subroutine Init(this, bounds)
 
     class(atm2lnd_type) :: this
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds  
 
     call this%InitAllocate(bounds)
     call this%InitHistory(bounds)
-
+    
   end subroutine Init
 
-  subroutine cplBypassInitAllocate(this, bounds)
-    implicit none
-
-    class(cplbypass_atminput_type) :: this
-    type(bounds_type), intent(in) :: bounds
-
-
-
-  end subroutine cplBypassInitAllocate
   !------------------------------------------------------------------------
   subroutine InitAllocate(this, bounds)
     !
@@ -186,7 +173,7 @@ contains
     !
     ! !ARGUMENTS:
     class(atm2lnd_type) :: this
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds  
     !
     ! !LOCAL VARIABLES:
     real(r8) :: ival  = 0.0_r8  ! initial value
@@ -204,16 +191,16 @@ contains
 
     ! atm->lnd
 
-    !DMR - variables added for CPL_BYPASS option
+    !DMR - variables added for CPL_BYPASS option 
 #ifdef CPL_BYPASS
     allocate(this%timelen                            (1:14))        ; this%timelen                       (:)   = ival_int
     allocate(this%timelen_spinup                     (1:14))        ; this%timelen_spinup                (:)   = ival_int
     allocate(this%tindex               (begg:endg,1:14,1:2))        ; this%tindex                    (:,:,:)   = ival_int
-    allocate(this%metsource                                )        ; this%metsource                           = ival_int
+    allocate(this%metsource                                )        ; this%metsource                           = ival_int   
     allocate(this%npf                                (1:14))        ; this%npf                           (:)   = ival
     !allocate(this%atm_input       (14,begg:endg,1,1:600000))        ; this%atm_input               (:,:,:,:)   = ival_short
     allocate(this%loaded_bypassdata                        )        ; this%loaded_bypassdata                   = 0
-    allocate(this%add_offsets                        (1:14))        ; this%add_offsets                   (:)   = ival_float
+    allocate(this%add_offsets                        (1:14))        ; this%add_offsets                   (:)   = ival_float 
     allocate(this%scale_factors                      (1:14))        ; this%scale_factors                 (:)   = ival_float
     allocate(this%startyear_met                            )        ; this%startyear_met                       = ival_int
     allocate(this%endyear_met_spinup                       )        ; this%endyear_met_spinup                  = ival_int
@@ -221,7 +208,7 @@ contains
     allocate(this%timeres                            (1:14))        ; this%timeres                       (:)   = ival
     allocate(this%var_offset              (14,begg:endg,12))        ; this%var_offset                (:,:,:)   = ival
     allocate(this%var_mult                (14,begg:endg,12))        ; this%var_mult                  (:,:,:)   = ival
-    allocate(this%co2_input                      (1,1,3000))        ; this%co2_input                 (:,:,:)   = ival
+    allocate(this%co2_input                      (1,1,3000))        ; this%co2_input                 (:,:,:)   = ival    
     allocate(this%c13o2_input                    (1,1,3000))        ; this%c13o2_input               (:,:,:)   = ival
     allocate(this%ndepind                     (begg:endg,2))        ; this%ndepind                     (:,:)   = ival_int
     allocate(this%hdmind                      (begg:endg,2))        ; this%hdmind                      (:,:)   = ival_int
@@ -229,7 +216,7 @@ contains
     allocate(this%forc_lnfm                     (begg:endg))        ; this%forc_lnfm                     (:)   = ival
     allocate(this%hdm1                          (720,360,1))        ; this%hdm1                      (:,:,:)   = ival
     allocate(this%hdm2                          (720,360,1))        ; this%hdm2                      (:,:,:)   = ival
-    allocate(this%lnfm                     (begg:endg,2920))        ; this%lnfm                        (:,:)   = ival
+    allocate(this%lnfm                     (begg:endg,2920))        ; this%lnfm                        (:,:)   = ival 
     allocate(this%ndep1                          (144,96,1))        ; this%ndep1                     (:,:,:)   = ival
     allocate(this%ndep2                          (144,96,1))        ; this%ndep2                     (:,:,:)   = ival
     allocate(this%aerodata                   (14,144,96,14))        ; this%aerodata                (:,:,:,:)   = ival
@@ -264,7 +251,7 @@ contains
     allocate(this%forc_lwrad_not_downscaled_grc (begg:endg))        ; this%forc_lwrad_not_downscaled_grc (:)   = ival
     allocate(this%forc_rain_not_downscaled_grc  (begg:endg))        ; this%forc_rain_not_downscaled_grc  (:)   = ival
     allocate(this%forc_snow_not_downscaled_grc  (begg:endg))        ; this%forc_snow_not_downscaled_grc  (:)   = ival
-
+    
     ! atm->lnd downscaled
     allocate(this%forc_t_downscaled_col         (begc:endc))        ; this%forc_t_downscaled_col         (:)   = ival
     allocate(this%forc_q_downscaled_col         (begc:endc))        ; this%forc_q_downscaled_col         (:)   = ival
@@ -318,7 +305,7 @@ contains
     !
     ! !ARGUMENTS:
     class(atm2lnd_type) :: this
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds  
     !
     ! !LOCAL VARIABLES:
     integer  :: begg, endg
@@ -342,12 +329,12 @@ contains
     call hist_addfld1d (fname='VOLRMCH',  units='m3',  &
          avgflag='A', long_name='river channel main channel water storage', &
          ptr_lnd=this%volrmch_grc)
-
+		 
     this%supply_grc(begg:endg) = spval
     call hist_addfld1d (fname='SUPPLY',  units='mm/s',  &
          avgflag='A', long_name='runoff supply for land use', &
          ptr_lnd=this%supply_grc)
-
+         
     this%deficit_grc(begg:endg) = spval
     call hist_addfld1d (fname='DEFICIT',  units='mm/s',  &
          avgflag='A', long_name='runoff supply deficit', &
@@ -458,7 +445,7 @@ contains
    call hist_addfld1d (fname='HDM', units='counts/km^2',      &
          avgflag='A', long_name='human population density',   &
          ptr_lnd=this%forc_hdm, default='inactive')
-
+   
     call hist_addfld1d (fname='LNFM', units='counts/km^2/hr',  &
          avgflag='A', long_name='Lightning frequency',        &
          ptr_lnd=this%forc_lnfm, default='inactive')
@@ -495,13 +482,13 @@ contains
     ! This routine set defaults values that are then overwritten by the
     ! restart file for restart or branch runs
     !
-    ! !USES
+    ! !USES 
     use elm_varcon  , only : spval
     use accumulMod  , only : init_accum_field
     !
     ! !ARGUMENTS:
     class(atm2lnd_type) :: this
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds  
     !---------------------------------------------------------------------
 
     this%fsd24_patch(bounds%begp:bounds%endp) = spval
@@ -539,10 +526,10 @@ contains
             desc='24hr sum of precipitation', accum_type='runmean', accum_period=-1, &
             subgrid_type='pft', numlev=1, init_value=0._r8)
 
-       ! Fudge - this neds to be initialized from the restat file eventually.
+       ! Fudge - this neds to be initialized from the restat file eventually. 
        call init_accum_field (name='RH24', units='m', &
             desc='24hr average of RH', accum_type='runmean', accum_period=-1, &
-            subgrid_type='pft', numlev=1, init_value=100._r8)
+            subgrid_type='pft', numlev=1, init_value=100._r8) 
 
        call init_accum_field (name='WIND24', units='m', &
             desc='24hr average of wind', accum_type='runmean', accum_period=-1, &
@@ -557,16 +544,16 @@ contains
     ! !DESCRIPTION:
     ! Initialize module variables that are associated with
     ! time accumulated fields. This routine is called for both an initial run
-    ! and a restart run (and must therefore must be called after the restart file
+    ! and a restart run (and must therefore must be called after the restart file 
     ! is read in and the accumulation buffer is obtained)
     !
-    ! !USES
+    ! !USES 
     use accumulMod       , only : extract_accum_field
     use clm_time_manager , only : get_nstep
     !
     ! !ARGUMENTS:
     class(atm2lnd_type) :: this
-    type(bounds_type), intent(in) :: bounds
+    type(bounds_type), intent(in) :: bounds  
     !
     ! !LOCAL VARIABLES:
     integer  :: begp, endp
@@ -632,7 +619,7 @@ contains
     !
     ! !ARGUMENTS:
     class(atm2lnd_type)                 :: this
-    type(bounds_type)      , intent(in) :: bounds
+    type(bounds_type)      , intent(in) :: bounds  
     !
     ! !LOCAL VARIABLES:
     integer :: g,c,p                     ! indices
@@ -655,7 +642,7 @@ contains
        call endrun(msg=errMsg(__FILE__, __LINE__))
     endif
 
-    ! Accumulate and extract forc_solad24 & forc_solad240
+    ! Accumulate and extract forc_solad24 & forc_solad240 
     do p = begp,endp
        g = veg_pp%gridcell(p)
        rbufslp(p) = this%forc_solad_grc(g,1)
@@ -665,7 +652,7 @@ contains
     call update_accum_field  ('FSD24' , rbufslp               , nstep)
     call extract_accum_field ('FSD24' , this%fsd24_patch      , nstep)
 
-    ! Accumulate and extract forc_solai24 & forc_solai240
+    ! Accumulate and extract forc_solai24 & forc_solai240 
     do p = begp,endp
        g = veg_pp%gridcell(p)
        rbufslp(p) = this%forc_solai_grc(g,1)
@@ -697,7 +684,7 @@ contains
        do p = bounds%begp,bounds%endp
           c = veg_pp%column(p)
           g = veg_pp%gridcell(p)
-          rbufslp(p) = this%forc_wind_grc(g)
+          rbufslp(p) = this%forc_wind_grc(g) 
        end do
        call update_accum_field  ('WIND24', rbufslp, nstep)
        call extract_accum_field ('WIND24', this%wind24_patch, nstep)
@@ -705,7 +692,7 @@ contains
        do p = bounds%begp,bounds%endp
           c = veg_pp%column(p)
           g = veg_pp%gridcell(p)
-          rbufslp(p) = this%forc_rh_grc(g)
+          rbufslp(p) = this%forc_rh_grc(g) 
        end do
        call update_accum_field  ('RH24', rbufslp, nstep)
        call extract_accum_field ('RH24', this%rh24_patch, nstep)
@@ -717,19 +704,19 @@ contains
 
   !------------------------------------------------------------------------
   subroutine Restart(this, bounds, ncid, flag)
-    !
+    ! 
     ! !USES:
     use restUtilMod
     use ncdio_pio
     !
     ! !ARGUMENTS:
     class(atm2lnd_type) :: this
-    type(bounds_type), intent(in) :: bounds
-    type(file_desc_t), intent(inout) :: ncid
-    character(len=*) , intent(in)    :: flag
+    type(bounds_type), intent(in) :: bounds  
+    type(file_desc_t), intent(inout) :: ncid   
+    character(len=*) , intent(in)    :: flag   
     !
     ! !LOCAL VARIABLES:
-    logical            :: readvar
+    logical            :: readvar 
     !------------------------------------------------------------------------
 
     call restartvar(ncid=ncid, flag=flag, varname='qflx_floodg', xtype=ncd_double, &
diff --git a/components/elm/src/main/column_varcon.F90 b/components/elm/src/main/column_varcon.F90
index b9021f2046..6759319527 100644
--- a/components/elm/src/main/column_varcon.F90
+++ b/components/elm/src/main/column_varcon.F90
@@ -31,13 +31,9 @@ module column_varcon
   public :: is_hydrologically_active   ! returns true if the given column type is hydrologically active
   public :: icemec_class_to_col_itype  ! convert an icemec class (1..maxpatch_glcmec) into col_pp%itype
   public :: col_itype_to_icemec_class  ! convert col_pp%itype into an icemec class (1..maxpatch_glcmec)
-  !$acc declare copyin(icol_roof       )
-  !$acc declare copyin(icol_sunwall    )
-  !$acc declare copyin(icol_shadewall  )
-  !$acc declare copyin(icol_road_imperv)
-  !$acc declare copyin(icol_road_perv  )
-contains
 
+contains
+  
   !-----------------------------------------------------------------------
   function is_hydrologically_active(col_itype, lun_itype) &
        result(hydrologically_active)
@@ -91,10 +87,10 @@ contains
     integer, intent(in) :: icemec_class ! icemec class, between 1 and maxpatch_glcmec
     !
     ! !LOCAL VARIABLES:
-
+    
     character(len=*), parameter :: subname = 'icemec_class_to_col_itype'
     !-----------------------------------------------------------------------
-
+    
     SHR_ASSERT((1 <= icemec_class .and. icemec_class <= maxpatch_glcmec), errMsg(__FILE__, __LINE__))
 
     col_itype = istice_mec*100 + icemec_class
@@ -116,15 +112,15 @@ contains
     integer, intent(in) :: col_itype ! col_pp%itype value for an icemec landunit
     !
     ! !LOCAL VARIABLES:
-
-    !character(len=*), parameter :: subname = 'col_itype_to_icemec_class'
+    
+    character(len=*), parameter :: subname = 'col_itype_to_icemec_class'
     !-----------------------------------------------------------------------
-
+    
     icemec_class = col_itype - istice_mec*100
 
     ! The following assertion is here to ensure that col_itype is really from an
     ! istice_mec landunit
-    !SHR_ASSERT((1 <= icemec_class .and. icemec_class <= maxpatch_glcmec), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT((1 <= icemec_class .and. icemec_class <= maxpatch_glcmec), errMsg(__FILE__, __LINE__))
 
   end function col_itype_to_icemec_class
 
diff --git a/components/elm/src/main/decompInitMod.F90 b/components/elm/src/main/decompInitMod.F90
index 18681b2df5..72a9ddfeae 100644
--- a/components/elm/src/main/decompInitMod.F90
+++ b/components/elm/src/main/decompInitMod.F90
@@ -19,11 +19,10 @@ module decompInitMod
   use ColumnType      , only : col_pp                
   use FatesInterfaceTypesMod, only : fates_maxElementsPerSite
   use VegetationType  , only : veg_pp                
-  use decompMod  
+  use decompMod
   use mct_mod  
   use topounit_varcon   , only : max_topounits, has_topounit
-  use domainMod         , only : ldomain
-  use decompMod         , only : procinfo
+  use domainMod         , only: ldomain
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -463,7 +462,6 @@ contains
        ipfts       = allvecg(cid,plev)  ! number of all clump cid pfts (over all processors)
        icohorts    = allvecg(cid,hlev)  ! number of all clump cid cohorts (over all processors)
 
-
        !--- overall total ---
        numg = numg + icells         ! total number of gridcells
        numt = numt + itunits     ! total number of landunits
diff --git a/components/elm/src/main/decompMod.F90 b/components/elm/src/main/decompMod.F90
index 4810e09dc3..ff9fc3383b 100644
--- a/components/elm/src/main/decompMod.F90
+++ b/components/elm/src/main/decompMod.F90
@@ -8,7 +8,7 @@ module decompMod
   ! !USES:
   use shr_kind_mod, only : r8 => shr_kind_r8
   ! Must use shr_sys_abort rather than endrun here to avoid circular dependency
-  use shr_sys_mod , only : shr_sys_abort
+  use shr_sys_mod , only : shr_sys_abort 
   use elm_varctl  , only : iulog
   use elm_varcon  , only : grlnd, nameg, namet, namel, namec, namep, nameCohort
   use mct_mod     , only : mct_gsMap
@@ -25,17 +25,10 @@ module decompMod
   integer, parameter, public :: BOUNDS_SUBGRID_PATCH    = 5
   integer, parameter, public :: BOUNDS_SUBGRID_COHORT   = 6
 
-  !$acc declare copyin(BOUNDS_SUBGRID_GRIDCELL )
-  !$acc declare copyin(BOUNDS_SUBGRID_TOPOUNIT )
-  !$acc declare copyin(BOUNDS_SUBGRID_LANDUNIT )
-  !$acc declare copyin(BOUNDS_SUBGRID_COLUMN   )
-  !$acc declare copyin(BOUNDS_SUBGRID_PATCH    )
-  !$acc declare copyin(BOUNDS_SUBGRID_COHORT   )
   !
   ! Define possible bounds levels
   integer, parameter, public :: BOUNDS_LEVEL_PROC  = 1
   integer, parameter, public :: BOUNDS_LEVEL_CLUMP = 2
-  !$acc declare copyin(BOUNDS_LEVEL_PROC, BOUNDS_LEVEL_CLUMP)
   !
   ! !PUBLIC MEMBER FUNCTIONS:
 
@@ -59,13 +52,11 @@ module decompMod
      module procedure get_proc_bounds_new
   end interface
   public get_proc_bounds    ! this processor beg and end gridcell,landunit,column,pft
-  public get_clump_bounds_gpu
-
-  public :: init_proc_clump_info
 
   ! !PRIVATE MEMBER FUNCTIONS:
   !
   ! !PRIVATE TYPES:
+  private  ! (now mostly public for decompinitmod)
 
   integer,public :: nclumps     ! total number of clumps across all processors
   integer,public :: numg        ! total number of gridcells on all procs
@@ -77,12 +68,12 @@ module decompMod
 
   type bounds_type
      ! The following variables correspond to "Local" quantities
-     integer :: begg, endg             ! beginning and ending gridcell index
-     integer :: begt, endt             ! beginning and ending topographic unit index
-     integer :: begl, endl             ! beginning and ending landunit index
-     integer :: begc, endc             ! beginning and ending column index
-     integer :: begp, endp             ! beginning and ending pft index
-     integer :: begCohort, endCohort   ! beginning and ending cohort indices
+     integer :: begg, endg                       ! beginning and ending gridcell index
+     integer :: begt, endt                       ! beginning and ending topographic unit index
+     integer :: begl, endl                       ! beginning and ending landunit index
+     integer :: begc, endc                       ! beginning and ending column index
+     integer :: begp, endp                       ! beginning and ending pft index
+     integer :: begCohort, endCohort             ! beginning and ending cohort indices
 
      ! The following variables correspond to "Ghost/Halo" quantites
      integer :: begg_ghost, endg_ghost           ! beginning and ending gridcell index
@@ -105,92 +96,56 @@ module decompMod
   end type bounds_type
   public bounds_type
 
-  type :: bounds_type_gpu
-     ! The following variables correspond to "Local" quantities
-     integer, pointer :: begg, endg            => null() ! beginning and ending gridcell index
-     integer, pointer :: begt, endt            => null() ! beginning and ending topographic unit index
-     integer, pointer :: begl, endl            => null() ! beginning and ending landunit index
-     integer, pointer :: begc, endc            => null() ! beginning and ending column index
-     integer, pointer :: begp, endp            => null() ! beginning and ending pft index
-     integer, pointer :: begCohort, endCohort  => null() ! beginning and ending cohort indices
-
-     ! The following variables correspond to "Ghost/Halo" quantites
-     integer, pointer :: begg_ghost, endg_ghost           => null() ! beginning and ending gridcell index
-     integer, pointer :: begt_ghost, endt_ghost           => null() ! beginning and ending topounit index
-     integer, pointer :: begl_ghost, endl_ghost           => null() ! beginning and ending landunit index
-     integer, pointer :: begc_ghost, endc_ghost           => null() ! beginning and ending column index
-     integer, pointer :: begp_ghost, endp_ghost           => null() ! beginning and ending pft index
-     integer, pointer :: begCohort_ghost, endCohort_ghost => null() ! beginning and ending cohort indices
-
-     ! The following variables correspond to "ALL" (=Local + Ghost) quantites
-     integer, pointer :: begg_all, endg_all           => null()   ! beginning and ending gridcell index
-     integer, pointer :: begt_all, endt_all           => null()   ! beginning and ending topounit index
-     integer, pointer :: begl_all, endl_all           => null()   ! beginning and ending landunit index
-     integer, pointer :: begc_all, endc_all           => null()   ! beginning and ending column index
-     integer, pointer :: begp_all, endp_all           => null()   ! beginning and ending pft index
-     integer, pointer :: begCohort_all, endCohort_all => null()   ! beginning and ending cohort indices
-
-     integer, pointer :: level       => null()      ! whether defined on the proc or clump level
-     integer, pointer :: clump_index => null()      ! if defined on the clump level, this gives the clump index
-  end type bounds_type_gpu
-
   !---global information on each pe
   type processor_type
      integer         :: nclumps                          ! number of clumps for processor_type iam
      integer,pointer :: cid(:)                           ! clump indices
-     
+
      ! The following variables correspond to "Local" quantities on a proc
-     integer   :: ncells                           ! number of gridcells in proc
-     integer   :: ntunits                          ! number of topographic units in proc
-     integer   :: nlunits                          ! number of landunits in proc
-     integer   :: ncols                            ! number of columns in proc
-     integer   :: npfts                            ! number of pfts in proc
-     integer   :: nCohorts                         ! number of cohorts in proc
-     integer   :: begg, endg                       ! beginning and ending gridcell index
-     integer   :: begt, endt                       ! beginning and ending topographic unit index
-     integer   :: begl, endl                       ! beginning and ending landunit index
-     integer   :: begc, endc                       ! beginning and ending column index
-     integer   :: begp, endp                       ! beginning and ending pft index
-     integer   :: begCohort, endCohort             ! beginning and ending cohort indices
+     integer         :: ncells                           ! number of gridcells in proc
+     integer         :: ntunits                          ! number of topographic units in proc
+     integer         :: nlunits                          ! number of landunits in proc
+     integer         :: ncols                            ! number of columns in proc
+     integer         :: npfts                            ! number of pfts in proc
+     integer         :: nCohorts                         ! number of cohorts in proc
+     integer         :: begg, endg                       ! beginning and ending gridcell index
+     integer         :: begt, endt                       ! beginning and ending topographic unit index
+     integer         :: begl, endl                       ! beginning and ending landunit index
+     integer         :: begc, endc                       ! beginning and ending column index
+     integer         :: begp, endp                       ! beginning and ending pft index
+     integer         :: begCohort, endCohort             ! beginning and ending cohort indices
 
      ! The following variables correspond to "Ghost/Halo" quantites on a proc
-     integer   :: ncells_ghost                     ! number of gridcells in proc
-     integer   :: ntunits_ghost                    ! number of topounits in proc
-     integer   :: nlunits_ghost                    ! number of landunits in proc
-     integer   :: ncols_ghost                      ! number of columns in proc
-     integer   :: npfts_ghost                      ! number of pfts in proc
-     integer   :: nCohorts_ghost                   ! number of cohorts in proc
-     integer   :: begg_ghost, endg_ghost           ! beginning and ending gridcell index
-     integer   :: begt_ghost, endt_ghost           ! beginning and ending topounit index
-     integer   :: begl_ghost, endl_ghost           ! beginning and ending landunit index
-     integer   :: begc_ghost, endc_ghost           ! beginning and ending column index
-     integer   :: begp_ghost, endp_ghost           ! beginning and ending pft index
-     integer   :: begCohort_ghost, endCohort_ghost ! beginning and ending cohort indices
+     integer         :: ncells_ghost                     ! number of gridcells in proc
+     integer         :: ntunits_ghost                    ! number of topounits in proc
+     integer         :: nlunits_ghost                    ! number of landunits in proc
+     integer         :: ncols_ghost                      ! number of columns in proc
+     integer         :: npfts_ghost                      ! number of pfts in proc
+     integer         :: nCohorts_ghost                   ! number of cohorts in proc
+     integer         :: begg_ghost, endg_ghost           ! beginning and ending gridcell index
+     integer         :: begt_ghost, endt_ghost           ! beginning and ending topounit index
+     integer         :: begl_ghost, endl_ghost           ! beginning and ending landunit index
+     integer         :: begc_ghost, endc_ghost           ! beginning and ending column index
+     integer         :: begp_ghost, endp_ghost           ! beginning and ending pft index
+     integer         :: begCohort_ghost, endCohort_ghost ! beginning and ending cohort indices
 
      ! The following variables correspond to "ALL" (=Local + Ghost) quantites on a proc
-     integer   :: ncells_all                       ! number of gridcells in proc
-     integer   :: ntunits_all                   ! number of topounits in proc
-     integer   :: nlunits_all                      ! number of landunits in proc
-     integer   :: ncols_all                        ! number of columns in proc
-     integer   :: npfts_all                        ! number of pfts in proc
-     integer   :: nCohorts_all                     ! number of cohorts in proc
-     integer   :: begg_all, endg_all               ! beginning and ending gridcell index
-     integer   :: begt_all, endt_all               ! beginning and ending topounit index
-     integer   :: begl_all, endl_all               ! beginning and ending landunit index
-     integer   :: begc_all, endc_all               ! beginning and ending column index
-     integer   :: begp_all, endp_all               ! beginning and ending pft index
-     integer   :: begCohort_all, endCohort_all     ! beginning and ending cohort indices
+     integer         :: ncells_all                       ! number of gridcells in proc
+     integer         :: ntunits_all                   ! number of topounits in proc
+     integer         :: nlunits_all                      ! number of landunits in proc
+     integer         :: ncols_all                        ! number of columns in proc
+     integer         :: npfts_all                        ! number of pfts in proc
+     integer         :: nCohorts_all                     ! number of cohorts in proc
+     integer         :: begg_all, endg_all               ! beginning and ending gridcell index
+     integer         :: begt_all, endt_all               ! beginning and ending topounit index
+     integer         :: begl_all, endl_all               ! beginning and ending landunit index
+     integer         :: begc_all, endc_all               ! beginning and ending column index
+     integer         :: begp_all, endp_all               ! beginning and ending pft index
+     integer         :: begCohort_all, endCohort_all     ! beginning and ending cohort indices
+
   end type processor_type
   public processor_type
-  
-  type(processor_type), public :: procinfo
-
-  type :: processor_type_gpu
-     integer, pointer :: nclumps   => null()             ! number of clumps for processor_type iam
-     integer, pointer :: cid(:)    => null()             ! clump indices
-
-  end type processor_type_gpu
-  type(processor_type_gpu), public :: gpu_procinfo
+  type(processor_type),public :: procinfo
 
   !---global information on each pe
   type clump_type
@@ -211,30 +166,6 @@ module decompMod
   public clump_type
   type(clump_type),public, allocatable :: clumps(:)
 
-    type clump_type_gpu
-       integer, pointer :: owner          => null()  ! process id owning clump
-       integer, pointer :: ncells         => null()  ! number of gridcells in clump
-       integer, pointer :: ntunits        => null()  ! number of topographic units in clump
-       integer, pointer :: nlunits        => null()  ! number of landunits in clump
-       integer, pointer :: ncols          => null()  ! number of columns in clump
-       integer, pointer :: npfts          => null()  ! number of pfts in clump
-       integer, pointer :: nCohorts       => null()  ! number of cohorts in clump
-       integer, pointer :: begg           => null()
-       integer, pointer :: endg           => null()  ! beginning and ending gridcell index
-       integer, pointer :: begt           => null()
-       integer, pointer :: endt           => null()  ! beginning and ending topographic unit index
-       integer, pointer :: begl           => null()
-       integer, pointer :: endl           => null()  ! beginning and ending landunit index
-       integer, pointer :: begc           => null()
-       integer, pointer :: endc           => null()  ! beginning and ending column index
-       integer, pointer :: begp           => null()
-       integer, pointer :: endp           => null()  ! beginning and ending pft index
-       integer, pointer :: begCohort      => null()
-       integer, pointer :: endCohort      => null()  ! beginning and ending cohort indices
-    end type clump_type_gpu
-    type(clump_type_gpu), public, allocatable :: gpu_clumps(:)
-
-
   !---global information on each pe
   !--- glo = 1d global sn ordered
   !--- gdc = 1d global dc ordered compressed
@@ -253,63 +184,8 @@ module decompMod
   type(mct_gsMap)  ,public,target :: gsMap_cohort_gdc2glo
   !------------------------------------------------------------------------------
 
-  !$acc declare create(clumps)
-  !$acc declare create(procinfo)
-
-  !$acc declare create(gpu_clumps, gpu_procinfo)
-
 contains
-  subroutine init_proc_clump_info()
-    implicit none
-
-    integer :: nc
-    print *, "allocating ",nclumps,"for gpu"
-
-    allocate(gpu_clumps(nclumps))
-    allocate(gpu_procinfo%cid(nclumps))
-    allocate(gpu_procinfo%nclumps);
-    gpu_procinfo%nclumps = procinfo%nclumps
-
-    do nc = 1 , nclumps
-      gpu_procinfo%cid(nc) = procinfo%cid(nc)
-      allocate(gpu_clumps(nc)%owner          )
-      allocate(gpu_clumps(nc)%ncells          )
-      allocate(gpu_clumps(nc)%ntunits      )
-      allocate(gpu_clumps(nc)%nlunits         )
-      allocate(gpu_clumps(nc)%ncols           )
-      allocate(gpu_clumps(nc)%npfts           )
-      allocate(gpu_clumps(nc)%nCohorts        )
-      allocate(gpu_clumps(nc)%begg       )
-      allocate(gpu_clumps(nc)%endg       )
-      allocate(gpu_clumps(nc)%begt       )
-      allocate(gpu_clumps(nc)%endt       )
-      allocate(gpu_clumps(nc)%begl       )
-      allocate(gpu_clumps(nc)%endl       )
-      allocate(gpu_clumps(nc)%begc       )
-      allocate(gpu_clumps(nc)%endc       )
-      allocate(gpu_clumps(nc)%begp       )
-      allocate(gpu_clumps(nc)%endp       )
-      allocate(gpu_clumps(nc)%begCohort  )
-      allocate(gpu_clumps(nc)%endCohort  )
-    end do
-    do nc = 1, nclumps
-      gpu_clumps(nc)%owner      = clumps(nc)%owner
-      gpu_clumps(nc)%ncells     = clumps(nc)%ncells
-      gpu_clumps(nc)%ntunits    = clumps(nc)%ntunits
-      gpu_clumps(nc)%nlunits    = clumps(nc)%nlunits
-      gpu_clumps(nc)%ncols      = clumps(nc)%ncols
-      gpu_clumps(nc)%npfts      = clumps(nc)%npfts
-      gpu_clumps(nc)%nCohorts   = clumps(nc)%nCohorts
-      gpu_clumps(nc)%begg = clumps(nc)%begg; gpu_clumps(nc)%endg = clumps(nc)%endg
-      gpu_clumps(nc)%begt = clumps(nc)%begt; gpu_clumps(nc)%endt = clumps(nc)%endt
-      gpu_clumps(nc)%begl = clumps(nc)%begl; gpu_clumps(nc)%endl = clumps(nc)%endl
-      gpu_clumps(nc)%begc = clumps(nc)%begc; gpu_clumps(nc)%endc = clumps(nc)%endc
-      gpu_clumps(nc)%begp = clumps(nc)%begp; gpu_clumps(nc)%endp = clumps(nc)%endp
-      gpu_clumps(nc)%begCohort = clumps(nc)%begCohort
-      gpu_clumps(nc)%endCohort = clumps(nc)%endCohort
-    end do
-
-  end subroutine init_proc_clump_info
+
   !-----------------------------------------------------------------------
   pure function get_beg(bounds, subgrid_level) result(beg_index)
     !
@@ -398,7 +274,7 @@ contains
 
   !------------------------------------------------------------------------------
    subroutine get_clump_bounds_new (n, bounds)
-
+     !
      ! !DESCRIPTION:
      ! Determine clump bounds
      !
@@ -409,14 +285,14 @@ contains
      ! !LOCAL VARIABLES:
      character(len=32), parameter :: subname = 'get_clump_bounds'  ! Subroutine name
      integer :: cid                                                ! clump id
-     #ifdef _OPENMP
+#ifdef _OPENMP
      integer, external :: OMP_GET_MAX_THREADS
      integer, external :: OMP_GET_NUM_THREADS
      integer, external :: OMP_GET_THREAD_NUM
-     #endif
+#endif
      !------------------------------------------------------------------------------
      !    Make sure this IS being called from a threaded region
-     #ifdef _OPENMP
+#ifdef _OPENMP
      ! FIX(SPM, 090314) - for debugging ED and openMP
      !write(iulog,*) 'SPM omp debug decompMod 1 ', &
           !OMP_GET_NUM_THREADS(),OMP_GET_MAX_THREADS(),OMP_GET_THREAD_NUM()
@@ -424,7 +300,7 @@ contains
      if ( OMP_GET_NUM_THREADS() == 1 .and. OMP_GET_MAX_THREADS() > 1 )then
         call shr_sys_abort( trim(subname)//' ERROR: Calling from inside a non-threaded region)')
      end if
-     #endif
+#endif
 
      cid  = procinfo%cid(n)
      bounds%begp = clumps(cid)%begp
@@ -464,7 +340,7 @@ contains
 
      bounds%begCohort = clumps(cid)%begCohort
      bounds%endCohort = clumps(cid)%endCohort
-
+     
      bounds%level = BOUNDS_LEVEL_CLUMP
      bounds%clump_index = n
 
@@ -764,57 +640,4 @@ contains
 
    end subroutine get_proc_total_ghosts
 
-   subroutine get_clump_bounds_gpu(n, bounds)
-     !$acc routine seq
-     ! !DESCRIPTION:
-     ! Determine clump bounds
-     !
-     ! !ARGUMENTS:
-     integer, value, intent(in)  :: n                ! processor clump index
-     type(bounds_type), intent(inout) :: bounds ! clump bounds
-     !
-     ! !LOCAL VARIABLES:
-     bounds%begp = gpu_clumps(n)%begp
-     bounds%endp = gpu_clumps(n)%endp
-     bounds%begc = gpu_clumps(n)%begc
-     bounds%endc = gpu_clumps(n)%endc
-     bounds%begl = gpu_clumps(n)%begl
-     bounds%endl = gpu_clumps(n)%endl
-     bounds%begt = gpu_clumps(n)%begt
-     bounds%endt = gpu_clumps(n)%endt
-     bounds%begg = gpu_clumps(n)%begg
-     bounds%endg = gpu_clumps(n)%endg
-      
-     ! clumps have no ghost quantites
-     bounds%begp_ghost = 0
-     bounds%endp_ghost = 0
-     bounds%begc_ghost = 0
-     bounds%endc_ghost = 0
-     bounds%begl_ghost = 0
-     bounds%endl_ghost = 0
-     bounds%begt_ghost = 0
-     bounds%endt_ghost = 0
-     bounds%begg_ghost = 0
-     bounds%endg_ghost = 0
-
-     ! Since clumps have no ghost quantites, all = local
-     bounds%begp_all = gpu_clumps(n)%begp
-     bounds%endp_all = gpu_clumps(n)%endp
-     bounds%begc_all = gpu_clumps(n)%begc
-     bounds%endc_all = gpu_clumps(n)%endc
-     bounds%begl_all = gpu_clumps(n)%begl
-     bounds%endl_all = gpu_clumps(n)%endl
-     bounds%begt_all = gpu_clumps(n)%begt
-     bounds%endt_all = gpu_clumps(n)%endt
-     bounds%begg_all = gpu_clumps(n)%begg
-     bounds%endg_all = gpu_clumps(n)%endg
-
-     bounds%begCohort = gpu_clumps(n)%begCohort
-     bounds%endCohort = gpu_clumps(n)%endCohort
-
-     bounds%level = BOUNDS_LEVEL_CLUMP
-     bounds%clump_index = n
-
-   end subroutine get_clump_bounds_gpu
-
 end module decompMod
diff --git a/components/elm/src/main/dynUpdateModAcc.F90 b/components/elm/src/main/dynUpdateModAcc.F90
deleted file mode 100644
index 8e9c490296..0000000000
--- a/components/elm/src/main/dynUpdateModAcc.F90
+++ /dev/null
@@ -1,606 +0,0 @@
-module dynUpdateModAcc
-
-   use shr_kind_mod , only : r8 => shr_kind_r8
-   use decompMod, only : bounds_type
-   use dynColumnStateUpdaterMod, only : column_state_updater_type
-   use dynPatchStateUpdaterMod , only : patch_state_updater_type 
-   use GridcellType    , only : grc_pp
-   use LandunitType    , only : lun_pp
-   use VegetationType       , only : veg_pp
-   use ColumnType           , only : col_pp
-   use elm_varcon      , only : ispval
-   use dynColumnTemplateMod, only : TEMPLATE_NONE_FOUND
-   
-   implicit none 
-   public
-   public :: update_column_state_acc
-   public :: update_column_state_no_special_handling_acc 
-   public :: old_weight_was_zeroAcc 
-   public :: patch_grewAcc
-   public :: update_patch_stateAcc 
-   public :: update_patch_state_partition_flux_by_typeAcc
-   public :: patch_set_new_weightsAcc
-   public :: column_set_new_weightsAcc
-   public :: set_old_patch_weightsAcc 
-   public :: set_old_column_weightsAcc
-
-contains
-
-  !-----------------------------------------------------------------------
-  subroutine update_column_state_acc(column_state_updater, bounds, &
-       var, non_conserved_mass, adjustment)
-    !
-    ! !DESCRIPTION:
-    ! Do the work of updating a column-level state variable due to changes in subgrid
-    ! weights.
-    !
-    ! !USES:
-    !$acc routine seq
-    ! !ARGUMENTS:
-    type(column_state_updater_type), intent(in) :: column_state_updater
-    type(bounds_type), intent(in) :: bounds
-
-    ! column-level variable of interest, updated in-place
-    real(r8), intent(inout) :: var( bounds%begc: )
-
-    ! mass lost (per unit of grid cell area) from each grid cell, if doing special
-    ! handling that leads mass to not be conserved; this can happen due to growing columns
-    ! where has_prognostic_state is false, or due to shrinking columns where
-    ! has_prognostic_state is false but vals_input /= 0. Positive denotes mass lost from
-    ! the grid cell, negative denotes mass gained by the grid cell.
-    real(r8), intent(inout) :: non_conserved_mass( bounds%begg: )
-
-    ! Apparent state adjustment in each column
-    real(r8), optional, intent(inout) :: adjustment( bounds%begc: )
-    !
-    ! !LOCAL VARIABLES:
-    integer  :: c, g
-
-    ! fractional area lost from this column
-    real(r8) :: area_lost
-
-    ! area-weighted amount lost from a given column
-    real(r8) :: area_weighted_loss
-
-    ! area-weighted amount lost from decreasing weights, in each grid cell
-    ! ((mass-per-unit-area) * (fractional area lost))
-    real(r8) :: total_loss_grc(bounds%begg:bounds%endg)
-
-    ! total area lost by columns decreasing in area (fractional area of grid cell)
-    ! Note that this should exactly equal the total area gained by columns increasing in area
-    real(r8) :: total_area_lost_grc(bounds%begg:bounds%endg)
-
-    ! amount of state gain needed per unit area of area gained
-    real(r8) :: gain_per_unit_area_grc(bounds%begg:bounds%endg)
-
-    ! mass gained by a given column ((mass-gained-per-unit-area) * (fractional area gained))
-    real(r8) :: mass_gained
-
-    ! value in a column before update
-    real(r8) :: val_old
-
-    ! ------------------------------------------------------------------------
-    ! Begin main work
-    ! ------------------------------------------------------------------------
-
-    ! Determine the total mass loss for each grid cell, along with the gross area loss
-    ! (which should match the gross area gain)
-    total_loss_grc(bounds%begg:bounds%endg) = 0._r8
-    total_area_lost_grc(bounds%begg:bounds%endg) = 0._r8
-    do c = bounds%begc, bounds%endc
-       g = col_pp%gridcell(c)
-       if (column_state_updater%area_gained_col(c) < 0._r8) then
-
-          area_lost = -1._r8 * column_state_updater%area_gained_col(c)
-          total_area_lost_grc(g) = total_area_lost_grc(g) + area_lost
-          area_weighted_loss = area_lost * var(c) 
-          total_loss_grc(g) = total_loss_grc(g) + area_weighted_loss
-         
-       end if
-    end do
-
-    ! Determine the mass loss per unit area for each grid cell. We essentially lump all of
-    ! the loss together in a "loss" pool in each grid cell, so that we can then
-    ! distribute that loss amongst the growing columns.
-    do g = bounds%begg, bounds%endg
-       if (total_area_lost_grc(g) > 0._r8) then
-          gain_per_unit_area_grc(g) = total_loss_grc(g) / total_area_lost_grc(g)
-       else
-          gain_per_unit_area_grc(g) = 0._r8
-       end if
-    end do
-
-    ! Distribute gain to growing columns
-    do c = bounds%begc, bounds%endc
-       g = col_pp%gridcell(c)
-       if (column_state_updater%area_gained_col(c) > 0._r8) then
-         mass_gained = column_state_updater%area_gained_col(c) * gain_per_unit_area_grc(g)
-         val_old = var(c)
-         !
-         ! Need to make sure fractional_area_new /= 0 to avoid divide-by-zero. Note
-         ! that fractional_area_new == 0 can only happen if both
-         ! fractional_area_old(c) == 0 and the fractional_areas of the shrinking
-         ! columns were all 0 - in which case the value of var is irrelevant for
-         ! conservation purposes.
-         var(c) = (column_state_updater%cwtgcell_old(c) *    var(c) + mass_gained) / &
-              (column_state_updater%cwtgcell_new(c))
-
-         adjustment(c) = var(c) - val_old 
-       end if
-    end do
-
-  end subroutine update_column_state_acc
-
-  !-----------------------------------------------------------------------
-  subroutine update_column_state_no_special_handling_acc(column_state_updater, bounds, clump_index, &
-       var, adjustment)
-    !
-    ! !DESCRIPTION:
-    ! Adjust the values of a column-level state variable due to changes in subgrid
-    ! weights.
-    !
-    ! This method does no special handling of any columns.
-    !
-    ! !USES:
-    !$acc routine seq
-    ! !ARGUMENTS:
-    type(column_state_updater_type), intent(in) :: column_state_updater
-    type(bounds_type), intent(in) :: bounds
-
-    ! Index of clump on which we're currently operating. Note that this implies that this
-    ! routine must be called from within a clump loop.
-    integer, intent(in) :: clump_index
-
-    real(r8), intent(inout) :: var( bounds%begc: ) ! column-level variable
-
-    ! Fraction of each column over which the state variable applies. See module-level
-    ! documentation for details. You must provide both old & new fractional areas, or
-    ! neither: it is invalid to provide just one. Fractional areas should be valid for all
-    ! columns, and fractional_area_new should have been computed based on a call to
-    ! update_column_state_no_special_handling: code that works with these fractional areas
-    ! is not able to do any special handling.
-
-    ! Apparent state adjustment in each column
-    real(r8),  intent(out) :: adjustment( bounds%begc: )
-    !
-    ! !LOCAL VARIABLES:
-    real(r8) :: non_conserved_mass!(bounds%begg:bounds%endg)
-    real(r8), parameter :: conservation_tolerance = 1.e-12_r8
-    integer  :: c,g
-
-    ! fractional area lost from this column
-    real(r8) :: area_lost
-
-    ! area-weighted amount lost from a given column
-    real(r8) :: area_weighted_loss
-
-    ! area-weighted amount lost from decreasing weights, in each grid cell
-    ! ((mass-per-unit-area) * (fractional area lost))
-    real(r8) :: total_loss_grc!(bounds%begg:bounds%endg)
-
-    ! total area lost by columns decreasing in area (fractional area of grid cell)
-    ! Note that this should exactly equal the total area gained by columns increasing in area
-    real(r8) :: total_area_lost_grc!(bounds%begg:bounds%endg)
-
-    ! amount of state gain needed per unit area of area gained
-    real(r8) :: gain_per_unit_area_grc!(bounds%begg:bounds%endg)
-
-    ! mass gained by a given column ((mass-gained-per-unit-area) * (fractional area gained))
-    real(r8) :: mass_gained
-
-    ! value in a column before update
-    real(r8) :: val_old
-
-    !character(len=*), parameter :: subname = 'update_column_state_no_special_handling'
-    !-----------------------------------------------------------------------
-
-   ! Even if there's no work to be done, need to zero out adjustment, since it's
-   ! intent(out), and caller may expect it to return in a reasonable state.
-     
-   ! adjustment(bounds%begc:bounds%endc) = 0._r8
-
-
-      ! non_conserved_mass(bounds%begg:bounds%endg) = 0._r8
-
-      ! call update_column_state_acc(column_state_updater, bounds, &
-      !          var, non_conserved_mass, adjustment)
-      ! ------------------------------------------------------------------------
-      ! Begin main work
-      ! ------------------------------------------------------------------------
-
-      ! Determine the total mass loss for each grid cell, along with the gross area loss
-      ! (which should match the gross area gain)
-      total_loss_grc = 0._r8    !(bounds%begg:bounds%endg) = 0._r8
-      total_area_lost_grc = 0._r8 !(bounds%begg:bounds%endg) = 0._r8
-      do c = bounds%begc, bounds%endc
-         g = col_pp%gridcell(c)
-         if (column_state_updater%area_gained_col(c) < 0._r8) then
-  
-            area_lost = -1._r8 * column_state_updater%area_gained_col(c)
-            total_area_lost_grc = total_area_lost_grc + area_lost
-            area_weighted_loss = area_lost * var(c) 
-            total_loss_grc = total_loss_grc + area_weighted_loss
-           
-         end if
-      end do
-      ! Determine the mass loss per unit area for each grid cell. We essentially lump all of
-      ! the loss together in a "loss" pool in each grid cell, so that we can then
-      ! distribute that loss amongst the growing columns.
-      if (total_area_lost_grc > 0._r8) then
-         gain_per_unit_area_grc = total_loss_grc / total_area_lost_grc
-      else
-         gain_per_unit_area_grc = 0._r8
-      end if
-
-      ! Distribute gain to growing columns
-      do c = bounds%begc, bounds%endc
-         g = col_pp%gridcell(c)
-         adjustment(c) = 0._r8
-         if (column_state_updater%area_gained_col(c) > 0._r8) then
-            mass_gained = column_state_updater%area_gained_col(c) * gain_per_unit_area_grc
-            val_old = var(c)
-            !
-            ! Need to make sure fractional_area_new /= 0 to avoid divide-by-zero. Note
-            ! that fractional_area_new == 0 can only happen if both
-            ! fractional_area_old(c) == 0 and the fractional_areas of the shrinking
-            ! columns were all 0 - in which case the value of var is irrelevant for
-            ! conservation purposes.
-            var(c) = (column_state_updater%cwtgcell_old(c) * var(c) + mass_gained) / &
-               (column_state_updater%cwtgcell_new(c))
-
-            adjustment(c) = var(c) - val_old 
-         end if
-       end do
-      ! Since there is no special handling in this routine, the non_conserved_mass variable
-      ! should not have any accumulation. We allow for roundoff-level accumulation in case
-      ! non-conserved mass is determined in a way that is prone to roundoff-level errors.
-      !err_msg = subname//': ERROR: failure to conserve mass when using no special handling'
-      non_conserved_mass = abs(non_conserved_mass)
-      if(non_conserved_mass > conservation_tolerance) print *, "Error Mass not conserved "
-      ! if(sum(non_conserved_mass(bounds%begg:bounds%endg)) < conservation_tolerance) Then
-      !   print *,  'ERROR: failure to conserve mass when using no special handling'
-      ! end if
-
-  end subroutine update_column_state_no_special_handling_acc
-
-  !-----------------------------------------------------------------------
-  function old_weight_was_zeroAcc(patch_state_updater, bounds) result(old_weight_was_zero)
-    !
-    ! !DESCRIPTION:
-    ! Returns a patch-level logical array that is true wherever the patch weight was zero
-    ! prior to weight updates
-    !
-    ! !USES:
-    !$acc routine seq
-    ! !ARGUMENTS:
-    type(patch_state_updater_type), intent(in) :: patch_state_updater
-    type(bounds_type), intent(in) :: bounds
-    logical :: old_weight_was_zero(bounds%begp:bounds%endp)  ! function result
-    !
-    ! !LOCAL VARIABLES:
-    integer :: p
-    !-----------------------------------------------------------------------
-
-    do p = bounds%begp, bounds%endp
-       old_weight_was_zero(p) = (patch_state_updater%pwtgcell_old(p) == 0._r8)
-    end do
-
-  end function old_weight_was_zeroAcc
-
-  !-----------------------------------------------------------------------
-  function patch_grewAcc(patch_state_updater, bounds) result(patch_grew)
-    !
-    ! !DESCRIPTION:
-    ! Returns a patch-level logical array that is true wherever the patch grew in this
-    ! time step
-    !
-    ! !USES:
-    !$acc routine seq
-    ! !ARGUMENTS:
-    type(patch_state_updater_type), intent(in) :: patch_state_updater
-    type(bounds_type), intent(in) :: bounds
-    logical :: patch_grew(bounds%begp:bounds%endp)  ! function result
-    !
-    ! !LOCAL VARIABLES:
-    integer :: p
-    !-----------------------------------------------------------------------
-
-    do p = bounds%begp, bounds%endp
-       patch_grew(p) = (patch_state_updater%dwt(p) > 0._r8)
-    end do
-
-  end function patch_grewAcc
-
-  !-----------------------------------------------------------------------
-  subroutine update_patch_stateAcc(patch_state_updater,p,c, &
-       var, flux_out_col_area, flux_out_grc_area, &
-       seed, seed_addition)
-    !
-    ! !DESCRIPTION:
-    ! Update a patch-level state variable and compute associated fluxes based on changing
-    ! patch areas
-    !
-    ! For growing patches, this subroutine adjusts var. For shrinking patches, this
-    ! subroutine accumulates flux in flux_out_col_area.
-    !
-    ! Changes are only made within the given filter. Note that this filter should include
-    ! inactive as well as active patches, so that it includes patches that just became
-    ! inactive.
-    !
-    ! !USES:
-    !$acc routine seq
-    ! !ARGUMENTS:
-    type(patch_state_updater_type), intent(in) :: patch_state_updater
-    integer , value  , intent(in) :: p,c
-    real(r8), intent(inout) :: var   ! patch-level state variable
-
-    ! Accumulated flux from shrinking areas, expressed as mass per unit area COLUMN, using
-    ! the OLD column weight. (The use of the old column weight is appropriate if the
-    ! fluxes from shrinking patches are applied to column-level state variables BEFORE
-    ! doing column-level state adjustments via the column_state_updater). For shrinking
-    ! areas, this is given as a NEGATIVE quantity. Often you will provide one of
-    ! flux_out_col_area or flux_out_grc_area, but it is okay to provide both, or to
-    ! provide neither if you don't need to track the flux out from this state variable.
-    real(r8), intent(inout), optional :: flux_out_col_area
-
-    ! Accumulated flux from shrinking areas, expressed as mass per unit area GRIDCELL. For
-    ! shrinking areas, this is given as a NEGATIVE quantity. Often you will provide one of
-    ! flux_out_col_area or flux_out_grc_area, but it is okay to provide both, or to
-    ! provide neither if you don't need to track the flux out from this state variable.
-    real(r8), intent(inout), optional :: flux_out_grc_area
-
-    ! If provided, this gives some 'seed' amount added to the state in the area into
-    ! which each growing patch grows. The value is ignored for patches that are either
-    ! constant or shrinking in area.
-    real(r8), intent(in), optional :: seed
-
-    ! If provided, this accumulates the amount of seed added to each patch. This gives
-    ! seed(p) * dwt(p). This can only be provided if seed is provided. Even though this is
-    ! a patch-level array, it is expressed as mass per unit area GRIDCELL.
-    real(r8), intent(inout), optional :: seed_addition
-    !
-    !
-    ! !LOCAL VARIABLES:
-
-    !-----------------------------------------------------------------------
-
-   !  if (present(seed_addition)) then
-   !     if (.not. present(seed)) then
-   !        print *, ' ERROR: seed_addition can only be provided if seed is provided'
-   !     end if
-   !  end if
-
-      if (patch_state_updater%dwt(p) > 0._r8) then
-          var  = var  * patch_state_updater%growing_old_fraction(p)
-      if (present(seed)) then
-         var  = var  + seed  * patch_state_updater%growing_new_fraction(p)
-         if (present(seed_addition)) then
-            seed_addition  = seed_addition  + seed  * patch_state_updater%dwt(p)
-         end if
-       end if
-       !
-    else if (patch_state_updater%dwt(p) < 0._r8) then
-      if (present(flux_out_grc_area)) then
-         flux_out_grc_area  = flux_out_grc_area  + var  * patch_state_updater%dwt(p)
-      end if
-      if (present(flux_out_col_area)) then
-         ! No need to check for divide by 0 here: If dwt < 0 then we must have had
-         ! cwtgcell_old > 0.
-         flux_out_col_area  = flux_out_col_area  + &
-              var  * (patch_state_updater%dwt(p) / patch_state_updater%cwtgcell_old(c))
-      end if
-    end if
-
-  end subroutine update_patch_stateAcc
-
-  !-----------------------------------------------------------------------
-  subroutine update_patch_state_partition_flux_by_typeAcc(patch_state_updater, &
-       p,c,flux1_out_dest, flux1_fraction_by_pft_type, &
-       var, flux1_out, flux2_out, &
-       seed, seed_addition)
-    !
-    ! !DESCRIPTION:
-    ! Update a patch-level state variable and compute associated fluxes based on
-    ! changing patch areas, with flux out partitioned into two fluxes. Partitioning is
-    ! based on pft type.
-    !
-    ! !USES:
-    !$acc routine seq
-    ! !ARGUMENTS:
-    type(patch_state_updater_type), intent(in) :: patch_state_updater
-    integer   , value, intent(in) :: p,c
-    character(len=1), intent(in) :: flux1_out_dest  ! flux1_out to column or grid (default)
-    real(r8), intent(in) :: flux1_fraction_by_pft_type( 0: ) ! fraction of flux that goes into flux1_out, indexed by pft type
-    real(r8), intent(inout) :: var!( bounds%begp: ) ! patch-level state variable
-
-    ! Accumulated fluxes from shrinking areas. For shrinking areas, these are given as
-    ! NEGATIVE quantities. Even though these are patch-level arrays, they are expressed
-    ! as mass per unit area GRIDCELL (so these are equivalent to the flux_out_grc_area
-    ! argument in the main update_patch_state routine).
-    real(r8), intent(inout) :: flux1_out!( bounds%begp: )
-    real(r8), intent(inout) :: flux2_out!( bounds%begp: )
-
-    ! If provided, this gives some 'seed' amount added to the state in the area into
-    ! which each growing patch grows. The value is ignored for patches that are either
-    ! constant or shrinking in area.
-    real(r8), intent(in), optional :: seed!( bounds%begp: )
-
-    ! If provided, this accumulates the amount of seed added to each patch. This gives
-    ! seed(p) * dwt(p). This can only be provided if seed is provided. Even though this is
-    ! a patch-level array, it is expressed as mass per unit area GRIDCELL.
-    real(r8), intent(inout), optional :: seed_addition!( bounds%begp: )
-    !
-    ! !LOCAL VARIABLES:
-    real(r8) :: total_flux_out!(bounds%begp:bounds%endp)
-    real(r8) :: my_flux1_fraction
-    !-----------------------------------------------------------------------
-
-
-    total_flux_out  = 0._r8
-    if (flux1_out_dest=='c') then
-       call update_patch_stateAcc(patch_state_updater, p, c, &
-          var, flux_out_col_area = total_flux_out, &
-          seed = seed, seed_addition = seed_addition)
-    else
-       call update_patch_stateAcc(patch_state_updater,p,c, &
-          var, flux_out_grc_area = total_flux_out, &
-          seed = seed, seed_addition = seed_addition)
-    end if
-
-    my_flux1_fraction = flux1_fraction_by_pft_type(veg_pp%itype(p))
-    flux1_out = flux1_out + total_flux_out * my_flux1_fraction
-    flux2_out = flux2_out + total_flux_out * (1._r8 - my_flux1_fraction)
-
-  end subroutine update_patch_state_partition_flux_by_typeAcc
-  !-----------------------------------------------------------------------
-  subroutine patch_set_new_weightsAcc(patch_state_updater, bounds)
-    !
-    ! !DESCRIPTION:
-    ! Set subgrid weights after dyn subgrid updates
-    !
-    ! !USES:
-    ! !ARGUMENTS:
-    type(patch_state_updater_type), intent(inout) :: patch_state_updater
-    type(bounds_type), intent(in) :: bounds
-    !
-    ! !LOCAL VARIABLES:
-    integer :: p
-
-    !-----------------------------------------------------------------------
-    !$acc parallel loop independent gang vector default(present) 
-    do p = bounds%begp, bounds%endp
-       patch_state_updater%pwtgcell_new(p) = veg_pp%wtgcell(p)
-       patch_state_updater%dwt(p)   = patch_state_updater%pwtgcell_new(p) &
-                                    - patch_state_updater%pwtgcell_old(p)
-       if (patch_state_updater%dwt(p) > 0._r8) then
-          patch_state_updater%growing_old_fraction(p) = &
-              patch_state_updater%pwtgcell_old(p)/ patch_state_updater%pwtgcell_new(p)
-          patch_state_updater%growing_new_fraction(p) = &
-              patch_state_updater%dwt(p)/ patch_state_updater%pwtgcell_new(p)
-       else
-          ! These values are unused in this case, but set them to something reasonable for
-          ! safety. (We could set them to NaN, but that requires a more expensive
-          ! subroutine call, using the shr_infnan_mod infrastructure.)
-          patch_state_updater%growing_old_fraction(p) = 1._r8
-          patch_state_updater%growing_new_fraction(p) = 0._r8
-       end if
-    end do
-
-  end subroutine patch_set_new_weightsAcc
-
-  !-----------------------------------------------------------------------
-  subroutine column_set_new_weightsAcc(column_state_updater, bounds, clump_index)
-    !
-    ! !DESCRIPTION:
-    ! Set subgrid weights after dyn subgrid updates
-    !
-    ! !USES:
-    !$acc routine seq
-    ! !ARGUMENTS:
-    type(column_state_updater_type), intent(inout) :: column_state_updater
-    type(bounds_type), intent(in) :: bounds
-
-    ! Index of clump on which we're currently operating. Note that this implies that this
-    ! routine must be called from within a clump loop.
-    integer,   intent(in) :: clump_index
-    !
-    ! !LOCAL VARIABLES:
-    integer :: c
-    !-----------------------------------------------------------------------
-
-    column_state_updater%any_changes(clump_index) = .false.
-
-    do c = bounds%begc, bounds%endc
-       column_state_updater%cwtgcell_new(c)     = col_pp%wtgcell(c)
-       column_state_updater%area_gained_col(c)  = &
-          column_state_updater%cwtgcell_new(c) - column_state_updater%cwtgcell_old(c)
-       if (column_state_updater%area_gained_col(c) /= 0._r8) then
-          column_state_updater%any_changes(clump_index) = .true.
-       end if
-    end do
-
-  end subroutine column_set_new_weightsAcc
-
-  !-----------------------------------------------------------------------
-  subroutine set_old_patch_weightsAcc(this, bounds)
-   !
-   ! !DESCRIPTION:
-   ! Set subgrid weights before dyn subgrid updates
-   !
-   ! !USES:
-   !
-   ! !ARGUMENTS:
-   !$acc routine seq
-   type(patch_state_updater_type), intent(inout) :: this
-   type(bounds_type), intent(in) :: bounds
-   !
-   ! !LOCAL VARIABLES:
-   integer :: p
-   integer :: c
-
-   ! character(len=*), parameter :: subname = 'set_old_weights'
-   !-----------------------------------------------------------------------
-
-   do p = bounds%begp, bounds%endp
-      c = veg_pp%column(p)
-      this%pwtgcell_old(p) = veg_pp%wtgcell(p)
-      this%cwtgcell_old(c) = col_pp%wtgcell(c)
-   end do
-
- end subroutine set_old_patch_weightsAcc
-
- !-----------------------------------------------------------------------
- subroutine set_old_column_weightsAcc(this, bounds)
-   !
-   ! !DESCRIPTION:
-   ! Set subgrid weights before dyn subgrid updates
-   !
-   ! !USES:
-   ! !ARGUMENTS:
-   !$acc routine seq 
-   use landunit_varcon, only : istsoil
-
-   type(column_state_updater_type) , intent(inout) :: this
-   type(bounds_type)                , intent(in) :: bounds
-   !
-   ! !LOCAL VARIABLES:
-   logical :: found  ! whether a suitable template column has been found
-   integer :: g,l,c, c_l  ! indices of grid cell, landunit, column
-   ! character(len=*), parameter :: subname = 'set_old_weights'
-   !-----------------------------------------------------------------------
-   do c = bounds%begc, bounds%endc
-     this%cwtgcell_old(c) = col_pp%wtgcell(c)
-   end do
-
-   do c = bounds%begc, bounds%endc
-      found = .false.
-      g = col_pp%gridcell(c)
-      l = grc_pp%landunit_indices(istsoil, g)
-
-      ! If this landunit exists on this grid cell...
-      if (l /= ispval) then
-         ! Loop through columns on this landunit; stop if as soon as we find an active
-         ! column: that will serve as the template
-         c_l = lun_pp%coli(l)
-         do while (.not. found .and. c_l <= lun_pp%colf(l))
-            if (col_pp%active(c_l)) then
-               found = .true.
-            else
-               c_l = c_l + 1
-            end if
-         end do
-      end if
-
-      if (found) then
-         this%natveg_template_col(c) = c_l
-      else
-         this%natveg_template_col(c) = TEMPLATE_NONE_FOUND
-      end if
-      ! call template_col_from_natveg_array(bounds, col_pp%(bounds%begc:bounds%endc), &
-      !        this%natveg_template_col(bounds%begc:bounds%endc))
-   end do 
-
- end subroutine set_old_column_weightsAcc
-
-
-end module dynUpdateModAcc
diff --git a/components/elm/src/main/elm_driver.F90 b/components/elm/src/main/elm_driver.F90
index daaa32dbcf..d0bb71e3c7 100644
--- a/components/elm/src/main/elm_driver.F90
+++ b/components/elm/src/main/elm_driver.F90
@@ -1,2570 +1,1887 @@
 module elm_driver
-   
-   !-----------------------------------------------------------------------
-   ! !DESCRIPTION:
-   ! This module provides the main ELM driver physics calling sequence.  Most
-   ! computations occurs over ``clumps'' of gridcells (and associated subgrid
-   ! scale entities) assigned to each MPI process. Computation is further
-   ! parallelized by looping over clumps on each process using shared memory OpenMP.
-   !
-   ! !USES:
-   !!use write_filterMod, only: write_filter 
-   use shr_kind_mod           , only : r8 => shr_kind_r8
-   use shr_sys_mod            , only : shr_sys_flush
-   use shr_log_mod            , only : errMsg => shr_log_errMsg
-   use elm_varpar             , only : nlevtrc_soil, nlevsoi
-   use elm_varpar             , only : nlevsno, nlevgrnd, crop_prog
-   use elm_varctl             , only : wrtdia, iulog, create_glacier_mec_landunit, use_fates, use_betr, use_extrasnowlayers
-   use elm_varctl             , only : use_cn, use_lch4, use_voc, use_noio, use_c13, use_c14
-   use elm_varctl             , only : use_erosion
-   use clm_time_manager       , only : get_step_size, get_curr_date, get_ref_date, get_nstep, is_beg_curr_day, get_curr_time_string
-   use clm_time_manager       , only : get_curr_calday, get_days_per_year, get_prev_date
-   use spmdMod                , only : masterproc, mpicom, iam
-   use decompMod              , only : get_proc_clumps, get_clump_bounds, get_proc_bounds, bounds_type
-   use filterMod              , only : filter, filter_inactive_and_active, proc_filter
-   use filterMod              , only : setProcFilters, createProcessorFilter, proc_filter_inactive_and_active
-   use filterMod              , only : updateFracNoSnoFilters 
-   use histFileMod            , only : hist_update_hbuf, hist_htapes_wrapup
-   use restFileMod            , only : restFile_write, restFile_filename
-   use abortutils             , only : endrun
-   !
-   use dynSubgridDriverMod    , only : dynSubgrid_driver
-   use BalanceCheckMod        , only : BeginColWaterBalance, ColWaterBalanceCheck
-   use BalanceCheckMod        , only : BeginGridWaterBalance, GridBalanceCheck
-   !
-   use CanopyTemperatureMod   , only : CanopyTemperature ! (formerly Biogeophysics1Mod)
-   use SoilTemperatureMod     , only : SoilTemperature
-   use LakeTemperatureMod     , only : LakeTemperature
-   !
-   use BareGroundFluxesMod    , only : BareGroundFluxes
-   use CanopyFluxesMod        , only : CanopyFluxes
-   use SedYieldMod            , only : SoilErosion
-   use SoilFluxesMod          , only : SoilFluxes ! (formerly Biogeophysics2Mod)
-   use UrbanFluxesMod         , only : UrbanFluxes
-   use LakeFluxesMod          , only : LakeFluxes
-   !
-   use HydrologyNoDrainageMod , only : HydrologyNoDrainage ! (formerly Hydrology2Mod)
-   use HydrologyDrainageMod   , only : HydrologyDrainage   ! (formerly Hydrology2Mod)
-   use CanopyHydrologyMod     , only : CanopyHydrology     ! (formerly Hydrology1Mod)
-   use LakeHydrologyMod       , only : LakeHydrology
-   !
-   use AerosolMod             , only : AerosolMasses
-   use SnowSnicarMod          , only : SnowAge_grain
-   use SurfaceAlbedoMod       , only : SurfaceAlbedo
-   use UrbanAlbedoMod         , only : UrbanAlbedo
-   !
-   use SurfaceRadiationMod    , only : SurfaceRadiation, CanopySunShadeFractions
-   use UrbanRadiationMod      , only : UrbanRadiation
-   !
-   use SedFluxType            , only : sedflux_type
-   !clm_interface
-   !use EcosystemDynMod      , only : EcosystemDynNoLeaching1, EcosystemDynNoLeaching2
-   
-   use EcosystemDynMod      , only : EcosystemDynLeaching
-   use VegStructUpdateMod   , only : VegStructUpdate
-   use AnnualUpdateMod      , only : AnnualUpdate
-   use EcosystemBalanceCheckMod      , only : BeginColCBalance, BeginColNBalance, ColCBalanceCheck, ColNBalanceCheck
-   use EcosystemBalanceCheckMod      , only : BeginColPBalance, ColPBalanceCheck
-   use EcosystemBalanceCheckMod      , only : BeginGridCBalance,GridCBalanceCheck
-   use EcosystemBalanceCheckMod      , only : BeginGridNBalance
-   use EcosystemBalanceCheckMod      , only : BeginGridPBalance
-   use EcosystemBalanceCheckMod      , only : EndGridCBalanceAfterDynSubgridDriver
-   use EcosystemBalanceCheckMod      , only : EndGridNBalanceAfterDynSubgridDriver
-   use EcosystemBalanceCheckMod      , only : EndGridPBalanceAfterDynSubgridDriver
-   use VerticalProfileMod   , only : decomp_vertprofiles
-   use FireMod              , only : FireInterp
-   use SatellitePhenologyMod  , only : SatellitePhenology, interpMonthlyVeg
-   use ndepStreamMod          , only : ndep_interp
-   use pdepStreamMod          , only : pdep_interp
-   use ActiveLayerMod         , only : alt_calc
-   use CH4Mod                 , only : CH4
-   use DUSTMod                , only : DustDryDep, DustEmission
-   use VOCEmissionMod         , only : VOCEmission
-   
-   !
-   use filterMod              , only : setFilters
-   !
-   use atm2lndMod             , only : downscale_forcings
-   use lnd2atmMod             , only : lnd2atm
-   use lnd2glcMod             , only : lnd2glc_type
-   !
-   use seq_drydep_mod         , only : n_drydep, drydep_method, DD_XLND
-   use DryDepVelocity         , only : depvel_compute
-   !
-   use DaylengthMod           , only : UpdateDaylength, first_step
-   use perf_mod
-   !
-   use elm_instMod            , only : ch4_vars, ep_betr
-   use elm_instMod            , only : carbonstate_vars, c13_carbonstate_vars, c14_carbonstate_vars
-   use elm_instMod            , only : carbonflux_vars, c13_carbonflux_vars, c14_carbonflux_vars
-   use elm_instMod            , only : nitrogenstate_vars,   nitrogenflux_vars
-   use elm_instMod            , only : phosphorusstate_vars, phosphorusflux_vars
-   use elm_instMod            , only : crop_vars, cnstate_vars
-   use elm_instMod            , only : dust_vars, vocemis_vars
-   use elm_instMod            , only : drydepvel_vars,aerosol_vars
-   use elm_instMod            , only : canopystate_vars,energyflux_vars
-   use elm_instMod            , only : frictionvel_vars,lakestate_vars
-   use elm_instMod            , only : photosyns_vars,sedflux_vars
-   use elm_instMod            , only : soilstate_vars,soilhydrology_vars
-   use elm_instMod            , only : solarabs_vars,soilhydrology_vars
-   use elm_instMod            , only : surfalb_vars,surfrad_vars
-   use elm_instMod            , only : temperature_vars
-   use elm_instMod            , only : waterflux_vars
-   use elm_instMod            , only : waterstate_vars
-   use elm_instMod            , only : atm2lnd_vars,lnd2atm_vars
-   use elm_instMod            , only : glc2lnd_vars,lnd2glc_vars
-   use elm_instMod            , only : soil_water_retention_curve
-   use elm_instMod            , only : chemstate_vars
-   use elm_instMod            , only : alm_fates
-   use elm_instMod            , only : PlantMicKinetics_vars
-   use tracer_varcon          , only : is_active_betr_bgc
-   use CNEcosystemDynBetrMod  , only : CNEcosystemDynBetr, CNFluxStateBetrSummary
-   use UrbanParamsType        , only : urbanparams_vars
-   
-   use elm_instMod            , only : col_es ! Why is this being used via elm_instMod??
-   
-   use GridcellType           , only : grc_pp
-   use GridcellDataType       , only : grc_cs, c13_grc_cs, c14_grc_cs
-   use GridcellDataType       , only : grc_cf, c13_grc_cf, c14_grc_cf
-   use GridcellDataType       , only : grc_nf, grc_pf, grc_ef, grc_wf, grc_ws
-   use GridcellDataType       , only : grc_es, grc_ns, grc_ps
-   use TopounitDataType         , only : top_as, top_af
-   use TopounitType             , only : top_pp
-   use LandunitType           , only : lun_pp
-   use ColumnType             , only : col_pp
-   use ColumnDataType         , only : col_es, col_ef, col_ws, col_wf
-   use ColumnDataType         , only : col_cs, c13_col_cs, c14_col_cs
-   use ColumnDataType         , only : col_cf, c13_col_cf, c14_col_cf
-   use ColumnDataType         , only : col_ns, col_nf
-   use ColumnDataType         , only : col_ps, col_pf
-   use VegetationType         , only : veg_pp
-   use VegetationDataType       , only : veg_es, veg_ws, veg_wf
-   use VegetationDataType       , only : veg_cs, c13_veg_cs, c14_veg_cs
-   use VegetationDataType       , only : c13_veg_cf, c14_veg_cf
-   use VegetationDataType       , only : veg_ns, veg_nf
-   use VegetationDataType       , only : veg_ps, veg_pf
-   use VegetationDataType       , only : veg_cf, veg_ef
-   use VegetationPropertiesType , only : veg_vp
-   
-   !----------------------------------------------------------------------------
-   ! bgc interface & pflotran:
-   use elm_varctl             , only : use_elm_interface
-   use elm_instMod            , only : elm_interface_data
-   use elm_interface_funcsMod , only : get_elm_data
-   ! (1) clm_bgc through interface
-   use elm_varctl             , only : use_elm_bgc
-   use elm_interface_funcsMod , only : elm_bgc_run, update_bgc_data_elm2elm
-   ! (2) pflotran
-   use clm_time_manager            , only : nsstep, nestep
-   use elm_varctl                  , only : use_pflotran, pf_cmode, pf_hmode, pf_tmode
-   use elm_interface_funcsMod      , only : update_bgc_data_pf2elm, update_th_data_pf2elm
-   use elm_interface_pflotranMod   , only : elm_pf_run, elm_pf_write_restart
-   use elm_interface_pflotranMod   , only : elm_pf_finalize
-   !----------------------------------------------------------------------------
-   use WaterBudgetMod              , only : WaterBudget_Reset, WaterBudget_Run, WaterBudget_Accum, WaterBudget_Print
-   use WaterBudgetMod              , only : WaterBudget_SetBeginningMonthlyStates
-   use WaterBudgetMod              , only : WaterBudget_SetEndingMonthlyStates
-   use CNPBudgetMod                , only : CNPBudget_Run, CNPBudget_Accum, CNPBudget_Print, CNPBudget_Reset
-   use CNPBudgetMod                , only : CNPBudget_SetBeginningMonthlyStates, CNPBudget_SetEndingMonthlyStates
-   use elm_varctl                  , only : do_budgets, budget_inst, budget_daily, budget_month
-   use elm_varctl                  , only : budget_ann, budget_ltann, budget_ltend
-   use elm_varctl
-   use PhotosynthesisMod        , only : params_inst
-   use SharedParamsMod          , only : ParamsShareInst
-   use CH4Mod                   , only : CH4ParamsInst
-   use CNDecompCascadeConType   , only : decomp_cascade_con
-   use DecompCascadeBGCMod      , only : DecompBGCParamsInst
-   use GapMortalityMod          , only : cngapmortparamsinst
-   use DecompCascadeCNMod       , only : DecompCNParamsInst
-   use NitrifDenitrifMod        , only : NitrifDenitrifParamsInst
-   use SoilLittDecompMod        , only : cndecompparamsinst
-   use AllocationMod            , only : AllocParamsInst, nu_com_phosphatase,nu_com_nfix
-   use LandunitDataType         , only : lun_ef, lun_es, lun_ws
-   
-   use NitrogenDynamicsMod, only : CNNDynamicsParamsInst
-   use dynSubgridControlMod , only : dyn_subgrid_control_inst
-   use dynInitColumnsMod    , only : initialize_new_columns
-   use dynConsBiogeophysMod , only : dyn_hwcontent_init, dyn_hwcontent_final
-   use dynConsBiogeochemMod , only : dyn_cnbal_patch, dyn_cnbal_column
-   use reweightMod          , only : reweight_wrapup
-   use subgridWeightsMod    , only : compute_higher_order_weights, set_subgrid_diagnostic_fields
-   use subgridWeightsMod    , only : subgrid_weights_diagnostics
-   use CarbonStateUpdate1Mod   , only : CarbonStateUpdateDynPatch
-   use NitrogenStateUpdate1Mod , only : NitrogenStateUpdateDynPatch
-   use PhosphorusStateUpdate1Mod     , only : PhosphorusStateUpdateDynPatch
-   
-   use dynSubgridDriverMod    , only : dynSubgrid_driver,dynSubgrid_wrapup_weight_changes
-   use dynSubgridDriverMod    , only : prior_weights  
-   !use dynColumnStateUpdaterMod , only: column_state_updater
-   use elm_instMod , only : patch_state_updater
-   use elm_instMod , only : column_state_updater
-   use domainMod , only : ldomain_gpu
-   use histGPUMod , only : tape_gpu, htape_gpu_init, hist_update_hbuf_gpu
-   use histFileMod , only : elmptr_ra, elmptr_rs, tape
-   use update_accMod
-   use timeinfoMod
-   use ColumnDataType, only : col_cs_summary, col_ns_summary,col_ps_summary
-   use VegetationDataType, only : veg_cs_summary, veg_ns_summary, veg_ps_summary
-   use pftvarcon
-   use decompMod , only : clumps, procinfo
-   use ColumnWorkRoutinesMod 
-   use CarbonStateUpdate3Mod 
-   use ErosionMod, only : ErosionFluxes 
-   !
-   ! !PUBLIC TYPES:
-   implicit none
-   !
-   ! !PUBLIC MEMBER FUNCTIONS:
-   public :: elm_drv            ! Main elm driver
-   !
-   ! !PRIVATE MEMBER FUNCTIONS:
-   private :: elm_drv_patch2col
-   private :: elm_drv_init      ! Initialization of variables needed from previous timestep
-   private :: write_diagnostic  ! Write diagnostic information to log file
-   !-----------------------------------------------------------------------
-   
-   contains
-   
-   !-----------------------------------------------------------------------
-   subroutine elm_drv(doalb, nextsw_cday, declinp1, declin, rstwr, nlend, rdate)
-      !
-      ! !DESCRIPTION:
-      !
-      ! First phase of the elm driver calling the elm physics. An outline of
-      ! the calling tree is given in the description of this module.
-      !
-      ! !USES:
-      #if _CUDA
-      use cudafor
-      #endif
-      use shr_orb_mod_elm
-      use decompMod , only : init_proc_clump_info, gpu_clumps, gpu_procinfo
-      use decompMod , only : get_clump_bounds_gpu
-      use ColumnDataType, only : col_cf_setvalues, col_nf_SetValues, col_pf_SetValues
-      use VegetationDataType, only : veg_cf_summary_rr
-      use VegetationSummaryRoutinesMod
-      use NitrogenDynamicsMod, only : NitrogenDeposition, NitrogenFixation, NitrogenFixation_balance, NitrogenFert
-      use NitrogenDynamicsMod, only : CNSoyFix
-      use MaintenanceRespMod , only : MaintenanceResp
-      use PhosphorusDynamicsMod,only: PhosphorusWeathering,PhosphorusBiochemMin,PhosphorusBiochemMin_balance,PhosphorusDeposition
-      use DecompCascadeCNMod   , only: decomp_rate_constants_cn
-      use AllocationMod, only : Allocation1_PlantNPDemand
-      use SoilLittDecompMod, only: SoilLittDecompAlloc, SoilLittDecompAlloc2
-      use PhenologyMod, only : Phenology, CNLitterToColumn
-      use GrowthRespMod, only : GrowthResp
-      use CarbonStateUpdate1Mod, only:CarbonStateUpdate0,CarbonStateUpdate_Phase1_col, CarbonStateUpdate_Phase1_pft
-      use NitrogenStateUpdate1Mod,only:NitrogenStateUpdate_Phase1_col, NitrogenStateUpdate_Phase1_pft
-      use PhosphorusStateUpdate1Mod,only:PhosphorusStateUpdate_Phase1_col, PhosphorusStateUpdate_Phase1_pft
-      use CarbonStateUpdate1Mod , only : CarbonStateDynGridUpdate
-      use NitrogenStateUpdate1Mod , only : NitrogenStateDynGridUpdate
-      use PhosphorusStateUpdate1Mod , only : PhosphorusStateDynGridUpdate
-      use SoilLittVertTranspMod,only:SoilLittVertTransp, createLitterTransportList, transport_ptr_list 
-      use GapMortalityMod,only:GapMortality
-      use NitrogenStateUpdate3Mod   , only: NitrogenStateUpdate3
-      use PhosphorusStateUpdate3Mod , only: PhosphorusStateUpdate3
-      use CarbonStateUpdate2Mod     , only: CarbonStateUpdate2, CarbonStateUpdate2h
-      use NitrogenStateUpdate2Mod   , only: NitrogenStateUpdate2, NitrogenStateUpdate2h
-      use PhosphorusStateUpdate2Mod , only: PhosphorusStateUpdate2, PhosphorusStateUpdate2h
-      use FireMod              , only: FireArea, FireFluxes
-      use C14DecayMod          , only: C14Decay, C14BombSpike
-      use WoodProductsMod      , only: WoodProducts
-      use CropHarvestPoolsMod  , only: CropHarvestPools
-      !
-      use dynSubgridControlMod, only : get_flanduse_timeseries
-      use dynSubgridControlMod, only : get_do_transient_pfts, get_do_transient_crops
-      use dynSubgridControlMod, only : get_do_harvest
-      use dynPriorWeightsMod  , only : set_prior_weights
-      use dynUpdateModAcc 
-      use glc2lndMod  , only : glc2lnd_vars_update_glc2lnd_acc
-      use ColumnWorkRoutinesMod
-      use dynpftFileMod, only : dynpft_interp
-      use dynHarvestMod, only : dynHarvest_interp
-      use dyncropFileMod      , only : dyncrop_init, dyncrop_interp
-      !!use writeMod , only : write_vars 
-      use histFileMod, only : ntapes  
-      use dynSubgridAdjustmentsMod, only : dyn_col_cs_Adjustments,dyn_col_ns_Adjustments,dyn_col_ps_Adjustments
-      use ForcingUpdateMod , only : update_forcings_cplbypass
-      use elm_instMod , only : cpl_bypass_input   
-      use elm_varpar , only : ndecomp_pools 
-      use UrbanParamsType, only : urban_hac_int 
-
-      !
-      ! !ARGUMENTS:
-      implicit none
-      logical ,        intent(in) :: doalb       ! true if time for surface albedo calc
-      real(r8),        intent(in) :: nextsw_cday ! calendar day for nstep+1
-      real(r8),        intent(in) :: declinp1    ! declination angle for next time step
-      real(r8),        intent(in) :: declin      ! declination angle for current time step
-      logical,         intent(in) :: rstwr       ! true => write restart file this step
-      logical,         intent(in) :: nlend       ! true => end of run on this step
-      character(len=*),intent(in) :: rdate       ! restart file time stamp for name
-      !
-      ! !LOCAL VARIABLES:
-      integer            :: nstep                   ! time step number
-      real(r8)           :: dtime                   ! land model time step (sec)
-      integer            :: nc, c, p, l, g, fp, j,t ! indices
-      integer            :: nclumps                 ! number of clumps on this processor
-      integer            :: yrp1                    ! year (0, ...) for nstep+1
-      integer            :: monp1                   ! month (1, ..., 12) for nstep+1
-      integer            :: dayp1                   ! day of month (1, ..., 31) for nstep+1
-      integer            :: secp1                   ! seconds into current date for nstep+1
-      integer            :: yr                      ! year (0, ...)
-      integer            :: mon                     ! month (1, ..., 12)
-      integer            :: day                     ! day of month (1, ..., 31)
-      integer            :: sec                     ! seconds of the day
-      integer            :: ncdate                  ! current date
-      integer            :: nbdate                  ! base date (reference date)
-      integer            :: kyr                     ! thousand years, equals 2 at end of first year
-      character(len=256) :: filer                   ! restart file name
-      integer            :: ier                     ! error code
-      character(len=256) :: dateTimeString
-      type(bounds_type)  :: bounds_clump
-      type(bounds_type)  :: bounds_proc
-      integer :: fc,fl
-      integer :: num_soilc,num_nourbanl 
-      real :: startt, stopt, eco_startt, eco_stopt,outer_start, outer_stop 
-      #if _CUDA
-      integer(kind=cuda_count_kind) :: heapsize,free1,free2,total
-      integer  :: istat, val
-      #endif
-      integer :: maxcols, begg,endg, i,maxpfts,begc,begp, endc, endp 
-      integer, allocatable :: ncols(:) 
-      integer, allocatable :: npfts(:) 
-      character(len=8) :: desc
-      logical :: transfer_tapes  
-      integer :: ispin = 0
-      !-----------------------------------------------------------------------
-      call get_curr_time_string(dateTimeString)
-      !if (masterproc) then
-         write(iulog,*)'Beginning timestep   : ',trim(dateTimeString)
-         write(iulog,*) 'doalb :', doalb
-        print *, trim(dateTimeString) 
-      !endif
-      
-      call get_proc_bounds(bounds_proc)
-      nclumps = get_proc_clumps()
-      !Update time variables
-      nstep_mod = get_nstep()
-      dtime_mod = real(get_step_size(),r8)
-      call get_curr_date(year_curr,mon_curr,day_curr,secs_curr)
-      call get_prev_date(year_prev,mon_prev,day_prev,secs_prev)
-      dayspyr_mod = get_days_per_year()
-      jday_mod = get_curr_calday()
-      
-      if (do_budgets) then
-         call WaterBudget_Reset()
-         
-         if (use_cn) then
-            call CNPBudget_Reset()
-         end if
-      end if
-      ! Determine processor bounds and clumps for this processor
-      write(iulog,*) "TOTAL Gridcells/clumps:",bounds_proc%endg,nclumps
-      if(nstep_mod == 0 ) then
-        #if _CUDA
-        istat = cudaDeviceGetLimit(heapsize, cudaLimitMallocHeapSize)
-        write(iulog,*) "SETTING Heap Limit from", heapsize
-        heapsize = 2000_8*1024_8*1024_8
-        write(iulog,*) "TO:",heapsize
-        istat = cudaDeviceSetLimit(cudaLimitMallocHeapSize,heapsize)
-        istat = cudaMemGetInfo(free1, total)
-        write(iulog,*) iam,"Free1:",free1
-        #endif 
-         write(iulog,*) "transferring data to GPU"
-         call init_proc_clump_info()
-         call createLitterTransportList() 
-
-         begg = bounds_proc%begg; endg = bounds_proc%endg 
-         begc = bounds_proc%begc; endc = bounds_proc%endc 
-         begp = bounds_proc%begp; endp = bounds_proc%endp 
-         
-         allocate(ncols(begg:endg)); ncols(:) = 0 
-          do c = bounds_proc%begc, bounds_proc%endc
-              g = col_pp%gridcell(c) 
-              ncols(g) = ncols(g) + 1  
-          end do 
-          maxcols = maxval(ncols)
-          ncols(:) = 1 
-
-          allocate(grc_pp%cols(begg:endg,maxcols))  
-          do c = begc, endc 
-              g = col_pp%gridcell(c) 
-              i = ncols(g) 
-              grc_pp%cols(g,i) = c 
-              grc_pp%ncolumns(g) = i 
-              ncols(g) = ncols(g) + 1
-          end do 
-           
-          deallocate(ncols(:))  
-
-          allocate(npfts(begg:endg)); 
-          npfts(:) = 0
-          allocate(grc_pp%npfts(begg:endg)) 
-
-          do p = begp, endp
-              c = veg_pp%column(p) 
-              g = col_pp%gridcell(c) 
-              npfts(g) = npfts(g) + 1 
-              grc_pp%npfts(g) = npfts(g)  
-          end do 
-
-          maxpfts = maxval(npfts)
-          write(iulog,*) "maxpfts",maxpfts 
-          
-          npfts(:) = 1 
-          
-          allocate(grc_pp%pfts(maxpfts,begg:endg)) 
-
-          do p = begp, endp
-              c = veg_pp%column(p)  
-              g = col_pp%gridcell(c) 
-              i = npfts(g) 
-              grc_pp%pfts(i,g) = p
-              npfts(g) = npfts(g) + 1
+
+  !-----------------------------------------------------------------------
+  ! !DESCRIPTION:
+  ! This module provides the main ELM driver physics calling sequence.  Most
+  ! computations occurs over ``clumps'' of gridcells (and associated subgrid
+  ! scale entities) assigned to each MPI process. Computation is further
+  ! parallelized by looping over clumps on each process using shared memory OpenMP.
+  !
+  ! !USES:
+  use shr_kind_mod           , only : r8 => shr_kind_r8
+  use shr_sys_mod            , only : shr_sys_flush
+  use shr_log_mod            , only : errMsg => shr_log_errMsg
+  use elm_varpar             , only : nlevtrc_soil, nlevsoi
+  use elm_varctl             , only : wrtdia, iulog, create_glacier_mec_landunit, use_fates, use_betr, use_extrasnowlayers
+  use elm_varctl             , only : use_cn, use_lch4, use_voc, use_noio, use_c13, use_c14
+  use elm_varctl             , only : use_erosion, use_fates_sp
+  use clm_time_manager       , only : get_step_size, get_curr_date, get_ref_date, get_nstep, is_beg_curr_day, get_curr_time_string
+  use clm_time_manager       , only : get_curr_calday, get_days_per_year
+  use elm_varpar             , only : nlevsno, nlevgrnd, crop_prog
+  use spmdMod                , only : masterproc, mpicom
+  use decompMod              , only : get_proc_clumps, get_clump_bounds, get_proc_bounds, bounds_type
+  use filterMod              , only : filter, filter_inactive_and_active
+  use histFileMod            , only : hist_update_hbuf, hist_htapes_wrapup
+  use restFileMod            , only : restFile_write, restFile_filename
+  use abortutils             , only : endrun
+  !
+  use dynSubgridDriverMod    , only : dynSubgrid_driver
+  use BalanceCheckMod        , only : BeginColWaterBalance, ColWaterBalanceCheck
+  use BalanceCheckMod        , only : BeginGridWaterBalance, GridBalanceCheck
+  !
+  use CanopyTemperatureMod   , only : CanopyTemperature ! (formerly Biogeophysics1Mod)
+  use SoilTemperatureMod     , only : SoilTemperature
+  use LakeTemperatureMod     , only : LakeTemperature
+  !
+  use BareGroundFluxesMod    , only : BareGroundFluxes
+  use CanopyFluxesMod        , only : CanopyFluxes
+  use SedYieldMod            , only : SoilErosion
+  use SoilFluxesMod          , only : SoilFluxes ! (formerly Biogeophysics2Mod)
+  use UrbanFluxesMod         , only : UrbanFluxes
+  use LakeFluxesMod          , only : LakeFluxes
+  !
+  use HydrologyNoDrainageMod , only : HydrologyNoDrainage ! (formerly Hydrology2Mod)
+  use HydrologyDrainageMod   , only : HydrologyDrainage   ! (formerly Hydrology2Mod)
+  use CanopyHydrologyMod     , only : CanopyHydrology     ! (formerly Hydrology1Mod)
+  use LakeHydrologyMod       , only : LakeHydrology
+  !
+  use AerosolMod             , only : AerosolMasses
+  use SnowSnicarMod          , only : SnowAge_grain
+  use SurfaceAlbedoMod       , only : SurfaceAlbedo
+  use UrbanAlbedoMod         , only : UrbanAlbedo
+  !
+  use SurfaceRadiationMod    , only : SurfaceRadiation, CanopySunShadeFractions
+  use UrbanRadiationMod      , only : UrbanRadiation
+  !
+  use SedFluxType            , only : sedflux_type
+  !clm_interface
+  use EcosystemDynMod      , only : EcosystemDynNoLeaching1, EcosystemDynNoLeaching2
+
+  use EcosystemDynMod      , only : EcosystemDynLeaching
+  use VegStructUpdateMod   , only : VegStructUpdate
+  use AnnualUpdateMod      , only : AnnualUpdate
+  use EcosystemBalanceCheckMod      , only : BeginColCBalance, BeginColNBalance, ColCBalanceCheck, ColNBalanceCheck
+  use EcosystemBalanceCheckMod      , only : BeginColPBalance, ColPBalanceCheck
+  use EcosystemBalanceCheckMod      , only : BeginGridCBalance, GridCBalanceCheck
+  use EcosystemBalanceCheckMod      , only : BeginGridNBalance
+  use EcosystemBalanceCheckMod      , only : BeginGridPBalance
+  use EcosystemBalanceCheckMod      , only : EndGridCBalanceAfterDynSubgridDriver
+  use EcosystemBalanceCheckMod      , only : EndGridNBalanceAfterDynSubgridDriver
+  use EcosystemBalanceCheckMod      , only : EndGridPBalanceAfterDynSubgridDriver
+  use VerticalProfileMod   , only : decomp_vertprofiles
+  use FireMod              , only : FireInterp
+  use SatellitePhenologyMod  , only : SatellitePhenology, interpMonthlyVeg
+  use ndepStreamMod          , only : ndep_interp
+  use pdepStreamMod          , only : pdep_interp
+  use ActiveLayerMod         , only : alt_calc
+  use CH4Mod                 , only : CH4
+  use DUSTMod                , only : DustDryDep, DustEmission
+  use VOCEmissionMod         , only : VOCEmission
+
+  !
+  use filterMod              , only : setFilters
+  !
+  use atm2lndMod             , only : downscale_forcings
+  use lnd2atmMod             , only : lnd2atm
+  use lnd2glcMod             , only : lnd2glc_type
+  !
+  use seq_drydep_mod         , only : n_drydep, drydep_method, DD_XLND
+  use DryDepVelocity         , only : depvel_compute
+  !
+  use DaylengthMod           , only : UpdateDaylength
+  use perf_mod
+  !
+  use elm_instMod            , only : ch4_vars, ep_betr
+  use elm_instMod            , only : carbonstate_vars, c13_carbonstate_vars, c14_carbonstate_vars
+  use elm_instMod            , only : carbonflux_vars, c13_carbonflux_vars, c14_carbonflux_vars
+  use elm_instMod            , only : nitrogenstate_vars
+  use elm_instMod            , only : nitrogenflux_vars
+  use elm_instMod            , only : phosphorusstate_vars
+  use elm_instMod            , only : phosphorusflux_vars
+  use elm_instMod            , only : crop_vars
+  use elm_instMod            , only : cnstate_vars
+  use elm_instMod            , only : dust_vars
+  use elm_instMod            , only : vocemis_vars
+  use elm_instMod            , only : drydepvel_vars
+  use elm_instMod            , only : aerosol_vars
+  use elm_instMod            , only : canopystate_vars
+  use elm_instMod            , only : energyflux_vars
+  use elm_instMod            , only : frictionvel_vars
+  use elm_instMod            , only : lakestate_vars
+  use elm_instMod            , only : photosyns_vars
+  use elm_instMod            , only : sedflux_vars
+  use elm_instMod            , only : soilstate_vars
+  use elm_instMod            , only : soilhydrology_vars
+  use elm_instMod            , only : solarabs_vars
+  use elm_instMod            , only : soilhydrology_vars
+  use elm_instMod            , only : surfalb_vars
+  use elm_instMod            , only : surfrad_vars
+  use elm_instMod            , only : temperature_vars
+  use elm_instMod            , only : col_es
+  use elm_instMod            , only : waterflux_vars
+  use elm_instMod            , only : waterstate_vars
+  use elm_instMod            , only : atm2lnd_vars
+  use elm_instMod            , only : lnd2atm_vars
+  use elm_instMod            , only : glc2lnd_vars
+  use elm_instMod            , only : lnd2glc_vars
+  use elm_instMod            , only : soil_water_retention_curve
+  use elm_instMod            , only : chemstate_vars
+  use elm_instMod            , only : alm_fates
+  use elm_instMod            , only : PlantMicKinetics_vars
+  use tracer_varcon          , only : is_active_betr_bgc
+  use CNEcosystemDynBetrMod  , only : CNEcosystemDynBetr, CNFluxStateBetrSummary
+  use UrbanParamsType        , only : urbanparams_vars
+
+  use GridcellType           , only : grc_pp
+  use GridcellDataType       , only : grc_cs, c13_grc_cs, c14_grc_cs
+  use GridcellDataType       , only : grc_cf, c13_grc_cf, c14_grc_cf
+  use GridcellDataType       , only : grc_ns, grc_nf
+  use GridcellDataType       , only : grc_ps, grc_pf
+  use TopounitDataType       , only : top_as, top_af
+  use LandunitType           , only : lun_pp
+  use ColumnType             , only : col_pp
+  use ColumnDataType         , only : col_es, col_ef, col_ws, col_wf
+  use ColumnDataType         , only : col_cs, c13_col_cs, c14_col_cs
+  use ColumnDataType         , only : col_cf, c13_col_cf, c14_col_cf
+  use ColumnDataType         , only : col_ns, col_nf
+  use ColumnDataType         , only : col_ps, col_pf
+  use VegetationType         , only : veg_pp
+  use VegetationDataType     , only : veg_es, veg_ws, veg_wf
+  use VegetationDataType     , only : veg_cs, c13_veg_cs, c14_veg_cs
+  use VegetationDataType     , only : veg_ns, veg_nf
+  use VegetationDataType     , only : veg_ps, veg_pf
+
+  !----------------------------------------------------------------------------
+  ! bgc interface & pflotran:
+  use elm_varctl             , only : use_elm_interface
+  use elm_instMod            , only : elm_interface_data
+  use elm_interface_funcsMod , only : get_elm_data
+  ! (1) clm_bgc through interface
+  use elm_varctl             , only : use_elm_bgc
+  use elm_interface_funcsMod , only : elm_bgc_run, update_bgc_data_elm2elm
+  ! (2) pflotran
+  use clm_time_manager            , only : nsstep, nestep
+  use elm_varctl                  , only : use_pflotran, pf_cmode, pf_hmode, pf_tmode
+  use elm_interface_funcsMod      , only : update_bgc_data_pf2elm, update_th_data_pf2elm
+  use elm_interface_pflotranMod   , only : elm_pf_run, elm_pf_write_restart
+  use elm_interface_pflotranMod   , only : elm_pf_finalize
+  !----------------------------------------------------------------------------
+  use WaterBudgetMod              , only : WaterBudget_Reset, WaterBudget_Run, WaterBudget_Accum, WaterBudget_Print
+  use WaterBudgetMod              , only : WaterBudget_SetBeginningMonthlyStates
+  use WaterBudgetMod              , only : WaterBudget_SetEndingMonthlyStates
+  use CNPBudgetMod                , only : CNPBudget_Run, CNPBudget_Accum, CNPBudget_Print, CNPBudget_Reset
+  use CNPBudgetMod                , only : CNPBudget_SetBeginningMonthlyStates, CNPBudget_SetEndingMonthlyStates
+  use elm_varctl                  , only : do_budgets, budget_inst, budget_daily, budget_month
+  use elm_varctl                  , only : budget_ann, budget_ltann, budget_ltend
+
+  use timeinfoMod
+  !
+  ! !PUBLIC TYPES:
+  implicit none
+  !
+  ! !PUBLIC MEMBER FUNCTIONS:
+  public :: elm_drv            ! Main elm driver
+  !
+  ! !PRIVATE MEMBER FUNCTIONS:
+  private :: elm_drv_patch2col
+  private :: elm_drv_init      ! Initialization of variables needed from previous timestep
+  private :: write_diagnostic  ! Write diagnostic information to log file
+  !-----------------------------------------------------------------------
+
+contains
+
+  !-----------------------------------------------------------------------
+  subroutine elm_drv(doalb, nextsw_cday, declinp1, declin, rstwr, nlend, rdate)
+    !
+    ! !DESCRIPTION:
+    !
+    ! First phase of the clm driver calling the clm physics. An outline of
+    ! the calling tree is given in the description of this module.
+    !
+    ! !USES:
+    !
+    ! !ARGUMENTS:
+    implicit none
+    logical ,        intent(in) :: doalb       ! true if time for surface albedo calc
+    real(r8),        intent(in) :: nextsw_cday ! calendar day for nstep+1
+    real(r8),        intent(in) :: declinp1    ! declination angle for next time step
+    real(r8),        intent(in) :: declin      ! declination angle for current time step
+    logical,         intent(in) :: rstwr       ! true => write restart file this step
+    logical,         intent(in) :: nlend       ! true => end of run on this step
+    character(len=*),intent(in) :: rdate       ! restart file time stamp for name
+    !
+    ! !LOCAL VARIABLES:
+    integer              :: nstep                   ! time step number
+    real(r8)             :: dtime                   ! land model time step (sec)
+    integer              :: nc, c, p, l, g          ! indices
+    integer              :: nclumps                 ! number of clumps on this processor
+    integer              :: yrp1                    ! year (0, ...) for nstep+1
+    integer              :: monp1                   ! month (1, ..., 12) for nstep+1
+    integer              :: dayp1                   ! day of month (1, ..., 31) for nstep+1
+    integer              :: secp1                   ! seconds into current date for nstep+1
+    integer              :: yr                      ! year (0, ...)
+    integer              :: mon                     ! month (1, ..., 12)
+    integer              :: day                     ! day of month (1, ..., 31)
+    integer              :: sec                     ! seconds of the day
+    integer              :: ncdate                  ! current date
+    integer              :: nbdate                  ! base date (reference date)
+    integer              :: kyr                     ! thousand years, equals 2 at end of first year
+    character(len=256)   :: filer                   ! restart file name
+    integer              :: ier                     ! error code
+    character(len=256)   :: dateTimeString
+    type(bounds_type)    :: bounds_clump
+    type(bounds_type)    :: bounds_proc
+    !-----------------------------------------------------------------------
+
+    call get_curr_time_string(dateTimeString)
+    if (masterproc) then
+       write(iulog,*)'Beginning timestep   : ',trim(dateTimeString)
+       call shr_sys_flush(iulog)
+    endif
+    ! Determine processor bounds and clumps for this processor
+
+    call get_proc_bounds(bounds_proc)
+    nclumps = get_proc_clumps()
+    nstep_mod = get_nstep()
+    dtime_mod = real(get_step_size(),r8)
+    call get_curr_date(year_curr,mon_curr, day_curr,secs_curr)
+    dayspyr_mod = get_days_per_year()
+    jday_mod = get_curr_calday()
+
+    if (do_budgets) then
+       call WaterBudget_Reset()
+
+       if (use_cn) then
+          call CNPBudget_Reset()
+       end if
+    end if
+
+
+    ! ============================================================================
+    ! Specified phenology
+    ! ============================================================================
+
+    if (.not.use_fates) then
+       if (use_cn) then
+          ! For dry-deposition need to call CLMSP so that mlaidiff is obtained
+          if ( n_drydep > 0 .and. drydep_method == DD_XLND ) then
+             call t_startf('interpMonthlyVeg')
+             call interpMonthlyVeg(bounds_proc, canopystate_vars)
+             call t_stopf('interpMonthlyVeg')
+          endif
+
+       else
+          ! Determine weights for time interpolation of monthly vegetation data.
+          ! This also determines whether it is time to read new monthly vegetation and
+          ! obtain updated leaf area index [mlai1,mlai2], stem area index [msai1,msai2],
+          ! vegetation top [mhvt1,mhvt2] and vegetation bottom [mhvb1,mhvb2]. The
+          ! weights obtained here are used in subroutine SatellitePhenology to obtain time
+          ! interpolated values.
+          if (doalb .or. ( n_drydep > 0 .and. drydep_method == DD_XLND ) .or. use_fates_sp) then
+             call t_startf('interpMonthlyVeg')
+             call interpMonthlyVeg(bounds_proc, canopystate_vars)
+             call t_stopf('interpMonthlyVeg')
+          end if
+       end if
+    end if
+
+    ! ==================================================================================
+    ! Determine decomp vertical profiles
+    !
+    ! These routines (alt_calc & decomp_vertprofiles) need to be called before
+    ! pftdyn_cnbal, and it appears that they need to be called before pftdyn_interp and
+    ! the associated filter updates, too (otherwise we get a carbon balance error)
+    ! ==================================================================================
+
+    !$OMP PARALLEL DO PRIVATE (nc,bounds_clump)
+    do nc = 1,nclumps
+       call get_clump_bounds(nc, bounds_clump)
+
+       call t_startf("decomp_vert")
+       call alt_calc(filter(nc)%num_soilc, filter(nc)%soilc, &
+            temperature_vars, canopystate_vars)
+
+       !  Note (WJS, 6-12-13): Because of this routine's placement in the driver sequence
+       !  (it is called very early in each timestep, before weights are adjusted and
+       !  filters are updated), it may be necessary for this routine to compute values over
+       !  inactive as well as active points (since some inactive points may soon become
+       !  active) - so that's what is done now. Currently, it seems to be okay to do this,
+       !  because the variables computed here seem to only depend on quantities that are
+       !  valid over inactive as well as active points.
+
+       if(use_fates .or. use_cn) then
+
+          call decomp_vertprofiles(bounds_clump, &
+               filter_inactive_and_active(nc)%num_soilc, &
+               filter_inactive_and_active(nc)%soilc, &
+               filter_inactive_and_active(nc)%num_soilp, &
+               filter_inactive_and_active(nc)%soilp, &
+               soilstate_vars, canopystate_vars, cnstate_vars)
+       end if
+       call t_stopf("decomp_vert")
+    end do
+    !$OMP END PARALLEL DO
+
+    ! ============================================================================
+    ! Zero fluxes for transient land cover
+    ! ============================================================================
+
+    !$OMP PARALLEL DO PRIVATE (nc,bounds_clump)
+    do nc = 1,nclumps
+       call get_clump_bounds(nc, bounds_clump)
+
+       call t_startf('beggridwbal')
+       call BeginGridWaterBalance(bounds_clump,               &
+            filter(nc)%num_nolakec, filter(nc)%nolakec,       &
+            filter(nc)%num_lakec, filter(nc)%lakec,           &
+            filter(nc)%num_hydrologyc, filter(nc)%hydrologyc, &
+            soilhydrology_vars )
+       call t_stopf('beggridwbal')
+
+       if (use_betr) then
+         dtime=get_step_size(); nstep=get_nstep()
+         call ep_betr%SetClock(dtime= dtime, nelapstep=nstep)
+         call ep_betr%BeginMassBalanceCheck(bounds_clump)
+       endif
+
+       call t_startf('cnpinit')
+
+       if (use_cn) then
+          call t_startf('cnpvegzero')
+
+          call veg_cs%ZeroDwt(bounds_clump)
+          if (use_c13) then
+             call c13_grc_cf%ZeroDWT(bounds_clump)
+             call c13_col_cf%ZeroDWT(bounds_clump)
+          end if
+          if (use_c14) then
+             call c14_grc_cf%ZeroDWT(bounds_clump)
+             call c14_col_cf%ZeroDWT(bounds_clump)
+          end if
+          call veg_ns%ZeroDWT(bounds_clump)
+          call veg_ps%ZeroDWT(bounds_clump)
+          call t_stopf('cnpvegzero')
+       end if
+
+       if (use_cn .or. use_fates) then
+          call t_startf('cnpzero')
+          call grc_cf%ZeroDWT(bounds_clump)
+          call col_cf%ZeroDWT(bounds_clump)
+          call grc_nf%ZeroDWT(bounds_clump)
+          call col_nf%ZeroDWT(bounds_clump)
+          call grc_pf%ZeroDWT(bounds_clump)
+          call col_pf%ZeroDWT(bounds_clump)
+          call t_stopf('cnpzero')
+       end if
+
+       call t_startf('cnpvegsumm')
+       if(use_cn) then
+          call veg_cs%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               filter(nc)%num_soilp, filter(nc)%soilp, col_cs)
+          call veg_ns%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               filter(nc)%num_soilp, filter(nc)%soilp, col_ns)
+          call veg_ps%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               filter(nc)%num_soilp, filter(nc)%soilp, col_ps)
+
+       elseif(use_fates)then
+          ! In this scenario, we simply zero all of the
+          ! column level variables that would had been upscaled
+          ! in the veg summary with p2c
+          call col_cs%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
+          call col_ns%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
+          call col_ps%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
+       end if
+       call t_stopf('cnpvegsumm')
+
+       if(use_cn .or. use_fates)then
+
+          call col_cs%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc)
+
+          call col_ns%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc)
+
+          call col_ps%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc)
+
+          call BeginGridCBalance(bounds_clump, col_cs, grc_cs)
+          call BeginGridNBalance(bounds_clump, col_ns, grc_ns)
+          call BeginGridPBalance(bounds_clump, col_ps, grc_ps)
+
+       end if
+
+       call t_stopf('cnpinit')
+
+
+    end do
+    !$OMP END PARALLEL DO
+
+    ! ============================================================================
+    ! Update subgrid weights with dynamic landcover (prescribed transient patches,
+    ! and or dynamic landunits), and do related adjustments. Note that this
+    ! call needs to happen outside loops over nclumps.
+    ! ============================================================================
+
+    call t_startf('dyn_subgrid')
+    call dynSubgrid_driver(bounds_proc,                                      &
+       urbanparams_vars, soilstate_vars, soilhydrology_vars, lakestate_vars, &
+       energyflux_vars, canopystate_vars, photosyns_vars, cnstate_vars,                       &
+       veg_cs, c13_veg_cs, c14_veg_cs,         &
+       col_cs, c13_col_cs, c14_col_cs, col_cf,  &
+       grc_cs, grc_cf , glc2lnd_vars,  crop_vars)
+    call t_stopf('dyn_subgrid')
+
+    if (use_cn  .or. use_fates) then
+       nstep = get_nstep()
+
+       if (nstep < 2 )then
+          if (masterproc) then
+             write(iulog,*) '--WARNING-- skipping CN balance check for first timestep'
+          end if
+       else
+          call t_startf('cnbalchk_at_grid')
+
+          !$OMP PARALLEL DO PRIVATE (nc,bounds_clump)
+          do nc = 1,nclumps
+             call get_clump_bounds(nc, bounds_clump)
+
+             if(use_cn) then
+                call veg_cs%Summary(bounds_clump, &
+                     filter(nc)%num_soilc, filter(nc)%soilc, &
+                     filter(nc)%num_soilp, filter(nc)%soilp, col_cs)
+
+                call veg_ns%Summary(bounds_clump, &
+                     filter(nc)%num_soilc, filter(nc)%soilc, &
+                     filter(nc)%num_soilp, filter(nc)%soilp, col_ns)
+
+                call veg_ps%Summary(bounds_clump, &
+                     filter(nc)%num_soilc, filter(nc)%soilc, &
+                     filter(nc)%num_soilp, filter(nc)%soilp, col_ps)
+
+             elseif(use_fates)then
+                ! In this scenario, we simply zero all of the
+                ! column level variables that would had been upscaled
+                ! in the veg summary with p2c
+                call col_cs%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
+                call col_ns%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
+                call col_ps%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
+             end if
+
+             call col_cs%Summary(bounds_clump, &
+                  filter(nc)%num_soilc, filter(nc)%soilc)
+
+             call col_ns%Summary(bounds_clump, &
+                  filter(nc)%num_soilc, filter(nc)%soilc)
+
+             call col_ps%Summary(bounds_clump, &
+                  filter(nc)%num_soilc, filter(nc)%soilc)
+
+             call EndGridCBalanceAfterDynSubgridDriver(bounds_clump, &
+                  filter(nc)%num_soilc, filter(nc)%soilc, &
+                  col_cs, grc_cs, grc_cf)
+
+             call EndGridNBalanceAfterDynSubgridDriver(bounds_clump, &
+                  filter(nc)%num_soilc, filter(nc)%soilc, &
+                  col_ns, grc_ns, grc_nf)
+
+             call EndGridPBalanceAfterDynSubgridDriver(bounds_clump, &
+                  filter(nc)%num_soilc, filter(nc)%soilc, &
+                  col_ps, grc_ps, grc_pf)
+
           end do
+          !$OMP END PARALLEL DO
+          call t_stopf('cnbalchk_at_grid')
 
-         deallocate(npfts(:))
-         ! Summarize grc_pp additions:
-         ! columns: 
-         !$acc update device( &
-         !$acc        spinup_state            &
-         !$acc       ,nyears_ad_carbon_only   &
-         !$acc       ,spinup_mortality_factor &
-         !$acc       ,carbon_only &
-         !$acc       ,carbonphosphorus_only &
-         !$acc       ,carbonnitrogen_only &
-         !$acc       ,use_crop            &
-         !$acc       ,use_snicar_frc      &
-         !$acc       ,use_snicar_ad       &
-         !$acc       ,use_vancouver       &
-         !$acc       ,use_mexicocity      &
-         !$acc       ,use_noio            &
-         !$acc       ,use_var_soil_thick  &
-         !$acc       ,NFIX_PTASE_plant &
-         !$acc       ,tw_irr &
-         !$acc       ,use_erosion &
-         !$acc       ,ero_ccycle  &
-         !$acc       ,anoxia &
-         !$acc       , glc_do_dynglacier &
-         !$acc       , all_active &
-         !$acc       , co2_ppmv &
-         !$acc       , urban_hac_int &
-         !$acc       , const_climate_hist &
-         !$acc     )
-         !$acc update device(first_step, nlevgrnd) ! TODO!!!!!!, eccen, obliqr, lambm0, mvelpp )
-         call update_acc_variables()
-         
-         !$acc update device ( &
-         !$acc       noveg                &
-         !$acc       ,ndllf_evr_tmp_tree   &
-         !$acc       ,ndllf_evr_brl_tree   &
-         !$acc       ,ndllf_dcd_brl_tree   &
-         !$acc       ,nbrdlf_evr_trp_tree  &
-         !$acc       ,nbrdlf_evr_tmp_tree  &
-         !$acc       ,nbrdlf_dcd_trp_tree  &
-         !$acc       ,nbrdlf_dcd_tmp_tree  &
-         !$acc       ,nbrdlf_dcd_brl_tree  &
-         !$acc       ,ntree                &
-         !$acc       ,nbrdlf_evr_shrub     &
-         !$acc       ,nbrdlf_dcd_tmp_shrub &
-         !$acc       ,nbrdlf_dcd_brl_shrub &
-         !$acc       ,nc3_arctic_grass     &
-         !$acc       ,nc3_nonarctic_grass  &
-         !$acc       ,nc4_grass            &
-         !$acc       ,npcropmin            &
-         !$acc       ,ncorn                &
-         !$acc       ,ncornirrig           &
-         !$acc       ,nscereal             &
-         !$acc       ,nscerealirrig        &
-         !$acc       ,nwcereal             &
-         !$acc       ,nwcerealirrig        &
-         !$acc       ,nsoybean             &
-         !$acc       ,nsoybeanirrig        &
-         !$acc       ,npcropmax            &
-         !$acc       ,nc3crop              &
-         !$acc       ,nc3irrig             &
-         !$acc       ,nmiscanthus          &
-         !$acc       ,nmiscanthusirrig     &
-         !$acc       ,nswitchgrass         &
-         !$acc       ,nswitchgrassirrig    &
-         !$acc       ,num_cfts_known_to_model )
-         #if _CUDA 
-         istat = cudaMemGetInfo(free2, total)
-         write(iulog,*) "Transferred:", free1-free2
-         write(iulog,*) "Total:",total
-         write(iulog,*) iam,"Free:", free2/1.E+9
-         #endif
-        call createProcessorFilter(nclumps, bounds_proc, proc_filter, glc2lnd_vars%icemask_grc)
-        call createProcessorFilter(nclumps, bounds_proc, proc_filter_inactive_and_active, glc2lnd_vars%icemask_grc)
-        
-        !$acc enter data copyin(&
-      !$acc aerosol_vars     , &
-      !$acc AllocParamsInst  , &
-      !$acc atm2lnd_vars     , &
-      !$acc canopystate_vars, &
-      !$acc CH4ParamsInst     , &
-      !$acc ch4_vars          , &
-      !$acc CNDecompParamsInst     , &
-      !$acc CNGapMortParamsInst     , &
-      !$acc CNNDynamicsParamsInst     , &
-      !$acc cnstate_vars      )
-     
-      !$acc enter data copyin(&
-      !$acc photosyns_vars     , &
-      !$acc sedflux_vars     , &
-      !$acc soilhydrology_vars     , &
-      !$acc soilstate_vars     , &
-      !$acc solarabs_vars     , &
-      !$acc surfalb_vars     , &
-      !$acc surfrad_vars )   
-      
-      #if _CUDA 
-      istat = cudaMemGetInfo(free2, total)
-      write(iulog,*) iam,"Free after  moremore_vars:", free2/1.E9
-      #endif
-      !$acc enter data copyin(&
-      !$acc patch_state_updater     , &
-      !$acc column_state_updater , &
-      !$acc prior_weights ) 
-            
-      #if _CUDA 
-      istat = cudaMemGetInfo(free2, total)
-      write(iulog,*) iam,"Free 1st:", free2/1.E9
-      #endif
-      !$acc enter data copyin(&
-      !$acc col_cf     , &
-      !$acc col_cs     , &
-      !$acc col_ef     , &
-      !$acc col_es     , &
-      !$acc col_nf     , &
-      !$acc col_ns     , &
-      !$acc col_pf     , &
-      !$acc col_pp     , &
-      !$acc col_ps     , &
-      !$acc col_wf     , &
-      !$acc col_ws     ) 
-      
-      #if _CUDA 
-      istat = cudaMemGetInfo(free2, total)
-      write(iulog,*) iam,"Free after Col:", free2/1.E9
-      #endif
-      !$acc enter data copyin( &
-      !$acc crop_vars  , &
-      !$acc DecompBGCParamsInst     , &
-      !$acc DecompCNParamsInst     , &
-      !$acc decomp_cascade_con     , &
-      !$acc drydepvel_vars     , &
-      !$acc dust_vars     , &
-      !$acc energyflux_vars     , &
-      !$acc frictionvel_vars     , &
-      !$acc glc2lnd_vars  ) 
-      
-      #if _CUDA 
-      istat = cudaMemGetInfo(free2, total)
-      write(iulog,*) iam,"Free after more vars:", free2/1.E9
-      #endif
-      !$acc enter data copyin(&
-      !$acc grc_cf     , &
-      !$acc grc_cs     , &
-      !$acc grc_ef     , &
-      !$acc grc_es     , &
-      !$acc grc_nf     , &
-      !$acc grc_ns     , &
-      !$acc grc_pf     , &
-      !$acc grc_pp     , &
-      !$acc grc_ps     , &
-      !$acc grc_wf     , &
-      !$acc grc_ws     ) 
-      
-      #if _CUDA 
-      istat = cudaMemGetInfo(free2, total)
-      write(iulog,*) iam,"Free after grc_vars:", free2/1.E9
-      #endif
-      !$acc enter data copyin(&
-      !$acc lakestate_vars , &
-      !$acc ldomain_gpu  ,&
-      !$acc lnd2glc_vars   , &
-      !$acc lnd2atm_vars   , &
-      !$acc lun_ef     , &
-      !$acc lun_es     , &
-      !$acc lun_pp     , &
-      !$acc lun_ws     , &
-      !$acc NitrifDenitrifParamsInst     , &
-      !$acc ParamsShareInst     , &
-      !$acc params_inst     ) 
-      
-      #if _CUDA 
-      istat = cudaMemGetInfo(free2, total)
-      write(iulog,*) iam,"Free after lun/lnd2atm/domain/params:", free2/1.E9
-      #endif
-      !$acc enter data copyin( subgrid_weights_diagnostics, &
-      !$acc top_af     , &
-      !$acc top_as     , &
-      !$acc top_pp     , &
-      !$acc urbanparams_vars , &
-      !$acc veg_cf     , &
-      !$acc veg_cs     , &
-      !$acc veg_ef     , &
-      !$acc veg_es     , &
-      !$acc veg_nf     , &
-      !$acc veg_ns     , &
-      !$acc veg_pf     , &
-      !$acc veg_pp     , &
-      !$acc veg_ps     , &
-      !$acc veg_vp     , &
-      !$acc veg_wf     , &
-      !$acc veg_ws      &
-      !$acc   )
-      #if _CUDA 
-      istat = cudaMemGetInfo(free2, total)
-      write(iulog,*) iam,"Free after top/veg vars:", free2/1.E9
-      #endif
-      call htape_gpu_init() 
-      !$acc enter data copyin(tape_gpu(:),elmptr_ra(:),elmptr_rs(:))
-      !$acc enter data copyin( doalb, declinp1, declin )
-      !$acc enter data copyin(filter(:), gpu_clumps(:), gpu_procinfo, proc_filter,proc_filter_inactive_and_active  )
-      !$acc enter data copyin(filter_inactive_and_active(:),bounds_proc )
-      !$acc enter data copyin(transport_ptr_list(:)) 
-      #if _CUDA 
-      istat = cudaMemGetInfo(free2, total)
-      write(iulog,*) iam,"Free after final copyin:", free2/1.E9
-      #endif
-      call setProcFilters(bounds_proc, proc_filter, .false., glc2lnd_vars%icemask_grc)
-      call setProcFilters(bounds_proc, proc_filter_inactive_and_active, .true., glc2lnd_vars%icemask_grc)
-      !$acc enter data copyin(cpl_bypass_input%atm_input(:,:,:,1:5))
-      end if
-      
-      !$acc enter data copyin(nstep_mod, dtime_mod, &
-      !$acc   year_curr,mon_curr,day_curr,secs_curr,&
-      !$acc   year_prev,mon_prev,day_prev,secs_prev, dayspyr_mod,jday_mod)
-      
-     !write(iulog,*) "update_forcings cplbypass : " 
-     !call update_forcings_cplbypass(bounds_proc, atm2lnd_vars, cpl_bypass_input, &
-     !       dtime_mod, thiscalday_mod,secs_curr, year_curr, mon_curr, nstep_mod) 
-      if (do_budgets) call WaterBudget_Reset()
-      
-      ! ============================================================================
-      ! Specified phenology
-      ! ============================================================================
-      
-      if (.not.use_fates) then
-         if (use_cn) then
-            ! For dry-deposition need to call CLMSP so that mlaidiff is obtained
-            if ( n_drydep > 0 .and. drydep_method == DD_XLND ) then
-               call t_startf('interpMonthlyVeg')
-               call interpMonthlyVeg(bounds_proc, canopystate_vars)
-               call t_stopf('interpMonthlyVeg')
-            endif
-            
-         else
-            ! Determine weights for time interpolation of monthly vegetation data.
-            ! This also determines whether it is time to read new monthly vegetation and
-            ! obtain updated leaf area index [mlai1,mlai2], stem area index [msai1,msai2],
-            ! vegetation top [mhvt1,mhvt2] and vegetation bottom [mhvb1,mhvb2]. The
-            ! weights obtained here are used in subroutine SatellitePhenology to obtain time
-            ! interpolated values.
-            if (doalb .or. ( n_drydep > 0 .and. drydep_method == DD_XLND )) then
-               call t_startf('interpMonthlyVeg')
-               call interpMonthlyVeg(bounds_proc, canopystate_vars)
-               call t_stopf('interpMonthlyVeg')
-            end if
+       end if
+    end if
+
+
+    ! ============================================================================
+    ! Initialize the mass balance checks for water.
+    !
+    ! Currently, I believe this needs to be done after weights are updated for
+    ! prescribed transient patches, because column-level water is not
+    ! generally conserved when weights change (instead the difference is put in
+    ! the grid cell-level terms, qflx_liq_dynbal, etc.). In the future, we may
+    ! want to change the balance checks to ensure that the grid cell-level water
+    ! is conserved, considering qflx_liq_dynbal; in this case, the call to
+    ! BeginWaterBalance should be moved to before the weight updates.
+    !
+    ! For CNP: This needs to be done after dynSubgrid_driver, because the
+    ! changes due to dynamic area adjustments can break column-level conservation
+    ! ============================================================================
+
+    !$OMP PARALLEL DO PRIVATE (nc,bounds_clump)
+    do nc = 1,nclumps
+       call get_clump_bounds(nc, bounds_clump)
+
+       call t_startf('begwbal')
+       call BeginColWaterBalance(bounds_clump,                &
+            filter(nc)%num_nolakec, filter(nc)%nolakec,       &
+            filter(nc)%num_lakec, filter(nc)%lakec,           &
+            filter(nc)%num_hydrologyc, filter(nc)%hydrologyc, &
+            soilhydrology_vars )
+       call t_stopf('begwbal')
+
+
+       call t_startf('begcnpbal')
+       ! call veg summary before col summary, for p2c
+       if (use_cn) then
+          call veg_cs%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               filter(nc)%num_soilp, filter(nc)%soilp, col_cs)
+          call veg_ns%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               filter(nc)%num_soilp, filter(nc)%soilp, col_ns)
+          call veg_ps%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               filter(nc)%num_soilp, filter(nc)%soilp, col_ps)
+       elseif(use_fates)then
+          ! In this scenario, we simply zero all of the
+          ! column level variables that would had been upscaled
+          ! in the veg summary with p2c
+          call col_cs%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
+          call col_ns%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
+          call col_ps%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
+       end if
+       call t_stopf('begcnpbal')
+
+
+       if (use_cn  .or. use_fates) then
+          call t_startf('begcnpbalwf')
+          call col_cs%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc)
+          call col_ns%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc)
+          call col_ps%Summary(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc)
+          call BeginColCBalance(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               col_cs)
+          call BeginColNBalance(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               col_ns)
+          call BeginColPBalance(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               col_ps)
+
+          call t_stopf('begcnpbalwf')
+       end if
+
+
+       if (do_budgets) then
+          call WaterBudget_SetBeginningMonthlyStates(bounds_clump )
+          if (use_cn) then
+             call CNPBudget_SetBeginningMonthlyStates(bounds_clump, col_cs, grc_cs)
+          endif
+       endif
+
+    end do
+    !$OMP END PARALLEL DO
+
+
+
+#ifndef CPL_BYPASS
+
+    if (use_cn .or. use_fates) then
+
+       ! ============================================================================
+       ! Update dynamic N deposition field, on albedo timestep
+       ! currently being done outside clumps loop, but no reason why it couldn't be
+       ! re-written to go inside.
+       ! ============================================================================
+
+       call t_startf('ndep_interp')
+       ! PET: switching CN timestep
+       call ndep_interp(bounds_proc, atm2lnd_vars)
+       call t_stopf('ndep_interp')
+    end if
+
+
+    if (use_cn) then
+       call t_startf('fireinterp')
+       call FireInterp(bounds_proc)
+       call t_stopf('fireinterp')
+    end if
+
+    if (use_cn .or. use_fates) then
+       ! ============================================================================
+       ! Update dynamic P deposition field, on albedo timestep
+       ! currently being done outside clumps loop, but no reason why it couldn't be
+       ! re-written to go inside.
+       ! ============================================================================
+
+       call t_startf('pdep_interp')
+       ! PET: switching CN timestep
+       call pdep_interp(bounds_proc, atm2lnd_vars)
+       call t_stopf('pdep_interp')
+    end if
+
+#endif
+
+    ! ============================================================================
+    ! Initialize variables from previous time step, downscale atm forcings, and
+    ! Determine canopy interception and precipitation onto ground surface.
+    ! Determine the fraction of foliage covered by water and the fraction
+    ! of foliage that is dry and transpiring. Initialize snow layer if the
+    ! snow accumulation exceeds 10 mm.
+    ! ============================================================================
+
+    !$OMP PARALLEL DO PRIVATE (nc,l,c, bounds_clump)
+    do nc = 1,nclumps
+       call get_clump_bounds(nc, bounds_clump)
+
+       call t_startf('drvinit')
+
+       call UpdateDaylength(bounds_clump, declin)
+
+       ! Initialze variables needed for new driver time step
+       call elm_drv_init(bounds_clump, &
+            filter(nc)%num_nolakec, filter(nc)%nolakec, &
+            filter(nc)%num_nolakep, filter(nc)%nolakep, &
+            filter(nc)%num_soilp  , filter(nc)%soilp,   &
+            canopystate_vars, energyflux_vars)
+
+       call downscale_forcings(bounds_clump, &
+            filter(nc)%num_do_smb_c, filter(nc)%do_smb_c, &
+            atm2lnd_vars)
+
+       call t_stopf('drvinit')
+
+       ! ============================================================================
+       ! Canopy Hydrology
+       ! (1) water storage of intercepted precipitation
+       ! (2) direct throughfall and canopy drainage of precipitation
+       ! (3) fraction of foliage covered by water and the fraction is dry and transpiring
+       ! (4) snow layer initialization if the snow accumulation exceeds 10 mm.
+       ! ============================================================================
+
+       call t_startf('canhydro')
+       call CanopyHydrology(bounds_clump, &
+            filter(nc)%num_nolakec, filter(nc)%nolakec, &
+            filter(nc)%num_nolakep, filter(nc)%nolakep, &
+            atm2lnd_vars, canopystate_vars, &
+            aerosol_vars )
+       call t_stopf('canhydro')
+
+       ! ============================================================================
+       ! Surface Radiation
+       ! ============================================================================
+
+       call t_startf('surfrad')
+
+       ! Surface Radiation primarily for non-urban columns
+
+       ! Most of the surface radiation calculations are agnostic to the forest-model
+       ! but the calculations of the fractions of sunlit and shaded canopies
+       ! are specific, calculate them first.
+       ! The nourbanp filter is set in dySubgrid_driver (earlier in this call)
+       ! over the patch index range defined by bounds_clump%begp:bounds_proc%endp
+
+       if(use_fates) then
+          call alm_fates%wrap_sunfrac(bounds_clump, top_af, canopystate_vars)
+       else
+          call CanopySunShadeFractions(filter(nc)%num_nourbanp, filter(nc)%nourbanp,    &
+                                       atm2lnd_vars, surfalb_vars, canopystate_vars,    &
+                                       solarabs_vars)
+       end if
+
+       call SurfaceRadiation(bounds_clump,                                 &
+            filter(nc)%num_nourbanp, filter(nc)%nourbanp,                  &
+            filter(nc)%num_urbanp, filter(nc)%urbanp    ,                  &
+            filter(nc)%num_urbanc, filter(nc)%urbanc,                      &
+            atm2lnd_vars, canopystate_vars, surfalb_vars, &
+            solarabs_vars, surfrad_vars)
+
+       ! Surface Radiation for only urban columns
+
+       call UrbanRadiation(bounds_clump,                                       &
+            filter(nc)%num_nourbanl, filter(nc)%nourbanl,                      &
+            filter(nc)%num_urbanl, filter(nc)%urbanl,                          &
+            filter(nc)%num_urbanc, filter(nc)%urbanc,                          &
+            filter(nc)%num_urbanp, filter(nc)%urbanp,                          &
+            atm2lnd_vars, urbanparams_vars, &
+            solarabs_vars, surfalb_vars, energyflux_vars)
+
+       call t_stopf('surfrad')
+
+       ! ============================================================================
+       ! Determine leaf temperature and surface fluxes based on ground
+       ! temperature from previous time step.
+       ! ============================================================================
+
+       call t_startf('bgp1')
+       call CanopyTemperature(bounds_clump,                                   &
+            filter(nc)%num_nolakec, filter(nc)%nolakec,                       &
+            filter(nc)%num_nolakep, filter(nc)%nolakep,                       &
+            atm2lnd_vars, canopystate_vars, soilstate_vars, frictionvel_vars, &
+            energyflux_vars)
+       call t_stopf('bgp1')
+
+       ! ============================================================================
+       ! Determine fluxes
+       ! ============================================================================
+
+       call t_startf('bgflux')
+
+       call col_wf%Reset(bounds_clump, filter(nc)%num_nolakec , filter(nc)%nolakec)
+
+       ! Bareground fluxes for all patches except lakes and urban landunits
+
+       call BareGroundFluxes(bounds_clump,                                 &
+            filter(nc)%num_nolakeurbanp, filter(nc)%nolakeurbanp,          &
+            atm2lnd_vars, canopystate_vars, soilstate_vars,                &
+            frictionvel_vars, ch4_vars  )
+       call t_stopf('bgflux')
+
+       ! non-bareground fluxes for all patches except lakes and urban landunits
+       ! Calculate canopy temperature, latent and sensible fluxes from the canopy,
+       ! and leaf water change by evapotranspiration
+
+       call t_startf('canflux')
+       call CanopyFluxes(bounds_clump,                                                   &
+            filter(nc)%num_nolakeurbanp, filter(nc)%nolakeurbanp,                        &
+            atm2lnd_vars, canopystate_vars, cnstate_vars, energyflux_vars,               &
+            frictionvel_vars, soilstate_vars, solarabs_vars, surfalb_vars,               &
+            ch4_vars, photosyns_vars )
+       call t_stopf('canflux')
+
+       ! Fluxes for all urban landunits
+
+       call t_startf('uflux')
+       call UrbanFluxes(bounds_clump,                        &
+            filter(nc)%num_nourbanl, filter(nc)%nourbanl,    &
+            filter(nc)%num_urbanl, filter(nc)%urbanl,        &
+            filter(nc)%num_urbanc, filter(nc)%urbanc,        &
+            filter(nc)%num_urbanp, filter(nc)%urbanp,        &
+            atm2lnd_vars, urbanparams_vars, soilstate_vars,  &
+            frictionvel_vars, energyflux_vars)
+       call t_stopf('uflux')
+
+       ! Fluxes for all lake landunits
+
+       call t_startf('bgplake')
+       call LakeFluxes(bounds_clump,                                         &
+            filter(nc)%num_lakec, filter(nc)%lakec,                          &
+            filter(nc)%num_lakep, filter(nc)%lakep,                          &
+            atm2lnd_vars, solarabs_vars, frictionvel_vars,  &
+            energyflux_vars, lakestate_vars)
+
+       ! ============================================================================
+       ! DUST and VOC emissions
+       ! ============================================================================
+
+       call t_startf('bgc')
+
+       ! Dust mobilization (C. Zender's modified codes)
+       call DustEmission(bounds_clump,                      &
+            filter(nc)%num_nolakep, filter(nc)%nolakep,     &
+            atm2lnd_vars, soilstate_vars, canopystate_vars, &
+            frictionvel_vars, dust_vars)
+
+       ! Dust dry deposition (C. Zender's modified codes)
+       call DustDryDep(bounds_clump, &
+            atm2lnd_vars, frictionvel_vars, dust_vars)
+
+       ! VOC emission (A. Guenther's MEGAN (2006) model)
+       if (use_voc) then
+          call VOCEmission(bounds_clump,                                         &
+               filter(nc)%num_soilp, filter(nc)%soilp,                           &
+               atm2lnd_vars, canopystate_vars, photosyns_vars, temperature_vars, &
+               vocemis_vars)
+       end if
+
+       call t_stopf('bgc')
+
+       ! ============================================================================
+       ! Determine temperatures
+       ! ============================================================================
+       if(use_betr)then
+         call ep_betr%BeTRSetBiophysForcing(bounds_clump, col_pp, veg_pp, 1, nlevsoi, waterstate_vars=waterstate_vars)
+         call ep_betr%PreDiagSoilColWaterFlux(filter(nc)%num_nolakec , filter(nc)%nolakec)
+       endif
+       ! Set lake temperature
+
+       call LakeTemperature(bounds_clump,             &
+            filter(nc)%num_lakec, filter(nc)%lakec,   &
+            filter(nc)%num_lakep, filter(nc)%lakep,   &
+            solarabs_vars, soilstate_vars,  ch4_vars, &
+            energyflux_vars, lakestate_vars)
+       call t_stopf('bgplake')
+
+       ! Set soil/snow temperatures including ground temperature
+
+       call t_startf('soiltemperature')
+       call SoilTemperature(bounds_clump,                     &
+            filter(nc)%num_urbanl  , filter(nc)%urbanl,       &
+            filter(nc)%num_nolakec , filter(nc)%nolakec,      &
+            atm2lnd_vars, urbanparams_vars, canopystate_vars, &
+            solarabs_vars, soilstate_vars, energyflux_vars )
+       call t_stopf('soiltemperature')
+
+
+       if(use_betr)then
+         call ep_betr%BeTRSetBiophysForcing(bounds_clump, col_pp, veg_pp, 1, nlevsoi, waterstate_vars=waterstate_vars)
+         call ep_betr%DiagnoseDtracerFreezeThaw(bounds_clump, filter(nc)%num_nolakec , filter(nc)%nolakec, col_pp, lun_pp)
+       endif
+       ! ============================================================================
+       ! update surface fluxes for new ground temperature.
+       ! ============================================================================
+
+       call t_startf('bgp2')
+       call SoilFluxes(bounds_clump,                       &
+            filter(nc)%num_urbanl,  filter(nc)%urbanl,     &
+            filter(nc)%num_nolakec, filter(nc)%nolakec,    &
+            filter(nc)%num_nolakep, filter(nc)%nolakep,    &
+            atm2lnd_vars, solarabs_vars, canopystate_vars, &
+            energyflux_vars )
+       call t_stopf('bgp2')
+
+       ! ============================================================================
+       ! Perform averaging from patch level to column level
+       ! ============================================================================
+
+       call t_startf('patch2col')
+       call elm_drv_patch2col(bounds_clump, filter(nc)%num_nolakec, filter(nc)%nolakec, energyflux_vars)
+       call t_stopf('patch2col')
+
+       ! ============================================================================
+       ! Vertical (column) soil and surface hydrology
+       ! ============================================================================
+
+       ! Note that filter_snowc and filter_nosnowc are returned by
+       ! LakeHydrology after the new snow filter is built
+
+       call t_startf('hydro without drainage')
+
+       call HydrologyNoDrainage(bounds_clump,                                &
+            filter(nc)%num_nolakec, filter(nc)%nolakec,                      &
+            filter(nc)%num_hydrologyc, filter(nc)%hydrologyc,                &
+            filter(nc)%num_hydrononsoic, filter(nc)%hydrononsoic,            &
+            filter(nc)%num_urbanc, filter(nc)%urbanc,                        &
+            filter(nc)%num_snowc, filter(nc)%snowc,                          &
+            filter(nc)%num_nosnowc, filter(nc)%nosnowc,canopystate_vars,     &
+            atm2lnd_vars, soilstate_vars, energyflux_vars,  &
+            soilhydrology_vars, aerosol_vars )
+
+       !  Calculate column-integrated aerosol masses, and
+       !  mass concentrations for radiative calculations and output
+       !  (based on new snow level state, after SnowFilter is rebuilt.
+       !  NEEDS TO BE AFTER SnowFiler is rebuilt, otherwise there
+       !  can be zero snow layers but an active column in filter)
+
+       call AerosolMasses( bounds_clump,                                   &
+            num_on=filter(nc)%num_snowc, filter_on=filter(nc)%snowc,       &
+            num_off=filter(nc)%num_nosnowc, filter_off=filter(nc)%nosnowc, &
+            aerosol_vars=aerosol_vars)
+
+       call t_stopf('hydro without drainage')
+
+       ! ============================================================================
+       ! Lake hydrology
+       ! ============================================================================
+
+       ! Note that filter_lakesnowc and filter_lakenosnowc are returned by
+       ! LakeHydrology after the new snow filter is built
+
+       call t_startf('hylake')
+       call LakeHydrology(bounds_clump,                                                      &
+            filter(nc)%num_lakec, filter(nc)%lakec,                                          &
+            filter(nc)%num_lakep, filter(nc)%lakep,                                          &
+            filter(nc)%num_lakesnowc, filter(nc)%lakesnowc,                                  &
+            filter(nc)%num_lakenosnowc, filter(nc)%lakenosnowc,                              &
+            atm2lnd_vars, soilstate_vars,  &
+            energyflux_vars, aerosol_vars, lakestate_vars)
+
+       !  Calculate column-integrated aerosol masses, and
+       !  mass concentrations for radiative calculations and output
+       !  (based on new snow level state, after SnowFilter is rebuilt.
+       !  NEEDS TO BE AFTER SnowFiler is rebuilt, otherwise there
+       !  can be zero snow layers but an active column in filter)
+
+       call AerosolMasses(bounds_clump,                                            &
+            num_on=filter(nc)%num_lakesnowc, filter_on=filter(nc)%lakesnowc,       &
+            num_off=filter(nc)%num_lakenosnowc, filter_off=filter(nc)%lakenosnowc, &
+            aerosol_vars=aerosol_vars)
+
+       ! Must be done here because must use a snow filter for lake columns
+
+       call SnowAge_grain(bounds_clump,                         &
+            filter(nc)%num_lakesnowc, filter(nc)%lakesnowc,     &
+            filter(nc)%num_lakenosnowc, filter(nc)%lakenosnowc )
+
+
+       call t_stopf('hylake')
+
+       ! ============================================================================
+       ! ! Fraction of soil covered by snow (Z.-L. Yang U. Texas)
+       ! ============================================================================
+
+       do c = bounds_clump%begc,bounds_clump%endc
+          l = col_pp%landunit(c)
+          if (lun_pp%urbpoi(l)) then
+             ! Urban landunit use Bonan 1996 (LSM Technical Note)
+             col_ws%frac_sno(c) = min( col_ws%snow_depth(c)/0.05_r8, 1._r8)
+          end if
+       end do
+
+       ! ============================================================================
+       ! Snow aging routine based on Flanner and Zender (2006), Linking snowpack
+       ! microphysics and albedo evolution, JGR, and Brun (1989), Investigation of
+       ! wet-snow metamorphism in respect of liquid-water content, Ann. Glaciol.
+       ! ============================================================================
+       ! Note the snow filters here do not include lakes
+       ! TODO: move this up
+
+       call t_startf('snow_init')
+       call SnowAge_grain(bounds_clump,                 &
+            filter(nc)%num_snowc, filter(nc)%snowc,     &
+            filter(nc)%num_nosnowc, filter(nc)%nosnowc )
+       call t_stopf('snow_init')
+
+       ! ============================================================================
+       ! Update sediment fluxes from land unit
+       ! ============================================================================
+
+       if (use_erosion) then
+          call t_startf('erosion')
+          call SoilErosion(bounds_clump, filter(nc)%num_soilc, filter(nc)%soilc, &
+               atm2lnd_vars, canopystate_vars, soilstate_vars,  sedflux_vars)
+          call t_stopf('erosion')
+       end if
+
+       ! ============================================================================
+       ! Ecosystem dynamics: Uses CN, or static parameterizations
+       ! ============================================================================
+
+       call t_startf('ecosysdyn')
+       if (use_cn)then
+          call crop_vars%CropIncrementYear(filter(nc)%num_pcropp, filter(nc)%pcropp)
+       endif
+
+       if(use_betr)then
+         !right now betr bgc is intended only for non-ed mode
+
+         if(is_active_betr_bgc)then
+           !this returns the plant nutrient demand to soil bgc
+           call CNEcosystemDynBetr(bounds_clump,                                &
+                 filter(nc)%num_soilc, filter(nc)%soilc,                        &
+                 filter(nc)%num_soilp, filter(nc)%soilp,                        &
+                 filter(nc)%num_pcropp, filter(nc)%pcropp, doalb,               &
+                 cnstate_vars, carbonflux_vars, carbonstate_vars,               &
+                 c13_carbonflux_vars, c13_carbonstate_vars,                     &
+                 c14_carbonflux_vars, c14_carbonstate_vars,                     &
+                 nitrogenflux_vars, nitrogenstate_vars,                         &
+                 atm2lnd_vars, waterstate_vars, waterflux_vars,                 &
+                 canopystate_vars, soilstate_vars, temperature_vars, crop_vars, &
+                 photosyns_vars, soilhydrology_vars, energyflux_vars,&
+                 PlantMicKinetics_vars,                                         &
+                 phosphorusflux_vars, phosphorusstate_vars)
+
+           call AnnualUpdate(bounds_clump,            &
+                  filter(nc)%num_soilc, filter(nc)%soilc, &
+                  filter(nc)%num_soilp, filter(nc)%soilp, &
+                  cnstate_vars)
+         endif
+       endif
+
+       ! FIX(SPM,032414)  push these checks into the routines below and/or make this consistent.
+
+       if( .not. is_active_betr_bgc) then
+
+          if (use_cn .or. use_fates) then
+
+             ! fully prognostic canopy structure and C-N biogeochemistry
+             ! - crop model:  crop algorithms called from within CNEcosystemDyn
+
+             !===========================================================================================
+             ! clm_interface: 'EcosystemDynNoLeaching' is divided into 2 subroutines (1 & 2): BEGIN
+             ! EcosystemDynNoLeaching1 is called before clm_interface
+             ! EcosystemDynNoLeaching2 is called after clm_interface
+             !===========================================================================================
+             call EcosystemDynNoLeaching1(bounds_clump,         &
+                       filter(nc)%num_soilc, filter(nc)%soilc,  &
+                       filter(nc)%num_soilp, filter(nc)%soilp,  &
+                       cnstate_vars,            &
+                       atm2lnd_vars,            &
+                       canopystate_vars, soilstate_vars, crop_vars,   &
+                       ch4_vars, photosyns_vars )
+
+             !--------------------------------------------------------------------------------
+             if (use_elm_interface) then
+                 ! STEP-1: pass data from CLM to elm_interface_data (INTERFACE DATA TYPE)
+                 call get_elm_data(elm_interface_data,bounds_clump,                     &
+                           filter(nc)%num_soilc, filter(nc)%soilc,                      &
+                           filter(nc)%num_soilp, filter(nc)%soilp,                      &
+                           atm2lnd_vars, soilstate_vars,                                &
+                           waterstate_vars, waterflux_vars,                             &
+                           temperature_vars, energyflux_vars,                           &
+                           cnstate_vars, carbonflux_vars, carbonstate_vars,             &
+                           nitrogenflux_vars, nitrogenstate_vars,                       &
+                           phosphorusflux_vars, phosphorusstate_vars,                   &
+                           ch4_vars)
+
+
+                 if (use_pflotran .and. pf_cmode) then
+                    call t_startf('pflotran')
+                    ! -------------------------------------------------------------------------
+                    ! PFLOTRAN calling for solving below-ground and ground-surface processes,
+                    ! including thermal, hydrological and biogeochemical processes
+                    ! STEP-2: (1) pass data from elm_interface_data to pflotran
+                    ! STEP-2: (2) run pflotran
+                    ! STEP-2: (3) update elm_interface_data from pflotran
+                    ! -------------------------------------------------------------------------
+                    call elm_pf_run(elm_interface_data, bounds_clump, filter, nc)
+
+                    ! STEP-3: update CLM from elm_interface_data
+                    call update_bgc_data_pf2elm(elm_interface_data%bgc,         &
+                           bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc, &
+                           filter(nc)%num_soilp, filter(nc)%soilp,              &
+                           cnstate_vars, carbonflux_vars, carbonstate_vars,     &
+                           nitrogenflux_vars, nitrogenstate_vars,               &
+                           phosphorusflux_vars, phosphorusstate_vars,           &
+                           ch4_vars)
+
+                    call t_stopf('pflotran')
+
+                 elseif (use_elm_bgc) then
+                    call t_startf('elm-bgc via interface')
+                    ! -------------------------------------------------------------------------
+                    ! run elm-bgc (SoilLittDecompAlloc) through interface
+                    ! STEP-2: (1) pass data from elm_interface_data to SoilLittDecompAlloc
+                    ! STEP-2: (2) run SoilLittDecompAlloc
+                    ! STEP-2: (3) update elm_interface_data from SoilLittDecompAlloc
+                    ! -------------------------------------------------------------------------
+                    call elm_bgc_run(elm_interface_data, bounds_clump,          &
+                           filter(nc)%num_soilc, filter(nc)%soilc,              &
+                           filter(nc)%num_soilp, filter(nc)%soilp,              &
+                           canopystate_vars, soilstate_vars,                    &
+                           temperature_vars, waterstate_vars,                   &
+                           cnstate_vars, ch4_vars,                              &
+                           carbonstate_vars, carbonflux_vars,                   &
+                           nitrogenstate_vars, nitrogenflux_vars,               &
+                           phosphorusstate_vars,phosphorusflux_vars)
+
+                    ! STEP-3: update CLM from elm_interface_data
+                    call update_bgc_data_elm2elm(elm_interface_data%bgc,        &
+                           bounds_clump, filter(nc)%num_soilc, filter(nc)%soilc,&
+                           filter(nc)%num_soilp, filter(nc)%soilp,              &
+                           cnstate_vars, carbonflux_vars, carbonstate_vars,     &
+                           nitrogenflux_vars, nitrogenstate_vars,               &
+                           phosphorusflux_vars, phosphorusstate_vars,           &
+                           ch4_vars)
+                    call t_stopf('elm-bgc via interface')
+                 end if !if (use_pflotran .and. pf_cmode)
+             end if !if (use_elm_interface)
+             !--------------------------------------------------------------------------------
+
+             call EcosystemDynNoLeaching2(bounds_clump,                &
+                   filter(nc)%num_soilc, filter(nc)%soilc,             &
+                   filter(nc)%num_soilp, filter(nc)%soilp,             &
+                   filter(nc)%num_pcropp, filter(nc)%pcropp, doalb,    &
+                   filter(nc)%num_ppercropp, filter(nc)%ppercropp,     &
+                   cnstate_vars,  atm2lnd_vars,          &
+                   canopystate_vars, soilstate_vars, crop_vars, ch4_vars, &
+                   photosyns_vars, soilhydrology_vars, energyflux_vars,   &
+                   sedflux_vars)
+
+             !===========================================================================================
+             ! clm_interface: 'EcosystemDynNoLeaching' is divided into 2 subroutines (1 & 2): END
+             !===========================================================================================
+             if(.not.use_fates)then
+               call AnnualUpdate(bounds_clump,            &
+                    filter(nc)%num_soilc, filter(nc)%soilc, &
+                    filter(nc)%num_soilp, filter(nc)%soilp, &
+                    cnstate_vars)
+             end if
+          else ! not use_cn
+
+             if (.not.use_fates_sp .and. doalb) then
+                ! Prescribed biogeography - prescribed canopy structure, some prognostic carbon fluxes
+                call SatellitePhenology(bounds_clump,               &
+                     filter(nc)%num_nolakep, filter(nc)%nolakep,    &
+                     waterstate_vars, canopystate_vars)
+             end if
+
+             if (use_fates_sp .and. doalb) then
+               call SatellitePhenology(bounds_clump,               &
+               filter_inactive_and_active(nc)%num_soilp, filter_inactive_and_active(nc)%soilp,    &
+               waterstate_vars, canopystate_vars)
+             endif
+
+          end if  ! end of if-use_cn   or if-use_fates
+       end if ! end of is_active_betr_bgc
+
+       call t_stopf('ecosysdyn')
+
+       ! Dry Deposition of chemical tracers (Wesely (1998) parameterizaion)
+       call t_startf('depvel')
+       if(.not.use_fates)then
+         call depvel_compute(bounds_clump, &
+              atm2lnd_vars, canopystate_vars, frictionvel_vars, &
+              photosyns_vars, drydepvel_vars)
+       end if
+       call t_stopf('depvel')
+
+       if (use_betr)then
+          call ep_betr%CalcSmpL(bounds_clump, 1, nlevsoi, filter(nc)%num_soilc, filter(nc)%soilc, &
+               col_es%t_soisno(bounds_clump%begc:bounds_clump%endc,1:nlevsoi), &
+               soilstate_vars, waterstate_vars, soil_water_retention_curve)
+
+          call ep_betr%SetBiophysForcing(bounds_clump, col_pp, veg_pp,                         &
+               carbonflux_vars=carbonflux_vars,                                                &
+               waterstate_vars=waterstate_vars,         waterflux_vars=waterflux_vars,         &
+               temperature_vars=temperature_vars,       soilhydrology_vars=soilhydrology_vars, &
+               atm2lnd_vars=atm2lnd_vars,               canopystate_vars=canopystate_vars,     &
+               chemstate_vars=chemstate_vars,           soilstate_vars=soilstate_vars, &
+               cnstate_vars = cnstate_vars, carbonstate_vars=carbonstate_vars)
+
+          if(is_active_betr_bgc)then
+             call ep_betr%PlantSoilBGCSend(bounds_clump, col_pp, veg_pp, &
+                  filter(nc)%num_soilc,  filter(nc)%soilc, cnstate_vars, &
+                  carbonflux_vars, c13_carbonflux_vars, c14_carbonflux_vars, nitrogenflux_vars, phosphorusflux_vars,&
+                  PlantMicKinetics_vars)
+          endif
+          call ep_betr%StepWithoutDrainage(bounds_clump, col_pp, veg_pp)
+       endif  !end use_betr
+
+       if (use_lch4 .and. .not. is_active_betr_bgc) then
+          !warning: do not call ch4 before AnnualUpdate, which will fail the ch4 model
+          call t_startf('ch4')
+          call CH4 (bounds_clump,                                                                  &
+               filter(nc)%num_soilc, filter(nc)%soilc,                                             &
+               filter(nc)%num_lakec, filter(nc)%lakec,                                             &
+               filter(nc)%num_soilp, filter(nc)%soilp,                                             &
+               atm2lnd_vars, lakestate_vars, canopystate_vars, soilstate_vars, soilhydrology_vars, &
+               energyflux_vars, ch4_vars, lnd2atm_vars, alm_fates)
+          call t_stopf('ch4')
+       end if
+
+       ! Dry Deposition of chemical tracers (Wesely (1998) parameterizaion)
+       call t_startf('depvel')
+       if(.not.use_fates)then
+         call depvel_compute(bounds_clump, &
+              atm2lnd_vars, canopystate_vars, frictionvel_vars, &
+              photosyns_vars, drydepvel_vars)
+       end if
+       call t_stopf('depvel')
+       ! ============================================================================
+       ! Calculate soil/snow hydrology with drainage (subsurface runoff)
+       ! ============================================================================
+
+       call t_startf('hydro2 drainage')
+
+       if (use_elm_interface .and. (use_pflotran .and. pf_hmode)) then
+         ! pflotran only works on 'soilc' (already done above).
+         ! here for non-soil hydrology columns
+         call HydrologyDrainage(bounds_clump,                     &
+            filter(nc)%num_nolakec, filter(nc)%nolakec,           &
+            filter(nc)%num_hydrononsoic, filter(nc)%hydrononsoic, &
+            filter(nc)%num_urbanc, filter(nc)%urbanc,             &
+            filter(nc)%num_do_smb_c, filter(nc)%do_smb_c,         &
+            atm2lnd_vars, glc2lnd_vars,        &
+            soilhydrology_vars, soilstate_vars)
+
+       else
+
+         call HydrologyDrainage(bounds_clump,                 &
+            filter(nc)%num_nolakec, filter(nc)%nolakec,       &
+            filter(nc)%num_hydrologyc, filter(nc)%hydrologyc, &
+            filter(nc)%num_urbanc, filter(nc)%urbanc,         &
+            filter(nc)%num_do_smb_c, filter(nc)%do_smb_c,     &
+            atm2lnd_vars, glc2lnd_vars,      &
+            soilhydrology_vars, soilstate_vars)
+
+       end if
+
+       call t_stopf('hydro2 drainage')
+
+       if (use_betr) then
+          call t_startf('betr drainage')
+          call ep_betr%StepWithDrainage(bounds_clump, col_pp)
+          call t_stopf('betr drainage')
+
+          call t_startf('betr balchk')
+          call ep_betr%MassBalanceCheck(bounds_clump)
+          call t_stopf('betr balchk')
+          call ep_betr%HistRetrieval(bounds_clump, filter(nc)%num_nolakec, filter(nc)%nolakec)
+
+          if(is_active_betr_bgc)then
+
+            !extract nitrogen pool and flux from betr
+            call ep_betr%PlantSoilBGCRecv(bounds_clump, col_pp, veg_pp, filter(nc)%num_soilc, filter(nc)%soilc,&
+               carbonstate_vars, carbonflux_vars, c13_carbonstate_vars, c13_carbonflux_vars, &
+               c14_carbonstate_vars, c14_carbonflux_vars, &
+               nitrogenstate_vars, nitrogenflux_vars, phosphorusstate_vars, phosphorusflux_vars)
+            !summarize total column nitrogen and carbon
+            call CNFluxStateBetrSummary(bounds_clump, col_pp, veg_pp, &
+                 filter(nc)%num_soilc, filter(nc)%soilc,                       &
+                 filter(nc)%num_soilp, filter(nc)%soilp,                       &
+                 carbonflux_vars, carbonstate_vars,                            &
+                 c13_carbonflux_vars, c13_carbonstate_vars,                    &
+                 c14_carbonflux_vars, c14_carbonstate_vars,                    &
+                 nitrogenflux_vars, nitrogenstate_vars,                        &
+                 phosphorusflux_vars, phosphorusstate_vars)
+          endif
+       endif  !end use_betr
+
+
+       if (use_cn .or. use_fates) then
+          if (.not. is_active_betr_bgc)then
+            call EcosystemDynLeaching(bounds_clump,                &
+               filter(nc)%num_soilc, filter(nc)%soilc,             &
+               filter(nc)%num_soilp, filter(nc)%soilp,             &
+               filter(nc)%num_pcropp, filter(nc)%pcropp, doalb,    &
+               cnstate_vars,  frictionvel_vars, canopystate_vars )
          end if
+       end if
+
+       ! ============================================================================
+       ! Update Vegetation
+       ! ============================================================================
+
+       ! Execute FATES dynamics
+       if ( use_fates ) then
+           ! Update high-frequency history diagnostics for FATES
+           call alm_fates%wrap_update_hifrq_hist(bounds_clump)
+           if ( is_beg_curr_day() ) then ! run ED at the start of each day
+               call alm_fates%dynamics_driv( bounds_clump, top_as,          &
+                    top_af, atm2lnd_vars, soilstate_vars, temperature_vars, &
+                    canopystate_vars, frictionvel_vars)
+           end if
+       end if
+
+       if (use_cn .and. doalb) then
+           call VegStructUpdate(filter(nc)%num_soilp, filter(nc)%soilp,   &
+                frictionvel_vars, cnstate_vars, &
+                canopystate_vars, crop_vars)
+       end if
+
+
+       ! ============================================================================
+       ! Check the energy and water balance, also carbon and nitrogen balance
+       ! ============================================================================
+
+       call t_startf('balchk')
+       call ColWaterBalanceCheck(bounds_clump, &
+            filter(nc)%num_do_smb_c, filter(nc)%do_smb_c, &
+            atm2lnd_vars, glc2lnd_vars, solarabs_vars,  &
+            energyflux_vars, canopystate_vars)
+       call t_stopf('balchk')
+
+       call t_startf('gridbalchk')
+       call GridBalanceCheck(bounds_clump                  , &
+            filter(nc)%num_do_smb_c, filter(nc)%do_smb_c   , &
+            atm2lnd_vars, glc2lnd_vars, solarabs_vars,       &
+            energyflux_vars, canopystate_vars              , &
+            soilhydrology_vars)
+       call t_stopf('gridbalchk')
+
+       if (do_budgets) then
+          call WaterBudget_SetEndingMonthlyStates(bounds_clump)
+          if (use_cn) then
+             call CNPBudget_SetEndingMonthlyStates(bounds_clump, col_cs, grc_cs)
+          endif
+       endif
+
+       if (use_cn .or. use_fates) then
+
+          call t_startf('cnbalchk')
+
+          call ColCBalanceCheck(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               col_cs, col_cf)
+
+          call ColNBalanceCheck(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               col_ns, col_nf)
+
+          call ColPBalanceCheck(bounds_clump, &
+               filter(nc)%num_soilc, filter(nc)%soilc, &
+               col_ps, col_pf)
+
+          call GridCBalanceCheck(bounds_clump, col_cs, col_cf, grc_cs, grc_cf)
+
+          call t_stopf('cnbalchk')
+       end if
+
+
+       ! ============================================================================
+       ! Determine albedos for next time step
+       ! ============================================================================
+
+       if (doalb) then
+
+          ! Albedos for non-urban columns
+          call t_startf('surfalb')
+          call SurfaceAlbedo(bounds_clump,                      &
+               filter_inactive_and_active(nc)%num_nourbanc,     &
+               filter_inactive_and_active(nc)%nourbanc,         &
+               filter_inactive_and_active(nc)%num_nourbanp,     &
+               filter_inactive_and_active(nc)%nourbanp,         &
+               filter_inactive_and_active(nc)%num_urbanc,       &
+               filter_inactive_and_active(nc)%urbanc,           &
+               filter_inactive_and_active(nc)%num_urbanp,       &
+               filter_inactive_and_active(nc)%urbanp,           &
+               nextsw_cday, declinp1,                           &
+               aerosol_vars, canopystate_vars, &
+               lakestate_vars, surfalb_vars )
+          call t_stopf('surfalb')
+
+          ! Albedos for urban columns
+          if (filter_inactive_and_active(nc)%num_urbanl > 0) then
+             call t_startf('urbsurfalb')
+             call UrbanAlbedo(bounds_clump,                  &
+                  filter_inactive_and_active(nc)%num_urbanl, &
+                  filter_inactive_and_active(nc)%urbanl,     &
+                  filter_inactive_and_active(nc)%num_urbanc, &
+                  filter_inactive_and_active(nc)%urbanc,     &
+                  filter_inactive_and_active(nc)%num_urbanp, &
+                  filter_inactive_and_active(nc)%urbanp,     &
+                  urbanparams_vars, solarabs_vars, surfalb_vars)
+             call t_stopf('urbsurfalb')
+          end if
+
+       end if
+
+    end do
+    !$OMP END PARALLEL DO
+
+    ! ============================================================================
+    ! Determine gridcell averaged properties to send to atm
+    ! ============================================================================
+
+    if(use_betr)then
+      call ep_betr%DiagnoseLnd2atm(bounds_proc, col_pp, lnd2atm_vars)
+    endif
+
+    call t_startf('lnd2atm')
+    call lnd2atm(bounds_proc,       &
+         atm2lnd_vars, surfalb_vars, frictionvel_vars,    &
+         energyflux_vars, solarabs_vars, drydepvel_vars,  &
+         vocemis_vars, dust_vars, ch4_vars, soilhydrology_vars, lnd2atm_vars)
+    call t_stopf('lnd2atm')
+
+    ! ============================================================================
+    ! Determine gridcell averaged properties to send to glc
+    ! ============================================================================
+
+    if (create_glacier_mec_landunit) then
+       call t_startf('lnd2glc')
+       !$OMP PARALLEL DO PRIVATE (nc, bounds_clump)
+       do nc = 1,nclumps
+          call get_clump_bounds(nc, bounds_clump)
+          call lnd2glc_vars%update_lnd2glc(bounds_clump,       &
+               filter(nc)%num_do_smb_c, filter(nc)%do_smb_c,   &
+               init=.false.)
+       end do
+       !$OMP END PARALLEL DO
+       call t_stopf('lnd2glc')
+    end if
+
+    ! ============================================================================
+    ! Write global average diagnostics to standard output
+    ! ============================================================================
+
+    nstep = get_nstep()
+    if (wrtdia) call mpi_barrier(mpicom,ier)
+    call t_startf('wrtdiag')
+    call write_diagnostic(bounds_proc, wrtdia, nstep, lnd2atm_vars)
+    call t_stopf('wrtdiag')
+
+    ! ============================================================================
+    ! Update accumulators
+    ! ============================================================================
+
+    ! FIX(SPM,032414) double check why this isn't called for ED
+
+    if (nstep > 0) then
+
+       call t_startf('accum')
+
+       call atm2lnd_vars%UpdateAccVars(bounds_proc)
+
+       call top_as%UpdateAccVars(bounds_proc)
+
+       call top_af%UpdateAccVars(bounds_proc)
+
+       call veg_es%UpdateAccVars(bounds_proc)
+
+       call canopystate_vars%UpdateAccVars(bounds_proc)
+
+       if (crop_prog) then
+          call crop_vars%UpdateAccVars(bounds_proc, temperature_vars)
+       end if
+
+       call cnstate_vars%UpdateAccVars(bounds_proc)
+
+       call t_stopf('accum')
+
+    end if
+
+    ! ============================================================================
+    ! Update history buffer
+    ! ============================================================================
+
+    call t_startf('hbuf')
+    call hist_update_hbuf(bounds_proc)
+    call t_stopf('hbuf')
+
+    ! ============================================================================
+    ! Compute water budget
+    ! ============================================================================
+    if (get_nstep()>0 .and. do_budgets) then
+       call WaterBudget_Run(bounds_proc, atm2lnd_vars, lnd2atm_vars, &
+            soilhydrology_vars)
+       call WaterBudget_Accum()
+       call WaterBudget_Print(budget_inst,  budget_daily,  budget_month,  &
+            budget_ann,  budget_ltann,  budget_ltend)
+
+       if (use_cn .and. do_budgets) then
+          call CNPBudget_Run(bounds_proc, atm2lnd_vars, lnd2atm_vars, grc_cs, grc_cf)
+          call CNPBudget_Accum()
+          call CNPBudget_Print(budget_inst,  budget_daily,  budget_month,  &
+               budget_ann,  budget_ltann,  budget_ltend)
       end if
-      
-      ! ==================================================================================
-      ! Determine decomp vertical profiles
-      !
-      ! These routines (alt_calc & decomp_vertprofiles) need to be called before
-      ! pftdyn_cnbal, and it appears that they need to be called before pftdyn_interp and
-      ! the associated filter updates, too (otherwise we get a carbon balance error)
-      ! ==================================================================================
-     !$acc parallel loop independent gang vector default(present) 
-     do nc = 1,nclumps
-        call alt_calc(filter(nc)%num_soilc, filter(nc)%soilc,canopystate_vars)
-     end do
-      
-      !  Note (WJS, 6-12-13): Because of this routine's placement in the driver sequence
-      !  (it is called very early in each timestep, before weights are adjusted and
-      !  filters are updated), it may be necessary for this routine to compute values over
-      !  inactive as well as active points (since some inactive points may soon become
-      !  active) - so that's what is done now. Currently, it seems to be okay to do this,
-      !  because the variables computed here seem to only depend on quantities that are
-      !  valid over inactive as well as active points.
-      if(use_fates .or. use_cn) then 
-         call cpu_time(startt)
-         call decomp_vertprofiles(bounds_proc,      &
-            proc_filter_inactive_and_active%num_soilc, proc_filter_inactive_and_active%soilc, &
-            proc_filter_inactive_and_active%num_soilp, proc_filter_inactive_and_active%soilp, &
-            soilstate_vars, canopystate_vars, cnstate_vars)
-         call cpu_time(stopt)
-         write(iulog,*) iam, "TIMING vert_profiles",(stopt-startt)*1.E+3,"ms"
-      end if
-      ! ============================================================================
-      ! Zero fluxes for transient land cover
-      ! ============================================================================
-      call t_startf('cnpinit')
-      call cpu_time(startt) 
-         
-      call t_startf('beggridwbal')
-      call BeginGridWaterBalance(bounds_proc,               &
-         proc_filter%num_nolakec, proc_filter%nolakec,       &
-         proc_filter%num_lakec, proc_filter%lakec,           &
-         proc_filter%num_hydrologyc, proc_filter%hydrologyc, &
-         soilhydrology_vars )
-      call t_stopf('beggridwbal')
-         
-      do nc = 1,nclumps
-         call get_clump_bounds_gpu(nc, bounds_clump)
-         if (use_betr) then
-            dtime=get_step_size(); nstep=get_nstep()
-            call ep_betr%SetClock(dtime= dtime, nelapstep=nstep)
-            call ep_betr%BeginMassBalanceCheck(bounds_clump)
-         endif
+    endif
+
+    ! ============================================================================
+    ! History/Restart output
+    ! ============================================================================
+
+    if (.not. use_noio) then
+
+       call t_startf('elm_drv_io')
+
+       ! Create history and write history tapes if appropriate
+       call t_startf('elm_drv_io_htapes')
+
+       call hist_htapes_wrapup( rstwr, nlend, bounds_proc,                    &
+            soilstate_vars%watsat_col(bounds_proc%begc:bounds_proc%endc, 1:), &
+            soilstate_vars%sucsat_col(bounds_proc%begc:bounds_proc%endc, 1:), &
+            soilstate_vars%bsw_col(bounds_proc%begc:bounds_proc%endc, 1:),    &
+            soilstate_vars%hksat_col(bounds_proc%begc:bounds_proc%endc, 1:))
+
+       call t_stopf('elm_drv_io_htapes')
+       ! Write restart/initial files if appropriate
+       if (rstwr) then
+          call t_startf('elm_drv_io_wrest')
+          filer = restFile_filename(rdate=rdate)
+
+          call restFile_write( bounds_proc, filer,                                            &
+               atm2lnd_vars, aerosol_vars, canopystate_vars, cnstate_vars,                    &
+               carbonstate_vars, c13_carbonstate_vars, c14_carbonstate_vars, carbonflux_vars, &
+               ch4_vars, energyflux_vars, frictionvel_vars, lakestate_vars,        &
+               nitrogenstate_vars, nitrogenflux_vars, photosyns_vars, soilhydrology_vars,     &
+               soilstate_vars, solarabs_vars, surfalb_vars, temperature_vars,                 &
+               waterflux_vars, waterstate_vars, sedflux_vars,                                 &
+               phosphorusstate_vars,phosphorusflux_vars,                                      &
+               ep_betr, alm_fates, crop_vars, rdate=rdate )
+
+         !----------------------------------------------
+         ! pflotran (off now)
+         ! if (use_pflotran) then
+         !     call elm_pf_write_restart(rdate)
+         ! end if
+         !----------------------------------------------
+
+
+          call t_stopf('elm_drv_io_wrest')
+       end if
+       call t_stopf('elm_drv_io')
+
+    end if
+
+    if (use_pflotran .and. nstep>=nestep) then
+       call elm_pf_finalize()
+    end if
+
+  end subroutine elm_drv
+
+  !-----------------------------------------------------------------------
+  subroutine elm_drv_init(bounds, &
+       num_nolakec, filter_nolakec, &
+       num_nolakep, filter_nolakep, &
+       num_soilp  , filter_soilp, &
+       canopystate_vars,  energyflux_vars)
+    !
+    ! !DESCRIPTION:
+    ! Initialization of clm driver variables needed from previous timestep
+    !
+    ! !USES:
+    use shr_kind_mod       , only : r8 => shr_kind_r8
+    use elm_varpar         , only : nlevsno
+    use elm_varcon         , only : h2osno_max
+    use landunit_varcon    , only : istice_mec
+    use CanopyStateType    , only : canopystate_type
+    use EnergyFluxType     , only : energyflux_type
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)     , intent(in)    :: bounds
+    integer               , intent(in)    :: num_nolakec       ! number of non-lake points in column filter
+    integer               , intent(in)    :: filter_nolakec(:) ! column filter for non-lake points
+    integer               , intent(in)    :: num_nolakep       ! number of non-lake points in patch filter
+    integer               , intent(in)    :: filter_nolakep(:) ! patch filter for non-lake points
+    integer               , intent(in)    :: num_soilp         ! number of soil points in patch filter
+    integer               , intent(in)    :: filter_soilp(:)   ! patch filter for soil points
+    type(canopystate_type), intent(inout) :: canopystate_vars
+    type(energyflux_type) , intent(inout) :: energyflux_vars
+    !
+    ! !LOCAL VARIABLES:
+    integer :: l, c, p, f, j         ! indices
+    integer :: fp, fc                  ! filter indices
+    !-----------------------------------------------------------------------
+
+    associate(                                                             &
+         snl                => col_pp%snl                                   , & ! Input:  [integer  (:)   ]  number of snow layers
+
+         h2osno             => col_ws%h2osno                , & ! Input:  [real(r8) (:)   ]  snow water (mm H2O)
+         h2osoi_ice         => col_ws%h2osoi_ice            , & ! Input:  [real(r8) (:,:) ]  ice lens (kg/m2)
+         h2osoi_liq         => col_ws%h2osoi_liq            , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2)
+         do_capsnow         => col_ws%do_capsnow            , & ! Output: [logical  (:)   ]  true => do snow capping
+         h2osno_old         => col_ws%h2osno_old            , & ! Output: [real(r8) (:)   ]  snow water (mm H2O) at previous time step
+         frac_iceold        => col_ws%frac_iceold           , & ! Output: [real(r8) (:,:) ]  fraction of ice relative to the tot water
+
+         elai               => canopystate_vars%elai_patch               , & ! Input:  [real(r8) (:)   ]  one-sided leaf area index with burying by snow
+         esai               => canopystate_vars%esai_patch               , & ! Input:  [real(r8) (:)   ]  one-sided stem area index with burying by snow
+         frac_veg_nosno     => canopystate_vars%frac_veg_nosno_patch     , & ! Output: [integer  (:)   ]  fraction of vegetation not covered by snow (0 OR 1) [-]
+         frac_veg_nosno_alb => canopystate_vars%frac_veg_nosno_alb_patch , & ! Output: [integer  (:)   ]  fraction of vegetation not covered by snow (0 OR 1) [-]
+
+         qflx_glcice        => col_wf%qflx_glcice            , & ! Output: [real(r8) (:)   ]  flux of new glacier ice (mm H2O/s) [+ = ice grows]
+
+         eflx_bot           => col_ef%eflx_bot              , & ! Output: [real(r8) (:)   ]  heat flux from beneath soil/ice column (W/m**2)
+
+         cisun_z            => photosyns_vars%cisun_z_patch              , & ! Output: [real(r8) (:)   ]  intracellular sunlit leaf CO2 (Pa)
+         cisha_z            => photosyns_vars%cisha_z_patch                & ! Output: [real(r8) (:)   ]  intracellular shaded leaf CO2 (Pa)
+         )
+
+      ! Initialize intracellular CO2 (Pa) parameters each timestep for use in VOCEmission
+      do p = bounds%begp,bounds%endp
+         cisun_z(p,:) = -999._r8
+         cisha_z(p,:) = -999._r8
       end do
-      
-     call cpu_time(stopt) 
-     write(iulog,*) "TIMING BeginGridWaterBalance :: ",(stopt-startt)*1.E+3,"ms"
-
-     call cpu_time(startt)
-
-      if(use_cn) then
-         call t_startf('cnpvegzero')
-         call zero_elm_weights(bounds_proc)
-         call t_stopf('cnpvegzero')
-      end if 
-      
-      call t_startf('cnpvegsumm')
-      if(use_cn) then
-        call veg_cs_Summary_acc(veg_cs,proc_filter%num_soilp, proc_filter%soilp)
-        call veg_ns_Summary_acc(veg_ns,proc_filter%num_soilp, proc_filter%soilp)
-        call veg_ps_Summary_acc(veg_ps,proc_filter%num_soilp, proc_filter%soilp)
-         
-         call summary_veg_state_p2c ( proc_filter%num_soilc, proc_filter%soilc, &
-         veg_cs, col_cs, veg_ps,col_ps, veg_ns, col_ns)
-         
-         ! elseif(use_fates)then
-         !      ! In this scenario, we simply zero all of the
-         !      ! column level variables that would had been upscaled
-         !      ! in the veg summary with p2c
-         !      call col_cs%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
-         !      call col_ns%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
-         !      call col_ps%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
-      end if
-      call cpu_time(stopt) 
-      write(iulog,*) iam,"TIMING cnpvegsum ",(stopt-startt)*1.E+3,"ms"
-      
-      call t_stopf('cnpvegsumm')
-      
-      if(use_cn .or. use_fates)then
-         !NOTE: potential optimization is to combine these into one subroutine to minimize
-         !      number of kernels launched
-         call cpu_time(startt) 
-
-         call col_cs_summary_acc(col_cs,proc_filter%num_soilc, proc_filter%soilc)
-         call col_ns_Summary_acc(col_ns,proc_filter%num_soilc, proc_filter%soilc)
-         call col_ps_Summary_acc(col_ps,proc_filter%num_soilc, proc_filter%soilc)
-         call cpu_time(stopt) 
-         write(iulog,*) iam, "TIMING col_summary :: ",(stopt-startt)*1.E+3,"ms" 
-         
-         call cpu_time(startt) 
-         call BeginGridCBalance(bounds_proc, col_cs, grc_cs)
-         call BeginGridNBalance(bounds_proc, col_ns, grc_ns)
-         call BeginGridPBalance(bounds_proc, col_ps, grc_ps)
-         call cpu_time(stopt) 
-         write(iulog,*) iam,"TIMING cnp_grid_balance :: ",(stopt-startt)*1.E+3,"ms"
-      end if
-      call t_stopf('cnpinit')
-      ! ============================================================================
-      ! Update subgrid weights with dynamic landcover (prescribed transient patches,
-      ! and or dynamic landunits), and do related adjustments. Note that this
-      ! call needs to happen outside loops over nclumps.
-      ! ============================================================================
-      
-     call cpu_time(startt)
-     call dyn_hwcontent_init(bounds_proc, &
-      proc_filter%num_nolakec, proc_filter%nolakec, &
-      proc_filter%num_lakec, proc_filter%lakec, &
-      urbanparams_vars, soilstate_vars, soilhydrology_vars, lakestate_vars )
-
-     !$acc parallel loop independent gang vector default(present) private(nc,bounds_clump) 
-     do nc = 1, nclumps
-        call get_clump_bounds_gpu(nc, bounds_clump)
-        call set_prior_weights(prior_weights, bounds_clump)
-        call set_old_patch_weightsAcc  (patch_state_updater,bounds_clump)
-        call set_old_column_weightsAcc (column_state_updater,bounds_clump)
-     end do
-     call cpu_time(stopt) 
-     write(iulog,*) iam, "TIMING dynhwcontent_init :: ",(stopt-startt)*1.E+3,"ms"
-     
-      ! ==========================================================================
-      ! Do land cover change that requires I/O, and thus must be outside a threaded region
-      ! ==========================================================================
-      
-      if (get_do_transient_pfts()) then
-         call dynpft_interp(bounds_proc)
-      end if
-      if (get_do_transient_crops()) then
-         call dyncrop_interp(bounds_proc,crop_vars)
-      end if
-      if (get_do_harvest()) then
-         call dynHarvest_interp(bounds_proc)
-      end if
-      
-      ! ==========================================================================
-      ! Do everything else related to land cover change
-      ! ==========================================================================
-      !$acc parallel loop independent gang vector default(present) private(nc, bounds_clump)
-      do nc = 1, nclumps
-         call get_clump_bounds_gpu(nc, bounds_clump)
-         #ifndef _OPENACC 
-         if (use_fates) then
-         end if
-         #endif
-         if (create_glacier_mec_landunit) then
-            call glc2lnd_vars_update_glc2lnd_acc(glc2lnd_vars ,bounds_clump)
+
+      do c = bounds%begc,bounds%endc
+         l = col_pp%landunit(c)
+
+         ! Save snow mass at previous time step
+         h2osno_old(c) = h2osno(c)
+
+         if (.not. use_extrasnowlayers) then
+            ! Decide whether to cap snow
+            if (h2osno(c) > h2osno_max) then
+               do_capsnow(c) = .true.
+            else
+               do_capsnow(c) = .false.
+            end if
+         ! else, snow capping subroutine in SnowHydrologyMod
          end if
-         
-         ! Everything following this point in this loop only needs to be called if we have
-         ! actually changed some weights in this time step. This is also required in the
-         ! first time step of the run to update filters to reflect state of CISM
-         ! (particularly mask that is past through coupler).
-         call dynSubgrid_wrapup_weight_changes(bounds_clump, glc2lnd_vars)
-         call column_set_new_weightsAcc(column_state_updater,bounds_clump, nc)
+
+         ! Reset flux from beneath soil/ice column
+         eflx_bot(c)  = 0._r8
+
+         ! Initialize qflx_glcice everywhere, to zero.
+         qflx_glcice(c) = 0._r8
+
       end do
-      
-      call setProcFilters(bounds_proc, proc_filter, .false.,glc2lnd_vars%icemask_grc)
-      
-      call patch_set_new_weightsAcc(patch_state_updater ,bounds_proc)
-       
-      call cpu_time(startt)  
-      !$acc parallel loop independent gang vector default(present) private(bounds_clump)
-      do nc = 1, nclumps 
-         call get_clump_bounds_gpu(nc, bounds_clump) 
-         call set_subgrid_diagnostic_fields(bounds_clump)
-         
-         call initialize_new_columns(bounds_clump, &
-            prior_weights%cactive, soilhydrology_vars )
-      end do 
-
-      call dyn_hwcontent_final(bounds_proc, &
-            proc_filter%num_nolakec, proc_filter%nolakec, &
-            proc_filter%num_lakec, proc_filter%lakec, &
-            urbanparams_vars, soilstate_vars, soilhydrology_vars, lakestate_vars, &
-            dtime_mod)
-
-      call cpu_time(stopt) 
-      write(iulog,*) iam,"TIMING dyn_hwcontent_final :: ",(stopt-startt)*1.E+3,"ms" 
-      call shr_sys_flush(iulog)  
-      if (use_cn) then
-         call cpu_time(startt) 
-         call dyn_cnbal_patch(bounds_proc, &
-            proc_filter_inactive_and_active%num_soilp, proc_filter_inactive_and_active%soilp, &
-            proc_filter_inactive_and_active%num_soilc, proc_filter_inactive_and_active%soilc, &
-            prior_weights, &
-            patch_state_updater, &
-            canopystate_vars, photosyns_vars, cnstate_vars, &
-            veg_cs, c13_veg_cs, c14_veg_cs, &
-            veg_ns, veg_ps, dtime_mod) 
-          
-         call cpu_time(stopt)
-         write(iulog,*) iam,"TIMING dyn_cnbal_patch :: ",(stopt-startt)*1.E+3,"ms" 
-         if(.not. use_fates ) then 
-            call cpu_time(startt) 
-            call CarbonStateDynGridUpdate(bounds_proc ,dtime_mod)
-            call PhosphorusStateDynGridUpdate(bounds_proc, dtime_mod)
-            call NitrogenStateDynGridUpdate(bounds_proc, dtime_mod)
-            
-            ! Transfer root/seed litter C/N/P to decomposer pools
-            call CarbonStateUpdateDynPatch(proc_filter_inactive_and_active%num_soilc,&
-            proc_filter_inactive_and_active%soilc,dtime_mod)
-            
-            call NitrogenStateUpdateDynPatch(proc_filter_inactive_and_active%num_soilc, &
-            proc_filter_inactive_and_active%soilc,dtime_mod)
-            
-            call PhosphorusStateUpdateDynPatch(proc_filter_inactive_and_active%num_soilc, &
-            proc_filter_inactive_and_active%soilc,dtime_mod)
-
-            call cpu_time(stopt) 
-            write(iulog,*) iam,"TIMING DynGridPatch :: ",(stopt-startt)*1.E+3, "ms"
-         end if 
-         
-      end if
-      
-      if(use_cn .or. use_fates)then
-         call cpu_time(startt) 
-        call dyn_col_cs_Adjustments(bounds_proc%begc,bounds_proc%endc, nclumps, column_state_updater, col_cs)
-        call dyn_col_ns_Adjustments(bounds_proc%begc,bounds_proc%endc, nclumps, column_state_updater, col_ns)
-        call dyn_col_ps_Adjustments(bounds_proc%begc,bounds_proc%endc, nclumps, column_state_updater, col_ps)
-         call cpu_time(stopt) 
-         write(iulog,*) iam,"TIMING dyn_cnbal_column :: ",(stopt-startt)*1.E+3,"ms"
-      end if
-      
-      if (use_cn  .or. use_fates) then
-         nstep = get_nstep()
-         
-         if (nstep < 2 )then
-            if (masterproc) then
-               write(iulog,*) '--WARNING-- skipping CN balance check for first timestep'
-            end if
+
+      ! Initialize fraction of vegetation not covered by snow
+
+      do p = bounds%begp,bounds%endp
+         if (veg_pp%active(p)) then
+            frac_veg_nosno(p) = frac_veg_nosno_alb(p)
          else
-            call t_startf('cnbalchk_at_grid')
-
-            call cpu_time(startt) 
-            
-            if(use_cn) then
-              call veg_cs_Summary_acc(veg_cs,proc_filter%num_soilp, proc_filter%soilp)
-              call veg_ns_Summary_acc(veg_ns,proc_filter%num_soilp, proc_filter%soilp)
-              call veg_ps_Summary_acc(veg_ps,proc_filter%num_soilp, proc_filter%soilp)
-               
-              call summary_veg_state_p2c ( proc_filter%num_soilc, proc_filter%soilc, &
-                     veg_cs, col_cs, veg_ps,col_ps, veg_ns, col_ns)
-               
-               
-            elseif(use_fates)then
-               do nc = 1,nclumps
-                  call get_clump_bounds(nc, bounds_clump)
-                  
-                  ! In this scenario, we simply zero all of the
-                  ! column level variables that would had been upscaled
-                  ! in the veg summary with p2c
-                  call col_cs%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
-                  call col_ns%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
-                  call col_ps%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
-               end do 
-            end if
-            !
-            call col_cs_summary_acc(col_cs, proc_filter%num_soilc, proc_filter%soilc)
-            call col_ns_Summary_acc(col_ns, proc_filter%num_soilc, proc_filter%soilc)
-            call col_ps_Summary_acc(col_ps, proc_filter%num_soilc, proc_filter%soilc)
-            
-           !$acc parallel loop independent gang vector default(present) private(bounds_clump)
-           do nc =1, nclumps 
-              call get_clump_bounds_gpu(nc,bounds_clump) 
-              call EndGridCBalanceAfterDynSubgridDriver(bounds_clump, &
-                 filter(nc)%num_soilc, filter(nc)%soilc, &
-                 col_cs, grc_cs, grc_cf)
-           
-              call EndGridNBalanceAfterDynSubgridDriver(bounds_clump, &
-                 filter(nc)%num_soilc, filter(nc)%soilc, &
-                 col_ns, grc_ns, grc_nf)
-           
-              call EndGridPBalanceAfterDynSubgridDriver(bounds_clump, &
-                 filter(nc)%num_soilc, filter(nc)%soilc, &
-                 col_ps, grc_ps, grc_pf)
-           end do 
-            call t_stopf('cnbalchk_at_grid')
-            call cpu_time(stopt) 
-            write(iulog,*) iam,"TIMING cnbalchk_at_grid :: ",(stopt-startt)*1.E+3, "ms"
+            frac_veg_nosno(p) = 0._r8
          end if
-      end if
-         
-         ! ============================================================================
-         ! Initialize the mass balance checks for water.
-         !
-         ! Currently, I believe this needs to be done after weights are updated for
-         ! prescribed transient patches, because column-level water is not
-         ! generally conserved when weights change (instead the difference is put in
-         ! the grid cell-level terms, qflx_liq_dynbal, etc.). In the future, we may
-         ! want to change the balance checks to ensure that the grid cell-level water
-         ! is conserved, considering qflx_liq_dynbal; in this case, the call to
-         ! BeginWaterBalance should be moved to before the weight updates.
-         !
-         ! For CNP: This needs to be done after dynSubgrid_driver, because the
-         ! changes due to dynamic area adjustments can break column-level conservation
-         ! ============================================================================
-         call cpu_time(startt) 
-         call t_startf('begwbal')
-         !$acc parallel loop independent gang vector default(present) private(nc, bounds_clump)
-         do nc = 1,nclumps
-            call get_clump_bounds_gpu(nc, bounds_clump)
-            
-            call BeginColWaterBalance(bounds_clump,                &
-               filter(nc)%num_nolakec, filter(nc)%nolakec,       &
-               filter(nc)%num_lakec, filter(nc)%lakec,           &
-               filter(nc)%num_hydrologyc, filter(nc)%hydrologyc, &
-               soilhydrology_vars )
-         end do 
-         call t_stopf('begwbal')
-            
-         call t_startf('begcnpbal')
-         ! call veg summary before col summary, for p2c
-         if (use_cn) then
-              call veg_cs_Summary_acc(veg_cs,proc_filter%num_soilp, proc_filter%soilp)
-              call veg_ns_Summary_acc(veg_ns,proc_filter%num_soilp, proc_filter%soilp)
-              call veg_ps_Summary_acc(veg_ps,proc_filter%num_soilp, proc_filter%soilp)
-            
-            call summary_veg_state_p2c(proc_filter%num_soilc,proc_filter%soilc,veg_cs,&
-                     col_cs, veg_ps, col_ps, veg_ns, col_ns)
-
-         else if(use_fates)then
-               ! In this scenario, we simply zero all of the
-               ! column level variables that would had been upscaled
-               ! in the veg summary with p2c
-               do nc = 1, nclumps 
-                  call get_clump_bounds(nc,bounds_clump) 
-                  call col_cs%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
-                  call col_ns%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
-                  call col_ps%ZeroForFates(bounds_clump,filter(nc)%num_soilc, filter(nc)%soilc)
-               end do 
-         endif
-         call t_stopf('begcnpbal')
-               
-         if (use_cn  .or. use_fates) then
-            call t_startf('begcnpbalwf')
-            call col_cs_summary_acc(col_cs,proc_filter%num_soilc, proc_filter%soilc)
-            call col_ns_Summary_acc(col_ns,proc_filter%num_soilc, proc_filter%soilc)
-            call col_ps_Summary_acc(col_ps,proc_filter%num_soilc, proc_filter%soilc)
-            
-            num_soilc = proc_filter%num_soilc
-            !$acc parallel loop independent gang vector default(present) 
-            do fc = 1, num_soilc 
-               c = proc_filter%soilc(fc) 
-               col_cs%begcb(c) = col_cs%totcolc(c) 
-               col_ns%begnb(c) = col_ns%totcoln(c) 
-               col_ps%begpb(c) = col_ps%totcolp(c) 
-            end do 
-            
-            call t_stopf('begcnpbalwf')
-            call cpu_time(stopt) 
-            write(iulog,*) iam,"TIMING ColBalanceCheck :: ",(stopt-startt)*1.E+3,"ms"
-         end if
-         if (do_budgets) then
-            call WaterBudget_SetBeginningMonthlyStates(bounds_proc )
-            if (use_cn) then
-               !call CNPBudget_SetBeginningMonthlyStates(bounds_proc, col_cs, grc_cs)
-            endif
-         endif
-               
-            #ifndef CPL_BYPASS
-            
-            if (use_cn .or. use_fates) then
-               
-               ! ============================================================================
-               ! Update dynamic N deposition field, on albedo timestep
-               ! currently being done outside clumps loop, but no reason why it couldn't be
-               ! re-written to go inside.
-               ! ============================================================================
-               
-               call t_startf('ndep_interp')
-               ! PET: switching CN timestep
-               call ndep_interp(bounds_proc, atm2lnd_vars)
-               call t_stopf('ndep_interp')
-            end if
-            
-            
-            if (use_cn) then
-               call t_startf('fireinterp')
-               call FireInterp(bounds_proc)
-               call t_stopf('fireinterp')
-            end if
-            
-            if (use_cn .or. use_fates) then
-               ! ============================================================================
-               ! Update dynamic P deposition field, on albedo timestep
-               ! currently being done outside clumps loop, but no reason why it couldn't be
-               ! re-written to go inside.
-               ! ============================================================================
-               
-               call t_startf('pdep_interp')
-               ! PET: switching CN timestep
-               call pdep_interp(bounds_proc, atm2lnd_vars)
-               call t_stopf('pdep_interp')
-            end if
-            
-            #endif
-
-            ! ============================================================================
-            ! Initialize variables from previous time step, downscale atm forcings, and
-            ! Determine canopy interception and precipitation onto ground surface.
-            ! Determine the fraction of foliage covered by water and the fraction
-            ! of foliage that is dry and transpiring. Initialize snow layer if the
-            ! snow accumulation exceeds 10 mm.
-            ! ============================================================================
-            
-            call cpu_time(startt)
-           !$acc parallel loop independent gang private(nc,bounds_clump)
-            do nc = 1,nclumps
-               call get_clump_bounds_gpu(nc, bounds_clump)
-               
-               call UpdateDaylength(bounds_clump, declin)
-               
-               ! Initialze variables needed for new driver time step
-               ! elm_drv_init uses bounds_clump in the routine.
-               call elm_drv_init(bounds_clump, &
-                  filter(nc)%num_nolakec, filter(nc)%nolakec, &
-                  filter(nc)%num_nolakep, filter(nc)%nolakep, &
-                  filter(nc)%num_soilp  , filter(nc)%soilp,   &
-                  canopystate_vars, energyflux_vars)
-               
-               call downscale_forcings(bounds_clump, &
-               filter(nc)%num_do_smb_c, filter(nc)%do_smb_c, &
-               atm2lnd_vars)
-               
-               ! ============================================================================
-               ! Canopy Hydrology
-               ! (1) water storage of intercepted precipitation
-               ! (2) direct throughfall and canopy drainage of precipitation
-               ! (3) fraction of foliage covered by water and the fraction is dry and transpiring
-               ! (4) snow layer initialization if the snow accumulation exceeds 10 mm.
-               ! ============================================================================
-               call CanopyHydrology(bounds_clump, &
-                  filter(nc)%num_nolakec, filter(nc)%nolakec, &
-                  filter(nc)%num_nolakep, filter(nc)%nolakep, &
-                  atm2lnd_vars, canopystate_vars, &
-                  aerosol_vars )
-            end do
-            call cpu_time(stopt) 
-            write(iulog,*) iam,"TIMING Biogeophys_setup :: ", (stopt-startt)*1.E+3, "ms"
-            call cpu_time(startt) 
-            !NOTE: canopystate_vars%frac_veg_nosno_alb_patch may be sufficient here?
-            call updateFracNoSnoFilters(bounds_proc,proc_filter, canopystate_vars%frac_veg_nosno_patch)
-            call cpu_time(stopt)
-            write(iulog,*) iam,"TIMING updateFracNoSnoFilters :: ",(stopt-startt)*1.E+3,"ms"
-
-            call cpu_time(startt)
-            ! ============================================================================
-            ! Surface Radiation
-            ! ============================================================================
-            
-            !call t_startf('surfrad')
-            
-            ! Surface Radiation primarily for non-urban columns
-            
-            ! Most of the surface radiation calculations are agnostic to the forest-model
-            ! but the calculations of the fractions of sunlit and shaded canopies
-            ! are specific, calculate them first.
-            ! The nourbanp filter is set in dySubgrid_driver (earlier in this call)
-            ! over the patch index range defined by bounds_clump%begp:bounds_proc%endp
-            
-            ! if(use_fates) then
-            !    call alm_fates%wrap_sunfrac(bounds_clump, top_af, canopystate_vars)
-            ! else
-            call CanopySunShadeFractions(proc_filter%num_nourbanp, proc_filter%nourbanp,    &
-                surfalb_vars, canopystate_vars, solarabs_vars)
-    
-            call SurfaceRadiation(bounds_proc,                &
-                proc_filter%num_nourbanp, proc_filter%nourbanp, &
-                proc_filter%num_urbanp, proc_filter%urbanp    , &
-                proc_filter%num_urbanc, proc_filter%urbanc,     &
-                canopystate_vars, surfalb_vars, &
-                solarabs_vars, surfrad_vars)
-             
-             ! Surface Radiation for only urban columns
-            call UrbanRadiation(                   &
-                proc_filter%num_nourbanl, proc_filter%nourbanl,    &
-                proc_filter%num_urbanl, proc_filter%urbanl,        &
-                urbanparams_vars, solarabs_vars, surfalb_vars)
-            
-            call cpu_time(stopt) 
-            write(iulog,*) iam,"TIMING Radiation :: ",(stopt-startt)*1.E+3, "ms" 
-            call shr_sys_flush(iulog) 
-            call cpu_time(startt)
-            ! ============================================================================ !
-            ! Determine leaf temperature and surface fluxes based on ground                !
-            ! temperature from previous time step.                                         !
-            ! ============================================================================ !
-            call t_startf('bgp1')
-            call CanopyTemperature(bounds_proc,                     &
-               proc_filter%num_nolakec, proc_filter%nolakec,        &
-               proc_filter%num_nolakep, proc_filter%nolakep,        &
-               atm2lnd_vars, canopystate_vars, soilstate_vars, frictionvel_vars, &
-               energyflux_vars)
-            call t_stopf('bgp1')
-            
-            !$acc parallel loop independent gang vector default(present) 
-            do fc = 1, proc_filter%num_nolakec
-               c = proc_filter%nolakec(fc)
-               col_wf%qflx_snow2topsoi     (c)   = 0._r8
-               col_wf%qflx_h2osfc2topsoi   (c)   = 0._r8
-            enddo
-            
-            call cpu_time(stopt)
-            write(iulog,*) iam,"TIMING CanopyTemp :: ",(stopt-startt)*1.E+3,"ms"
-            ! Bareground fluxes for all patches except lakes and urban landunits
-            ! ============================================================================
-            ! Determine fluxes
-            ! ============================================================================
-            if(proc_filter%num_nolu_barep > 0) then 
-               call BareGroundFluxes(proc_filter%num_nolu_barep,proc_filter%nolu_barep,&
-                  canopystate_vars, soilstate_vars, &
-                  frictionvel_vars, ch4_vars)
-            endif 
-            
-            call cpu_time(startt)
-            call CanopyFluxes(bounds_proc, proc_filter%num_nolu_barep, proc_filter%nolu_barep, &
-                   proc_filter%num_nolu_vegp, proc_filter%nolu_vegp , &
-                   canopystate_vars, cnstate_vars  , energyflux_vars, &
-                   frictionvel_vars, soilstate_vars, solarabs_vars, surfalb_vars, &
-                   ch4_vars, photosyns_vars)
-            call cpu_time(stopt)
-
-            write(iulog,*) iam,"TIMING CanopyFluxes :: ",(stopt-startt)*1.E+3,"ms"
-            call cpu_time(startt)
-            ! Define fields that appear on the restart file for non-urban landunits
-            num_nourbanl = proc_filter%num_nourbanl
-            !$acc parallel loop independent gang vector default(present) private(l)
-            do fl = 1, num_nourbanl
-               l = proc_filter%nourbanl(fl)
-               lun_es%taf(l) = spval
-               lun_ws%qaf(l) = spval
-            end do
-            
-            if(proc_filter%num_urbanl > 0) then
-               print *, "UrbanFluxes", proc_filter%num_urbanl
-               call UrbanFluxes(bounds_proc, & 
-                  proc_filter%num_urbanl, proc_filter%urbanl,        &
-                  proc_filter%num_urbanc, proc_filter%urbanc,        &
-                  proc_filter%num_urbanp, proc_filter%urbanp,        &
-                  urbanparams_vars, soilstate_vars,  &
-                  frictionvel_vars )
-            endif
-            
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING UrbanFluxes :: ",(stopt-startt)*1.E+3,"ms"
-            call shr_sys_flush(iulog) 
-            call cpu_time(startt)
-            call LakeFluxes(proc_filter%num_lakep, proc_filter%lakep, &
-                       solarabs_vars, frictionvel_vars, &
-                       energyflux_vars, lakestate_vars)
-            call cpu_time(stopt)
-            write(iulog,*)iam, "TIMING LakeFluxes :",(stopt-startt)*1.E+3,"ms"
-            ! ============================================================================
-            ! DUST and VOC emissions
-            ! ============================================================================
-            call cpu_time(startt)
-
-            !call t_startf('bgc')
-            ! Dust mobilization (C. Zender's modified codes)
-            call DustEmission(bounds_proc,      &
-            proc_filter%num_nolakep, proc_filter%nolakep, &
-            soilstate_vars, canopystate_vars, &
-            frictionvel_vars, dust_vars)
-            
-            ! Dust dry deposition (C. Zender's modified codes)
-            call DustDryDep(bounds_proc, frictionvel_vars, dust_vars)
-            
-            ! VOC emission (A. Guenther's MEGAN (2006) model)
-            call shr_sys_flush(iulog) 
-            !if (use_voc) then
-            !   call VOCEmission(bounds_clump,                                         &
-            !        filter(nc)%num_soilp, filter(nc)%soilp,                           &
-            !        atm2lnd_vars, canopystate_vars, photosyns_vars, temperature_vars, &
-            !        vocemis_vars)
-            !end if
-            
-            call cpu_time(stopt)
-            write(iulog,*)iam, "TIMING Dust :: ",(stopt-startt)*1.E+3, "ms"
-            
-            ! ============================================================================
-            ! Determine temperatures
-            ! ============================================================================
-            call cpu_time(startt)
-            call LakeTemperature(bounds_proc, proc_filter%num_lakec, proc_filter%lakec,&
-               proc_filter%num_lakep, proc_filter%lakep, &
-               solarabs_vars, soilstate_vars, ch4_vars, &
-               lakestate_vars)
-            call cpu_time(stopt) 
-            write(iulog,*) iam, "TIMING LakeTemps :: ",(stopt-startt)*1.E+3,"ms"
-            
-            ! Set soil/snow temperatures including ground temperature
-            call t_startf('soiltemperature')
-            call cpu_time(startt)
-            call SoilTemperature(bounds_proc,  &
-               proc_filter%num_urbanl  , proc_filter%urbanl,   &
-               proc_filter%num_nolakec , proc_filter%nolakec,  &
-               urbanparams_vars, canopystate_vars, &
-               solarabs_vars, soilstate_vars )
-            call cpu_time(stopt) 
-            write(iulog,*) iam,"TIMING SoilTemp ",(stopt-startt)*1.E+3,"ms"
-
-            call t_stopf('soiltemperature')
-            
-            call cpu_time(startt) 
-            !$acc parallel loop independent gang vector private(nc,bounds_clump)
-            do nc = 1,nclumps
-               call get_clump_bounds_gpu(nc, bounds_clump)
-               ! ============================================================================
-               ! update surface fluxes for new ground temperature.
-               ! ============================================================================
-               !call t_startf('bgp2')
-               call SoilFluxes(bounds_clump,                 &
-               filter(nc)%num_urbanl,  filter(nc)%urbanl,     &
-               filter(nc)%num_nolakec, filter(nc)%nolakec,    &
-               filter(nc)%num_nolakep, filter(nc)%nolakep,    &
-               atm2lnd_vars, solarabs_vars, canopystate_vars, &
-               energyflux_vars )
-               !call t_stopf('bgp2')
-               
-            end do
-
-            !$acc parallel loop independent gang vector private(nc,bounds_clump)
-            do nc = 1,nclumps
-               call get_clump_bounds_gpu(nc, bounds_clump)
-               ! ============================================================================
-               ! Perform averaging from patch level to column level
-               ! ============================================================================
-               !call t_startf('patch2col')
-               call elm_drv_patch2col(bounds_clump, filter(nc)%num_nolakec, filter(nc)%nolakec, energyflux_vars)
-               !call t_stopf('patch2col')
-            end do 
-            call cpu_time(stopt) 
-            write(iulog,*) iam, "TIMING SoilFlux/p2c ",(stopt-startt)*1.E+3,"ms"
-
-            call cpu_time(outer_start)
-            call cpu_time(startt) 
-            ! ============================================================================
-            ! Vertical (column) soil and surface hydrology
-            ! ============================================================================
-            ! Note that filter_snowc and filter_nosnowc are returned by
-            ! LakeHydrology after the new snow filter is built
-            !call t_startf('hydro without drainage')
-
-            call HydrologyNoDrainage(bounds_proc,                   &
-                proc_filter%num_nolakec, proc_filter%nolakec,           &
-                proc_filter%num_hydrologyc, proc_filter%hydrologyc,     &
-                proc_filter%num_hydrononsoic, proc_filter%hydrononsoic, &
-                proc_filter%num_urbanc, proc_filter%urbanc,             &
-                proc_filter%num_snowc, proc_filter%snowc,               &
-                proc_filter%num_nosnowc, proc_filter%nosnowc,           &
-                canopystate_vars, atm2lnd_vars, soilstate_vars,  &
-                soilhydrology_vars, aerosol_vars )
-               
-            call cpu_time(stopt) 
-            write(iulog,*) iam, "TIMING HydroNoDrainage :: ",(stopt-startt)*1.E+3,"ms" 
-
-            ! Calculate column-integrated aerosol masses, and
-            ! mass concentrations for radiative calculations and output
-            ! (based on new snow level state, after SnowFilter is rebuilt.
-            ! NEEDS TO BE AFTER SnowFiler is rebuilt, otherwise there
-            ! can be zero snow layers but an active column in filter)
-            
-            call cpu_time(startt)
-            call AerosolMasses( bounds_proc,                                   &
-            num_on=proc_filter%num_snowc, filter_on=proc_filter%snowc,       &
-            num_off=proc_filter%num_nosnowc, filter_off=proc_filter%nosnowc, &
-            aerosol_vars=aerosol_vars)
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING AerosolMasses :: ",(stopt-startt)*1.E+3,"ms" 
-
-            !call t_stopf('hydro without drainage')
-               
-            ! ============================================================================
-            ! Lake hydrology
-            ! ============================================================================
-            ! Note that filter_lakesnowc and filter_lakenosnowc are returned by
-            ! LakeHydrology after the new snow filter is built
-            !call t_startf('hylake')
-            
-            call cpu_time(startt)
-            call LakeHydrology(bounds_proc,                       &
-            proc_filter%num_lakec, proc_filter%lakec,                &
-            proc_filter%num_lakep, proc_filter%lakep,                &
-            proc_filter%num_lakesnowc, proc_filter%lakesnowc,        &
-            proc_filter%num_lakenosnowc, proc_filter%lakenosnowc,    &
-            atm2lnd_vars, soilstate_vars,  &
-            aerosol_vars, lakestate_vars)
-            call cpu_time(stopt) 
-
-            !  Calculate column-integrated aerosol masses, and
-            !  mass concentrations for radiative calculations and output
-            !  (based on new snow level state, after SnowFilter is rebuilt.
-            !  NEEDS TO BE AFTER SnowFiler is rebuilt, otherwise there
-            !  can be zero snow layers but an active column in filter)
-            call cpu_time(startt)
-            call AerosolMasses(bounds_proc,                                       &
-            num_on=proc_filter%num_lakesnowc, filter_on=proc_filter%lakesnowc,       &
-            num_off=proc_filter%num_lakenosnowc, filter_off=proc_filter%lakenosnowc, &
-            aerosol_vars=aerosol_vars)
-            call cpu_time(stopt) 
-            write(iulog,*) iam, "TIMING AerosolMasses :: ",(stopt-startt)*1.E+3,"ms" 
-
-            call cpu_time(startt) 
-            ! Must be done here because must use a snow filter for lake columns
-            call SnowAge_grain(bounds_proc,                &
-            proc_filter%num_lakesnowc, proc_filter%lakesnowc, &
-            proc_filter%num_lakenosnowc, proc_filter%lakenosnowc )
-               
-            call cpu_time(stopt)
-            call cpu_time(outer_stop)
-            write(iulog,*) iam, "TIMING SnowAgeGrain :: ",(stopt-startt)*1.E+3,"ms" 
-            write(iulog,*) iam, "TIMING Hydro-Aerosol :: ",(outer_stop-outer_start)*1.E+3,"ms" 
-            ! ============================================================================
-            ! ! Fraction of soil covered by snow (Z.-L. Yang U. Texas)
-            ! ============================================================================
-            call cpu_time(startt) 
-            !$acc parallel loop independent gang vector private(c,l)
-            do c = bounds_proc%begc,bounds_proc%endc
-               l = col_pp%landunit(c)
-               if (lun_pp%urbpoi(l)) then
-                  ! Urban landunit use Bonan 1996 (LSM Technical Note)
-                  col_ws%frac_sno(c) = min(col_ws%snow_depth(c)/0.05_r8, 1._r8)
-               end  if
-            end do
-            call cpu_time(stopt) 
-            write(iulog,*) iam,"TIMING frac_sno :: ",(stopt-startt)*1.E+3,"ms" 
-
-            call cpu_time(startt) 
-            ! ============================================================================
-            ! Snow aging routine based on Flanner and Zender (2006), Linking snowpack
-            ! microphysics and albedo evolution, JGR, and Brun (1989), Investigation of
-            ! wet-snow metamorphism in respect of liquid-water content, Ann. Glaciol.
-            ! ============================================================================
-            ! Note the snow filters here do not include lakes
-            ! TODO: move this up
-            call t_startf('snow_init')
-            call SnowAge_grain(bounds_proc,                 &
-            proc_filter%num_snowc, proc_filter%snowc,     &
-            proc_filter%num_nosnowc, proc_filter%nosnowc )
-            call t_stopf('snow_init')
-            ! ============================================================================
-            ! Update sediment fluxes from land unit
-            ! ============================================================================
-            if (use_erosion) then
-               call t_startf('erosion')
-               call SoilErosion(bounds_clump, filter(nc)%num_soilc, filter(nc)%soilc, &
-                    atm2lnd_vars, canopystate_vars, soilstate_vars,  sedflux_vars)
-               call t_stopf('erosion')
-            end if
-            ! ============================================================================
-            ! Ecosystem dynamics: Uses CN, or static parameterizations
-            ! ============================================================================
-            call t_startf('ecosysdyn')
-            !if (use_cn)then
-            !    call crop_vars%CropIncrementYear(filter(nc)%num_pcropp, filter(nc)%pcropp)
-            !endif
-            call cpu_time(stopt) 
-            write(iulog,*) iam,"TIMING SnowAge_grain :: ",(stopt-startt)*1.E+3,"ms" 
-            
-            ! fully prognostic canopy structure and C-N biogeochemistry
-            ! - crop model:  crop algorithms called from within CNEcosystemDyn
-            
-            !===========================================================================================
-            ! elm_interface: 'EcosystemDynNoLeaching' is divided into 2 subroutines (1 & 2): BEGIN
-            ! EcosystemDynNoLeaching1 is called before clm_interface
-            ! EcosystemDynNoLeaching2 is called after clm_interface
-            !===========================================================================================
-         if(use_cn) then 
-            call cpu_time(eco_startt) 
-
-            call cpu_time(startt)
-            call col_cf_SetValues_acc(col_cf,proc_filter%num_soilc, proc_filter%soilc)
-            call col_nf_SetValues_acc(col_nf,proc_filter%num_soilc, proc_filter%soilc)
-            call col_pf_SetValues_acc(col_pf,proc_filter%num_soilc, proc_filter%soilc)
-            
-            call veg_cf_SetValues_acc(veg_cf,proc_filter%num_soilp, proc_filter%soilp, 0._r8)
-            call veg_nf_setvalues_acc(veg_nf,proc_filter%num_soilp, proc_filter%soilp, 0._r8)
-            call veg_pf_SetValues_acc(veg_pf,proc_filter%num_soilp, proc_filter%soilp, 0._r8)
-            call cpu_time(stopt) 
-            write(iulog,*) iam, "TIMING SetValuesCols ", (stopt-startt)*1.E+3,"ms"
-
-            call cpu_time(startt)
-            call NitrogenDeposition(bounds_proc, atm2lnd_vars)
-            
-            if ( (.not. nu_com_nfix) .or. use_fates) then
-               #ifndef OPENACC
-               !soilc loop
-               call NitrogenFixation( proc_filter%num_soilc, proc_filter%soilc, dayspyr_mod)
-               #endif
-            else
-               ! nu_com_nfix is true
-               !soilc loop
-               call NitrogenFixation_balance( proc_filter%num_soilc, proc_filter%soilc, cnstate_vars )
-            end if
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING NDeposition: ",(stopt-startt)*1.E+3,"ms"
-            
-            call get_proc_bounds(bounds_proc)
-            call cpu_time(startt)
-            if (crop_prog) then
-               call NitrogenFert(proc_filter%num_soilc,proc_filter%soilc )
-               
-               call CNSoyfix( proc_filter%num_soilc, proc_filter%soilc,&
-               proc_filter%num_soilp, proc_filter%soilp, &
-               crop_vars, cnstate_vars )
-            end if
-            ! This is auto-trophic respiration, thus don't call this for FATES
-            call MaintenanceResp( proc_filter%num_soilc, proc_filter%soilc, &
-            proc_filter%num_soilp, proc_filter%soilp, &
-            canopystate_vars, soilstate_vars,  photosyns_vars )
-            
-            if ( nu_com .ne. 'RD') then
-               ! for P competition purpose, calculate P fluxes that will potentially increase solution P pool
-               ! then competitors take up solution P
-               #ifdef OPENACC 
-               call endrun("only RD is supported with OpenACC")
-               #endif 
-               call PhosphorusWeathering(proc_filter%num_soilc, proc_filter%soilc, cnstate_vars, dtime_mod)
-               !NOTE:  nu_com_phosphatase is FALSE for RD
-               if (.not. nu_com_phosphatase) then
-                  call PhosphorusBiochemMin(proc_filter%num_soilc, proc_filter%soilc, &
-                  cnstate_vars, dtime_mod)
-               else
-                  call PhosphorusBiochemMin_balance(bounds_proc,proc_filter%num_soilc, proc_filter%soilc, &
-                  cnstate_vars, dtime_mod)
-               end if
-            end if
-            
-            ! --------------------------------------------------
-            ! Phosphorus Deposition ! X.SHI
-            ! --------------------------------------------------
-            call PhosphorusDeposition(bounds_proc,  atm2lnd_vars )
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING MR/PDeposition: ",(stopt-startt)*1.E+3, "ms"
-            !-------------------------------------------------------------------------------------------------
-            ! plfotran: 'decomp_rate_constants' must be calculated before entering "clm_interface"
-            call cpu_time(startt)
-            
-            call decomp_rate_constants_cn( proc_filter%num_soilc, proc_filter%soilc, &
-            canopystate_vars, soilstate_vars,  ch4_vars, cnstate_vars)
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING DecompRate:",(stopt-startt)*1.E+3,"ms"
-            !-------------------------------------------------------------------------------------------------
-            ! 'decomp_vertprofiles' (calc nfixation_prof) is moved from SoilLittDecompAlloc:
-            ! ------------------------------------------------------------------------------------------------
-            call cpu_time(startt)
-            call decomp_vertprofiles(bounds_proc,     &
-            proc_filter%num_soilc, proc_filter%soilc, &
-            proc_filter%num_soilp, proc_filter%soilp, &
-            soilstate_vars, canopystate_vars, cnstate_vars)
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING EcoVert_profiles",(stopt-startt)*1.E+3,"ms"
-            
-            ! Allocation1 is always called (w/ or w/o use_elm_interface)
-            ! pflotran: call 'Allocation1' to obtain potential N demand for support initial GPP
-            if(.not.use_fates)then
-               call cpu_time(startt)
-               call Allocation1_PlantNPDemand ( &
-               proc_filter%num_soilc, proc_filter%soilc, &
-               proc_filter%num_soilp, proc_filter%soilp, &
-               photosyns_vars, crop_vars, canopystate_vars, cnstate_vars, &
-               dtime_mod, year_curr )
-               call cpu_time(stopt)
-               write(iulog,*) iam, "TIMING AllocationPhase1 : ",(stopt-startt)*1.E+3,"ms"
-            end if
-            call cpu_time(startt)
-            ! directly run elm-bgc
-            ! if (use_elm_interface & use_elm_bgc), then CNDecomAlloc is called in elm_driver
-           call SoilLittDecompAlloc (bounds_proc, proc_filter%num_soilc, proc_filter%soilc,    &
-                 proc_filter%num_soilp, proc_filter%soilp,    &
-                 canopystate_vars, soilstate_vars,            &
-                 cnstate_vars, ch4_vars, dtime_mod )
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING SoilLittDecompAlloc:",(stopt-startt)*1.E+3,"ms"
-            
-            !----------------------------------------------------------------
-            ! SoilLittDecompAlloc2 is called by both elm-bgc & pflotran
-            ! pflotran: call 'SoilLittDecompAlloc2' to calculate some diagnostic variables and 'fpg' for plant N uptake
-            ! pflotran & elm-bgc : 'Allocation3_AG' and vertically integrate net and gross mineralization fluxes
-            call cpu_time(startt)
-            call SoilLittDecompAlloc2 (proc_filter%num_soilc, proc_filter%soilc,&
-            proc_filter%num_soilp, proc_filter%soilp,  &
-            canopystate_vars, soilstate_vars,          &
-            cnstate_vars, crop_vars, dtime_mod )
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING SoilLittDecompAlloc2:",(stopt-startt)*1.E+3,"ms"
-            
-            !--------------------------------------------
-            ! Phenology
-            !--------------------------------------------
-            ! Phenology needs to be called after SoilLittDecompAlloc, because it
-            ! depends on current time-step fluxes to new growth on the last
-            ! litterfall timestep in deciduous systems
-            ! event = 'Phenology'
-            ! call t_start_lnd(event)
-            call cpu_time(startt)
-            call Phenology(proc_filter%num_soilc, proc_filter%soilc, &
-            proc_filter%num_soilp, proc_filter%soilp, &
-            proc_filter%num_pcropp, proc_filter%pcropp,filter(1)%num_ppercropp,filter(1)%ppercropp, doalb, &
-            crop_vars, canopystate_vars, soilstate_vars, cnstate_vars )
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING Phenology :",(stopt-startt)*1.E+3,"ms"
-           
-            call cpu_time(startt)  
-            call GrowthResp(proc_filter%num_soilp, proc_filter%soilp)
-            call veg_cf_summary_rr(veg_cf, proc_filter%num_soilp, proc_filter%soilp, &
-                                   proc_filter%num_soilc, proc_filter%soilc, col_cf)
-            
-            call CarbonStateUpdate0(proc_filter%num_soilp,proc_filter%soilp,veg_cs,veg_cf, dtime_mod)
-            !if ( use_c13 ) then
-            !    call CarbonStateUpdate0(p,c13_veg_cs,c13_veg_cf, dtime_mod)
-            !end if
-            !if ( use_c14 ) then
-            !    call CarbonStateUpdate0(p,c14_veg_cs,c14_veg_cf, dtime_mod)
-            !end if
-            call CNLitterToColumn(proc_filter%num_soilc, proc_filter%soilc, cnstate_vars )
-            call cpu_time(stopt) 
-            write(iulog,*) iam, "TIMING Summary ::",(stopt-startt)*1.E+3,"ms"
-
-            call cpu_time(startt) 
-            call CarbonStateUpdate_Phase1_col(proc_filter%num_soilc, proc_filter%soilc, col_cs, col_cf, dtime_mod)
-            call NitrogenStateUpdate_Phase1_col(proc_filter%num_soilc, proc_filter%soilc, cnstate_vars, dtime_mod)
-            call PhosphorusStateUpdate_Phase1_col(proc_filter%num_soilc, proc_filter%soilc, cnstate_vars, dtime_mod)
-            call cpu_time(stopt) 
-            write(iulog,*) "Phase1_col", (stopt-startt)*1.E+3, "ms" 
-            if(.not. use_fates) then 
-               call CarbonStateUpdate_Phase1_PFT(proc_filter%num_soilp,proc_filter%soilp,crop_vars, veg_cs, veg_cf,dtime_mod)
-               call NitrogenStateUpdate_Phase1_pft(proc_filter%num_soilp,proc_filter%soilp, dtime_mod)
-               call PhosphorusStateUpdate_Phase1_pft(proc_filter%num_soilp,proc_filter%soilp, dtime_mod) 
-            end if
-            
-            call cpu_time(startt)
-            call SoilLittVertTransp( proc_filter%num_soilc, proc_filter%soilc, &
-               canopystate_vars, cnstate_vars )
-            call cpu_time(stopt)
-            write(iulog,*) iam, "TIMING SoilLittVertTransp: ",(stopt-startt)*1.E+3,"ms"
-
-            call cpu_time(startt) 
-            call GapMortality( proc_filter%num_soilc, proc_filter%soilc, &
-                   proc_filter%num_soilp, proc_filter%soilp,&
-                   cnstate_vars )
-            !--------------------------------------------
-            ! Update2
-            !--------------------------------------------
-            call CarbonStateUpdate2( proc_filter%num_soilc, proc_filter%soilc, &
-                     proc_filter%num_soilp, proc_filter%soilp, &
-                     col_cs, veg_cs, col_cf, veg_cf)
-
-            call NitrogenStateUpdate2(proc_filter%num_soilc, proc_filter%soilc, &
-            proc_filter%num_soilp, proc_filter%soilp )
-            
-            call PhosphorusStateUpdate2(proc_filter%num_soilc, proc_filter%soilc, &
-            proc_filter%num_soilp, proc_filter%soilp )
-            
-            call CarbonStateUpdate2h( proc_filter%num_soilc, proc_filter%soilc,  &
-            proc_filter%num_soilp, proc_filter%soilp, &
-            col_cs, veg_cs, col_cf, veg_cf)
-            
-            call NitrogenStateUpdate2h(proc_filter%num_soilc, proc_filter%soilc, &
-            proc_filter%num_soilp, proc_filter%soilp)
-            
-            call PhosphorusStateUpdate2h(proc_filter%num_soilc, proc_filter%soilc, proc_filter%num_soilp, proc_filter%soilp)
-            call WoodProducts(proc_filter%num_soilc, proc_filter%soilc )
-            call CropHarvestPools(proc_filter%num_soilc, proc_filter%soilc, dtime_mod)
-            call cpu_time(stopt) 
-            write(iulog,*) "TIMING StateUpdate :: ",(stopt-startt)*1.E+3,"ms" 
-            
-            call cpu_time(startt) 
-            call FireArea( bounds_proc, &
-                    proc_filter%num_soilc, proc_filter%soilc, &
-                    proc_filter%num_soilp, proc_filter%soilp, &
-                    atm2lnd_vars, energyflux_vars, soilhydrology_vars, &
-                    cnstate_vars )
-             
-            call FireFluxes(proc_filter%num_soilc, proc_filter%soilc, &
-                    proc_filter%num_soilp, proc_filter%soilp, cnstate_vars)
-
-            call cpu_time(stopt) 
-            write(iulog,*) iam, "TIMING FireMod :: ",(stopt-startt)*1.E+3,"ms" 
-            
-            if ( use_erosion ) then
-                call ErosionFluxes(bounds_proc, proc_filter%num_soilc, proc_filter%soilc, soilstate_vars, sedflux_vars )
+      end do
+
+      ! Initialize set of previous time-step variables
+      ! Ice fraction of snow at previous time step
+
+      do j = -nlevsno+1,0
+         do f = 1, num_nolakec
+            c = filter_nolakec(f)
+            if (j >= snl(c) + 1) then
+               frac_iceold(c,j) = h2osoi_ice(c,j)/(h2osoi_liq(c,j)+h2osoi_ice(c,j))
             end if
-            !--------------------------------------------
-            ! Update3
-            !--------------------------------------------
-            if(.not.use_fates)then
-               ! if ( use_c13 ) then
-               ! call CarbonIsoFlux3(proc_filter%num_soilc, proc_filter%soilc,proc_filter%num_soilp, proc_filter%soilp, &
-               !      cnstate_vars, &
-               !      isotope=c13, isocol_cs=c13_col_cs, isoveg_cs=c13_veg_cs, isocol_cf=c13_col_cf, isoveg_cf=c13_veg_cf)
-               ! end if
-               ! if ( use_c14 ) then
-               !    call CarbonIsoFlux3(proc_filter%num_soilc, proc_filter%soilc,proc_filter%num_soilp, proc_filter%soilp, &
-               !         cnstate_vars , &
-               !         isotope=c14, isocol_cs=c14_col_cs, isoveg_cs=c14_veg_cs, isocol_cf=c14_col_cf, isoveg_cf=c14_veg_cf)
-               ! end if
-          
-                call CarbonStateUpdate3( proc_filter%num_soilc, proc_filter%soilc,proc_filter%num_soilp, proc_filter%soilp, &
-                     col_cs, veg_cs, col_cf, veg_cf, dtime_mod)
-          
-                if ( use_c13 ) then
-                   call CarbonStateUpdate3( proc_filter%num_soilc, proc_filter%soilc,proc_filter%num_soilp, proc_filter%soilp, &
-                        c13_col_cs, c13_veg_cs, c13_col_cf, c13_veg_cf, dtime_mod)
-                end if
-                if ( use_c14 ) then
-                   call CarbonStateUpdate3( proc_filter%num_soilc, proc_filter%soilc,proc_filter%num_soilp, proc_filter%soilp, &
-                        c14_col_cs, c14_veg_cs, c14_col_cf, c14_veg_cf, dtime_mod)
-                end if
-                if ( use_c14 ) then
-                   call C14Decay(proc_filter%num_soilc, proc_filter%soilc,proc_filter%num_soilp, proc_filter%soilp, &
-                        cnstate_vars )
-          
-                   call C14BombSpike(proc_filter%num_soilp, proc_filter%soilp, &
-                        cnstate_vars)
-                end if
-          
-                call veg_cf_summary_for_ch4(veg_cf,bounds_proc, proc_filter%num_soilp, proc_filter%soilp)
-                if( use_c13 ) then
-                   call col_cf_summary_for_ch4(c13_col_cf,bounds_proc,proc_filter%num_soilc, proc_filter%soilc)
-                   call veg_cf_summary_for_ch4(c13_veg_cf,bounds_proc,proc_filter%num_soilp, proc_filter%soilp)
-                endif
-                if( use_c14 ) then
-                   call col_cf_summary_for_ch4(c14_col_cf,bounds_proc,proc_filter%num_soilc, proc_filter%soilc)
-                   call veg_cf_summary_for_ch4(c14_veg_cf,bounds_proc,proc_filter%num_soilp, proc_filter%soilp)
-                endif
-          
-            end if !end of if not use_fates block
-          
-           call col_cf_summary_for_ch4(col_cf,bounds_proc, proc_filter%num_soilc, proc_filter%soilc)
-            
-            !===========================================================================================
-            ! elm_interface: 'EcosystemDynNoLeaching' is divided into 2 subroutines (1 & 2): END
-            !===========================================================================================
-         end if !use_cn  
-         
-         !$acc parallel loop independent gang vector default(present) private(nc,bounds_clump)
-         do nc = 1,nclumps
-            call get_clump_bounds_gpu(nc, bounds_clump)
-            call AnnualUpdate(bounds_clump,            &
-            filter(nc)%num_soilc, filter(nc)%soilc, &
-            filter(nc)%num_soilp, filter(nc)%soilp, &
-            cnstate_vars)
          end do
-          
-         if(.not. use_fates .and. .not. ( n_drydep == 0 .or. drydep_method /= DD_XLND )) then
-            print *, "n_drydep:",n_drydep,"method:",drydep_method, "DD_XLND",DD_XLND
-           ! Dry Deposition of chemical tracers (Wesely (1998) parameterizaion)
-           call t_startf('depvel')
-           !$acc parallel loop independent gang vector default(present)
-           do nc = 1,nclumps
-              call get_clump_bounds_gpu(nc, bounds_clump)
-              call depvel_compute(bounds_clump, &
-                     atm2lnd_vars, canopystate_vars, frictionvel_vars, &
-                     photosyns_vars, drydepvel_vars)
-            end do
-            call t_stopf('depvel')
-         endif ! end if depvel_compute
-         
-         if (use_lch4 .and. .not. is_active_betr_bgc) then
-            !warning: do not call ch4 before AnnualUpdate, which will fail the ch4 model
-            call t_startf('ch4')
-            call CH4 (bounds_proc,                        &
-               proc_filter%num_soilc, proc_filter%soilc,  &
-               proc_filter%num_lakec, proc_filter%lakec,  &
-               proc_filter%num_soilp, proc_filter%soilp,  &
-               lakestate_vars, canopystate_vars, &
-               soilstate_vars, soilhydrology_vars, &
-               energyflux_vars, ch4_vars, lnd2atm_vars)
-            call t_stopf('ch4')
-         end if
+      end do
 
-         if(.not. use_fates .and. .not. ( n_drydep == 0 .or. drydep_method /= DD_XLND )) then
-            print *, "n_drydep:",n_drydep,"method:",drydep_method, "DD_XLND",DD_XLND
-           ! Dry Deposition of chemical tracers (Wesely (1998) parameterizaion)
-           call t_startf('depvel')
-           !$acc parallel loop independent gang vector default(present)
-           do nc = 1,nclumps
-              call get_clump_bounds_gpu(nc, bounds_clump)
-              call depvel_compute(bounds_clump, &
-                     atm2lnd_vars, canopystate_vars, frictionvel_vars, &
-                     photosyns_vars, drydepvel_vars)
-            end do
-            call t_stopf('depvel')
-         endif ! end if depvel_compute
-           ! ============================================================================
-           ! Calculate soil/snow hydrology with drainage (subsurface runoff)
-           ! ============================================================================
-           
-           call t_startf('hydro2 drainage')
-           
-           call HydrologyDrainage(bounds_proc,                 &
-              proc_filter%num_nolakec, proc_filter%nolakec,       &
-              proc_filter%num_hydrologyc, proc_filter%hydrologyc, &
-              proc_filter%num_urbanc, proc_filter%urbanc,         &
-              proc_filter%num_do_smb_c, proc_filter%do_smb_c,     &
-              atm2lnd_vars, glc2lnd_vars,      &
-              soilhydrology_vars, soilstate_vars)
-            
-           call t_stopf('hydro2 drainage')
-            call cpu_time(stopt)
-            write(iulog,*) iam,"TIMING Depvel/HydroDrainage :: ",(stopt-startt)*1.E+3,"ms"
- 
-            if (use_cn .or. use_fates) then
-               call cpu_time(startt)
-               call EcosystemDynLeaching(               &
-                  proc_filter%num_soilc, proc_filter%soilc,             &
-                  proc_filter%num_soilp, proc_filter%soilp,             &
-                  cnstate_vars )
-               call cpu_time(stopt)
-               write(iulog,*) iam,"TIMING EcosystemDynLeaching :: ",(stopt-startt)*1.E+3,"ms"
-            end if 
-            ! ============================================================================
-            ! Update Vegetation
-            ! ============================================================================
-            ! Execute FATES dynamics
-            if ( use_fates ) then
-                ! Update high-frequency history diagnostics for FATES
-                call alm_fates%wrap_update_hifrq_hist(bounds_clump)
-                if ( is_beg_curr_day() ) then ! run ED at the start of each day
-                    call alm_fates%dynamics_driv( bounds_clump, top_as,          &
-                         top_af, atm2lnd_vars, soilstate_vars, temperature_vars, &
-                         canopystate_vars, frictionvel_vars)
-                end if
-            end if
-            call cpu_time(startt)
-            if (use_cn .and. doalb) then
-                call VegStructUpdate(proc_filter%num_soilp, proc_filter%soilp,   &
-                     frictionvel_vars, cnstate_vars, &
-                     canopystate_vars, crop_vars, dtime_mod)
-            end if
-            ! ============================================================================
-            ! Check the energy and water balance, also carbon and nitrogen balance
-            ! ============================================================================
-            
-            call t_startf('balchk')
-            !$acc parallel loop independent gang vector default(present) private(nc,bounds_clump)
-            do nc = 1,nclumps
-               call get_clump_bounds_gpu(nc, bounds_clump)
-               call ColWaterBalanceCheck(bounds_clump, &
-               filter(nc)%num_do_smb_c, filter(nc)%do_smb_c, &
-               atm2lnd_vars, glc2lnd_vars, solarabs_vars,  &
-               energyflux_vars, canopystate_vars)
-             end do 
-            call t_stopf('balchk')
-               
-            call t_startf('gridbalchk')
-            !$acc parallel loop independent gang vector default(present) private(nc,bounds_clump)
-            do nc = 1,nclumps
-               call get_clump_bounds_gpu(nc, bounds_clump)
-               call GridBalanceCheck(bounds_clump                  , &
-               atm2lnd_vars, glc2lnd_vars,       &
-               energyflux_vars, soilhydrology_vars)
-            enddo
-            call t_stopf('gridbalchk')
-               
-            if (do_budgets) then
-              !!!! !$acc parallel loop independent gang vector default(present) private(nc,bounds_clump)
-              do nc = 1,nclumps
-                 call get_clump_bounds_gpu(nc, bounds_clump)
-                 call WaterBudget_SetEndingMonthlyStates(bounds_clump)
-                 if (use_cn) then
-                   call CNPBudget_SetEndingMonthlyStates(bounds_clump, col_cs, grc_cs)
-                 endif
-              enddo  
-            endif
-            call t_startf('cnbalchk')
-            if (use_cn .or. use_fates) then
-              !$acc parallel loop independent gang vector default(present) private(nc,bounds_clump)
-              do nc = 1,nclumps
-                 call get_clump_bounds_gpu(nc, bounds_clump)
-               
-                 call ColCBalanceCheck( &
-                 filter(nc)%num_soilc, filter(nc)%soilc, &
-                 col_cs, col_cf)
-                 
-                 call ColNBalanceCheck(bounds_clump, &
-                 filter(nc)%num_soilc, filter(nc)%soilc, &
-                 col_ns, col_nf)
-                 
-                 call ColPBalanceCheck(bounds_clump, &
-                 filter(nc)%num_soilc, filter(nc)%soilc, &
-                 col_ps, col_pf)
-                 
-                 call GridCBalanceCheck(bounds_clump, col_cs, col_cf, grc_cs, grc_cf)
-               
-               end do
-               call t_stopf('cnbalchk')
-            end if
-            ! ============================================================================
-            ! Determine albedos for next time step
-            ! ============================================================================
-            
-            if (.false.) then
-               !if(nstep_mod >1 ) call write_vars() 
-               !$acc parallel loop independent gang private(nc,bounds_clump)
-               do nc = 1,nclumps
-                  call get_clump_bounds_gpu(nc, bounds_clump)
-                  ! Albedos for  non-urban columns
-                  !call t_startf('surfalb')
-                  call SurfaceAlbedo(bounds_clump,                      &
-                  filter_inactive_and_active(nc)%num_nourbanc,     &
-                  filter_inactive_and_active(nc)%nourbanc,         &
-                  filter_inactive_and_active(nc)%num_nourbanp,     &
-                  filter_inactive_and_active(nc)%nourbanp,         &
-                  filter_inactive_and_active(nc)%num_urbanc,       &
-                  filter_inactive_and_active(nc)%urbanc,           &
-                  filter_inactive_and_active(nc)%num_urbanp,       &
-                  filter_inactive_and_active(nc)%urbanp,           &
-                  nextsw_cday, declinp1,                           &
-                  aerosol_vars, canopystate_vars, &
-                  lakestate_vars, surfalb_vars )
-                  !call t_stopf('surfalb')
-                  
-                  ! Albedos for urban columns
-                  if (filter_inactive_and_active(nc)%num_urbanl > 0) then
-                     !call t_startf('urbsurfalb')
-                     call UrbanAlbedo(         &
-                     filter_inactive_and_active(nc)%num_urbanl, &
-                     filter_inactive_and_active(nc)%urbanl,     &
-                     filter_inactive_and_active(nc)%num_urbanc, &
-                     filter_inactive_and_active(nc)%urbanc,     &
-                     filter_inactive_and_active(nc)%num_urbanp, &
-                     filter_inactive_and_active(nc)%urbanp,     &
-                     urbanparams_vars, solarabs_vars, surfalb_vars)
-                     !call t_stopf('urbsurfalb')
-                  end if
-               end do
-            end if
-            
-            #ifdef _CUDA
-            istat = cudaMemGetInfo(free2, total)
-            write(iulog,*) iam,"Free:", free2/1.E9
-            #endif
-            ! ============================================================================
-            ! Determine gridcell averaged properties to send to atm
-            ! ============================================================================
-            if(use_betr)then
-               call ep_betr%DiagnoseLnd2atm(bounds_proc, col_pp, lnd2atm_vars)
-            endif
-            call t_startf('lnd2atm')
-            call cpu_time(startt) 
-            call lnd2atm(bounds_proc,       &
-               atm2lnd_vars, surfalb_vars, frictionvel_vars,    &
-               energyflux_vars, solarabs_vars, drydepvel_vars,  &
-               dust_vars, ch4_vars, soilhydrology_vars, lnd2atm_vars)
-            call cpu_time(stopt) 
-            write(iulog,*) iam, "TIMING lnd2atm :: ",(stopt-startt)*1.E+3,"ms"
-            call t_stopf('lnd2atm')
-            ! ============================================================================
-            ! Determine gridcell averaged properties to send to glc
-            ! ============================================================================
-            
-            if (create_glacier_mec_landunit) then
-               call t_startf('lnd2glc')
-               do nc = 1,nclumps
-                  call get_clump_bounds(nc, bounds_clump)
-                  call lnd2glc_vars%update_lnd2glc(bounds_clump,       &
-                  filter(nc)%num_do_smb_c, filter(nc)%do_smb_c,   &
-                  init=.false.)
-               end do
-               call t_stopf('lnd2glc')
-            end if
-            
-            ! ============================================================================
-            ! Write global average diagnostics to standard output
-            ! ============================================================================
-            
-            nstep = get_nstep()
-            if (wrtdia) call mpi_barrier(mpicom,ier)
-            call t_startf('wrtdiag')
-            call write_diagnostic(bounds_proc, wrtdia, nstep, lnd2atm_vars)
-            call t_stopf('wrtdiag')
-            
-            ! ============================================================================
-            ! Update accumulators
-            ! ============================================================================
-            
-            ! FIX(SPM,032414) double check why this isn't called for ED
-            
-            if (nstep_mod > 0) then
-               
-               call t_startf('accum')
-               
-               call atm2lnd_vars%UpdateAccVars(bounds_proc)
-               
-               call top_as%UpdateAccVars(bounds_proc)
-               
-               call top_af%UpdateAccVars(bounds_proc)
-               
-               call veg_es%UpdateAccVars(bounds_proc)
-               
-               call canopystate_vars%UpdateAccVars(bounds_proc)
-               
-               if (crop_prog) then
-                  call crop_vars%UpdateAccVars(bounds_proc, temperature_vars)
-               end if
-               
-               call cnstate_vars%UpdateAccVars(bounds_proc)
-               
-               call t_stopf('accum')
-               
-            end if
-            
-            ! ============================================================================
-            ! Update history buffer
-            ! ============================================================================
-            
-            ! Determine if end of history interval
-            transfer_tapes = .false.
-            do t = 1, ntapes 
-               if (tape(t)%nhtfrq==0) then   !monthly average
-                  if (mon_curr /= mon_prev) then 
-                     tape(t)%is_endhist = .true.
-                     transfer_tapes = .true. 
-                  end if 
-               else
-                  write(iulog,*) "nhtfrq: ", tape(t)%nhtfrq 
-                  if (mod(nstep_mod,tape(t)%nhtfrq) == 0) then
-                     tape(t)%is_endhist = .true.
-                     transfer_tapes = .true.
-                  end if 
-               end if
-            end do 
-            call t_startf('hbuf')
-            !call hist_update_hbuf_gpu(nstep_mod,transfer_tapes, nclumps)
-            call hist_update_hbuf(bounds_proc)  
-            call t_stopf('hbuf')
-            write(iulog,*) iam, "TIMING hist_update_hbuf :: ",(stopt-startt)*1.E+3,"ms"
-            
-            ! ============================================================================
-            ! Compute water budget
-            ! ============================================================================
-            if (get_nstep()>0 .and. do_budgets) then
-               call WaterBudget_Run(bounds_proc, atm2lnd_vars, lnd2atm_vars, &
-               soilhydrology_vars)
-               call WaterBudget_Accum()
-               call WaterBudget_Print(budget_inst,  budget_daily,  budget_month,  &
-               budget_ann,  budget_ltann,  budget_ltend)
-               
-               if (use_cn .and. do_budgets) then
-                  call CNPBudget_Run(bounds_proc, atm2lnd_vars, lnd2atm_vars, grc_cs, grc_cf)
-                  call CNPBudget_Accum()
-                  call CNPBudget_Print(budget_inst,  budget_daily,  budget_month,  &
-                  budget_ann,  budget_ltann,  budget_ltend)
-               end if
-            endif
-            
-            ! ============================================================================
-            ! History/Restart output
-            ! ============================================================================
-            
-            if (.not. use_noio) then
-               
-               call t_startf('elm_drv_io')
-               
-               ! Create history and write history tapes if appropriate
-               call t_startf('elm_drv_io_htapes')
-               
-               call hist_htapes_wrapup( rstwr, nlend, bounds_proc,                    &
-               soilstate_vars%watsat_col(bounds_proc%begc:bounds_proc%endc, 1:), &
-               soilstate_vars%sucsat_col(bounds_proc%begc:bounds_proc%endc, 1:), &
-               soilstate_vars%bsw_col(bounds_proc%begc:bounds_proc%endc, 1:),    &
-               soilstate_vars%hksat_col(bounds_proc%begc:bounds_proc%endc, 1:))
-               
-               call t_stopf('elm_drv_io_htapes')
-               ! Write restart/initial files if appropriate
-               if (rstwr) then
-                  call t_startf('elm_drv_io_wrest')
-                  filer = restFile_filename(rdate=rdate)
-                  
-                  call restFile_write( bounds_proc, filer,                                            &
-                  atm2lnd_vars, aerosol_vars, canopystate_vars, cnstate_vars,                    &
-                  carbonstate_vars, c13_carbonstate_vars, c14_carbonstate_vars, carbonflux_vars, &
-                  ch4_vars, energyflux_vars, frictionvel_vars, lakestate_vars,        &
-                  nitrogenstate_vars, nitrogenflux_vars, photosyns_vars, soilhydrology_vars,     &
-                  soilstate_vars, solarabs_vars, surfalb_vars, temperature_vars,                 &
-                  waterflux_vars, waterstate_vars, sedflux_vars,                                 &
-                  phosphorusstate_vars,phosphorusflux_vars,                                      &
-                  ep_betr, alm_fates, crop_vars, rdate=rdate )
-                  
-                  !----------------------------------------------
-                  ! pflotran (off now)
-                  ! if (use_pflotran) then
-                  !     call elm_pf_write_restart(rdate)
-                  ! end if
-                  !----------------------------------------------
-                  
-                  
-                  call t_stopf('elm_drv_io_wrest')
-               end if
-               call t_stopf('elm_drv_io')
-               
-            end if
-            
-            if (use_pflotran .and. nstep>=nestep) then
-               call elm_pf_finalize()
-            end if
-            
-         end subroutine elm_drv
-         
-         !-----------------------------------------------------------------------
-         subroutine elm_drv_init(bounds, &
-            num_nolakec, filter_nolakec, &
-            num_nolakep, filter_nolakep, &
-            num_soilp  , filter_soilp, &
-            canopystate_vars,  energyflux_vars)
-            !
-            ! !DESCRIPTION:
-            ! Initialization of elm driver variables needed from previous timestep
-            !$acc routine seq
-            ! !USES:
-            use shr_kind_mod       , only : r8 => shr_kind_r8
-            use elm_varpar         , only : nlevsno
-            use elm_varcon         , only : h2osno_max
-            use landunit_varcon    , only : istice_mec
-            use CanopyStateType    , only : canopystate_type
-            use EnergyFluxType     , only : energyflux_type
-            !
-            ! !ARGUMENTS:
-            type(bounds_type)     , intent(in)    :: bounds
-            integer               , intent(in)    :: num_nolakec       ! number of non-lake points in column filter
-            integer               , intent(in)    :: filter_nolakec(:) ! column filter for non-lake points
-            integer               , intent(in)    :: num_nolakep       ! number of non-lake points in patch filter
-            integer               , intent(in)    :: filter_nolakep(:) ! patch filter for non-lake points
-            integer               , intent(in)    :: num_soilp         ! number of soil points in patch filter
-            integer               , intent(in)    :: filter_soilp(:)   ! patch filter for soil points
-            type(canopystate_type), intent(inout) :: canopystate_vars
-            type(energyflux_type) , intent(inout) :: energyflux_vars
-            !
-            ! !LOCAL VARIABLES:
-            integer :: l, c, p, f, j         ! indices
-            integer :: fp, fc                  ! filter indices
-            !-----------------------------------------------------------------------
-            
-            associate(                                       &
-               snl                => col_pp%snl          , & ! Input:  [integer  (:)   ]  number of snow layers
-               h2osno             => col_ws%h2osno       , & ! Input:  [real(r8) (:)   ]  snow water (mm H2O)
-               h2osoi_ice         => col_ws%h2osoi_ice   , & ! Input:  [real(r8) (:,:) ]  ice lens (kg/m2)
-               h2osoi_liq         => col_ws%h2osoi_liq   , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2)
-               do_capsnow         => col_ws%do_capsnow   , & ! Output: [logical  (:)   ]  true => do snow capping
-               h2osno_old         => col_ws%h2osno_old   , & ! Output: [real(r8) (:)   ]  snow water (mm H2O) at previous time step
-               frac_iceold        => col_ws%frac_iceold  , & ! Output: [real(r8) (:,:) ]  fraction of ice relative to the tot water
-               elai               => canopystate_vars%elai_patch               , & ! Input:  [real(r8) (:)   ]  one-sided leaf area index with burying by snow
-               esai               => canopystate_vars%esai_patch               , & ! Input:  [real(r8) (:)   ]  one-sided stem area index with burying by snow
-               frac_veg_nosno     => canopystate_vars%frac_veg_nosno_patch     , & ! Output: [integer  (:)   ]  fraction of vegetation not covered by snow (0 OR 1) [-]
-               frac_veg_nosno_alb => canopystate_vars%frac_veg_nosno_alb_patch , & ! Output: [integer  (:)   ]  fraction of vegetation not covered by snow (0 OR 1) [-]
-               qflx_glcice        => col_wf%qflx_glcice   , & ! Output: [real(r8) (:)   ]  flux of new glacier ice (mm H2O/s) [+ = ice grows]
-               eflx_bot           => col_ef%eflx_bot      , & ! Output: [real(r8) (:)   ]  heat flux from beneath soil/ice column (W/m**2)
-               cisun_z            => photosyns_vars%cisun_z_patch , & ! Output: [real(r8) (:)   ]  intracellular sunlit leaf CO2 (Pa)
-               cisha_z            => photosyns_vars%cisha_z_patch   & ! Output: [real(r8) (:)   ]  intracellular shaded leaf CO2 (Pa)
-               )
-               ! Initialize intracellular CO2 (Pa) parameters each timestep for use in VOCEmission
-               do p = bounds%begp,bounds%endp
-                  cisun_z(p,:) = -999._r8
-                  cisha_z(p,:) = -999._r8
-               end do
-               
-               do c = bounds%begc,bounds%endc
-                  l = col_pp%landunit(c)
-                  
-                  ! Save snow mass at previous time step
-                  h2osno_old(c) = h2osno(c)
-                  
-                  if (.not. use_extrasnowlayers) then
-                     ! Decide whether to cap snow
-                     if (h2osno(c) > h2osno_max) then
-                        do_capsnow(c) = .true.
-                     else
-                        do_capsnow(c) = .false.
-                     end if
-                     ! else, snow capping subroutine in SnowHydrologyMod
-                  end if
-                  
-                  ! Reset flux from beneath soil/ice column
-                  eflx_bot(c)  = 0._r8
-                  
-                  ! Initialize qflx_glcice everywhere, to zero.
-                  qflx_glcice(c) = 0._r8
-                  
-               end do
-               
-               ! Initialize fraction of vegetation not covered by snow
-               
-               do p = bounds%begp,bounds%endp
-                  if (veg_pp%active(p)) then
-                     frac_veg_nosno(p) = frac_veg_nosno_alb(p)
-                  else
-                     frac_veg_nosno(p) = 0._r8
-                  end if
-               end do
-               
-               ! Initialize set of previous time-step variables
-               ! Ice fraction of snow at previous time step
-               
-               do j = -nlevsno+1,0
-                  do f = 1, num_nolakec
-                     c = filter_nolakec(f)
-                     if (j >= snl(c) + 1) then
-                        frac_iceold(c,j) = h2osoi_ice(c,j)/(h2osoi_liq(c,j)+h2osoi_ice(c,j))
-                     end if
-                  end do
-               end do
-               
-               end associate
-               
-            end subroutine elm_drv_init
-            
-            !-----------------------------------------------------------------------
-            subroutine elm_drv_patch2col (bounds, num_nolakec, filter_nolakec, &
-               energyflux_vars )
-               !
-               ! !DESCRIPTION:
-               ! Averages over all patchs for variables defined over both soil and lake
-               ! to provide the column-level averages of state and flux variables
-               ! defined at the patch level.
-               !
-               ! NOTE:  Test creation of new p2c_1d_filter that is called within a parallel
-               !        loop
-               !$acc routine seq
-               ! !USES:
-               use EnergyFluxType , only : energyflux_type
-               use subgridAveMod  , only : p2c
-               !
-               ! !ARGUMENTS:
-               type(bounds_type)     , intent(in)    :: bounds
-               integer               , intent(in)    :: num_nolakec       ! number of column non-lake points in column filter
-               integer               , intent(in)    :: filter_nolakec(:) ! column filter for non-lake points
-               type(energyflux_type) , intent(inout) :: energyflux_vars
-               !
-               ! !LOCAL VARIABLES:
-               integer :: c,fc              ! indices
-               integer :: num_allc          ! number of active column points
-               integer :: filter_allc(bounds%endp-bounds%begp+1)    ! filter for all active column points
-               ! -----------------------------------------------------------------
-               associate( &
-                  h2ocan_patch       => veg_ws%h2ocan , &
-                  h2ocan_col         => col_ws%h2ocan , &
-                  qflx_ev_snow_patch => veg_wf%qflx_ev_snow , &
-                  qflx_ev_snow_col   => col_wf%qflx_ev_snow, &
-                  qflx_ev_soil_patch =>veg_wf%qflx_ev_soil ,&
-                  qflx_ev_soil_col   =>col_wf%qflx_ev_soil ,&
-                  qflx_ev_h2osfc_patch => veg_wf%qflx_ev_h2osfc , &
-                  qflx_ev_h2osfc_col   => col_wf%qflx_ev_h2osfc , &
-                  qflx_evap_soi_patch => veg_wf%qflx_evap_soi   , &
-                  qflx_evap_soi_col   => col_wf%qflx_evap_soi   , &
-                  qflx_evap_tot_patch => veg_wf%qflx_evap_tot   , &
-                  qflx_evap_tot_col   => col_wf%qflx_evap_tot   , &
-                  qflx_rain_grnd_patch => veg_wf%qflx_rain_grnd , &
-                  qflx_rain_grnd_col   => col_wf%qflx_rain_grnd , &
-                  qflx_snow_grnd_patch => veg_wf%qflx_snow_grnd , &
-                  qflx_snow_grnd_col   => col_wf%qflx_snow_grnd , &
-                  qflx_snwcp_liq_patch => veg_wf%qflx_snwcp_liq , &
-                  qflx_snwcp_liq_col   => col_wf%qflx_snwcp_liq , &
-                  qflx_snwcp_ice_patch => veg_wf%qflx_snwcp_ice , &
-                  qflx_snwcp_ice_col   => col_wf%qflx_snwcp_ice , &
-                  qflx_tran_veg_patch  => veg_wf%qflx_tran_veg  , &
-                  qflx_tran_veg_col    => col_wf%qflx_tran_veg  , &
-                  qflx_evap_grnd_patch => veg_wf%qflx_evap_grnd , &
-                  qflx_evap_grnd_col   => col_wf%qflx_evap_grnd , &
-                  qflx_prec_grnd_patch => veg_wf%qflx_prec_grnd , &
-                  qflx_prec_grnd_col   => col_wf%qflx_prec_grnd , &
-                  qflx_dew_grnd_patch  => veg_wf%qflx_dew_grnd  , &
-                  qflx_dew_grnd_col    => col_wf%qflx_dew_grnd  , &
-                  qflx_dirct_rain_patch => veg_wf%qflx_dirct_rain , &
-                  qflx_dirct_rain_col   => col_wf%qflx_dirct_rain , &
-                  qflx_leafdrip_patch   => veg_wf%qflx_leafdrip   , &
-                  qflx_leafdrip_col     => col_wf%qflx_leafdrip   , &
-                  qflx_sub_snow_patch   => veg_wf%qflx_sub_snow   , &
-                  qflx_sub_snow_col     => col_wf%qflx_sub_snow   , &
-                  qflx_dew_snow_patch   => veg_wf%qflx_dew_snow   , &
-                  qflx_dew_snow_col     => col_wf%qflx_dew_snow   , &
-                  qflx_irrig_patch     => veg_wf%qflx_irrig_patch , &
-                  qflx_irrig_col       => col_wf%qflx_irrig       , &
-                  qflx_evap_veg_patch  => veg_wf%qflx_evap_veg    , &
-                  qflx_evap_veg_col    => col_wf%qflx_evap_veg     &
-                  )
-                  ! Set up a filter for all active column points
-                  
-                  fc = 0
-                  do c = bounds%begc,bounds%endc
-                     if (col_pp%active(c)) then
-                        fc = fc + 1
-                        filter_allc(fc) = c
-                     end if
-                  end do
-                  num_allc = fc
-                  
-                  ! Note: lake points are excluded from many of the following
-                  ! averages. For some fields, this is because the field doesn't
-                  ! apply over lakes. However, for many others, this is because the
-                  ! field is computed in LakeHydrologyMod, which is called after
-                  ! this routine; thus, for lakes, the column-level values of these
-                  ! fields are explicitly set in LakeHydrologyMod. (The fields that
-                  ! are included here for lakes are computed elsewhere, e.g., in
-                  ! LakeFluxesMod.)
-                  
-                  ! Averaging for patch water state variables
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  h2ocan_patch(bounds%begp:bounds%endp), &
-                  h2ocan_col(bounds%begc:bounds%endc))
-                  
-                  ! Averaging for patch evaporative flux variables
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_ev_snow_patch(bounds%begp:bounds%endp), &
-                  qflx_ev_snow_col(bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_ev_soil_patch(bounds%begp:bounds%endp), &
-                  qflx_ev_soil_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_ev_h2osfc_patch(bounds%begp:bounds%endp), &
-                  qflx_ev_h2osfc_col  (bounds%begc:bounds%endc))
-                  
-                  ! Averaging for patch water flux variables
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_evap_soi_patch(bounds%begp:bounds%endp), &
-                  qflx_evap_soi_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_evap_tot_patch(bounds%begp:bounds%endp), &
-                  qflx_evap_tot_col(bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_rain_grnd_patch(bounds%begp:bounds%endp), &
-                  qflx_rain_grnd_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_snow_grnd_patch(bounds%begp:bounds%endp), &
-                  qflx_snow_grnd_col  (bounds%begc:bounds%endc))
-                  #ifndef _OPENACC
-                  if (.not. use_extrasnowlayers) then
-                     call p2c (bounds, num_allc, filter_allc, &
-                     veg_wf%qflx_snwcp_liq(bounds%begp:bounds%endp), &
-                     col_wf%qflx_snwcp_liq(bounds%begc:bounds%endc))
-                     !TODO - WJS has suggested that at this point qflx_snwcp_liq_patch should
-                     ! now be set to nan in order to ensure that this variable is not used
-                     ! for the remainder of the timestep - other variables where this should
-                     ! occur in this routine should be examined as well
-                     
-                     ! For lakes, this field is initially set in LakeFluxesMod (which
-                     ! is called before this routine; hence it is appropriate to
-                     ! include lake columns in this p2c call.  However, it is later
-                     ! overwritten in LakeHydrologyMod, both on the patch and the column
-                     ! level.
-                     
-                     call p2c (bounds, num_allc, filter_allc, &
-                          veg_wf%qflx_snwcp_ice(bounds%begp:bounds%endp), &
-                          col_wf%qflx_snwcp_ice(bounds%begc:bounds%endc))
-                  end if
-                  #ENDIF
-                  call p2c (bounds, num_allc, filter_allc, &
-                  qflx_snwcp_liq_patch(bounds%begp:bounds%endp), &
-                  qflx_snwcp_liq_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_tran_veg_patch(bounds%begp:bounds%endp), &
-                  qflx_tran_veg_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_evap_grnd_patch(bounds%begp:bounds%endp), &
-                  qflx_evap_grnd_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_allc, filter_allc, &
-                  qflx_evap_soi_patch(bounds%begp:bounds%endp), &
-                  qflx_evap_soi_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_prec_grnd_patch(bounds%begp:bounds%endp), &
-                  qflx_prec_grnd_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_dew_grnd_patch(bounds%begp:bounds%endp), &
-                  qflx_dew_grnd_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_dirct_rain_patch(bounds%begp:bounds%endp), &
-                  qflx_dirct_rain_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_leafdrip_patch(bounds%begp:bounds%endp), &
-                  qflx_leafdrip_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_sub_snow_patch(bounds%begp:bounds%endp), &
-                  qflx_sub_snow_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_dew_snow_patch(bounds%begp:bounds%endp), &
-                  qflx_dew_snow_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_irrig_patch(bounds%begp:bounds%endp), &
-                  qflx_irrig_col  (bounds%begc:bounds%endc))
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_tran_veg_patch(bounds%begp:bounds%endp), &
-                  qflx_tran_veg_col  (bounds%begc:bounds%endc) )
-                  
-                  call p2c (bounds, num_nolakec, filter_nolakec, &
-                  qflx_evap_veg_patch(bounds%begp:bounds%endp), &
-                  qflx_evap_veg_col  (bounds%begc:bounds%endc))
-                  
-                  end associate
-                  
-               end subroutine elm_drv_patch2col
-               
-               !------------------------------------------------------------------------
-               subroutine write_diagnostic (bounds, wrtdia, nstep, lnd2atm_vars)
-                  !
-                  ! !DESCRIPTION:
-                  ! Write diagnostic surface temperature output each timestep.  Written to
-                  ! be fast but not bit-for-bit because order of summations can change each
-                  ! timestep.
-                  !
-                  ! !USES:
-                  use decompMod  , only : get_proc_global
-                  use spmdMod    , only : masterproc, npes, MPI_REAL8
-                  use spmdMod    , only : MPI_STATUS_SIZE, mpicom, MPI_SUM
-                  use shr_sys_mod, only : shr_sys_flush
-                  use abortutils , only : endrun
-                  use shr_log_mod, only : errMsg => shr_log_errMsg
-                  use lnd2atmType, only : lnd2atm_type
-                  !
-                  ! !ARGUMENTS:
-                  type(bounds_type)  , intent(in) :: bounds
-                  logical            , intent(in) :: wrtdia     !true => write diagnostic
-                  integer            , intent(in) :: nstep      !model time step
-                  type(lnd2atm_type) , intent(in) :: lnd2atm_vars
-                  !
-                  ! !REVISION HISTORY:
-                  ! Created by Mariana Vertenstein
-                  !
-                  ! !LOCAL VARIABLES:
-                  integer :: p                       ! loop index
-                  integer :: numg                    ! total number of gridcells across all processors
-                  integer :: ier                     ! error status
-                  real(r8):: psum                    ! partial sum of ts
-                  real(r8):: tsum                    ! sum of ts
-                  real(r8):: tsxyav                  ! average ts for diagnostic output
-                  integer :: status(MPI_STATUS_SIZE) ! mpi status
-                  character(len=256)   :: dateTimeString
-                  !------------------------------------------------------------------------
-                  
-                  call get_proc_global(ng=numg)
-                  
-                  if (wrtdia) then
-                     
-                     call t_barrierf('sync_write_diag', mpicom)
-                     psum = sum(lnd2atm_vars%t_rad_grc(bounds%begg:bounds%endg))
-                     call mpi_reduce(psum, tsum, 1, MPI_REAL8, MPI_SUM, 0, mpicom, ier)
-                     if (ier/=0) then
-                        write(iulog,*) 'write_diagnostic: Error in mpi_reduce()'
-                        call endrun(msg=errMsg(__FILE__, __LINE__))
-                     end if
-                     if (masterproc) then
-                        tsxyav = tsum / numg
-                        write(iulog,1000) nstep, tsxyav
-                        call shr_sys_flush(iulog)
-                     end if
-                     
-                  else
-                     
-                     #ifndef CPL_BYPASS
-                     call get_curr_time_string(dateTimeString)
-                     if (masterproc) then
-                        write(iulog,*)'   Completed timestep: ',trim(dateTimeString)
-                        call shr_sys_flush(iulog)
-                     end if
-                     #endif
-                     
-                  endif
-                  
-                  1000 format (1x,'nstep = ',i10,'   TS = ',f21.15)
-                  
-               end subroutine write_diagnostic
-               
-               subroutine zero_elm_weights(bounds)
-                  ! Zeroes the weights of variables 
-                  ! at start of elm timestep 
-                  implicit none 
-                  type(bounds_type), intent(in) :: bounds 
-                  integer :: p, g ,c, j
-                  ! Vegetation
-                  !$acc parallel loop independent gang vector default(present) 
-                  do p = bounds%begp,bounds%endp
-                     !C
-                     veg_cs%dispvegc(p) = 0._r8
-                     veg_cs%storvegc(p) = 0._r8
-                     veg_cs%totpftc(p)  = 0._r8
-                     !N
-                     veg_ns%dispvegn(p) = 0._r8
-                     veg_ns%storvegn(p) = 0._r8
-                     veg_ns%totvegn(p)  = 0._r8
-                     veg_ns%totpftn(p)  = 0._r8
-                     !P
-                     veg_ps%dispvegp(p) = 0._r8
-                     veg_ps%storvegp(p) = 0._r8
-                     veg_ps%totvegp(p)  = 0._r8
-                     veg_ps%totpftp(p)  = 0._r8
-                  end do
-                  
-                  ! if (use_c13) then
-                  !      call c13_grc_cf%ZeroDWT(bounds_clump)
-                  !      call c13_col_cf%ZeroDWT(bounds_clump)
-                  ! end if
-                  ! if (use_c14) then
-                  !      call c14_grc_cf%ZeroDWT(bounds_clump)
-                  !      call c14_col_cf%ZeroDWT(bounds_clump)
-                  ! end if
-                  !$acc parallel loop independent gang vector default(present)
-                  do g = bounds%begg, bounds%endg
-                     grc_cf%dwt_seedc_to_leaf(g)         = 0._r8
-                     grc_cf%dwt_seedc_to_deadstem(g)     = 0._r8
-                     grc_cf%dwt_conv_cflux(g)            = 0._r8
-                     grc_cf%dwt_prod10c_gain(g)          = 0._r8
-                     grc_cf%dwt_prod100c_gain(g)         = 0._r8
-                     grc_cf%hrv_deadstemc_to_prod10c(g)  = 0._r8
-                     grc_cf%hrv_deadstemc_to_prod100c(g) = 0._r8
-                     !
-                     grc_nf%dwt_seedn_to_leaf(g)     = 0._r8
-                     grc_nf%dwt_seedn_to_deadstem(g) = 0._r8
-                     grc_nf%dwt_conv_nflux(g)        = 0._r8
-                     grc_nf%dwt_seedn_to_npool(g)    = 0._r8
-                     grc_nf%dwt_prod10n_gain(g)      = 0._r8
-                     grc_nf%dwt_prod100n_gain(g)     = 0._r8
-                     !
-                     grc_pf%dwt_seedp_to_leaf(g)     = 0._r8
-                     grc_pf%dwt_seedp_to_deadstem(g) = 0._r8
-                     grc_pf%dwt_conv_pflux(g)        = 0._r8
-                     grc_pf%dwt_seedp_to_ppool(g)    = 0._r8
-                     grc_pf%dwt_prod10p_gain(g)      = 0._r8
-                     grc_pf%dwt_prod100p_gain(g)     = 0._r8
-                     !
-                  end do
-                  
-                  !COLUMN VARIABLES
-                  !$acc parallel loop independent gang vector default(present) 
-                  do c = bounds%begc,bounds%endc
-                     col_cf%dwt_conv_cflux(c)           = 0._r8
-                     col_cf%dwt_prod10c_gain(c)         = 0._r8
-                     col_cf%dwt_prod100c_gain(c)        = 0._r8
-                     col_cf%dwt_crop_productc_gain(c)   = 0._r8
-                     col_cf%dwt_slash_cflux(c)          = 0._r8
-                     
-                     col_nf%dwt_conv_nflux(c)        = 0._r8
-                     col_nf%dwt_prod10n_gain(c)      = 0._r8
-                     col_nf%dwt_prod100n_gain(c)     = 0._r8
-                     col_nf%dwt_crop_productn_gain(c)= 0._r8
-                     col_nf%dwt_slash_nflux(c)       = 0._r8
-                     !
-                     col_pf%dwt_conv_pflux(c)        = 0._r8
-                     col_pf%dwt_prod10p_gain(c)      = 0._r8
-                     col_pf%dwt_prod100p_gain(c)     = 0._r8
-                     col_pf%dwt_crop_productp_gain(c) = 0._r8
-                     col_pf%dwt_slash_pflux(c)       = 0._r8
-                  end do
-                  
-                  !$acc parallel loop independent gang worker default(present)
-                  do j = 1, nlevdecomp_full
-                     !$acc loop vector independent 
-                     do c = bounds%begc,bounds%endc
-                        col_cf%dwt_frootc_to_litr_met_c(c,j)    = 0._r8
-                        col_cf%dwt_frootc_to_litr_cel_c(c,j)    = 0._r8
-                        col_cf%dwt_frootc_to_litr_lig_c(c,j)    = 0._r8
-                        col_cf%dwt_livecrootc_to_cwdc(c,j)      = 0._r8
-                        col_cf%dwt_deadcrootc_to_cwdc(c,j)      = 0._r8
-                        !
-                        col_nf%dwt_frootn_to_litr_met_n(c,j) = 0._r8
-                        col_nf%dwt_frootn_to_litr_cel_n(c,j) = 0._r8
-                        col_nf%dwt_frootn_to_litr_lig_n(c,j) = 0._r8
-                        col_nf%dwt_livecrootn_to_cwdn(c,j)   = 0._r8
-                        col_nf%dwt_deadcrootn_to_cwdn(c,j)   = 0._r8
-                        !
-                        col_pf%dwt_frootp_to_litr_met_p(c,j) = 0._r8
-                        col_pf%dwt_frootp_to_litr_cel_p(c,j) = 0._r8
-                        col_pf%dwt_frootp_to_litr_lig_p(c,j) = 0._r8
-                        col_pf%dwt_livecrootp_to_cwdp(c,j)   = 0._r8
-                        col_pf%dwt_deadcrootp_to_cwdp(c,j)   = 0._r8
-                     end do
-                  end do
-                  
-                  
-               end subroutine zero_elm_weights
-               
-            end module elm_driver
-            
-            
+    end associate
+
+  end subroutine elm_drv_init
+
+  !-----------------------------------------------------------------------
+  subroutine elm_drv_patch2col (bounds, num_nolakec, filter_nolakec, &
+         energyflux_vars )
+    !
+    ! !DESCRIPTION:
+    ! Averages over all patchs for variables defined over both soil and lake
+    ! to provide the column-level averages of state and flux variables
+    ! defined at the patch level.
+    !
+    ! !USES:
+    use EnergyFluxType , only : energyflux_type
+    use subgridAveMod  , only : p2c
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)     , intent(in)    :: bounds
+    integer               , intent(in)    :: num_nolakec       ! number of column non-lake points in column filter
+    integer               , intent(in)    :: filter_nolakec(:) ! column filter for non-lake points
+    type(energyflux_type) , intent(inout) :: energyflux_vars
+    !
+    ! !LOCAL VARIABLES:
+    integer :: c,fc              ! indices
+    integer :: num_allc          ! number of active column points
+    integer :: filter_allc(bounds%endp-bounds%begp+1)    ! filter for all active column points
+    ! -----------------------------------------------------------------
+    associate( &
+      h2ocan_patch       => veg_ws%h2ocan , &
+      h2ocan_col         => col_ws%h2ocan , &
+      qflx_ev_snow_patch => veg_wf%qflx_ev_snow , &
+      qflx_ev_snow_col   => col_wf%qflx_ev_snow, &
+      qflx_ev_soil_patch =>veg_wf%qflx_ev_soil ,&
+      qflx_ev_soil_col   =>col_wf%qflx_ev_soil ,&
+      qflx_ev_h2osfc_patch => veg_wf%qflx_ev_h2osfc , &
+      qflx_ev_h2osfc_col   => col_wf%qflx_ev_h2osfc , &
+      qflx_evap_soi_patch => veg_wf%qflx_evap_soi   , &
+      qflx_evap_soi_col   => col_wf%qflx_evap_soi   , &
+      qflx_evap_tot_patch => veg_wf%qflx_evap_tot   , &
+      qflx_evap_tot_col   => col_wf%qflx_evap_tot   , &
+      qflx_rain_grnd_patch => veg_wf%qflx_rain_grnd , &
+      qflx_rain_grnd_col   => col_wf%qflx_rain_grnd , &
+      qflx_snow_grnd_patch => veg_wf%qflx_snow_grnd , &
+      qflx_snow_grnd_col   => col_wf%qflx_snow_grnd , &
+      qflx_snwcp_liq_patch => veg_wf%qflx_snwcp_liq , &
+      qflx_snwcp_liq_col   => col_wf%qflx_snwcp_liq , &
+      qflx_snwcp_ice_patch => veg_wf%qflx_snwcp_ice , &
+      qflx_snwcp_ice_col   => col_wf%qflx_snwcp_ice , &
+      qflx_tran_veg_patch  => veg_wf%qflx_tran_veg  , &
+      qflx_tran_veg_col    => col_wf%qflx_tran_veg  , &
+      qflx_evap_grnd_patch => veg_wf%qflx_evap_grnd , &
+      qflx_evap_grnd_col   => col_wf%qflx_evap_grnd , &
+      qflx_prec_grnd_patch => veg_wf%qflx_prec_grnd , &
+      qflx_prec_grnd_col   => col_wf%qflx_prec_grnd , &
+      qflx_dew_grnd_patch  => veg_wf%qflx_dew_grnd  , &
+      qflx_dew_grnd_col    => col_wf%qflx_dew_grnd  , &
+      qflx_dirct_rain_patch => veg_wf%qflx_dirct_rain , &
+      qflx_dirct_rain_col   => col_wf%qflx_dirct_rain , &
+      qflx_leafdrip_patch   => veg_wf%qflx_leafdrip   , &
+      qflx_leafdrip_col     => col_wf%qflx_leafdrip   , &
+      qflx_sub_snow_patch   => veg_wf%qflx_sub_snow   , &
+      qflx_sub_snow_col     => col_wf%qflx_sub_snow   , &
+      qflx_dew_snow_patch   => veg_wf%qflx_dew_snow   , &
+      qflx_dew_snow_col     => col_wf%qflx_dew_snow   , &
+      qflx_irrig_patch     => veg_wf%qflx_irrig_patch , &
+      qflx_irrig_col       => col_wf%qflx_irrig       , &
+      qflx_evap_veg_patch  => veg_wf%qflx_evap_veg    , &
+      qflx_evap_veg_col    => col_wf%qflx_evap_veg     &
+      )
+    ! Set up a filter for all active column points
+
+    fc = 0
+    do c = bounds%begc,bounds%endc
+       if (col_pp%active(c)) then
+          fc = fc + 1
+          filter_allc(fc) = c
+       end if
+    end do
+    num_allc = fc
+
+    ! Note: lake points are excluded from many of the following
+    ! averages. For some fields, this is because the field doesn't
+    ! apply over lakes. However, for many others, this is because the
+    ! field is computed in LakeHydrologyMod, which is called after
+    ! this routine; thus, for lakes, the column-level values of these
+    ! fields are explicitly set in LakeHydrologyMod. (The fields that
+    ! are included here for lakes are computed elsewhere, e.g., in
+    ! LakeFluxesMod.)
+
+    ! Averaging for patch water state variables
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         h2ocan_patch(bounds%begp:bounds%endp), &
+         h2ocan_col(bounds%begc:bounds%endc))
+
+    ! Averaging for patch evaporative flux variables
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_ev_snow_patch(bounds%begp:bounds%endp), &
+         qflx_ev_snow_col(bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_ev_soil_patch(bounds%begp:bounds%endp), &
+         qflx_ev_soil_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_ev_h2osfc_patch(bounds%begp:bounds%endp), &
+         qflx_ev_h2osfc_col  (bounds%begc:bounds%endc))
+
+    ! Averaging for patch water flux variables
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_evap_soi_patch(bounds%begp:bounds%endp), &
+         qflx_evap_soi_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_evap_tot_patch(bounds%begp:bounds%endp), &
+         qflx_evap_tot_col(bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_rain_grnd_patch(bounds%begp:bounds%endp), &
+         qflx_rain_grnd_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_snow_grnd_patch(bounds%begp:bounds%endp), &
+         qflx_snow_grnd_col  (bounds%begc:bounds%endc))
+
+    if (.not. use_extrasnowlayers) then
+       call p2c (bounds, num_allc, filter_allc, &
+            veg_wf%qflx_snwcp_liq(bounds%begp:bounds%endp), &
+            col_wf%qflx_snwcp_liq(bounds%begc:bounds%endc))
+            !TODO - WJS has suggested that at this point qflx_snwcp_liq_patch should
+            ! now be set to nan in order to ensure that this variable is not used
+            ! for the remainder of the timestep - other variables where this should
+            ! occur in this routine should be examined as well
+
+            ! For lakes, this field is initially set in LakeFluxesMod (which
+            ! is called before this routine; hence it is appropriate to
+            ! include lake columns in this p2c call.  However, it is later
+            ! overwritten in LakeHydrologyMod, both on the patch and the column
+            ! level.
+
+       call p2c (bounds, num_allc, filter_allc, &
+            veg_wf%qflx_snwcp_ice(bounds%begp:bounds%endp), &
+            col_wf%qflx_snwcp_ice(bounds%begc:bounds%endc))
+    end if
+
+    call p2c (bounds, num_allc, filter_allc, &
+         qflx_snwcp_liq_patch(bounds%begp:bounds%endp), &
+         qflx_snwcp_liq_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_tran_veg_patch(bounds%begp:bounds%endp), &
+         qflx_tran_veg_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_evap_grnd_patch(bounds%begp:bounds%endp), &
+         qflx_evap_grnd_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_allc, filter_allc, &
+         qflx_evap_soi_patch(bounds%begp:bounds%endp), &
+         qflx_evap_soi_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_prec_grnd_patch(bounds%begp:bounds%endp), &
+         qflx_prec_grnd_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_dew_grnd_patch(bounds%begp:bounds%endp), &
+         qflx_dew_grnd_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_dirct_rain_patch(bounds%begp:bounds%endp), &
+         qflx_dirct_rain_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_leafdrip_patch(bounds%begp:bounds%endp), &
+         qflx_leafdrip_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_sub_snow_patch(bounds%begp:bounds%endp), &
+         qflx_sub_snow_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_dew_snow_patch(bounds%begp:bounds%endp), &
+         qflx_dew_snow_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_irrig_patch(bounds%begp:bounds%endp), &
+         qflx_irrig_col  (bounds%begc:bounds%endc))
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_tran_veg_patch(bounds%begp:bounds%endp), &
+         qflx_tran_veg_col  (bounds%begc:bounds%endc) )
+
+    call p2c (bounds, num_nolakec, filter_nolakec, &
+         qflx_evap_veg_patch(bounds%begp:bounds%endp), &
+         qflx_evap_veg_col  (bounds%begc:bounds%endc))
+
+    end associate
+
+  end subroutine elm_drv_patch2col
+
+  !------------------------------------------------------------------------
+  subroutine write_diagnostic (bounds, wrtdia, nstep, lnd2atm_vars)
+    !
+    ! !DESCRIPTION:
+    ! Write diagnostic surface temperature output each timestep.  Written to
+    ! be fast but not bit-for-bit because order of summations can change each
+    ! timestep.
+    !
+    ! !USES:
+    use decompMod  , only : get_proc_global
+    use spmdMod    , only : masterproc, npes, MPI_REAL8
+    use spmdMod    , only : MPI_STATUS_SIZE, mpicom, MPI_SUM
+    use shr_sys_mod, only : shr_sys_flush
+    use abortutils , only : endrun
+    use shr_log_mod, only : errMsg => shr_log_errMsg
+    use lnd2atmType, only : lnd2atm_type
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)  , intent(in) :: bounds
+    logical            , intent(in) :: wrtdia     !true => write diagnostic
+    integer            , intent(in) :: nstep      !model time step
+    type(lnd2atm_type) , intent(in) :: lnd2atm_vars
+    !
+    ! !REVISION HISTORY:
+    ! Created by Mariana Vertenstein
+    !
+    ! !LOCAL VARIABLES:
+    integer :: p                       ! loop index
+    integer :: numg                    ! total number of gridcells across all processors
+    integer :: ier                     ! error status
+    real(r8):: psum                    ! partial sum of ts
+    real(r8):: tsum                    ! sum of ts
+    real(r8):: tsxyav                  ! average ts for diagnostic output
+    integer :: status(MPI_STATUS_SIZE) ! mpi status
+    character(len=256)   :: dateTimeString
+    !------------------------------------------------------------------------
+
+    call get_proc_global(ng=numg)
+
+    if (wrtdia) then
+
+       call t_barrierf('sync_write_diag', mpicom)
+       psum = sum(lnd2atm_vars%t_rad_grc(bounds%begg:bounds%endg))
+       call mpi_reduce(psum, tsum, 1, MPI_REAL8, MPI_SUM, 0, mpicom, ier)
+       if (ier/=0) then
+          write(iulog,*) 'write_diagnostic: Error in mpi_reduce()'
+          call endrun(msg=errMsg(__FILE__, __LINE__))
+       end if
+       if (masterproc) then
+          tsxyav = tsum / numg
+          write(iulog,1000) nstep, tsxyav
+          call shr_sys_flush(iulog)
+       end if
+
+    else
+
+#ifndef CPL_BYPASS
+       call get_curr_time_string(dateTimeString)
+       if (masterproc) then
+          write(iulog,*)'   Completed timestep: ',trim(dateTimeString)
+          call shr_sys_flush(iulog)
+       end if
+#endif
+
+    endif
+
+1000 format (1x,'nstep = ',i10,'   TS = ',f21.15)
+
+  end subroutine write_diagnostic
+
+end module elm_driver
diff --git a/components/elm/src/main/elm_initializeMod.F90 b/components/elm/src/main/elm_initializeMod.F90
index a5afbbb736..4ff34497d0 100644
--- a/components/elm/src/main/elm_initializeMod.F90
+++ b/components/elm/src/main/elm_initializeMod.F90
@@ -79,8 +79,6 @@ contains
     use ExternalModelInterfaceMod , only: EMI_Determine_Active_EMs
     use dynSubgridControlMod      , only: dynSubgridControl_init
     use filterMod                 , only: allocFilters
-    use filterMod                 , only : proc_filter, proc_filter_inactive_and_active
-    use filterMod                 , only : createProcessorFilter, setProcFilters  
     use reweightMod               , only: reweight_wrapup
     use ELMFatesInterfaceMod      , only: ELMFatesGlobals
     use topounit_varcon           , only: max_topounits, has_topounit, topounit_varcon_init    
@@ -370,13 +368,7 @@ contains
             ldomain%glcmask(bounds_clump%begg:bounds_clump%endg)*1._r8)
     end do
     !$OMP END PARALLEL DO
-    
-    call createProcessorFilter(nclumps, bounds_proc, proc_filter, ldomain%glcmask(begg:endg)*1._r8)
-    call createProcessorFilter(nclumps, bounds_proc, proc_filter_inactive_and_active, ldomain%glcmask(begg:endg)*1._r8)
-    !!!!$acc enter data copyin (proc_filter, proc_filter_inactive_and_active) 
-    !!! call setProcFilters(bounds_proc, proc_filter, .false., ldomain%glcmask(begg:endg)*1._r8)
-    !!! call setProcFilters(bounds_proc, proc_filter_inactive_and_active, .true., ldomain%glcmask(begg:endg)*1._r8)
-    
+
     ! ------------------------------------------------------------------------
     ! Remainder of initialization1
     ! ------------------------------------------------------------------------
@@ -393,6 +385,7 @@ contains
     ! Some things are kept until the end of initialize2; urban_valid is kept through the
     ! end of the run for error checking.
 
+    !deallocate (wt_lunit, wt_cft, wt_glc_mec)
     deallocate (wt_cft, wt_glc_mec)    !wt_lunit not deallocated because it is being used in CanopyHydrologyMod.F90
     deallocate (wt_tunit, elv_tunit, slp_tunit, asp_tunit,num_tunit_per_grd)
     call t_stopf('elm_init1')
@@ -478,11 +471,6 @@ contains
     use tracer_varcon         , only : is_active_betr_bgc
     use clm_time_manager      , only : is_restart
     use ALMbetrNLMod          , only : betr_namelist_buffer
-    use UrbanParamsType       , only : urban_hac_int, urban_hac_off_int, urban_hac_on_int, urban_wasteheat_int
-    use UrbanParamsType       , only : urban_hac, urban_hac_off, urban_hac_on, urban_wasteheat_on
-    use elm_instMod           , only : patch_state_updater, column_state_updater
-    use subgridAveMod, only :  initialize_scale_l2g_lookup, initialize_scale_c2l
-    use domainMod, only : domain_transfer
     !
     ! !ARGUMENTS
     implicit none
@@ -652,7 +640,7 @@ contains
 
     ! FATES is instantiated in the following call.  The global is in clm_inst
     call elm_inst_biogeochem(bounds_proc)
-    call domain_transfer()
+
     ! ------------------------------------------------------------------------
     ! Initialize accumulated fields
     ! ------------------------------------------------------------------------
@@ -681,9 +669,7 @@ contains
     call print_accum_fields()
 
     call t_stopf('init_accflds')
-    
-    call initialize_scale_l2g_lookup()
-    call initialize_scale_c2l(bounds_proc)
+
     ! ------------------------------------------------------------------------
     ! Initializate dynamic subgrid weights (for prescribed transient Patches,
     ! and/or dynamic landunits); note that these will be overwritten in a
@@ -692,7 +678,7 @@ contains
 
     call t_startf('init_dyn_subgrid')
     call init_subgrid_weights_mod(bounds_proc)
-    call dynSubgrid_init(bounds_proc, glc2lnd_vars, crop_vars,patch_state_updater,column_state_updater)
+    call dynSubgrid_init(bounds_proc, glc2lnd_vars, crop_vars)
     call t_stopf('init_dyn_subgrid')
 
     ! ------------------------------------------------------------------------
@@ -832,7 +818,7 @@ contains
        finidat = trim(finidat_interp_dest)
 
     end if
-    print *, "Rewegiths!!!"
+
     !$OMP PARALLEL DO PRIVATE (nc, bounds_clump)
     do nc = 1, nclumps
        call get_clump_bounds(nc, bounds_clump)
@@ -1019,15 +1005,6 @@ contains
        write(iulog,*)
     endif
     call t_stopf('init_wlog')
-    
-    ! Set urban_hac to an integer flag, since "trim" is not supported on GPUs
-    if(trim(urban_hac) == urban_hac_off) then 
-       urban_hac_int = urban_hac_off_int 
-    else if (trim(urban_hac) == urban_hac_on) then 
-       urban_hac_int = urban_hac_on_int
-    elseif(trim(urban_hac) == urban_wasteheat_on) then 
-       urban_hac_int = urban_wasteheat_int
-    end if 
 
     call t_stopf('elm_init2')
 
diff --git a/components/elm/src/main/elm_instMod.F90 b/components/elm/src/main/elm_instMod.F90
index 9f5ce148b1..200185b146 100644
--- a/components/elm/src/main/elm_instMod.F90
+++ b/components/elm/src/main/elm_instMod.F90
@@ -5,9 +5,8 @@ module elm_instMod
   use shr_kind_mod               , only : r8 => shr_kind_r8
   use shr_log_mod                , only : errMsg => shr_log_errMsg
   use abortutils                 , only : endrun
-  use shr_sys_mod                , only : shr_sys_flush
   use decompMod                  , only : bounds_type, get_proc_bounds
-  use elm_varctl                 , only : use_cn, use_voc, use_c13, use_c14, use_fates, use_betr, iulog
+  use elm_varctl                 , only : use_cn, use_voc, use_c13, use_c14, use_fates, use_betr
   !-----------------------------------------
   ! Definition of component types
   !-----------------------------------------
@@ -41,7 +40,7 @@ module elm_instMod
   use WaterfluxType              , only : waterflux_type,   waterflux_vars
   use WaterstateType             , only : waterstate_type, waterstate_vars
   use VOCEmissionMod             , only : vocemis_type
-  use atm2lndType                , only : atm2lnd_type, cplbypass_atminput_type
+  use atm2lndType                , only : atm2lnd_type
   use lnd2atmType                , only : lnd2atm_type
   use lnd2glcMod                 , only : lnd2glc_type
   use glc2lndMod                 , only : glc2lnd_type
@@ -80,10 +79,7 @@ module elm_instMod
   ! instances declared in their own modules
   use UrbanParamsType            , only : urbanparams_vars
   use controlMod                 , only : nlfilename
-  use dynPatchStateUpdaterMod    , only : patch_state_updater_type 
-  use dynColumnStateUpdaterMod   , only : column_state_updater_type 
 
-  use dynUpdateModAcc            , only : patch_su_type_gpu 
 
   !
   implicit none
@@ -134,38 +130,9 @@ module elm_instMod
   type(hlm_fates_interface_type)                      :: alm_fates
   class(betr_simulation_alm_type), pointer            :: ep_betr
   type(PlantMicKinetics_type)                         :: PlantMicKinetics_vars
-  
-  type(cplbypass_atminput_type)                       :: cpl_bypass_input 
-  type(patch_state_updater_type)                      :: patch_state_updater 
-  type(column_state_updater_type)                     :: column_state_updater 
-
   public :: elm_inst_biogeochem
   public :: elm_inst_biogeophys
   public :: alm_fates
-    
-
-  !$acc declare create(ch4_vars)
-  !$acc declare create(crop_vars)
-  !$acc declare create(cnstate_vars)
-  !$acc declare create(dust_vars)
-  !$acc declare create(drydepvel_vars)
-  !$acc declare create(aerosol_vars)
-  !$acc declare create(canopystate_vars)
-  !$acc declare create(energyflux_vars)
-  !$acc declare create(frictionvel_vars)
-  !$acc declare create(lakestate_vars)
-  !$acc declare create(photosyns_vars)
-  !$acc declare create(sedflux_vars)
-  !$acc declare create(soilstate_vars)
-  !$acc declare create(soilhydrology_vars)
-  !$acc declare create(solarabs_vars)
-  !$acc declare create(surfalb_vars)
-  !$acc declare create(surfrad_vars)
-  !$acc declare create(atm2lnd_vars)
-  !$acc declare create(glc2lnd_vars)
-  !$acc declare create(lnd2atm_vars)
-  !$acc declare create(lnd2glc_vars)
-  !$acc declare create(column_state_updater) 
 
 contains
 
@@ -330,8 +297,6 @@ contains
     allocate (h2osno_col(begc:endc))
     allocate (snow_depth_col(begc:endc))
 
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::snow water  " 
-    call shr_sys_flush(iulog)
     ! snow water
     ! Note: Glacier_mec columns are initialized with half the maximum snow cover.
     ! This gives more realistic values of qflx_glcice sooner in the simulation
@@ -377,38 +342,26 @@ contains
     end do
 
    ! Initialize urban constants
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::urbanparams init " 
-    call shr_sys_flush(iulog)
 
     call urbanparams_vars%Init(bounds_proc)
 
     ! Initialize ecophys constants
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::veg_vp init " 
-    call shr_sys_flush(iulog)
 
     call veg_vp%Init()
 
     ! Initialize soil order related constants
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::soilordercon init " 
-    call shr_sys_flush(iulog)
 
     call soilorderconInit()
 
     ! Initialize lake constants
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::LakeConinit " 
-    call shr_sys_flush(iulog)
 
     call LakeConInit()
 
     ! Initialize surface albedo constants
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::SurfaceAlbedoInitTimeConst init " 
-    call shr_sys_flush(iulog)
 
     call SurfaceAlbedoInitTimeConst(bounds_proc)
 
     ! Initialize vertical data components
-    write(iulog,*) "DEBUG: elm_inst_biogeophys ::initvertical " 
-    call shr_sys_flush(iulog)
 
     call initVertical(bounds_proc,               &
          snow_depth_col(begc:endc),              &
@@ -427,8 +380,6 @@ contains
     call lnd2glc_vars%Init( bounds_proc )
 
     ! If single-column determine closest latitude and longitude
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::single column  " 
-    call shr_sys_flush(iulog)
 
     if (single_column) then
        call getfil (fsurdat, locfn, 0)
@@ -446,8 +397,6 @@ contains
     call canopystate_vars%init(bounds_proc)
 
     call soilstate_vars%init(bounds_proc)
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::waterstate  " 
-    call shr_sys_flush(iulog)
 
     call waterstate_vars%init(bounds_proc,         &
          h2osno_col(begc:endc),                    &
@@ -455,8 +404,6 @@ contains
          soilstate_vars%watsat_col(begc:endc, 1:), &
          col_es%t_soisno(begc:endc, -nlevsno+1:) )
 
-    write(iulog,*) "DEBUG: elm_inst_biogeophys :: grc_ws " 
-    call shr_sys_flush(iulog)
     call grc_ws%Init(bounds_proc%begg_all, bounds_proc%endg_all)
     call lun_ws%Init(bounds_proc%begl_all, bounds_proc%endl_all)
     call col_ws%Init(bounds_proc%begc_all, bounds_proc%endc_all, &
@@ -466,8 +413,6 @@ contains
     call veg_ws%Init(bounds_proc%begp_all, bounds_proc%endp_all)
 
     call waterflux_vars%init(bounds_proc)
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::grc_WF  " 
-    call shr_sys_flush(iulog)
 
     call grc_wf%Init(bounds_proc%begg_all, bounds_proc%endg_all, bounds_proc)
     call col_wf%Init(bounds_proc%begc_all, bounds_proc%endc_all)
@@ -477,16 +422,12 @@ contains
     ! WJS (6-24-14): Without the following write statement, the assertion in
     ! energyflux_vars%init fails with pgi 13.9 on yellowstone. So for now, I'm leaving
     ! this write statement in place as a workaround for this problem.
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::energyflux " 
-    call shr_sys_flush(iulog)
     call energyflux_vars%init(bounds_proc, col_es%t_grnd(begc:endc))
 
     call grc_ef%Init(bounds_proc%begg_all, bounds_proc%endg_all)
     call lun_ef%Init(bounds_proc%begl_all, bounds_proc%endl_all)
     call col_ef%Init(bounds_proc%begc_all, bounds_proc%endc_all)
     call veg_ef%Init(bounds_proc%begp_all, bounds_proc%endp_all)
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::drydep " 
-    call shr_sys_flush(iulog)
 
     call drydepvel_vars%Init(bounds_proc)
     call aerosol_vars%Init(bounds_proc)
@@ -494,8 +435,6 @@ contains
     call frictionvel_vars%Init(bounds_proc)
 
     call lakestate_vars%Init(bounds_proc)
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::photosyns " 
-    call shr_sys_flush(iulog)
 
     call photosyns_vars%Init(bounds_proc)
 
@@ -518,8 +457,6 @@ contains
          source=create_soil_water_retention_curve())
 
 
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::ch4 vars " 
-    call shr_sys_flush(iulog)
     ! Note - always initialize the memory for ch4_vars
     call ch4_vars%Init(bounds_proc, soilstate_vars%cellorg_col(begc:endc, 1:))
 
@@ -531,12 +468,8 @@ contains
     ! Initialise the BeTR
     ! --------------------------------------------------------------
 
-    write(iulog,*) "DEBUG: elm_inst_biogeophys::dealoc" 
-    call shr_sys_flush(iulog)
     deallocate (h2osno_col)
     deallocate (snow_depth_col)
-    write(iulog,*) "DEBUG: elm_inst_biogeophys finished " 
-    call shr_sys_flush(iulog)
 
     end subroutine elm_inst_biogeophys
 
diff --git a/components/elm/src/main/elm_interface_funcsMod.F90 b/components/elm/src/main/elm_interface_funcsMod.F90
index c364fbf758..76bc8bffbd 100644
--- a/components/elm/src/main/elm_interface_funcsMod.F90
+++ b/components/elm/src/main/elm_interface_funcsMod.F90
@@ -1397,10 +1397,10 @@ contains
                 phosphorusstate_vars,phosphorusflux_vars)
 
     ! STEP-2: (ii) run SoilLittDecompAlloc
-    !call SoilLittDecompAlloc (bounds, num_soilc, filter_soilc,    &
-    !           num_soilp, filter_soilp,                     &
-    !           canopystate_vars, soilstate_vars,            &
-    !           cnstate_vars, ch4_vars, dt )
+    call SoilLittDecompAlloc (bounds, num_soilc, filter_soilc,    &
+               num_soilp, filter_soilp,                     &
+               canopystate_vars, soilstate_vars,            &
+               cnstate_vars, ch4_vars, dt )
 
     ! STEP-2: (iii) update elm_bgc_data from SoilLittDecompAlloc
     call elm_bgc_update_data(elm_interface_data%bgc, bounds, &
diff --git a/components/elm/src/main/elm_varcon.F90 b/components/elm/src/main/elm_varcon.F90
index e2a4271685..ae29c8633c 100644
--- a/components/elm/src/main/elm_varcon.F90
+++ b/components/elm/src/main/elm_varcon.F90
@@ -43,47 +43,42 @@ module elm_varcon
   real(r8), parameter :: n_melt=0.7                         ! fsca shape parameter
   real(r8), parameter :: e_ice=6.0                          ! soil ice impedance factor
   real(r8), parameter :: pc = 0.4                           ! threshold probability
-  real(r8), parameter :: mu = 0.13889                       ! connectivity exponent
-  real(r8), parameter :: grav   = SHR_CONST_G                          ! gravity constant [m/s2]
-  real(r8), parameter :: sb     = SHR_CONST_STEBOL                     ! stefan-boltzmann constant  [W/m2/K4]
-  real(r8), parameter :: vkc    = SHR_CONST_KARMAN                     ! von Karman constant [-]
-  real(r8), parameter :: rwat   = SHR_CONST_RWV                        ! gas constant for water vapor [J/(kg K)]
-  real(r8), parameter :: rair   = SHR_CONST_RDAIR                      ! gas constant for dry air [J/kg/K]
-  real(r8), parameter :: roverg = SHR_CONST_RWV/SHR_CONST_G*1000._r8   ! Rw/g constant = (8.3144/0.018)/(9.80616)*1000. mm/K
-  real(r8), parameter :: cpliq  = SHR_CONST_CPFW                       ! Specific heat of water [J/kg-K]
-  real(r8), parameter :: cpice  = SHR_CONST_CPICE                      ! Specific heat of ice [J/kg-K]
-  real(r8), parameter :: cpair  = SHR_CONST_CPDAIR                     ! specific heat of dry air [J/kg/K]
-  real(r8), parameter :: hvap   = SHR_CONST_LATVAP                     ! Latent heat of evap for water [J/kg]
-  real(r8), parameter :: hsub   = SHR_CONST_LATSUB                     ! Latent heat of sublimation    [J/kg]
-  real(r8), parameter :: hfus   = SHR_CONST_LATICE                     ! Latent heat of fusion for ice [J/kg]
-  real(r8), parameter :: denh2o = SHR_CONST_RHOFW                      ! density of liquid water [kg/m3]
-  real(r8), parameter :: denice = SHR_CONST_RHOICE                     ! density of ice [kg/m3]
-  real(r8), parameter :: rgas   = SHR_CONST_RGAS                       ! universal gas constant [J/K/kmole]
-  real(r8), parameter :: tkair  = 0.023_r8                             ! thermal conductivity of air   [W/m/K]
-  real(r8), parameter :: tkice  = 2.290_r8                             ! thermal conductivity of ice   [W/m/K]
-  real(r8), parameter :: tkwat  = 0.57_r8                              ! thermal conductivity of water [W/m/K]
+  real(r8), parameter :: mu = 0.13889                       ! connectivity exponent 
+  real(r8) :: grav   = SHR_CONST_G                          ! gravity constant [m/s2]
+  real(r8) :: sb     = SHR_CONST_STEBOL                     ! stefan-boltzmann constant  [W/m2/K4]
+  real(r8) :: vkc    = SHR_CONST_KARMAN                     ! von Karman constant [-]
+  real(r8) :: rwat   = SHR_CONST_RWV                        ! gas constant for water vapor [J/(kg K)]
+  real(r8) :: rair   = SHR_CONST_RDAIR                      ! gas constant for dry air [J/kg/K]
+  real(r8) :: roverg = SHR_CONST_RWV/SHR_CONST_G*1000._r8   ! Rw/g constant = (8.3144/0.018)/(9.80616)*1000. mm/K
+  real(r8) :: cpliq  = SHR_CONST_CPFW                       ! Specific heat of water [J/kg-K]
+  real(r8) :: cpice  = SHR_CONST_CPICE                      ! Specific heat of ice [J/kg-K]
+  real(r8) :: cpair  = SHR_CONST_CPDAIR                     ! specific heat of dry air [J/kg/K]
+  real(r8) :: hvap   = SHR_CONST_LATVAP                     ! Latent heat of evap for water [J/kg]
+  real(r8) :: hsub   = SHR_CONST_LATSUB                     ! Latent heat of sublimation    [J/kg]
+  real(r8) :: hfus   = SHR_CONST_LATICE                     ! Latent heat of fusion for ice [J/kg]
+  real(r8) :: denh2o = SHR_CONST_RHOFW                      ! density of liquid water [kg/m3]
+  real(r8) :: denice = SHR_CONST_RHOICE                     ! density of ice [kg/m3]
+  real(r8) :: rgas   = SHR_CONST_RGAS                       ! universal gas constant [J/K/kmole]
+  real(r8) :: tkair  = 0.023_r8                             ! thermal conductivity of air   [W/m/K]
+  real(r8) :: tkice  = 2.290_r8                             ! thermal conductivity of ice   [W/m/K]
+  real(r8) :: tkwat  = 0.57_r8                              ! thermal conductivity of water [W/m/K]
   real(r8), parameter :: tfrz   = SHR_CONST_TKFRZ                      ! freezing temperature [K]
   real(r8), parameter :: tcrit  = 2.5_r8                    ! critical temperature to determine rain or snow
   real(r8) :: o2_molar_const = 0.209_r8                     ! constant atmospheric O2 molar ratio (mol/mol)
   real(r8) :: oneatm = 1.01325e5_r8                         ! one standard atmospheric pressure [Pa]
-  !$acc declare copyin(o2_molar_const)
-  !$acc declare copyin(oneatm        )
 
   real(r8) :: bdsno = 250._r8                               ! bulk density snow (kg/m**3)
   real(r8) :: alpha_aero = 1.0_r8                           ! constant for aerodynamic parameter weighting
   real(r8) :: tlsai_crit = 2.0_r8                           ! critical value of elai+esai for which aerodynamic parameters are maximum
   real(r8) :: watmin = 0.01_r8                              ! minimum soil moisture (mm)
-  !$acc declare copyin(bdsno     )
-  !$acc declare copyin(alpha_aero)
-  !$acc declare copyin(tlsai_crit)
-  !$acc declare copyin(watmin    )
+
   real(r8) :: re = SHR_CONST_REARTH*0.001_r8                ! radius of earth (km)
 
   real(r8), public, parameter :: degpsec = 15._r8/3600.0_r8 ! Degree's earth rotates per second
   real(r8), public, parameter ::  secspday= SHR_CONST_CDAY  ! Seconds per day
   integer,  public, parameter :: isecspday= secspday        ! Integer seconds per day
   real(r8), public, parameter ::  spval = 1.e36_r8          ! special value for real data
-  integer , public, parameter :: ispval = -9999             ! special value for int data
+  integer , public, parameter :: ispval = -9999             ! special value for int data 
                                                             ! (keep this negative to avoid conflicts with possible valid values)
 
   ! These are tunable constants from clm2_3
@@ -98,9 +93,8 @@ module elm_varcon
   real(r8) :: pondmx = 0.0_r8       ! Ponding depth (mm)
   real(r8) :: pondmx_urban = 1.0_r8 ! Ponding depth for urban roof and impervious road (mm)
 
-  real(r8) :: thk_bedrock = 3.0_r8  ! thermal conductivity of 'typical' saturated granitic rock
+  real(r8) :: thk_bedrock = 3.0_r8  ! thermal conductivity of 'typical' saturated granitic rock 
                                     ! (Clauser and Huenges, 1995)(W/m/K)
-  !$acc declare copyin(thk_bedrock)
 
   real(r8), parameter :: aquifer_water_baseline = 5000._r8 ! baseline value for water in the unconfined aquifer [mm]
 
@@ -108,7 +102,6 @@ module elm_varcon
   real(r8), parameter :: preind_atm_del13c = -6.0   ! preindustrial value for atmospheric del13C
   real(r8), parameter :: preind_atm_ratio = SHR_CONST_PDB + (preind_atm_del13c * SHR_CONST_PDB)/1000.0  ! 13C/12C
   real(r8) :: c13ratio = preind_atm_ratio/(1.0+preind_atm_ratio) ! 13C/(12+13)C preind atmosphere
-  !$acc declare copyin(c13ratio)
 
    ! typical del13C for C3 photosynthesis (permil, relative to PDB)
   real(r8), parameter :: c3_del13c = -28._r8
@@ -122,28 +115,25 @@ module elm_varcon
   ! isotope ratio (13c/[12c+13c]) for C3 photosynthesis
   real(r8), parameter :: c3_r2 = c3_r1/(1._r8 + c3_r1)
 
-  ! isotope ratio (13c/12c) for C4 photosynthesis
+  ! isotope ratio (13c/12c) for C4 photosynthesis  
   real(r8), parameter :: c4_r1 = SHR_CONST_PDB + ((c4_del13c*SHR_CONST_PDB)/1000._r8)
 
   ! isotope ratio (13c/[12c+13c]) for C4 photosynthesis
   real(r8), parameter :: c4_r2 = c4_r1/(1._r8 + c4_r1)
-
+  
   !!! C14
   real(r8) :: c14ratio = 1.e-12_r8
   ! real(r8) :: c14ratio = 1._r8  ! debug lets set to 1 to try to avoid numerical errors
-  !$acc declare copyin(c14ratio)
 
   ! Note that the wasteheat factors are currently set to zero until a better parameterization can be developed
   ! The prior parameterization appeared to be significantly overestimating wasteheat
   real(r8) :: ht_wasteheat_factor = 0.0_r8  !wasteheat factor for urban heating (-)
   real(r8) :: ac_wasteheat_factor = 0.0_r8  !wasteheat factor for urban air conditioning (-)
   real(r8) :: wasteheat_limit = 100._r8  !limit on wasteheat (W/m2)
-  !$acc declare copyin(ht_wasteheat_factor)
-  !$acc declare copyin(ac_wasteheat_factor)
-  !$acc declare copyin(wasteheat_limit    )
-  real(r8)  :: h2osno_max = 1000._r8    ! max allowed snow thickness (mm H2O)
+
+  real(r8) :: h2osno_max = 1000._r8      ! max allowed snow thickness (mm H2O)
   real(r8), parameter :: lapse_glcmec = 0.006_r8  ! surface temperature lapse rate (deg m-1)
-                                                  ! Pritchard et al. (GRL, 35, 2008) use 0.006
+                                                  ! Pritchard et al. (GRL, 35, 2008) use 0.006  
   real(r8), parameter :: glcmec_rain_snow_threshold = SHR_CONST_TKFRZ  ! temperature dividing rain & snow in downscaling (K)
 
   integer, private :: i  ! loop index
@@ -151,8 +141,6 @@ module elm_varcon
  !real(r8), parameter :: nitrif_n2o_loss_frac = 0.02_r8  ! fraction of N lost as N2O in nitrification (Parton et al., 2001)
   real(r8), parameter :: nitrif_n2o_loss_frac = 6.e-4_r8 ! fraction of N lost as N2O in nitrification (Li et al., 2000)
   real(r8), parameter :: frac_minrlztn_to_no3 = 0.2_r8   ! fraction of N mineralized that is dieverted to the nitrification stream (Parton et al., 2001)
-  !$acc declare copyin(nitrif_n2o_loss_frac)
-  !$acc declare copyin(frac_minrlztn_to_no3)
 
   !------------------------------------------------------------------
   ! Set subgrid names
@@ -166,7 +154,7 @@ module elm_varcon
   character(len=16), parameter :: namec  = 'column'       ! name of columns
   character(len=16), parameter :: namep  = 'pft'          ! name of patches
   character(len=16), parameter :: nameCohort = 'cohort'   ! name of cohorts (ED specific)
-  !$acc declare copyin(grlnd,nameg,namet,namel,namec,namep )
+
   !------------------------------------------------------------------
   ! Initialize miscellaneous radiation constants
   !------------------------------------------------------------------
@@ -175,9 +163,6 @@ module elm_varcon
   real(r8) :: betais  = 0.5_r8            ! two-stream parameter betai for snow
   real(r8) :: omegas(numrad)           ! two-stream parameter omega for snow by band
   data (omegas(i),i=1,numrad) /0.8_r8, 0.4_r8/
-  !$acc declare copyin(betads)
-  !$acc declare copyin(betais)
-  !$acc declare copyin(omegas)
 
   ! Lake Model Constants will be defined in LakeCon.
 
@@ -206,7 +191,7 @@ module elm_varcon
 
   real(r8), parameter :: catomw = 12.011_r8     ! molar mass of C atoms (g/mol)
   real(r8), parameter :: natomw = 14.007_r8     ! molar mass of N atoms (g/mol)
-
+  
   real(r8) :: s_con(ngases,4)    ! Schmidt # calculation constants (spp, #)
   data (s_con(1,i),i=1,4) /1898_r8, -110.1_r8, 2.834_r8, -0.02791_r8/ ! CH4
   data (s_con(2,i),i=1,4) /1801_r8, -120.1_r8, 3.7818_r8, -0.047608_r8/ ! O2
@@ -229,69 +214,13 @@ module elm_varcon
   data kh_theta(1:3) /714.29_r8, 769.23_r8, 29.4_r8/ ! CH4, O2, CO2
 
   real(r8) :: kh_tbase = 298._r8 ! base temperature for calculation of Henry's constant (K)
-  !$acc declare copyin(catomw)
-  !$acc declare copyin(natomw)
-  !$acc declare copyin(s_con)
-  !$acc declare copyin(d_con_w)
-  !$acc declare copyin(d_con_g)
-  !$acc declare copyin(c_h_inv)
-  !$acc declare copyin(kh_theta)
-  !$acc declare copyin(kh_tbase)
 
   !------------------------------------------------------------------
   ! snow physical constants
   !------------------------------------------------------------------
   ! minimum allowed snow effective radius (also "fresh snow" value) [microns]
-  real(r8), public, parameter :: snw_rds_min = 54.526_r8
+  real(r8), public, parameter :: snw_rds_min = 54.526_r8    
   !-----------------------------------------------------------------------
-  !# acc variable declarations
-
-  !$acc declare copyin(spval, ispval,rpi,zlnd, tfrz,h2osno_max)
-  !$acc declare copyin(glcmec_rain_snow_threshold, snw_rds_min)
-  !$acc declare copyin(lapse_glcmec)
-  !$acc declare copyin(degpsec  )
-  !$acc declare copyin(secspday )
-  !$acc declare copyin(isecspday)
-  !$acc declare copyin(grav  )
-  !$acc declare copyin(sb    )
-  !$acc declare copyin(vkc   )
-  !$acc declare copyin(rwat  )
-  !$acc declare copyin(rair  )
-  !$acc declare copyin(roverg)
-  !$acc declare copyin(cpliq )
-  !$acc declare copyin(cpice )
-  !$acc declare copyin(cpair )
-  !$acc declare copyin(hvap  )
-  !$acc declare copyin(hsub  )
-  !$acc declare copyin(hfus  )
-  !$acc declare copyin(denh2o)
-  !$acc declare copyin(denice)
-  !$acc declare copyin(rgas  )
-  !$acc declare copyin(tkair )
-  !$acc declare copyin(tkice )
-  !$acc declare copyin(tkwat )
-
-  !$acc declare copyin(zlnd )
-  !$acc declare copyin(zsno )
-  !$acc declare copyin(csoilc)
-  !$acc declare copyin(capr  )
-  !$acc declare copyin(cnfac )
-  !$acc declare copyin(ssi   )
-  !$acc declare copyin(wimp  )
-  !$acc declare copyin(pondmx)
-  !$acc declare copyin(pondmx_urban)
-
-  !$acc declare create(zlak(:)        )
-  !$acc declare create(dzlak(:)       )
-  !$acc declare create(zsoi(:)        )
-  !$acc declare create(dzsoi(:)       )
-  !$acc declare create(zisoi(:)       )
-  !$acc declare create(dzsoi_decomp(:))
-  !$acc declare create(nlvic(:)       )
-  !$acc declare create(dzvic(:)       )
-  !$acc declare create(zsoifl(:)      )
-  !$acc declare create(zisoifl(:)     )
-  !$acc declare create(dzsoifl(:)     )
 
 contains
 
diff --git a/components/elm/src/main/elm_varctl.F90 b/components/elm/src/main/elm_varctl.F90
index f6c22c2d67..a5b7a1cf76 100644
--- a/components/elm/src/main/elm_varctl.F90
+++ b/components/elm/src/main/elm_varctl.F90
@@ -240,7 +240,7 @@ module elm_varctl
   !  BeTR switches
   !----------------------------------------------------------
   logical, public :: use_betr = .false.          ! true=> use BeTR
-  !$acc declare copyin(use_betr)
+  !$acc declare create(use_betr)
 
   !----------------------------------------------------------
   ! lai streams switch for Sat. Phenology
@@ -454,7 +454,7 @@ module elm_varctl
   !$acc declare copyin(pf_tmode     )
   !$acc declare copyin(pf_frzmode   )
   !$acc declare copyin(initth_pf2clm)
-  !$acc declare copyin(pf_elmnstep0 )
+  !$acc declare copyin(pf_clmnstep0 )
 
   ! cpl_bypass
    character(len=fname_len), public :: metdata_type   = ' '    ! metdata type for CPL_BYPASS mode
@@ -463,17 +463,19 @@ module elm_varctl
    character(len=fname_len), public :: co2_file       = ' '    ! co2 file for CPL_BYPASS mode
    character(len=fname_len), public :: aero_file      = ' '    ! aerosol deposition file for CPL_BYPASS mode
 
-  !$acc declare copyin(use_fates)
+  !$acc declare create(use_fates)
 
   !$acc declare copyin(use_c13, use_cn, use_lch4, glcmec_downscale_rain_snow_convert)
   !$acc declare copyin(use_c14)
   !$acc declare copyin(glcmec_downscale_longwave, subgridflag)
   !$acc declare copyin(use_nofire         )
   !$acc declare copyin(use_lch4           )
+  !$acc declare copyin(use_nitrif_denitrif)
   !$acc declare copyin(use_vertsoilc      )
   !$acc declare copyin(use_extralakelayers)
   !$acc declare copyin(use_vichydro       )
   !$acc declare copyin(use_century_decomp )
+  !$acc declare copyin(use_cn             )
   !$acc declare copyin(use_crop           )
   !$acc declare copyin(use_snicar_frc     )
   !$acc declare copyin(use_snicar_ad      )
@@ -481,16 +483,14 @@ module elm_varctl
   !$acc declare copyin(use_mexicocity     )
   !$acc declare copyin(use_noio           )
   !$acc declare copyin(use_var_soil_thick )
-  !$acc declare copyin(irrigate)
   !$acc declare copyin(tw_irr)
   !$acc declare copyin(use_vsfm                   )
   !$acc declare copyin(vsfm_use_dynamic_linesearch)
   !$acc declare copyin(vsfm_include_seepage_bc    )
   !$acc declare copyin(vsfm_satfunc_type          )
   !$acc declare copyin(vsfm_lateral_model_type    )
-  !$acc declare copyin(use_extrasnowlayers)
-  !$acc declare copyin(extra_gw_irr)
-  !$acc declare copyin(use_lake_wat_storage) 
+
+
   !----------------------------------------------------------
   ! Budgets
   !----------------------------------------------------------
diff --git a/components/elm/src/main/elm_varpar.F90 b/components/elm/src/main/elm_varpar.F90
index 0645f8dbee..0b1a197469 100644
--- a/components/elm/src/main/elm_varpar.F90
+++ b/components/elm/src/main/elm_varpar.F90
@@ -24,12 +24,12 @@ module elm_varpar
   integer, parameter :: toplev_equalspace =  6
   integer            :: nlevsoi               ! number of hydrologically active soil layers
   integer            :: nlevsoifl             ! number of soil layers on input file
-  integer            :: nlevgrnd              ! number of ground layers
+  integer            :: nlevgrnd              ! number of ground layers 
                                               ! (includes lower layers that are hydrologically inactive)
   integer            :: nlevurb               ! number of urban layers
   integer            :: nlevlak               ! number of lake layers
   integer            :: nlevdecomp            ! number of biogeochemically active soil layers
-  integer            :: nlevdecomp_full       ! number of biogeochemical layers
+  integer            :: nlevdecomp_full       ! number of biogeochemical layers 
                                               ! (includes lower layers that are biogeochemically inactive)
   integer            :: nlevtrc_soil
   integer            :: nlevtrc_full
@@ -68,10 +68,10 @@ module elm_varpar
 
   ! constants for decomposition cascade
 
-  integer :: i_met_lit
-  integer :: i_cel_lit
-  integer :: i_lig_lit
-  integer :: i_cwd
+  integer :: i_met_lit 
+  integer :: i_cel_lit 
+  integer :: i_lig_lit 
+  integer :: i_cwd 
 
   integer :: ndecomp_pools
   integer :: ndecomp_cascade_transitions
@@ -94,52 +94,6 @@ module elm_varpar
   public elm_varpar_init          ! set parameters
   !
   !-----------------------------------------------------------------------
-  !$acc declare create(crop_prog)
-  !$acc declare create(maxpatch_pft)
-  !$acc declare create(ndecomp_pools)
-  !$acc declare create(ndecomp_cascade_transitions)
-  !$acc declare create(more_vertlayers)
-  !$acc declare create(nlevsno    )
-
-
-  !$acc declare copyin(nlev_equalspace  )
-  !$acc declare copyin(toplev_equalspace)
-  !$acc declare copyin(ngases     )
-  !$acc declare copyin(nlevcan    )
-  !$acc declare copyin(nvegwcs    )
-  !$acc declare copyin(numwat     )
-  !$acc declare copyin(numrad     )
-  !$acc declare copyin(ivis       )
-  !$acc declare copyin(inir       )
-  !$acc declare copyin(numsolar   )
-  !$acc declare copyin(ndst       )
-  !$acc declare copyin(dst_src_nbr)
-  !$acc declare copyin(sz_nbr     )
-  !$acc declare copyin(mxpft      )
-  !$acc declare create(nlevsoi        )
-  !$acc declare create(nlevsoifl      )
-  !$acc declare create(nlevurb        )
-  !$acc declare create(nlevlak        )
-  !$acc declare create(nlevdecomp     )
-  !$acc declare create(nlevdecomp_full)
-  !$acc declare create(nlevtrc_soil   )
-  !$acc declare create(nlevtrc_full   )
-  !$acc declare create(nlevgrnd)
-  !$acc declare create(natpft_lb  )
-  !$acc declare create(natpft_ub  )
-  !$acc declare create(natpft_size)
-  !$acc declare create(cft_lb     )
-  !$acc declare create(cft_ub     )
-  !$acc declare create(cft_size   )
-  !$acc declare create(i_met_lit  )
-  !$acc declare create(i_cel_lit  )
-  !$acc declare create(i_lig_lit  )
-  !$acc declare create(i_cwd      )
-  !$acc declare create(maxpatch_glcmec )
-  !$acc declare create(max_patch_per_col)
-  !$acc declare create(mach_eps)
-
-  !$acc declare create(nlayert)
 
 contains
 
@@ -147,7 +101,7 @@ contains
   subroutine elm_varpar_init()
     !
     ! !DESCRIPTION:
-    ! Initialize module variables
+    ! Initialize module variables 
     !
     ! !ARGUMENTS:
     implicit none
@@ -220,7 +174,7 @@ contains
        nlevdecomp      = 1
        nlevdecomp_full = 1
     end if
-
+    
     nlevtrc_full   = nlevsoi
     if(use_betr) then
       nlevtrc_soil = nlevsoi
@@ -248,7 +202,7 @@ contains
        i_cwd = 4
     end if
 
-
+    
 
 
   end subroutine elm_varpar_init
diff --git a/components/elm/src/main/elm_varsur.F90 b/components/elm/src/main/elm_varsur.F90
index 8424112c0a..bd1a7682f3 100644
--- a/components/elm/src/main/elm_varsur.F90
+++ b/components/elm/src/main/elm_varsur.F90
@@ -48,6 +48,5 @@ module elm_varsur
   real(r8), pointer :: slp_tunit(:,:)  ! Topounit slope 
   integer, pointer :: asp_tunit(:,:)  ! Topounit aspect
   !-----------------------------------------------------------------------
-    
-  !$acc declare create(wt_lunit) 
+
 end module elm_varsur
diff --git a/components/elm/src/main/fileio_mod.F90 b/components/elm/src/main/fileio_mod.F90
deleted file mode 100644
index b20028c50d..0000000000
--- a/components/elm/src/main/fileio_mod.F90
+++ /dev/null
@@ -1,501 +0,0 @@
-module fileio_mod
-!#define DEBUG
-
-        use shr_kind_mod   , only : r8 => shr_kind_r8
-
-    implicit none
-
-        ! public members
-        integer, public :: funit_id(256) = 0
-
-    ! public subroutines
-        public :: fio_open
-        public :: fio_close
-        public :: fio_read
-        public :: fio_write
-
-        interface fio_read
-                module procedure fio_read_int
-                module procedure fio_read_real8
-                module procedure fio_read_logical_array
-                module procedure fio_read_int_array
-    module procedure fio_read_int_2Darray
-                module procedure fio_read_real8_array
-                module procedure fio_read_real8_2Darray
-                module procedure fio_read_real8_3Darray
-                module procedure fio_read_string_array
-        end interface
-
-contains
-
-! error code
-! 0: success
-! 1: file does not exist
-! 2: field name not found
-
-    ! open file
-        subroutine fio_open(unitid, filename, accesstype, overwritten, errcode)
-                implicit none
-                ! input
-                integer,                        intent(in)              :: unitid
-                character(len=*),   intent(in)          :: filename
-                integer,                        intent(in)              :: accesstype  ! 1: read, 2: write, 3: read write
-                integer, optional,  intent(in)          :: overwritten ! 1. overwritten files(default), 0. append to files
-                integer, optional,      intent(inout)   :: errcode
-
-                ! local vars
-                logical :: alive
-                integer :: error
-                character(len=256)              :: temp
-                integer :: ow ! local over written
-
-                if (present(overwritten)) then
-                        ow = overwritten
-                else
-                        ow = 1
-                endif
-
-                error = 0
-                inquire(file=filename, exist=alive)
-                if (alive .eqv. .false.) then
-                                if (accesstype .eq. 1) then
-#if defined(DEBUG)
-                            write (*, "(A)") "file does not exist"
-#endif
-                            error = 1
-                            if (present(errcode)) then
-                                    errcode = error
-                            end if
-                        else
-                            funit_id(unitid) = unitid
-#if defined(DEBUG)
-                            write(*, "(A,A)") "create file: ", filename
-#endif
-                            open(unit=funit_id(unitid), file=filename, status="new", iostat=error, form='formatted')
-                            if (present(errcode)) then
-                                    errcode = error
-                            end if
-                        endif
-                else
-                    funit_id(unitid) = unitid
-#if defined(DEBUG)
-                    write(*, "(A,A)") "open file: ", filename
-#endif
-            ! read file
-        if(accesstype .eq. 1) then
-                                                open(unit=funit_id(unitid), file=filename, action="read", status="old", iostat=error, form='formatted')
-                                else
-            if(ow .eq. 1) then
-                                        open(unit=funit_id(unitid), file=filename, status="new", iostat=error, form='formatted')
-                                else
-                          open(unit=funit_id(unitid), file=filename, status="old", position="append", iostat=error, form='formatted')
-                                endif
-                                endif
-
-                        if (present(errcode)) then
-                            errcode = error
-                  end if
-
-                endif
-
-        end subroutine fio_open
-
-        ! close file
-        subroutine fio_close(unitid)
-                implicit none
-
-                integer, intent(in) :: unitid
-
-                close(funit_id(unitid))
-
-        end subroutine fio_close
-
-        ! read int
-        subroutine fio_read_int(unitid, fieldname, vardata, errcode)
-                implicit none
-                ! input
-                integer,   intent(in)              :: unitid
-                character(len=*), intent(in)       :: fieldname
-                integer,           intent(inout)   :: vardata
-                integer, optional, intent(inout)   :: errcode
-
-                ! local var
-                integer                         :: ct
-                integer                         :: error
-                character(len=256)      :: line
-
-          rewind(unit=funit_id(unitid))
-
-#if defined(DEBUG)
-                write(*, "(A,A)") "fieldname: ", fieldname
-#endif
-
-        do while(.true.)
-                        read(unit=funit_id(unitid), fmt="(A)", iostat=error) line
-                        if (error/=0) then
-                                ! field not found
-                                write(*, "(A)") "not found"
-                                error = 2
-                                exit
-                        end if
-            ! found
-                        if (trim(line(:)) .eq. trim(fieldname)) then
-                                read(unit=funit_id(unitid), fmt=*, iostat=error) vardata
-
-#if defined(DEBUG)
-                                write (*, "(I6)") vardata
-#endif
-                                error = 0
-                                exit
-                        end if
-                end do
-
-                if (present(errcode)) then
-                        errcode = error
-                end if
-
-        end subroutine fio_read_int
-
-        ! read int array
-        subroutine fio_read_int_array(unitid, fieldname, vardata, errcode)
-                implicit none
-                ! input
-                integer,                        intent(in)              :: unitid
-                character(len=*),       intent(in)              :: fieldname
-                integer,                        intent(inout)   :: vardata(:)
-                integer, optional,      intent(inout)   :: errcode
-
-                ! local var
-                integer                         :: ct
-                integer                         :: error
-                character(len=256)      :: line
-
-            rewind(unit=funit_id(unitid))
-#if defined(DEBUG)
-                write(*, "(A,A)") "fieldname: ", fieldname
-#endif
-                do while(.true.)
-                        read(unit=funit_id(unitid), fmt="(A)", iostat=error) line
-                        if (error/=0) then
-                                ! field not found
-                                write(*, "(A)") "not found"
-                                error = 2
-                                exit
-                        end if
-            ! found
-                        if (line(:) .eq. fieldname) then
-                                read(unit=funit_id(unitid), fmt=*, iostat=error) vardata
-#if defined(DEBUG)
-                                write (*, "(10(2X,I6))") vardata
-#endif
-                                error = 0
-                                exit
-                        end if
-                end do
-                if (present(errcode)) then
-                        errcode = error
-                end if
-
-        end subroutine fio_read_int_array
-
-
-  ! read real8 2D array
-  subroutine fio_read_int_2Darray(unitid, fieldname, vardata, errcode)
-    implicit none
-    ! input
-    integer,                    intent(in)              :: unitid
-    character(len=*),   intent(in)              :: fieldname
-    integer,                    intent(inout)   :: vardata(:,:)
-    integer, optional,  intent(inout)   :: errcode
-
-    ! local var
-    integer                     :: ct
-    integer                     :: error
-    character(len=256)  :: line
-
-      rewind(unit=funit_id(unitid))
-#if defined(DEBUG)
-    write(*, "(A,A)") "fieldname: ", fieldname
-#endif
-    do while(.true.)
-      read(unit=funit_id(unitid), fmt="(A)", iostat=error) line
-      if (error/=0) then
-        ! field not found
-        write(*, "(A)") "not found"
-        error = 2
-        exit
-      end if
-            ! found
-      if (line(:) .eq. fieldname) then
-        read(unit=funit_id(unitid), fmt=*, iostat=error) vardata
-#if defined(DEBUG)
-        write (*, "(10(2X,I6))") vardata
-#endif
-        error = 0
-        exit
-      end if
-    end do
-    if (present(errcode)) then
-      errcode = error
-    end if
-
-  end subroutine fio_read_int_2Darray
-
-        ! read real8
-        subroutine fio_read_real8(unitid, fieldname, vardata, errcode)
-                implicit none
-                ! input
-                integer,          intent(in)              :: unitid
-                character(len=*), intent(in)              :: fieldname
-                real(r8),         intent(inout)   :: vardata
-                integer, optional,      intent(inout)   :: errcode
-
-                ! local var
-                integer                         :: ct
-                integer                         :: error
-                character(len=256)      :: line
-
-            rewind(unit=funit_id(unitid))
-#if defined(DEBUG)
-                write(*, "(A,A)") "fieldname: ", fieldname
-#endif
-                do while(.true.)
-                        read(unit=funit_id(unitid), fmt="(A)", iostat=error) line
-                        if (error/=0) then
-                                ! field not found
-                                write(*, "(A)") "not found"
-                                error = 2
-                                exit
-                        end if
-            ! found
-                        if (line(:) .eq. fieldname) then
-                                read(unit=funit_id(unitid), fmt=*, iostat=error) vardata
-#if defined(DEBUG)
-                                !write (*, "(F12.8)") vardata
-                                write(*,*) vardata
-#endif
-                                error = 0
-                                exit
-                        end if
-                end do
-                if (present(errcode)) then
-                        errcode = error
-                end if
-
-        end subroutine fio_read_real8
-
-        ! read real8 array
-        subroutine fio_read_real8_array(unitid, fieldname, vardata, errcode)
-                implicit none
-                ! input
-                integer,                        intent(in)              :: unitid
-                character(len=*),       intent(in)              :: fieldname
-                real(r8),                       intent(inout)   :: vardata(:)
-                integer, optional,      intent(inout)   :: errcode
-
-                ! local var
-                integer                         :: ct
-                integer                         :: error
-                character(len=256)      :: line
-
-            rewind(unit=funit_id(unitid))
-#if defined(DEBUG)
-                write(*, "(A,A)") "fieldname: ", fieldname
-#endif
-                do while(.true.)
-                        read(unit=funit_id(unitid), fmt="(A)", iostat=error) line
-                        if (error/=0) then
-                                ! field not found
-                                write(*, "(A)") "not found"
-                                error = 2
-                                exit
-                        end if
-            ! found
-                        if (line(:) .eq. fieldname) then
-                                read(unit=funit_id(unitid), fmt=*, iostat=error) vardata
-#if defined(DEBUG)
-                                write (*, "(10(2X,F12.4))") vardata
-#endif
-                                error = 0
-                                exit
-                        end if
-                end do
-                if (present(errcode)) then
-                        errcode = error
-                end if
-
-        end subroutine fio_read_real8_array
-
-        ! read real8 2D array
-        subroutine fio_read_real8_2Darray(unitid, fieldname, vardata, errcode)
-                implicit none
-                ! input
-                integer,                        intent(in)              :: unitid
-                character(len=*),       intent(in)              :: fieldname
-                real(r8),                       intent(inout)   :: vardata(:,:)
-                integer, optional,      intent(inout)   :: errcode
-
-                ! local var
-                integer                         :: ct
-                integer                         :: error
-                character(len=256)      :: line
-
-            rewind(unit=funit_id(unitid))
-#if defined(DEBUG)
-                write(*, "(A,A)") "fieldname: ", fieldname
-#endif
-                do while(.true.)
-                        read(unit=funit_id(unitid), fmt="(A)", iostat=error) line
-                        if (error/=0) then
-                                ! field not found
-                                write(*, "(A)") "not found"
-                                error = 2
-                                exit
-                        end if
-            ! found
-                        if (line(:) .eq. fieldname) then
-                                read(unit=funit_id(unitid), fmt=*, iostat=error) vardata
-#if defined(DEBUG)
-                                write (*, "(10(2X,F12.4))") vardata
-#endif
-                                error = 0
-                                exit
-                        end if
-                end do
-                if (present(errcode)) then
-                        errcode = error
-                end if
-
-        end subroutine fio_read_real8_2Darray
-
-        ! read real8 3D array
-        subroutine fio_read_real8_3Darray(unitid, fieldname, vardata, errcode)
-                implicit none
-                ! input
-                integer,                        intent(in)              :: unitid
-                character(len=*),       intent(in)              :: fieldname
-                real(r8),                       intent(inout)   :: vardata(:,:, :)
-                integer, optional,      intent(inout)   :: errcode
-
-                ! local var
-                integer                         :: ct
-                integer                         :: error
-                character(len=256)      :: line
-
-            rewind(unit=funit_id(unitid))
-#if defined(DEBUG)
-                write(*, "(A,A)") "fieldname: ", fieldname
-#endif
-                do while(.true.)
-                        read(unit=funit_id(unitid), fmt="(A)", iostat=error) line
-                        if (error/=0) then
-                                ! field not found
-                                write(*, "(A)") "not found"
-                                error = 2
-                                exit
-                        end if
-            ! found
-                        if (line(:) .eq. fieldname) then
-                                read(unit=funit_id(unitid), fmt=*, iostat=error) vardata
-#if defined(DEBUG)
-                                write (*, "(10(2X,F12.4))") vardata
-#endif
-                                error = 0
-                                exit
-                        end if
-                end do
-                if (present(errcode)) then
-                        errcode = error
-                end if
-
-        end subroutine fio_read_real8_3Darray
-
-        ! read real8
-        subroutine fio_read_string_array(unitid, fieldname, vardata, errcode)
-                implicit none
-                ! input
-                integer,                        intent(in)              :: unitid
-                character(len=*),       intent(in)              :: fieldname
-                character(len=*),       intent(inout)   :: vardata(:)
-                integer, optional,      intent(inout)   :: errcode
-
-                ! local var
-                integer                         :: ct
-                integer                         :: error
-                character(len=256)      :: line
-
-            rewind(unit=funit_id(unitid))
-#if defined(DEBUG)
-                write(*, "(A,A)") "fieldname: ", fieldname
-#endif
-                do while(.true.)
-                        read(unit=funit_id(unitid), fmt="(A)", iostat=error) line
-                        if (error/=0) then
-                                ! field not found
-                                write(*, "(A)") "not found"
-                                error = 2
-                                exit
-                        end if
-            ! found
-                        if (line(:) .eq. fieldname) then
-                                read(unit=funit_id(unitid), fmt=*, iostat=error) vardata
-#if defined(DEBUG)
-                                write (*, "((3(2X,A)))") vardata
-#endif
-                                error = 0
-                                exit
-                        end if
-                end do
-                if (present(errcode)) then
-                        errcode = error
-                end if
-
-        end subroutine fio_read_string_array
-
-        ! write file
-        subroutine fio_write()
-        end subroutine fio_write
-
-        ! read logical array
-        subroutine fio_read_logical_array(unitid, fieldname, vardata, errcode)
-                implicit none
-                ! input
-                integer,                        intent(in)              :: unitid
-                character(len=*),       intent(in)              :: fieldname
-                logical,                        intent(inout)   :: vardata(:)
-                integer, optional,      intent(inout)   :: errcode
-
-                ! local var
-                integer                         :: ct
-                integer                         :: error
-                character(len=256)      :: line
-
-            rewind(unit=funit_id(unitid))
-#if defined(DEBUG)
-                write(*, "(A,A)") "fieldname: ", fieldname
-#endif
-                do while(.true.)
-                        read(unit=funit_id(unitid), fmt="(A)", iostat=error) line
-                        if (error/=0) then
-                                ! field not found
-                                write(*, "(A)") "not found"
-                                error = 2
-                                exit
-                        end if
-            ! found
-                        if (line(:) .eq. fieldname) then
-                                read(unit=funit_id(unitid), fmt=*, iostat=error) vardata
-#if defined(DEBUG)
-                                write (*, *) vardata
-#endif
-                                error = 0
-                                exit
-                        end if
-                end do
-                if (present(errcode)) then
-                        errcode = error
-                end if
-
-        end subroutine fio_read_logical_array
-
-end module fileio_mod
diff --git a/components/elm/src/main/filterMod.F90 b/components/elm/src/main/filterMod.F90
index 8a177e56c3..768235bea4 100644
--- a/components/elm/src/main/filterMod.F90
+++ b/components/elm/src/main/filterMod.F90
@@ -1,4 +1,7 @@
 module filterMod
+
+#include "shr_assert.h"
+
   !-----------------------------------------------------------------------
   ! !DESCRIPTION:
   ! Module of filters used for processing columns and pfts of particular
@@ -7,160 +10,93 @@ module filterMod
   !
   ! !USES:
   use shr_kind_mod   , only : r8 => shr_kind_r8
-  use decompMod      , only : bounds_type
+  use shr_log_mod    , only : errMsg => shr_log_errMsg
+  use abortutils     , only : endrun
+  use elm_varctl     , only : iulog
+  use decompMod      , only : bounds_type  
   use GridcellType   , only : grc_pp
   use LandunitType   , only : lun_pp                
   use ColumnType     , only : col_pp                
   use VegetationType , only : veg_pp  
   use TopounitType   , only : top_pp
-
   !
   ! !PUBLIC TYPES:
   implicit none
   save
   private
   !
-  type :: clumpfilter
-     integer, pointer :: natvegp(:)   => null()   ! nat-vegetated (present) filter (pfts)
-     integer, pointer :: num_natvegp  => null()   ! number of pfts in nat-vegetated filter
-
-     integer, pointer :: pcropp(:)    => null()  ! prognostic crop filter (pfts)
-     integer, pointer :: num_pcropp   => null()  ! number of pfts in prognostic crop filter
-     integer, pointer :: ppercropp(:)  => null()  ! prognostic perennial crop filter (pfts)
-     integer, pointer :: num_ppercropp => null()  ! number of pfts in prognostic perennial crop filter
-     integer, pointer :: soilnopcropp(:)  =>null()! soil w/o prog. crops (pfts)
-     integer, pointer :: num_soilnopcropp =>null()        ! number of pfts in soil w/o prog crops
-
-     integer, pointer :: lakep(:)  => null()   ! lake filter (pfts)
-     integer, pointer :: num_lakep => null()   ! number of pfts in lake filter
-     integer, pointer :: nolakep(:)  => null() ! non-lake filter (pfts)
-     integer, pointer :: num_nolakep => null() ! number of pfts in non-lake filter
-     integer, pointer :: lakec(:)  => null()   ! lake filter (columns)
-     integer, pointer :: num_lakec => null()   ! number of columns in lake filter
-     integer, pointer :: nolakec(:)  => null() ! non-lake filter (columns)
-     integer, pointer :: num_nolakec => null() ! number of columns in non-lake filter
-
-     integer, pointer :: soilc(:)  => null()   ! soil filter (columns)
-     integer, pointer :: num_soilc => null()   ! number of columns in soil filter
-     integer, pointer :: soilp(:)  => null()   ! soil filter (pfts)
-     integer, pointer :: num_soilp => null()   ! number of pfts in soil filter
-
-     integer, pointer :: snowc(:)  => null()   ! snow filter (columns)
-     integer, pointer :: num_snowc => null()   ! number of columns in snow filter
-     integer, pointer :: nosnowc(:)  => null() ! non-snow filter (columns)
-     integer, pointer :: num_nosnowc => null() ! number of columns in non-snow filter
-
-     integer, pointer :: lakesnowc(:)  => null()   ! snow filter (columns)
-     integer, pointer :: num_lakesnowc => null()   ! number of columns in snow filter
-     integer, pointer :: lakenosnowc(:)  => null() ! non-snow filter (columns)
-     integer, pointer :: num_lakenosnowc => null() ! number of columns in non-snow filter
-
-     integer, pointer :: hydrologyc(:)  =>null() ! hydrology filter (columns)
-     integer, pointer :: num_hydrologyc =>null()          ! number of columns in hydrology filter
-
-     integer, pointer :: hydrononsoic(:)   => null() ! non-soil hydrology filter (columns)
-     integer, pointer :: num_hydrononsoic  => null() ! number of columns in non-soil hydrology filter
-
-     integer, pointer :: urbanl(:)  => null()    ! urban filter (landunits)
-     integer, pointer :: num_urbanl => null()             ! number of landunits in urban filter
-     integer, pointer :: nourbanl(:) =>null()    ! non-urban filter (landunits)
-     integer, pointer :: num_nourbanl=>null()             ! number of landunits in non-urban filter
-
-     integer, pointer :: urbanc(:)    => null()   ! urban filter (columns)
-     integer, pointer :: num_urbanc   => null()            ! number of columns in urban filter
-     integer, pointer :: nourbanc(:)  => null()   ! non-urban filter (columns)
-     integer, pointer :: num_nourbanc => null()            ! number of columns in non-urban filter
-
-     integer, pointer :: urbanp(:)    => null()    ! urban filter (pfts)
-     integer, pointer :: num_urbanp   => null()             ! number of pfts in urban filter
-     integer, pointer :: nourbanp(:)  => null()    ! non-urban filter (pfts)
-     integer, pointer :: num_nourbanp => null()             ! number of pfts in non-urban filter
-
-     integer, pointer :: nolakeurbanp(:)  => null()! non-lake, non-urban filter (pfts)
-     integer, pointer :: num_nolakeurbanp => null()         ! number of pfts in non-lake, non-urban filter
-
-     integer, pointer :: icemecc(:)  => null()    ! glacier mec filter (cols)
-     integer, pointer :: num_icemecc => null()             ! number of columns in glacier mec filter
-
-     integer, pointer :: do_smb_c(:)  => null()  ! glacier+bareland SMB calculations-on filter (cols)
-     integer, pointer :: num_do_smb_c => null()           ! number of columns in glacier+bareland SMB mec filter
+  type clumpfilter
+     integer, pointer :: natvegp(:)      ! nat-vegetated (present) filter (pfts)
+     integer :: num_natvegp              ! number of pfts in nat-vegetated filter
+
+     integer, pointer :: pcropp(:)       ! prognostic crop filter (pfts)
+     integer :: num_pcropp               ! number of pfts in prognostic crop filter
+     integer, pointer :: ppercropp(:)    ! prognostic perennial crop filter (pfts)
+     integer :: num_ppercropp            ! number of pfts in prognostic perennial crop filter
+     integer, pointer :: soilnopcropp(:) ! soil w/o prog. crops (pfts)
+     integer :: num_soilnopcropp         ! number of pfts in soil w/o prog crops
+
+     integer, pointer :: lakep(:)        ! lake filter (pfts)
+     integer :: num_lakep                ! number of pfts in lake filter
+     integer, pointer :: nolakep(:)      ! non-lake filter (pfts)
+     integer :: num_nolakep              ! number of pfts in non-lake filter
+     integer, pointer :: lakec(:)        ! lake filter (columns)
+     integer :: num_lakec                ! number of columns in lake filter
+     integer, pointer :: nolakec(:)      ! non-lake filter (columns)
+     integer :: num_nolakec              ! number of columns in non-lake filter
+
+     integer, pointer :: soilc(:)        ! soil filter (columns)
+     integer :: num_soilc                ! number of columns in soil filter 
+     integer, pointer :: soilp(:)        ! soil filter (pfts)
+     integer :: num_soilp                ! number of pfts in soil filter 
+
+     integer, pointer :: snowc(:)        ! snow filter (columns) 
+     integer :: num_snowc                ! number of columns in snow filter 
+     integer, pointer :: nosnowc(:)      ! non-snow filter (columns) 
+     integer :: num_nosnowc              ! number of columns in non-snow filter 
+
+     integer, pointer :: lakesnowc(:)    ! snow filter (columns) 
+     integer :: num_lakesnowc            ! number of columns in snow filter 
+     integer, pointer :: lakenosnowc(:)  ! non-snow filter (columns) 
+     integer :: num_lakenosnowc          ! number of columns in non-snow filter 
+
+     integer, pointer :: hydrologyc(:)   ! hydrology filter (columns)
+     integer :: num_hydrologyc           ! number of columns in hydrology filter 
+
+     integer, pointer :: hydrononsoic(:) ! non-soil hydrology filter (columns)
+     integer :: num_hydrononsoic         ! number of columns in non-soil hydrology filter
+
+     integer, pointer :: urbanl(:)       ! urban filter (landunits)
+     integer :: num_urbanl               ! number of landunits in urban filter 
+     integer, pointer :: nourbanl(:)     ! non-urban filter (landunits)
+     integer :: num_nourbanl             ! number of landunits in non-urban filter 
+
+     integer, pointer :: urbanc(:)       ! urban filter (columns)
+     integer :: num_urbanc               ! number of columns in urban filter
+     integer, pointer :: nourbanc(:)     ! non-urban filter (columns)
+     integer :: num_nourbanc             ! number of columns in non-urban filter
+
+     integer, pointer :: urbanp(:)       ! urban filter (pfts)
+     integer :: num_urbanp               ! number of pfts in urban filter
+     integer, pointer :: nourbanp(:)     ! non-urban filter (pfts)
+     integer :: num_nourbanp             ! number of pfts in non-urban filter
+
+     integer, pointer :: nolakeurbanp(:) ! non-lake, non-urban filter (pfts)
+     integer :: num_nolakeurbanp         ! number of pfts in non-lake, non-urban filter
+
+     integer, pointer :: icemecc(:)      ! glacier mec filter (cols)
+     integer :: num_icemecc              ! number of columns in glacier mec filter
+     
+     integer, pointer :: do_smb_c(:)     ! glacier+bareland SMB calculations-on filter (cols)
+     integer :: num_do_smb_c             ! number of columns in glacier+bareland SMB mec filter         
 
   end type clumpfilter
-  public :: clumpfilter
-
-  type :: procfilter
-
-      integer, pointer :: soilc(:)   => null() ! soil filter (columns)
-      integer, pointer :: num_soilc  => null() ! number of columns in soil filter
-      integer, pointer :: soilp(:)   => null() ! soil filter (pfts)
-      integer, pointer :: num_soilp  => null() ! number of pfts in soil filter
-      integer, pointer :: num_pcropp => null() !
-      integer, pointer :: pcropp(:)  => null() !
-
-      ! new filter group replacing nolakeurbanp
-      ! used in BareGroundFluxes and CanopyFluxes
-      ! need to be updated AFTER elm_drv_init subroutine
-      integer, pointer :: num_nolu_barep => null()
-      integer, pointer :: nolu_barep(:)  => null()
-      integer, pointer :: num_nolu_vegp => null()
-      integer, pointer :: nolu_vegp(:)  => null()
-
-      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-      integer, pointer :: urbanl(:)   => null()    ! urban filter (landunits)
-      integer, pointer :: num_urbanl  => null()    ! number of landunits in urban filter
-      integer, pointer :: nourbanl(:) => null()    ! non-urban filter (landunits)
-      integer, pointer :: num_nourbanl=> null()    ! number of landunits in non-urban filter
-
-      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-      integer, pointer :: urbanc(:)  => null()   ! urban filter (columns)
-      integer, pointer :: num_urbanc => null()   ! number of columns in urban filter
-      integer, pointer :: urbanp(:)  => null()   ! urban filter (pfts)
-      integer, pointer :: num_urbanp => null()   ! number of pfts in urban filter
-      integer, pointer :: nourbanp(:)  => null()    ! non-urban filter (pfts)
-      integer, pointer :: num_nourbanp => null()    ! number of pfts in non-urban filter
- 
-
-      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-      integer, pointer :: nolakec(:)  => null() ! non-lake filter (columns)
-      integer, pointer :: num_nolakec => null() ! number of columns in non-lake filter
-      integer, pointer :: lakec(:)  => null()   ! lake filter (pfts)
-      integer, pointer :: num_lakec => null()   ! number of pfts in lake filter
-      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-      integer, pointer :: lakep(:)  => null()   ! lake filter (pfts)
-      integer, pointer :: num_lakep => null()   ! number of pfts in lake filter
-      integer, pointer :: nolakep(:)  => null() ! non-lake filter (pfts)
-      integer, pointer :: num_nolakep => null() ! number of pfts in non-lake filter
- 
-
-      integer, pointer :: hydrologyc(:)  =>null() ! hydrology filter (columns)
-      integer, pointer :: num_hydrologyc =>null()          ! number of columns in hydrology filter
-
-      integer, pointer :: hydrononsoic(:)   => null() ! non-soil hydrology filter (columns)
-      integer, pointer :: num_hydrononsoic  => null() ! number of columns in non-soil hydrology filter
-
-      integer, pointer :: snowc(:)  => null()   ! snow filter (columns)
-      integer, pointer :: num_snowc => null()   ! number of columns in snow filter
-      integer, pointer :: nosnowc(:)  => null() ! non-snow filter (columns)
-      integer, pointer :: num_nosnowc => null() ! number of columns in non-snow filter
-
-      integer, pointer :: lakesnowc(:)  => null()   ! snow filter (columns)
-      integer, pointer :: num_lakesnowc => null()   ! number of columns in snow filter
-      integer, pointer :: lakenosnowc(:)  => null() ! non-snow filter (columns)
-      integer, pointer :: num_lakenosnowc => null() ! number of columns in non-snow filter
-      
-      integer, pointer :: do_smb_c(:)  => null() ! glacier+bareland SMB calculations-on filter (cols)
-      integer, pointer :: num_do_smb_c => null() ! number of columns in glacier+bareland SMB mec filter
-
-   end type
-   public :: procfilter
+  public clumpfilter
 
   ! This is the standard set of filters, which should be used in most places in the code.
   ! These filters only include 'active' points.
   type(clumpfilter), allocatable, public :: filter(:)
-  !$acc declare create(filter)
-  type(procfilter) , public :: proc_filter, proc_filter_inactive_and_active
-  !$acc declare create(proc_filter,proc_filter_inactive_and_active)
-
+  
   ! --- DO NOT USING THE FOLLOWING VARIABLE UNLESS YOU KNOW WHAT YOU'RE DOING! ---
   !
   ! This is a separate set of filters that contains both inactive and active points. It is
@@ -176,21 +112,18 @@ module filterMod
   ! before this variable was added (i.e., when there was only a single group of filters).
   !
   type(clumpfilter), allocatable, public :: filter_inactive_and_active(:)
-  !$acc declare create(filter_inactive_and_active)
+  !
   public allocFilters   ! allocate memory for filters
   public setFilters     ! set filters
-  public :: createProcessorFilter
-  public :: updateFracNoSnoFilters 
 
   private allocFiltersOneGroup  ! allocate memory for one group of filters
   private setFiltersOneGroup    ! set one group of filters
-  public :: setProcFilters
   !
   ! !REVISION HISTORY:
   ! Created by Mariana Vertenstein
   ! 11/13/03, Peter Thornton: Added soilp and num_soilp
   ! Jan/08, S. Levis: Added crop-related filters
-  ! June/13, Bill Sacks: Change main filters to just work over 'active' points;
+  ! June/13, Bill Sacks: Change main filters to just work over 'active' points; 
   ! add filter_inactive_and_active
   !-----------------------------------------------------------------------
 
@@ -208,6 +141,7 @@ contains
 
     call allocFiltersOneGroup(filter)
     call allocFiltersOneGroup(filter_inactive_and_active)
+
   end subroutine allocFilters
 
   !------------------------------------------------------------------------
@@ -217,8 +151,7 @@ contains
     ! Allocate CLM filters, for one group of filters.
     !
     ! !USES:
-    use decompMod , only : get_clump_bounds
-    use decompMod,  only : procinfo
+    use decompMod , only : get_proc_clumps, get_clump_bounds
     !
     ! !ARGUMENTS:
     type(clumpfilter), intent(inout), allocatable :: this_filter(:)  ! the filter to allocate
@@ -227,172 +160,87 @@ contains
     integer :: nc          ! clump index
     integer :: nclumps     ! total number of clumps on this processor
     integer :: ier         ! error status
-    type(bounds_type) :: bounds
+    type(bounds_type) :: bounds  
     !------------------------------------------------------------------------
 
     ! Determine clump variables for this processor
 
-    nclumps = procinfo%nclumps
+    nclumps = get_proc_clumps()
 
     ier = 0
     if( .not. allocated(this_filter)) then
        allocate(this_filter(nclumps), stat=ier)
     end if
     if (ier /= 0) then
-       write(*,*) 'allocFiltersOneGroup(): allocation error for clumpsfilters'
-       stop
+       write(iulog,*) 'allocFiltersOneGroup(): allocation error for clumpsfilters'
+       call endrun(msg=errMsg(__FILE__, __LINE__))
     end if
 
     ! Loop over clumps on this processor
 
-    !$OMP PARALLEL DO PRIVATE (nc,bounds)
+!$OMP PARALLEL DO PRIVATE (nc,bounds)
     do nc = 1, nclumps
        call get_clump_bounds(nc, bounds)
-       allocate(this_filter(nc)%num_lakep  )
-       allocate(this_filter(nc)%num_nolakep )
-       allocate(this_filter(nc)%num_nolakeurbanp )
-       allocate(this_filter(nc)%num_lakec  )
-       allocate(this_filter(nc)%num_nolakec)
-       allocate(this_filter(nc)%num_soilc)
-       allocate(this_filter(nc)%num_soilp)
-       allocate(this_filter(nc)%num_snowc)
-       allocate(this_filter(nc)%num_nosnowc)
-       allocate(this_filter(nc)%num_lakesnowc)
-       allocate(this_filter(nc)%num_lakenosnowc)
-       allocate(this_filter(nc)%num_natvegp)
 
        allocate(this_filter(nc)%lakep(bounds%endp-bounds%begp+1))
        allocate(this_filter(nc)%nolakep(bounds%endp-bounds%begp+1))
        allocate(this_filter(nc)%nolakeurbanp(bounds%endp-bounds%begp+1))
+
        allocate(this_filter(nc)%lakec(bounds%endc-bounds%begc+1))
        allocate(this_filter(nc)%nolakec(bounds%endc-bounds%begc+1))
+
        allocate(this_filter(nc)%soilc(bounds%endc-bounds%begc+1))
        allocate(this_filter(nc)%soilp(bounds%endp-bounds%begp+1))
+
        allocate(this_filter(nc)%snowc(bounds%endc-bounds%begc+1))
        allocate(this_filter(nc)%nosnowc(bounds%endc-bounds%begc+1))
+
        allocate(this_filter(nc)%lakesnowc(bounds%endc-bounds%begc+1))
        allocate(this_filter(nc)%lakenosnowc(bounds%endc-bounds%begc+1))
-       allocate(this_filter(nc)%natvegp(bounds%endp-bounds%begp+1))
 
-       allocate(this_filter(nc)%num_hydrologyc)
-       allocate(this_filter(nc)%num_hydrononsoic)
-       allocate(this_filter(nc)%num_urbanp)
-       allocate(this_filter(nc)%num_nourbanp)
-       allocate(this_filter(nc)%num_urbanc)
-       allocate(this_filter(nc)%num_nourbanc)
-       allocate(this_filter(nc)%num_urbanl)
-       allocate(this_filter(nc)%num_nourbanl)
-       allocate(this_filter(nc)%num_pcropp)
-       allocate(this_filter(nc)%num_ppercropp)
-       allocate(this_filter(nc)%num_soilnopcropp)
-       allocate(this_filter(nc)%num_icemecc)
-       allocate(this_filter(nc)%num_do_smb_c)
+       allocate(this_filter(nc)%natvegp(bounds%endp-bounds%begp+1))
 
        allocate(this_filter(nc)%hydrologyc(bounds%endc-bounds%begc+1))
        allocate(this_filter(nc)%hydrononsoic(bounds%endc-bounds%begc+1))
+
        allocate(this_filter(nc)%urbanp(bounds%endp-bounds%begp+1))
        allocate(this_filter(nc)%nourbanp(bounds%endp-bounds%begp+1))
+
        allocate(this_filter(nc)%urbanc(bounds%endc-bounds%begc+1))
        allocate(this_filter(nc)%nourbanc(bounds%endc-bounds%begc+1))
+
        allocate(this_filter(nc)%urbanl(bounds%endl-bounds%begl+1))
        allocate(this_filter(nc)%nourbanl(bounds%endl-bounds%begl+1))
+
        allocate(this_filter(nc)%pcropp(bounds%endp-bounds%begp+1))
        allocate(this_filter(nc)%ppercropp(bounds%endp-bounds%begp+1))
        allocate(this_filter(nc)%soilnopcropp(bounds%endp-bounds%begp+1))
-       allocate(this_filter(nc)%icemecc(bounds%endc-bounds%begc+1))
-       allocate(this_filter(nc)%do_smb_c(bounds%endc-bounds%begc+1))
 
+       allocate(this_filter(nc)%icemecc(bounds%endc-bounds%begc+1))      
+       allocate(this_filter(nc)%do_smb_c(bounds%endc-bounds%begc+1))       
+       
     end do
-    !$OMP END PARALLEL DO
+!$OMP END PARALLEL DO
 
   end subroutine allocFiltersOneGroup
 
-
-  subroutine createProcessorFilter(nclumps, bounds_proc,this_filter,icemask_grc)
-     implicit none
-     !===================================================!
-     integer , intent(in) :: nclumps
-     type(bounds_type), intent(in) :: bounds_proc
-     type(procfilter) , intent(inout) :: this_filter   ! the group of filters to set
-     real(r8)         , intent(in)    :: icemask_grc(bounds_proc%begg: ) ! ice sheet grid coverage mask [gridcell]
-
-     integer :: nc
-     integer :: begp,endp,begc,endc, begl,endl
-
-
-     allocate(this_filter%num_soilc     ); this_filter%num_soilc        = 0
-     allocate(this_filter%num_soilp     ); this_filter%num_soilp        = 0
-     allocate(this_filter%num_pcropp    ); this_filter%num_pcropp       = 0
-     allocate(this_filter%num_nolu_barep); this_filter%num_nolu_barep   = 0
-     allocate(this_filter%num_nolu_vegp ); this_filter%num_nolu_vegp    = 0
-     allocate(this_filter%num_urbanp  );this_filter%num_urbanp   = 0
-     allocate(this_filter%num_nourbanp  );this_filter%num_nourbanp   = 0
-
-     allocate(this_filter%num_urbanc  );this_filter%num_urbanc   = 0
-     allocate(this_filter%num_urbanl  );this_filter%num_urbanl   = 0
-     allocate(this_filter%num_nourbanl);this_filter%num_nourbanl = 0
-     allocate(this_filter%num_lakep  ); this_filter%num_lakep = 0
-     allocate(this_filter%num_lakec)  ; this_filter%num_lakec = 0
-     allocate(this_filter%num_nolakec); this_filter%num_nolakec = 0
-     
-     allocate(this_filter%num_lakesnowc); this_filter%num_lakesnowc = 0
-     allocate(this_filter%num_lakenosnowc); this_filter%num_lakenosnowc = 0
-
-     allocate(this_filter%num_nolakep); this_filter%num_nolakep = 0
-
-     allocate(this_filter%num_hydrologyc)   
-     allocate(this_filter%num_hydrononsoic) 
-     allocate(this_filter%num_snowc)
-     allocate(this_filter%num_nosnowc)
-
-     allocate(this_filter%num_do_smb_c); this_filter%num_do_smb_c = 0 
-     
-     allocate(this_filter%soilc     (bounds_proc%endc-bounds_proc%begc+1)); this_filter%soilc     (:)=0;
-     allocate(this_filter%soilp     (bounds_proc%endp-bounds_proc%begp+1)); this_filter%soilp     (:)=0;
-     allocate(this_filter%pcropp    (bounds_proc%endp-bounds_proc%begp+1)); this_filter%pcropp    (:)=0;
-     allocate(this_filter%nolu_barep(bounds_proc%endp-bounds_proc%begp+1)); this_filter%nolu_barep(:)=0;
-     allocate(this_filter%nolu_vegp (bounds_proc%endp-bounds_proc%begp+1)); this_filter%nolu_vegp (:)=0;
-     !
-     allocate(this_filter%urbanp  (bounds_proc%endp-bounds_proc%begp+1));this_filter%urbanp  (:) = 0;
-     allocate(this_filter%nourbanp  (bounds_proc%endp-bounds_proc%begp+1));this_filter%nourbanp  (:) = 0;
-     !
-     allocate(this_filter%urbanc  (bounds_proc%endc-bounds_proc%begc+1));this_filter%urbanc  (:) = 0;
-     allocate(this_filter%urbanl  (bounds_proc%endl-bounds_proc%begl+1));this_filter%urbanl  (:) = 0;
-     allocate(this_filter%nourbanl(bounds_proc%endl-bounds_proc%begl+1));this_filter%nourbanl(:) = 0;
-     allocate(this_filter%lakep(bounds_proc%endp-bounds_proc%begp+1)); this_filter%lakep(:) = 0;
-     allocate(this_filter%nolakep(bounds_proc%endp-bounds_proc%begp+1)); this_filter%nolakep(:) = 0;
-
-     allocate(this_filter%lakec(bounds_proc%endc-bounds_proc%begc+1)); this_filter%lakec(:) = 0; 
-     allocate(this_filter%nolakec(bounds_proc%endc-bounds_proc%begc+1)) ; this_filter%nolakec(:) = 0; 
-     allocate(this_filter%hydrologyc(bounds_proc%endc-bounds_proc%begc+1))    ; this_filter%hydrologyc(:) = 0;
-     allocate(this_filter%hydrononsoic(bounds_proc%endc-bounds_proc%begc+1))  ; this_filter%hydrononsoic(:)= 0;
-
-     allocate(this_filter%do_smb_c(bounds_proc%endc-bounds_proc%begc+1)); this_filter%do_smb_c(:) = 0 
-     !Not populated in filterMod :
-     allocate(this_filter%snowc(bounds_proc%endc-bounds_proc%begc+1));  this_filter%snowc(:) = 0;
-     allocate(this_filter%nosnowc(bounds_proc%endc-bounds_proc%begc+1)); this_filter%nosnowc(:) = 0;
-
-     allocate(this_filter%lakesnowc(bounds_proc%endc-bounds_proc%begc+1)); this_filter%lakesnowc(:) = 0;
-     allocate(this_filter%lakenosnowc(bounds_proc%endc-bounds_proc%begc+1)); this_filter%lakenosnowc(:) = 0;
-    
-
-  end subroutine createProcessorFilter
-
   !------------------------------------------------------------------------
   subroutine setFilters(bounds, icemask_grc)
-    !$acc routine seq 
+    !
     ! !DESCRIPTION:
     ! Set CLM filters.
     use decompMod , only : BOUNDS_LEVEL_CLUMP
     !
     ! !ARGUMENTS:
-    type(bounds_type) , intent(in) :: bounds
-    real(r8)          , intent(in) :: icemask_grc(bounds%begg: ) ! ice sheet grid coverage mask [gridcell]
+    type(bounds_type) , intent(in) :: bounds  
+    real(r8)          , intent(in) :: icemask_grc( bounds%begg: ) ! ice sheet grid coverage mask [gridcell]
     !------------------------------------------------------------------------
 
+    SHR_ASSERT(bounds%level == BOUNDS_LEVEL_CLUMP, errMsg(__FILE__, __LINE__))
+
     call setFiltersOneGroup(bounds, &
          filter, include_inactive = .false., &
-         icemask_grc = icemask_grc(bounds%begg:bounds%endg) )
+         icemask_grc = icemask_grc(bounds%begg:bounds%endg))
 
     ! At least as of June, 2013, the 'inactive_and_active' version of the filters is
     ! static in time. Thus, we could have some logic saying whether we're in
@@ -404,12 +252,11 @@ contains
     ! filters are updated. But if this proves to be a performance problem, we could
     ! introduce an argument saying whether we're in initialization, and if so, skip this
     ! call.
-
-
+    
     call setFiltersOneGroup(bounds, &
          filter_inactive_and_active, include_inactive = .true., &
          icemask_grc = icemask_grc(bounds%begg:bounds%endg))
-
+    
   end subroutine setFilters
 
 
@@ -422,7 +269,7 @@ contains
     ! "Standard" filters only include active points. However, this routine can be used to set
     ! alternative filters that also apply over inactive points, by setting include_inactive =
     ! .true.
-    !$acc routine seq 
+    !
     ! !USES:
     use decompMod , only : BOUNDS_LEVEL_CLUMP
     use pftvarcon , only : npcropmin, nppercropmin
@@ -430,10 +277,10 @@ contains
     use column_varcon, only : icol_road_perv
     !
     ! !ARGUMENTS:
-    type(bounds_type) , intent(in)    :: bounds
+    type(bounds_type) , intent(in)    :: bounds  
     type(clumpfilter) , intent(inout) :: this_filter(:)              ! the group of filters to set
     logical           , intent(in)    :: include_inactive            ! whether inactive points should be included in the filters
-    real(r8)          , intent(in)    :: icemask_grc(bounds%begg: ) ! ice sheet grid coverage mask [gridcell]
+    real(r8)          , intent(in)    :: icemask_grc( bounds%begg: ) ! ice sheet grid coverage mask [gridcell]
     !
     ! LOCAL VARAIBLES:
     integer :: nc          ! clump index
@@ -448,11 +295,14 @@ contains
     integer :: t           !topounit index
     !------------------------------------------------------------------------
 
+    SHR_ASSERT(bounds%level == BOUNDS_LEVEL_CLUMP, errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(icemask_grc) == (/bounds%endg/)), errMsg(__FILE__, __LINE__))
+
     nc = bounds%clump_index
 
-    ! Create lake and non-lake filters at column-level
+    ! Create lake and non-lake filters at column-level 
 
-    fl  = 0
+    fl = 0
     fnl = 0
     do c = bounds%begc,bounds%endc
        t =col_pp%topounit(c)
@@ -472,12 +322,11 @@ contains
     this_filter(nc)%num_lakec = fl
     this_filter(nc)%num_nolakec = fnl
 
-    ! Create lake and non-lake filters at pft-level
+    ! Create lake and non-lake filters at pft-level 
 
-    fl  = 0
+    fl = 0
     fnl = 0
     fnlu = 0
-
     do p = bounds%begp,bounds%endp
        t =veg_pp%topounit(p)
        if (top_pp%active(t)) then
@@ -535,7 +384,7 @@ contains
     end do
     this_filter(nc)%num_soilp = fs
 
-    ! Create column-level hydrology filter (soil and Urban pervious road cols)
+    ! Create column-level hydrology filter (soil and Urban pervious road cols) 
 
     f = 0
     fn= 0
@@ -672,7 +521,7 @@ contains
        end if
     end do
     this_filter(nc)%num_icemecc = f
-
+    
     f = 0
     do c = bounds%begc,bounds%endc
        t =col_pp%topounit(c)
@@ -688,336 +537,11 @@ contains
           end if
        end if
     end do
-    this_filter(nc)%num_do_smb_c = f
+    this_filter(nc)%num_do_smb_c = f    
 
     ! Note: snow filters are reconstructed each time step in
     ! LakeHydrology and SnowHydrology
 
   end subroutine setFiltersOneGroup
 
-  subroutine setProcFilters(bounds, this_filter, include_inactive,icemask_grc)
-    !
-    ! !DESCRIPTION:
-    ! Set CLM filters for one group of filters.
-    !
-    ! "Standard" filters only include active points. However, this routine can be used to set
-    ! alternative filters that also apply over inactive points, by setting include_inactive =
-    ! .true.
-    !
-    ! !USES:
-    use pftvarcon , only : npcropmin
-    use landunit_varcon, only : istsoil, istcrop, istice_mec
-    use column_varcon, only : icol_road_perv
-    !
-    ! !ARGUMENTS:
-    type(bounds_type) , intent(in)   :: bounds
-    type(procfilter)  , intent(inout) :: this_filter           ! the group of filters to set
-    logical           , intent(in)   :: include_inactive            ! whether inactive points should be included in the filters
-    real(r8) , intent(in) :: icemask_grc(:) 
-    !
-    ! LOCAL VARAIBLES:
-    integer :: nc        ! clump index
-    integer :: c,l,p, t  ! column, landunit, pft indices
-    integer :: g         ! gridcell index
-    integer :: flc        ! lake filter index
-    integer :: fnlc, fnlu,flp,fnlp ! non-lake filter index
-    integer :: fsc,fsp,fpc    ! soil filter index
-    integer :: ful, fnul,fuc,fup,fnup  ! urban indices
-    integer :: fsmb 
-    integer :: fhydroc, fhydronosoic
-    integer :: fcropp 
-    integer :: fidx1, fidx2, fidx3, fidx4, fidx5, fidx6 
-    integer :: begc,endc,begp,endp,begl,endl
-
-    !------------------------------------------------------------------------
-    fidx1 = 0; fidx2 = 0; fidx3 = 0; fidx4 = 0; fidx5 = 0; fidx6 =0;
-    this_filter%num_soilc  = 0   
-    this_filter%num_soilp  = 0   
-    this_filter%num_pcropp = 0 
-    this_filter%num_urbanp = 0
-    this_filter%num_nourbanp = 0
-    this_filter%num_urbanc = 0
-    this_filter%num_urbanl = 0 
-    this_filter%num_nourbanl = 0
-    this_filter%num_lakep  = 0
-    this_filter%num_nolakep  = 0
-
-    this_filter%num_lakec  = 0 
-    this_filter%num_nolakec= 0
-    
-    this_filter%num_do_smb_c = 0 
-    begl = bounds%begl; endl = bounds%endl 
-    begc = bounds%begc; endc = bounds%endc 
-    begp = bounds%begp; endp = bounds%endp
-
-   !$acc enter data copyin(include_inactive) 
-   
-   flc = 0
-   fnlc = 0 
-   !$acc parallel loop independent gang vector default(present) &
-   !$acc      private(fidx1,fidx2,l) copy(flc,fnlc) present(this_filter%lakec(:),this_filter%nolakec(:))
-    do c = begc, endc
-       if( col_pp%active(c) .or. include_inactive ) then
-          l = col_pp%landunit(c)
-          if (lun_pp%lakpoi(l)) then
-            !$acc atomic capture 
-            flc = flc + 1
-            fidx1 = flc 
-            !$acc end atomic 
-            this_filter%lakec(fidx1) = c
-          else
-            !$acc atomic capture  
-            fnlc = fnlc + 1
-            fidx2 = fnlc 
-            !$acc end atomic 
-            this_filter%nolakec(fidx2) = c
-          end if
-       end if 
-   end do 
-   this_filter%num_lakec = flc
-   this_filter%num_nolakec = fnlc
-   
-   fsc = 0; 
-   fuc = 0;  
-   !$acc parallel loop independent gang vector private(fidx1) copy(fsc) &
-   !$acc   present(this_filter%soilc(:)) default(present)
-    do c = begc, endc
-       if (col_pp%active(c) .or. include_inactive) then
-          l =col_pp%landunit(c)
-         ! Create soil filter at column-level
-          if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-            !$acc atomic capture  
-            fsc = fsc + 1
-            fidx1 = fsc 
-            !$acc end atomic 
-            this_filter%soilc(fidx1) = c
-          end if
-       end if
-    end do
-    this_filter%num_soilc = fsc
-
-   !$acc parallel loop independent gang vector private(fidx2) copy(fuc) &
-   !$acc present(this_filter%urbanc(:),lun_pp%urbpoi(:),col_pp%landunit(:),col_pp%active(:) ) default(present)
-    do c = begc, endc
-       if (col_pp%active(c) .or. include_inactive) then
-          l =col_pp%landunit(c)
-          ! Create column-level urban and non-urban filters
-          if (lun_pp%urbpoi(l)) then
-             !$acc atomic capture 
-            fuc = fuc + 1
-            fidx2 = fuc 
-            !$acc end atomic 
-            this_filter%urbanc(fidx2) = c
-         end if
-       end if
-    end do
-
-    this_filter%num_urbanc = fuc
-    ! Create soil filter at pft-level
-    fsp = 0 
-    fcropp = 0
-    fup = 0
-    fnup = 0
-   
-    !$acc parallel loop independent gang vector default(present) &
-    !$acc   private(fidx1,fidx2) copy(fsp,fcropp) present(this_filter%soilp(:),this_filter%pcropp(:) )
-    do p = begp, endp
-      if (veg_pp%active(p) .or. include_inactive) then
-          l =veg_pp%landunit(p)
-          if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
-            !$acc atomic capture  
-            fsp = fsp + 1
-            fidx1 = fsp 
-            !$acc end atomic 
-            this_filter%soilp(fidx1) = p
-          end if
-          if (veg_pp%itype(p) >= npcropmin) then !skips 2 generic crop types
-            !$acc atomic capture 
-            fcropp   = fcropp + 1
-            fidx2 = fcropp 
-            !$acc end atomic 
-            this_filter%pcropp(fidx2) = p
-         end if 
-      end if 
-    end do 
-    !$acc parallel loop independent gang vector default(present) &
-    !$acc   private(fidx1,fidx2 ) copy(fup,fnup) present(this_filter%urbanp(:), this_filter%nourbanp(:))
-    do p = begp, endp
-      if (veg_pp%active(p) .or. include_inactive) then
-          l =veg_pp%landunit(p)
-         if (lun_pp%urbpoi(l)) then
-            !$acc atomic capture 
-            fup = fup + 1
-            fidx1 = fup 
-            !$acc end atomic 
-            this_filter%urbanp(fidx1) = p
-         else 
-            !$acc atomic capture 
-            fnup = fnup + 1
-            fidx2 = fnup 
-            !$acc end atomic 
-            this_filter%nourbanp(fidx2) = p
-         end if
-      end if
-    end do
-   this_filter%num_soilp  = fsp
-   this_filter%num_pcropp = fcropp
-   this_filter%num_urbanp = fup
-   this_filter%num_nourbanp = fnup 
-   
-   flp = 0 
-   fnlp = 0 
-   !$acc parallel loop independent gang vector default(present) &
-   !$acc   private(fidx1,fidx2) copy(flp,fnlp) present(this_filter%lakep(:), this_filter%nolakep(:))
-    do p = begp, endp
-      if (veg_pp%active(p) .or. include_inactive) then
-          l =veg_pp%landunit(p)
-         if (lun_pp%lakpoi(l) ) then
-            !$acc atomic capture 
-            flp = flp + 1
-            fidx1 = flp 
-            !$acc end atomic 
-            this_filter%lakep(fidx1) = p
-         else 
-           !$acc atomic capture
-            fnlp = fnlp + 1 
-            fidx2 = fnlp 
-            !$acc end atomic 
-            this_filter%nolakep(fidx2) = p 
-         end if
-      end if 
-   end do 
-
-   this_filter%num_lakep = flp
-   this_filter%num_nolakep = fnlp    
-   ful = 0 
-   fnul = 0 
-   ! Create landunit-level urban and non-urban filters
-   !$acc parallel loop independent gang vector default(present) &
-   !$acc   private(fidx1,fidx2) copy(ful,fnul) present(this_filter%urbanl(:),this_filter%nourbanl(:))
-    do l = begl, endl
-       if (lun_pp%active(l) .or. include_inactive) then
-          if (lun_pp%urbpoi(l)) then
-            !$acc atomic capture 
-             ful = ful + 1
-             fidx1 = ful 
-             !$acc end atomic 
-             this_filter%urbanl(fidx1) = l
-          else
-             !$acc atomic capture 
-             fnul = fnul + 1
-             fidx2 = fnul 
-             !$acc end atomic 
-             this_filter%nourbanl(fidx2) = l
-          end if
-       end if
-    end do
-    this_filter%num_urbanl = ful
-    this_filter%num_nourbanl = fnul
-
-    ! Create column-level hydrology filter (soil and Urban pervious road cols)
-    fhydroc = 0 
-    fhydronosoic = 0 
-   !$acc parallel loop independent gang vector default(present) &
-   !$acc   private(fidx1,fidx2) copy(fhydroc, fhydronosoic) present(this_filter%hydrologyc(:),this_filter%hydrononsoic(:))
-    do c = begc, endc
-      if (col_pp%active(c) .or. include_inactive) then
-         l =col_pp%landunit(c)
-         if (lun_pp%itype(l) == istsoil .or. col_pp%itype(c) == icol_road_perv .or. &
-              lun_pp%itype(l) == istcrop) then
-             !$acc atomic capture 
-              fhydroc = fhydroc + 1
-              fidx1 = fhydroc 
-             !$acc end atomic 
-              this_filter%hydrologyc(fidx1) = c
-           if (col_pp%itype(c) == icol_road_perv) then
-             !$acc atomic capture  
-              fhydronosoic = fhydronosoic + 1
-              fidx2 = fhydronosoic 
-             !$acc end atomic 
-               this_filter%hydrononsoic(fidx2) = c
-           end if
-         end if
-      end if
-    end do
-    this_filter%num_hydrologyc = fhydroc
-    this_filter%num_hydrononsoic = fhydronosoic
-     fsmb = 0 
-    !$acc parallel loop independent gang vector default(present) &
-    !$acc   private(fidx1) copy(fsmb) present(this_filter%do_smb_c(:))
-     do c = begc, endc
-        t =col_pp%topounit(c)
-        if (top_pp%active(t)) then
-           if (col_pp%active(c) .or. include_inactive) then
-              l = col_pp%landunit(c)
-              g = col_pp%gridcell(c)
-              if ( lun_pp%itype(l) == istice_mec .or. &
-                 (lun_pp%itype(l) == istsoil .and. icemask_grc(g) > 0.)) then
-                 !$acc atomic capture 
-                 fsmb = fsmb + 1
-                 fidx1 = fsmb
-                 !$acc end atomic 
-                 this_filter%do_smb_c(fidx1) = c
-              end if
-           end if
-        end if
-     end do
-    this_filter%num_do_smb_c = fsmb
-
-    !$acc exit data delete(include_inactive)
-    
-  end subroutine setProcFilters
-
-  subroutine updateFracNoSnoFilters(bounds, this_filter,frac_veg_nosno)
-   ! !DESCRIPTION
-   ! This is a separate routine to update only the new 
-   ! no lake/urban bare ground or vegetated patches used 
-   ! in BareGroundFluxes and CanopyFluxes.
-   ! frac_veg_nosno is currently updated in elm_drv_init, which 
-   ! is after the dynSubgrid setFilters, hence the separate routine.
-   !
-   ! Currently there is no need to calculate this for inactive patches.
-   implicit none 
-   ! !Input/Output Variables 
-   type(bounds_type), intent(in)  :: bounds 
-   type(procfilter), intent(inout) :: this_filter 
-   integer          , intent(in)   :: frac_veg_nosno(:)
-   ! !Local variables 
-   integer :: p, fbp, fvp, l, begp, endp  
-   integer :: fidx1, fidx2 
-        
-   begp = bounds%begp
-   endp = bounds%endp
-
-   fbp = 0
-   fvp = 0
-
-   !$acc parallel loop independent gang vector default(present) private(fidx1, fidx2) copy(fbp,fvp) &
-   !$acc present(this_filter%nolu_barep(:),this_filter%nolu_vegp(:))
-   do p = begp,endp
-    if (veg_pp%active(p)) then
-       l =veg_pp%landunit(p)
-       if(.not. lun_pp%lakpoi(l) .and. .not. (lun_pp%urbpoi(l)) ) then
-         if (frac_veg_nosno(p) == 0) then !BareGround??
-            !$acc atomic capture 
-            fbp = fbp + 1
-            fidx1 = fbp 
-            !$acc end atomic 
-            this_filter%nolu_barep(fidx1) = p
-         else !pft is not bareground
-            !$acc atomic capture 
-            fvp = fvp + 1
-            fidx2 = fvp 
-            !$acc end atomic 
-            this_filter%nolu_vegp(fidx2) = p
-         end if
-       end if
-    end if
-   end do
-
-   this_filter%num_nolu_barep = fbp
-   this_filter%num_nolu_vegp  = fvp
-
-  end subroutine updateFracNoSnoFilters
-
 end module filterMod
diff --git a/components/elm/src/main/glc2lndMod.F90 b/components/elm/src/main/glc2lndMod.F90
index b799515b9f..1e178c6d92 100644
--- a/components/elm/src/main/glc2lndMod.F90
+++ b/components/elm/src/main/glc2lndMod.F90
@@ -275,6 +275,7 @@ contains
     use elm_varcon      , only : ispval
     use elm_varctl      , only : glc_do_dynglacier
     use landunit_varcon , only : istice_mec
+    use column_varcon   , only : col_itype_to_icemec_class
     use subgridWeightsMod , only : set_landunit_weight
     !
     ! !ARGUMENTS:
@@ -322,15 +323,15 @@ contains
                if (area_ice_mec > 0) then
                   ! Determine index of the glc_mec landunit
                   l_ice_mec = top_pp%landunit_indices(istice_mec, t)
-#ifndef _OPENACC              
+                  
                   if (l_ice_mec == ispval) then
                      write(iulog,*) ' ERROR: no ice_mec landunit found within the icemask, for g = ', g
                      call endrun()
                   end if
-#endif 
+
                   frac_assigned(1:maxpatch_glcmec) = .false.
                   do c = lun_pp%coli(l_ice_mec), lun_pp%colf(l_ice_mec)
-                     icemec_class = col_pp%itype(c) - istice_mec*100 
+                     icemec_class = col_itype_to_icemec_class(col_pp%itype(c))
                      col_pp%wtlunit(c) = glc2lnd_vars%frac_grc(g, icemec_class) / lun_pp%wttopounit(l_ice_mec)
                      frac_assigned(icemec_class) = .true.
                   end do
@@ -361,7 +362,7 @@ contains
        ! Values from GLC are only valid within the icemask, so we only update CLM's topo values there
        if (glc2lnd_vars%icemask_grc(g) > 0._r8) then
           if (lun_pp%itype(l) == istice_mec) then
-             icemec_class = col_pp%itype(c) - istice_mec*100
+             icemec_class = col_itype_to_icemec_class(col_pp%itype(c))
           else
              ! If not on a glaciated column, assign topography to the bare-land value determined by GLC.
              icemec_class = 0
diff --git a/components/elm/src/main/histFileMod.F90 b/components/elm/src/main/histFileMod.F90
index 3a238857ae..edae6df593 100644
--- a/components/elm/src/main/histFileMod.F90
+++ b/components/elm/src/main/histFileMod.F90
@@ -230,7 +230,6 @@ module histFileMod
   ! History tape: an array of history_tape entities (only active fields)
   !
   type (history_tape), public :: tape(max_tapes)       ! array history tapes
-  !$acc declare create(elmptr_rs, elmptr_ra)
   !
   ! Namelist input
   !
diff --git a/components/elm/src/main/histGPUMod.F90 b/components/elm/src/main/histGPUMod.F90
index f35ed8cf52..43522b97c4 100644
--- a/components/elm/src/main/histGPUMod.F90
+++ b/components/elm/src/main/histGPUMod.F90
@@ -2,60 +2,71 @@ module histGPUMod
 
   use shr_kind_mod  , only : r8 => shr_kind_r8
   use decompMod     , only : bounds_type
-  use histFileMod   , only : elmptr_rs, elmptr_ra, elmpoint_rs
+  use histFileMod   , only : elmptr_rs, elmptr_ra
   use elm_varcon    , only : spval, ispval, dzsoi_decomp
   use elm_varcon    , only : grlnd, nameg, namet, namel, namec, namep
   use GridcellType  , only : grc_pp
   use LandunitType  , only : lun_pp
   use ColumnType    , only : col_pp
   use VegetationType, only : veg_pp
-  use subgridAveMod, only : unity, urbanf, urbans, natveg, veg,ice,nonurb,lake 
+
   implicit None
 
   integer , private, parameter :: no_snow_MIN = 1                 ! minimum valid value for this flag
-  integer , public , parameter :: no_snow_normal = 1  ! normal treatment, which should be used for most fields (use spval when snow layer not present)
-  integer , public , parameter :: no_snow_zero = 2    ! average in a 0 value for times when the snow layer isn't present
+  integer , public , parameter :: no_snow_normal = 1              ! normal treatment, which should be used for most fields (use spval when snow layer not present)
+  integer , public , parameter :: no_snow_zero = 2                ! average in a 0 value for times when the snow layer isn't present
   integer , private, parameter :: no_snow_MAX = 2                 ! maximum valid value for this flag
   integer , private, parameter :: no_snow_unset = no_snow_MIN - 1 ! flag specifying that field is NOT a multi-layer snow field
+  integer , parameter :: unity = 0, urbanf = 1, urbans = 2
+  integer , parameter :: natveg = 3, veg =4, ice=5, nonurb=6, lake=7
 
   !!mappings that hold the tape and field position in the CPU tapes
   !!for a given field on the gpu tape
   integer, allocatable  :: map_tapes(:)
   integer, allocatable  :: map_fields(:)
-  integer :: total_flds
+
   PUBLIC
 
   type, public :: history_entry_gpu
-    !
-     character(len=16), pointer :: type1d     ! pointer to first dimension type from data type (nameg, etc)
-     character(len=16), pointer :: type1d_out ! hbuf first dimension type from data type (nameg, etc)
-     integer, pointer :: beg1d      ! on-node 1d clm pointer start index
-     integer, pointer :: end1d      ! on-node 1d clm pointer end index
-     integer, pointer :: num1d      ! size of clm pointer first dimension (all nodes)
-     integer, pointer :: numdims    ! the actual number of dimensions, this allows
+     character(len=64), pointer :: name       => null() ! field name
+     character(len=16), pointer :: type1d     => null() ! pointer to first dimension type from data type (nameg, etc)
+     character(len=16), pointer :: type1d_out => null() ! hbuf first dimension type from data type (nameg, etc)
+     character(len=16), pointer :: type2d     => null() ! hbuf second dimension type ["levgrnd","levlak","numrad","ltype","natpft","cft","glc_nec","elevclas","subname(n)","month"]
+     integer, pointer :: beg1d   => null()   ! on-node 1d clm pointer start index
+     integer, pointer :: end1d   => null()   ! on-node 1d clm pointer end index
+     integer, pointer :: num1d   => null()   ! size of clm pointer first dimension (all nodes)
+     integer, pointer :: numdims => null()   ! the actual number of dimensions, this allows
                                              ! for 2D arrays, where the second dimension is allowed
                                              ! to be 1
-     integer, pointer :: beg1d_out   ! on-node 1d hbuf pointer start index
-     integer, pointer :: end1d_out   ! on-node 1d hbuf pointer end index
-     integer, pointer :: num1d_out   ! size of hbuf first dimension (all nodes)
-     integer, pointer :: num2d       ! size of hbuf second dimension (e.g. number of vertical levels)
-     integer, pointer :: hpindex     ! history pointer index
-     integer, pointer :: p2c_scale_type  ! scale factor when averaging pft to column
-     integer, pointer :: c2l_scale_type  ! scale factor when averaging column to landunit
-     integer, pointer :: l2g_scale_type  ! scale factor when averaging landunit to gridcell
-
-     integer, pointer :: no_snow_behavior ! for multi-layer snow fields, flag saying how to treat times when a given snow layer is absent
+     integer,pointer :: beg1d_out =>null()   ! on-node 1d hbuf pointer start index
+     integer,pointer :: end1d_out =>null()   ! on-node 1d hbuf pointer end index
+     integer,pointer :: num1d_out =>null()   ! size of hbuf first dimension (all nodes)
+     integer,pointer :: num2d     =>null()   ! size of hbuf second dimension (e.g. number of vertical levels)
+     integer,pointer :: hpindex   =>null()   ! history pointer index
+     integer, pointer :: p2c_scale_type => null() ! scale factor when averaging pft to column
+     integer, pointer :: c2l_scale_type => null() ! scale factor when averaging column to landunit
+     integer, pointer :: l2g_scale_type => null() ! scale factor when averaging landunit to gridcell
+     character(len=8), pointer :: t2g_scale_type => null() ! scale factor when averaging topounit to gridcell
+     integer, pointer :: no_snow_behavior => null()        ! for multi-layer snow fields, flag saying how to treat times when a given snow layer is absent
      !
-     character(len=1), pointer  :: avgflag   ! time averaging flag
-     real(r8), pointer :: hbuf(:,:) ! history buffer (dimensions: dim1d x num2d)
-     integer , pointer :: nacs(:,:) ! accumulation counter (dimensions: dim1d x num2d)
+     character(len=1), pointer  :: avgflag => null()   ! time averaging flag
+     real(r8), pointer :: hbuf(:,:)   => null()         ! history buffer (dimensions: dim1d x num2d)
+     integer , pointer :: nacs(:,:)   => null()         ! accumulation counter (dimensions: dim1d x num2d)
   end type history_entry_gpu
 
-  type (history_entry_gpu), public, allocatable :: tape_gpu(:)   ! array concat htapes
-  !$acc declare create(tape_gpu(:))
-!   type(elmpoint_rs) , public, allocatable :: gpu_elmptr_rs(:)
-!!!!$acc declare create(gpu_elmptr_rs(:))  
-  public :: hist_update_hbuf_gpu
+  type, public :: history_tape_gpu
+     integer , pointer  :: nflds      => null() ! number of active fields on tape
+     integer , pointer  :: ntimes     => null() ! current number of time samples on tape
+     integer , pointer  :: mfilt      => null() ! maximum number of time samples per tape
+     integer , pointer  :: nhtfrq     => null() ! number of time samples per tape
+     logical , pointer  :: is_endhist => null() ! true => current time step is end of history interval
+     real(r8), pointer  :: begtime    => null() ! time at beginning of history averaging interval
+     type (history_entry_gpu), allocatable :: hlist(:)   ! array of active history tape entries
+  end type history_tape_gpu
+
+  type (history_tape_gpu), public :: tape_gpu    ! array concat htapes
+  !$acc declare create(tape_gpu)
+
 contains
 
   subroutine htape_gpu_init()
@@ -65,123 +76,126 @@ contains
 
     implicit none
     integer :: size1,size2,t,f,field
-    integer :: num1dflds, num2dflds 
-    integer :: hp
-    integer, parameter :: maxflds = 100 
+    integer :: total_flds
     total_flds = 0
-    num1dflds = 0
-    num2dflds = 0 
 
     !!First sum to get total fields:
     do t = 1, ntapes
       total_flds = total_flds + tape(t)%nflds
     end do
-
+    allocate(tape_gpu%nflds) ;tape_gpu%nflds = total_flds
     print *, "allocating tapu_gpu%hlist with ",total_flds,"fields"
+    allocate(tape_gpu%hlist(total_flds))
+
+    allocate(tape_gpu%ntimes)
+    allocate(tape_gpu%mfilt )
+    allocate(tape_gpu%nhtfrq)
+    tape_gpu%nflds  = tape(1)%nflds
+    tape_gpu%ntimes = tape(1)%ntimes
+    tape_gpu%mfilt  = tape(1)%mfilt
+    tape_gpu%nhtfrq = tape(1)%nhtfrq
     !!! Fill out tape_gpu and create mappings
+    !!! TODO:  the size of field is know so should
+    !!! rewrite loop to be done in parallel.
     field = 1
     allocate(map_tapes(total_flds),map_fields(total_flds))
-    allocate(tape_gpu(total_flds))
     do t = 1, ntapes
       do f = 1, tape(t)%nflds
         map_tapes(field) = t ; map_fields(field) = f
         size1 = size(tape(t)%hlist(f)%hbuf,1);
         size2 = size(tape(t)%hlist(f)%hbuf,2)
-        allocate(tape_gpu(field)%hbuf(size1,size2))
+        allocate(tape_gpu%hlist(field)%hbuf(size1,size2))
         size1 = size(tape(t)%hlist(f)%nacs,1);
         size2 = size(tape(t)%hlist(f)%nacs,2)
-        allocate(tape_gpu(field)%nacs(size1,size2))
-        tape_gpu(field)%hbuf(:,:) = tape(t)%hlist(f)%hbuf(:,:)
-        tape_gpu(field)%nacs(:,:) = tape(t)%hlist(f)%nacs(:,:)
-        allocate(tape_gpu(field)%avgflag)
+        allocate(tape_gpu%hlist(field)%nacs(size1,size2))
+        tape_gpu%hlist(field)%hbuf(:,:) = tape(t)%hlist(f)%hbuf(:,:)
+        tape_gpu%hlist(field)%nacs(:,:) = tape(t)%hlist(f)%nacs(:,:)
         !!
-        tape_gpu(field)%avgflag = tape(t)%hlist(f)%avgflag
-        allocate(tape_gpu(field)%type1d          )
-        allocate(tape_gpu(field)%type1d_out      )
-        allocate(tape_gpu(field)%beg1d           )
-        allocate(tape_gpu(field)%end1d           )
-        allocate(tape_gpu(field)%num1d           )
-        allocate(tape_gpu(field)%numdims         )
-        allocate(tape_gpu(field)%beg1d_out       )
-        allocate(tape_gpu(field)%end1d_out       )
-        allocate(tape_gpu(field)%num1d_out       )
-        allocate(tape_gpu(field)%num2d           )
-        allocate(tape_gpu(field)%hpindex         )
-        allocate(tape_gpu(field)%p2c_scale_type  )
-        allocate(tape_gpu(field)%c2l_scale_type  )
-        allocate(tape_gpu(field)%l2g_scale_type  )
-        allocate(tape_gpu(field)%no_snow_behavior)
-        tape_gpu(field)%type1d     = tape(t)%hlist(f)%field%type1d
-        tape_gpu(field)%type1d_out = tape(t)%hlist(f)%field%type1d_out
-        tape_gpu(field)%beg1d      = tape(t)%hlist(f)%field%beg1d
-        tape_gpu(field)%end1d      = tape(t)%hlist(f)%field%end1d
-        tape_gpu(field)%num1d      = tape(t)%hlist(f)%field%num1d
-        tape_gpu(field)%numdims    = tape(t)%hlist(f)%field%numdims
-        tape_gpu(field)%beg1d_out  = tape(t)%hlist(f)%field%beg1d_out
-        tape_gpu(field)%end1d_out  = tape(t)%hlist(f)%field%end1d_out
-        tape_gpu(field)%num1d_out  = tape(t)%hlist(f)%field%num1d_out
-        tape_gpu(field)%num2d      = tape(t)%hlist(f)%field%num2d
-        tape_gpu(field)%hpindex    = tape(t)%hlist(f)%field%hpindex
-        
-      !   if(tape_gpu(field)%numdims == 1 .and. num1dflds < maxflds  ) then 
-      !       num1dflds = num1dflds + 1
-      !       hp = tape_gpu(f)%hpindex
-      !       gpu_elmptr_rs(num1dflds)%ptr => elmptr_rs(hp)%ptr
-      !   else
-      !       num2dflds = num2dflds + 1 
-      !   end if 
-
+        allocate(tape_gpu%hlist(field)%avgflag)
+        tape_gpu%hlist(field)%avgflag = tape(t)%hlist(f)%avgflag
+        allocate(tape_gpu%hlist(field)%name            )
+        allocate(tape_gpu%hlist(field)%type1d          )
+        allocate(tape_gpu%hlist(field)%type1d_out      )
+        allocate(tape_gpu%hlist(field)%type2d          )
+        allocate(tape_gpu%hlist(field)%beg1d           )
+        allocate(tape_gpu%hlist(field)%end1d           )
+        allocate(tape_gpu%hlist(field)%num1d           )
+        allocate(tape_gpu%hlist(field)%numdims         )
+        allocate(tape_gpu%hlist(field)%beg1d_out       )
+        allocate(tape_gpu%hlist(field)%end1d_out       )
+        allocate(tape_gpu%hlist(field)%num1d_out       )
+        allocate(tape_gpu%hlist(field)%num2d           )
+        allocate(tape_gpu%hlist(field)%hpindex         )
+        allocate(tape_gpu%hlist(field)%p2c_scale_type  )
+        allocate(tape_gpu%hlist(field)%c2l_scale_type  )
+        allocate(tape_gpu%hlist(field)%l2g_scale_type  )
+        allocate(tape_gpu%hlist(field)%t2g_scale_type  )
+        allocate(tape_gpu%hlist(field)%no_snow_behavior)
+        tape_gpu%hlist(field)%name       = tape(t)%hlist(f)%field%name
+        tape_gpu%hlist(field)%type1d     = tape(t)%hlist(f)%field%type1d
+        tape_gpu%hlist(field)%type1d_out = tape(t)%hlist(f)%field%type1d_out
+        tape_gpu%hlist(field)%type2d     = tape(t)%hlist(f)%field%type2d
+        tape_gpu%hlist(field)%beg1d      = tape(t)%hlist(f)%field%beg1d
+        tape_gpu%hlist(field)%end1d      = tape(t)%hlist(f)%field%end1d
+        tape_gpu%hlist(field)%num1d      = tape(t)%hlist(f)%field%num1d
+        tape_gpu%hlist(field)%numdims    = tape(t)%hlist(f)%field%numdims
+        tape_gpu%hlist(field)%beg1d_out  = tape(t)%hlist(f)%field%beg1d_out
+        tape_gpu%hlist(field)%end1d_out  = tape(t)%hlist(f)%field%end1d_out
+        tape_gpu%hlist(field)%num1d_out  = tape(t)%hlist(f)%field%num1d_out
+        tape_gpu%hlist(field)%num2d      = tape(t)%hlist(f)%field%num2d
+        tape_gpu%hlist(field)%hpindex    = tape(t)%hlist(f)%field%hpindex
         if(trim(tape(t)%hlist(f)%field%p2c_scale_type) =='unity') then
-            tape_gpu(field)%p2c_scale_type = unity
+            tape_gpu%hlist(field)%p2c_scale_type = unity
         elseif(trim(tape(t)%hlist(f)%field%p2c_scale_type) =='urbanf')Then
-            tape_gpu(field)%p2c_scale_type = urbanf
+            tape_gpu%hlist(field)%p2c_scale_type = urbanf
         elseif(trim(tape(t)%hlist(f)%field%p2c_scale_type) =='urbans')Then
-            tape_gpu(field)%p2c_scale_type = urbans
+            tape_gpu%hlist(field)%p2c_scale_type = urbans
         end if
         if(trim(tape(t)%hlist(f)%field%c2l_scale_type) =='unity') then
-            tape_gpu(field)%c2l_scale_type = unity
+            tape_gpu%hlist(field)%c2l_scale_type = unity
         elseif(trim(tape(t)%hlist(f)%field%c2l_scale_type) =='urbanf')Then
-            tape_gpu(field)%c2l_scale_type = urbanf
+            tape_gpu%hlist(field)%c2l_scale_type = urbanf
         elseif(trim(tape(t)%hlist(f)%field%c2l_scale_type) =='urbans')Then
-            tape_gpu(field)%c2l_scale_type = urbans
+            tape_gpu%hlist(field)%c2l_scale_type = urbans
         end if
 
         if (trim(tape(t)%hlist(f)%field%l2g_scale_type) == 'unity') then
-           tape_gpu(field)%l2g_scale_type = unity
+           tape_gpu%hlist(field)%l2g_scale_type = unity
         else if (trim(tape(t)%hlist(f)%field%l2g_scale_type) == 'natveg') then
-           tape_gpu(field)%l2g_scale_type = natveg
+           tape_gpu%hlist(field)%l2g_scale_type = natveg
         else if (trim(tape(t)%hlist(f)%field%l2g_scale_type) == 'veg') then
-           tape_gpu(field)%l2g_scale_type = veg
+           tape_gpu%hlist(field)%l2g_scale_type = veg
         else if (trim(tape(t)%hlist(f)%field%l2g_scale_type) == 'ice') then
-           tape_gpu(field)%l2g_scale_type = ice
+           tape_gpu%hlist(field)%l2g_scale_type = ice
         else if (trim(tape(t)%hlist(f)%field%l2g_scale_type) == 'nonurb') then
-           tape_gpu(field)%l2g_scale_type = nonurb
+           tape_gpu%hlist(field)%l2g_scale_type = nonurb
         else if (trim(tape(t)%hlist(f)%field%l2g_scale_type) == 'lake') then
-           tape_gpu(field)%l2g_scale_type = lake
+           tape_gpu%hlist(field)%l2g_scale_type = lake
         else
            print *, "scale_l2g_lookup_array : scale type  not supported   ",tape(t)%hlist(f)%field%l2g_scale_type
            stop
         end if
-        tape_gpu(field)%no_snow_behavior = tape(t)%hlist(f)%field%no_snow_behavior
+
+        tape_gpu%hlist(field)%t2g_scale_type   = tape(t)%hlist(f)%field%t2g_scale_type
+        tape_gpu%hlist(field)%no_snow_behavior = tape(t)%hlist(f)%field%no_snow_behavior
         field = field + 1
       end do
     enddo
 
-
   end subroutine htape_gpu_init
 
-!   !-----------------------------------------------------------------------
-  subroutine hist_update_hbuf_gpu(step,transfer_tapes, nclumps )
+  !-----------------------------------------------------------------------
+  subroutine hist_update_hbuf_gpu(step,inc, nclumps)
     !
     ! !DESCRIPTION:
     ! Accumulate (or take min, max, etc. as appropriate) input field
     ! into its history buffer for appropriate tapes.
     !
-    use histFileMod, only : ntapes,elmptr_rs, elmptr_ra  
-    use decompMod, only : get_proc_bounds,get_clump_bounds_gpu, bounds_type
+    use histFileMod, only : ntapes
+    use decompMod, only : get_proc_bounds,get_clump_bounds, bounds_type
     ! !ARGUMENTS:
     integer , intent(in) :: step
-    logical , intent(in) :: transfer_tapes
+    integer , intent(in) :: inc
     integer, value, intent(in) :: nclumps
     !
     ! !LOCAL VARIABLES:
@@ -190,38 +204,42 @@ contains
     integer :: f                   ! field index
     integer :: numdims             ! number of dimensions
     integer :: num2d               ! size of second dimension (e.g. number of vertical levels)
-    integer :: field 
+    integer :: field, total_flds
     !----------------------------------------------------------------------
-      
-    print *, "History Buffer with ",total_flds,"fields" 
-    !$acc parallel loop gang vector collapse(2) independent default(present) private(nc,f,hp,numdims,num2d,bounds)
+
+    total_flds = tape_gpu%nflds
+
+
+    !$acc parallel vector_length(128) default(present)
+    !$acc loop gang worker collapse(2) independent private(nc,f,hp,numdims,num2d,bounds)
     do nc = 1, nclumps
       do f = 1, total_flds
-        call get_clump_bounds_gpu(nc, bounds)
+        !call get_proc_bounds(bounds)
+        call get_clump_bounds(nc, bounds)
 
-        numdims = tape_gpu(f)%numdims
+        numdims = tape_gpu%hlist(f)%numdims
         if ( numdims == 1) then
-              hp = tape_gpu(f)%hpindex
-              call hist_update_hbuf_field_1d_gpu( f, hp ,bounds,elmptr_rs(hp)%ptr)
+              hp = tape_gpu%hlist(f)%hpindex
+              call hist_update_hbuf_field_1d_gpu( f, hp ,bounds)
         else
-              hp = tape_gpu(f)%hpindex
-              num2d = tape_gpu(f)%num2d
-              call hist_update_hbuf_field_2d_gpu( f, hp , bounds, num2d,elmptr_ra(hp)%ptr)
+              hp = tape_gpu%hlist(f)%hpindex
+              num2d = tape_gpu%hlist(f)%num2d
+              call hist_update_hbuf_field_2d_gpu( f, hp , bounds, num2d)
         end if
 
       enddo
     end do
+    !$acc end parallel
 
     !TODO: change inc to be end of hist interval?
-    if(transfer_tapes) then
+    if(mod(step,inc) == 0 .and. step .ne. 0) then
         print *, "transfering tape to cpu:"
         call transfer_tape_to_cpu()
-        call set_gpu_tape
     endif
   end subroutine hist_update_hbuf_gpu
 
   !-----------------------------------------------------------------------
-  subroutine hist_update_hbuf_field_1d_gpu( f, hpindex, bounds,field)
+  subroutine hist_update_hbuf_field_1d_gpu( f, hpindex, bounds)
     !$acc routine seq
     ! !DESCRIPTION:
     ! Accumulate (or take min, max, etc. as appropriate) input field
@@ -240,7 +258,6 @@ contains
     integer,value, intent(in) :: f            ! field index
     integer,value, intent(in) :: hpindex
     type(bounds_type), intent(in) :: bounds
-    real(r8), intent(inout) :: field(:) 
     !
     ! !LOCAL VARIABLES:
     integer  :: k                       ! gridcell, landunit, column or pft index
@@ -254,17 +271,17 @@ contains
     !-----------------------------------------------------------------------
 
     associate(&
-      avgflag        =>  tape_gpu(f)%avgflag  ,&
-      nacs           =>  tape_gpu(f)%nacs       ,&
-      hbuf           =>  tape_gpu(f)%hbuf       ,&
-      beg1d          =>  tape_gpu(f)%beg1d     ,&
-      end1d          =>  tape_gpu(f)%end1d      ,&
-      type1d         =>  tape_gpu(f)%type1d     ,&
-      type1d_out     =>  tape_gpu(f)%type1d_out    ,&
-      p2c_scale_type =>  tape_gpu(f)%p2c_scale_type,&
-      c2l_scale_type =>  tape_gpu(f)%c2l_scale_type,&
-      l2g_scale_type =>  tape_gpu(f)%l2g_scale_type &
-      !field          =>  elmptr_rs(hpindex)%ptr &
+      avgflag        =>  tape_gpu%hlist(f)%avgflag  ,&
+      nacs           =>  tape_gpu%hlist(f)%nacs       ,&
+      hbuf           =>  tape_gpu%hlist(f)%hbuf       ,&
+      beg1d          =>  tape_gpu%hlist(f)%beg1d     ,&
+      end1d          =>  tape_gpu%hlist(f)%end1d      ,&
+      type1d         =>  tape_gpu%hlist(f)%type1d     ,&
+      type1d_out     =>  tape_gpu%hlist(f)%type1d_out    ,&
+      p2c_scale_type =>  tape_gpu%hlist(f)%p2c_scale_type,&
+      c2l_scale_type =>  tape_gpu%hlist(f)%c2l_scale_type,&
+      l2g_scale_type =>  tape_gpu%hlist(f)%l2g_scale_type,&
+      field          =>  elmptr_rs(hpindex)%ptr &
       )
     ! set variables to check weights when allocate all pfts
 
@@ -454,7 +471,7 @@ contains
 end subroutine hist_update_hbuf_field_1d_gpu
 
   !-----------------------------------------------------------------------
-  subroutine hist_update_hbuf_field_2d_gpu ( f,hpindex, bounds, num2d, field)
+  subroutine hist_update_hbuf_field_2d_gpu ( f,hpindex, bounds, num2d)
     !$acc routine seq
     ! !DESCRIPTION:
     ! Accumulate (or take min, max, etc. as appropriate) input field
@@ -472,7 +489,6 @@ end subroutine hist_update_hbuf_field_1d_gpu
     integer,value, intent(in) :: hpindex
     type(bounds_type), intent(in) :: bounds
     integer, intent(in) :: num2d        ! size of second dimension
-    real(r8), intent(inout) :: field(:,:) 
     !
     ! !LOCAL VARIABLES:
     integer  :: k                       ! gridcell, landunit, column or pft index
@@ -488,17 +504,18 @@ end subroutine hist_update_hbuf_field_1d_gpu
     !-----------------------------------------------------------------------
 
     associate(&
-    avgflag             =>  tape_gpu(f)%avgflag         ,&
-    nacs                =>  tape_gpu(f)%nacs             ,&
-    hbuf                =>  tape_gpu(f)%hbuf             ,&
-    beg1d               =>  tape_gpu(f)%beg1d           ,&
-    end1d               =>  tape_gpu(f)%end1d           ,&
-    type1d              =>  tape_gpu(f)%type1d          ,&
-    type1d_out          =>  tape_gpu(f)%type1d_out      ,&
-    p2c_scale_type      =>  tape_gpu(f)%p2c_scale_type  ,&
-    c2l_scale_type      =>  tape_gpu(f)%c2l_scale_type  ,&
-    l2g_scale_type      =>  tape_gpu(f)%l2g_scale_type  ,&
-    no_snow_behavior    =>  tape_gpu(f)%no_snow_behavior &
+    avgflag             =>  tape_gpu%hlist(f)%avgflag         ,&
+    nacs                =>  tape_gpu%hlist(f)%nacs             ,&
+    hbuf                =>  tape_gpu%hlist(f)%hbuf             ,&
+    beg1d               =>  tape_gpu%hlist(f)%beg1d           ,&
+    end1d               =>  tape_gpu%hlist(f)%end1d           ,&
+    type1d              =>  tape_gpu%hlist(f)%type1d          ,&
+    type1d_out          =>  tape_gpu%hlist(f)%type1d_out      ,&
+    p2c_scale_type      =>  tape_gpu%hlist(f)%p2c_scale_type  ,&
+    c2l_scale_type      =>  tape_gpu%hlist(f)%c2l_scale_type  ,&
+    l2g_scale_type      =>  tape_gpu%hlist(f)%l2g_scale_type  ,&
+    no_snow_behavior    =>  tape_gpu%hlist(f)%no_snow_behavior,&
+    field               =>  elmptr_ra(hpindex)%ptr &
     )
 
     if (no_snow_behavior /= no_snow_unset) then
@@ -818,15 +835,14 @@ end subroutine hist_update_hbuf_field_1d_gpu
     integer :: size1,size2,t,f, field
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     print *, "updating tape_gpu on cpu:"
-    !$acc update self(tape_gpu(:))
+    !$acc update self(tape_gpu)
 
     !loop is done on cpu --- could accelerate using openACC cpu threading?
     print *, "update tape on cpu"
-    do field = 1, total_flds
+    do field = 1, tape_gpu%nflds
       t = map_tapes(field) ; f = map_fields(field);
-      if(tape(t)%hlist(f)%field%name  == "ALTMAX") print *, "ALTMAX is field # ",field 
-      tape(t)%hlist(f)%hbuf(:,:) = tape_gpu(f)%hbuf(:,:)
-      tape(t)%hlist(f)%nacs(:,:) = tape_gpu(f)%nacs(:,:)
+      tape(t)%hlist(f)%hbuf(:,:) = tape_gpu%hlist(f)%hbuf(:,:)
+      tape(t)%hlist(f)%nacs(:,:) = tape_gpu%hlist(f)%nacs(:,:)
     end do
 
 
@@ -838,12 +854,13 @@ end subroutine hist_update_hbuf_field_1d_gpu
           integer  :: t
           integer :: f
 
-          do f = 1, total_flds
+          do f = 1, tape_gpu%nflds
             t = map_tapes(f)
             if(tape(t)%is_endhist) then
-                tape_gpu(f)%hbuf(:,:) = 0d0
-                tape_gpu(f)%nacs(:,:) = 0
-                !$acc update device(tape_gpu(f))
+                print *,  "adjusting gpu tape after normalization/zeroing",t
+                tape_gpu%hlist(f)%hbuf(:,:) = 0d0
+                tape_gpu%hlist(f)%nacs(:,:) = 0
+                !$acc update device(tape_gpu%hlist(f))
             end if
           end do
 
diff --git a/components/elm/src/main/landunit_varcon.F90 b/components/elm/src/main/landunit_varcon.F90
index f58b358e33..8cb481dcc7 100644
--- a/components/elm/src/main/landunit_varcon.F90
+++ b/components/elm/src/main/landunit_varcon.F90
@@ -12,7 +12,7 @@ module landunit_varcon
   implicit none
   save
   private
-
+  
   !------------------------------------------------------------------
   ! Initialize landunit type constants
   !------------------------------------------------------------------
@@ -44,25 +44,14 @@ module landunit_varcon
   ! !PUBLIC MEMBER FUNCTIONS:
   public :: landunit_varcon_init  ! initialize constants in this module
   public :: landunit_is_special   ! returns true if this is a special landunit
-
+  
   !
   ! !PRIVATE MEMBER FUNCTIONS:
   private :: set_landunit_names   ! set the landunit_names vector
 !-----------------------------------------------------------------------
-!$acc declare copyin(istsoil    )
-!$acc declare copyin(istcrop    )
-!$acc declare copyin(istice     )
-!$acc declare copyin(istice_mec )
-!$acc declare copyin(istdlak    )
-!$acc declare copyin(istwet     )
-!$acc declare copyin(isturb_MIN )
-!$acc declare copyin(isturb_tbd )
-!$acc declare copyin(isturb_hd  )
-!$acc declare copyin(isturb_md  )
-!$acc declare copyin(isturb_MAX )
-!$acc declare copyin(max_lunit  )
-contains
 
+contains
+  
   !-----------------------------------------------------------------------
   subroutine landunit_varcon_init()
     !
@@ -74,14 +63,14 @@ contains
     ! !ARGUMENTS:
     !
     ! !LOCAL VARIABLES:
-
+    
     character(len=*), parameter :: subname = 'landunit_varcon_init'
     !-----------------------------------------------------------------------
-
+    
     call set_landunit_names()
 
   end subroutine landunit_varcon_init
-
+  
   !-----------------------------------------------------------------------
   function landunit_is_special(ltype) result(is_special)
     !
@@ -121,7 +110,7 @@ contains
     character(len=*), parameter :: not_set = 'NOT_SET'
     character(len=*), parameter :: subname = 'set_landunit_names'
     !-----------------------------------------------------------------------
-
+    
     landunit_names(:) = not_set
 
     landunit_names(istsoil) = 'vegetated_or_bare_soil'
diff --git a/components/elm/src/main/lnd2atmMod.F90 b/components/elm/src/main/lnd2atmMod.F90
index daf3069a8b..7aab58e8b8 100644
--- a/components/elm/src/main/lnd2atmMod.F90
+++ b/components/elm/src/main/lnd2atmMod.F90
@@ -11,10 +11,11 @@ module lnd2atmMod
   use shr_megan_mod        , only : shr_megan_mechcomps_n
   use elm_varpar           , only : numrad, ndst, nlevgrnd, nlevsno, nlevsoi !ndst = number of dust bins.
   use elm_varcon           , only : rair, grav, cpair, hfus, tfrz, spval
-  use elm_varctl           , only : iulog, use_c13, use_cn, use_lch4, use_voc, use_fates
-  use seq_drydep_mod_elm   , only : n_drydep, drydep_method, DD_XLND
+  use elm_varctl           , only : iulog, use_c13, use_cn, use_lch4, use_voc, use_fates, use_atm_downscaling_to_topunit
+  use tracer_varcon        , only : is_active_betr_bgc
+  use seq_drydep_mod   , only : n_drydep, drydep_method, DD_XLND
   use decompMod            , only : bounds_type
-  use subgridAveMod        , only : p2g, c2g
+  use subgridAveMod        , only : p2g, c2g, p2t  
   use lnd2atmType          , only : lnd2atm_type
   use atm2lndType          , only : atm2lnd_type
   use CH4Mod               , only : ch4_type
@@ -26,12 +27,13 @@ module lnd2atmMod
   use SolarAbsorbedType    , only : solarabs_type
   use SurfaceAlbedoType    , only : surfalb_type
   use GridcellType         , only : grc_pp
+  use TopounitDataType     , only : top_es, top_af                 ! To calculate t_rad at topounit level needed in downscaling
   use GridcellDataType     , only : grc_ef, grc_ws, grc_wf
   use ColumnDataType       , only : col_ws, col_wf, col_cf, col_es
   use VegetationDataType   , only : veg_es, veg_ef, veg_ws, veg_wf
-  use SoilHydrologyType    , only : soilhydrology_type
-  use subgridAveMod , only : unity, urbanf, urbans, natveg, veg, ice, nonurb, lake 
-  #define is_active_betr_bgc .false. 
+  use SoilHydrologyType    , only : soilhydrology_type 
+  use spmdmod          , only: masterproc
+  use elm_varctl     , only : iulog
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -41,6 +43,9 @@ module lnd2atmMod
   ! !PUBLIC MEMBER FUNCTIONS:
   public :: lnd2atm
   public :: lnd2atm_minimal
+
+  integer, parameter :: unity = 0, urbanf = 1, urbans = 2
+  integer, parameter :: natveg = 3, veg =4, ice=5, nonurb=6, lake=7
   !------------------------------------------------------------------------
 
 contains
@@ -66,8 +71,7 @@ contains
     type(lnd2atm_type)    , intent(inout) :: lnd2atm_vars
     !
     ! !LOCAL VARIABLES:
-    integer :: g                                    ! index
-
+    integer :: g, t                                    ! index
     !------------------------------------------------------------------------
     associate( &
       h2osno => col_ws%h2osno  , &
@@ -114,7 +118,21 @@ contains
     do g = bounds%begg,bounds%endg
        lnd2atm_vars%t_rad_grc(g) = sqrt(sqrt(eflx_lwrad_out_grc(g)/sb))
     end do
+    
+    ! Calculate topounit level eflx_lwrad_out_topo for downscaling purpose
+    if (use_atm_downscaling_to_topunit) then
+       call p2t(bounds, &
+            eflx_lwrad_out (bounds%begp:bounds%endp), &
+            top_es%eflx_lwrad_out_topo      (bounds%begt:bounds%endt), &
+            p2c_scale_type='unity', c2l_scale_type= 'urbanf', l2t_scale_type='unity')
+    
+       do t = bounds%begt,bounds%endt
+          top_es%t_rad(t) = sqrt(sqrt(top_es%eflx_lwrad_out_topo(t)/sb))   
+       end do
+    end if
+    
     end associate
+
   end subroutine lnd2atm_minimal
 
   !------------------------------------------------------------------------
@@ -122,14 +140,14 @@ contains
        atm2lnd_vars, surfalb_vars, frictionvel_vars, &
        energyflux_vars, &
        solarabs_vars, drydepvel_vars, &
-       dust_vars, ch4_vars, soilhydrology_vars, lnd2atm_vars)
+       vocemis_vars, dust_vars, ch4_vars, soilhydrology_vars, lnd2atm_vars)
     !
     ! !DESCRIPTION:
     ! Compute lnd2atm_vars component of gridcell derived type
     !
     ! !USES:
+      !$acc routine seq
     use CH4varcon  , only : ch4offline
-    use shr_sys_mod, only : shr_sys_flush
     !
     ! !ARGUMENTS:
     type(bounds_type)      , intent(in)     :: bounds
@@ -139,7 +157,7 @@ contains
     type(energyflux_type)  , intent(in)     :: energyflux_vars
     type(solarabs_type)    , intent(in)     :: solarabs_vars
     type(drydepvel_type)   , intent(in)     :: drydepvel_vars
-   !  type(vocemis_type)     , intent(in)     :: vocemis_vars
+    type(vocemis_type)     , intent(in)     :: vocemis_vars
     type(dust_type)        , intent(in)     :: dust_vars
     type(ch4_type)         , intent(in)     :: ch4_vars
     type(soilhydrology_type), intent(in)    :: soilhydrology_vars
@@ -312,15 +330,13 @@ contains
             p2c_scale_type=unity, c2l_scale_type= unity, l2g_scale_type=unity)
     endif
 
-! #ifndef _OPENACC
-!     ! voc emission flux
-!     if (use_voc .and. shr_megan_mechcomps_n>0) then
-!        call p2g(bounds, shr_megan_mechcomps_n, &
-!             vocemis_vars%vocflx_patch, &
-!             lnd2atm_vars%flxvoc_grc  , &
-!             p2c_scale_type=unity, c2l_scale_type= unity, l2g_scale_type=unity)
-!     end if
-! #endif 
+    ! voc emission flux
+    if (use_voc .and. shr_megan_mechcomps_n>0) then
+       call p2g(bounds, shr_megan_mechcomps_n, &
+            vocemis_vars%vocflx_patch, &
+            lnd2atm_vars%flxvoc_grc  , &
+            p2c_scale_type=unity, c2l_scale_type= unity, l2g_scale_type=unity)
+    end if
 
     ! dust emission flux
     call p2g(bounds, ndst, &
@@ -394,6 +410,11 @@ contains
        qflx_rofice_grc(g) = qflx_rofice_grc(g) - grc_wf%qflx_ice_dynbal(g)
     enddo
 
+    call c2g( bounds, &
+         col_ws%wslake_col(bounds%begc:bounds%endc), &
+         lnd2atm_vars%wslake_grc(bounds%begg:bounds%endg), &
+         c2l_scale_type= 'urbanf', l2g_scale_type='unity' )
+
     ! calculate total water storage for history files
     ! first set tws to gridcell total endwb
     ! second add river storage as gridcell average depth (1.e-3 converts [m3/km2] to [mm])
@@ -426,13 +447,11 @@ contains
          c2l_scale_type= urbans, l2g_scale_type=unity )
 
     do g = bounds%begg,bounds%endg
-#ifndef _OPENACC
        ! TODO temperary treatment in case weird values after c2g
        if(lnd2atm_vars%t_soisno_grc(g, 1) > 400._r8) then
              write(iulog,*)'lnd2atm_vars%t_soisno_grc(g, 1) is',lnd2atm_vars%t_soisno_grc(g, 1)
              call endrun( msg=' lnd2atm ERROR: lnd2atm_vars%t_soisno_grc >  400 Kelvin degree.'//errMsg(__FILE__, __LINE__))
        end if
-#endif 
        lnd2atm_vars%Tqsur_grc(g) = avg_tsoil_surf(t_soisno_grc(g,:))
        lnd2atm_vars%Tqsub_grc(g) = avg_tsoil(zwt_grc(g),t_soisno_grc(g,:))
 
@@ -444,7 +463,7 @@ contains
 
     function avg_tsoil_surf(Tsoil_) result(avgT_)
       !$acc routine seq
-       ! Function for estimating average soil temperature within the top few layers (which closely interacts with surface runoff)
+    ! Function for estimating average soil temperature within the top few layers (which closely interacts with surface runoff)
         implicit none
         real(r8), intent(in) :: Tsoil_(-nlevsno+1:nlevgrnd)       ! water table depth, soil temperature
         real(r8) :: avgT_             ! average soil temperature within the saturated layers
@@ -475,7 +494,7 @@ contains
 
     function avg_tsoil(zwt_, Tsoil_) result(avgT_)
       !$acc routine seq
-      ! Function for estimating average soil temperature within the saturated soil zone (which produces subsurface runoff)
+    ! Function for estimating average soil temperature within the saturated soil zone (which produces subsurface runoff)
         implicit none
         real(r8), intent(in) :: zwt_, Tsoil_(-nlevsno+1:nlevgrnd)       ! water table depth, soil temperature
         real(r8) :: avgT_             ! average soil temperature within the saturated layers
diff --git a/components/elm/src/main/perfMod_GPU.F90 b/components/elm/src/main/perfMod_GPU.F90
index 5cee1eee30..ad573fc9be 100644
--- a/components/elm/src/main/perfMod_GPU.F90
+++ b/components/elm/src/main/perfMod_GPU.F90
@@ -9,7 +9,6 @@ contains
 
   subroutine  t_start_lnd(event)
 
-    !$acc routine seq
     character(len=64), intent(in) :: event
 
 #ifndef _OPENACC
@@ -20,7 +19,6 @@ contains
 
   subroutine  t_stop_lnd(event)
 
-    !$acc routine seq 
     character(len=64), intent(in) :: event
 
 #ifndef _OPENACC
diff --git a/components/elm/src/main/pftvarcon.F90 b/components/elm/src/main/pftvarcon.F90
index 5f1e95e632..36514f14b3 100644
--- a/components/elm/src/main/pftvarcon.F90
+++ b/components/elm/src/main/pftvarcon.F90
@@ -21,7 +21,7 @@ module pftvarcon
   !
   ! Vegetation type constants
   !
-  integer :: noveg                  !value for not vegetated
+  integer :: noveg                  !value for not vegetated 
   integer :: ndllf_evr_tmp_tree     !value for Needleleaf evergreen temperate tree
   integer :: ndllf_evr_brl_tree     !value for Needleleaf evergreen boreal tree
   integer :: ndllf_dcd_brl_tree     !value for Needleleaf deciduous boreal tree
@@ -51,7 +51,6 @@ module pftvarcon
   integer :: nppercropmax           !value for last prognostic perennial crop in list
   integer :: nc3crop                !value for generic crop (rf)
   integer :: nc3irrig               !value for irrigated generic crop (ir)
-
   integer :: ncassava               !value for cassava, rain fed (rf)
   integer :: ncassavairrig          !value for cassava, irrigated (ir)
   integer :: ncotton                !value for cotton, rain fed (rf)
@@ -79,47 +78,11 @@ module pftvarcon
   integer :: nwillow                !value for willow, rain fed (rf)
   integer :: nwillowirrig           !value for willow, irrigated (ir)  
   
-
-  !$acc declare create(noveg               )
-  !$acc declare create(ndllf_evr_tmp_tree  )
-  !$acc declare create(ndllf_evr_brl_tree  )
-  !$acc declare create(ndllf_dcd_brl_tree  )
-  !$acc declare create(nbrdlf_evr_trp_tree )
-  !$acc declare create(nbrdlf_evr_tmp_tree )
-  !$acc declare create(nbrdlf_dcd_trp_tree )
-  !$acc declare create(nbrdlf_dcd_tmp_tree )
-  !$acc declare create(nbrdlf_dcd_brl_tree )
-  !$acc declare create(ntree               )
-  !$acc declare create(nbrdlf_evr_shrub    )
-  !$acc declare create(nbrdlf_dcd_tmp_shrub)
-  !$acc declare create(nbrdlf_dcd_brl_shrub)
-  !$acc declare create(nc3_arctic_grass    )
-  !$acc declare create(nc3_nonarctic_grass )
-  !$acc declare create(nc4_grass           )
-  !$acc declare create(npcropmin           )
-  !$acc declare create(nppercropmin        )
-  !$acc declare create(ncorn               )
-  !$acc declare create(ncornirrig          )
-  !$acc declare create(nscereal            )
-  !$acc declare create(nscerealirrig       )
-  !$acc declare create(nwcereal            )
-  !$acc declare create(nwcerealirrig       )
-  !$acc declare create(nsoybean            )
-  !$acc declare create(nsoybeanirrig       )
-  !$acc declare create(npcropmax           )
-  !$acc declare create(nc3crop             )
-  !$acc declare create(nc3irrig            )
-  !$acc declare create(nmiscanthus      )
-  !$acc declare create(nmiscanthusirrig )
-  !$acc declare create(nswitchgrass     )
-  !$acc declare create(nswitchgrassirrig)
-
   ! Number of crop functional types actually used in the model. This includes each CFT for
   ! which is_pft_known_to_model is true. Note that this includes irrigated crops even if
   ! irrigation is turned off in this run: it just excludes crop types that aren't handled
   ! at all, as given by the mergetoelmpft list.
   integer :: num_cfts_known_to_model
-  !$acc declare create(num_cfts_known_to_model)
 
   real(r8), allocatable :: dleaf(:)       !characteristic leaf dimension (m)
   real(r8), allocatable :: c3psn(:)       !photosynthetic pathway: 0. = c4, 1. = c3
@@ -160,40 +123,6 @@ module pftvarcon
   real(r8), allocatable :: livewdcp(:)    !live wood (phloem and ray parenchyma) C:P (gC/gP)
   real(r8), allocatable :: deadwdcp(:)    !dead wood (xylem and heartwood) C:P (gC/gP)
 
-  !$acc declare create(dleaf(:)    )
-  !$acc declare create(c3psn(:)    )
-  !$acc declare create(xl(:)       )
-  !$acc declare create(rhol(:,:)   )
-  !$acc declare create(rhos(:,:)   )
-  !$acc declare create(taul(:,:)   )
-  !$acc declare create(taus(:,:)   )
-  !$acc declare create(z0mr(:)     )
-  !$acc declare create(displar(:)  )
-  !$acc declare create(roota_par(:))
-  !$acc declare create(rootb_par(:))
-  !$acc declare create(crop(:)     )
-  !$acc declare create(irrigated(:))
-  !$acc declare create(smpso(:)    )
-  !$acc declare create(smpsc(:)    )
-  !$acc declare create(fnitr(:)    )
-  !$acc declare create(slatop(:)      )
-  !$acc declare create(dsladlai(:)    )
-  !$acc declare create(leafcn(:)      )
-  !$acc declare create(flnr(:)        )
-  !$acc declare create(woody(:)       )
-  !$acc declare create(lflitcn(:)     )
-  !$acc declare create(frootcn(:)     )
-  !$acc declare create(livewdcn(:)    )
-  !$acc declare create(deadwdcn(:)    )
-  !$acc declare create(grperc(:)      )
-  !$acc declare create(grpnow(:)      )
-  !$acc declare create(rootprof_beta(:))
-  !$acc declare create(leafcp(:)  )
-  !$acc declare create(lflitcp(:) )
-  !$acc declare create(frootcp(:) )
-  !$acc declare create(livewdcp(:))
-  !$acc declare create(deadwdcp(:))
-  !$acc declare create(percrop(:) )
   ! for crop
 
   ! These arrays give information about the merge of unused crop types to the types CLM
@@ -338,7 +267,7 @@ module pftvarcon
   real(r8), allocatable :: deadwdcp_obs_flex(:,:)     !upper and lower range of dead wood (xylem and heartwood) C:P (gC/gP)
   ! Photosynthesis parameters
   real(r8), allocatable :: fnr(:)              !fraction of nitrogen in RuBisCO
-  real(r8), allocatable :: act25(:)
+  real(r8), allocatable :: act25(:)           
   real(r8), allocatable :: kcha(:)             !Activation energy for kc
   real(r8), allocatable :: koha(:)             !Activation energy for ko
   real(r8), allocatable :: cpha(:)             !Activation energy for cp
@@ -355,7 +284,7 @@ module pftvarcon
   real(r8), allocatable :: theta_cj(:)         !
   real(r8), allocatable :: bbbopt(:)           !Ball-Berry stomatal conductance intercept
   real(r8), allocatable :: mbbopt(:)           !Ball-Berry stomatal conductance slope
-  real(r8), allocatable :: nstor(:)            !Nitrogen storage pool timescale
+  real(r8), allocatable :: nstor(:)            !Nitrogen storage pool timescale 
   real(r8), allocatable :: br_xr(:)            !Base rate for excess respiration
   real(r8)              :: tc_stress           !Critial temperature for moisture stress
   real(r8), allocatable :: vcmax_np1(:)        !vcmax~np relationship coefficient
@@ -372,157 +301,6 @@ module pftvarcon
   real(r8), allocatable :: gcpsi(:)            !bare ground LAI-decay parameter
   real(r8), allocatable :: pftcc(:)            !plant cover reduction factor for transport capacity
 
-  !$acc declare create(rsub_top_globalmax, gcpsi, pftcc)
-
-  !$acc declare create(mergetoelmpft         (:))
-  !$acc declare create(is_pft_known_to_model (:))
-  !$acc declare create(graincn(:)      )
-  !$acc declare create(graincp(:)      )
-  !$acc declare create(mxtmp(:)        )
-  !$acc declare create(baset(:)        )
-  !$acc declare create(declfact(:)     )
-  !$acc declare create(bfact(:)        )
-  !$acc declare create(aleaff(:)       )
-  !$acc declare create(arootf(:)       )
-  !$acc declare create(astemf(:)       )
-  !$acc declare create(arooti(:)       )
-  !$acc declare create(fleafi(:)       )
-  !$acc declare create(allconsl(:)     )
-  !$acc declare create(allconss(:)     )
-  !$acc declare create(ztopmx(:)       )
-  !$acc declare create(laimx(:)        )
-  !$acc declare create(gddmin(:)       )
-  !$acc declare create(hybgdd(:)       )
-  !$acc declare create(lfemerg(:)      )
-  !$acc declare create(grnfill(:)      )
-  !$acc declare create(mxmat(:)        )
-  !$acc declare create(mnNHplantdate(:))
-  !$acc declare create(mxNHplantdate(:))
-  !$acc declare create(mnSHplantdate(:))
-  !$acc declare create(mxSHplantdate(:))
-  !$acc declare create(planttemp(:)    )
-  !$acc declare create(minplanttemp(:) )
-  !$acc declare create(froot_leaf(:)   )
-  !$acc declare create(stem_leaf(:)    )
-  !$acc declare create(croot_stem(:)   )
-  !$acc declare create(flivewd(:)      )
-  !$acc declare create(fcur(:)         )
-  !$acc declare create(lf_flab(:)      )
-  !$acc declare create(lf_fcel(:)      )
-  !$acc declare create(lf_flig(:)      )
-  !$acc declare create(fr_flab(:)      )
-  !$acc declare create(fr_fcel(:)      )
-  !$acc declare create(fr_flig(:)      )
-  !$acc declare create(leaf_long(:)    )
-  !$acc declare create(froot_long(:)   )
-  !$acc declare create(evergreen(:)    )
-  !$acc declare create(stress_decid(:) )
-  !$acc declare create(season_decid(:) )
-  !$acc declare create(pconv(:)        )
-  !$acc declare create(pprod10(:)      )
-  !$acc declare create(pprod100(:)     )
-  !$acc declare create(pprodharv10(:)  )
-  !$acc declare create(cc_leaf(:) )
-  !$acc declare create(cc_lstem(:))
-  !$acc declare create(cc_dstem(:))
-  !$acc declare create(cc_other(:))
-  !$acc declare create(fm_leaf(:) )
-  !$acc declare create(fm_lstem(:))
-  !$acc declare create(fm_dstem(:))
-  !$acc declare create(fm_other(:))
-  !$acc declare create(fm_root(:) )
-  !$acc declare create(fm_lroot(:))
-  !$acc declare create(fm_droot(:))
-  !$acc declare create(fsr_pft(:) )
-  !$acc declare create(fd_pft(:)  )
-  !$acc declare create(fertnitro(:))
-  !$acc declare create(fleafcn(:)  )
-  !$acc declare create(ffrootcn(:) )
-  !$acc declare create(fstemcn(:)  )
-  !$acc declare create(presharv(:) )
-  !$acc declare create(convfact(:) )
-  !$acc declare create(fyield(:)   )
-  !$acc declare create(root_dmx(:) )
-  !$acc declare copyin(reinickerp)
-  !$acc declare copyin(dwood     )
-  !$acc declare copyin(allom1    )
-  !$acc declare copyin(allom2    )
-  !$acc declare copyin(allom3    )
-  !$acc declare copyin(allom1s   )
-  !$acc declare copyin(allom2s   )
-  !$acc declare create(VMAX_PLANT_NH4(:)   )
-  !$acc declare create(VMAX_PLANT_NO3(:)   )
-  !$acc declare create(VMAX_PLANT_P(:)     )
-  !$acc declare create(VMAX_MINSURF_P_vr(:,:) )
-  !$acc declare create(KM_PLANT_NH4(:)     )
-  !$acc declare create(KM_PLANT_NO3(:)     )
-  !$acc declare create(KM_PLANT_P(:)       )
-  !$acc declare create(KM_MINSURF_P_vr(:,:))
-  !$acc declare create(KM_DECOMP_NH4       )
-  !$acc declare create(KM_DECOMP_NO3       )
-  !$acc declare create(KM_DECOMP_P         )
-  !$acc declare create(KM_NIT              )
-  !$acc declare create(KM_DEN              )
-  !$acc declare create(decompmicc_patch_vr(:,:))
-  !$acc declare create(alpha_nfix(:)           )
-  !$acc declare create(alpha_ptase(:)          )
-  !$acc declare create(ccost_nfix(:)           )
-  !$acc declare create(pcost_nfix(:)           )
-  !$acc declare create(ccost_ptase(:)          )
-  !$acc declare create(ncost_ptase(:)          )
-  !$acc declare create(VMAX_NFIX(:)        )
-  !$acc declare create(KM_NFIX(:)          )
-  !$acc declare create(VMAX_PTASE(:)       )
-  !$acc declare create(KM_PTASE            )
-  !$acc declare create(lamda_ptase         )
-  !$acc declare create(i_vc(:)             )
-  !$acc declare create(s_vc(:)             )
-  !$acc declare create(leafcn_obs(:)         )
-  !$acc declare create(frootcn_obs(:)        )
-  !$acc declare create(livewdcn_obs(:)       )
-  !$acc declare create(deadwdcn_obs(:)       )
-  !$acc declare create(leafcp_obs(:)         )
-  !$acc declare create(frootcp_obs(:)        )
-  !$acc declare create(livewdcp_obs(:)       )
-  !$acc declare create(deadwdcp_obs(:)       )
-  !$acc declare create(leafcn_obs_flex(:,:)  )
-  !$acc declare create(frootcn_obs_flex(:,:) )
-  !$acc declare create(livewdcn_obs_flex(:,:))
-  !$acc declare create(deadwdcn_obs_flex(:,:))
-  !$acc declare create(leafcp_obs_flex(:,:)  )
-  !$acc declare create(frootcp_obs_flex(:,:) )
-  !$acc declare create(livewdcp_obs_flex(:,:))
-  !$acc declare create(deadwdcp_obs_flex(:,:))
-  !$acc declare create(fnr(:)      )
-  !$acc declare create(act25(:)    )
-  !$acc declare create(kcha(:)     )
-  !$acc declare create(koha(:)     )
-  !$acc declare create(cpha(:)     )
-  !$acc declare create(vcmaxha(:)  )
-  !$acc declare create(jmaxha(:)   )
-  !$acc declare create(tpuha(:)    )
-  !$acc declare create(lmrha(:)    )
-  !$acc declare create(vcmaxhd(:)  )
-  !$acc declare create(jmaxhd(:)   )
-  !$acc declare create(tpuhd(:)    )
-  !$acc declare create(lmrhd(:)    )
-  !$acc declare create(lmrse(:)    )
-  !$acc declare create(qe(:)       )
-  !$acc declare create(theta_cj(:) )
-  !$acc declare create(bbbopt(:)   )
-  !$acc declare create(mbbopt(:)   )
-  !$acc declare create(nstor(:)    )
-  !$acc declare create(br_xr(:)    )
-  !$acc declare create(tc_stress   )
-  !$acc declare create(vcmax_np1(:))
-  !$acc declare create(vcmax_np2(:))
-  !$acc declare create(vcmax_np3(:))
-  !$acc declare create(vcmax_np4(:))
-  !$acc declare create(jmax_np1    )
-  !$acc declare create(jmax_np2    )
-  !$acc declare create(jmax_np3    )
-  !$acc declare create(laimax      )
-
   !
   ! !PUBLIC MEMBER FUNCTIONS:
   public :: pftconrd ! Read and initialize vegetation (PFT) constants
@@ -575,7 +353,7 @@ contains
     !       and finally crops, ending with soybean
     ! DO NOT CHANGE THE ORDER -- WITHOUT MODIFYING OTHER PARTS OF THE CODE WHERE THE ORDER MATTERS!
     !
-    character(len=pftname_len) :: expected_pftnames(0:mxpft)
+    character(len=pftname_len) :: expected_pftnames(0:mxpft) 
 !-----------------------------------------------------------------------
 
     expected_pftnames( 0) = 'not_vegetated                      '
@@ -671,26 +449,26 @@ contains
     allocate( mergetoelmpft (0:mxpft) )
     allocate( is_pft_known_to_model  (0:mxpft) )
 
-    allocate( graincn       (0:mxpft) )
-    allocate( graincp       (0:mxpft) )
-    allocate( mxtmp         (0:mxpft) )
-    allocate( baset         (0:mxpft) )
-    allocate( declfact      (0:mxpft) )
-    allocate( bfact         (0:mxpft) )
-    allocate( aleaff        (0:mxpft) )
-    allocate( arootf        (0:mxpft) )
-    allocate( astemf        (0:mxpft) )
-    allocate( arooti        (0:mxpft) )
-    allocate( fleafi        (0:mxpft) )
-    allocate( allconsl      (0:mxpft) )
-    allocate( allconss      (0:mxpft) )
-    allocate( ztopmx        (0:mxpft) )
-    allocate( laimx         (0:mxpft) )
-    allocate( gddmin        (0:mxpft) )
-    allocate( hybgdd        (0:mxpft) )
-    allocate( lfemerg       (0:mxpft) )
-    allocate( grnfill       (0:mxpft) )
-    allocate( mxmat         (0:mxpft) )
+    allocate( graincn       (0:mxpft) )      
+    allocate( graincp       (0:mxpft) )      
+    allocate( mxtmp         (0:mxpft) )        
+    allocate( baset         (0:mxpft) )        
+    allocate( declfact      (0:mxpft) )     
+    allocate( bfact         (0:mxpft) )        
+    allocate( aleaff        (0:mxpft) )       
+    allocate( arootf        (0:mxpft) )       
+    allocate( astemf        (0:mxpft) )       
+    allocate( arooti        (0:mxpft) )       
+    allocate( fleafi        (0:mxpft) )       
+    allocate( allconsl      (0:mxpft) )     
+    allocate( allconss      (0:mxpft) )     
+    allocate( ztopmx        (0:mxpft) )       
+    allocate( laimx         (0:mxpft) )        
+    allocate( gddmin        (0:mxpft) )       
+    allocate( hybgdd        (0:mxpft) )       
+    allocate( lfemerg       (0:mxpft) )      
+    allocate( grnfill       (0:mxpft) )      
+    allocate( mxmat         (0:mxpft) )        
     allocate( mnNHplantdate (0:mxpft) )
     allocate( mxNHplantdate (0:mxpft) )
     allocate( mnSHplantdate (0:mxpft) )
@@ -712,13 +490,13 @@ contains
     allocate( fr_flig       (0:mxpft) )      
     allocate( leaf_long     (0:mxpft) )   
     allocate( froot_long    (0:mxpft) )
-    allocate( evergreen     (0:mxpft) )
-    allocate( stress_decid  (0:mxpft) )
-    allocate( season_decid  (0:mxpft) )
-    allocate( pconv         (0:mxpft) )
-    allocate( pprod10       (0:mxpft) )
-    allocate( pprod100      (0:mxpft) )
-    allocate( pprodharv10   (0:mxpft) )
+    allocate( evergreen     (0:mxpft) )    
+    allocate( stress_decid  (0:mxpft) ) 
+    allocate( season_decid  (0:mxpft) ) 
+    allocate( pconv         (0:mxpft) )        
+    allocate( pprod10       (0:mxpft) )      
+    allocate( pprod100      (0:mxpft) )     
+    allocate( pprodharv10   (0:mxpft) )  
     allocate( cc_leaf       (0:mxpft) )
     allocate( cc_lstem      (0:mxpft) )
     allocate( cc_dstem      (0:mxpft) )
@@ -733,12 +511,12 @@ contains
     allocate( fsr_pft       (0:mxpft) )
     allocate( fd_pft        (0:mxpft) )
     allocate( fertnitro     (0:mxpft) )
-    allocate( fleafcn       (0:mxpft) )
-    allocate( ffrootcn      (0:mxpft) )
+    allocate( fleafcn       (0:mxpft) )  
+    allocate( ffrootcn      (0:mxpft) ) 
     allocate( fstemcn       (0:mxpft) )
     allocate( presharv      (0:mxpft) )
     allocate( convfact      (0:mxpft) )
-    allocate( fyield        (0:mxpft) )
+    allocate( fyield        (0:mxpft) )  
     allocate( root_dmx      (0:mxpft) )
 
     if (use_crop) then
@@ -751,7 +529,7 @@ contains
     allocate( VMAX_PLANT_NO3(0:mxpft) )
     allocate( VMAX_PLANT_P(0:mxpft) )
     allocate( VMAX_MINSURF_P_vr(1:nlevdecomp_full,0:nsoilorder))
-    allocate( KM_PLANT_NH4(0:mxpft) )
+    allocate( KM_PLANT_NH4(0:mxpft) ) 
     allocate( KM_PLANT_NO3(0:mxpft) )
     allocate( KM_PLANT_P(0:mxpft) )
     allocate( KM_MINSURF_P_vr(1:nlevdecomp_full,0:nsoilorder))
@@ -771,22 +549,22 @@ contains
     allocate( VMAX_NFIX          (0:mxpft) )
     allocate( KM_NFIX            (0:mxpft) )
     ! new stoichiometry
-    allocate( leafcn_obs         (0:mxpft) )
-    allocate( frootcn_obs        (0:mxpft) )
+    allocate( leafcn_obs         (0:mxpft) )   
+    allocate( frootcn_obs        (0:mxpft) )   
     allocate( livewdcn_obs       (0:mxpft) )
-    allocate( deadwdcn_obs       (0:mxpft) )
-    allocate( leafcp_obs         (0:mxpft) )
-    allocate( frootcp_obs        (0:mxpft) )
+    allocate( deadwdcn_obs       (0:mxpft) )      
+    allocate( leafcp_obs         (0:mxpft) )   
+    allocate( frootcp_obs        (0:mxpft) )   
     allocate( livewdcp_obs       (0:mxpft) )
-    allocate( deadwdcp_obs       (0:mxpft) )
-    allocate( leafcn_obs_flex         (0:mxpft,1:2) )
-    allocate( frootcn_obs_flex        (0:mxpft,1:2) )
+    allocate( deadwdcp_obs       (0:mxpft) ) 
+    allocate( leafcn_obs_flex         (0:mxpft,1:2) )   
+    allocate( frootcn_obs_flex        (0:mxpft,1:2) )   
     allocate( livewdcn_obs_flex       (0:mxpft,1:2) )
-    allocate( deadwdcn_obs_flex       (0:mxpft,1:2) )
-    allocate( leafcp_obs_flex         (0:mxpft,1:2) )
-    allocate( frootcp_obs_flex        (0:mxpft,1:2) )
+    allocate( deadwdcn_obs_flex       (0:mxpft,1:2) )      
+    allocate( leafcp_obs_flex         (0:mxpft,1:2) )   
+    allocate( frootcp_obs_flex        (0:mxpft,1:2) )   
     allocate( livewdcp_obs_flex       (0:mxpft,1:2) )
-    allocate( deadwdcp_obs_flex       (0:mxpft,1:2) )
+    allocate( deadwdcp_obs_flex       (0:mxpft,1:2) ) 
     allocate( vcmax_np1          (0:mxpft) )
     allocate( vcmax_np2          (0:mxpft) )
     allocate( vcmax_np3          (0:mxpft) )
@@ -826,7 +604,7 @@ contains
     call ncd_inqdid(ncid,'pft',dimid)
     call ncd_inqdlen(ncid,dimid,npft)
 
-    call ncd_io('pftname',pftname, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    call ncd_io('pftname',pftname, 'read', ncid, readvar=readv, posNOTonfile=.true.) 
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
     call ncd_io('z0mr',z0mr, 'read', ncid, readvar=readv, posNOTonfile=.true.)
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
@@ -918,16 +696,16 @@ contains
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
     call ncd_io('fr_flab',fr_flab, 'read', ncid, readvar=readv, posNOTonfile=.true.)
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fr_fcel',fr_fcel, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    call ncd_io('fr_fcel',fr_fcel, 'read', ncid, readvar=readv, posNOTonfile=.true.)    
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fr_flig',fr_flig, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    call ncd_io('fr_flig',fr_flig, 'read', ncid, readvar=readv, posNOTonfile=.true.)    
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('leaf_long',leaf_long, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    call ncd_io('leaf_long',leaf_long, 'read', ncid, readvar=readv, posNOTonfile=.true.)    
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
     call ncd_io('froot_long',froot_long, 'read', ncid, readvar=readv, posNOTonfile=.true.)
     if (.not. readv) froot_long = leaf_long
     !if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('evergreen',evergreen, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    call ncd_io('evergreen',evergreen, 'read', ncid, readvar=readv, posNOTonfile=.true.)    
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
     call ncd_io('stress_decid',stress_decid, 'read', ncid, readvar=readv, posNOTonfile=.true.)
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
@@ -964,95 +742,95 @@ contains
        call ncd_io('rootprof_beta',rootprof_beta, 'read', ncid, readvar=readv, posNOTonfile=.true.)
        if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
     end if
-    call ncd_io('pconv',pconv, 'read', ncid, readvar=readv)
+    call ncd_io('pconv',pconv, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('pprod10',pprod10, 'read', ncid, readvar=readv)
+    call ncd_io('pprod10',pprod10, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('pprodharv10',pprodharv10, 'read', ncid, readvar=readv)
+    call ncd_io('pprodharv10',pprodharv10, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('pprod100',pprod100, 'read', ncid, readvar=readv)
+    call ncd_io('pprod100',pprod100, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('graincn',graincn, 'read', ncid, readvar=readv)
+    call ncd_io('graincn',graincn, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('graincp',graincp, 'read', ncid, readvar=readv)
+    call ncd_io('graincp',graincp, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('mxtmp',mxtmp, 'read', ncid, readvar=readv)
+    call ncd_io('mxtmp',mxtmp, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('baset',baset, 'read', ncid, readvar=readv)
+    call ncd_io('baset',baset, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('declfact',declfact, 'read', ncid, readvar=readv)
+    call ncd_io('declfact',declfact, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('bfact',bfact, 'read', ncid, readvar=readv)
+    call ncd_io('bfact',bfact, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('aleaff',aleaff, 'read', ncid, readvar=readv)
+    call ncd_io('aleaff',aleaff, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('arootf',arootf, 'read', ncid, readvar=readv)
+    call ncd_io('arootf',arootf, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('astemf',astemf, 'read', ncid, readvar=readv)
+    call ncd_io('astemf',astemf, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('arooti',arooti, 'read', ncid, readvar=readv)
+    call ncd_io('arooti',arooti, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fleafi',fleafi, 'read', ncid, readvar=readv)
+    call ncd_io('fleafi',fleafi, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('allconsl',allconsl, 'read', ncid, readvar=readv)
+    call ncd_io('allconsl',allconsl, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('allconss',allconss, 'read', ncid, readvar=readv)
+    call ncd_io('allconss',allconss, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('crop',crop, 'read', ncid, readvar=readv)
+    call ncd_io('crop',crop, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('irrigated',irrigated, 'read', ncid, readvar=readv)
+    call ncd_io('irrigated',irrigated, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('ztopmx',ztopmx, 'read', ncid, readvar=readv)
+    call ncd_io('ztopmx',ztopmx, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('laimx',laimx, 'read', ncid, readvar=readv)
+    call ncd_io('laimx',laimx, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('gddmin',gddmin, 'read', ncid, readvar=readv)
+    call ncd_io('gddmin',gddmin, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('hybgdd',hybgdd, 'read', ncid, readvar=readv)
+    call ncd_io('hybgdd',hybgdd, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('lfemerg',lfemerg, 'read', ncid, readvar=readv)
+    call ncd_io('lfemerg',lfemerg, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('grnfill',grnfill, 'read', ncid, readvar=readv)
+    call ncd_io('grnfill',grnfill, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('mxmat',mxmat, 'read', ncid, readvar=readv)
+    call ncd_io('mxmat',mxmat, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('cc_leaf', cc_leaf, 'read', ncid, readvar=readv)
+    call ncd_io('cc_leaf', cc_leaf, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('cc_lstem',cc_lstem, 'read', ncid, readvar=readv)
+    call ncd_io('cc_lstem',cc_lstem, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('cc_dstem',cc_dstem, 'read', ncid, readvar=readv)
+    call ncd_io('cc_dstem',cc_dstem, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('cc_other',cc_other, 'read', ncid, readvar=readv)
+    call ncd_io('cc_other',cc_other, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fm_leaf', fm_leaf, 'read', ncid, readvar=readv)
+    call ncd_io('fm_leaf', fm_leaf, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fm_lstem',fm_lstem, 'read', ncid, readvar=readv)
+    call ncd_io('fm_lstem',fm_lstem, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fm_dstem',fm_dstem, 'read', ncid, readvar=readv)
+    call ncd_io('fm_dstem',fm_dstem, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fm_other',fm_other, 'read', ncid, readvar=readv)
+    call ncd_io('fm_other',fm_other, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fm_root', fm_root, 'read', ncid, readvar=readv)
+    call ncd_io('fm_root', fm_root, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fm_lroot',fm_lroot, 'read', ncid, readvar=readv)
+    call ncd_io('fm_lroot',fm_lroot, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fm_droot',fm_droot, 'read', ncid, readvar=readv)
+    call ncd_io('fm_droot',fm_droot, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fsr_pft', fsr_pft, 'read', ncid, readvar=readv)
+    call ncd_io('fsr_pft', fsr_pft, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('fd_pft',  fd_pft, 'read', ncid, readvar=readv)
+    call ncd_io('fd_pft',  fd_pft, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('planting_temp',planttemp, 'read', ncid, readvar=readv)
+    call ncd_io('planting_temp',planttemp, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('min_planting_temp',minplanttemp, 'read', ncid, readvar=readv)
+    call ncd_io('min_planting_temp',minplanttemp, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('min_NH_planting_date',mnNHplantdate, 'read', ncid, readvar=readv)
+    call ncd_io('min_NH_planting_date',mnNHplantdate, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('min_SH_planting_date',mnSHplantdate, 'read', ncid, readvar=readv)
+    call ncd_io('min_SH_planting_date',mnSHplantdate, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('max_NH_planting_date',mxNHplantdate, 'read', ncid, readvar=readv)
+    call ncd_io('max_NH_planting_date',mxNHplantdate, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
-    call ncd_io('max_SH_planting_date',mxSHplantdate, 'read', ncid, readvar=readv)
+    call ncd_io('max_SH_planting_date',mxSHplantdate, 'read', ncid, readvar=readv)  
     if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
 
     if (nu_com .ne. 'RD' ) then
@@ -1060,36 +838,36 @@ contains
         ! These are soil parameters and used for both FATES and big leaf ELM
         call ncd_io('VMAX_MINSURF_P_vr',VMAX_MINSURF_P_vr, 'read', ncid, readvar=readv)
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in soil order VMAX_MINSURF_P_vr'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_MINSURF_P_vr',KM_MINSURF_P_vr, 'read', ncid, readvar=readv)
+        call ncd_io('KM_MINSURF_P_vr',KM_MINSURF_P_vr, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in soil order KM_MINSURF_P_vr'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_DECOMP_NH4',KM_DECOMP_NH4, 'read', ncid, readvar=readv)
+        call ncd_io('KM_DECOMP_NH4',KM_DECOMP_NH4, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in KM_DECOMP_NH4'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_DECOMP_NO3',KM_DECOMP_NO3, 'read', ncid, readvar=readv)
+        call ncd_io('KM_DECOMP_NO3',KM_DECOMP_NO3, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in KM_DECOMP_NO3'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_DECOMP_P',KM_DECOMP_P, 'read', ncid, readvar=readv)
+        call ncd_io('KM_DECOMP_P',KM_DECOMP_P, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in KM_DECOMP_P'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_NIT',KM_NIT, 'read', ncid, readvar=readv)
+        call ncd_io('KM_NIT',KM_NIT, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in KM_NIT'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_DEN',KM_DEN, 'read', ncid, readvar=readv)
+        call ncd_io('KM_DEN',KM_DEN, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in KM_DEN'//errMsg(__FILE__, __LINE__))
 
         if(.not.use_fates) then
-
-        call ncd_io('VMAX_PLANT_NH4',VMAX_PLANT_NH4, 'read', ncid, readvar=readv)
+        
+        call ncd_io('VMAX_PLANT_NH4',VMAX_PLANT_NH4, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft VMAX_PLANT_NH4'//errMsg(__FILE__, __LINE__))
-        call ncd_io('VMAX_PLANT_NO3',VMAX_PLANT_NO3, 'read', ncid, readvar=readv)
+        call ncd_io('VMAX_PLANT_NO3',VMAX_PLANT_NO3, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft VMAX_PLANT_NO3'//errMsg(__FILE__, __LINE__))
-        call ncd_io('VMAX_PLANT_P',VMAX_PLANT_P, 'read', ncid, readvar=readv)
+        call ncd_io('VMAX_PLANT_P',VMAX_PLANT_P, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft VMAX_PLANT_P'//errMsg(__FILE__, __LINE__))
-
-        call ncd_io('KM_PLANT_NH4',KM_PLANT_NH4, 'read', ncid, readvar=readv)
+        
+        call ncd_io('KM_PLANT_NH4',KM_PLANT_NH4, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft KM_PLANT_NH4'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_PLANT_NO3',KM_PLANT_NO3, 'read', ncid, readvar=readv)
+        call ncd_io('KM_PLANT_NO3',KM_PLANT_NO3, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft KM_PLANT_NO3'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_PLANT_P',KM_PLANT_P, 'read', ncid, readvar=readv)
+        call ncd_io('KM_PLANT_P',KM_PLANT_P, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft KM_PLANT_P'//errMsg(__FILE__, __LINE__))
-
-        call ncd_io('decompmicc_patch_vr',decompmicc_patch_vr, 'read', ncid, readvar=readv)
+        
+        call ncd_io('decompmicc_patch_vr',decompmicc_patch_vr, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft decompmicc_patch_vr'//errMsg(__FILE__, __LINE__))
         call ncd_io('alpha_nfix',alpha_nfix, 'read', ncid, readvar=readv)
         if ( .not. readv ) alpha_nfix(:)=0._r8
@@ -1103,19 +881,19 @@ contains
         if ( .not. readv ) ccost_ptase(:)=0._r8
         call ncd_io('ncost_ptase',ncost_ptase, 'read', ncid, readvar=readv)
         if ( .not. readv ) ncost_ptase(:)=0._r8
-        call ncd_io('VMAX_NFIX',VMAX_NFIX, 'read', ncid, readvar=readv)
+        call ncd_io('VMAX_NFIX',VMAX_NFIX, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in VMAX_NFIX'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_NFIX',KM_NFIX, 'read', ncid, readvar=readv)
+        call ncd_io('KM_NFIX',KM_NFIX, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in KM_NFIX'//errMsg(__FILE__, __LINE__))
-        call ncd_io('VMAX_PTASE',VMAX_PTASE, 'read', ncid, readvar=readv)
+        call ncd_io('VMAX_PTASE',VMAX_PTASE, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in VMAX_PTASE'//errMsg(__FILE__, __LINE__))
-        call ncd_io('KM_PTASE',KM_PTASE, 'read', ncid, readvar=readv)
+        call ncd_io('KM_PTASE',KM_PTASE, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in KM_PTASE'//errMsg(__FILE__, __LINE__))
-        call ncd_io('lamda_ptase',lamda_ptase, 'read', ncid, readvar=readv)
+        call ncd_io('lamda_ptase',lamda_ptase, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in lamda_ptase'//errMsg(__FILE__, __LINE__))
-        call ncd_io('i_vc',i_vc, 'read', ncid, readvar=readv)
+        call ncd_io('i_vc',i_vc, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in i_vc'//errMsg(__FILE__, __LINE__))
-        call ncd_io('s_vc',s_vc, 'read', ncid, readvar=readv)
+        call ncd_io('s_vc',s_vc, 'read', ncid, readvar=readv)  
         if ( .not. readv ) call endrun(msg=' ERROR: error in reading in s_vc'//errMsg(__FILE__, __LINE__))
         call ncd_io('nsc_rtime',nsc_rtime, 'read', ncid, readvar=readv)
         if ( .not. readv ) nsc_rtime(:) = 1.0_r8
@@ -1181,13 +959,13 @@ contains
     call ncd_io('fnr', fnr, 'read', ncid, readvar=readv, posNOTonfile=.true.)
     if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__))
     call ncd_io('act25', act25, 'read', ncid, readvar=readv, posNOTonfile=.true.)
-    if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__))
+    if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__)) 
     call ncd_io('kcha', kcha, 'read', ncid, readvar=readv, posNOTonfile=.true.)
-    if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__))
+    if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__)) 
     call ncd_io('koha', koha, 'read', ncid, readvar=readv, posNOTonfile=.true.)
-    if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__))
+    if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__)) 
     call ncd_io('cpha', cpha, 'read', ncid, readvar=readv, posNOTonfile=.true.)
-    if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__))
+    if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__))  
     call ncd_io('vcmaxha', vcmaxha, 'read', ncid, readvar=readv, posNOTonfile=.true.)
     if ( .not. readv) call endrun(msg='ERROR:  error in reading in pft data'//errMsg(__FILE__,__LINE__))
     call ncd_io('jmaxha', jmaxha, 'read', ncid, readvar=readv, posNOTonfile=.true.)
@@ -1225,8 +1003,8 @@ contains
     if ( .not. readv ) gcpsi(:) = 0._r8
     call ncd_io('pftcc',pftcc, 'read', ncid, readvar=readv, posNOTonfile=.true.)
     if ( .not. readv ) pftcc(:) = 1._r8
-
-    call ncd_io('mergetoelmpft', mergetoelmpft, 'read', ncid, readvar=readv)
+       
+    call ncd_io('mergetoelmpft', mergetoelmpft, 'read', ncid, readvar=readv)  
     if ( .not. readv ) then
        do i = 0, mxpft
           mergetoelmpft(i) = i
@@ -1454,3 +1232,4 @@ contains
   end subroutine set_num_cfts_known_to_model
 
 end module pftvarcon
+
diff --git a/components/elm/src/main/reweightMod.F90 b/components/elm/src/main/reweightMod.F90
index c85678873f..c59fb54a7f 100644
--- a/components/elm/src/main/reweightMod.F90
+++ b/components/elm/src/main/reweightMod.F90
@@ -11,8 +11,6 @@ module reweightMod
 #include "shr_assert.h"
   use shr_log_mod    , only : errMsg => shr_log_errMsg
   use shr_kind_mod   , only : r8 => shr_kind_r8
-  use shr_sys_mod    , only : shr_sys_flush
-  use elm_varctl     , only : iulog
   !
   ! PUBLIC TYPES:
   implicit none
@@ -36,7 +34,7 @@ contains
     !
     ! This should be called whenever any weights change (e.g., pft weights on the column,
     ! landunit weights on the grid cell, etc.).
-    !$acc routine seq 
+    !
     ! !USES:
     use filterMod         , only : setFilters
     use subgridWeightsMod , only : set_active, check_weights
@@ -47,7 +45,8 @@ contains
     real(r8)          , intent(in) :: icemask_grc( bounds%begg: ) ! ice sheet grid coverage mask [gridcell]
     !------------------------------------------------------------------------
 
-    ! SHR_ASSERT(bounds%level == BOUNDS_LEVEL_CLUMP, errMsg(__FILE__, __LINE__))
+    SHR_ASSERT(bounds%level == BOUNDS_LEVEL_CLUMP, errMsg(__FILE__, __LINE__))
+
     call set_active(bounds)
     call check_weights(bounds, active_only=.false.)
     call check_weights(bounds, active_only=.true.)
diff --git a/components/elm/src/main/soilorder_varcon.F90 b/components/elm/src/main/soilorder_varcon.F90
index 2aa67edfbb..77d2f0002d 100644
--- a/components/elm/src/main/soilorder_varcon.F90
+++ b/components/elm/src/main/soilorder_varcon.F90
@@ -50,18 +50,7 @@ module soilorder_varcon
 
   !+
   real(r8), pointer :: r_mort_soilorder(:)
-  !$acc declare create(smax(:)       )
-  !$acc declare create(ks_sorption(:))
-  !$acc declare create(r_weather(:)  )
-  !$acc declare create(r_adsorp(:)   )
-  !$acc declare create(r_desorp(:)   )
-  !$acc declare create(r_occlude(:)  )
-  !$acc declare create(k_s1_biochem(:))
-  !$acc declare create(k_s2_biochem(:))
-  !$acc declare create(k_s3_biochem(:))
-  !$acc declare create(k_s4_biochem(:))
 
-  !$acc declare create(r_mort_soilorder)
 
 
   ! !PUBLIC MEMBER FUNCTIONS:
@@ -176,6 +165,8 @@ contains
 
     call ncd_pio_closefile(ncid)
 
+
+
     do i = 1,nsoilorder
 
        if ( trim(adjustl(soilordername(i))) /= trim(expected_soilnames(i)) )then
@@ -195,3 +186,4 @@ contains
 
 
 end module soilorder_varcon
+
diff --git a/components/elm/src/main/subgridAveMod.F90 b/components/elm/src/main/subgridAveMod.F90
index b63e542589..dfbc9448b4 100644
--- a/components/elm/src/main/subgridAveMod.F90
+++ b/components/elm/src/main/subgridAveMod.F90
@@ -23,9 +23,8 @@ module subgridAveMod
   implicit none
   save
 
-  integer, public, parameter :: unity = 1, natveg = 2, veg = 3
-  integer, public, parameter :: ice = 4, nonurb = 5, lake = 6
-  integer, public, parameter :: urbanf = 2, urbans = 3
+  integer, parameter :: unity = 0, urbanf = 1, urbans = 2
+  integer, parameter :: natveg = 3, veg =4, ice=5, nonurb=6, lake=7
   !
   ! !PUBLIC MEMBER FUNCTIONS:
   public :: p2c   ! Perform an average pfts to columns
@@ -45,7 +44,7 @@ module subgridAveMod
      module procedure p2c_1d
      module procedure p2c_1d_gpu
      module procedure p2c_2d
-   !   module procedure p2c_2d_gpu
+     module procedure p2c_2d_gpu
      module procedure p2c_1d_filter
      module procedure p2c_2d_filter
   end interface
@@ -102,25 +101,13 @@ module subgridAveMod
     module procedure create_scale_c2l_gpu
   end interface
 
-  public :: p2c_1d_filter_parallel
-  public :: p2c_1d_parallel 
-  public :: p2c_2d_parallel
-  public :: c2g_1d_parallel
-  !
-  public :: initialize_scale_l2g_lookup
-  public :: initialize_scale_c2l
+
   !
   ! !PRIVATE MEMBER FUNCTIONS:
   private :: build_scale_l2g
   private :: create_scale_l2g_lookup
   private :: build_scale_l2t
   private :: create_scale_l2t_lookup
-
-  ! New arrays created to stop unnecessary calls for fixed scaling quantities
-  real(r8), allocatable, private :: main_scale_l2g_lookup(:,:) !dimensions (scale_type, lun_pp%itype)
-  !$acc declare create(main_scale_l2g_lookup(:,:))
-  real(r8), allocatable, private :: main_scale_c2l(:,:) ! dimensions = (col, scale_type) 
-  !$acc declare create(main_scale_c2l(:,:))
   
   ! WJS (10-14-11): TODO:
   !
@@ -148,7 +135,6 @@ contains
     ! Averaging is only done for points that are not equal to "spval".
     !
     ! !ARGUMENTS:
-      !$acc routine seq 
     type(bounds_type), intent(in) :: bounds
     real(r8), intent(in)  :: parr( bounds%begp: )         ! patch array
     real(r8), intent(out) :: carr( bounds%begc: )         ! column array
@@ -156,10 +142,24 @@ contains
     !
     ! !LOCAL VARIABLES:
     integer  :: p,c,index                       ! indices
-    logical  :: found                           ! temporary for error check
-    real(r8) :: sumwt(bounds%begc:bounds%endc)  ! sum of weights
+    real(r8) :: scale_p2c(bounds%begp:bounds%endp) ! scale factor for column->landunit mapping
+    logical  :: found                              ! temporary for error check
+    real(r8) :: sumwt(bounds%begc:bounds%endc)     ! sum of weights
     !------------------------------------------------------------------------
 
+    ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(parr) == (/bounds%endp/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(carr) == (/bounds%endc/)), errMsg(__FILE__, __LINE__))
+
+    if (p2c_scale_type == 'unity') then
+       do p = bounds%begp,bounds%endp
+          scale_p2c(p) = 1.0_r8
+       end do
+    else
+      write(iulog,*)'p2c_2d error: scale type ',p2c_scale_type,' not supported'
+      call endrun(msg=errMsg(__FILE__, __LINE__))
+    end if
+
     carr(bounds%begc:bounds%endc) = spval
     sumwt(bounds%begc:bounds%endc) = 0._r8
     do p = bounds%begp,bounds%endp
@@ -167,12 +167,11 @@ contains
           if (parr(p) /= spval) then
              c = veg_pp%column(p)
              if (sumwt(c) == 0._r8) carr(c) = 0._r8
-             carr(c) = carr(c) + parr(p) * veg_pp%wtcol(p)
+             carr(c) = carr(c) + parr(p) * scale_p2c(p) * veg_pp%wtcol(p)
              sumwt(c) = sumwt(c) + veg_pp%wtcol(p)
           end if
        end if
     end do
-    
     found = .false.
     do c = bounds%begc,bounds%endc
        if (sumwt(c) > 1.0_r8 + 1.e-6_r8) then
@@ -182,9 +181,12 @@ contains
           carr(c) = carr(c)/sumwt(c)
        end if
     end do
+    if (found) then
+      write(iulog,*)'p2c_1d error: sumwt is greater than 1.0'
+      call endrun(decomp_index=index, elmlevel=namec, msg=errMsg(__FILE__, __LINE__))
+    end if
 
   end subroutine p2c_1d
-
   !-----------------------------------------------------------------------
   subroutine p2c_1d_gpu (bounds, parr, carr, p2c_scale_type)
     !$acc routine seq
@@ -200,10 +202,21 @@ contains
     !
     ! !LOCAL VARIABLES:
     integer  :: p,c,index                       ! indices
+    real(r8) :: scale_p2c(bounds%begp:bounds%endp) ! scale factor for column->landunit mapping
     logical  :: found                              ! temporary for error check
     real(r8) :: sumwt(bounds%begc:bounds%endc)     ! sum of weights
     !------------------------------------------------------------------------
 
+    ! Enforce expected array sizes
+
+    if (p2c_scale_type == unity) then
+       do p = bounds%begp,bounds%endp
+          scale_p2c(p) = 1.0_r8
+       end do
+    else
+       stop
+    end if
+
     carr(bounds%begc:bounds%endc) = spval
     sumwt(bounds%begc:bounds%endc) = 0._r8
     do p = bounds%begp,bounds%endp
@@ -211,7 +224,7 @@ contains
           if (parr(p) /= spval) then
              c = veg_pp%column(p)
              if (sumwt(c) == 0._r8) carr(c) = 0._r8
-             carr(c) = carr(c) + parr(p) * veg_pp%wtcol(p)
+             carr(c) = carr(c) + parr(p) * scale_p2c(p) * veg_pp%wtcol(p)
              sumwt(c) = sumwt(c) + veg_pp%wtcol(p)
           end if
        end if
@@ -231,62 +244,6 @@ contains
 
   end subroutine p2c_1d_gpu
 
-  subroutine p2c_1d_parallel (bounds, parr, carr, p2c_scale_type, para)
-   ! !DESCRIPTION:
-   ! Perfrom subgrid-average from pfts to columns.
-   ! Averaging is only done for points that are not equal to "spval".
-   !
-   ! !ARGUMENTS:
-   type(bounds_type), intent(in) :: bounds
-   real(r8), intent(in)  :: parr( bounds%begp: )   ! patch array
-   real(r8), intent(out) :: carr(1:)   ! column array
-   integer, intent(in) :: p2c_scale_type ! scale type
-   logical, intent(in) :: para 
-   !
-   ! !LOCAL VARIABLES:
-   integer  :: p,c,index                       ! indices
-   logical  :: found                              ! temporary for error check
-   real(r8) :: sumwt, sum_arr !(bounds%begc:bounds%endc)     ! sum of weights
-   !------------------------------------------------------------------------
-
-   !$acc parallel loop independent gang worker default(present) private(sumwt,sum_arr)
-   do c = bounds%begc, bounds%endc
-      sumwt = 0._r8
-      sum_arr = 0._r8
-      !$acc loop vector reduction(+:sumwt)
-      do p = col_pp%pfti(c), col_pp%pftf(c)
-         if (veg_pp%active(p) .and. veg_pp%wtcol(p) /= 0._r8) then
-            if (parr(p) /= spval) then
-               
-               sum_arr = sum_arr + parr(p) * veg_pp%wtcol(p)
-               sumwt = sumwt + veg_pp%wtcol(p)
-            end if
-         end if
-      end do
-      carr(c) = sum_arr ! is this an issue for not being spval anymore?
-      if(sumwt > 1.0_r8 + 1.e-6_r8 ) then 
-         stop "Error p2c_1d sumwts > 1"
-      elseif(sumwt /= 0._r8) then 
-         carr(c) = carr(c)/sumwt
-      elseif(sumwt == 0._r8) then 
-         carr(c) = spval 
-      end if 
-   end do 
-   
-   ! found = .false.
-   ! do c = bounds%begc,bounds%endc
-   !    if (sumwt(c) > 1.0_r8 + 1.e-6_r8) then
-   !       found = .true.
-   !       index = c
-   !    else if (sumwt(c) /= 0._r8) then
-   !       carr(c) = carr(c)/sumwt(c)
-   !    end if
-   ! end do
-   ! if (found) then
-   !   stop
-   ! end if
- end subroutine p2c_1d_parallel 
-
   !-----------------------------------------------------------------------
   subroutine p2c_2d (bounds, num2d, parr, carr, p2c_scale_type)
     !
@@ -303,10 +260,24 @@ contains
     !
     ! !LOCAL VARIABLES:
     integer  :: j,p,c,index                         ! indices
+    real(r8) :: scale_p2c(bounds%begp:bounds%endp)     ! scale factor for column->landunit mapping
     logical  :: found                                  ! temporary for error check
     real(r8) :: sumwt(bounds%begc:bounds%endc)         ! sum of weights
     !------------------------------------------------------------------------
 
+    ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(parr) == (/bounds%endp, num2d/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(carr) == (/bounds%endc, num2d/)), errMsg(__FILE__, __LINE__))
+
+    if (p2c_scale_type == 'unity') then
+       do p = bounds%begp,bounds%endp
+          scale_p2c(p) = 1.0_r8
+       end do
+    else
+       write(iulog,*)'p2c_2d error: scale type ',p2c_scale_type,' not supported'
+       call endrun(msg=errMsg(__FILE__, __LINE__))
+    end if
+
     carr(bounds%begc : bounds%endc, :) = spval
     do j = 1,num2d
        sumwt(bounds%begc : bounds%endc) = 0._r8
@@ -315,7 +286,7 @@ contains
              if (parr(p,j) /= spval) then
                 c = veg_pp%column(p)
                 if (sumwt(c) == 0._r8) carr(c,j) = 0._r8
-                carr(c,j) = carr(c,j) + parr(p,j) * veg_pp%wtcol(p)
+                carr(c,j) = carr(c,j) + parr(p,j) * scale_p2c(p) * veg_pp%wtcol(p)
                 sumwt(c) = sumwt(c) + veg_pp%wtcol(p)
              end if
           end if
@@ -329,13 +300,17 @@ contains
              carr(c,j) = carr(c,j)/sumwt(c)
           end if
        end do
-
+       if (found) then
+          write(iulog,*)'p2c_2d error: sumwt is greater than 1.0 at c= ',index,' lev= ',j
+          call endrun(decomp_index=index, elmlevel=namec, msg=errMsg(__FILE__, __LINE__))
+       end if
     end do
   end subroutine p2c_2d
 
 
   !-----------------------------------------------------------------------
-  subroutine p2c_2d_parallel(bounds, num2d, parr, carr)
+  subroutine p2c_2d_gpu (bounds, num2d, parr, carr, p2c_scale_type)
+    !$acc routine seq
     ! !DESCRIPTION:
     ! Perfrom subgrid-average from landunits to gridcells.
     ! Averaging is only done for points that are not equal to "spval".
@@ -345,90 +320,50 @@ contains
     integer           , intent(in)  :: num2d                     ! size of second dimension
     real(r8)          , intent(in)  :: parr( bounds%begp: , 1: ) ! patch array
     real(r8)          , intent(out) :: carr( bounds%begc: , 1: ) ! column array
+    integer           , intent(in) :: p2c_scale_type ! unity = 0, urbanf = 1, urbans = 2
     !
     ! !LOCAL VARIABLES:
-    integer  :: j,p,c,index                      ! indices
-    real(r8), parameter :: scale_p2c = 1.0_r8    ! scale factor for column->landunit mapping
-    logical  :: found                            ! temporary for error check
-    real(r8) :: sumwt(bounds%begc:bounds%endc)   ! sum of weights
-    real(r8) :: sum1 
+    integer  :: j,p,c,index                         ! indices
+    real(r8) :: scale_p2c(bounds%begp:bounds%endp)     ! scale factor for column->landunit mapping
+    logical  :: found                                  ! temporary for error check
+    real(r8) :: sumwt(bounds%begc:bounds%endc)         ! sum of weights
     !------------------------------------------------------------------------
 
-    !$acc enter data create(&
-    !$acc sumwt(:), &
-    !$acc sum1)
-
-    !$acc parallel loop independent gang worker default(present) private(sum1)
-    do c = bounds%begc, bounds%endc 
-      sum1 = 0._r8 
-      !$acc loop vector reduction(+:sum1)
-      do p = col_pp%pfti(c), col_pp%pftf(c) 
-         if (veg_pp%active(p) .and. veg_pp%wtcol(p) /= 0._r8 .and. parr(p,j) /= spval) then
-            sum1 = sum1 + veg_pp%wtcol(p)
-         end if 
-      end do
-      if(sum1 > 1.0_r8 + 1.e-6_r8) stop  
-      sumwt(c) = sum1 
-    end do
+    if (p2c_scale_type == unity) then
+       do p = bounds%begp,bounds%endp
+          scale_p2c(p) = 1.0_r8
+       end do
+    else
+      stop
+    end if
 
-    ! carr(bounds%begc : bounds%endc, :) = spval
-    !$acc parallel loop independent gang worker default(present) private(sum1)
+    carr(bounds%begc : bounds%endc, :) = spval
     do j = 1,num2d
-      do c = bounds%begc,bounds%endc
-            sum1 = 0._r8 
-         do p = col_pp%pfti(c), col_pp%pftf(c) 
-            if (veg_pp%active(p) .and. veg_pp%wtcol(p) /= 0._r8 .and. parr(p,j) /= spval) then
-                sum1 = sum1 + parr(p,j) * veg_pp%wtcol(p)
-            end if
-         end do
-         carr(c,j) = sum1
-         if(sumwt(c) /= 0._r8) then 
-            carr(c,j) = carr(c,j)/sumwt(c)
-         end if 
-      end do 
-    end do 
-
-    !$acc exit data delete(&
-    !$acc sumwt(:), &
-    !$acc sum1)
-
-  end subroutine p2c_2d_parallel
-
-
-  !-----------------------------------------------------------------------
-  subroutine p2c_1d_filter_parallel( numfc, filterc,  pftarr, colarr)
-    !
-    ! !DESCRIPTION:
-    ! perform pft to column averaging for single level pft arrays
-    ! Note: pftarr and colarr are the entire array for a processor
-    !      not divisble by clumps
-    !
-    ! !ARGUMENTS:
-    integer , intent(in)  :: numfc
-    integer , intent(in)  :: filterc(numfc)
-    real(r8), intent(in)  :: pftarr(:)
-    real(r8), intent(out) :: colarr(:)
-
-    ! !LOCAL VARIABLES:
-    integer :: fc,c,p  ! indices
-    real(r8) :: sum1
-    !-----------------------------------------------------------------------
-
-    ! Enforce expected array sizes
-
-    !$acc parallel loop independent gang worker private(c,sum1) &
-    !$acc default(present) create(sum1)
-    do fc = 1,numfc
-       c = filterc(fc)
-       sum1 = 0._r8
-       !$acc loop vector reduction(+:sum1)
-       do p = col_pp%pfti(c), col_pp%pftf(c)
-          if (veg_pp%active(p)) sum1 = sum1 + pftarr(p) * veg_pp%wtcol(p)
+       sumwt(bounds%begc : bounds%endc) = 0._r8
+       do p = bounds%begp,bounds%endp
+          if (veg_pp%active(p) .and. veg_pp%wtcol(p) /= 0._r8) then
+             if (parr(p,j) /= spval) then
+                c = veg_pp%column(p)
+                if (sumwt(c) == 0._r8) carr(c,j) = 0._r8
+                carr(c,j) = carr(c,j) + parr(p,j) * scale_p2c(p) * veg_pp%wtcol(p)
+                sumwt(c) = sumwt(c) + veg_pp%wtcol(p)
+             end if
+          end if
+       end do
+       found = .false.
+       do c = bounds%begc,bounds%endc
+          if (sumwt(c) > 1.0_r8 + 1.e-6_r8) then
+             found = .true.
+             index = c
+          else if (sumwt(c) /= 0._r8) then
+             carr(c,j) = carr(c,j)/sumwt(c)
+          end if
        end do
-       colarr(c) = sum1
+       if (found) then
+         stop
+       end if
     end do
-
-end subroutine p2c_1d_filter_parallel
+  end subroutine p2c_2d_gpu
 
   !-----------------------------------------------------------------------
   subroutine p2c_1d_filter (bounds, numfc, filterc,  pftarr, colarr)
@@ -443,10 +378,14 @@ end subroutine p2c_1d_filter_parallel
     integer , intent(in)  :: filterc(numfc)
     real(r8), intent(in)  :: pftarr( bounds%begp: )
     real(r8), intent(out) :: colarr( bounds%begc: )
+    !type(column_physical_properties) , target :: col_pp
 
-       ! !LOCAL VARIABLES:
+    ! !LOCAL VARIABLES:
     integer :: fc,c,p  ! indices
     !-----------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+
     do fc = 1,numfc
        c = filterc(fc)
        colarr(c) = 0._r8
@@ -508,6 +447,8 @@ end subroutine p2c_1d_filter_parallel
     real(r8) :: scale_c2l(bounds%begc:bounds%endc) ! scale factor for column->landunit mapping
     !------------------------------------------------------------------------
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(parr) == (/bounds%endp/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(larr) == (/bounds%endl/)), errMsg(__FILE__, __LINE__))
 
     call create_scale_c2l(bounds,c2l_scale_type,scale_c2l(bounds%begc:bounds%endc))
 
@@ -516,8 +457,8 @@ end subroutine p2c_1d_filter_parallel
           scale_p2c(p) = 1.0_r8
        end do
     else
-       !#py write(iulog,*)'p2l_1d error: scale type ',p2c_scale_type,' not supported'
-       !#py !#py call endrun(msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'p2l_1d error: scale type ',p2c_scale_type,' not supported'
+       call endrun(msg=errMsg(__FILE__, __LINE__))
     end if
 
     larr(bounds%begl : bounds%endl) = spval
@@ -543,8 +484,8 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     if (found) then
-       !#py write(iulog,*)'p2l_1d error: sumwt is greater than 1.0 at l= ',index
-       !#py !#py call endrun(decomp_index=index, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'p2l_1d error: sumwt is greater than 1.0 at l= ',index
+       call endrun(decomp_index=index, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
     end if
 
   end subroutine p2l_1d
@@ -573,6 +514,8 @@ end subroutine p2c_1d_filter_parallel
     !------------------------------------------------------------------------
 
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(parr) == (/bounds%endp, num2d/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(larr) == (/bounds%endl, num2d/)), errMsg(__FILE__, __LINE__))
     
     call create_scale_c2l(bounds,c2l_scale_type,scale_c2l(bounds%begc:bounds%endc))
 
@@ -582,8 +525,8 @@ end subroutine p2c_1d_filter_parallel
           scale_p2c(p) = 1.0_r8
        end do
     else
-       !#py write(iulog,*)'p2l_2d error: scale type ',p2c_scale_type,' not supported'
-       !#py !#py call endrun(msg=errMsg(__FILE__, __LINE__))
+      write(iulog,*)'p2l_2d error: scale type ',p2c_scale_type,' not supported'
+      call endrun(msg=errMsg(__FILE__, __LINE__))
     end if
 
     larr(bounds%begl : bounds%endl, :) = spval
@@ -610,8 +553,8 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
        if (found) then
-          !#py write(iulog,*)'p2l_2d error: sumwt is greater than 1.0 at l= ',index,' j= ',j
-          !#py !#py call endrun(decomp_index=index, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
+          write(iulog,*)'p2l_2d error: sumwt is greater than 1.0 at l= ',index,' j= ',j
+          call endrun(decomp_index=index, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
@@ -652,8 +595,8 @@ end subroutine p2c_1d_filter_parallel
           scale_p2c(p) = 1.0_r8
        end do
     else
-       !#py write(iulog,*)'p2g_1d error: scale type ',c2l_scale_type,' not supported'
-       !#py !#py call endrun(msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'p2g_1d error: scale type ',c2l_scale_type,' not supported'
+       call endrun(msg=errMsg(__FILE__, __LINE__))
     end if
 
     garr(bounds%begg : bounds%endg) = spval
@@ -680,8 +623,8 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     if (found) then
-       !#py write(iulog,*)'p2g_1d error: sumwt is greater than 1.0 at g= ',index
-       !#py !#py call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'p2g_1d error: sumwt is greater than 1.0 at g= ',index
+       call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
     end if
 
   end subroutine p2g_1d
@@ -703,23 +646,75 @@ end subroutine p2c_1d_filter_parallel
     !  !LOCAL VARIABLES:
     integer  :: p,c,l,g,index                   ! indices
     logical  :: found                              ! temporary for error check
-    real(r8),parameter :: scale_p2c = 1._r8 ! scale factor
-    real(r8) :: scale_c2l ! scale factor
-    real(r8) :: scale_l2g ! scale factor
+    real(r8) :: scale_p2c(bounds%begp:bounds%endp) ! scale factor
+    real(r8) :: scale_c2l(bounds%begc:bounds%endc) ! scale factor
+    real(r8) :: scale_l2g(bounds%begl:bounds%endl) ! scale factor
     real(r8) :: sumwt(bounds%begg:bounds%endg)     ! sum of weights
     !------------------------------------------------------------------------
+
+    call build_scale_l2g_gpu(bounds, l2g_scale_type, &
+         scale_l2g)
+
+    if (c2l_scale_type == unity) then
+       do c = bounds%begc,bounds%endc
+          scale_c2l(c) = 1.0_r8
+       end do
+    else if (c2l_scale_type == urbanf) then
+       do c = bounds%begc,bounds%endc
+          l = col_pp%landunit(c)
+          if (lun_pp%urbpoi(l)) then
+             if (col_pp%itype(c) == icol_sunwall) then
+                scale_c2l(c) = 3.0 * lun_pp%canyon_hwr(l)
+             else if (col_pp%itype(c) == icol_shadewall) then
+                scale_c2l(c) = 3.0 * lun_pp%canyon_hwr(l)
+             else if (col_pp%itype(c) == icol_road_perv .or. col_pp%itype(c) == icol_road_imperv) then
+                scale_c2l(c) = 3.0_r8
+             else if (col_pp%itype(c) == icol_roof) then
+                scale_c2l(c) = 1.0_r8
+             end if
+          else
+             scale_c2l(c) = 1.0_r8
+          end if
+       end do
+    else if (c2l_scale_type == urbans) then
+       do c = bounds%begc,bounds%endc
+          l = col_pp%landunit(c)
+          if (lun_pp%urbpoi(l)) then
+             if (col_pp%itype(c) == icol_sunwall) then
+                scale_c2l(c) = (3.0 * lun_pp%canyon_hwr(l)) / (2.*lun_pp%canyon_hwr(l) + 1.)
+             else if (col_pp%itype(c) == icol_shadewall) then
+                scale_c2l(c) = (3.0 * lun_pp%canyon_hwr(l)) / (2.*lun_pp%canyon_hwr(l) + 1.)
+             else if (col_pp%itype(c) == icol_road_perv .or. col_pp%itype(c) == icol_road_imperv) then
+                scale_c2l(c) = 3.0 / (2.*lun_pp%canyon_hwr(l) + 1.)
+             else if (col_pp%itype(c) == icol_roof) then
+                scale_c2l(c) = 1.0_r8
+             end if
+          else
+             scale_c2l(c) = 1.0_r8
+          end if
+       end do
+    else
+       print *, 'p2g_1d error: scale type ',c2l_scale_type,' not supported'
+    end if
+
+    if (p2c_scale_type == unity) then
+       do p = bounds%begp,bounds%endp
+          scale_p2c(p) = 1.0_r8
+       end do
+    else
+       print *, 'p2g_1d error: scale type ',c2l_scale_type,' not supported'
+    end if
+
     garr(bounds%begg : bounds%endg) = spval
     sumwt(bounds%begg : bounds%endg) = 0._r8
     do p = bounds%begp,bounds%endp
        if (veg_pp%active(p) .and. veg_pp%wtgcell(p) /= 0._r8) then
           c = veg_pp%column(p)
           l = veg_pp%landunit(p)
-          scale_l2g = main_scale_l2g_lookup(l2g_scale_type,lun_pp%itype(l))
-          scale_c2l = main_scale_c2l(c,c2l_scale_type)
-          if (parr(p) /= spval .and. scale_c2l /= spval .and. scale_l2g /= spval) then
+          if (parr(p) /= spval .and. scale_c2l(c) /= spval .and. scale_l2g(l) /= spval) then
              g = veg_pp%gridcell(p)
              if (sumwt(g) == 0._r8) garr(g) = 0._r8
-             garr(g) = garr(g) + parr(p) * scale_p2c * scale_c2l * scale_l2g * veg_pp%wtgcell(p)
+             garr(g) = garr(g) + parr(p) * scale_p2c(p) * scale_c2l(c) * scale_l2g(l) * veg_pp%wtgcell(p)
              sumwt(g) = sumwt(g) + veg_pp%wtgcell(p)
           end if
        end if
@@ -766,6 +761,8 @@ end subroutine p2c_1d_filter_parallel
     real(r8) :: sumwt(bounds%begg:bounds%endg)         ! sum of weights
     !------------------------------------------------------------------------
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(parr) == (/bounds%endp, num2d/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(garr) == (/bounds%endg, num2d/)), errMsg(__FILE__, __LINE__))
 
     call build_scale_l2g(bounds, l2g_scale_type, &
          scale_l2g)
@@ -777,8 +774,8 @@ end subroutine p2c_1d_filter_parallel
           scale_p2c(p) = 1.0_r8
        end do
     else
-       !#py write(iulog,*)'p2g_2d error: scale type ',c2l_scale_type,' not supported'
-       !#py !#py call endrun(msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'p2g_2d error: scale type ',c2l_scale_type,' not supported'
+       call endrun(msg=errMsg(__FILE__, __LINE__))
     end if
 
     garr(bounds%begg : bounds%endg, :) = spval
@@ -806,8 +803,8 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
        if (found) then
-          !#py write(iulog,*)'p2g_2d error: sumwt gt 1.0 at g/sumwt = ',index,sumwt(index)
-          !#py !#py call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
+          write(iulog,*)'p2g_2d error: sumwt gt 1.0 at g/sumwt = ',index,sumwt(index)
+          call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
@@ -884,8 +881,10 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
     else
-       !write(iulog,*)'p2g_2d error: scale type ',c2l_scale_type,' not supported'
-       !call endrun(msg=errMsg(__FILE__, __LINE__))
+#ifndef _OPENACC
+       write(iulog,*)'p2g_2d error: scale type ',c2l_scale_type,' not supported'
+       call endrun(msg=errMsg(__FILE__, __LINE__))
+#endif 
     end if
 
     if (p2c_scale_type == unity) then
@@ -893,8 +892,10 @@ end subroutine p2c_1d_filter_parallel
           scale_p2c(p) = 1.0_r8
        end do
     else
-       !write(iulog,*)'p2g_2d error: scale type ',c2l_scale_type,' not supported'
-       !call endrun(msg=errMsg(__FILE__, __LINE__))
+#ifndef _OPENACC
+       write(iulog,*)'p2g_2d error: scale type ',c2l_scale_type,' not supported'
+       call endrun(msg=errMsg(__FILE__, __LINE__))
+#endif 
     end if
 
     garr(bounds%begg : bounds%endg, :) = spval
@@ -950,6 +951,8 @@ end subroutine p2c_1d_filter_parallel
     !------------------------------------------------------------------------
 
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(carr) == (/bounds%endc/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(larr) == (/bounds%endl/)), errMsg(__FILE__, __LINE__))
 
     call create_scale_c2l(bounds, c2l_scale_type, scale_c2l(bounds%begc:bounds%endc))
 
@@ -975,8 +978,8 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     if (found) then
-       !#py write(iulog,*)'c2l_1d error: sumwt is greater than 1.0 at l= ',index
-       !#py !#py call endrun(decomp_index=index, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'c2l_1d error: sumwt is greater than 1.0 at l= ',index
+       call endrun(decomp_index=index, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
     end if
 
   end subroutine c2l_1d
@@ -1003,6 +1006,8 @@ end subroutine p2c_1d_filter_parallel
     !------------------------------------------------------------------------
 
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(carr) == (/bounds%endc, num2d/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(larr) == (/bounds%endl, num2d/)), errMsg(__FILE__, __LINE__))
 
     call create_scale_c2l(bounds, c2l_scale_type, &
          scale_c2l(bounds%begc:bounds%endc))
@@ -1030,13 +1035,12 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
        if (found) then
-        !#py write(iulog,*)'c2l_2d error: sumwt is greater than 1.0 at l= ',index,' lev= ',j
-        !#py !#py call endrun(decomp_index=index, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
+        write(iulog,*)'c2l_2d error: sumwt is greater than 1.0 at l= ',index,' lev= ',j
+        call endrun(decomp_index=index, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
   end subroutine c2l_2d
-
   !-----------------------------------------------------------------------
   subroutine c2g_1d(bounds, carr, garr, c2l_scale_type, l2g_scale_type)
     ! !DESCRIPTION:
@@ -1077,7 +1081,6 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     found = .false.
-    
     do g = bounds%begg, bounds%endg
        if (sumwt(g) > 1.0_r8 + 1.e-6_r8) then
           found = .true.
@@ -1087,8 +1090,8 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     if (found) then
-       !#py write(iulog,*)'c2g_1d error: sumwt is greater than 1.0 at g= ',index
-       !#py !#py call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'c2g_1d error: sumwt is greater than 1.0 at g= ',index
+       call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
     end if
 
   end subroutine c2g_1d
@@ -1109,23 +1112,25 @@ end subroutine p2c_1d_filter_parallel
     ! !LOCAL VARIABLES:
     integer  :: c,l,g,index                     ! indices
     logical  :: found                              ! temporary for error check
-    real(r8) :: scale_c2l ! scale factor
-    real(r8) :: scale_l2g ! scale factor
+    real(r8) :: scale_c2l(bounds%begc:bounds%endc) ! scale factor
+    real(r8) :: scale_l2g(bounds%begl:bounds%endl) ! scale factor
     real(r8) :: sumwt(bounds%begg:bounds%endg)     ! sum of weights
     !------------------------------------------------------------------------
-   
+
+    call build_scale_l2g_gpu(bounds, l2g_scale_type, &
+         scale_l2g)
+
+    call create_scale_c2l_gpu(bounds,c2l_scale_type, scale_c2l)
+
     garr(bounds%begg : bounds%endg) = spval
     sumwt(bounds%begg : bounds%endg) = 0._r8
-
     do c = bounds%begc,bounds%endc
        if (col_pp%active(c) .and. col_pp%wtgcell(c) /= 0._r8) then
           l = col_pp%landunit(c)
-          scale_l2g = main_scale_l2g_lookup(l2g_scale_type,lun_pp%itype(l))
-          scale_c2l = main_scale_c2l(c,c2l_scale_type)
-          if (carr(c) /= spval .and. scale_c2l /= spval .and. scale_l2g /= spval) then
-            g = col_pp%gridcell(c)
+          if (carr(c) /= spval .and. scale_c2l(c) /= spval .and. scale_l2g(l) /= spval) then
+             g = col_pp%gridcell(c)
              if (sumwt(g) == 0._r8) garr(g) = 0._r8
-             garr(g) = garr(g) + carr(c) * scale_c2l * scale_l2g * col_pp%wtgcell(c)
+             garr(g) = garr(g) + carr(c) * scale_c2l(c) * scale_l2g(l) * col_pp%wtgcell(c)
              sumwt(g) = sumwt(g) + col_pp%wtgcell(c)
           end if
        end if
@@ -1139,72 +1144,15 @@ end subroutine p2c_1d_filter_parallel
           garr(g) = garr(g)/sumwt(g)
        end if
     end do
+    if (found) then
+#ifndef _OPENACC            
+        write(iulog,*) 'c2g_1d error: sumwt is greater than 1.0 at g= ',index
+        call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
+#endif 
+    end if
 
   end subroutine c2g_1d_gpu
 
-  
-  subroutine c2g_1d_parallel(bounds, carr, garr, c2l_scale_type, l2g_scale_type,para)
-   ! !DESCRIPTION:
-   ! Perfrom subgrid-average from columns to gridcells.
-   ! Averaging is only done for points that are not equal to "spval".
-   !
-   use GridcellType , only : grc_pp 
-   ! !ARGUMENTS:
-   type(bounds_type), intent(in) :: bounds
-   real(r8), intent(in)  :: carr( bounds%begc: )  ! input column array
-   real(r8), intent(out) :: garr( bounds%begg: )  ! output gridcell array
-   integer , intent(in) :: c2l_scale_type  !! unity = 1, urbanf = 2, urbans = 3
-   integer , intent(in) :: l2g_scale_type  !!natveg = 2, veg =3, ice=4, nonurb=5, lake=6
-   logical, intent(in) :: para
-   !
-   ! !LOCAL VARIABLES:
-   integer  :: c,l,g,index,fc  ! indices
-   logical  :: found        ! temporary for error check
-   real(r8) :: scale_c2l  ! scale factor ! now using main_scale_c2l
-   real(r8) :: scale_l2g  ! scale factor
-   real(r8) :: sumwt   ! sum of weights
-   real(r8) :: sum_g 
-   !- -----------------------------------------------------------------------
-   ! note : scale_l2g(l) = main_scale_l2g_lookup(TYPE,lun_pp%itype(l))
-   !        main_scale_c2l(cols, c2l_scale_type)
-   !$acc enter data create(&
-   !$acc sumwt, &
-   !$acc sum_g)
-
-   !$acc parallel loop independent gang worker default(present) private(sumwt,sum_g) copyin(c2l_scale_type)
-   do g = bounds%begg,bounds%endg
-      sumwt = 0._r8
-      sum_g = 0._r8
-      !$acc loop reduction(+:sumwt,sum_g) private(l,scale_l2g,scale_c2l,c)
-      do fc = 1, grc_pp%ncolumns(g)
-         c = grc_pp%cols(g,fc)  
-         if (col_pp%active(c) .and. col_pp%wtgcell(c) /= 0._r8) then
-            l = col_pp%landunit(c)
-            scale_l2g = main_scale_l2g_lookup(l2g_scale_type,lun_pp%itype(l))
-            scale_c2l = main_scale_c2l(c,c2l_scale_type)
-            if (carr(c) /= spval .and. scale_c2l /= spval .and. scale_l2g /= spval) then
-               sum_g = sum_g + carr(c) * scale_c2l * scale_l2g * col_pp%wtgcell(c)
-               sumwt = sumwt + col_pp%wtgcell(c)
-            end if
-         end if
-      end do 
-      garr(g) = sum_g
-
-      if(sumwt .ne. 0._r8) then 
-         garr(g) = garr(g)/sumwt
-      elseif(sumwt == 0._r8 ) then 
-         garr(g) = spval  !! needed to keep unused equal to spval?
-      elseif(sumwt > 1.0_r8 + 1.e-6_r8 ) then 
-         stop "Error with col gridcell weights"
-      end if 
-   end do
-
-   !$acc exit data delete(&
-   !$acc sumwt, &
-   !$acc sum_g)
-
- end subroutine c2g_1d_parallel
-
   !-----------------------------------------------------------------------
   subroutine c2g_2d(bounds, num2d, carr, garr, c2l_scale_type, l2g_scale_type)
     ! !DESCRIPTION:
@@ -1217,7 +1165,7 @@ end subroutine p2c_1d_filter_parallel
     real(r8), intent(in)  :: carr( bounds%begc: , 1: ) ! input column array
     real(r8), intent(out) :: garr( bounds%begg: , 1: ) ! output gridcell array
     character(len=*), intent(in) :: c2l_scale_type     ! scale factor type for averaging
-    character(len=*), intent(in) :: l2g_scale_type     ! scale factor type for averaging
+        character(len=*), intent(in) :: l2g_scale_type     ! scale factor type for averaging
     !
     ! !LOCAL VARIABLES:
     integer  :: j,c,g,l,index                       ! indices
@@ -1256,8 +1204,8 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
        if (found) then
-          !#py write(iulog,*)'c2g_2d error: sumwt is greater than 1.0 at g= ',index
-          !#py !#py call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
+          write(iulog,*)'c2g_2d error: sumwt is greater than 1.0 at g= ',index
+          call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
@@ -1365,8 +1313,8 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     if (found) then
-       !#py write(iulog,*) 'l2g_1d error: sumwt is greater than 1.0 at g= ',index
-       !#py !#py call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*) 'l2g_1d error: sumwt is greater than 1.0 at g= ',index
+       call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
     end if
 
   end subroutine l2g_1d
@@ -1419,8 +1367,8 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
        if (found) then
-          !#py write(iulog,*) 'l2g_2d error: sumwt is greater than 1.0 at g= ',index,' lev= ',j
-          !#py !#py call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
+          write(iulog,*) 'l2g_2d error: sumwt is greater than 1.0 at g= ',index,' lev= ',j
+          call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
@@ -1557,7 +1505,6 @@ end subroutine p2c_1d_filter_parallel
      end do
 
   end subroutine build_scale_l2g
-
   !-----------------------------------------------------------------------
   subroutine build_scale_l2g_gpu(bounds, l2g_scale_type, scale_l2g)
     !$acc routine seq
@@ -1608,6 +1555,7 @@ end subroutine p2c_1d_filter_parallel
     integer  :: l                       ! index
     !-----------------------------------------------------------------------
      
+    SHR_ASSERT_ALL((ubound(scale_l2t) == (/bounds%endl/)), errMsg(__FILE__, __LINE__))
 
      call create_scale_l2t_lookup(l2t_scale_type, scale_lookup)
 
@@ -1673,8 +1621,8 @@ end subroutine p2c_1d_filter_parallel
      else if (trim(l2g_scale_type) == 'lake') then
         scale_lookup(istdlak) = 1.0_r8
      else
-      !   write(iulog,*)'scale_l2g_lookup_array error: scale type ',l2g_scale_type,' not supported'
-      !   call endrun(msg=errMsg(__FILE__, __LINE__))
+        write(iulog,*)'scale_l2g_lookup_array error: scale type ',l2g_scale_type,' not supported'
+        call endrun(msg=errMsg(__FILE__, __LINE__))
      end if
 
   end subroutine create_scale_l2g_lookup
@@ -1715,8 +1663,8 @@ end subroutine p2c_1d_filter_parallel
      else if (l2t_scale_type == 'lake') then
         scale_lookup(istdlak) = 1.0_r8
      else
-        !#py write(iulog,*)'scale_l2g_lookup_array error: scale type ',l2t_scale_type,' not supported'
-        !#py !#py call endrun(msg=errMsg(__FILE__, __LINE__))
+        write(iulog,*)'scale_l2g_lookup_array error: scale type ',l2t_scale_type,' not supported'
+        call endrun(msg=errMsg(__FILE__, __LINE__))
      end if
 
   end subroutine create_scale_l2t_lookup
@@ -1746,6 +1694,8 @@ end subroutine p2c_1d_filter_parallel
     !------------------------------------------------------------------------
 
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(parr) == (/bounds%endp/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(tarr) == (/bounds%endt/)), errMsg(__FILE__, __LINE__))
 
     call build_scale_l2t(bounds, l2t_scale_type, &
          scale_l2t(bounds%begl:bounds%endl))
@@ -1759,8 +1709,8 @@ end subroutine p2c_1d_filter_parallel
           scale_p2c(p) = 1.0_r8
        end do
     else
-       !#py write(iulog,*)'p2t_1d error: scale type ',p2c_scale_type,' not supported'
-       !#py !#py call endrun(msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'p2t_1d error: scale type ',p2c_scale_type,' not supported'
+       call endrun(msg=errMsg(__FILE__, __LINE__))
     end if
 
     tarr(bounds%begt : bounds%endt) = spval
@@ -1787,8 +1737,8 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     if (found) then
-       !#py write(iulog,*)'p2t_1d error: sumwt is greater than 1.0 at t= ',index
-       !#py !#py call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'p2t_1d error: sumwt is greater than 1.0 at t= ',index
+       call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
     end if
 
   end subroutine p2t_1d
@@ -1821,6 +1771,8 @@ end subroutine p2c_1d_filter_parallel
     !------------------------------------------------------------------------
 
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(parr) == (/bounds%endp, num2d/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(tarr) == (/bounds%endt, num2d/)), errMsg(__FILE__, __LINE__))
 
     call build_scale_l2t(bounds, l2t_scale_type, &
          scale_l2t(bounds%begl:bounds%endl))
@@ -1834,8 +1786,8 @@ end subroutine p2c_1d_filter_parallel
           scale_p2c(p) = 1.0_r8
        end do
     else
-       !#py write(iulog,*)'p2t_2d error: scale type ',p2c_scale_type,' not supported'
-       !#py !#py call endrun(msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'p2t_2d error: scale type ',p2c_scale_type,' not supported'
+       call endrun(msg=errMsg(__FILE__, __LINE__))
     end if
 
     tarr(bounds%begt : bounds%endt, :) = spval
@@ -1863,8 +1815,8 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
        if (found) then
-          !#py write(iulog,*)'p2t_2d error: sumwt gt 1.0 at t/sumwt = ',index,sumwt(index)
-          !#py !#py call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
+          write(iulog,*)'p2t_2d error: sumwt gt 1.0 at t/sumwt = ',index,sumwt(index)
+          call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
@@ -1893,6 +1845,8 @@ end subroutine p2c_1d_filter_parallel
     !------------------------------------------------------------------------
 
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(carr) == (/bounds%endc/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(tarr) == (/bounds%endt/)), errMsg(__FILE__, __LINE__))
 
     call build_scale_l2t(bounds, l2t_scale_type, &
          scale_l2t(bounds%begl:bounds%endl))
@@ -1924,8 +1878,8 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     if (found) then
-       !#py write(iulog,*)'c2t_1d error: sumwt is greater than 1.0 at t= ',index
-       !#py !#py call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'c2t_1d error: sumwt is greater than 1.0 at t= ',index
+       call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
     end if
 
   end subroutine c2t_1d
@@ -1954,6 +1908,8 @@ end subroutine p2c_1d_filter_parallel
     !------------------------------------------------------------------------
 
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(carr) == (/bounds%endc, num2d/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(tarr) == (/bounds%endt, num2d/)), errMsg(__FILE__, __LINE__))
 
     call build_scale_l2t(bounds, l2t_scale_type, &
          scale_l2t(bounds%begl:bounds%endl))
@@ -1986,8 +1942,8 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
        if (found) then
-          !#py write(iulog,*)'c2t_2d error: sumwt is greater than 1.0 at t= ',index
-          !#py !#py call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
+          write(iulog,*)'c2t_2d error: sumwt is greater than 1.0 at t= ',index
+          call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
@@ -2014,6 +1970,8 @@ end subroutine p2c_1d_filter_parallel
     !------------------------------------------------------------------------
 
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(larr) == (/bounds%endl/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(tarr) == (/bounds%endt/)), errMsg(__FILE__, __LINE__))
 
     call build_scale_l2t(bounds, l2t_scale_type, &
          scale_l2t(bounds%begl:bounds%endl))
@@ -2040,8 +1998,8 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     if (found) then
-       !#py write(iulog,*)'l2t_1d error: sumwt is greater than 1.0 at t= ',index
-       !#py !#py call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'l2t_1d error: sumwt is greater than 1.0 at t= ',index
+       call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
     end if
 
   end subroutine l2t_1d
@@ -2069,6 +2027,8 @@ end subroutine p2c_1d_filter_parallel
     !------------------------------------------------------------------------
 
     ! Enforce expected array sizes
+    SHR_ASSERT_ALL((ubound(larr) == (/bounds%endl, num2d/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(tarr) == (/bounds%endt, num2d/)), errMsg(__FILE__, __LINE__))
 
     call build_scale_l2t(bounds, l2t_scale_type, &
          scale_l2t(bounds%begl:bounds%endl))
@@ -2096,8 +2056,8 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
        if (found) then
-          !#py write(iulog,*)'l2t_2d error: sumwt is greater than 1.0 at t= ',index,' lev= ',j
-          !#py !#py call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
+          write(iulog,*)'l2t_2d error: sumwt is greater than 1.0 at t= ',index,' lev= ',j
+          call endrun(decomp_index=index, elmlevel=namet, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
@@ -2161,8 +2121,10 @@ end subroutine p2c_1d_filter_parallel
      else if (l2g_scale_type == lake) then
         scale_lookup(istdlak) = 1.0_r8
      else
-        !write(iulog,*)'scale_l2g_lookup_array error: scale type ',l2g_scale_type,' not supported'
-        !call endrun(msg=errMsg(__FILE__, __LINE__))
+#ifndef _OPENACC             
+        write(iulog,*)'scale_l2g_lookup_array error: scale type ',l2g_scale_type,' not supported'
+        call endrun(msg=errMsg(__FILE__, __LINE__))
+#endif 
      end if
 
   end subroutine create_scale_l2g_lookup_gpu
@@ -2213,8 +2175,8 @@ end subroutine p2c_1d_filter_parallel
        end if
     end do
     if (found) then
-       !#py write(iulog,*)'t2g_1d error: sumwt is greater than 1.0 at g= ',index
-       !#py !#py call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
+       write(iulog,*)'t2g_1d error: sumwt is greater than 1.0 at g= ',index
+       call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
     end if
 
   end subroutine t2g_1d
@@ -2267,8 +2229,8 @@ end subroutine p2c_1d_filter_parallel
           end if
        end do
        if (found) then
-          !#py write(iulog,*)'t2g_2d error: sumwt is greater than 1.0 at g= ',index,' lev= ',j
-          !#py !#py call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
+          write(iulog,*)'t2g_2d error: sumwt is greater than 1.0 at g= ',index,' lev= ',j
+          call endrun(decomp_index=index, elmlevel=nameg, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
@@ -2427,8 +2389,8 @@ end subroutine p2c_1d_filter_parallel
           end if
         end do
       else
-        !#py write(iulog,*) 'error: scale type ',c2l_scale_type,' not supported'
-        !#py !#py call endrun(msg=errMsg(__FILE__, __LINE__))
+        write(iulog,*) 'error: scale type ',c2l_scale_type,' not supported'
+        call endrun(msg=errMsg(__FILE__, __LINE__))
       end if
 
     end subroutine create_scale_c2l
@@ -2489,144 +2451,5 @@ end subroutine p2c_1d_filter_parallel
 
       end subroutine create_scale_c2l_gpu
 
-       subroutine initialize_scale_l2g_lookup()
-         ! DESCRIPTION: 
-         ! create module copy of scale_l2g_lookup to avoid creating it for
-         ! every subgridAve call. 
-         !
-         use landunit_varcon, only : istsoil, istcrop, istice, istice_mec, istdlak
-         use landunit_varcon, only : isturb_MIN, isturb_MAX, max_lunit
-         
-         implicit none 
-
-         integer, parameter :: num_scale_types = 6 ! unity, natveg, veg, ice, nonurb, lake
-         integer :: itype, lunit 
-
-         allocate(main_scale_l2g_lookup(num_scale_types, max_lunit))
-
-         !itype = unity 
-         !!!$acc parallel loop independent gang vector default(present) 
-         do lunit = 1,max_lunit
-            main_scale_l2g_lookup(unity,lunit) = 1.0_r8
-         end do 
-
-         !itype = natveg
-         !!!$acc parallel loop independent gang vector default(present) 
-         do lunit = 1,max_lunit
-            if(lunit == istsoil) then 
-               main_scale_l2g_lookup(natveg,lunit) = 1.0_r8
-            else 
-               main_scale_l2g_lookup(natveg,lunit) = spval
-            end if 
-         end do 
-
-         !itype = veg 
-         !!!$acc parallel loop independent gang vector default(present) 
-         do lunit = 1,max_lunit
-            if(lunit == istsoil .or. lunit == istcrop ) then 
-               main_scale_l2g_lookup(veg,lunit) = 1.0_r8
-            else 
-               main_scale_l2g_lookup(veg,lunit) = spval
-            end if 
-         end do 
-         
-         !itype = ice 
-         !!!$acc parallel loop independent gang vector default(present) 
-         do lunit = 1,max_lunit
-            if(lunit == istice .or. lunit == istice_mec ) then 
-               main_scale_l2g_lookup(ice,lunit) = 1.0_r8
-            else 
-               main_scale_l2g_lookup(ice,lunit) = spval
-            end if 
-         end do 
-
-         !itype = nonurb
-         !!$acc parallel loop independent gang vector default(present) 
-         do lunit = 1,max_lunit
-            main_scale_l2g_lookup(ice,lunit) = 1.0_r8
-            if(lunit >= isturb_MIN .and. lunit <= isturb_MAX) then  
-               main_scale_l2g_lookup(ice,lunit) = spval
-            end if 
-         end do 
-
-         !itype = lake
-         !!$acc parallel loop independent gang vector default(present) 
-         do lunit = 1,max_lunit
-            if(lunit == istdlak) then 
-               main_scale_l2g_lookup(ice,lunit) = 1.0_r8
-            else 
-               main_scale_l2g_lookup(ice,lunit) = spval
-            end if 
-         end do 
-      
-         !$acc update device(main_scale_l2g_lookup(:,:))  
-
-       end subroutine initialize_scale_l2g_lookup
-
-       subroutine initialize_scale_c2l(bounds)
-         ! Description:
-         ! intialize and create scale_c2l to avoid having to calculate it 
-         ! every time a c2g or similar routine is called. 
-         ! May have to be called again if lun_pp%canyon_hwr is modified.
-         !
-         ! Note: Could save memory by just allocating over landunits?
-         ! Input variables: 
-         !
-         type(bounds_type), intent(in) :: bounds ! processor level bounds!
-         ! Local Variables
-         integer :: c, l, begc,endc 
-         integer, parameter :: num_scale_types = 3 ! unity, urbanf, urbans 
-
-         begc = bounds%begc
-         endc = bounds%endc 
-         ! allocate memory :
-         allocate(main_scale_c2l(begc:endc,num_scale_types))
-         
-         ! c2l_scale_type == unity
-        !!! !$acc parallel loop independent gang vector default(present) 
-         do c = begc,endc
-            main_scale_c2l(c,unity) = 1.0_r8
-         end do
-         
-         !c2l_scale_type == urbanf
-         !!!$acc parallel loop independent gang vector default(present) 
-         do c = begc,endc
-            l = col_pp%landunit(c)
-            if (lun_pp%urbpoi(l)) then
-               if (col_pp%itype(c) == icol_sunwall) then
-                  main_scale_c2l(c,urbanf) = 3.0 * lun_pp%canyon_hwr(l)
-               else if (col_pp%itype(c) == icol_shadewall) then
-                  main_scale_c2l(c,urbanf) = 3.0 * lun_pp%canyon_hwr(l)
-               else if (col_pp%itype(c) == icol_road_perv .or. col_pp%itype(c) == icol_road_imperv) then
-                  main_scale_c2l(c,urbanf) = 3.0_r8
-               else if (col_pp%itype(c) == icol_roof) then
-                  main_scale_c2l(c,urbanf) = 1.0_r8
-               end if
-            else
-               main_scale_c2l(c,urbanf) = 1.0_r8
-            end if
-         end do
-         
-           ! c2l_scale_type == urbans 
-         !!!$acc parallel loop independent gang vector default(present) 
-         do c = begc, endc
-           l = col_pp%landunit(c)
-           if (lun_pp%urbpoi(l)) then
-             if (col_pp%itype(c) == icol_sunwall) then
-               main_scale_c2l(c,urbans) = (3.0 * lun_pp%canyon_hwr(l)) / (2.*lun_pp%canyon_hwr(l) + 1.)
-             else if (col_pp%itype(c) == icol_shadewall) then
-               main_scale_c2l(c,urbans) = (3.0 * lun_pp%canyon_hwr(l)) / (2.*lun_pp%canyon_hwr(l) + 1.)
-             else if (col_pp%itype(c) == icol_road_perv .or. col_pp%itype(c) == icol_road_imperv) then
-               main_scale_c2l(c,urbans) = 3.0 / (2.*lun_pp%canyon_hwr(l) + 1.)
-             else if (col_pp%itype(c) == icol_roof) then
-               main_scale_c2l(c,urbans) = 1.0_r8
-             end if
-           else
-            main_scale_c2l(c,urbans) = 1.0_r8
-           end if
-         end do
-        
-         !$acc update device(main_scale_c2l(:,:)) 
-       end subroutine initialize_scale_c2l
-       
+
 end module subgridAveMod
diff --git a/components/elm/src/main/subgridRestMod.F90 b/components/elm/src/main/subgridRestMod.F90
index d2d2be3112..eb49daaf3a 100644
--- a/components/elm/src/main/subgridRestMod.F90
+++ b/components/elm/src/main/subgridRestMod.F90
@@ -1,6 +1,6 @@
 module subgridRestMod
 
-! #include "shr_assert.h"
+#include "shr_assert.h"
 
   !------------------------------------------------------------------------
   ! !USES:
@@ -142,309 +142,309 @@ contains
 
     deallocate(rgarr,igarr)
     
-!     !------------------------------------------------------------------
-!     ! Write topounit info
-!     !------------------------------------------------------------------
-
-!     allocate(rtarr(bounds%begt:bounds%endt), itarr(bounds%begt:bounds%endt))
-
-!     do t=bounds%begt,bounds%endt
-!        rtarr(t) = grc_pp%londeg(top_pp%gridcell(t))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='topo1d_lon', xtype=ncd_double,  &
-!          dim1name='topounit',                                                      &
-!          long_name='topounit longitude', units='degrees_east',                     &
-!          interpinic_flag='skip', readvar=readvar, data=rtarr)
+    !------------------------------------------------------------------
+    ! Write topounit info
+    !------------------------------------------------------------------
+
+    allocate(rtarr(bounds%begt:bounds%endt), itarr(bounds%begt:bounds%endt))
+
+    do t=bounds%begt,bounds%endt
+       rtarr(t) = grc_pp%londeg(top_pp%gridcell(t))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='topo1d_lon', xtype=ncd_double,  &
+         dim1name='topounit',                                                      &
+         long_name='topounit longitude', units='degrees_east',                     &
+         interpinic_flag='skip', readvar=readvar, data=rtarr)
  
-!     do t=bounds%begt,bounds%endt
-!        rtarr(t) = grc_pp%latdeg(top_pp%gridcell(t))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='topo1d_lat', xtype=ncd_double,  &
-!          dim1name='topounit',                                                      &
-!          long_name='topounit latitude', units='degrees_north',                     &
-!          interpinic_flag='skip', readvar=readvar, data=rtarr)
-
-!     do t=bounds%begt,bounds%endt
-!        itarr(t) = mod(ldecomp%gdc2glo(top_pp%gridcell(t))-1,ldomain%ni) + 1
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='topo1d_ixy', xtype=ncd_int,     &
-!          dim1name='topounit',                                                      &
-!          long_name='2d longitude index of corresponding topounit',                 &
-!          interpinic_flag='skip', readvar=readvar, data=itarr)
-
-!      do t=bounds%begt,bounds%endt
-!         itarr(t) = (ldecomp%gdc2glo(top_pp%gridcell(t))-1)/ldomain%ni + 1
-!      enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='topo1d_jxy', xtype=ncd_int,     &
-!          dim1name='topounit',                                                      &
-!          long_name='2d latitude index of corresponding topounit',                  &
-!          interpinic_flag='skip', readvar=readvar, data=itarr)
-
-!     itarr = GetGlobalIndexArray(top_pp%gridcell(bounds%begt:bounds%endt), bounds%begt, bounds%endt, elmlevel=nameg)
-!     call restartvar(ncid=ncid, flag=flag, varname='topo1d_gridcell_index', xtype=ncd_int, &
-!          dim1name='topounit',                                                             &
-!          long_name='gridcell index of corresponding topounit',                            &
-!          interpinic_flag='skip', readvar=readvar, data=itarr)
-
-!     deallocate(rtarr, itarr)
-
-!     !------------------------------------------------------------------
-!     ! Write landunit info
-!     !------------------------------------------------------------------
-
-!     allocate(rlarr(bounds%begl:bounds%endl), ilarr(bounds%begl:bounds%endl))
-
-!     do l=bounds%begl,bounds%endl
-!        rlarr(l) = grc_pp%londeg(lun_pp%gridcell(l))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='land1d_lon', xtype=ncd_double,  &
-!          dim1name='landunit',                                                      &
-!          long_name='landunit longitude', units='degrees_east',                     &
-!          interpinic_flag='skip', readvar=readvar, data=rlarr)
+    do t=bounds%begt,bounds%endt
+       rtarr(t) = grc_pp%latdeg(top_pp%gridcell(t))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='topo1d_lat', xtype=ncd_double,  &
+         dim1name='topounit',                                                      &
+         long_name='topounit latitude', units='degrees_north',                     &
+         interpinic_flag='skip', readvar=readvar, data=rtarr)
+
+    do t=bounds%begt,bounds%endt
+       itarr(t) = mod(ldecomp%gdc2glo(top_pp%gridcell(t))-1,ldomain%ni) + 1
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='topo1d_ixy', xtype=ncd_int,     &
+         dim1name='topounit',                                                      &
+         long_name='2d longitude index of corresponding topounit',                 &
+         interpinic_flag='skip', readvar=readvar, data=itarr)
+
+     do t=bounds%begt,bounds%endt
+        itarr(t) = (ldecomp%gdc2glo(top_pp%gridcell(t))-1)/ldomain%ni + 1
+     enddo
+    call restartvar(ncid=ncid, flag=flag, varname='topo1d_jxy', xtype=ncd_int,     &
+         dim1name='topounit',                                                      &
+         long_name='2d latitude index of corresponding topounit',                  &
+         interpinic_flag='skip', readvar=readvar, data=itarr)
+
+    itarr = GetGlobalIndexArray(top_pp%gridcell(bounds%begt:bounds%endt), bounds%begt, bounds%endt, elmlevel=nameg)
+    call restartvar(ncid=ncid, flag=flag, varname='topo1d_gridcell_index', xtype=ncd_int, &
+         dim1name='topounit',                                                             &
+         long_name='gridcell index of corresponding topounit',                            &
+         interpinic_flag='skip', readvar=readvar, data=itarr)
+
+    deallocate(rtarr, itarr)
+
+    !------------------------------------------------------------------
+    ! Write landunit info
+    !------------------------------------------------------------------
+
+    allocate(rlarr(bounds%begl:bounds%endl), ilarr(bounds%begl:bounds%endl))
+
+    do l=bounds%begl,bounds%endl
+       rlarr(l) = grc_pp%londeg(lun_pp%gridcell(l))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='land1d_lon', xtype=ncd_double,  &
+         dim1name='landunit',                                                      &
+         long_name='landunit longitude', units='degrees_east',                     &
+         interpinic_flag='skip', readvar=readvar, data=rlarr)
  
-!     do l=bounds%begl,bounds%endl
-!        rlarr(l) = grc_pp%latdeg(lun_pp%gridcell(l))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='land1d_lat', xtype=ncd_double,  &
-!          dim1name='landunit',                                                      &
-!          long_name='landunit latitude', units='degrees_north',                     &
-!          interpinic_flag='skip', readvar=readvar, data=rlarr)
-
-!     do l=bounds%begl,bounds%endl
-!        ilarr(l) = mod(ldecomp%gdc2glo(lun_pp%gridcell(l))-1,ldomain%ni) + 1
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='land1d_ixy', xtype=ncd_int,     &
-!          dim1name='landunit',                                                      &
-!          long_name='2d longitude index of corresponding landunit',                 &
-!          interpinic_flag='skip', readvar=readvar, data=ilarr)
-
-!      do l=bounds%begl,bounds%endl
-!         ilarr(l) = (ldecomp%gdc2glo(lun_pp%gridcell(l))-1)/ldomain%ni + 1
-!      enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='land1d_jxy', xtype=ncd_int,     &
-!          dim1name='landunit',                                                      &
-!          long_name='2d latitude index of corresponding landunit',                  &
-!          interpinic_flag='skip', readvar=readvar, data=ilarr)
-
-!     ilarr = GetGlobalIndexArray(lun_pp%gridcell(bounds%begl:bounds%endl), bounds%begl, bounds%endl, elmlevel=nameg)
-!     call restartvar(ncid=ncid, flag=flag, varname='land1d_gridcell_index', xtype=ncd_int, &
-!          dim1name='landunit',                                                             &
-!          long_name='gridcell index of corresponding landunit',                            &
-!          interpinic_flag='skip', readvar=readvar, data=ilarr)
+    do l=bounds%begl,bounds%endl
+       rlarr(l) = grc_pp%latdeg(lun_pp%gridcell(l))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='land1d_lat', xtype=ncd_double,  &
+         dim1name='landunit',                                                      &
+         long_name='landunit latitude', units='degrees_north',                     &
+         interpinic_flag='skip', readvar=readvar, data=rlarr)
+
+    do l=bounds%begl,bounds%endl
+       ilarr(l) = mod(ldecomp%gdc2glo(lun_pp%gridcell(l))-1,ldomain%ni) + 1
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='land1d_ixy', xtype=ncd_int,     &
+         dim1name='landunit',                                                      &
+         long_name='2d longitude index of corresponding landunit',                 &
+         interpinic_flag='skip', readvar=readvar, data=ilarr)
+
+     do l=bounds%begl,bounds%endl
+        ilarr(l) = (ldecomp%gdc2glo(lun_pp%gridcell(l))-1)/ldomain%ni + 1
+     enddo
+    call restartvar(ncid=ncid, flag=flag, varname='land1d_jxy', xtype=ncd_int,     &
+         dim1name='landunit',                                                      &
+         long_name='2d latitude index of corresponding landunit',                  &
+         interpinic_flag='skip', readvar=readvar, data=ilarr)
+
+    ilarr = GetGlobalIndexArray(lun_pp%gridcell(bounds%begl:bounds%endl), bounds%begl, bounds%endl, elmlevel=nameg)
+    call restartvar(ncid=ncid, flag=flag, varname='land1d_gridcell_index', xtype=ncd_int, &
+         dim1name='landunit',                                                             &
+         long_name='gridcell index of corresponding landunit',                            &
+         interpinic_flag='skip', readvar=readvar, data=ilarr)
     
-!     ilarr = GetGlobalIndexArray(lun_pp%topounit(bounds%begl:bounds%endl), bounds%begl, bounds%endl, elmlevel=namet)
-!     call restartvar(ncid=ncid, flag=flag, varname='land1d_topounit_index', xtype=ncd_int, &
-!          dim1name='landunit',                                                             &
-!          long_name='topounit index of corresponding landunit',                            &
-!          interpinic_flag='skip', readvar=readvar, data=ilarr)
-
-!     call restartvar(ncid=ncid, flag=flag, varname='land1d_ityplun', xtype=ncd_int, &
-!          dim1name='landunit',                                                      &
-!          long_name='landunit type (see global attributes)', units=' ',             &
-!          interpinic_flag='skip', readvar=readvar, data=lun_pp%itype)
-
-!     do l=bounds%begl,bounds%endl
-!        if (lun_pp%active(l)) then
-!           ilarr(l) = 1
-!        else
-!           ilarr(l) = 0
-!        end if
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='land1d_active', xtype=ncd_int,  &
-!          dim1name='landunit',                                                      &
-!          long_name='landunit active flag (1=active, 0=inactive)',                  &
-!          interpinic_flag='skip', readvar=readvar, data=ilarr)
-
-!     deallocate(rlarr, ilarr)
-
-!     !------------------------------------------------------------------
-!     ! Write column info
-!     !------------------------------------------------------------------
-
-!     allocate(rcarr(bounds%begc:bounds%endc), icarr(bounds%begc:bounds%endc))
-
-!     do c= bounds%begc, bounds%endc
-!        rcarr(c) = grc_pp%londeg(col_pp%gridcell(c))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_lon', xtype=ncd_double,   &
-!          dim1name='column',                                                         &
-!          long_name='column longitude', units='degrees_east',                        &
-!          interpinic_flag='skip', readvar=readvar, data=rcarr)
-
-!     do c= bounds%begc, bounds%endc
-!        rcarr(c) = grc_pp%latdeg(col_pp%gridcell(c))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_lat', xtype=ncd_double,   &
-!          dim1name='column',                                                         &
-!          long_name='column latitude', units='degrees_north',                        &
-!          interpinic_flag='skip', readvar=readvar, data=rcarr)
-
-!     do c= bounds%begc, bounds%endc
-!        icarr(c) = mod(ldecomp%gdc2glo(col_pp%gridcell(c))-1,ldomain%ni) + 1
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_ixy', xtype=ncd_int,      &
-!          dim1name='column',                                                         &
-!          long_name='2d longitude index of corresponding column', units=' ',         &
-!          interpinic_flag='skip', readvar=readvar, data=icarr)
-
-!     do c= bounds%begc, bounds%endc
-!        icarr(c) = (ldecomp%gdc2glo(col_pp%gridcell(c))-1)/ldomain%ni + 1
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_jxy', xtype=ncd_int,      &
-!          dim1name='column',                                                         &
-!          long_name='2d latitude index of corresponding column', units=' ',          &
-!          interpinic_flag='skip', readvar=readvar, data=icarr)
-
-!     icarr = GetGlobalIndexArray(col_pp%gridcell(bounds%begc:bounds%endc), bounds%begc, bounds%endc, elmlevel=nameg)
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_gridcell_index', xtype=ncd_int, &
-!          dim1name='column',                                                               &
-!          long_name='gridcell index of corresponding column',                              &
-!          interpinic_flag='skip', readvar=readvar, data=icarr)
+    ilarr = GetGlobalIndexArray(lun_pp%topounit(bounds%begl:bounds%endl), bounds%begl, bounds%endl, elmlevel=namet)
+    call restartvar(ncid=ncid, flag=flag, varname='land1d_topounit_index', xtype=ncd_int, &
+         dim1name='landunit',                                                             &
+         long_name='topounit index of corresponding landunit',                            &
+         interpinic_flag='skip', readvar=readvar, data=ilarr)
+
+    call restartvar(ncid=ncid, flag=flag, varname='land1d_ityplun', xtype=ncd_int, &
+         dim1name='landunit',                                                      &
+         long_name='landunit type (see global attributes)', units=' ',             &
+         interpinic_flag='skip', readvar=readvar, data=lun_pp%itype)
+
+    do l=bounds%begl,bounds%endl
+       if (lun_pp%active(l)) then
+          ilarr(l) = 1
+       else
+          ilarr(l) = 0
+       end if
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='land1d_active', xtype=ncd_int,  &
+         dim1name='landunit',                                                      &
+         long_name='landunit active flag (1=active, 0=inactive)',                  &
+         interpinic_flag='skip', readvar=readvar, data=ilarr)
+
+    deallocate(rlarr, ilarr)
+
+    !------------------------------------------------------------------
+    ! Write column info
+    !------------------------------------------------------------------
+
+    allocate(rcarr(bounds%begc:bounds%endc), icarr(bounds%begc:bounds%endc))
+
+    do c= bounds%begc, bounds%endc
+       rcarr(c) = grc_pp%londeg(col_pp%gridcell(c))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_lon', xtype=ncd_double,   &
+         dim1name='column',                                                         &
+         long_name='column longitude', units='degrees_east',                        &
+         interpinic_flag='skip', readvar=readvar, data=rcarr)
+
+    do c= bounds%begc, bounds%endc
+       rcarr(c) = grc_pp%latdeg(col_pp%gridcell(c))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_lat', xtype=ncd_double,   &
+         dim1name='column',                                                         &
+         long_name='column latitude', units='degrees_north',                        &
+         interpinic_flag='skip', readvar=readvar, data=rcarr)
+
+    do c= bounds%begc, bounds%endc
+       icarr(c) = mod(ldecomp%gdc2glo(col_pp%gridcell(c))-1,ldomain%ni) + 1
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_ixy', xtype=ncd_int,      &
+         dim1name='column',                                                         &
+         long_name='2d longitude index of corresponding column', units=' ',         &
+         interpinic_flag='skip', readvar=readvar, data=icarr)
+
+    do c= bounds%begc, bounds%endc
+       icarr(c) = (ldecomp%gdc2glo(col_pp%gridcell(c))-1)/ldomain%ni + 1
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_jxy', xtype=ncd_int,      &
+         dim1name='column',                                                         &
+         long_name='2d latitude index of corresponding column', units=' ',          &
+         interpinic_flag='skip', readvar=readvar, data=icarr)
+
+    icarr = GetGlobalIndexArray(col_pp%gridcell(bounds%begc:bounds%endc), bounds%begc, bounds%endc, elmlevel=nameg)
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_gridcell_index', xtype=ncd_int, &
+         dim1name='column',                                                               &
+         long_name='gridcell index of corresponding column',                              &
+         interpinic_flag='skip', readvar=readvar, data=icarr)
     
-!     icarr = GetGlobalIndexArray(col_pp%topounit(bounds%begc:bounds%endc), bounds%begc, bounds%endc, elmlevel=namet)
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_topounit_index', xtype=ncd_int, &
-!          dim1name='column',                                                               &
-!          long_name='topounit index of corresponding column',                              &
-!          interpinic_flag='skip', readvar=readvar, data=icarr)
-
-!     icarr = GetGlobalIndexArray(col_pp%landunit(bounds%begc:bounds%endc), bounds%begc, bounds%endc, elmlevel=namel)
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_landunit_index', xtype=ncd_int, &
-!          dim1name='column',                                                               &
-!          long_name='landunit index of corresponding column',                              &
-!          interpinic_flag='skip', readvar=readvar, data=icarr)
-
-!     do c= bounds%begc, bounds%endc
-!        icarr(c) = lun_pp%itype(col_pp%landunit(c))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_ityplun', xtype=ncd_int,  &
-!          dim1name='column',                                                         &
-!          long_name='column landunit type (see global attributes)', units=' ',       &
-!          interpinic_flag='skip', readvar=readvar, data=icarr)
-
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_ityp', xtype=ncd_int,     &
-!          dim1name='column',                                                         &
-!          long_name='column type (see global attributes)', units=' ',                &
-!          interpinic_flag='skip', readvar=readvar, data=col_pp%itype)
-
-!     do c=bounds%begc,bounds%endc
-!        if (col_pp%active(c)) then 
-!           icarr(c) = 1
-!        else
-!           icarr(c) = 0
-!        end if
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='cols1d_active', xtype=ncd_int,   &
-!          dim1name='column',                                                         &
-!          long_name='column active flag (1=active, 0=inactive)', units=' ',          &
-!          interpinic_flag='skip', readvar=readvar, data=icarr)
-
-!     deallocate(rcarr, icarr)
-
-!     !------------------------------------------------------------------
-!     ! Write pft info
-!     !------------------------------------------------------------------
-
-!     allocate(rparr(bounds%begp:bounds%endp), iparr(bounds%begp:bounds%endp))
-
-!     do p=bounds%begp,bounds%endp
-!        rparr(p) = grc_pp%londeg(veg_pp%gridcell(p))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_lon', xtype=ncd_double, &
-!          dim1name='pft',                                                          &
-!          long_name='pft longitude', units='degrees_east',                         &
-!          interpinic_flag='skip', readvar=readvar, data=rparr)
-
-!     do p=bounds%begp,bounds%endp
-!        rparr(p) = grc_pp%latdeg(veg_pp%gridcell(p))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_lat', xtype=ncd_double, &
-!          dim1name='pft',                                                          &
-!          long_name='pft latitude', units='degrees_north',                         &
-!          interpinic_flag='skip', readvar=readvar, data=rparr)
-
-!     do p=bounds%begp,bounds%endp
-!        iparr(p) = mod(ldecomp%gdc2glo(veg_pp%gridcell(p))-1,ldomain%ni) + 1
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_ixy', xtype=ncd_int, &
-!          dim1name='pft',                                                       &
-!          long_name='2d longitude index of corresponding pft', units='',        &
-!          interpinic_flag='skip', readvar=readvar, data=iparr)
-
-!     do p=bounds%begp,bounds%endp
-!        iparr(p) = (ldecomp%gdc2glo(veg_pp%gridcell(p))-1)/ldomain%ni + 1
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_jxy', xtype=ncd_int, &
-!          dim1name='pft',                                                       &
-!          long_name='2d latitude index of corresponding pft', units='',         &
-!          interpinic_flag='skip', readvar=readvar, data=iparr)
-
-!     iparr = GetGlobalIndexArray(veg_pp%gridcell(bounds%begp:bounds%endp), bounds%begp, bounds%endp, elmlevel=nameg)
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_gridcell_index', xtype=ncd_int, &
-!          dim1name='pft',                                                                  &
-!          long_name='gridcell index of corresponding pft',                                 &
-!          interpinic_flag='skip', readvar=readvar, data=iparr)
+    icarr = GetGlobalIndexArray(col_pp%topounit(bounds%begc:bounds%endc), bounds%begc, bounds%endc, elmlevel=namet)
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_topounit_index', xtype=ncd_int, &
+         dim1name='column',                                                               &
+         long_name='topounit index of corresponding column',                              &
+         interpinic_flag='skip', readvar=readvar, data=icarr)
+
+    icarr = GetGlobalIndexArray(col_pp%landunit(bounds%begc:bounds%endc), bounds%begc, bounds%endc, elmlevel=namel)
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_landunit_index', xtype=ncd_int, &
+         dim1name='column',                                                               &
+         long_name='landunit index of corresponding column',                              &
+         interpinic_flag='skip', readvar=readvar, data=icarr)
+
+    do c= bounds%begc, bounds%endc
+       icarr(c) = lun_pp%itype(col_pp%landunit(c))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_ityplun', xtype=ncd_int,  &
+         dim1name='column',                                                         &
+         long_name='column landunit type (see global attributes)', units=' ',       &
+         interpinic_flag='skip', readvar=readvar, data=icarr)
+
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_ityp', xtype=ncd_int,     &
+         dim1name='column',                                                         &
+         long_name='column type (see global attributes)', units=' ',                &
+         interpinic_flag='skip', readvar=readvar, data=col_pp%itype)
+
+    do c=bounds%begc,bounds%endc
+       if (col_pp%active(c)) then 
+          icarr(c) = 1
+       else
+          icarr(c) = 0
+       end if
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='cols1d_active', xtype=ncd_int,   &
+         dim1name='column',                                                         &
+         long_name='column active flag (1=active, 0=inactive)', units=' ',          &
+         interpinic_flag='skip', readvar=readvar, data=icarr)
+
+    deallocate(rcarr, icarr)
+
+    !------------------------------------------------------------------
+    ! Write pft info
+    !------------------------------------------------------------------
+
+    allocate(rparr(bounds%begp:bounds%endp), iparr(bounds%begp:bounds%endp))
+
+    do p=bounds%begp,bounds%endp
+       rparr(p) = grc_pp%londeg(veg_pp%gridcell(p))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_lon', xtype=ncd_double, &
+         dim1name='pft',                                                          &
+         long_name='pft longitude', units='degrees_east',                         &
+         interpinic_flag='skip', readvar=readvar, data=rparr)
+
+    do p=bounds%begp,bounds%endp
+       rparr(p) = grc_pp%latdeg(veg_pp%gridcell(p))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_lat', xtype=ncd_double, &
+         dim1name='pft',                                                          &
+         long_name='pft latitude', units='degrees_north',                         &
+         interpinic_flag='skip', readvar=readvar, data=rparr)
+
+    do p=bounds%begp,bounds%endp
+       iparr(p) = mod(ldecomp%gdc2glo(veg_pp%gridcell(p))-1,ldomain%ni) + 1
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_ixy', xtype=ncd_int, &
+         dim1name='pft',                                                       &
+         long_name='2d longitude index of corresponding pft', units='',        &
+         interpinic_flag='skip', readvar=readvar, data=iparr)
+
+    do p=bounds%begp,bounds%endp
+       iparr(p) = (ldecomp%gdc2glo(veg_pp%gridcell(p))-1)/ldomain%ni + 1
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_jxy', xtype=ncd_int, &
+         dim1name='pft',                                                       &
+         long_name='2d latitude index of corresponding pft', units='',         &
+         interpinic_flag='skip', readvar=readvar, data=iparr)
+
+    iparr = GetGlobalIndexArray(veg_pp%gridcell(bounds%begp:bounds%endp), bounds%begp, bounds%endp, elmlevel=nameg)
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_gridcell_index', xtype=ncd_int, &
+         dim1name='pft',                                                                  &
+         long_name='gridcell index of corresponding pft',                                 &
+         interpinic_flag='skip', readvar=readvar, data=iparr)
     
-!     iparr = GetGlobalIndexArray(veg_pp%topounit(bounds%begp:bounds%endp), bounds%begp, bounds%endp, elmlevel=namet)
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_topounit_index', xtype=ncd_int, &
-!          dim1name='pft',                                                                  &
-!          long_name='topounit index of corresponding pft',                                 &
-!          interpinic_flag='skip', readvar=readvar, data=iparr)
-
-!     iparr = GetGlobalIndexArray(veg_pp%landunit(bounds%begp:bounds%endp), bounds%begp, bounds%endp, elmlevel=namel)
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_landunit_index', xtype=ncd_int, &
-!          dim1name='pft',                                                                  &
-!          long_name='landunit index of corresponding pft',                                 &
-!          interpinic_flag='skip', readvar=readvar, data=iparr)
-
-!     iparr = GetGlobalIndexArray(veg_pp%column(bounds%begp:bounds%endp), bounds%begp, bounds%endp, elmlevel=namec)
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_column_index', xtype=ncd_int,   &
-!          dim1name='pft',                                                                  &
-!          long_name='column index of corresponding pft',                                   &
-!          interpinic_flag='skip', readvar=readvar, data=iparr)
-
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_itypveg', xtype=ncd_int,  &
-!          dim1name='pft',                                                            &
-!          long_name='pft vegetation type', units='',                                 &
-!          interpinic_flag='skip', readvar=readvar, data=veg_pp%itype)
-
-!     do p=bounds%begp,bounds%endp
-!        iparr(p) = col_pp%itype(veg_pp%column(p))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_itypcol', xtype=ncd_int, &
-!          dim1name='pft',                                                           &
-!          long_name='pft column type (see global attributes)', units='',          &
-!          interpinic_flag='skip', readvar=readvar, data=iparr)
-
-!     do p=bounds%begp,bounds%endp
-!        iparr(p) = lun_pp%itype(veg_pp%landunit(p))
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_ityplun', xtype=ncd_int, &
-!          dim1name='pft',                                                           &
-!          long_name='pft landunit type (see global attributes)', units='',          &
-!          interpinic_flag='skip', readvar=readvar, data=iparr)
-
-!     do p=bounds%begp,bounds%endp
-!        if (veg_pp%active(p)) then
-!           iparr(p) = 1
-!        else
-!           iparr(p) = 0
-!        end if
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_active', xtype=ncd_int, &
-!          dim1name='pft',                                                          &
-!          long_name='pft active flag (1=active, 0=inactive)', units='',            &
-!          interpinic_flag='skip', readvar=readvar, data=iparr)
-
-!     do p=bounds%begp,bounds%endp
-!        c = veg_pp%column(p)
-!        rparr(p) = col_pp%glc_topo(c)
-!     enddo
-!     call restartvar(ncid=ncid, flag=flag, varname='pfts1d_topoglc', xtype=ncd_double,   &
-!          dim1name='column',                                                             &
-!          long_name='mean elevation on glacier elevation classes', units='m',            &
-!          interpinic_flag='skip', readvar=readvar, data=rparr)
-
-!     deallocate(rparr, iparr)
+    iparr = GetGlobalIndexArray(veg_pp%topounit(bounds%begp:bounds%endp), bounds%begp, bounds%endp, elmlevel=namet)
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_topounit_index', xtype=ncd_int, &
+         dim1name='pft',                                                                  &
+         long_name='topounit index of corresponding pft',                                 &
+         interpinic_flag='skip', readvar=readvar, data=iparr)
+
+    iparr = GetGlobalIndexArray(veg_pp%landunit(bounds%begp:bounds%endp), bounds%begp, bounds%endp, elmlevel=namel)
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_landunit_index', xtype=ncd_int, &
+         dim1name='pft',                                                                  &
+         long_name='landunit index of corresponding pft',                                 &
+         interpinic_flag='skip', readvar=readvar, data=iparr)
+
+    iparr = GetGlobalIndexArray(veg_pp%column(bounds%begp:bounds%endp), bounds%begp, bounds%endp, elmlevel=namec)
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_column_index', xtype=ncd_int,   &
+         dim1name='pft',                                                                  &
+         long_name='column index of corresponding pft',                                   &
+         interpinic_flag='skip', readvar=readvar, data=iparr)
+
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_itypveg', xtype=ncd_int,  &
+         dim1name='pft',                                                            &
+         long_name='pft vegetation type', units='',                                 &
+         interpinic_flag='skip', readvar=readvar, data=veg_pp%itype)
+
+    do p=bounds%begp,bounds%endp
+       iparr(p) = col_pp%itype(veg_pp%column(p))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_itypcol', xtype=ncd_int, &
+         dim1name='pft',                                                           &
+         long_name='pft column type (see global attributes)', units='',          &
+         interpinic_flag='skip', readvar=readvar, data=iparr)
+
+    do p=bounds%begp,bounds%endp
+       iparr(p) = lun_pp%itype(veg_pp%landunit(p))
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_ityplun', xtype=ncd_int, &
+         dim1name='pft',                                                           &
+         long_name='pft landunit type (see global attributes)', units='',          &
+         interpinic_flag='skip', readvar=readvar, data=iparr)
+
+    do p=bounds%begp,bounds%endp
+       if (veg_pp%active(p)) then
+          iparr(p) = 1
+       else
+          iparr(p) = 0
+       end if
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_active', xtype=ncd_int, &
+         dim1name='pft',                                                          &
+         long_name='pft active flag (1=active, 0=inactive)', units='',            &
+         interpinic_flag='skip', readvar=readvar, data=iparr)
+
+    do p=bounds%begp,bounds%endp
+       c = veg_pp%column(p)
+       rparr(p) = col_pp%glc_topo(c)
+    enddo
+    call restartvar(ncid=ncid, flag=flag, varname='pfts1d_topoglc', xtype=ncd_double,   &
+         dim1name='column',                                                             &
+         long_name='mean elevation on glacier elevation classes', units='m',            &
+         interpinic_flag='skip', readvar=readvar, data=rparr)
+
+    deallocate(rparr, iparr)
 
   end subroutine subgridRest_write_only
 
@@ -575,7 +575,7 @@ contains
     character(len=*), parameter :: subname = 'save_old_weights'
     !-----------------------------------------------------------------------
     
-!     SHR_ASSERT(bounds%level == BOUNDS_LEVEL_PROC, subname//' ERROR: expect proc-level bounds')
+    SHR_ASSERT(bounds%level == BOUNDS_LEVEL_PROC, subname//' ERROR: expect proc-level bounds')
 
     allocate(pft_wtlunit_before_rest_read(bounds%begp:bounds%endp))
     pft_wtlunit_before_rest_read(bounds%begp:bounds%endp) = veg_pp%wtlunit(bounds%begp:bounds%endp)
diff --git a/components/elm/src/main/subgridWeightsMod.F90 b/components/elm/src/main/subgridWeightsMod.F90
index b5f89c98a8..6c7ef1f847 100644
--- a/components/elm/src/main/subgridWeightsMod.F90
+++ b/components/elm/src/main/subgridWeightsMod.F90
@@ -13,14 +13,14 @@ module subgridWeightsMod
   ! Note: in the following, 'active' refers to a pft, column, landunit or grid cell over
   ! which computations are performed, and 'inactive' refers to a pft, column or landunit
   ! where computations are NOT performed (grid cells are always active).
-  !
+  ! 
   ! (1) For all columns, landunits and grid cells, the sum of all subgrid weights of its
   !     children (or grandchildren, etc.) is equal to 1. For example:
   !     - For all columns, the sum of all pft weights on the column equals 1
   !     - For all landunits, the sum of all col weights on the landunit equals 1
   !     - For all grid cells, the sum of all pft weights on the grid cell equals 1
   !     - etc.
-  !
+  ! 
   ! (2) For all ACTIVE columns, landunits and grid cells, the sum of all subgrid weights of
   !     its ACTIVE children (or grandchildren, etc.) is equal to 1. For example:
   !     - For all active columns, the sum of all pft weights on the column equals 1 when
@@ -91,7 +91,6 @@ module subgridWeightsMod
   ! !USES:
   use shr_kind_mod , only : r8 => shr_kind_r8
   use shr_log_mod  , only : errMsg => shr_log_errMsg
-  use shr_sys_mod  , only : shr_sys_flush 
   use abortutils   , only : endrun
   use elm_varctl   , only : iulog, all_active
   use elm_varcon   , only : nameg, namel, namec, namep
@@ -131,9 +130,8 @@ module subgridWeightsMod
      real(r8), pointer :: pct_cft(:,:)       ! % of each crop functional type, as % of landunit [begt:endt,cft_lb:cft_ub]
      real(r8), pointer :: pct_glc_mec(:,:)   ! % of each glacier elevation class, as % of landunit [begt:endt,1:maxpatch_glcmec]
   end type subgrid_weights_diagnostics_type
-
-  type(subgrid_weights_diagnostics_type), public :: subgrid_weights_diagnostics
-  !$acc declare create(subgrid_weights_diagnostics)
+     
+  type(subgrid_weights_diagnostics_type) :: subgrid_weights_diagnostics
 
   !
   ! !PRIVATE MEMBER FUNCTIONS:
@@ -165,10 +163,10 @@ contains
     type(bounds_type), intent(in) :: bounds  ! proc bounds
     !
     ! !LOCAL VARIABLES:
-
+    
     character(len=*), parameter :: subname = 'init_subgrid_weights_mod'
     !-----------------------------------------------------------------------
-
+    
     SHR_ASSERT(bounds%level == BOUNDS_LEVEL_PROC, errMsg(__FILE__, __LINE__))
 
     ! ------------------------------------------------------------------------
@@ -220,14 +218,13 @@ contains
     !
     ! !DESCRIPTION:
     ! Assuming veg_pp%wtcol, col_pp%wtlunit and lun_pp%wttopounit have already been computed, compute
-    ! the "higher-order" weights:
+    ! the "higher-order" weights: 
     ! veg_pp%wtlunit, veg_pp%wttopounit, veg_pp%wtgcell,
     ! col_pp%wttopounit, col_pp%wtgcell, and
     ! lun_pp%wtgcell, for all p, c, and l
     !
     ! !USES:
     !
-    !$acc routine seq
     ! !ARGUMENTS:
     implicit none
     type(bounds_type), intent(in) :: bounds  ! clump bounds
@@ -271,7 +268,6 @@ contains
     ! !USES:
     !
     ! !ARGUMENTS:
-      !$acc routine seq
     implicit none
     type(bounds_type), intent(in) :: bounds  ! bounds
     !
@@ -280,14 +276,14 @@ contains
 
     character(len=*), parameter :: subname = 'set_active'
     !------------------------------------------------------------------------
-   
+
     do l = bounds%begl,bounds%endl
        t = lun_pp%topounit(l)
        lun_pp%active(l) = is_active_l(l)
        if (lun_pp%active(l) .and. .not. lun_pp%itype(l) == istice_mec .and. .not. lun_pp%itype(l) == istsoil .and. .not. top_pp%active(t)) then
-          print *, ' ERROR: active landunit found on inactive topounit', &
+          write(iulog,*) trim(subname),' ERROR: active landunit found on inactive topounit', &
                          'at l = ', l, ', t = ', t
-          stop !call endrun(decomp_index=l, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
+          call endrun(decomp_index=l, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
@@ -295,27 +291,21 @@ contains
        l = col_pp%landunit(c)
        col_pp%active(c) = is_active_c(c)
        if (col_pp%active(c) .and. .not. lun_pp%active(l)) then
-          print *, trim(subname),' ERROR: active column found on inactive landunit', &
+          write(iulog,*) trim(subname),' ERROR: active column found on inactive landunit', &
                          'at c = ', c, ', l = ', l
-          stop !call endrun(decomp_index=c, elmlevel=namec, msg=errMsg(__FILE__, __LINE__))
+          call endrun(decomp_index=c, elmlevel=namec, msg=errMsg(__FILE__, __LINE__))
        end if
     end do
 
     do p = bounds%begp,bounds%endp
        c = veg_pp%column(p)
        veg_pp%active(p) = is_active_p(p)
-       !if (all_active) then
-       !   veg_pp%active(p) = .true.
-       !else
-       !   c =veg_pp%column(p)
-       !   veg_pp%active(p) = .false.
-       !   if (col_pp%active(c) .and. veg_pp%wtcol(p) > 0._r8) veg_pp%active(p) = .true.
-       !end if
        if (veg_pp%active(p) .and. .not. col_pp%active(c)) then
-          print *,' ERROR: active pft found on inactive column', &
+          write(iulog,*) trim(subname),' ERROR: active pft found on inactive column', &
                          'at p = ', p, ', c = ', c
+          call endrun(decomp_index=p, elmlevel=namep, msg=errMsg(__FILE__, __LINE__))
        end if
-     end do
+    end do
 
   end subroutine set_active
 
@@ -324,10 +314,10 @@ contains
     !
     ! !DESCRIPTION:
     ! Determine whether the given landunit is active
-    !$acc routine seq 
+    !
     ! !USES:
     use landunit_varcon, only : istsoil, istice, istice_mec
-    use domainMod , only : ldomain_gpu
+    use domainMod , only : ldomain
     !
     ! !ARGUMENTS:
     implicit none
@@ -367,7 +357,7 @@ contains
        ! PET: 4/25/2018: By keeping the glcmask reference at the gridcell level, this forces
        ! is_active_l = .true. for istice_mec landunits on all topounits for the gridcell.
        !if (lun_pp%itype(l) == istice_mec .and. ldomain%glcmask(g) == 1) is_active_l = .true. ! make sure no active l for inactive topounit TKT
-       if (top_pp%active(t) .and. lun_pp%itype(l) == istice_mec .and. ldomain_gpu%glcmask(g) == 1) is_active_l = .true.
+       if (top_pp%active(t) .and. lun_pp%itype(l) == istice_mec .and. ldomain%glcmask(g) == 1) is_active_l = .true.
 
        ! In general, include a virtual natural vegetation landunit. This aids
        ! initialization of a new landunit; and for runs that are coupled to CISM, this
@@ -395,52 +385,15 @@ contains
 
   end function is_active_l
 
-  !-----------------------------------------------------------------------
-  subroutine is_active_l_gpu(bounds,lun_pp_active)
-    !
-    ! !DESCRIPTION:
-    ! Determine whether the given landunit is active
-   !! !$acc routine seq
-    ! !USES:
-    use landunit_varcon, only : istsoil, istice, istice_mec
-    use domainMod , only : ldomain_gpu
-    !
-    ! !ARGUMENTS:
-    implicit none
-    !
-    ! !LOCAL VARIABLES:
-    type(bounds_type)  , intent(in) :: bounds
-    logical ,intent(inout) :: lun_pp_active(bounds%begl:)
-    integer :: g,t,l  ! grid cell index
-    !------------------------------------------------------------------------
-    do l = bounds%begl, bounds%endl
-      if (all_active) then
-        lun_pp_active(l) = .true.
-
-      else
-        g = lun_pp%gridcell(l)
-        lun_pp_active(l) = .false.
-
-        if (lun_pp%wttopounit(l) > 0) lun_pp_active(l) = .true.
-        if (lun_pp%itype(l) == istice_mec .and. ldomain_gpu%glcmask(g) == 1) lun_pp_active(l) = .true.
-
-        if (lun_pp%itype(l) == istsoil .and. .not. is_topo_all_ltypeX(lun_pp%topounit(l), istice)) then
-            lun_pp_active(l) = .true.
-        end if
-      end if
-    end do
-
-  end subroutine is_active_l_gpu
-
   !-----------------------------------------------------------------------
   logical function is_active_c(c)
     !
     ! !DESCRIPTION:
     ! Determine whether the given column is active
-    !$acc routine seq 
+    !
     ! !USES:
     use landunit_varcon, only : istice_mec, isturb_MIN, isturb_MAX
-    use domainMod , only : ldomain_gpu
+    use domainMod , only : ldomain
     !
     ! !ARGUMENTS:
     implicit none
@@ -477,7 +430,7 @@ contains
        !
        ! Note that we use glcmask rather than icemask here; see comment in is_active_l
        ! for the rationale.
-       if (top_pp%active(t) .and. lun_pp%itype(l) == istice_mec .and. ldomain_gpu%glcmask(g) == 1) is_active_c = .true.
+       if (top_pp%active(t) .and. lun_pp%itype(l) == istice_mec .and. ldomain%glcmask(g) == 1) is_active_c = .true.
 
        ! We don't really need to run over 0-weight urban columns. But because of some
        ! messiness in the urban code (many loops are over the landunit filter, then drill
@@ -492,50 +445,6 @@ contains
 
   end function is_active_c
 
-  !-----------------------------------------------------------------------
-  subroutine is_active_c_gpu(bounds, col_pp_active)
-    !
-    ! !DESCRIPTION:
-    ! Determine whether the given column is active
-    !! !$acc routine seq
-    ! !USES:
-    use landunit_varcon, only : istice_mec, isturb_MIN, isturb_MAX
-    use domainMod , only : ldomain_gpu
-    !
-    ! !ARGUMENTS:
-    implicit none
-    type(bounds_type), intent(in) :: bounds   ! column index
-    logical , intent(inout)  :: col_pp_active(bounds%begc:)
-    !
-    ! !LOCAL VARIABLES:
-    integer :: l  ! landunit index
-    integer :: g,c  ! grid cell index
-    !------------------------------------------------------------------------
-    do c = bounds%begc, bounds%endc
-      if (all_active) then
-        col_pp_active(c) = .true.
-
-      else
-        l =col_pp%landunit(c)
-        g =col_pp%gridcell(c)
-
-        col_pp_active(c) = .false.
-        if (lun_pp%active(l) .and. col_pp%wtlunit(c) > 0._r8) col_pp_active(c) = .true.
-        !
-        !
-        if (lun_pp%itype(l) == istice_mec .and. ldomain_gpu%glcmask(g) == 1) col_pp_active(c) = .true.
-        if (lun_pp%active(l) .and. (lun_pp%itype(l) >= isturb_MIN .and. lun_pp%itype(l) <= isturb_MAX)) then
-            col_pp_active(c) = .true.
-        end if
-      end if
-      if (col_pp_active(c) .and. .not. lun_pp%active(l)) then
-         print *, ' ERROR: active column found on inactive landunit', &
-                        'at c = ', c, ', l = ', l
-      end if
-    end do
-
-  end subroutine is_active_c_gpu
-
   !-----------------------------------------------------------------------
   logical function is_active_p(p)
     !
@@ -543,7 +452,7 @@ contains
     ! Determine whether the given pft is active
     !
     ! !USES:
-    !$acc routine seq 
+    !
     ! !ARGUMENTS:
     implicit none
     integer, intent(in) :: p   ! pft index
@@ -557,7 +466,7 @@ contains
 
     else
        c =veg_pp%column(p)
-
+    
        is_active_p = .false.
 
        ! ------------------------------------------------------------------------
@@ -575,7 +484,6 @@ contains
     !
     ! !DESCRIPTION:
     ! Get the subgrid weight of a given landunit type on a single topographic unit
-    !$acc routine seq
     !
     ! !USES:
     use elm_varcon, only : ispval
@@ -588,9 +496,9 @@ contains
     ! !LOCAL VARIABLES:
     integer :: l ! landunit index
 
-    !character(len=*), parameter :: subname = 'get_landunit_weight'
+    character(len=*), parameter :: subname = 'get_landunit_weight'
     !-----------------------------------------------------------------------
-
+    
     l = top_pp%landunit_indices(ltype, t)
     if (l == ispval) then
        weight = 0._r8
@@ -605,7 +513,6 @@ contains
     !
     ! !DESCRIPTION:
     ! Set the subgrid weight of a given landunit type on a single topographic unit
-    !$acc routine seq
     !
     ! !USES:
     use elm_varcon, only : ispval
@@ -617,7 +524,7 @@ contains
     !
     ! !LOCAL VARIABLES:
     integer :: l ! landunit index
-
+    
     character(len=*), parameter :: subname = 'set_landunit_weight'
     !-----------------------------------------------------------------------
 
@@ -625,13 +532,11 @@ contains
     if (l /= ispval) then
        lun_pp%wttopounit(l) = weight
     else if (weight > 0._r8) then
-#ifndef _OPENACC
        write(iulog,*) subname//' ERROR: Attempt to assign non-zero weight to a non-existent landunit'
        write(iulog,*) 'g, t, l, ltype, weight = ', top_pp%gridcell(t), t, l, ltype, weight
        call endrun(decomp_index=l, elmlevel=namel, msg=errMsg(__FILE__, __LINE__))
-#endif
     end if
-
+    
   end subroutine set_landunit_weight
 
 
@@ -642,7 +547,6 @@ contains
     ! Determine if the given topounit is 100% covered by the landunit type given by ltype
     !
     ! !USES:
-    !$acc routine seq
     !
     ! !ARGUMENTS:
     implicit none
@@ -654,7 +558,7 @@ contains
     real(r8) :: wt_lunit ! subgrid weight of the given landunit
 
     real(r8), parameter :: tolerance = 1.e-13_r8  ! tolerance for checking whether landunit's weight is 1
-    !character(len=*), parameter :: subname = 'is_topo_all_ltypeX'
+    character(len=*), parameter :: subname = 'is_topo_all_ltypeX'
     !------------------------------------------------------------------------------
 
     wt_lunit = get_landunit_weight(t, ltype)
@@ -675,13 +579,12 @@ contains
     ! This routine operates in two different modes, depending on the value of active_only. If
     ! active_only is true, then we check the sum of weights of the ACTIVE children,
     ! grandchildren, etc. of a given point. If active_only is false, then we check the sum of
-    ! weights of ALL children, grandchildren, etc. of a given point.
+    ! weights of ALL children, grandchildren, etc. of a given point. 
     !
     ! Normally this routine will be called twice: once with active_only=false, and once with
     ! active_only=true.
     !
     ! !USES
-    !$acc routine seq
     !
     ! !ARGUMENTS
     implicit none
@@ -690,15 +593,17 @@ contains
     !
     ! !LOCAL VARIABLES:
     integer :: g,t,l,c,p, tu     ! loop counters
-    real(r8) :: sumwtcol(bounds%begc:bounds%endc)
-    real(r8) :: sumwtlunit(bounds%begl:bounds%endl)
-    real(r8) :: sumwtgcell(bounds%begg:bounds%endg)
-    real(r8) :: sumwttunit(bounds%begt:bounds%endt)
+    real(r8), allocatable :: sumwtcol(:), sumwtlunit(:), sumwtgcell(:), sumwttunit(:)
     logical :: error_found                ! true if we find an error
     logical :: topo_active_only           ! Check the weights of the active topounits
-    !character(len=*), parameter :: subname = 'check_weights'
+    character(len=*), parameter :: subname = 'check_weights'
     !------------------------------------------------------------------------------
 
+    allocate(sumwtcol(bounds%begc:bounds%endc))
+    allocate(sumwtlunit(bounds%begl:bounds%endl))
+    allocate(sumwttunit(bounds%begt:bounds%endt))
+    allocate(sumwtgcell(bounds%begg:bounds%endg))
+
     error_found = .false.
 
     ! Check PFT-level weights
@@ -713,7 +618,7 @@ contains
        t = veg_pp%topounit(p)
        g = veg_pp%gridcell(p)
 
-       if ((active_only .and. veg_pp%active(p)) .or. .not. active_only) then
+       if ((active_only .and. veg_pp%active(p)) .or. .not. active_only) then 
           sumwtcol(c) = sumwtcol(c) + veg_pp%wtcol(p)
           sumwtlunit(l) = sumwtlunit(l) + veg_pp%wtlunit(p)
           !topo_active_only = top_pp%active(t)
@@ -724,13 +629,12 @@ contains
        end if
     end do
 
-#ifndef _OPENACC
     do c = bounds%begc,bounds%endc
        tu = col_pp%topounit(c)
        topo_active_only = top_pp%active(tu) 
        if (topo_active_only) then ! Check only for the valid topounits
           if (.not. weights_okay(sumwtcol(c), active_only, col_pp%active(c))) then
-             write(iulog,*) ' ERROR: at c = ',c,'total PFT weight is ',sumwtcol(c), &
+             write(iulog,*) trim(subname),' ERROR: at c = ',c,'total PFT weight is ',sumwtcol(c), &
                          'active_only = ', active_only
              error_found = .true.
           end if
@@ -742,7 +646,7 @@ contains
        topo_active_only = top_pp%active(tu) 
        if (topo_active_only) then 
           if (.not. weights_okay(sumwtlunit(l), active_only, lun_pp%active(l))) then
-             write(iulog,*) ' ERROR: at l = ',l,'total PFT weight is ',sumwtlunit(l), &
+             write(iulog,*) trim(subname),' ERROR: at l = ',l,'total PFT weight is ',sumwtlunit(l), &
                          'active_only = ', active_only
              error_found = .true.
           end if
@@ -753,7 +657,7 @@ contains
        topo_active_only = top_pp%active(t)
        if (topo_active_only) then 
           if (.not. weights_okay(sumwttunit(t), active_only, top_pp%active(t))) then
-             write(iulog,*) ' ERROR: at t = ',t,'total PFT weight is ',sumwttunit(t), &
+             write(iulog,*) trim(subname),' ERROR: at t = ',t,'total PFT weight is ',sumwttunit(t), &
                          'active_only = ', active_only
              error_found = .true.
           end if
@@ -762,12 +666,11 @@ contains
 
     do g = bounds%begg,bounds%endg
        if (.not. weights_okay(sumwtgcell(g), active_only, i_am_active=.true.)) then
-          write(iulog,*) ' ERROR: at g = ',g,'total PFT weight is ',sumwtgcell(g), &
+          write(iulog,*) trim(subname),' ERROR: at g = ',g,'total PFT weight is ',sumwtgcell(g), &
                          'active_only = ', active_only
           error_found = .true.
        end if
     end do
-#endif
 
     ! Check col-level weights
     sumwtlunit(bounds%begl : bounds%endl) = 0._r8
@@ -789,13 +692,12 @@ contains
        end if
     end do
 
-#ifndef _OPENACC
     do l = bounds%begl,bounds%endl
        tu = lun_pp%topounit(l)
        topo_active_only = top_pp%active(tu)
        if (topo_active_only) then ! Check only for the valid topounits
           if (.not. weights_okay(sumwtlunit(l), active_only, lun_pp%active(l))) then
-             write(iulog,*) ' ERROR: at l = ',l,'total col weight is ',sumwtlunit(l), &
+             write(iulog,*) trim(subname),' ERROR: at l = ',l,'total col weight is ',sumwtlunit(l), &
                          'active_only = ', active_only
              error_found = .true.
           end if
@@ -806,21 +708,21 @@ contains
        topo_active_only = top_pp%active(t)
        if (topo_active_only) then
           if (.not. weights_okay(sumwttunit(t), active_only, top_pp%active(t))) then
-             write(iulog,*) ' ERROR: at t = ',t,'total col weight is ',sumwttunit(t), &
+             write(iulog,*) trim(subname),' ERROR: at t = ',t,'total col weight is ',sumwttunit(t), &
                          'active_only = ', active_only
              error_found = .true.
           end if
        end if
     end do
-
+    
     do g = bounds%begg,bounds%endg
        if (.not. weights_okay(sumwtgcell(g), active_only, i_am_active=.true.)) then
-          write(iulog,*) ' ERROR: at g = ',g,'total col weight is ',sumwtgcell(g), &
+          write(iulog,*) trim(subname),' ERROR: at g = ',g,'total col weight is ',sumwtgcell(g), &
                          'active_only = ', active_only
           error_found = .true.
        end if
     end do
-#endif
+
     ! Check landunit-level weights
     sumwtgcell(bounds%begg : bounds%endg) = 0._r8
     sumwttunit(bounds%begt : bounds%endt) = 0._r8
@@ -835,25 +737,24 @@ contains
        end if       
     end do
 
-    
-#ifndef _OPENACC
     do t = bounds%begt,bounds%endt
        if (top_pp%active(t)) then
           if (.not. weights_okay(sumwttunit(t), active_only, top_pp%active(t))) then
-             write(iulog,*) ' ERROR: at t= ',t,'total lunit weight is ',sumwttunit(t), &
+             write(iulog,*) trim(subname),' ERROR: at t= ',t,'total lunit weight is ',sumwttunit(t), &
                          'active_only = ', active_only
              error_found = .true.
           end if
        end if
     end do
+    
     do g = bounds%begg,bounds%endg
        if (.not. weights_okay(sumwtgcell(g), active_only, i_am_active=.true.)) then
-          write(iulog,*) ' ERROR: at g = ',g,'total lunit weight is ',sumwtgcell(g), &
+          write(iulog,*) trim(subname),' ERROR: at g = ',g,'total lunit weight is ',sumwtgcell(g), &
                          'active_only = ', active_only
           error_found = .true.
        end if
     end do
-#endif
+    
     ! Check topounit-level weights
     sumwtgcell(bounds%begg : bounds%endg) = 0._r8    
     do t = bounds%begt,bounds%endt
@@ -863,16 +764,21 @@ contains
        end if       
     end do
 
-    !do g = bounds%begg,bounds%endg
-    !   if (.not. weights_okay(sumwtgcell(g), active_only, i_am_active=.true.)) then
-    !      write(iulog,*) trim(subname),' ERROR: at g = ',g,'total topounit weight is ',sumwtgcell(g), &
-    !                     'active_only = ', active_only
-    !      write(iulog,*) trim(subname),' ERROR: at g = ',g,' ntopounits = ',grc_pp%ntopounits(g)
-    !      error_found = .true.
-    !   end if
-    !end do
+    do g = bounds%begg,bounds%endg
+       if (.not. weights_okay(sumwtgcell(g), active_only, i_am_active=.true.)) then
+          write(iulog,*) trim(subname),' ERROR: at g = ',g,'total topounit weight is ',sumwtgcell(g), &
+                         'active_only = ', active_only
+          write(iulog,*) trim(subname),' ERROR: at g = ',g,' ntopounits = ',grc_pp%ntopounits(g)
+          error_found = .true.
+       end if
+    end do
     
-    !deallocate(sumwtcol, sumwtlunit, sumwttunit, sumwtgcell)
+    deallocate(sumwtcol, sumwtlunit, sumwttunit, sumwtgcell)
+
+    if (error_found) then
+       call endrun(msg=errMsg(__FILE__, __LINE__))
+    end if
+
     ! Success
 
   end subroutine check_weights
@@ -890,7 +796,6 @@ contains
     !   grandchildren or great-grandchilden? (alternative is that it includes weights of ALL
     !   children, grandchildren or great-grandchildren)
     ! - i_am_active: true if the column, landunit or grid cell of interest is active
-    !$acc routine seq
     !
     ! !ARGUMENTS:
     implicit none
@@ -925,16 +830,15 @@ contains
     ! Set history fields giving diagnostics about subgrid weights
     !
     ! !USES:
-    !$acc routine seq
     !
     ! !ARGUMENTS:
     type(bounds_type), intent(in) :: bounds
     !
     ! !LOCAL VARIABLES:
-
-    !character(len=*), parameter :: subname = 'set_subgrid_diagnostic_fields'
+    
+    character(len=*), parameter :: subname = 'set_subgrid_diagnostic_fields'
     !-----------------------------------------------------------------------
-
+    
     call set_pct_landunit_diagnostics(bounds)
     call set_pct_pft_diagnostics(bounds)
     call set_pct_glc_mec_diagnostics(bounds)
@@ -948,7 +852,6 @@ contains
     ! Set pct_landunit diagnostic field: % of each landunit on the grid cell
     !
     ! !USES:
-    !$acc routine seq
     !
     ! !ARGUMENTS:
     type(bounds_type), intent(in) :: bounds
@@ -956,9 +859,10 @@ contains
     ! !LOCAL VARIABLES:
     integer :: g, l,t,ti,topi  ! grid cell & landunit indices
     integer :: ltype ! landunit type
-
+    
     character(len=*), parameter :: subname = 'set_pct_landunit_diagnostics'
     !-----------------------------------------------------------------------
+
     subgrid_weights_diagnostics%pct_landunit(bounds%begt:bounds%endt,:) = 0._r8
     
     do l = bounds%begl, bounds%endl
@@ -984,11 +888,10 @@ contains
     ! Note that pct_glc_mec will be 0 for all elevation classes in a grid cell that does
     ! not have a glc_mec landunit. However, it will still sum to 100% for a grid cell
     ! that has a 0-weight (i.e., virtual) glc_mec landunit.
-    !$acc routine seq
     !
     ! !USES:
     use landunit_varcon, only : istice_mec
-    !use column_varcon, only : col_itype_to_icemec_class
+    use column_varcon, only : col_itype_to_icemec_class
     use elm_varpar, only : maxpatch_glcmec
     !
     ! !ARGUMENTS:
@@ -997,10 +900,10 @@ contains
     ! !LOCAL VARIABLES:
     integer :: c,l,g,t,ti,topi          ! indices
     integer :: icemec_class   ! icemec class (1..maxpatch_glcmec)
-
+    
     character(len=*), parameter :: subname = 'set_pct_glc_mec_diagnostics'
     !-----------------------------------------------------------------------
-
+    
     if (maxpatch_glcmec > 0) then
        subgrid_weights_diagnostics%pct_glc_mec(bounds%begt:bounds%endt,:) = 0._r8
     
@@ -1011,7 +914,7 @@ contains
           !topi = grc_pp%topi(g)
           !ti = t - topi + 1
           if (lun_pp%itype(l) == istice_mec) then
-             icemec_class = col_pp%itype(c) - istice_mec*100
+             icemec_class = col_itype_to_icemec_class(col_pp%itype(c))
              subgrid_weights_diagnostics%pct_glc_mec(t, icemec_class) = col_pp%wtlunit(c) * 100._r8
           end if
        end do
@@ -1024,7 +927,6 @@ contains
     !
     ! !DESCRIPTION:
     ! Set pct_nat_pft & pct_cft diagnostic fields: % of PFTs on their landunit
-    !$acc routine seq
     !
     ! !USES:
     use landunit_varcon, only : istsoil, istcrop
@@ -1037,9 +939,10 @@ contains
     integer :: p,l,g,t,ti,topi           ! indices
     integer :: ptype           ! pft itype
     integer :: ptype_1indexing ! pft itype, translated into 1-indexing for the given landunit type
-
+    
     character(len=*), parameter :: subname = 'set_pct_pft_diagnostics'
     !-----------------------------------------------------------------------
+    
     subgrid_weights_diagnostics%pct_nat_pft(bounds%begt:bounds%endt,:) = 0._r8
 
     ! Note that pct_cft will be 0-size if cft_size is 0 (which can happen if we don't
diff --git a/components/elm/src/main/surfrdMod.F90 b/components/elm/src/main/surfrdMod.F90
index bd3dbadef3..3544b67294 100755
--- a/components/elm/src/main/surfrdMod.F90
+++ b/components/elm/src/main/surfrdMod.F90
@@ -20,6 +20,7 @@ module surfrdMod
   use pio
   use spmdMod       
   use topounit_varcon , only : max_topounits, has_topounit  
+  
   !
   ! !PUBLIC TYPES:
   implicit none
diff --git a/components/elm/src/main/timeinfoMod.F90 b/components/elm/src/main/timeinfoMod.F90
index d1eaa2e43d..9eab687a3c 100644
--- a/components/elm/src/main/timeinfoMod.F90
+++ b/components/elm/src/main/timeinfoMod.F90
@@ -69,7 +69,7 @@ contains
           doalb = (nextsw_cday_mod >= -0.5_r8)
     end if
 
-  end subroutine increment_time_vars
+  end subroutine
 
 
 
diff --git a/components/elm/src/main/topounit_varcon.F90 b/components/elm/src/main/topounit_varcon.F90
index a6ecf8b24e..056f8fd520 100644
--- a/components/elm/src/main/topounit_varcon.F90
+++ b/components/elm/src/main/topounit_varcon.F90
@@ -108,6 +108,7 @@ module topounit_varcon
        endif    
        if (.not. readvar) then
           write(iulog,*)' ERROR: While reading number of topounits per grid from lfsurfdat file '
+          !call endrun(msg=errMsg(__FILE__, __LINE__))
         end if
   
        ! Make sure the number of topounits per grid consistent with the land mask
@@ -117,6 +118,7 @@ module topounit_varcon
                   'initialize1: landmask/Number of topounits mismatch'
              write(iulog,*)trim(subname),&
                   'More than 1 topounits where landmask = 0, gridcell index', n
+             !call endrun(msg=errMsg(__FILE__, __LINE__))
           endif
        enddo
     end if
diff --git a/components/elm/src/main/update_accMod.F90 b/components/elm/src/main/update_accMod.F90
deleted file mode 100644
index 2c19dabbd3..0000000000
--- a/components/elm/src/main/update_accMod.F90
+++ /dev/null
@@ -1,298 +0,0 @@
-module update_accMod
-
-  public :: update_acc_variables
-contains
-
-
-subroutine update_acc_variables()
-  use pftvarcon
-  use elm_varctl
-  use elm_varcon
-  use elm_varpar
-  use soilorder_varcon
-  use LakeCon
-  use SoilWaterMovementMod
-  use SharedParamsMod
-  use MaintenanceRespMod
-  use NitrifDenitrifMod
-  use CNStateType
-  use AllocationMod
-  !---------- MaintenanceRespMod ------------!
-  !$acc update device(br_mr_Inst)
-  !----------- NitrifDenitrifMod -----------!
-  !$acc update device (no_frozen_nitrif_denitrif )
-  !---------- CNStateType ---------------!
-  !$acc update device(fert_type  &
-  !$acc               ,fert_continue &
-  !$acc               ,fert_dose     &
-  !$acc               ,fert_start    &
-  !$acc               ,fert_end      &
-  !---------- soilorder_varcon -------------!
-  !$acc               ,smax(:)       &
-  !$acc               ,ks_sorption(:)&
-  !$acc               ,r_weather(:)  &
-  !$acc               ,r_adsorp(:)   &
-  !$acc               ,r_desorp(:)   &
-  !$acc               ,r_occlude(:)  &
-  !$acc               ,k_s1_biochem(:) &
-  !$acc               ,k_s2_biochem(:) &
-  !$acc               ,k_s3_biochem(:) &
-  !$acc               ,k_s4_biochem(:) &
-  !$acc               ,r_mort_soilorder(:) )
-  !---------- SharedParamsMod -------------- !
-  !$acc update device(anoxia_wtsat, nlev_soildecomp_standard )
-  !--------- elm_varpar --------------------!
-  !$acc update device( &
-  !$acc       nlevsoi         &
-  !$acc       ,nlevsno        &
-  !$acc       ,nlevsoifl       &
-  !$acc       ,nlevurb         &
-  !$acc       ,nlevlak         &
-  !$acc       ,nlevdecomp      &
-  !$acc       ,nlevdecomp_full &
-  !$acc       ,nlevtrc_soil    &
-  !$acc       ,nlevtrc_full    &
-  !$acc       ,nlevgrnd        &
-  !$acc       ,natpft_lb       &
-  !$acc       ,natpft_ub       &
-  !$acc       ,natpft_size     &
-  !$acc       ,cft_lb          &
-  !$acc       ,cft_ub          &
-  !$acc       ,cft_size        &
-  !$acc       ,i_met_lit       &
-  !$acc       ,i_cel_lit       &
-  !$acc       ,i_lig_lit       &
-  !$acc       ,i_cwd           &
-  !$acc       ,maxpatch_glcmec   &
-  !$acc       ,max_patch_per_col &
-  !$acc       ,mach_eps         &
-  !$acc       ,maxpatch_pft )
-  !--------- elm_varcon --------------------!
-  !$acc update device(&
-  !$acc       zlak(:)        &
-  !$acc       ,dzlak(:)       &
-  !$acc       ,zsoi(:)        &
-  !$acc       ,dzsoi(:)       &
-  !$acc       ,zisoi(:)       &
-  !$acc       ,dzsoi_decomp(:) &
-  !$acc       ,nlvic(:)       &
-  !$acc       ,dzvic(:)       &
-  !$acc       ,zsoifl(:)      &
-  !$acc       ,zisoifl(:)     &
-  !$acc       ,dzsoifl(:)     &
-  !$acc       ,denh2o         &
-  !-------- elm_varctl ---------------------!
-  !$acc       ,glcmec_downscale_rain_snow_convert &
-  !$acc       ,glcmec_downscale_longwave &
-  !$acc       ,subgridflag &
-  !$acc       ,use_nofire          &
-  !$acc       ,use_lch4            &
-  !$acc       ,use_vertsoilc       &
-  !$acc       ,use_extralakelayers &
-  !$acc       ,use_vichydro        &
-  !$acc       ,use_century_decomp  &
-  !$acc       ,use_cn              )
-  ! -------- pftvarcon ------------------!
-  !$acc update device( &
-  !$acc        dleaf(:)       &
-  !$acc       ,c3psn(:)       &
-  !$acc       ,xl(:)          &
-  !$acc       ,rhol(:,:)      &
-  !$acc       ,rhos(:,:)      &
-  !$acc       ,taul(:,:)      &
-  !$acc       ,taus(:,:)      &
-  !$acc       ,z0mr(:)        &
-  !$acc       ,displar(:)     &
-  !$acc       ,roota_par(:)   &
-  !$acc       ,rootb_par(:)   &
-  !$acc       ,crop(:)        &
-  !$acc       ,irrigated(:)   &
-  !$acc       ,smpso(:)       &
-  !$acc       ,smpsc(:)       &
-  !$acc       ,fnitr(:)       &
-  !$acc       ,slatop(:)      &
-  !$acc       ,dsladlai(:)    &
-  !$acc       ,leafcn(:)      &
-  !$acc       ,flnr(:)        &
-  !$acc       ,woody(:)       &
-  !$acc       ,lflitcn(:)     &
-  !$acc       ,frootcn(:)     &
-  !$acc       ,livewdcn(:)    &
-  !$acc       ,deadwdcn(:)    &
-  !$acc       ,grperc(:)      &
-  !$acc       ,grpnow(:)      &
-  !$acc       ,rootprof_beta(:) &
-  !$acc       ,leafcp(:)   &
-  !$acc       ,lflitcp(:)  &
-  !$acc       ,frootcp(:)  &
-  !$acc       ,livewdcp(:) &
-  !$acc       ,deadwdcp(:) &
-  !$acc    ,mergetoelmpft (:) &
-  !$acc    ,is_pft_known_to_model (:) &
-  !$acc        ,graincn(:)       &
-  !$acc        ,graincp(:)       &
-  !$acc        ,mxtmp(:)         &
-  !$acc        ,baset(:)         &
-  !$acc        ,declfact(:)      &
-  !$acc        ,bfact(:)         &
-  !$acc        ,aleaff(:)        &
-  !$acc        ,arootf(:)        &
-  !$acc        ,astemf(:)        &
-  !$acc        ,arooti(:)        &
-  !$acc        ,fleafi(:)        &
-  !$acc        ,allconsl(:)      &
-  !$acc        ,allconss(:)      &
-  !$acc        ,ztopmx(:)        &
-  !$acc        ,laimx(:)         &
-  !$acc        ,gddmin(:)        &
-  !$acc        ,hybgdd(:)        &
-  !$acc        ,lfemerg(:)       &
-  !$acc        ,grnfill(:)       &
-  !$acc        ,mxmat(:)         &
-  !$acc        ,mnNHplantdate(:) &
-  !$acc        ,mxNHplantdate(:) &
-  !$acc        ,mnSHplantdate(:) &
-  !$acc        ,mxSHplantdate(:) &
-  !$acc        ,planttemp(:)     &
-  !$acc        ,minplanttemp(:)  &
-  !$acc        ,froot_leaf(:)    &
-  !$acc        ,stem_leaf(:)     &
-  !$acc        ,croot_stem(:)    &
-  !$acc        ,flivewd(:)       &
-  !$acc        ,fcur(:)          &
-  !$acc        ,lf_flab(:)       &
-  !$acc        ,lf_fcel(:)       &
-  !$acc        ,lf_flig(:)       &
-  !$acc        ,fr_flab(:)       &
-  !$acc        ,fr_fcel(:)       &
-  !$acc        ,fr_flig(:)       &
-  !$acc        ,leaf_long(:)     &
-  !$acc        ,froot_long(:)    &
-  !$acc        ,evergreen(:)     &
-  !$acc        ,stress_decid(:)  &
-  !$acc        ,season_decid(:)  &
-  !$acc        ,pconv(:)         &
-  !$acc        ,pprod10(:)       &
-  !$acc        ,pprod100(:)      &
-  !$acc        ,pprodharv10(:)   &
-  !$acc       ,cc_leaf(:)  &
-  !$acc       ,cc_lstem(:) &
-  !$acc       ,cc_dstem(:) &
-  !$acc       ,cc_other(:) &
-  !$acc       ,fm_leaf(:)  &
-  !$acc       ,fm_lstem(:) &
-  !$acc       ,fm_dstem(:) &
-  !$acc       ,fm_other(:) &
-  !$acc       ,fm_root(:)  &
-  !$acc       ,fm_lroot(:) &
-  !$acc       ,fm_droot(:) &
-  !$acc       ,fsr_pft(:)  &
-  !$acc       ,fd_pft(:)   &
-  !$acc       ,fertnitro(:) &
-  !$acc       ,fleafcn(:)   &
-  !$acc       ,ffrootcn(:)  &
-  !$acc       ,fstemcn(:)   &
-  !$acc       ,presharv(:)  &
-  !$acc       ,convfact(:)  &
-  !$acc       ,fyield(:)    &
-  !$acc       ,root_dmx(:)  &
-  !$acc     ,VMAX_PLANT_NH4(:)   &
-  !$acc     ,VMAX_PLANT_NO3(:)   &
-  !$acc     ,VMAX_PLANT_P(:)     &
-  !$acc     ,VMAX_MINSURF_P_vr(:,:) &
-  !$acc     ,KM_PLANT_NH4(:)      &
-  !$acc     ,KM_PLANT_NO3(:)      &
-  !$acc     ,KM_PLANT_P(:)        &
-  !$acc     ,KM_MINSURF_P_vr(:,:) )
-  !$acc update device( &
-  !$acc     KM_DECOMP_NH4        &
-  !$acc     ,KM_DECOMP_NO3        &
-  !$acc     ,KM_DECOMP_P          &
-  !$acc     ,KM_NIT               &
-  !$acc     ,KM_DEN               &
-  !$acc     ,decompmicc_patch_vr(:,:) &
-  !$acc     ,alpha_nfix(:)            &
-  !$acc     ,alpha_ptase(:)           &
-  !$acc     ,ccost_nfix(:)            &
-  !$acc     ,pcost_nfix(:)            &
-  !$acc     ,ccost_ptase(:)           &
-  !$acc     ,ncost_ptase(:)           &
-  !$acc     ,VMAX_NFIX(:)       &
-  !$acc     ,KM_NFIX(:)         &
-  !$acc     ,VMAX_PTASE(:)      &
-  !$acc     ,KM_PTASE           &
-  !$acc     ,lamda_ptase        &
-  !$acc     ,i_vc(:)            &
-  !$acc     ,s_vc(:)            &
-  !$acc     ,leafcn_obs(:)          &
-  !$acc     ,frootcn_obs(:)         &
-  !$acc     ,livewdcn_obs(:)        &
-  !$acc     ,deadwdcn_obs(:)        &
-  !$acc     ,leafcp_obs(:)          &
-  !$acc     ,frootcp_obs(:)         &
-  !$acc     ,livewdcp_obs(:)        &
-  !$acc     ,deadwdcp_obs(:)        &
-  !$acc     ,leafcn_obs_flex(:,:)   &
-  !$acc     ,frootcn_obs_flex(:,:)  &
-  !$acc     ,livewdcn_obs_flex(:,:) &
-  !$acc     ,deadwdcn_obs_flex(:,:) &
-  !$acc     ,leafcp_obs_flex(:,:)   &
-  !$acc     ,frootcp_obs_flex(:,:)  &
-  !$acc     ,livewdcp_obs_flex(:,:) &
-  !$acc     ,deadwdcp_obs_flex(:,:) &
-  !$acc     ,fnr(:)        &
-  !$acc     ,act25(:)      &
-  !$acc     ,kcha(:)       &
-  !$acc     ,koha(:)       &
-  !$acc     ,cpha(:)       &
-  !$acc     ,vcmaxha(:)    &
-  !$acc     ,jmaxha(:)     &
-  !$acc     ,tpuha(:)      &
-  !$acc     ,lmrha(:)      &
-  !$acc     ,vcmaxhd(:)    &
-  !$acc     ,jmaxhd(:)     &
-  !$acc     ,tpuhd(:)      &
-  !$acc     ,lmrhd(:)      &
-  !$acc     ,lmrse(:)      &
-  !$acc     ,qe(:)         &
-  !$acc     ,theta_cj(:)   &
-  !$acc     ,bbbopt(:)     &
-  !$acc     ,mbbopt(:)     &
-  !$acc     ,nstor(:)      &
-  !$acc     ,br_xr(:)      &
-  !$acc     ,tc_stress     &
-  !$acc     ,vcmax_np1(:)  &
-  !$acc     ,vcmax_np2(:)  &
-  !$acc     ,vcmax_np3(:)  &
-  !$acc     ,vcmax_np4(:)  &
-  !$acc     ,jmax_np1      &
-  !$acc     ,jmax_np2      &
-  !$acc     ,jmax_np3      &
-  !$acc     ,laimax        &
-  !$acc    ,rsub_top_globalmax &
-  !------------- LakeCon ------------------!
-  !$acc    ,fcrit      &
-  !$acc    ,minz0lake  &
-  !$acc     ,pudz &
-  !$acc     ,depthcrit &
-  !$acc     ,mixfact &
-  !$acc     ,betavis &
-  !$acc     ,lakepuddling &
-  !$acc     ,lake_no_ed )
-  !------------ SoilWaterMovementMod ---------------- !
-  !$acc update device(soilroot_water_method )
-  !----------- AllocationMod ------------------- !
-  !$acc update device( nu_com_leaf_physiology &
-  !$acc    , nu_com_root_kinetics   &
-  !$acc    , nu_com_phosphatase     &
-  !$acc    , nu_com_nfix            &
-  !$acc    , bdnr                   &
-  !$acc    , dayscrecover           &
-  !!!!! NOTE: this is needed based on nu_com !$acc    , decompmicc(:)          &
-  !$acc    , crop_supln             &
-  !$acc     )
-
-end subroutine update_acc_variables
-
-
-end module update_accMod
diff --git a/components/elm/src/utils/AnnualFluxDribbler.F90 b/components/elm/src/utils/AnnualFluxDribbler.F90
index a97d0da5bf..3e1bb43ee1 100644
--- a/components/elm/src/utils/AnnualFluxDribbler.F90
+++ b/components/elm/src/utils/AnnualFluxDribbler.F90
@@ -82,18 +82,19 @@ module AnnualFluxDribbler
   ! !PUBLIC TYPES:
 
   type, public :: annual_flux_dribbler_type
+     private
      ! Metadata
-     character(len=128), pointer :: name
-     character(len=64) , pointer :: units
+     character(len=name_maxlen) :: name
+     character(len=units_maxlen) :: units
 
      ! Whether this dribbler allows non-zero deltas on time steps other than the first
      ! time step of the year
-     logical, pointer :: allows_non_annual_delta
+     logical :: allows_non_annual_delta
 
      ! Which subgrid level this dribbler is operating at, stored in various ways
-     character(len=64), pointer :: dim1name
-     character(len=64), pointer :: name_subgrid
-     integer, pointer :: bounds_subgrid_level
+     character(len=subgrid_maxlen) :: dim1name
+     character(len=subgrid_maxlen) :: name_subgrid
+     integer :: bounds_subgrid_level
 
      ! Annual amount to dribble in over the year
      real(r8), pointer :: amount_to_dribble(:)
@@ -164,7 +165,6 @@ contains
 
     character(len=*), parameter :: subname = 'annual_flux_dribbler_gridcell'
     !-----------------------------------------------------------------------
-    allocate(this%dim1name);allocate(this%name_subgrid);allocate(this%bounds_subgrid_level)
 
     this%dim1name = 'gridcell'
     this%name_subgrid = nameg
@@ -202,7 +202,6 @@ contains
 
     character(len=*), parameter :: subname = 'annual_flux_dribbler_patch'
     !-----------------------------------------------------------------------
-    allocate(this%dim1name);allocate(this%name_subgrid);allocate(this%bounds_subgrid_level)
 
     this%dim1name = 'pft'
     this%name_subgrid = namep
@@ -548,9 +547,6 @@ contains
 
     character(len=*), parameter :: subname = 'set_metadata'
     !-----------------------------------------------------------------------
-    allocate(this%name )
-    allocate(this%units)
-    allocate(this%allows_non_annual_delta)
 
     if (len_trim(name) > name_maxlen) then
        write(iulog,*) subname // ': name too long'
diff --git a/components/elm/src/utils/SimpleMathMod.F90 b/components/elm/src/utils/SimpleMathMod.F90
index ea65d5ce5f..978fc5d537 100644
--- a/components/elm/src/utils/SimpleMathMod.F90
+++ b/components/elm/src/utils/SimpleMathMod.F90
@@ -1,6 +1,6 @@
 module SimpleMathMod
 
-!#py #include "shr_assert.h"
+#include "shr_assert.h"
   !------------------------------------------------------------------------------
   !
   ! DESCRIPTIONS:
@@ -19,11 +19,11 @@ implicit none
 contains
 !--------------------------------------------------------------------------------
   subroutine array_normalization_2d(which_dim, arr2d_inout)
-    !$acc routine seq
-    !DESCRIPTIONS
-    !do normalization for the input array along dimension which_dim
-    !
-    !USES
+  !$acc routine seq
+  !DESCRIPTIONS
+  !do normalization for the input array along dimension which_dim
+  !
+  !USES
   use shr_kind_mod, only: r8 => shr_kind_r8
   implicit none
 
@@ -76,50 +76,54 @@ contains
   end subroutine array_normalization_2d
 
 !--------------------------------------------------------------------------------
-  subroutine array_normalization_2d_filter( lbj2, ubj2, numf, filter, arr2d_inout)
+subroutine array_normalization_2d_filter(lbj1, ubj1, lbj2, ubj2, numf, filter, arr2d_inout)
+  !$acc routine seq
   !DESCRIPTIONS
   !do normalization with filter for the input array along dimension 2
+
   !
   !USES
   use shr_kind_mod, only: r8 => shr_kind_r8
   implicit none
-  integer,  intent(in) :: lbj2         !right bound of dim 1
+  integer,  intent(in) :: lbj1         !left bound of dim 1
+  integer,  intent(in) :: lbj2         !left bound of dim 2
+  integer,  intent(in) :: ubj1         !right bound of dim 1
   integer,  intent(in) :: ubj2         !right bound of dim 2
   integer,  intent(in) :: numf         !filter size
   integer,  intent(in) :: filter(:)    !filter
-  real(r8), intent(inout) :: arr2d_inout(: , : )   !input 2d array
+  real(r8), intent(inout) :: arr2d_inout(lbj1: , lbj2: )   !input 2d array
+
 
   !local variables
   integer  :: sz1, sz2     !array size
   integer  :: j2           !indices
   integer  :: f, p         !indices
-  real(r8) :: arr_sum(numf), sum1
-
-  !$acc enter data create(arr_sum(1:numf))
-  !$acc parallel loop independent gang worker default(present) private(sum1)
-  do f = 1, numf
-     sum1 = 0._r8
-     !$acc loop vector reduction(+:sum1)
-     do j2 = lbj2, ubj2
-        !obtain the total
-        sum1=sum1+arr2d_inout(f,j2)
+  real(r8) :: arr_sum(lbj1:ubj1)
+
+  ! Enforce expected array sizes
+
+
+  arr_sum(:) = 0._r8
+  do j2 = lbj2, ubj2
+    do f = 1, numf
+      p = filter(f)
+      !obtain the total
+      arr_sum(p)=arr_sum(p)+arr2d_inout(p,j2)
     enddo
-    arr_sum(f) = sum1
   enddo
 
     !normalize with the total if arr_sum is non-zero
-  !$acc parallel loop independent gang default(present)
   do j2 = lbj2, ubj2
-    !$acc loop vector independent
     do f = 1, numf
+      p = filter(f)
       !I found I have to ensure >0._r8 because of some unknown reason, jyt May 23, 2014
       !I will test this later with arr_sum(p)/=0._r8
-      if(arr_sum(f)>0._r8 .or. arr_sum(f)<0._r8)then
-        arr2d_inout(f,j2) = arr2d_inout(f,j2)/arr_sum(f)
+      if(arr_sum(p)>0._r8 .or. arr_sum(p)<0._r8)then
+        arr2d_inout(p,j2) = arr2d_inout(p,j2)/arr_sum(p)
       endif
     enddo
   enddo
-  !$acc exit data delete(arr_sum(:))
+  return
   end subroutine array_normalization_2d_filter
 !--------------------------------------------------------------------------------
 
@@ -134,7 +138,6 @@ contains
   ! USES
   !
   use shr_kind_mod, only: r8 => shr_kind_r8
-  !#py !#py use shr_log_mod    , only : errMsg => shr_log_errMsg
   implicit none
   integer,  intent(in) :: lbj1         !left bound of dim 1
   integer,  intent(in) :: lbj2         !left bound of dim 2
@@ -175,8 +178,6 @@ contains
   !USES
   !
   use shr_kind_mod, only: r8 => shr_kind_r8
-  !#py use shr_assert_mod , only : shr_assert
-  !#py !#py use shr_log_mod    , only : errMsg => shr_log_errMsg
   implicit none
   real(r8), intent(in) :: arr1d_in(:)     !scaling factor
   integer,  intent(in) :: which_dim        !which dimension is scaled
@@ -234,7 +235,7 @@ contains
     subroutine matvec_acc(START,END_,RES,A,X)
       !$acc routine seq
       !As of Cuda 10.1 calling cuBlas functions from device code
-      !is not supported.  So must have create any blas routines with
+      !is not supported.  So must create any blas routines with
       !acc routine seq manually.  This is for square matrices Matrix Vector Multiplication
       !used only in PhotosynthesisMod::calcstressroot so far
 
diff --git a/components/elm/src/utils/domainLateralMod.F90 b/components/elm/src/utils/domainLateralMod.F90
index fdb8d7ba4f..b46299a136 100644
--- a/components/elm/src/utils/domainLateralMod.F90
+++ b/components/elm/src/utils/domainLateralMod.F90
@@ -1,6 +1,552 @@
 module domainLateralMod
 
 #include "shr_assert.h"
+
+#ifdef USE_PETSC_LIB
+  !-----------------------------------------------------------------------
+  !BOP
+  !
+  ! !MODULE: domainMod
+  !
+  ! !DESCRIPTION:
+  ! Module containing:
+  ! - Information regarding lateral connectivity of the land grid,
+  ! - PETSc-based framework to exchange data across processors.
+  !
+#include <petsc/finclude/petsc.h>
+  !
+  ! !USES:
+  use petscsys
+  use petscvec
+  use petscmat
+  use petscts
+  use petscdm
+  use petscdmda
+  use shr_kind_mod, only : r8 => shr_kind_r8
+  use shr_sys_mod , only : shr_sys_abort
+  use spmdMod     , only : masterproc
+  use elm_varctl  , only : iulog
+  use spmdMod     , only : masterproc, iam, npes, mpicom, comp_id
+  use abortutils  , only : endrun
+  use UnstructuredGridType, only : ugdm_type, ugrid_type
+  !
+  ! !PUBLIC TYPES:
+  implicit none
+  private
+  !
+  type, public :: domainlateral_type
+
+     type(ugrid_type), pointer :: ugrid                  ! unstructured grid object
+     
+     type(ugdm_type), pointer :: dm_1dof                 ! PETSc DM for 1 DOF
+     type(ugdm_type), pointer :: dm_nlevgrnddof          !
+
+  end type domainlateral_type
+
+  type(domainlateral_type)    , public :: ldomain_lateral
+  !
+  ! !PUBLIC MEMBER FUNCTIONS:
+  public domainlateral_init          ! allocates/nans domain types
+  public ExchangeColumnLevelGhostData
+  !
+  !EOP
+  !------------------------------------------------------------------------------
+
+contains
+
+  !------------------------------------------------------------------------------
+  !BOP
+  !
+  ! !IROUTINE: domainlateral_init
+  !
+  ! !INTERFACE:
+  subroutine domainlateral_init(domain_l, cellsOnCell_old, edgesOnCell_old, &
+       nEdgesOnCell_old, areaCell_old, dcEdge_old, dvEdge_old, &
+       nCells_loc_old, nEdges_loc_old, maxEdges)
+    !
+    use decompMod, only : ldecomp, get_proc_bounds
+    use UnstructuredGridType, only : create_ugrid, create_ugdm
+    ! !ARGUMENTS:
+    implicit none
+    !
+    !
+    type(domainlateral_type) :: domain_l                ! domain datatype
+    integer , intent(in)     :: cellsOnCell_old(:,:)    ! grid cell level connectivity information as read in from netcdf file
+    integer , intent(in)     :: edgesOnCell_old(:,:)    ! index to determine distance between neighbors from dcEdge [in natural order prior to domain decomposition]
+    integer , intent(in)     :: nEdgesOnCell_old(:)     ! number of edged                                            [in natural order prior to domain decomposition]
+    real(r8), intent(in)     :: dvEdge_old(:)           ! distance between neighbors                                 [in natural order prior to domain decomposition]
+    real(r8), intent(in)     :: dcEdge_old(:)           ! distance between vertices                                  [in natural order prior to domain decomposition]
+    real(r8), intent(in)     :: areaCell_old(:)         ! area of grid cell                                          [in natural order prior to domain decomposition]
+    integer , intent(in)     :: nCells_loc_old          ! number of local cell-to-cell connections                   [in natural order prior to domain decomposition]
+    integer , intent(in)     :: nEdges_loc_old          ! number of edges                                            [in natural order prior to domain decomposition]
+    integer , intent(in)     :: maxEdges                ! max number of edges/neighbors
+    !
+    integer :: begg, endg
+
+    allocate(domain_l%ugrid)
+    allocate(domain_l%dm_1dof)
+    allocate(domain_l%dm_nlevgrnddof)
+
+    call get_proc_bounds(begg, endg)
+
+    call create_ugrid(domain_l%ugrid, mpicom, begg, endg, ldecomp%gdc2glo, &
+         cellsOnCell_old, ncells_loc_old, maxEdges)
+
+    call create_ugdm(domain_l%ugrid, domain_l%dm_1dof, 1)
+
+    call save_geometric_attributes(edgesOnCell_old, &
+         nEdgesOnCell_old, areaCell_old, dcEdge_old, dvEdge_old, &
+         nCells_loc_old, nEdges_loc_old, maxEdges)
+
+  end subroutine domainlateral_init
+
+  !------------------------------------------------------------------------------
+  subroutine save_geometric_attributes(edgesOnCell_old, &
+       nEdgesOnCell_old, areaCell_old, dcEdge_old, dvEdge_old, &
+       nCells_loc_old, nEdges_loc_old, maxEdges)
+    !
+    ! !DESCRIPTION:
+    ! Save following geometric attributes:
+    !  - grid cell area,
+    !  - centroidal distance between neighboring grid cells, and
+    !  - edge length between neighboring grid cells.
+    !
+    implicit none
+    !
+    ! !ARGUMENTS:
+    integer , intent(in)     :: edgesOnCell_old(:,:) ! index to determine distance between neighbors from dcEdge [in natural order prior to domain decomposition]
+    integer , intent(in)     :: nEdgesOnCell_old(:)  ! number of edges                                           [in natural order prior to domain decomposition]
+    real(r8), intent(in)     :: dcEdge_old(:)        ! distance between neighbors                                [in natural order prior to domain decomposition]
+    real(r8), intent(in)     :: dvEdge_old(:)        ! distance between vertices                                 [in natural order prior to domain decomposition]
+    real(r8), intent(in)     :: areaCell_old(:)      ! area of grid cell                                         [in natural order prior to domain decomposition]
+    integer , intent(in)     :: nCells_loc_old       ! number of local cell-to-cell connections                  [in natural order prior to domain decomposition]
+    integer , intent(in)     :: nEdges_loc_old       ! number of edges                                           [in natural order prior to domain decomposition]
+    integer , intent(in)     :: maxEdges             ! max number of edges/neighbors
+    !
+    ! !LOCAL VARIABLES:
+    PetscInt                 :: ii                   ! temporary
+    PetscInt                 :: icell, iedge         ! indices
+    PetscInt                 :: dcdv_count           ! counter for non-zero dc/dv
+    PetscInt                 :: count                ! temporary
+    PetscInt                 :: nblocks              ! temporary
+    PetscInt, pointer        :: int_array(:)         ! temporary
+    IS                       :: is_from, is_to       ! temporary
+    VecScatter               :: scatter              ! temprary
+    Vec                      :: dcdvEdge_glb_vec     ! global vectors for dcEdge
+    Vec                      :: dcdvEdge_loc_vec     ! global vectors for dcEdge
+    Vec                      :: attr_glb_vec         ! temporary global vector
+    Vec                      :: attr_loc_vec         ! temporary sequential vector
+    PetscReal, pointer       :: real_ptr(:)          ! temporary
+    PetscReal, pointer       :: dcOnCell_old(:,:)    ! temporary array to hold distance between neighbors
+    PetscReal, pointer       :: dvOnCell_old(:,:)    ! temporary array to hold distance between vertices
+    PetscErrorCode           :: ierr                 ! get error code from PETSc
+
+    allocate(dcOnCell_old(maxEdges, nCells_loc_old))
+    allocate(dvOnCell_old(maxEdges, nCells_loc_old))
+
+    dcOnCell_old = 0._r8
+    dvOnCell_old = 0._r8
+
+    dcdv_count = 0
+    do icell = 1, nCells_loc_old
+       dcdv_count = dcdv_count + nEdgesOnCell_old(icell)
+    enddo
+
+    nblocks = 2
+    call VecCreate(mpicom, dcdvEdge_glb_vec, ierr); CHKERRQ(ierr)
+    call VecSetSizes(dcdvEdge_glb_vec, nEdges_loc_old*nblocks, PETSC_DECIDE, ierr);
+    CHKERRQ(ierr)
+    call VecSetBlockSize(dcdvEdge_glb_vec, nblocks, ierr);CHKERRQ(ierr)
+    call VecSetFromOptions(dcdvEdge_glb_vec, ierr);CHKERRQ(ierr)
+
+    call VecCreate(PETSC_COMM_SELF, dcdvEdge_loc_vec, ierr); CHKERRQ(ierr)
+    call VecSetSizes(dcdvEdge_loc_vec, dcdv_count*nblocks, PETSC_DECIDE, ierr);
+    CHKERRQ(ierr)
+    call VecSetBlockSize(dcdvEdge_loc_vec, nblocks, ierr);CHKERRQ(ierr)
+    call VecSetFromOptions(dcdvEdge_loc_vec, ierr);CHKERRQ(ierr)
+
+    call VecGetArrayF90(dcdvEdge_glb_vec, real_ptr, ierr); CHKERRQ(ierr)
+    count = 0;
+    do iedge = 1, nEdges_loc_old
+       count = count + 1
+       real_ptr(count) = dcEdge_old(iedge)
+       count = count + 1
+       real_ptr(count) = dvEdge_old(iedge)
+    enddo
+    call VecRestoreArrayF90(dcdvEdge_glb_vec, real_ptr, ierr); CHKERRQ(ierr)
+
+    ! Populate dcOnCell_old
+    allocate(int_array(dcdv_count))
+    do ii = 1,dcdv_count
+       int_array(ii) = ii-1
+    enddo
+    call ISCreateBlock(mpicom, nblocks, dcdv_count, int_array, &
+         PETSC_COPY_VALUES, is_to, ierr);CHKERRQ(ierr);
+
+    dcdv_count = 0
+    do icell = 1, nCells_loc_old
+       do iedge = 1, nEdgesOnCell_old(icell)
+          dcdv_count            = dcdv_count + 1
+          int_array(dcdv_count) = edgesOnCell_old(iedge, icell) - 1
+       enddo
+    enddo
+    call ISCreateBlock(mpicom, nblocks, dcdv_count, int_array, &
+         PETSC_COPY_VALUES, is_from, ierr);CHKERRQ(ierr);
+    deallocate(int_array)
+
+    call VecScatterCreate(dcdvEdge_glb_vec, is_from, dcdvEdge_loc_vec, is_to, &
+         scatter, ierr); CHKERRQ(ierr)
+    call ISDestroy(is_from, ierr); CHKERRQ(ierr)
+    call ISDestroy(is_to, ierr); CHKERRQ(ierr)
+
+    call VecScatterBegin(scatter, dcdvEdge_glb_vec, dcdvEdge_loc_vec, INSERT_VALUES, SCATTER_FORWARD, ierr);
+    CHKERRQ(ierr);
+    call VecScatterEnd(scatter, dcdvEdge_glb_vec, dcdvEdge_loc_vec, INSERT_VALUES, SCATTER_FORWARD, ierr);
+    CHKERRQ(ierr);
+    call VecScatterDestroy(scatter, ierr)
+
+    call VecGetArrayF90(dcdvEdge_loc_vec, real_ptr, ierr); CHKERRQ(ierr)
+    count = 0
+    do icell = 1, nCells_loc_old
+       do iedge = 1, nEdgesOnCell_old(icell)
+          count = count + 1;
+          dcOnCell_old(iedge, icell) = real_ptr(count)
+          count = count + 1
+          dvOnCell_old(iedge, icell) = real_ptr(count)
+       enddo
+    enddo
+    call VecRestoreArrayF90(dcdvEdge_loc_vec, real_ptr, ierr); CHKERRQ(ierr)
+    call VecDestroy(dcdvEdge_loc_vec, ierr); CHKERRQ(ierr)
+
+    ! Aggregate data to be sent
+    nblocks = maxEdges*2
+    call VecCreate(mpicom, attr_glb_vec, ierr); CHKERRQ(ierr)
+    call VecSetSizes(attr_glb_vec, nCells_loc_old*nblocks, PETSC_DECIDE, ierr);
+    CHKERRQ(ierr)
+    call VecSetBlockSize(attr_glb_vec, nblocks, ierr);CHKERRQ(ierr)
+    call VecSetFromOptions(attr_glb_vec, ierr);CHKERRQ(ierr)
+
+    call VecCreate(PETSC_COMM_SELF, attr_loc_vec, ierr); CHKERRQ(ierr)
+    call VecSetSizes(attr_loc_vec, ldomain_lateral%ugrid%ngrid_local*nblocks, PETSC_DECIDE, ierr);
+    CHKERRQ(ierr)
+    call VecSetBlockSize(attr_loc_vec, nblocks, ierr);CHKERRQ(ierr)
+    call VecSetFromOptions(attr_loc_vec, ierr);CHKERRQ(ierr)
+
+    call VecGetArrayF90(attr_glb_vec, real_ptr, ierr); CHKERRQ(ierr)
+    count = 0
+    do icell = 1, nCells_loc_old
+       do iedge = 1, maxEdges
+          count           = count + 1;
+          real_ptr(count) = dcOnCell_old(iedge, icell)
+       enddo
+
+       do iedge = 1, maxEdges
+          count           = count + 1;
+          real_ptr(count) = dvOnCell_old(iedge, icell)
+       enddo
+    enddo
+    call VecRestoreArrayF90(attr_glb_vec, real_ptr, ierr); CHKERRQ(ierr)
+    deallocate(dcOnCell_old)
+    deallocate(dvOnCell_old)
+
+    allocate(int_array(ldomain_lateral%ugrid%ngrid_local))
+    do ii = 1, ldomain_lateral%ugrid%ngrid_local
+       int_array(ii) = ldomain_lateral%ugrid%grid_id_norder(ii) - 1
+    enddo
+
+    call ISCreateBlock(mpicom, nblocks, ldomain_lateral%ugrid%ngrid_local, int_array, &
+         PETSC_COPY_VALUES, is_from, ierr);CHKERRQ(ierr);
+    deallocate(int_array)
+
+    allocate(int_array(ldomain_lateral%ugrid%ngrid_local))
+    do ii = 1, ldomain_lateral%ugrid%ngrid_local
+       int_array(ii) = ii - 1
+    enddo
+
+    call ISCreateBlock(mpicom, nblocks, ldomain_lateral%ugrid%ngrid_local, int_array, &
+         PETSC_COPY_VALUES, is_to, ierr);CHKERRQ(ierr);
+    deallocate(int_array)
+
+    call VecScatterCreate(attr_glb_vec, is_from, attr_loc_vec, is_to, &
+         scatter, ierr); CHKERRQ(ierr)
+    call ISDestroy(is_from, ierr); CHKERRQ(ierr)
+    call ISDestroy(is_to, ierr); CHKERRQ(ierr)
+
+    call VecScatterBegin(scatter, attr_glb_vec, attr_loc_vec, &
+         INSERT_VALUES, SCATTER_FORWARD, ierr); CHKERRQ(ierr);
+    call VecScatterEnd(scatter, attr_glb_vec, attr_loc_vec, &
+         INSERT_VALUES, SCATTER_FORWARD, ierr); CHKERRQ(ierr);
+    call VecScatterDestroy(scatter, ierr)
+
+    allocate(ldomain_lateral%ugrid%dcOnGrid_local(maxEdges, ldomain_lateral%ugrid%ngrid_local))
+    allocate(ldomain_lateral%ugrid%dvOnGrid_local(maxEdges, ldomain_lateral%ugrid%ngrid_local))
+
+    call VecGetArrayF90(attr_loc_vec, real_ptr, ierr); CHKERRQ(ierr);
+    count = 0
+    do ii = 1, ldomain_lateral%ugrid%ngrid_local
+
+       do iedge = 1, maxEdges
+          count = count + 1
+          ldomain_lateral%ugrid%dcOnGrid_local(iedge, ii) = real_ptr(count)
+       enddo
+
+       do iedge = 1, maxEdges
+          count = count + 1
+          ldomain_lateral%ugrid%dvOnGrid_local(iedge, ii) = real_ptr(count)
+       enddo
+    enddo
+    call VecRestoreArrayF90(attr_loc_vec, real_ptr, ierr); CHKERRQ(ierr);
+
+    call VecDestroy(attr_loc_vec, ierr); CHKERRQ(ierr);
+    call VecDestroy(attr_glb_vec, ierr); CHKERRQ(ierr);
+
+    !
+    ! areaCell
+    !
+    allocate(ldomain_lateral%ugrid%areaGrid_ghosted(ldomain_lateral%ugrid%ngrid_ghosted))
+
+    nblocks = 1
+    call VecCreate(mpicom, attr_glb_vec, ierr); CHKERRQ(ierr)
+    call VecSetSizes(attr_glb_vec, nCells_loc_old*nblocks, PETSC_DECIDE, ierr);
+    CHKERRQ(ierr)
+    call VecSetBlockSize(attr_glb_vec, nblocks, ierr);CHKERRQ(ierr)
+    call VecSetFromOptions(attr_glb_vec, ierr);CHKERRQ(ierr)
+
+    call VecCreate(PETSC_COMM_SELF, attr_loc_vec, ierr); CHKERRQ(ierr)
+    call VecSetSizes(attr_loc_vec, ldomain_lateral%ugrid%ngrid_ghosted*nblocks, PETSC_DECIDE, ierr);
+    CHKERRQ(ierr)
+    call VecSetBlockSize(attr_loc_vec, nblocks, ierr);CHKERRQ(ierr)
+    call VecSetFromOptions(attr_loc_vec, ierr);CHKERRQ(ierr)
+
+    allocate(int_array(ldomain_lateral%ugrid%ngrid_ghosted))
+    do ii = 1,ldomain_lateral%ugrid%ngrid_ghosted
+       int_array(ii) = ii-1
+    enddo
+    call ISCreateBlock(mpicom, nblocks, ldomain_lateral%ugrid%ngrid_ghosted, int_array, &
+         PETSC_COPY_VALUES, is_to, ierr);CHKERRQ(ierr);
+
+    do ii = 1, ldomain_lateral%ugrid%ngrid_ghosted
+       int_array(ii) = ldomain_lateral%ugrid%grid_id_norder(ii) - 1
+    enddo
+    call ISCreateBlock(mpicom, nblocks, ldomain_lateral%ugrid%ngrid_ghosted, int_array, &
+         PETSC_COPY_VALUES, is_from, ierr);CHKERRQ(ierr);
+    deallocate(int_array)
+
+    call VecGetArrayF90(attr_glb_vec, real_ptr, ierr); CHKERRQ(ierr)
+    do ii = 1, nCells_loc_old
+       real_ptr(ii) = areaCell_old(ii)
+    enddo
+    call VecRestoreArrayF90(attr_glb_vec, real_ptr, ierr); CHKERRQ(ierr)
+
+    call VecScatterCreate(attr_glb_vec, is_from, attr_loc_vec, is_to, &
+         scatter, ierr); CHKERRQ(ierr)
+    call ISDestroy(is_from, ierr); CHKERRQ(ierr)
+    call ISDestroy(is_to, ierr); CHKERRQ(ierr)
+
+    call VecScatterBegin(scatter, attr_glb_vec, attr_loc_vec, &
+         INSERT_VALUES, SCATTER_FORWARD, ierr); CHKERRQ(ierr);
+    call VecScatterEnd(scatter, attr_glb_vec, attr_loc_vec, &
+         INSERT_VALUES, SCATTER_FORWARD, ierr); CHKERRQ(ierr);
+    call VecScatterDestroy(scatter, ierr)
+
+    call VecGetArrayF90(attr_loc_vec, real_ptr, ierr); CHKERRQ(ierr)
+    do ii = 1, ldomain_lateral%ugrid%ngrid_ghosted
+       ldomain_lateral%ugrid%areaGrid_ghosted(ii) = real_ptr(ii)
+    enddo
+    call VecRestoreArrayF90(attr_loc_vec, real_ptr, ierr); CHKERRQ(ierr)
+
+    call VecDestroy(attr_loc_vec, ierr); CHKERRQ(ierr);
+    call VecDestroy(attr_glb_vec, ierr); CHKERRQ(ierr);
+
+  end subroutine save_geometric_attributes
+
+  !-----------------------------------------------------------------------
+
+  subroutine ExchangeColumnLevelGhostData(bounds_proc, nvals_per_col, &
+       data_send_col, data_recv_col)
+    !
+    ! !DESCRIPTION:
+    ! - Exchanges column level data between MPI tasks.
+    ! - This subroutine must be called from OUTSIDE any loops over clumps
+    !
+    ! !USES:
+    use landunit_varcon , only : max_lunit
+    use decompMod       , only : bounds_type, BOUNDS_LEVEL_PROC
+    use LandunitType    , only : lun_pp
+    use ColumnType      , only : col_pp
+    use UnstructuredGridType, only : ScatterDataG2L
+    !
+    implicit none
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in)  :: bounds_proc       ! bound information at processor level
+    integer , intent(in )          :: nvals_per_col     ! number of values per grid column
+    real(r8), intent(in ), pointer :: data_send_col(:)  ! data to be send by each MPI task
+    real(r8), intent(out), pointer :: data_recv_col(:)  ! data received by each MPI task
+    !
+    ! !LOCAL VARIABLES:
+    integer             :: c,g,l,j                 ! indices
+    integer             :: cidx, lidx              ! column/landunit index
+    integer             :: ltype                   ! landunit type
+    integer             :: col_ltype               ! landunit type of the column
+    integer             :: ier                     ! error
+    integer             :: ndata_send              ! number of data sent by local mpi rank
+    integer             :: ndata_recv              ! number of data received by local mpi rank
+    integer             :: max_ncol_local          ! maximum number of columns per grid cell for local mpi rank
+    integer             :: max_ncol_global         ! maximum number of columns per grid cell across all mpi ranks
+    integer             :: nblocks                 ! number of values per grid cell
+    integer             :: nvals_col               ! number of values per subgrid category
+    integer             :: nvals                   ! number of values per subgrid category + additional values
+    integer             :: count                   ! temporary
+    integer             :: beg_idx, end_idx        ! begin/end index for accessing values in data_send/data_recv
+    integer             :: begc_idx, endc_idx      ! begin/end index for accessing values in data_send/data_recv
+    integer, pointer    :: ncol(:)                 ! number of columns in grid cell
+    integer, pointer    :: landunit_index(:,:)     ! index of the first landunit of a given landunit_itype within a grid cell
+    real(r8) , pointer  :: data_send(:)            ! data sent by local mpi rank
+    real(r8) , pointer  :: data_recv(:)            ! data received by local mpi rank
+    real(r8) , pointer  :: lun_rank(:)             ! rank of a landunit in a given grid cell for a given landunit type
+    real(r8) , pointer  :: grid_count(:)           ! temporary
+    integer             :: l_rank                  ! rank of landunit
+    integer             :: last_lun_type           ! temporary
+    PetscErrorCode      :: ierr                    ! PETSc return
+
+    character(len=*), parameter :: subname = 'ExchangeColumnLevelGhostData'
+    !-----------------------------------------------------------------------
+
+    SHR_ASSERT(bounds_proc%level == BOUNDS_LEVEL_PROC, subname // ': argument must be PROC-level bounds')
+
+    ! Compute index of the first landunit for a given landunit_itype within a grid cell
+    allocate(landunit_index(bounds_proc%begg_all:bounds_proc%endg_all,max_lunit))
+    landunit_index = 0
+
+    do lidx = bounds_proc%begl_all,  bounds_proc%endl_all
+       if (landunit_index(lun_pp%gridcell(lidx),lun_pp%itype(lidx)) == 0) then
+          landunit_index(lun_pp%gridcell(lidx),lun_pp%itype(lidx)) = lidx
+       endif
+    enddo
+
+    ! Compute number of columns for each grid cell
+    allocate(ncol(bounds_proc%begg:bounds_proc%endg))
+    ncol = 0
+
+    max_ncol_local = 0
+    do c = bounds_proc%begc, bounds_proc%endc
+       g       = col_pp%gridcell(c)
+       ncol(g) = ncol(g) + 1
+       if (ncol(g) > max_ncol_local) max_ncol_local = ncol(g)
+    enddo
+
+    ! Determine the maximum number of columns for a grid cell
+    call mpi_allreduce(max_ncol_local, max_ncol_global, 1, MPI_INTEGER, MPI_MAX, mpicom, ier)
+
+    ! Determine the total number of data per subgrid category
+    nvals     = nvals_per_col + 2
+
+    ! Determine the number of data to be sent/received by
+    ! local mpi rank and allocate memory
+    nblocks = max_ncol_global * nvals
+
+    ndata_send = nblocks*(bounds_proc%endg     - bounds_proc%begg     + 1)
+    ndata_recv = nblocks*(bounds_proc%endg_all - bounds_proc%begg_all + 1)
+
+    allocate(data_send(ndata_send))
+    allocate(data_recv(ndata_recv))
+
+    data_send = -9999.d0
+    ! Determine the rank of first landunit for a given grid cell
+    ! and given landunit type
+    !
+    ! NOTE: Assumption is that for subgrid category are contigously allocated
+    !       for a given landunit type.
+    !
+    allocate(lun_rank  (bounds_proc%begl_all:bounds_proc%endl_all))
+    allocate(grid_count(bounds_proc%begg_all:bounds_proc%endg_all))
+
+    lun_rank(:)   = 0.d0
+    grid_count(:) = 0.d0
+    last_lun_type   = -1
+
+    do l = bounds_proc%begl_all, bounds_proc%endl_all
+       g             = lun_pp%gridcell(l)
+
+       if (last_lun_type /= lun_pp%itype(l)) then
+          grid_count(:) = 0.d0
+          last_lun_type = lun_pp%itype(l)
+       endif
+       grid_count(g) = grid_count(g) + 1.d0
+       lun_rank(l)   = grid_count(g)
+    enddo
+
+    ! Aggregate the data to send
+    ncol = 0
+    do c = bounds_proc%begc, bounds_proc%endc
+
+       g = col_pp%gridcell(c)
+       l = col_pp%landunit(c)
+
+       beg_idx            = (g-bounds_proc%begg)*nblocks + ncol(g)*nvals + 1
+       data_send(beg_idx) = real(lun_pp%itype(l))
+
+       beg_idx            = beg_idx + 1
+       data_send(beg_idx) = lun_rank(l)
+
+       beg_idx = beg_idx + 1
+       end_idx = beg_idx + nvals_per_col - 1
+
+       begc_idx = (c-bounds_proc%begc)*nvals_per_col + 1
+       endc_idx = begc_idx + nvals_per_col -1
+
+       data_send(beg_idx:end_idx) = data_send_col(begc_idx:endc_idx)
+
+       ncol(g) = ncol(g) + 1
+    enddo
+
+    ! Scatter: Global-to-Local
+    call ScatterDataG2L(ldomain_lateral%ugrid, nblocks, ndata_send, data_send, ndata_recv, data_recv)
+
+    ! Save data for ghost subgrid category
+    c = bounds_proc%endc
+    do ltype = 1, max_lunit
+       do g = bounds_proc%endg + 1, bounds_proc%endg_all
+
+          do cidx = 0, max_ncol_local-1
+
+             beg_idx = (g-bounds_proc%begg)*nblocks + cidx*nvals + 1
+
+             col_ltype = int(data_recv(beg_idx))
+
+             beg_idx  = beg_idx + 1
+             l_rank   = int(data_recv(beg_idx))
+
+             if (col_ltype == ltype) then
+                c       = c + 1
+
+                beg_idx = beg_idx + 1
+                end_idx = beg_idx + nvals_per_col - 1
+
+                begc_idx = (c-bounds_proc%begc)*nvals_per_col + 1
+                endc_idx = begc_idx + nvals_per_col -1
+
+                data_recv_col(begc_idx:endc_idx) = data_recv(beg_idx:end_idx)
+
+             endif
+          enddo
+       enddo
+    enddo
+
+    ! Free up memory
+    deallocate(ncol           )
+    deallocate(lun_rank       )
+    deallocate(grid_count     )
+    deallocate(landunit_index )
+    deallocate(data_send      )
+    deallocate(data_recv      )
+
+  end subroutine ExchangeColumnLevelGhostData
+
+
+#else
+
   !-----------------------------------------------------------------------
   ! This is a stub for the case when PETSc is unavailable
   !
@@ -62,4 +608,6 @@ contains
 
   end subroutine domainlateral_init
 
+#endif
+
 end module domainLateralMod
diff --git a/components/elm/src/utils/domainMod.F90 b/components/elm/src/utils/domainMod.F90
index 7ecd3a523e..f956c290ba 100644
--- a/components/elm/src/utils/domainMod.F90
+++ b/components/elm/src/utils/domainMod.F90
@@ -1,24 +1,22 @@
 module domainMod
 !-----------------------------------------------------------------------
 !BOP
-!
+
 ! !MODULE: domainMod
-!
+
 ! !DESCRIPTION:
 ! Module containing 2-d global surface boundary data information
-!
+
 ! !USES:
   use shr_kind_mod, only : r8 => shr_kind_r8
+  use shr_sys_mod , only : shr_sys_abort
+  use spmdMod     , only : masterproc
   use elm_varctl  , only : iulog
-  use spmdMod  , only : masterproc
-  use shr_sys_mod, only : shr_sys_abort 
-  #define nan 1e36
 
-!
 ! !PUBLIC TYPES:
   implicit none
   private
-!
+
   public :: domain_type
 
   !--- this typically contains local domain info with arrays dim begg:endg ---
@@ -30,7 +28,7 @@ module domainMod
      character(len=8) :: elmlevel   ! grid type
      integer ,pointer :: mask(:)    ! land mask: 1 = land, 0 = ocean
      real(r8),pointer :: frac(:)    ! fractional land
-     real(r8),pointer :: topo(:)    ! topography
+     real(r8),pointer :: topo(:)    ! topography 
      integer ,pointer :: num_tunits_per_grd(:)    ! Number of topountis per grid to be used in subgrid decomposition
      real(r8),pointer :: latc(:)    ! latitude of grid cell (deg)
      real(r8),pointer :: lonc(:)    ! longitude of grid cell (deg)
@@ -60,36 +58,15 @@ module domainMod
   type(domain_type)    , public :: ldomain
   real(r8), allocatable, public :: lon1d(:), lat1d(:) ! 1d lat/lons for 2d grids
 
-  type, public :: domain_params_type
-     !! This is a type that holds only physically relevant fields of ldomain
-     !! Needed to workaround gpu compiler issues.  Alternative may be to pass ldomain
-     !! as arguments instead of by USE.
-     real(r8), pointer :: f_grd(:) 
-     real(r8), pointer :: f_surf(:)
-     real(r8), pointer :: firrig(:)
-     real(r8), pointer :: latc(:)    ! latitude of grid cell (deg)
-     real(r8), pointer :: lonc(:)    ! longitude of grid cell (deg)
-
-     !real(r8), pointer :: area(:)  !Only in CNPBudgetMod?
-     !real(r8), pointer :: frac(:)
-     integer, pointer :: glcmask(:)
-
-  end type domain_params_type
-
-  type(domain_params_type), public :: ldomain_gpu
-  !$acc declare create(ldomain_gpu)
-
 ! !PUBLIC MEMBER FUNCTIONS:
   public domain_init          ! allocates/nans domain types
   public domain_clean         ! deallocates domain types
   public domain_check         ! write out domain info
-  public :: domain_transfer
-!
+
 ! !REVISION HISTORY:
 ! Originally elm_varsur by Mariana Vertenstein
 ! Migrated from elm_varsur to domainMod by T Craig
-!
-!
+
 !EOP
 !------------------------------------------------------------------------------
 
@@ -97,35 +74,35 @@ contains
 
 !------------------------------------------------------------------------------
 !BOP
-!
+
 ! !IROUTINE: domain_init
-!
+
 ! !INTERFACE:
-subroutine domain_init(domain,isgrid2d,ni,nj,nbeg,nend,elmlevel)
-   !
-   ! !DESCRIPTION:
-   ! This subroutine allocates and nans the domain type
-   !
-   ! !USES:
-   !
-   ! !ARGUMENTS:
-   implicit none
-   type(domain_type)   :: domain        ! domain datatype
-   logical, intent(in) :: isgrid2d      ! true => global grid is lat/lon
-   integer, intent(in) :: ni,nj         ! grid size, 2d
-   integer         , intent(in), optional  :: nbeg,nend  ! beg/end indices
-   character(len=*), intent(in), optional  :: elmlevel   ! grid type
-   !
-   ! !REVISION HISTORY:
-   !   Created by T Craig
-   !
-   !
-   ! !LOCAL VARIABLES:
-   !EOP
-   integer :: ier
-   integer :: nb,ne
-   !
-   !------------------------------------------------------------------------------
+  subroutine domain_init(domain,isgrid2d,ni,nj,nbeg,nend,elmlevel)
+    use shr_infnan_mod, only : nan => shr_infnan_nan, assignment(=)
+
+! !DESCRIPTION:
+! This subroutine allocates and nans the domain type
+
+! !USES:
+
+! !ARGUMENTS:
+    implicit none
+    type(domain_type)   :: domain        ! domain datatype
+    logical, intent(in) :: isgrid2d      ! true => global grid is lat/lon
+    integer, intent(in) :: ni,nj         ! grid size, 2d
+    integer         , intent(in), optional  :: nbeg,nend  ! beg/end indices
+    character(len=*), intent(in), optional  :: elmlevel   ! grid type
+
+! !REVISION HISTORY:
+!   Created by T Craig
+
+! !LOCAL VARIABLES:
+!EOP
+    integer ier
+    integer nb,ne
+
+!------------------------------------------------------------------------------
 
     nb = 1
     ne = ni*nj
@@ -144,21 +121,25 @@ subroutine domain_init(domain,isgrid2d,ni,nj,nbeg,nend,elmlevel)
     endif
     allocate(domain%mask(nb:ne),domain%frac(nb:ne),domain%latc(nb:ne), &
              domain%pftm(nb:ne),domain%area(nb:ne),domain%firrig(nb:ne),domain%lonc(nb:ne), &
-             domain%topo(nb:ne),domain%f_surf(nb:ne),domain%f_grd(nb:ne),domain%glcmask(nb:ne), &
-             domain%num_tunits_per_grd(nb:ne), domain%xCell(nb:ne),domain%yCell(nb:ne),stat=ier)
-    if(ier /= 0) then 
-      call shr_sys_abort('domain_init ERROR: allocate mask, frac, lat, lon, area')
-    endif 
-    
+             domain%topo(nb:ne),domain%f_surf(nb:ne),domain%f_grd(nb:ne),domain%num_tunits_per_grd(nb:ne),domain%glcmask(nb:ne), &
+             domain%xCell(nb:ne),domain%yCell(nb:ne),stat=ier)
+    if (ier /= 0) then
+       call shr_sys_abort('domain_init ERROR: allocate mask, frac, lat, lon, area ')
+    endif
+
     ! pflotran:beg-----------------------------------------------------
     ! 'nv' is user-defined, so it must be initialized or assigned value prior to call this subroutine
     if (domain%nv > 0 .and. domain%nv /= huge(1)) then
        if(.not.associated(domain%lonv)) then
            allocate(domain%lonv(nb:ne, 1:domain%nv), stat=ier)
+           if (ier /= 0) &
+           call shr_sys_abort('domain_init ERROR: allocate lonv ')
            domain%lonv     = nan
        endif
        if(.not.associated(domain%latv)) then
            allocate(domain%latv(nb:ne, 1:domain%nv))
+           if (ier /= 0) &
+           call shr_sys_abort('domain_init ERROR: allocate latv ')
            domain%latv     = nan
        endif
     end if
@@ -183,7 +164,7 @@ subroutine domain_init(domain,isgrid2d,ni,nj,nbeg,nend,elmlevel)
     domain%xCell    = nan
     domain%yCell    = nan
     domain%area     = nan
-    domain%firrig   = 0.7_r8
+    domain%firrig   = 0.7_r8    
     domain%f_surf   = 1.0_r8
     domain%f_grd    = 0.0_r8
 
@@ -195,60 +176,66 @@ subroutine domain_init(domain,isgrid2d,ni,nj,nbeg,nend,elmlevel)
     endif
 
     domain%pftm     = -9999
-    domain%glcmask  = 0
+    domain%glcmask  = 0  
 
 end subroutine domain_init
 !------------------------------------------------------------------------------
 !BOP
-!
+
 ! !IROUTINE: domain_clean
-!
+
 ! !INTERFACE:
-subroutine domain_clean(domain)
-   !
-   ! !DESCRIPTION:
-   ! This subroutine deallocates the domain type
-   !
-   ! !ARGUMENTS:
-   implicit none
-   type(domain_type) :: domain        ! domain datatype
-   !
-   ! !REVISION HISTORY:
-   !   Created by T Craig
-   !
-   !
-   ! !LOCAL VARIABLES:
-   !EOP
-   integer :: ier
-   !
-   !------------------------------------------------------------------------------
-   if (domain%set) then
-      if (masterproc) then
-         write(iulog,*) 'domain_clean: cleaning ',domain%ni,domain%nj
-      endif
-      deallocate(domain%mask,domain%frac,domain%latc, &
-            domain%lonc,domain%area,domain%firrig,domain%pftm, &
-            domain%topo,domain%f_surf,domain%f_grd,domain%num_tunits_per_grd,domain%glcmask, &
-            domain%xCell,domain%yCell,stat=ier)
-
-      ! pflotran:beg-----------------------------------------------------
-      ! 'nv' is user-defined, so it must be initialized or assigned value prior to call this subroutine
-      if (domain%nv > 0 .and. domain%nv /= huge(1)) then
-         if (associated(domain%lonv)) then
-            deallocate(domain%lonv, stat=ier)
-            nullify(domain%lonv)
-         endif
-
-         if (associated(domain%latv)) then
-            deallocate(domain%latv, stat=ier)
-            nullify(domain%latv)
-         endif
-      endif
+  subroutine domain_clean(domain)
+
+! !DESCRIPTION:
+! This subroutine deallocates the domain type
+
+! !ARGUMENTS:
+    implicit none
+    type(domain_type) :: domain        ! domain datatype
+
+! !REVISION HISTORY:
+!   Created by T Craig
+
+! !LOCAL VARIABLES:
+!EOP
+    integer ier
+!
+!------------------------------------------------------------------------------
+    if (domain%set) then
+       if (masterproc) then
+          write(iulog,*) 'domain_clean: cleaning ',domain%ni,domain%nj
+       endif
+       deallocate(domain%mask,domain%frac,domain%latc, &
+             domain%pftm,domain%area,domain%firrig,domain%lonc, &
+             domain%topo,domain%f_surf,domain%f_grd,domain%num_tunits_per_grd,domain%glcmask, &
+             domain%xCell,domain%yCell,stat=ier)
+       if (ier /= 0) then
+          call shr_sys_abort('domain_clean ERROR: deallocate mask, frac, lat, lon, area ')
+       endif
+
+       ! pflotran:beg-----------------------------------------------------
+       ! 'nv' is user-defined, so it must be initialized or assigned value prior to call this subroutine
+       if (domain%nv > 0 .and. domain%nv /= huge(1)) then
+          if (associated(domain%lonv)) then
+             deallocate(domain%lonv, stat=ier)
+             if (ier /= 0) &
+             call shr_sys_abort('domain_clean ERROR: deallocate lonv ')
+             nullify(domain%lonv)
+          endif
+
+          if (associated(domain%latv)) then
+             deallocate(domain%latv, stat=ier)
+             if (ier /= 0) &
+             call shr_sys_abort('domain_clean ERROR: deallocate latv ')
+             nullify(domain%latv)
+          endif
+       endif
        ! pflotran:beg-----------------------------------------------------
 
     else
        if (masterproc) then
-         write(iulog,*) 'domain_clean WARN: clean domain unecessary '
+          write(iulog,*) 'domain_clean WARN: clean domain unecessary '
        endif
     endif
 
@@ -264,76 +251,53 @@ subroutine domain_clean(domain)
 end subroutine domain_clean
 !------------------------------------------------------------------------------
 !BOP
-!
+
 ! !IROUTINE: domain_check
-!
+
 ! !INTERFACE:
-subroutine domain_check(domain)
-   !
-   ! !DESCRIPTION:
-   ! This subroutine write domain info
-   !
-   ! !USES:
-   !
-   ! !ARGUMENTS:
-   implicit none
-   type(domain_type),intent(in)  :: domain ! domain datatype
-   !
-   ! !REVISION HISTORY:
-   !   Created by T Craig
-   !
-   !
-   ! !LOCAL VARIABLES:
-   !
-   !EOP
-   !------------------------------------------------------------------------------
-
-   if (masterproc) then
-      write(iulog,*) '  domain_check set       = ',domain%set
-      write(iulog,*) '  domain_check decomped  = ',domain%decomped
-      write(iulog,*) '  domain_check ns        = ',domain%ns
-      write(iulog,*) '  domain_check ni,nj     = ',domain%ni,domain%nj
-      write(iulog,*) '  domain_check elmlevel  = ',trim(domain%elmlevel)
-      write(iulog,*) '  domain_check nbeg,nend = ',domain%nbeg,domain%nend
-      write(iulog,*) '  domain_check lonc      = ',minval(domain%lonc),maxval(domain%lonc)
-      write(iulog,*) '  domain_check latc      = ',minval(domain%latc),maxval(domain%latc)
-      write(iulog,*) '  domain_check mask      = ',minval(domain%mask),maxval(domain%mask)
-      write(iulog,*) '  domain_check frac      = ',minval(domain%frac),maxval(domain%frac)
-      write(iulog,*) '  domain_check topo      = ',minval(domain%topo),maxval(domain%topo)
-      write(iulog,*) '  domain_check num_tunits_per_grd      = ',minval(domain%num_tunits_per_grd),maxval(domain%num_tunits_per_grd)
-      write(iulog,*) '  domain_check firrig    = ',minval(domain%firrig),maxval(domain%firrig)
-      write(iulog,*) '  domain_check f_surf    = ',minval(domain%f_surf),maxval(domain%f_surf)
-      write(iulog,*) '  domain_check f_grd     = ',minval(domain%f_grd),maxval(domain%f_grd)
-      write(iulog,*) '  domain_check area      = ',minval(domain%area),maxval(domain%area)
-      write(iulog,*) '  domain_check pftm      = ',minval(domain%pftm),maxval(domain%pftm)
-      write(iulog,*) '  domain_check glcmask   = ',minval(domain%glcmask),maxval(domain%glcmask)
-      write(iulog,*) ' '
-   endif
+  subroutine domain_check(domain)
 
-end subroutine domain_check
+! !DESCRIPTION:
+! This subroutine write domain info
+
+! !USES:
 
-subroutine domain_transfer()
+! !ARGUMENTS:
+    implicit none
+    type(domain_type),intent(in)  :: domain        ! domain datatype
 
-   implicit none
-   integer :: nend
+! !REVISION HISTORY:
+!   Created by T Craig
 
-   nend = ubound(ldomain%f_grd,1)
+! !LOCAL VARIABLES:
+!
+!EOP
+!------------------------------------------------------------------------------
 
-   allocate(ldomain_gpu%f_grd  (1:nend) )
-   allocate(ldomain_gpu%f_surf (1:nend) )
-   allocate(ldomain_gpu%firrig (1:nend) )
-   allocate(ldomain_gpu%glcmask(1:nend) )
-   allocate(ldomain_gpu%latc(1:nend))
-   allocate(ldomain_gpu%lonc(1:nend))
-   ldomain_gpu%f_grd(:)  = ldomain%f_grd(:)
-   ldomain_gpu%f_surf(:)  = ldomain%f_surf(:)
-   ldomain_gpu%firrig(:)  = ldomain%firrig(:)
-   ldomain_gpu%glcmask(:) = ldomain%glcmask(:)
-   ldomain_gpu%latc(:) = ldomain%latc(:)
-   ldomain_gpu%lonc(:) = ldomain%lonc(:)
+  if (masterproc) then
+    write(iulog,*) '  domain_check set       = ',domain%set
+    write(iulog,*) '  domain_check decomped  = ',domain%decomped
+    write(iulog,*) '  domain_check ns        = ',domain%ns
+    write(iulog,*) '  domain_check ni,nj     = ',domain%ni,domain%nj
+    write(iulog,*) '  domain_check elmlevel  = ',trim(domain%elmlevel)
+    write(iulog,*) '  domain_check nbeg,nend = ',domain%nbeg,domain%nend
+    write(iulog,*) '  domain_check lonc      = ',minval(domain%lonc),maxval(domain%lonc)
+    write(iulog,*) '  domain_check latc      = ',minval(domain%latc),maxval(domain%latc)
+    write(iulog,*) '  domain_check mask      = ',minval(domain%mask),maxval(domain%mask)
+    write(iulog,*) '  domain_check frac      = ',minval(domain%frac),maxval(domain%frac)
+    write(iulog,*) '  domain_check topo      = ',minval(domain%topo),maxval(domain%topo)
+    write(iulog,*) '  domain_check num_tunits_per_grd      = ',minval(domain%num_tunits_per_grd),maxval(domain%num_tunits_per_grd)
+    write(iulog,*) '  domain_check firrig    = ',minval(domain%firrig),maxval(domain%firrig)
+    write(iulog,*) '  domain_check f_surf    = ',minval(domain%f_surf),maxval(domain%f_surf)
+    write(iulog,*) '  domain_check f_grd     = ',minval(domain%f_grd),maxval(domain%f_grd)
+    write(iulog,*) '  domain_check area      = ',minval(domain%area),maxval(domain%area)
+    write(iulog,*) '  domain_check pftm      = ',minval(domain%pftm),maxval(domain%pftm)
+    write(iulog,*) '  domain_check glcmask   = ',minval(domain%glcmask),maxval(domain%glcmask)
+    write(iulog,*) ' '
+  endif
 
-end subroutine domain_transfer
+end subroutine domain_check
 
 !------------------------------------------------------------------------------
 
-end module domainMod
\ No newline at end of file
+end module domainMod
diff --git a/components/elm/src/utils/quadraticMod.F90 b/components/elm/src/utils/quadraticMod.F90
index 2564f7fcd2..890d3da421 100644
--- a/components/elm/src/utils/quadraticMod.F90
+++ b/components/elm/src/utils/quadraticMod.F90
@@ -22,7 +22,7 @@ contains
      !
      ! !REVISION HISTORY:
      ! 4/5/10: Adapted from /home/bonan/ecm/psn/An_gs_iterative.f90 by Keith Oleson
-     !$acc routine seq
+     !
      ! !USES:
      implicit none
      !
@@ -33,19 +33,18 @@ contains
      ! !LOCAL VARIABLES:
      real(r8) :: q                        ! Temporary term for quadratic solution
      !------------------------------------------------------------------------------
-#ifndef _OPENACC
+    
      if (a == 0._r8) then
         write (iulog,*) 'Quadratic solution error: a = ',a
         call endrun(msg=errmsg(__FILE__, __LINE__))
      end if
-#endif
-
+   
      if (b >= 0._r8) then
         q = -0.5_r8 * (b + sqrt(b*b - 4._r8*a*c))
      else
         q = -0.5_r8 * (b - sqrt(b*b - 4._r8*a*c))
      end if
-
+   
      r1 = q / a
      if (q /= 0._r8) then
         r2 = c / q
diff --git a/components/elm/src/utils/shr_orb_mod_elm.F90 b/components/elm/src/utils/shr_orb_mod_elm.F90
deleted file mode 100644
index 934dd9ba27..0000000000
--- a/components/elm/src/utils/shr_orb_mod_elm.F90
+++ /dev/null
@@ -1,784 +0,0 @@
-MODULE shr_orb_mod_elm
-
-  use shr_kind_mod, only: SHR_KIND_R8, SHR_KIND_IN
-  use shr_sys_mod
-  use shr_const_mod
-  use shr_log_mod, only: s_loglev  => shr_log_Level
-  use shr_log_mod, only: s_logunit => shr_log_Unit
-
-  IMPLICIT none
-
-  !----------------------------------------------------------------------------
-  ! PUBLIC: Interfaces and global data
-  !----------------------------------------------------------------------------
-  public :: shr_orb_cosz
-  public :: shr_orb_params
-  public :: shr_orb_decl
-  public :: shr_orb_print
-
-  real   (SHR_KIND_R8),public,parameter :: SHR_ORB_UNDEF_REAL = 1.e36_SHR_KIND_R8 ! undefined real
-  integer(SHR_KIND_IN),public,parameter :: SHR_ORB_UNDEF_INT  = 2000000000        ! undefined int
-
-  !----------------------------------------------------------------------------
-  ! PRIVATE: by default everything else is private to this module
-  !----------------------------------------------------------------------------
-  private
-
-  real   (SHR_KIND_R8),parameter :: pi                 = SHR_CONST_PI
-  real   (SHR_KIND_R8),parameter :: SHR_ORB_ECCEN_MIN  =   0.0_SHR_KIND_R8 ! min value for eccen
-  real   (SHR_KIND_R8),parameter :: SHR_ORB_ECCEN_MAX  =   0.1_SHR_KIND_R8 ! max value for eccen
-  real   (SHR_KIND_R8),parameter :: SHR_ORB_OBLIQ_MIN  = -90.0_SHR_KIND_R8 ! min value for obliq
-  real   (SHR_KIND_R8),parameter :: SHR_ORB_OBLIQ_MAX  = +90.0_SHR_KIND_R8 ! max value for obliq
-  real   (SHR_KIND_R8),parameter :: SHR_ORB_MVELP_MIN  =   0.0_SHR_KIND_R8 ! min value for mvelp
-  real   (SHR_KIND_R8),parameter :: SHR_ORB_MVELP_MAX  = 360.0_SHR_KIND_R8 ! max value for mvelp
-  !===============================================================================
-CONTAINS
-  !===============================================================================
-
-  real(SHR_KIND_R8) pure FUNCTION shr_orb_cosz(jday,lat,lon,declin,dt_avg)
-    !$acc routine seq
-    !----------------------------------------------------------------------------
-    !
-    ! FUNCTION to return the cosine of the solar zenith angle.
-    ! Assumes 365.0 days/year.
-    !
-    !--------------- Code History -----------------------------------------------
-    !
-    ! Original Author: Brian Kauffman
-    ! Date:            Jan/98
-    ! History:         adapted from statement FUNCTION in share/orb_cosz.h
-    !
-    !----------------------------------------------------------------------------
-
-    real   (SHR_KIND_R8),intent(in) :: jday   ! Julian cal day (1.xx to 365.xx)
-    real   (SHR_KIND_R8),intent(in) :: lat    ! Centered latitude (radians)
-    real   (SHR_KIND_R8),intent(in) :: lon    ! Centered longitude (radians)
-    real   (SHR_KIND_R8),intent(in) :: declin ! Solar declination (radians)
-    real   (SHR_KIND_R8),intent(in), optional   :: dt_avg ! if present and set non-zero, then use in the
-    ! average cosz calculation
-    logical :: use_dt_avg
-
-    !----------------------------------------------------------------------------
-
-    use_dt_avg = .false.
-    if (present(dt_avg)) then
-       if (dt_avg /= 0.0_shr_kind_r8) use_dt_avg = .true.
-    end if
-
-
-    ! If dt for the average cosz is specified, then call the shr_orb_avg_cosz
-    if (use_dt_avg) then
-       shr_orb_cosz =  shr_orb_avg_cosz(jday, lat, lon, declin, dt_avg)
-    else
-       shr_orb_cosz = sin(lat)*sin(declin) - &
-            cos(lat)*cos(declin) * &
-            cos((jday-floor(jday))*2.0_SHR_KIND_R8*pi + lon)
-    end if
-
-  END FUNCTION shr_orb_cosz
-
-  !=======================================================================
-  ! A New Algorithm for Calculation of Cosine Solar Zenith Angle
-  ! Author: Linjiong Zhou
-  ! E-mail: linjiongzhou@hotmail.com
-  ! Date  : 2015.02.22
-  ! Ref.  : Zhou et al., GRL, 2015
-  !=======================================================================
-
-  real (SHR_KIND_R8) pure function shr_orb_avg_cosz(jday, lat, lon, declin, dt_avg)
-    !$acc routine seq
-
-    implicit none
-
-    !-----------------------------------------------------------------------
-    ! In/Out Arguements
-
-    real(SHR_KIND_R8), intent(in) :: jday   ! Julian calendar day (1.xx to 365.xx)
-    real(SHR_KIND_R8), intent(in) :: lat    ! latitude (radian)
-    real(SHR_KIND_R8), intent(in) :: lon    ! longitude (radian)
-    real(SHR_KIND_R8), intent(in) :: declin ! solar declination (radian)
-    real(SHR_KIND_R8), intent(in) :: dt_avg ! dt for averaged cosz calculation
-
-    !-----------------------------------------------------------------------
-    ! Local Arguments
-
-    real(SHR_KIND_R8),parameter :: piover2 = pi/2.0_SHR_KIND_R8
-    real(SHR_KIND_R8),parameter :: twopi   = pi*2.0_SHR_KIND_R8
-
-    real(SHR_KIND_R8) :: aa, bb
-    real(SHR_KIND_R8) :: del, phi
-    real(SHR_KIND_R8) :: cos_h, h
-    real(SHR_KIND_R8) :: t1, t2, dt
-    real(SHR_KIND_R8) :: tt1, tt2, tt3, tt4
-
-    !-----------------------------------------------------------------------
-    ! Compute Half-day Length
-
-    ! adjust latitude so that its tangent will be defined
-    if (lat ==  piover2) then
-       del = lat - 1.0e-05_SHR_KIND_R8
-    else if (lat ==  -piover2) then
-       del = lat + 1.0e-05_SHR_KIND_R8
-    else
-       del = lat
-    end if
-
-    ! adjust declination so that its tangent will be defined
-    if (declin == piover2) then
-       phi = declin - 1.0e-05_SHR_KIND_R8
-    else if (declin == -piover2) then
-       phi = declin + 1.0e-05_SHR_KIND_R8
-    else
-       phi = declin
-    end if
-
-    ! define the cosine of the half-day length
-    ! adjust for cases of all daylight or all night
-    cos_h = - tan(del) * tan(phi)
-    if (cos_h <= -1.0_SHR_KIND_R8) then
-       h = pi
-    else if (cos_h >= 1.0_SHR_KIND_R8) then
-       h = 0.0_SHR_KIND_R8
-    else
-       h = acos(cos_h)
-    end if
-
-    !-----------------------------------------------------------------------
-    ! Define Local Time t and t + dt
-
-    ! adjust t to be between -pi and pi
-    t1 = (jday - int(jday)) * twopi + lon - pi
-
-    if (t1 >=  pi) then
-       t1 = t1 - twopi
-    else if (t1 < -pi) then
-       t1 = t1 + twopi
-    end if
-
-    dt = dt_avg / 86400.0_SHR_KIND_R8 * twopi
-    t2 = t1 + dt
-
-    !-----------------------------------------------------------------------
-    ! Compute Cosine Solar Zenith angle
-
-    ! define terms needed in the cosine zenith angle equation
-    aa = sin(lat) * sin(declin)
-    bb = cos(lat) * cos(declin)
-
-    ! define the hour angle
-    ! force it to be between -h and h
-    ! consider the situation when the night period is too short
-    if (t2 >= pi .and. t1 <= pi .and. pi - h <= dt) then
-       tt2 = h
-       tt1 = min(max(t1, -h)       ,         h)
-       tt4 = min(max(t2, twopi - h), twopi + h)
-       tt3 = twopi - h
-    else if (t2 >= -pi .and. t1 <= -pi .and. pi - h <= dt) then
-       tt2 = - twopi + h
-       tt1 = min(max(t1, -twopi - h), -twopi + h)
-       tt4 = min(max(t2, -h)        ,          h)
-       tt3 = -h
-    else
-       if (t2 > pi) then
-          tt2 = min(max(t2 - twopi, -h), h)
-       else if (t2 < - pi) then
-          tt2 = min(max(t2 + twopi, -h), h)
-       else
-          tt2 = min(max(t2 ,        -h), h)
-       end if
-       if (t1 > pi) then
-          tt1 = min(max(t1 - twopi, -h), h)
-       else if (t1 < - pi) then
-          tt1 = min(max(t1 + twopi, -h), h)
-       else
-          tt1 = min(max(t1        , -h), h)
-       end if
-       tt4 = 0.0_SHR_KIND_R8
-       tt3 = 0.0_SHR_KIND_R8
-    end if
-
-    ! perform a time integration to obtain cosz if desired
-    ! output is valid over the period from t to t + dt
-    if (tt2 > tt1 .or. tt4 > tt3) then
-       shr_orb_avg_cosz = (aa * (tt2 - tt1) + bb * (sin(tt2) - sin(tt1))) / dt + &
-            (aa * (tt4 - tt3) + bb * (sin(tt4) - sin(tt3))) / dt
-    else
-       shr_orb_avg_cosz = 0.0_SHR_KIND_R8
-    end if
-
-  end function shr_orb_avg_cosz
-
-  !===============================================================================
-
-  SUBROUTINE shr_orb_params( iyear_AD , eccen  , obliq , mvelp     ,     &
-       &               obliqr   , lambm0 , mvelpp, log_print )
-
-    !-------------------------------------------------------------------------------
-    !
-    ! Calculate earths orbital parameters using Dave Threshers formula which
-    ! came from Berger, Andre.  1978  "A Simple Algorithm to Compute Long-Term
-    ! Variations of Daily Insolation".  Contribution 18, Institute of Astronomy
-    ! and Geophysics, Universite Catholique de Louvain, Louvain-la-Neuve, Belgium
-    !
-    !------------------------------Code history-------------------------------------
-    !
-    ! Original Author: Erik Kluzek
-    ! Date:            Oct/97
-    !
-    !-------------------------------------------------------------------------------
-
-    !----------------------------- Arguments ------------------------------------
-    integer(SHR_KIND_IN),intent(in)    :: iyear_AD  ! Year to calculate orbit for
-    real   (SHR_KIND_R8),intent(inout) :: eccen     ! orbital eccentricity
-    real   (SHR_KIND_R8),intent(inout) :: obliq     ! obliquity in degrees
-    real   (SHR_KIND_R8),intent(inout) :: mvelp     ! moving vernal equinox long
-    real   (SHR_KIND_R8),intent(out)   :: obliqr    ! Earths obliquity in rad
-    real   (SHR_KIND_R8),intent(out)   :: lambm0    ! Mean long of perihelion at
-    ! vernal equinox (radians)
-    real   (SHR_KIND_R8),intent(out)   :: mvelpp    ! moving vernal equinox long
-    ! of perihelion plus pi (rad)
-    logical             ,intent(in)    :: log_print ! Flags print of status/error
-
-    !------------------------------ Parameters ----------------------------------
-    integer(SHR_KIND_IN),parameter :: poblen =47 ! # of elements in series wrt obliquity
-    integer(SHR_KIND_IN),parameter :: pecclen=19 ! # of elements in series wrt eccentricity
-    integer(SHR_KIND_IN),parameter :: pmvelen=78 ! # of elements in series wrt vernal equinox
-    real   (SHR_KIND_R8),parameter :: psecdeg = 1.0_SHR_KIND_R8/3600.0_SHR_KIND_R8 ! arc sec to deg conversion
-
-    real   (SHR_KIND_R8) :: degrad = pi/180._SHR_KIND_R8   ! degree to radian conversion factor
-    real   (SHR_KIND_R8) :: yb4_1950AD         ! number of years before 1950 AD
-
-    character(len=*),parameter :: subname = '(shr_orb_params)'
-
-    ! Cosine series data for computation of obliquity: amplitude (arc seconds),
-    ! rate (arc seconds/year), phase (degrees).
-
-    real   (SHR_KIND_R8), parameter :: obamp(poblen) =  & ! amplitudes for obliquity cos series
-         &      (/   -2462.2214466_SHR_KIND_R8, -857.3232075_SHR_KIND_R8, -629.3231835_SHR_KIND_R8,   &
-         &            -414.2804924_SHR_KIND_R8, -311.7632587_SHR_KIND_R8,  308.9408604_SHR_KIND_R8,   &
-         &            -162.5533601_SHR_KIND_R8, -116.1077911_SHR_KIND_R8,  101.1189923_SHR_KIND_R8,   &
-         &             -67.6856209_SHR_KIND_R8,   24.9079067_SHR_KIND_R8,   22.5811241_SHR_KIND_R8,   &
-         &             -21.1648355_SHR_KIND_R8,  -15.6549876_SHR_KIND_R8,   15.3936813_SHR_KIND_R8,   &
-         &              14.6660938_SHR_KIND_R8,  -11.7273029_SHR_KIND_R8,   10.2742696_SHR_KIND_R8,   &
-         &               6.4914588_SHR_KIND_R8,    5.8539148_SHR_KIND_R8,   -5.4872205_SHR_KIND_R8,   &
-         &              -5.4290191_SHR_KIND_R8,    5.1609570_SHR_KIND_R8,    5.0786314_SHR_KIND_R8,   &
-         &              -4.0735782_SHR_KIND_R8,    3.7227167_SHR_KIND_R8,    3.3971932_SHR_KIND_R8,   &
-         &              -2.8347004_SHR_KIND_R8,   -2.6550721_SHR_KIND_R8,   -2.5717867_SHR_KIND_R8,   &
-         &              -2.4712188_SHR_KIND_R8,    2.4625410_SHR_KIND_R8,    2.2464112_SHR_KIND_R8,   &
-         &              -2.0755511_SHR_KIND_R8,   -1.9713669_SHR_KIND_R8,   -1.8813061_SHR_KIND_R8,   &
-         &              -1.8468785_SHR_KIND_R8,    1.8186742_SHR_KIND_R8,    1.7601888_SHR_KIND_R8,   &
-         &              -1.5428851_SHR_KIND_R8,    1.4738838_SHR_KIND_R8,   -1.4593669_SHR_KIND_R8,   &
-         &               1.4192259_SHR_KIND_R8,   -1.1818980_SHR_KIND_R8,    1.1756474_SHR_KIND_R8,   &
-         &              -1.1316126_SHR_KIND_R8,    1.0896928_SHR_KIND_R8/)
-
-    real   (SHR_KIND_R8), parameter :: obrate(poblen) = & ! rates for obliquity cosine series
-         &        (/  31.609974_SHR_KIND_R8, 32.620504_SHR_KIND_R8, 24.172203_SHR_KIND_R8,   &
-         &            31.983787_SHR_KIND_R8, 44.828336_SHR_KIND_R8, 30.973257_SHR_KIND_R8,   &
-         &            43.668246_SHR_KIND_R8, 32.246691_SHR_KIND_R8, 30.599444_SHR_KIND_R8,   &
-         &            42.681324_SHR_KIND_R8, 43.836462_SHR_KIND_R8, 47.439436_SHR_KIND_R8,   &
-         &            63.219948_SHR_KIND_R8, 64.230478_SHR_KIND_R8,  1.010530_SHR_KIND_R8,   &
-         &             7.437771_SHR_KIND_R8, 55.782177_SHR_KIND_R8,  0.373813_SHR_KIND_R8,   &
-         &            13.218362_SHR_KIND_R8, 62.583231_SHR_KIND_R8, 63.593761_SHR_KIND_R8,   &
-         &            76.438310_SHR_KIND_R8, 45.815258_SHR_KIND_R8,  8.448301_SHR_KIND_R8,   &
-         &            56.792707_SHR_KIND_R8, 49.747842_SHR_KIND_R8, 12.058272_SHR_KIND_R8,   &
-         &            75.278220_SHR_KIND_R8, 65.241008_SHR_KIND_R8, 64.604291_SHR_KIND_R8,   &
-         &             1.647247_SHR_KIND_R8,  7.811584_SHR_KIND_R8, 12.207832_SHR_KIND_R8,   &
-         &            63.856665_SHR_KIND_R8, 56.155990_SHR_KIND_R8, 77.448840_SHR_KIND_R8,   &
-         &             6.801054_SHR_KIND_R8, 62.209418_SHR_KIND_R8, 20.656133_SHR_KIND_R8,   &
-         &            48.344406_SHR_KIND_R8, 55.145460_SHR_KIND_R8, 69.000539_SHR_KIND_R8,   &
-         &            11.071350_SHR_KIND_R8, 74.291298_SHR_KIND_R8, 11.047742_SHR_KIND_R8,   &
-         &             0.636717_SHR_KIND_R8, 12.844549_SHR_KIND_R8/)
-
-    real   (SHR_KIND_R8), parameter :: obphas(poblen) = & ! phases for obliquity cosine series
-         &      (/    251.9025_SHR_KIND_R8, 280.8325_SHR_KIND_R8, 128.3057_SHR_KIND_R8,   &
-         &            292.7252_SHR_KIND_R8,  15.3747_SHR_KIND_R8, 263.7951_SHR_KIND_R8,   &
-         &            308.4258_SHR_KIND_R8, 240.0099_SHR_KIND_R8, 222.9725_SHR_KIND_R8,   &
-         &            268.7809_SHR_KIND_R8, 316.7998_SHR_KIND_R8, 319.6024_SHR_KIND_R8,   &
-         &            143.8050_SHR_KIND_R8, 172.7351_SHR_KIND_R8,  28.9300_SHR_KIND_R8,   &
-         &            123.5968_SHR_KIND_R8,  20.2082_SHR_KIND_R8,  40.8226_SHR_KIND_R8,   &
-         &            123.4722_SHR_KIND_R8, 155.6977_SHR_KIND_R8, 184.6277_SHR_KIND_R8,   &
-         &            267.2772_SHR_KIND_R8,  55.0196_SHR_KIND_R8, 152.5268_SHR_KIND_R8,   &
-         &             49.1382_SHR_KIND_R8, 204.6609_SHR_KIND_R8,  56.5233_SHR_KIND_R8,   &
-         &            200.3284_SHR_KIND_R8, 201.6651_SHR_KIND_R8, 213.5577_SHR_KIND_R8,   &
-         &             17.0374_SHR_KIND_R8, 164.4194_SHR_KIND_R8,  94.5422_SHR_KIND_R8,   &
-         &            131.9124_SHR_KIND_R8,  61.0309_SHR_KIND_R8, 296.2073_SHR_KIND_R8,   &
-         &            135.4894_SHR_KIND_R8, 114.8750_SHR_KIND_R8, 247.0691_SHR_KIND_R8,   &
-         &            256.6114_SHR_KIND_R8,  32.1008_SHR_KIND_R8, 143.6804_SHR_KIND_R8,   &
-         &             16.8784_SHR_KIND_R8, 160.6835_SHR_KIND_R8,  27.5932_SHR_KIND_R8,   &
-         &            348.1074_SHR_KIND_R8,  82.6496_SHR_KIND_R8/)
-
-    ! Cosine/sine series data for computation of eccentricity and fixed vernal
-    ! equinox longitude of perihelion (fvelp): amplitude,
-    ! rate (arc seconds/year), phase (degrees).
-
-    real   (SHR_KIND_R8), parameter :: ecamp (pecclen) = & ! ampl for eccen/fvelp cos/sin series
-         &      (/   0.01860798_SHR_KIND_R8,  0.01627522_SHR_KIND_R8, -0.01300660_SHR_KIND_R8,   &
-         &           0.00988829_SHR_KIND_R8, -0.00336700_SHR_KIND_R8,  0.00333077_SHR_KIND_R8,   &
-         &          -0.00235400_SHR_KIND_R8,  0.00140015_SHR_KIND_R8,  0.00100700_SHR_KIND_R8,   &
-         &           0.00085700_SHR_KIND_R8,  0.00064990_SHR_KIND_R8,  0.00059900_SHR_KIND_R8,   &
-         &           0.00037800_SHR_KIND_R8, -0.00033700_SHR_KIND_R8,  0.00027600_SHR_KIND_R8,   &
-         &           0.00018200_SHR_KIND_R8, -0.00017400_SHR_KIND_R8, -0.00012400_SHR_KIND_R8,   &
-         &           0.00001250_SHR_KIND_R8/)
-
-    real   (SHR_KIND_R8), parameter :: ecrate(pecclen) = & ! rates for eccen/fvelp cos/sin series
-         &      (/    4.2072050_SHR_KIND_R8,  7.3460910_SHR_KIND_R8, 17.8572630_SHR_KIND_R8,  &
-         &           17.2205460_SHR_KIND_R8, 16.8467330_SHR_KIND_R8,  5.1990790_SHR_KIND_R8,  &
-         &           18.2310760_SHR_KIND_R8, 26.2167580_SHR_KIND_R8,  6.3591690_SHR_KIND_R8,  &
-         &           16.2100160_SHR_KIND_R8,  3.0651810_SHR_KIND_R8, 16.5838290_SHR_KIND_R8,  &
-         &           18.4939800_SHR_KIND_R8,  6.1909530_SHR_KIND_R8, 18.8677930_SHR_KIND_R8,  &
-         &           17.4255670_SHR_KIND_R8,  6.1860010_SHR_KIND_R8, 18.4174410_SHR_KIND_R8,  &
-         &            0.6678630_SHR_KIND_R8/)
-
-    real   (SHR_KIND_R8), parameter :: ecphas(pecclen) = & ! phases for eccen/fvelp cos/sin series
-         &      (/    28.620089_SHR_KIND_R8, 193.788772_SHR_KIND_R8, 308.307024_SHR_KIND_R8,  &
-         &           320.199637_SHR_KIND_R8, 279.376984_SHR_KIND_R8,  87.195000_SHR_KIND_R8,  &
-         &           349.129677_SHR_KIND_R8, 128.443387_SHR_KIND_R8, 154.143880_SHR_KIND_R8,  &
-         &           291.269597_SHR_KIND_R8, 114.860583_SHR_KIND_R8, 332.092251_SHR_KIND_R8,  &
-         &           296.414411_SHR_KIND_R8, 145.769910_SHR_KIND_R8, 337.237063_SHR_KIND_R8,  &
-         &           152.092288_SHR_KIND_R8, 126.839891_SHR_KIND_R8, 210.667199_SHR_KIND_R8,  &
-         &            72.108838_SHR_KIND_R8/)
-
-    ! Sine series data for computation of moving vernal equinox longitude of
-    ! perihelion: amplitude (arc seconds), rate (arc sec/year), phase (degrees).
-
-    real   (SHR_KIND_R8), parameter :: mvamp (pmvelen) = & ! amplitudes for mvelp sine series
-         &      (/   7391.0225890_SHR_KIND_R8, 2555.1526947_SHR_KIND_R8, 2022.7629188_SHR_KIND_R8,  &
-         &          -1973.6517951_SHR_KIND_R8, 1240.2321818_SHR_KIND_R8,  953.8679112_SHR_KIND_R8,  &
-         &           -931.7537108_SHR_KIND_R8,  872.3795383_SHR_KIND_R8,  606.3544732_SHR_KIND_R8,  &
-         &           -496.0274038_SHR_KIND_R8,  456.9608039_SHR_KIND_R8,  346.9462320_SHR_KIND_R8,  &
-         &           -305.8412902_SHR_KIND_R8,  249.6173246_SHR_KIND_R8, -199.1027200_SHR_KIND_R8,  &
-         &            191.0560889_SHR_KIND_R8, -175.2936572_SHR_KIND_R8,  165.9068833_SHR_KIND_R8,  &
-         &            161.1285917_SHR_KIND_R8,  139.7878093_SHR_KIND_R8, -133.5228399_SHR_KIND_R8,  &
-         &            117.0673811_SHR_KIND_R8,  104.6907281_SHR_KIND_R8,   95.3227476_SHR_KIND_R8,  &
-         &             86.7824524_SHR_KIND_R8,   86.0857729_SHR_KIND_R8,   70.5893698_SHR_KIND_R8,  &
-         &            -69.9719343_SHR_KIND_R8,  -62.5817473_SHR_KIND_R8,   61.5450059_SHR_KIND_R8,  &
-         &            -57.9364011_SHR_KIND_R8,   57.1899832_SHR_KIND_R8,  -57.0236109_SHR_KIND_R8,  &
-         &            -54.2119253_SHR_KIND_R8,   53.2834147_SHR_KIND_R8,   52.1223575_SHR_KIND_R8,  &
-         &            -49.0059908_SHR_KIND_R8,  -48.3118757_SHR_KIND_R8,  -45.4191685_SHR_KIND_R8,  &
-         &            -42.2357920_SHR_KIND_R8,  -34.7971099_SHR_KIND_R8,   34.4623613_SHR_KIND_R8,  &
-         &            -33.8356643_SHR_KIND_R8,   33.6689362_SHR_KIND_R8,  -31.2521586_SHR_KIND_R8,  &
-         &            -30.8798701_SHR_KIND_R8,   28.4640769_SHR_KIND_R8,  -27.1960802_SHR_KIND_R8,  &
-         &             27.0860736_SHR_KIND_R8,  -26.3437456_SHR_KIND_R8,   24.7253740_SHR_KIND_R8,  &
-         &             24.6732126_SHR_KIND_R8,   24.4272733_SHR_KIND_R8,   24.0127327_SHR_KIND_R8,  &
-         &             21.7150294_SHR_KIND_R8,  -21.5375347_SHR_KIND_R8,   18.1148363_SHR_KIND_R8,  &
-         &            -16.9603104_SHR_KIND_R8,  -16.1765215_SHR_KIND_R8,   15.5567653_SHR_KIND_R8,  &
-         &             15.4846529_SHR_KIND_R8,   15.2150632_SHR_KIND_R8,   14.5047426_SHR_KIND_R8,  &
-         &            -14.3873316_SHR_KIND_R8,   13.1351419_SHR_KIND_R8,   12.8776311_SHR_KIND_R8,  &
-         &             11.9867234_SHR_KIND_R8,   11.9385578_SHR_KIND_R8,   11.7030822_SHR_KIND_R8,  &
-         &             11.6018181_SHR_KIND_R8,  -11.2617293_SHR_KIND_R8,  -10.4664199_SHR_KIND_R8,  &
-         &             10.4333970_SHR_KIND_R8,  -10.2377466_SHR_KIND_R8,   10.1934446_SHR_KIND_R8,  &
-         &            -10.1280191_SHR_KIND_R8,   10.0289441_SHR_KIND_R8,  -10.0034259_SHR_KIND_R8/)
-
-    real   (SHR_KIND_R8), parameter :: mvrate(pmvelen) = & ! rates for mvelp sine series
-         &      (/    31.609974_SHR_KIND_R8, 32.620504_SHR_KIND_R8, 24.172203_SHR_KIND_R8,   &
-         &             0.636717_SHR_KIND_R8, 31.983787_SHR_KIND_R8,  3.138886_SHR_KIND_R8,   &
-         &            30.973257_SHR_KIND_R8, 44.828336_SHR_KIND_R8,  0.991874_SHR_KIND_R8,   &
-         &             0.373813_SHR_KIND_R8, 43.668246_SHR_KIND_R8, 32.246691_SHR_KIND_R8,   &
-         &            30.599444_SHR_KIND_R8,  2.147012_SHR_KIND_R8, 10.511172_SHR_KIND_R8,   &
-         &            42.681324_SHR_KIND_R8, 13.650058_SHR_KIND_R8,  0.986922_SHR_KIND_R8,   &
-         &             9.874455_SHR_KIND_R8, 13.013341_SHR_KIND_R8,  0.262904_SHR_KIND_R8,   &
-         &             0.004952_SHR_KIND_R8,  1.142024_SHR_KIND_R8, 63.219948_SHR_KIND_R8,   &
-         &             0.205021_SHR_KIND_R8,  2.151964_SHR_KIND_R8, 64.230478_SHR_KIND_R8,   &
-         &            43.836462_SHR_KIND_R8, 47.439436_SHR_KIND_R8,  1.384343_SHR_KIND_R8,   &
-         &             7.437771_SHR_KIND_R8, 18.829299_SHR_KIND_R8,  9.500642_SHR_KIND_R8,   &
-         &             0.431696_SHR_KIND_R8,  1.160090_SHR_KIND_R8, 55.782177_SHR_KIND_R8,   &
-         &            12.639528_SHR_KIND_R8,  1.155138_SHR_KIND_R8,  0.168216_SHR_KIND_R8,   &
-         &             1.647247_SHR_KIND_R8, 10.884985_SHR_KIND_R8,  5.610937_SHR_KIND_R8,   &
-         &            12.658184_SHR_KIND_R8,  1.010530_SHR_KIND_R8,  1.983748_SHR_KIND_R8,   &
-         &            14.023871_SHR_KIND_R8,  0.560178_SHR_KIND_R8,  1.273434_SHR_KIND_R8,   &
-         &            12.021467_SHR_KIND_R8, 62.583231_SHR_KIND_R8, 63.593761_SHR_KIND_R8,   &
-         &            76.438310_SHR_KIND_R8,  4.280910_SHR_KIND_R8, 13.218362_SHR_KIND_R8,   &
-         &            17.818769_SHR_KIND_R8,  8.359495_SHR_KIND_R8, 56.792707_SHR_KIND_R8,   &
-         &            8.448301_SHR_KIND_R8,  1.978796_SHR_KIND_R8,  8.863925_SHR_KIND_R8,   &
-         &             0.186365_SHR_KIND_R8,  8.996212_SHR_KIND_R8,  6.771027_SHR_KIND_R8,   &
-         &            45.815258_SHR_KIND_R8, 12.002811_SHR_KIND_R8, 75.278220_SHR_KIND_R8,   &
-         &            65.241008_SHR_KIND_R8, 18.870667_SHR_KIND_R8, 22.009553_SHR_KIND_R8,   &
-         &            64.604291_SHR_KIND_R8, 11.498094_SHR_KIND_R8,  0.578834_SHR_KIND_R8,   &
-         &             9.237738_SHR_KIND_R8, 49.747842_SHR_KIND_R8,  2.147012_SHR_KIND_R8,   &
-         &             1.196895_SHR_KIND_R8,  2.133898_SHR_KIND_R8,  0.173168_SHR_KIND_R8/)
-
-    real   (SHR_KIND_R8), parameter :: mvphas(pmvelen) = & ! phases for mvelp sine series
-         &      (/    251.9025_SHR_KIND_R8, 280.8325_SHR_KIND_R8, 128.3057_SHR_KIND_R8,   &
-         &            348.1074_SHR_KIND_R8, 292.7252_SHR_KIND_R8, 165.1686_SHR_KIND_R8,   &
-         &            263.7951_SHR_KIND_R8,  15.3747_SHR_KIND_R8,  58.5749_SHR_KIND_R8,   &
-         &             40.8226_SHR_KIND_R8, 308.4258_SHR_KIND_R8, 240.0099_SHR_KIND_R8,   &
-         &            222.9725_SHR_KIND_R8, 106.5937_SHR_KIND_R8, 114.5182_SHR_KIND_R8,   &
-         &            268.7809_SHR_KIND_R8, 279.6869_SHR_KIND_R8,  39.6448_SHR_KIND_R8,   &
-         &            126.4108_SHR_KIND_R8, 291.5795_SHR_KIND_R8, 307.2848_SHR_KIND_R8,   &
-         &             18.9300_SHR_KIND_R8, 273.7596_SHR_KIND_R8, 143.8050_SHR_KIND_R8,   &
-         &            191.8927_SHR_KIND_R8, 125.5237_SHR_KIND_R8, 172.7351_SHR_KIND_R8,   &
-         &            316.7998_SHR_KIND_R8, 319.6024_SHR_KIND_R8,  69.7526_SHR_KIND_R8,   &
-         &            123.5968_SHR_KIND_R8, 217.6432_SHR_KIND_R8,  85.5882_SHR_KIND_R8,   &
-         &            156.2147_SHR_KIND_R8,  66.9489_SHR_KIND_R8,  20.2082_SHR_KIND_R8,   &
-         &            250.7568_SHR_KIND_R8,  48.0188_SHR_KIND_R8,   8.3739_SHR_KIND_R8,   &
-         &             17.0374_SHR_KIND_R8, 155.3409_SHR_KIND_R8,  94.1709_SHR_KIND_R8,   &
-         &            221.1120_SHR_KIND_R8,  28.9300_SHR_KIND_R8, 117.1498_SHR_KIND_R8,   &
-         &            320.5095_SHR_KIND_R8, 262.3602_SHR_KIND_R8, 336.2148_SHR_KIND_R8,   &
-         &            233.0046_SHR_KIND_R8, 155.6977_SHR_KIND_R8, 184.6277_SHR_KIND_R8,   &
-         &            267.2772_SHR_KIND_R8,  78.9281_SHR_KIND_R8, 123.4722_SHR_KIND_R8,   &
-         &            188.7132_SHR_KIND_R8, 180.1364_SHR_KIND_R8,  49.1382_SHR_KIND_R8,   &
-         &            152.5268_SHR_KIND_R8,  98.2198_SHR_KIND_R8,  97.4808_SHR_KIND_R8,   &
-         &            221.5376_SHR_KIND_R8, 168.2438_SHR_KIND_R8, 161.1199_SHR_KIND_R8,   &
-         &             55.0196_SHR_KIND_R8, 262.6495_SHR_KIND_R8, 200.3284_SHR_KIND_R8,   &
-         &            201.6651_SHR_KIND_R8, 294.6547_SHR_KIND_R8,  99.8233_SHR_KIND_R8,   &
-         &            213.5577_SHR_KIND_R8, 154.1631_SHR_KIND_R8, 232.7153_SHR_KIND_R8,   &
-         &            138.3034_SHR_KIND_R8, 204.6609_SHR_KIND_R8, 106.5938_SHR_KIND_R8,   &
-         &            250.4676_SHR_KIND_R8, 332.3345_SHR_KIND_R8,  27.3039_SHR_KIND_R8/)
-
-    !---------------------------Local variables----------------------------------
-    integer(SHR_KIND_IN) :: i       ! Index for series summations
-    real   (SHR_KIND_R8) :: obsum   ! Obliquity series summation
-    real   (SHR_KIND_R8) :: cossum  ! Cos series summation for eccentricity/fvelp
-    real   (SHR_KIND_R8) :: sinsum  ! Sin series summation for eccentricity/fvelp
-    real   (SHR_KIND_R8) :: fvelp   ! Fixed vernal equinox long of perihelion
-    real   (SHR_KIND_R8) :: mvsum   ! mvelp series summation
-    real   (SHR_KIND_R8) :: beta    ! Intermediate argument for lambm0
-    real   (SHR_KIND_R8) :: years   ! Years to time of interest ( pos <=> future)
-    real   (SHR_KIND_R8) :: eccen2  ! eccentricity squared
-    real   (SHR_KIND_R8) :: eccen3  ! eccentricity cubed
-
-    !-------------------------- Formats -----------------------------------------
-    character(len=*),parameter :: F00 = "('(shr_orb_params) ',4a)"
-    character(len=*),parameter :: F01 = "('(shr_orb_params) ',a,i9)"
-    character(len=*),parameter :: F02 = "('(shr_orb_params) ',a,f6.3)"
-    character(len=*),parameter :: F03 = "('(shr_orb_params) ',a,es14.6)"
-
-    !----------------------------------------------------------------------------
-    ! radinp and algorithms below will need a degree to radian conversion factor
-
-     if ( log_print .and. s_loglev > 0 ) then
-         write(s_logunit,F00) 'Calculate characteristics of the orbit:'
-     end if
-
-    ! Check for flag to use input orbit parameters
-
-    IF ( iyear_AD == SHR_ORB_UNDEF_INT ) THEN
-
-       ! Check input obliq, eccen, and mvelp to ensure reasonable
-
-       if( obliq == SHR_ORB_UNDEF_REAL )then
-           write(s_logunit,F00) trim(subname)//' Have to specify orbital parameters:'
-           write(s_logunit,F00) 'Either set: iyear_AD, OR [obliq, eccen, and mvelp]:'
-           write(s_logunit,F00) 'iyear_AD is the year to simulate orbit for (ie. 1950): '
-           write(s_logunit,F00) 'obliq, eccen, mvelp specify the orbit directly:'
-           write(s_logunit,F00) 'The AMIP II settings (for a 1995 orbit) are: '
-            write(s_logunit,F00) ' obliq =  23.4441'
-            write(s_logunit,F00) ' eccen =   0.016715'
-            write(s_logunit,F00) ' mvelp = 102.7'
-           call shr_sys_abort(subname//' ERROR: unreasonable obliq')
-       else if ( log_print ) then
-           write(s_logunit,F00) 'Use input orbital parameters: '
-       end if
-       if( (obliq < SHR_ORB_OBLIQ_MIN).or.(obliq > SHR_ORB_OBLIQ_MAX) ) then
-           write(s_logunit,F03) 'Input obliquity unreasonable: ', obliq
-          call shr_sys_abort(subname//' ERROR: unreasonable obliq')
-       end if
-       if( (eccen < SHR_ORB_ECCEN_MIN).or.(eccen > SHR_ORB_ECCEN_MAX) ) then
-           write(s_logunit,F03) 'Input eccentricity unreasonable: ', eccen
-          call shr_sys_abort(subname//' ERROR: unreasonable eccen')
-       end if
-       if( (mvelp < SHR_ORB_MVELP_MIN).or.(mvelp > SHR_ORB_MVELP_MAX) ) then
-           write(s_logunit,F03) 'Input mvelp unreasonable: ' , mvelp
-          call shr_sys_abort(subname//' ERROR: unreasonable mvelp')
-       end if
-       eccen2 = eccen*eccen
-       eccen3 = eccen2*eccen
-
-    ELSE  ! Otherwise calculate based on years before present
-
-        if ( log_print .and. s_loglev > 0) then
-            write(s_logunit,F01) 'Calculate orbit for year: ' , iyear_AD
-        end if
-       yb4_1950AD = 1950.0_SHR_KIND_R8 - real(iyear_AD,SHR_KIND_R8)
-       if ( abs(yb4_1950AD) .gt. 1000000.0_SHR_KIND_R8 )then
-           write(s_logunit,F00) 'orbit only valid for years+-1000000'
-           write(s_logunit,F00) 'Relative to 1950 AD'
-           write(s_logunit,F03) '# of years before 1950: ',yb4_1950AD
-           write(s_logunit,F01) 'Year to simulate was  : ',iyear_AD
-          call shr_sys_abort(subname//' ERROR: unreasonable year')
-       end if
-
-       ! The following calculates the earths obliquity, orbital eccentricity
-       ! (and various powers of it) and vernal equinox mean longitude of
-       ! perihelion for years in the past (future = negative of years past),
-       ! using constants (see parameter section) given in the program of:
-       !
-       ! Berger, Andre.  1978  A Simple Algorithm to Compute Long-Term Variations
-       ! of Daily Insolation.  Contribution 18, Institute of Astronomy and
-       ! Geophysics, Universite Catholique de Louvain, Louvain-la-Neuve, Belgium.
-       !
-       ! and formulas given in the paper (where less precise constants are also
-       ! given):
-       !
-       ! Berger, Andre.  1978.  Long-Term Variations of Daily Insolation and
-       ! Quaternary Climatic Changes.  J. of the Atmo. Sci. 35:2362-2367
-       !
-       ! The algorithm is valid only to 1,000,000 years past or hence.
-       ! For a solution valid to 5-10 million years past see the above author.
-       ! Algorithm below is better for years closer to present than is the
-       ! 5-10 million year solution.
-       !
-       ! Years to time of interest must be negative of years before present
-       ! (1950) in formulas that follow.
-
-       years = - yb4_1950AD
-
-       ! In the summations below, cosine or sine arguments, which end up in
-       ! degrees, must be converted to radians via multiplication by degrad.
-       !
-       ! Summation of cosine series for obliquity (epsilon in Berger 1978) in
-       ! degrees. Convert the amplitudes and rates, which are in arc secs, into
-       ! degrees via multiplication by psecdeg (arc seconds to degrees conversion
-       ! factor).  For obliq, first term is Berger 1978 epsilon star; second
-       ! term is series summation in degrees.
-
-       obsum = 0.0_SHR_KIND_R8
-       do i = 1, poblen
-          obsum = obsum + obamp(i)*psecdeg*cos((obrate(i)*psecdeg*years + &
-               &       obphas(i))*degrad)
-       end do
-       obliq = 23.320556_SHR_KIND_R8 + obsum
-
-       ! Summation of cosine and sine series for computation of eccentricity
-       ! (eccen; e in Berger 1978) and fixed vernal equinox longitude of
-       ! perihelion (fvelp; pi in Berger 1978), which is used for computation
-       ! of moving vernal equinox longitude of perihelion.  Convert the rates,
-       ! which are in arc seconds, into degrees via multiplication by psecdeg.
-
-       cossum = 0.0_SHR_KIND_R8
-       do i = 1, pecclen
-          cossum = cossum+ecamp(i)*cos((ecrate(i)*psecdeg*years+ecphas(i))*degrad)
-       end do
-
-       sinsum = 0.0_SHR_KIND_R8
-       do i = 1, pecclen
-          sinsum = sinsum+ecamp(i)*sin((ecrate(i)*psecdeg*years+ecphas(i))*degrad)
-       end do
-
-       ! Use summations to calculate eccentricity
-
-       eccen2 = cossum*cossum + sinsum*sinsum
-       eccen  = sqrt(eccen2)
-       eccen3 = eccen2*eccen
-
-       ! A series of cases for fvelp, which is in radians.
-       if (abs(cossum) .le. 1.0E-8_SHR_KIND_R8) then
-          if (sinsum .eq. 0.0_SHR_KIND_R8) then
-             fvelp = 0.0_SHR_KIND_R8
-          else if (sinsum .lt. 0.0_SHR_KIND_R8) then
-             fvelp = 1.5_SHR_KIND_R8*pi
-          else if (sinsum .gt. 0.0_SHR_KIND_R8) then
-             fvelp = .5_SHR_KIND_R8*pi
-          endif
-       else if (cossum .lt. 0.0_SHR_KIND_R8) then
-          fvelp = atan(sinsum/cossum) + pi
-       else ! cossum > 1.0e-8
-          if (sinsum .lt. 0.0_SHR_KIND_R8) then
-             fvelp = atan(sinsum/cossum) + 2.0_SHR_KIND_R8*pi
-          else
-             fvelp = atan(sinsum/cossum)
-          endif
-       endif
-
-       ! Summation of sin series for computation of moving vernal equinox long
-       ! of perihelion (mvelp; omega bar in Berger 1978) in degrees.  For mvelp,
-       ! first term is fvelp in degrees; second term is Berger 1978 psi bar
-       ! times years and in degrees; third term is Berger 1978 zeta; fourth
-       ! term is series summation in degrees.  Convert the amplitudes and rates,
-       ! which are in arc seconds, into degrees via multiplication by psecdeg.
-       ! Series summation plus second and third terms constitute Berger 1978
-       ! psi, which is the general precession.
-
-       mvsum = 0.0_SHR_KIND_R8
-       do i = 1, pmvelen
-          mvsum = mvsum + mvamp(i)*psecdeg*sin((mvrate(i)*psecdeg*years + &
-               &       mvphas(i))*degrad)
-       end do
-       mvelp = fvelp/degrad + 50.439273_SHR_KIND_R8*psecdeg*years + 3.392506_SHR_KIND_R8 + mvsum
-
-       ! Cases to make sure mvelp is between 0 and 360.
-
-       do while (mvelp .lt. 0.0_SHR_KIND_R8)
-          mvelp = mvelp + 360.0_SHR_KIND_R8
-       end do
-       do while (mvelp .ge. 360.0_SHR_KIND_R8)
-          mvelp = mvelp - 360.0_SHR_KIND_R8
-       end do
-
-    END IF  ! end of test on whether to calculate or use input orbital params
-
-    ! Orbit needs the obliquity in radians
-
-    obliqr = obliq*degrad
-
-    ! 180 degrees must be added to mvelp since observations are made from the
-    ! earth and the sun is considered (wrongly for the algorithm) to go around
-    ! the earth. For a more graphic explanation see Appendix B in:
-    !
-    ! A. Berger, M. Loutre and C. Tricot. 1993.  Insolation and Earth Orbital
-    ! Periods.  J. of Geophysical Research 98:10,341-10,362.
-    !
-    ! Additionally, orbit will need this value in radians. So mvelp becomes
-    ! mvelpp (mvelp plus pi)
-
-    mvelpp = (mvelp + 180._SHR_KIND_R8)*degrad
-
-    ! Set up an argument used several times in lambm0 calculation ahead.
-
-    beta = sqrt(1._SHR_KIND_R8 - eccen2)
-
-    ! The mean longitude at the vernal equinox (lambda m nought in Berger
-    ! 1978; in radians) is calculated from the following formula given in
-    ! Berger 1978.  At the vernal equinox the true longitude (lambda in Berger
-    ! 1978) is 0.
-
-    lambm0 = 2._SHR_KIND_R8*((.5_SHR_KIND_R8*eccen + .125_SHR_KIND_R8*eccen3)*(1._SHR_KIND_R8 + beta)*sin(mvelpp)  &
-         &      - .250_SHR_KIND_R8*eccen2*(.5_SHR_KIND_R8    + beta)*sin(2._SHR_KIND_R8*mvelpp)            &
-         &      + .125_SHR_KIND_R8*eccen3*(1._SHR_KIND_R8/3._SHR_KIND_R8 + beta)*sin(3._SHR_KIND_R8*mvelpp))
-
-    if ( log_print ) then
-        write(s_logunit,F03) '------ Computed Orbital Parameters ------'
-         write(s_logunit,F03) 'Eccentricity      = ',eccen
-         write(s_logunit,F03) 'Obliquity (deg)   = ',obliq
-         write(s_logunit,F03) 'Obliquity (rad)   = ',obliqr
-         write(s_logunit,F03) 'Long of perh(deg) = ',mvelp
-         write(s_logunit,F03) 'Long of perh(rad) = ',mvelpp
-         write(s_logunit,F03) 'Long at v.e.(rad) = ',lambm0
-        write(s_logunit,F03) '-----------------------------------------'
-    end if
-
-  END SUBROUTINE shr_orb_params
-
-  !===============================================================================
-
-  SUBROUTINE shr_orb_decl(calday ,eccen ,mvelpp ,lambm0 ,obliqr ,delta ,eccf)
-    !$acc routine seq
-    !-------------------------------------------------------------------------------
-    !
-    ! Compute earth/orbit parameters using formula suggested by
-    ! Duane Thresher.
-    !
-    !---------------------------Code history----------------------------------------
-    !
-    ! Original version:  Erik Kluzek
-    ! Date:              Oct/1997
-    !
-    !-------------------------------------------------------------------------------
-
-    !------------------------------Arguments--------------------------------
-    real   (SHR_KIND_R8),intent(in)  :: calday ! Calendar day, including fraction
-    real   (SHR_KIND_R8),intent(in)  :: eccen  ! Eccentricity
-    real   (SHR_KIND_R8),intent(in)  :: obliqr ! Earths obliquity in radians
-    real   (SHR_KIND_R8),intent(in)  :: lambm0 ! Mean long of perihelion at the
-    ! vernal equinox (radians)
-    real   (SHR_KIND_R8),intent(in)  :: mvelpp ! moving vernal equinox longitude
-    ! of perihelion plus pi (radians)
-    real   (SHR_KIND_R8),intent(out) :: delta  ! Solar declination angle in rad
-    real   (SHR_KIND_R8),intent(out) :: eccf   ! Earth-sun distance factor (ie. (1/r)**2)
-
-    !---------------------------Local variables-----------------------------
-    real   (SHR_KIND_R8),parameter :: dayspy = 365.0_SHR_KIND_R8  ! days per year
-    real   (SHR_KIND_R8),parameter :: ve     = 80.5_SHR_KIND_R8   ! Calday of vernal equinox
-    ! assumes Jan 1 = calday 1
-
-    real   (SHR_KIND_R8) ::   lambm  ! Lambda m, mean long of perihelion (rad)
-    real   (SHR_KIND_R8) ::   lmm    ! Intermediate argument involving lambm
-    real   (SHR_KIND_R8) ::   lamb   ! Lambda, the earths long of perihelion
-    real   (SHR_KIND_R8) ::   invrho ! Inverse normalized sun/earth distance
-    real   (SHR_KIND_R8) ::   sinl   ! Sine of lmm
-
-    ! Compute eccentricity factor and solar declination using
-    ! day value where a round day (such as 213.0) refers to 0z at
-    ! Greenwich longitude.
-    !
-    ! Use formulas from Berger, Andre 1978: Long-Term Variations of Daily
-    ! Insolation and Quaternary Climatic Changes. J. of the Atmo. Sci.
-    ! 35:2362-2367.
-    !
-    ! To get the earths true longitude (position in orbit; lambda in Berger
-    ! 1978) which is necessary to find the eccentricity factor and declination,
-    ! must first calculate the mean longitude (lambda m in Berger 1978) at
-    ! the present day.  This is done by adding to lambm0 (the mean longitude
-    ! at the vernal equinox, set as March 21 at noon, when lambda=0; in radians)
-    ! an increment (delta lambda m in Berger 1978) that is the number of
-    ! days past or before (a negative increment) the vernal equinox divided by
-    ! the days in a model year times the 2*pi radians in a complete orbit.
-
-    lambm = lambm0 + (calday - ve)*2._SHR_KIND_R8*pi/dayspy
-    lmm   = lambm  - mvelpp
-
-    ! The earths true longitude, in radians, is then found from
-    ! the formula in Berger 1978:
-
-    sinl  = sin(lmm)
-    lamb  = lambm  + eccen*(2._SHR_KIND_R8*sinl + eccen*(1.25_SHR_KIND_R8*sin(2._SHR_KIND_R8*lmm)  &
-         &     + eccen*((13.0_SHR_KIND_R8/12.0_SHR_KIND_R8)*sin(3._SHR_KIND_R8*lmm) - 0.25_SHR_KIND_R8*sinl)))
-
-    ! Using the obliquity, eccentricity, moving vernal equinox longitude of
-    ! perihelion (plus), and earths true longitude, the declination (delta)
-    ! and the normalized earth/sun distance (rho in Berger 1978; actually inverse
-    ! rho will be used), and thus the eccentricity factor (eccf), can be
-    ! calculated from formulas given in Berger 1978.
-
-    invrho = (1._SHR_KIND_R8 + eccen*cos(lamb - mvelpp)) / (1._SHR_KIND_R8 - eccen*eccen)
-
-    ! Set solar declination and eccentricity factor
-
-    delta  = asin(sin(obliqr)*sin(lamb))
-    eccf   = invrho*invrho
-
-    return
-
-  END SUBROUTINE shr_orb_decl
-
-  !===============================================================================
-
-  SUBROUTINE shr_orb_print( iyear_AD, eccen, obliq, mvelp )
-
-    !-------------------------------------------------------------------------------
-    !
-    ! Print out the information on the Earths input orbital characteristics
-    !
-    !---------------------------Code history----------------------------------------
-    !
-    ! Original version:  Erik Kluzek
-    ! Date:              Oct/1997
-    !
-    !-------------------------------------------------------------------------------
-
-    !---------------------------Arguments----------------------------------------
-    integer(SHR_KIND_IN),intent(in) :: iyear_AD ! requested Year (AD)
-    real   (SHR_KIND_R8),intent(in) :: eccen    ! eccentricity (unitless)
-    ! (typically 0 to 0.1)
-    real   (SHR_KIND_R8),intent(in) :: obliq    ! obliquity (-90 to +90 degrees)
-    ! typically 22-26
-    real   (SHR_KIND_R8),intent(in) :: mvelp    ! moving vernal equinox at perhel
-    ! (0 to 360 degrees)
-    !-------------------------- Formats -----------------------------------------
-    character(len=*),parameter :: F00 = "('(shr_orb_print) ',4a)"
-    character(len=*),parameter :: F01 = "('(shr_orb_print) ',a,i9.4)"
-    character(len=*),parameter :: F02 = "('(shr_orb_print) ',a,f6.3)"
-    character(len=*),parameter :: F03 = "('(shr_orb_print) ',a,es14.6)"
-    !----------------------------------------------------------------------------
-
-     if (s_loglev > 0) then
-        if ( iyear_AD .ne. SHR_ORB_UNDEF_INT ) then
-           if ( iyear_AD > 0 ) then
-               write(s_logunit,F01) 'Orbital parameters calculated for year: AD ',iyear_AD
-           else
-               write(s_logunit,F01) 'Orbital parameters calculated for year: BC ',iyear_AD
-           end if
-        else if ( obliq /= SHR_ORB_UNDEF_REAL ) then
-            write(s_logunit,F03) 'Orbital parameters: '
-            write(s_logunit,F03) 'Obliquity (degree):              ', obliq
-            write(s_logunit,F03) 'Eccentricity (unitless):         ', eccen
-            write(s_logunit,F03) 'Long. of moving Perhelion (deg): ', mvelp
-        else
-            write(s_logunit,F03) 'Orbit parameters not set!'
-        end if
-     endif
-
-  END SUBROUTINE shr_orb_print
-  !===============================================================================
-
-END MODULE shr_orb_mod_elm
diff --git a/share/build/buildlib.csm_share b/share/build/buildlib.csm_share
index 69b3c9829f..90a4765c62 100755
--- a/share/build/buildlib.csm_share
+++ b/share/build/buildlib.csm_share
@@ -1,7 +1,4 @@
 #!/usr/bin/env python3
-import os, sys 
-_CIMEROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)),"..","..","cime")
-sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))
 from standard_script_setup import *
 from CIME.utils import copyifnewer, run_bld_cmd_ensure_logging, expect, symlink_force
 from CIME.case import Case
diff --git a/share/build/buildlib.gptl b/share/build/buildlib.gptl
index 4e155d4b57..2f29cf2f0b 100755
--- a/share/build/buildlib.gptl
+++ b/share/build/buildlib.gptl
@@ -1,13 +1,11 @@
 #!/usr/bin/env python3
-import os, sys 
-_CIMEROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)),"..","..","cime")
-sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))
 from standard_script_setup import *
 from CIME.utils import run_bld_cmd_ensure_logging
 from CIME.case import Case
 from CIME.build import get_standard_makefile_args
 
 logger = logging.getLogger(__name__)
+
 def parse_command_line(args, description):
 ###############################################################################
     parser = argparse.ArgumentParser(
@@ -54,7 +52,7 @@ def buildlib(bldroot, installpath, case):
                 install=installpath, comp_interface=comp_interface, stdargs=get_standard_makefile_args(case, shared_lib=True))
 
     gmake_cmd = case.get_value("GMAKE")
-    print("running builib gptl gmake cmd","{} {}".format(gmake_cmd, gmake_opts) )  
+
     # This runs the gptl make command
     cmd = "{} {}".format(gmake_cmd, gmake_opts)
     run_bld_cmd_ensure_logging(cmd, logger)
diff --git a/share/util/shr_flux_mod.F90 b/share/util/shr_flux_mod.F90
index be3e40c5bc..1b06dc255c 100644
--- a/share/util/shr_flux_mod.F90
+++ b/share/util/shr_flux_mod.F90
@@ -2425,7 +2425,6 @@ end subroutine shr_flux_MOstability
 ! except for tau_diff and prev_tau_diff, which can be of either sign.
 subroutine shr_flux_update_stress(wind0, wsresp, tau_est, tau, prev_tau, &
      tau_diff, prev_tau_diff, wind_adj)
-  !$acc routine seq 
   ! Wind speed from atmosphere (not updated by iteration) [m/s]
   real(r8), intent(in) :: wind0
   ! Response of boundary layer wind to stress changes in a time step [m/s/Pa]
